<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>7Rocky</title><link>https://7rocky.github.io/en/</link><description>Recent content on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 22 Oct 2022 00:00:00 +0100</lastBuildDate><atom:link href="https://7rocky.github.io/en/index.xml" rel="self" type="application/rss+xml"/><item><title>Faculty</title><link>https://7rocky.github.io/en/htb/faculty/</link><pubDate>Sat, 22 Oct 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/faculty/</guid><description>Hack The Box. Linux. Medium machine. This machine has a website that is vulnerable to SQLi and autentication bypass which leads to a website where we can export HTML content to PDF. There is a vulnerability where we can attach local files to the PDF file and read a password reused for SSH. Using sudo we can execute a Node.js script as another user and exploit a command injection vulnerability. This second user is allowed to run GDB and moreover GDB has cap_sys_ptrace capability set, so we can debug a process running as root and run arbitrary code</description></item><item><title>OpenSource</title><link>https://7rocky.github.io/en/htb/opensource/</link><pubDate>Sat, 08 Oct 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/opensource/</guid><description>Hack The Box. Linux. Easy machine. This machine has a website exposes its source code, being vulnerable to Directory Path Traversal. Using this vulnerability we can read the necessary files to compute the PIN for the Flask debug console and get Remote Code Execution in a Docker container. After that, we need to use port forwarding to view a Gitea instance and enter credentials found in a Git repository. Here we have the private SSH key so we can enter as a system user. There is a Cron job that commits new changes of a Git repository and leads to privilege escalation</description></item><item><title>Scanned</title><link>https://7rocky.github.io/en/htb/scanned/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/scanned/</guid><description>Hack The Box. Linux. Insane machine. This machine has a website that is able to analyze malware binaries. Analyzing the sandbox C code, we notice that we can use a log file to exfiltrate information through the web server report, and also abuse a misconfiguration to escape from chroot. Then, we can read a SQLite database file and extract a hashed password, which is reused for SSH. Once inside the machine, we are able to run a SUID binary from inside the sandbox and copy a malicious shared library so that the SUID binary runs Bash as root. Deep knowledge about Linux, programming in C and Bash, code audit experience and escaping techniques is needed in order to compromise this machine. This write-up uses a custom Bash script with an embedded C program to list directories and read files from the server and also a Go program to crack a hashed password</description></item><item><title>Noter</title><link>https://7rocky.github.io/en/htb/noter/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/noter/</guid><description>Hack The Box. Linux. Medium machine. This machine has a web application built with Flask to manage notes in Markdown and PDF. We are able to extract the secret key used to sign session cookies and then forge cookies to enumerate users. Once we have a privileged user, we can access the FTP server and analyze the source code of the web application to detect a command injection vulnerability. Then, we can access the machine and find out that MySQL runs as root, which leads to privilege escalation</description></item><item><title>Timelapse</title><link>https://7rocky.github.io/en/htb/timelapse/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/timelapse/</guid><description>Hack The Box. Windows. Easy machine. This machine presents an Active Directory (AD) environment where we can find an encrypted ZIP file in SMB. We can crack the password and find a PFX file holding public and private keys for WinRM. Again we can crack the password and extract the keys to connect to the machine. There is a PowerShell history where we find a password for a LAPS reader member, which will tell us the password for Administrator. Basic Windows exploitation techniques and enumeration are needed in order to compromise this machine</description></item><item><title>Retired</title><link>https://7rocky.github.io/en/htb/retired/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/retired/</guid><description>Hack The Box. Linux. Medium machine. This machine has a PHP website that is vulnerable to Directory Path Traversal. There we find a PHP file that expects a file to be uploaded in order to be passed to a local socket server. We are able to enumerate open processes and download the binary that runs the server and see that it is vulnerable to Buffer Overflow. Once exploited, we can pivot to another user using symbolic links. And then, we are allowed to add custom executable formats, which can be exploited to become root. Solid binary exploitation techniques and Linux concepts are required in order to compromise this machine. This write-up contains some custom Python exploits for the foothold part</description></item><item><title>OverGraph</title><link>https://7rocky.github.io/en/htb/overgraph/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/overgraph/</guid><description>Hack The Box. Linux. Hard machine. This machine contains a website that is vulnerable to Open Redirect, a web application built with AngularJS which is vulnerable to Client-Side Template Injection and XSS, and a GraphQL endpoint. We are able to register a new account bypassing an OTP code using a NoSQLi payload. Then, we can perform a CSRF attack abusing the Open Redirect to inject an XSS payload on the victim&amp;rsquo;s profile in order to get an adminToken stored in localStorage. After that, we are able to upload video files that are processed with ffmpeg, so we can exploit a Server-Side Request Forgery vulnerability to read files from the server. Eventually, we will access as a user to the machine and find a binary that is running as root. Having analyzed the binary, we can obtain a valid token to use the program and exploit a vulnerability to write arbitrary data at an arbitrary address, leading to RCE or write permissions as root</description></item><item><title>Late</title><link>https://7rocky.github.io/en/htb/late/</link><pubDate>Sat, 30 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/late/</guid><description>Hack The Box. Linux. Easy machine. This machine contains a Flask web application that extracts text from images and renders them, being vulnerable to SSTI. Then there is a PAM configured for SSH with relative paths that can be abused because of some privileges to ovewrite executables. Basic web exploitation and Linux enumeration skills are needed in order to compromise this machine</description></item><item><title>Catch</title><link>https://7rocky.github.io/en/htb/catch/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/catch/</guid><description>Hack The Box. Linux. Medium machine. This machine offers an APK file that contains hard-coded authentication tokens for some services exposed by the machine. One of the tokens can be used to enumerate a Let&amp;rsquo;s Chat application using its API and get credentials for Cachet. This service is vulnerable to Server-Side Template Injection in PHP and we can get more credentials to access via SSH. The machine has a Cron job configured to analyze APK files using a Bash script that is vulnerable to command injection, so we need to upload a maliciously crafted APK file to exploit it and become root</description></item><item><title>Acute</title><link>https://7rocky.github.io/en/htb/acute/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/acute/</guid><description>Hack The Box. Windows. Hard machine. This machine exposes a website where we can find a Word document with useful information and some usernames. There is a PowerShell Web Access where we can access using a default credential and extract another password from a screenshot. There is an Active Directory domain controller where we can execute commands as other users. We will be able to connect to the first machine and dump NTLM hashes and finally become domain administrator. Deep knowledge on PowerShell commands and basic Windows and Active Directory exploitation techniques are needed in order to compromise this machine</description></item><item><title>RouterSpace</title><link>https://7rocky.github.io/en/htb/routerspace/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/routerspace/</guid><description>Hack The Box. Linux. Easy machine. This machine has a downloadable APK file with a simple app. This app performs a web request to an API the needs th be captured with a proxy, and this API is vulnerable to a command injection. After that, we can access to the machine via SSH and basic enumeration shows that the version of sudo is vulnerable</description></item><item><title>Undetected</title><link>https://7rocky.github.io/en/htb/undetected/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/undetected/</guid><description>Hack The Box. Linux. Medium machine. This machine has a website in PHP with a third-party dependency that is vulnerable to RCE. The machine has already been compromised and has some backdoors and exploits that need to be detected and analyzed using reverse engineering techniques</description></item><item><title>Paper</title><link>https://7rocky.github.io/en/htb/paper/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/paper/</guid><description>Hack The Box. Linux. Easy machine. This machine contains a Wordpress website that has some secret information hidden in draft posts, and also a chat bot that shows sensitive information. After that, the server happens to be vulnerable to PolKit. Wordpress enumeration is needed to compromise the machine</description></item><item><title>Meta</title><link>https://7rocky.github.io/en/htb/meta/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/meta/</guid><description>Hack The Box. Linux. Medium machine. This machine has a website that analyzes uploaded images with a vulnerable version of exiftool that leads to RCE. Then, there is a Cron job that transforms images using ImageMagick&amp;rsquo;s mogrify command, which is vulnerable to command injection. Finally, we have sudo permissions on neofetch, which leads to privilege escalation</description></item><item><title>Timing</title><link>https://7rocky.github.io/en/htb/timing/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/timing/</guid><description>Hack The Box. Linux. Medium machine. This machine has a PHP web application that is vulnerable to user enumeration, LFI, Type Juggling and SQLi, apart from some other bugs and misconfigurations. After reading the PHP source code, we find a way to upload a PHP web shell and get RCE. After that, we find a password inside a Git repository and access via SSH. Then, we can run a JAR file using sudo that downloads files as root, and we can use a symlink to write an authorized SSH key for root</description></item><item><title>Pandora</title><link>https://7rocky.github.io/en/htb/pandora/</link><pubDate>Sat, 21 May 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/pandora/</guid><description>Hack The Box. Linux. Easy machine. This machine exposes sensitive information through SNMP that allows to access the machine. Then we find a local instance of Pandora FMS that has multiple vulnerabilities and they can be exploited to gain RCE as another user. This user is allowed to run a SUID binary that is vulnerable to PATH hijacking, but the attack needs to be performed with an SSH shell. Basic enumeration and pentesting skills are needed in order to compromise this machine</description></item><item><title>Unicode</title><link>https://7rocky.github.io/en/htb/unicode/</link><pubDate>Sat, 07 May 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/unicode/</guid><description>Hack The Box. Linux. Medium machine. This machine uses JWT tokens with JWKS and JKU that can be forged to arrive to a directory path traversal vulnerability that can be exploited using some Unicode bypassing. After that, there is a Python compiled binary that can be run with sudo and uses curl behind the hoods. Some JWT knowledge, path traversal and command injection bypassing techniques are needed to compromise this machine. This write-up uses a custom Python script to exploit a directory path traversal using JWT with JWKS</description></item><item><title>Backdoor</title><link>https://7rocky.github.io/en/htb/backdoor/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/backdoor/</guid><description>Hack The Box. Linux. Easy machine. This machine contains a Wordpress website that has a plugin vulnerable to Directory Path Traversal, which can be used to enumerate running processes, and then a SUID binary. Wordpress enumeration and experience with file inclusion vulnerabilities is needed to compromise the machine. This write-up uses a custom Python script to read files from the server and a personal public exploit to gain access to the machine</description></item><item><title>Backend</title><link>https://7rocky.github.io/en/htb/backend/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/backend/</guid><description>Hack The Box. Linux. Medium machine. This machine has an API where we can create a new account after some exploration. Then we can find some documentation in Swagger format where we see an endpoint to execute commands and to read files from the server. We must find the secret key used to sign JWT tokens in order to create a valid token to execute commands. Knowledge on JWT tokens and API enumeration are needed to compromise this machine</description></item><item><title>Overflow</title><link>https://7rocky.github.io/en/htb/overflow/</link><pubDate>Sat, 09 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/overflow/</guid><description>Hack The Box. Linux. Hard machine. This machine contains a website that is vulnerable to Padding Oracle Attack and Bit Flipper Attack to login as admin and also vulnerable to SQLi by a CMS. There is another subdomain that runs a version of exiftool that has an RCE vulnerability. Once in the machine, lateral movements are relatively easy and privilege escalation consists of reversing and exploiting a Buffer Overflow vulnerability on a SUID binary. Deep knowledge on web exploitation, cryptography and binary exploitation are needed in order to compromise this machine. This write-up uses a custom Python script to perform a Bit Flipper Attack and a Ruby script to exploit SQLi</description></item><item><title>Shibboleth</title><link>https://7rocky.github.io/en/htb/shibboleth/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/shibboleth/</guid><description>Hack The Box. Linux. Medium machine. This machine has a vulnerable IPMI service where we can find a password that is reused for a Zabbix control panel. Here we can enter and get access to the machine. Next, we find a vulnerable version for MariaDB which leads to RCE as root. Good enumeration and pentesting methodology are needed in order to comprimise this machine</description></item><item><title>Altered</title><link>https://7rocky.github.io/en/htb/altered/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/altered/</guid><description>Hack The Box. Linux. Hard machine. This machine has a PHP website vulnerable to user enumeration. Then we can use brute force on a PIN to reset a password after bypassing rate limits and exploit SQLi and Type Juggling. After that, we see that the Linux kernel is vulnerable to DirtyPipe. Advanced web exploitation techniques are needed in order to compromise this machine. This write-up uses a custom Ruby script to find the valid PIN</description></item><item><title>Secret</title><link>https://7rocky.github.io/en/htb/secret/</link><pubDate>Sat, 26 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/secret/</guid><description>Hack The Box. Linux. Easy Machine. This machine contains an API that uses JWT tokens for authentication. We can download the proyect and discover that it is a Git repository, so that we can see the secret key in previous commits and exploit a command injection vulnerability. There is a SUID binary that reads files as root although it only shows some statistics of the file, but we are able to kill the process and read the coredump. Web exploitation techniques, Git enumeration and knowledge about Linux processes are needed in order to compromise this machine</description></item><item><title>Stacked</title><link>https://7rocky.github.io/en/htb/stacked/</link><pubDate>Sat, 19 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/stacked/</guid><description>Hack The Box. Linux. Insane machine. This machine contains a LocalStack environment that is vulnerable to CSRF and command injection. By discovering an XSS vulnerability in a subdomain, we can use CSRF to exploit the command injection vulnerability and get RCE inside a container. After escalating privileges inside the container by restarting a service and entering a malicious command, we can interact with Docker from the host machine and create a malicious container from scratch that mounts the host file system into the container to get arbitrary file read and write. Web exploitation techniques and deep Docker knowledge is needed in order to compromise this machine</description></item><item><title>Ransom</title><link>https://7rocky.github.io/en/htb/ransom/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/ransom/</guid><description>Hack The Box. Linux. Medium machine. This machine has a Laravel website with a login form that is vulnerable to Type Juggling. After that we find a encrypted ZIP file and we can perform a known plaintext attack to extract the files. The password expected for the login form is reused for the root user. Basic knowledge about web pentesting on PHP and knowledge about ZIP files is required in order to comprimise this machine</description></item><item><title>Devzat</title><link>https://7rocky.github.io/en/htb/devzat/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/devzat/</guid><description>Hack The Box. Linux. Medium machine. This machine contains chat service over SSH and a hidden web subdomain vulnerable to command injection. Then we can access the machine and exploit a vulnerable version of InluxDB to extract the password for another user. This user has permissions to see a development project for the SSH chat that allows to read arbitrary files from the server. Basic web exploitation and Linux enumeration techniques are needed in order to compromise this machine</description></item><item><title>Hancliffe</title><link>https://7rocky.github.io/en/htb/hancliffe/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/hancliffe/</guid><description>Hack The Box. Windows. Hard machine. This machine contains a webpage that hides a Nuxeo Java application vulnerable to SSTI by breaking nginx parser logic. Then we find access the machine and find an application that has a public exploit to access as another user. After that, we extract Firefox credentials and use a password generator to login as another user and find a custom Windows PE. Having reversed the binary to obtain the expected credentials, we find a Buffer Overflow vulnerability that must be exploited via Socket Reuse to access as Administrator</description></item><item><title>Driver</title><link>https://7rocky.github.io/en/htb/driver/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/driver/</guid><description>Hack The Box. Windows. Easy machine. This machine contains a website with default credentials authentication and a file upload. Here we can upload an SCF to capture the user&amp;rsquo;s NTLMv2 hash and crack it. Then we can exploit PrintNightmare. Windows basic exploitation techniques are needed in order to compromise this machine</description></item><item><title>GoodGames</title><link>https://7rocky.github.io/en/htb/goodgames/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/goodgames/</guid><description>Hack The Box. Linux. Easy machine. This machine has website that is vulnerable to SQL injection where we can extract a password to access an internal website that is vulnerable to SSTI. Then, we get access to a Docker container that mounts a directory from the machine, so that we can abuse it to escalate privileges. Basic web exploitation skills and Docker breakout techniques are needed in order to compromise this machine. This write-up uses a custom Python script to compromise the entire machine from scratch</description></item><item><title>Bolt</title><link>https://7rocky.github.io/en/htb/bolt/</link><pubDate>Sat, 19 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/bolt/</guid><description>Hack The Box. Linux. Medium machine. This machine has several virtual hosts and a Docker image that contains a lot of information needed to exploit the websites. There is an SSTI vulnerability between two websites interaction. Then we can extract a PGP private key from Google Chrome cache and decrypt a message. Deep knowledge about Docker and basic web exploitation skills are needed in order to compromise this machine</description></item><item><title>SteamCloud</title><link>https://7rocky.github.io/en/htb/steamcloud/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/steamcloud/</guid><description>Hack The Box. Linux. Easy machine. This machine has a Kubernetes cluster that exposes the kubelet and it is vulnerable to unauthenticated RCE. We are able to extract credentials from a running Pod and use them to create a malicious Pod that mounts the hosts file system. Basic knowledge about pentesting on Kubernetes is needed to compromise this machine</description></item><item><title>Epsilon</title><link>https://7rocky.github.io/en/htb/epsilon/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/epsilon/</guid><description>Hack The Box. Linux. Medium machine. This machine contains a website that exposes Git repository with secrets in old commits. There is a website that needs a valid JWT token in order to exploit an SSTI vulnerability. The secret for the JWT tokens is stored in an AWS Lambda function. Then, there is a Cron job that can be exploited using symlinks to gain arbitrary read. Knowledge about Git, JWT, SSTI and AWS Lambda, as well as Cron job exploitation, is needed to compromise this machine</description></item><item><title>Horizontall</title><link>https://7rocky.github.io/en/htb/horizontall/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/horizontall/</guid><description>Hack The Box. Linux. Easy machine. This machine has a website that hides a valid subdomain that contains a Strapi webapp vulnerable to RCE. There is also an internal Laravel webapp vulnerable to RCE. Some knowledge about JavaScript, PHP and Python, as well as port forwarding techniques, are needed to compromise this machine. This write-up uses a custom script that chains two exploits for Strapi needed to obtain RCE</description></item><item><title>Forge</title><link>https://7rocky.github.io/en/htb/forge/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/forge/</guid><description>Hack The Box. Linux. Medium machine. This machine has a Server-Side Request Forgery (SSRF) vulnerability from a subdomain to an FTP server. After that, there are sudo permissions to run a Python script with a debugger. Basic web pentesting bypassing techniques are needed to compromise this machine. This write-up uses a custom Python script to exploit the SSRF</description></item><item><title>NodeBlog</title><link>https://7rocky.github.io/en/htb/nodeblog/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/nodeblog/</guid><description>Hack The Box. Linux. Easy machine. This machine contains a blog that is vulnerable to NoSQL injection, then to XML External Entity (XXE) injection and finally to insecure deserialization to get Remote Code Execution. Advanced web pentesting techniques and scripting skills are needed in order to compromise this machine. This write-up uses custom scripts in Bash, Python and Node.js to exploit all vulnerabilities</description></item><item><title>Previse</title><link>https://7rocky.github.io/en/htb/previse/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/previse/</guid><description>Hack The Box. Linux. Easy machine. This machine has a webpage vulnerable to command injection after bypassing redirects and managing to register a new account. After that, a hash must be cracked to login as a low privileged user and perform a PATH hijacking using sudo. Common web pentesting and Burp Suite skills, as well as common privilege escalation techniques are needed to compromise the machine. This write-up uses a custom Go program to automate the foothold process</description></item><item><title>Static</title><link>https://7rocky.github.io/en/htb/static/</link><pubDate>Sat, 18 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/static/</guid><description>Hack The Box. Linux. Hard machine. This machine contains a website that exposes a corrupted Gzip file that must be patched to get a TOTP key and download a VPN file. Then there are some PHP vulnerable services that can be compromised and get to an internal server that contains a binary executable file having a Format String vulnerability. Deep knowledge about pivoting and port forwarding techniques, network enumeration and PHP exploitation, as well as Format String exploitation are needed to compromise this machine. This write-up uses a custom Ruby script to automate the process of downloading the VPN file, a Python script gain RCE over a PHP web server and another Python script to exploit a binary using Format String</description></item><item><title>Writer</title><link>https://7rocky.github.io/en/htb/writer/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/writer/</guid><description>Hack The Box. Linux. Medium machine. This machine contains a website that is vulnerable to SQL injection. This allows to read the source code of the server and find a vulnerability. Then some command injection techniques to escalate privileges. Some scripting for automating a SQLi exploit, SMB, SMTP and Cron tasks are needed to compromise the machine. This write-up uses custom Python scripts for SQLi and for the foothold</description></item><item><title>Pikaboo</title><link>https://7rocky.github.io/en/htb/pikaboo/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/pikaboo/</guid><description>Hack The Box. Linux. Hard machine. This machine uses nginx and Apache web servers with a misconfiguration that derives in directory path traversal and afterwards in local file inclusion. There are credentials for FTP in LDAP and a Cron job that is vulnerable to command injection. Web enumeration, knowledge about nginx and LDAP, file inclusion techniques and command injection tricks are needed to compromise this machine. This write-up uses a custom Python script to compromise the entire machine from scratch</description></item><item><title>LogForge</title><link>https://7rocky.github.io/en/htb/logforge/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/logforge/</guid><description>Hack The Box. Linux. Medium machine. This machine uses Log4j in a Tomcat server that is vulnerable to JNDI lookup. Then there is an FTP server made in Java that also uses Log4j, but this time it is only vulnerable to information disclosure. Knowlegde about Log4j exploitation, Tomcat, FTP and Wireshark are needed in order to compromise this machine</description></item><item><title>Intelligence</title><link>https://7rocky.github.io/en/htb/intelligence/</link><pubDate>Sat, 27 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/intelligence/</guid><description>Hack The Box. Windows. Medium machine. This machine presents an Active Directory (AD) environment to perform user enumeration, network poisoning and a Silver Ticket attack. Some scripting, DNS operations, AD attacks and BloodHound basics are needed to compromise this machine. This write-up uses a custom Go script to fuzz for files in a web server</description></item><item><title>Union</title><link>https://7rocky.github.io/en/htb/union/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/union/</guid><description>Hack The Box. Linux. Medium machine. This machine contains Union-based SQL injection (SQLi) and command injection vulnerabilities. Some SQLi bypassing techniques and source code analysis skills are needed to compromise this machine. This write-up uses a custom Java program to automate a SQLi attack</description></item><item><title>BountyHunter</title><link>https://7rocky.github.io/en/htb/bountyhunter/</link><pubDate>Sat, 20 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/bountyhunter/</guid><description>Hack The Box. Linux. Easy machine. This machine has a website that is vulnerable to XML External Entity (XXE) injection and that has sudo permissions configured. Some knowledge about XXE, PHP and Python is needed to compromise this machine. This write-up uses a custom Bash script to read files from the server exploiting XXE</description></item><item><title>Seal</title><link>https://7rocky.github.io/en/htb/seal/</link><pubDate>Sat, 13 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/seal/</guid><description>Hack The Box. Linux. Medium machine. This machine contains a Tomcat website on top of nginx, which has a configuration vulnerability that leads to Remote Code Execution (RCE), then it has some misconfigurations related to file permissions and sudo commands. Knowledge about Tomcat exploitation and Linux file system is needed to compromise this machine</description></item><item><title>Nunchucks</title><link>https://7rocky.github.io/en/htb/nunchucks/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/nunchucks/</guid><description>Hack The Box. Linux. Easy machine. This machine has a webpage vulnerable to Server-Side Template Injection (SSTI) and system capabilities set, but with some protections. Knowledge about Node.js templates and Perl are needed to compromise this machine</description></item><item><title>Explore</title><link>https://7rocky.github.io/en/htb/explore/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/explore/</guid><description>Hack The Box. Android. Easy machine. This is a mobile device that uses a vulnerable application that exposes files that provide access via SSH. Some port scanning, port forwarding and Android skills are needed to compromise this device</description></item><item><title>Spider</title><link>https://7rocky.github.io/en/htb/spider/</link><pubDate>Sat, 23 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/spider/</guid><description>Hack The Box. Linux. Hard machine. This machine contains a website that is vulnerable to Server-Side Template Injection (SSTI) in two fields and SQL injection (SQLi), and an internal website that is vulnerable to XML External Entity (XXE) injection. Advanced knowledge on SSTI and bypassing techniques, SQLi, XXE and port forwarding skills are needed to compromise the machine. This write-up uses a Python script to exploit SSTI and a Bash script to read file using XXE</description></item><item><title>dynstr</title><link>https://7rocky.github.io/en/htb/dynstr/</link><pubDate>Sat, 16 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/dynstr/</guid><description>Hack The Box. Linux. Medium machine. This machine uses a dynamic DNS service vulnerable to command injection and then the machine has sudo permissions for a command that uses a wildard. DNS knowledge, command injection techniques and wildcard abusing skills are needed to compromise this machine</description></item><item><title>Monitors</title><link>https://7rocky.github.io/en/htb/monitors/</link><pubDate>Sat, 09 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/monitors/</guid><description>Hack The Box. Linux. Hard machine. This machine has a Wordpress web site with a plugin vulnerable to Directory Path Traversal, another website vulnerable to SQL injection, and yet another webpage vulnerable to Insecure Deserialization running inside a Docker container with system capabilities enabled. Deep knowledge about web enumeration, vulnerabilities and exploitation techniques, as well as port forwarding and Docker escaping methods are needed to compromise this machine. This write-up uses a custom Bash script to exploit Insecure Deserialization</description></item><item><title>Cap</title><link>https://7rocky.github.io/en/htb/cap/</link><pubDate>Sat, 02 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/cap/</guid><description>Hack The Box. Linux. Easy machine. This machine contains Insecure Direct Object Reference (IDOR) and system capabilities. Reading capture files in Wireshark and capabilities enumeration skills are needed to compromise this machine</description></item><item><title>Antique</title><link>https://7rocky.github.io/en/htb/antique/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/antique/</guid><description>Hack The Box. Linux. Easy machine. This machine is a HP JetDirect printer that exposes its password through SNMP and has an arbritrary file read vulnerability. SNMP enumeration and port forwarding techniques are needed to compromise this machine. This write-up uses a custom Python script to obtain a clear-text password</description></item><item><title>Knife</title><link>https://7rocky.github.io/en/htb/knife/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/knife/</guid><description>Hack The Box. Linux. Easy machine. This machine contains a webpage built on PHP with a version that has a backdoor and sudo permissions configured. Knowledge of the PHP version and basic privilege escalation skills are needed to compromise this machine</description></item><item><title>Rope</title><link>https://7rocky.github.io/en/htb/rope/</link><pubDate>Sat, 23 May 2020 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/rope/</guid><description>Hack The Box. Linux. Insane machine. This machine exposes a custom web server that is vulnerable to Directory Path Traversal so we can read files and discover that it is a binary file. After ananlyzing the binary, we discover that it has a Format String vulnerability that can be exploited to get RCE as john. This user is able to run another binary as user r4j. This binary uses an external library that we can modify because of its permissions and gain access as r4j. Finally, there&amp;rsquo;s another binary that runs a local socket server, we can access the binary and analyze it to find out a Buffer Overflow vulnerability. The binary has all protections set, but it is still exploitable to get RCE as root</description></item><item><title>Forest</title><link>https://7rocky.github.io/en/htb/forest/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/forest/</guid><description>Hack The Box. Windows. Easy machine. This machine presents an Active Directory (AD) environment to perform MS RPC enumeration, AS-REProasting, password decrypting, DCSync and Pass the Hash. Basic AD enumeration and exploitation skills, as well as BloodHound knowledge, are needed to compromise this machine</description></item><item><title>Netmon</title><link>https://7rocky.github.io/en/htb/netmon/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/netmon/</guid><description>Hack The Box. Windows. Easy machine. This machine presents an instance of PRTG Network Monitor which is vulnerable to RCE as system. We can connect to FTP with anonymous credentials and read the backup for a configuration file for PRTG Network Monitor and get an old password, which provides a format to guess the current password. Then we can run the public exploit to get RCE and become Administrator</description></item><item><title>Frolic</title><link>https://7rocky.github.io/en/htb/frolic/</link><pubDate>Sat, 23 Mar 2019 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/frolic/</guid><description>Hack The Box. Linux. Easy machine. This machine has a website that stores some files with different encodings and esoteric languages. In the end, we reach to a PlaySMS instance that is vulnerable to RCE using PHP. The machine has a SUID binary that is vulnerable to Buffer Overflow and leads to privilege escalation</description></item><item><title>Active</title><link>https://7rocky.github.io/en/htb/active/</link><pubDate>Sat, 08 Dec 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/active/</guid><description>Hack The Box. Windows. Easy machine. This machine presents an Active Directory (AD) environment to perform SMB enumeration, password decrypting and Kerberoasting. Basic AD enumeration and exploitation skills are needed to compromise this machine</description></item><item><title>Jerry</title><link>https://7rocky.github.io/en/htb/jerry/</link><pubDate>Sat, 17 Nov 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/jerry/</guid><description>Hack The Box. Windows. Easy machine. This machine exposes a default page with Tomcat. We can access to the manager using default credentials and get Remote Code Execution on the machine as Administrator</description></item><item><title>Mirai</title><link>https://7rocky.github.io/en/htb/mirai/</link><pubDate>Sat, 10 Feb 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/mirai/</guid><description>Hack The Box. Linux. Easy machine. This machine is a Raspberry Pi device that is configured with default credentials, so we can access through SSH and become root because we belong to group sudo. To get the root.txt flag, we need to do a raw copy of a USB stick</description></item><item><title>Blue</title><link>https://7rocky.github.io/en/htb/blue/</link><pubDate>Sat, 13 Jan 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/blue/</guid><description>Hack The Box. Windows. Easy machine. This machine exposes SMB version 1, which is vulnerable to EternalBlue. Once the exploit is done, we get access as Administrator</description></item><item><title>Lame</title><link>https://7rocky.github.io/en/htb/lame/</link><pubDate>Sun, 18 Jun 2017 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/en/htb/lame/</guid><description>Hack The Box. Linux. Easy machine. This machine exposes vulnerable versions for FTP and SMB services. The SMB service is exploitable and derives in RCE as root</description></item><item><title>0ld is g0ld</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/0ld-is-g0ld/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/0ld-is-g0ld/</guid><description>We are given a PDF file called 0ld is g0ld.pdf, but it is protected with a password.
In order to obtain the password, we can use pdf2john to extract a hash and pass it to john to perform a dictionary attack using rockyou.txt:
$ pdf2john 0ld\ is\ g0ld.pdf | tee hash 0ld is g0ld.pdf:$pdf$4*4*128*-1060*1*16*5c8f37d2a45eb64e9dbbf71ca3e86861*32*9cba5cfb1c536f1384bba7458aae3f8100000000000000000000000000000000*32*702cc7ced92b595274b7918dcb6dc74bedef6ef851b4b4b5b8c88732ba4dac0c $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (PDF [MD5 SHA2 RC4/AES 32/64]) Cost 1 (revision) is 4 for all loaded hashes Press 'q' or Ctrl-C to abort, almost any other key for status jumanji69 (0ld is g0ld.</description></item><item><title>5x5 Crypto</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/5x5-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/5x5-crypto/</guid><description>We are given this set of numbers and characters:
1-3,4-4,2-1,3-1,1-5,1-1,4-2,3-3,{,4-4,2-3,4-5,3-2,1-2,4-3,_,4-5,3-5,} And we are told that the encryption method takes a 5x5 grid with all letters of the alphabet in order. If we do a quick search, we will find Polybius Square, which is this one:
A B C D E F G H I/J K L M N O P Q R S T U V W X Y Z We can take every pair of i-j and match it to a letter finding the corresponding row-column cell.</description></item><item><title>A little something to get you started</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/a-little-something-to-get-you-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/a-little-something-to-get-you-started/</guid><description>We have a simple website like this one:
We can read the HTML source code of the website, which is:
There is an image called background.png, but we did not observe any image on the website. We can try to access it using curl:
$ curl http://35.190.155.168/9a968e7787/background.png ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ And we have the flag.</description></item><item><title>aes</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</guid><description>We are given this output:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" It is an output from Python REPL. It takes a random password from rockyou.txt and uses it as the key to encrypt the flag with AES ECB.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</guid><description>We are given a website to analyze. The index file shows the server source code:
#!/usr/bin/env python3 fromflaskimportFlask, render_template_string, request, Response app=Flask(__name__) @app.route('/') defindex(): returnResponse(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') defssti(): query=request.args['query'] iflen(query) &amp;gt;2: return"Too long!" returnrender_template_string(query) app.run('0.0.0.0', 3002, debug=True) It is a website built with Flask, in Python. One interesting thing is that debug mode is enabled.
The challenge talks about SSTI (Server-Side Template Injection), but we can only enter a 2-byte payload.</description></item><item><title>Amidst Us</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</guid><description>We have the following website, that mimics the game Among Us:
There is a button to select a color with a color picker:
If we analyze the given source code, we have a Flask application (in Python). This is application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) The function make_alpha is defined in application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.</description></item><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>We have the Python source code to launch a local instance for the challenge:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Taking a look at the source code, we see that the program expects a number $M$ from us to generate a shared secret.</description></item><item><title>APKrypt</title><link>https://7rocky.github.io/en/ctf/htb-challenges/mobile/apkrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/mobile/apkrypt/</guid><description>We are given an APK file (APKrypt.apk). We need to find a VIP code inside the APK file. Hence, we will use d2j-dex2jar to get a JAR file:
$ d2j-dex2jar APKrypt.apk dex2jar APKrypt.apk - ./APKrypt-dex2jar.jar Now we upload the JAR file into www.javadecompilers.com and select Jadx as decompiler.
The main file is at sources/com/example/apkrypt/MainActivity.java:
packagecom.example.apkrypt; importandroid.app.Activity; importandroid.os.Bundle; importandroid.util.Base64; importandroid.view.View; importandroid.widget.Button; importandroid.widget.EditText; importandroid.widget.Toast; importjava.security.Key; importjava.security.MessageDigest; importjava.security.NoSuchAlgorithmException; importjavax.crypto.Cipher; importjavax.crypto.spec.SecretKeySpec; publicclassMainActivityextendsActivity{ /* renamed from: b1 */ Buttonf77b1; EditTexted1; publicstaticStringdecrypt(Stringstr) throwsException{ KeygenerateKey =generateKey(); Cipherinstance =Cipher.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</guid><description>We are asked to compute -arcsin(-1) * 0.2 (in radians) and take the digits between positions 10000 and 10099 of the decimal part of the result.
First of all, let&amp;rsquo;s do the math:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$
Notice that the inverse sine function is bounded: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Therefore:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$</description></item><item><title>Art</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/art/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/art/</guid><description>We are given a PNG image called art.png:
$ file art.png art.png: PNG image data, 300 x 300, 8-bit/color RGBA, non-interlaced We might think that the flag is somehow encoded in the colors that appear in the image. Actually, after a bit of research, we can find out that there is an esoteric language called npiet that encodes text in images with colors:
The examples look similar to what we have, so let&amp;rsquo;s try it:</description></item><item><title>baby auth</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-auth/</guid><description>We are provided with this webpage:
First, we can register a new account (asdf as username):
And we are told that we are not admin. In fact, the authentication is handled with session cookies:
The session cookie looks encoded in Base64, so let&amp;rsquo;s try to decode it (beware of URL encoding):
$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {"username":"asdf"} It shows our username, so maybe we can modify the cookie and get access as admin:</description></item><item><title>baby BoneChewerCon</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-bonechewercon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-bonechewercon/</guid><description>We are provided with this webpage:
At the bottom of the page we have a text input. Let&amp;rsquo;s enter something and submit.
It shows an error in the Laravel debugger (a PHP framework):
This is a bad practice and a security issue, since debuggers might contain sensitive information and most of them provide ways to execute code.
Flag Indeed, we can find the flag in an environment variable named APP_KEY (HTB{wh3n_th3_d3bugg3r_turns_4g41nst_th3_d3bugg33}):</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</guid><description>We have a Flask web application that allows us to render other websites inside it as an image:
Behind the hoods, the server is launching a Headless Chrome with selenium, accessing the site we provided and taking a screenshot to show it. Here is an example:
The objective is to reach the endpoint /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') However, it is protected by checking that the request is done from 127.</description></item><item><title>Baby Crypt</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-crypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-crypt/</guid><description>We have a binary called baby_crypt:
$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped If we open it in Ghidra, we will see this main function:
intmain() { char*key; longin_FS_OFFSET; inti; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); printf("Give me the key and I\'ll give you the flag: "</description></item><item><title>baby interdimensional internet</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-interdimensional-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-interdimensional-internet/</guid><description>We are provided with this webpage:
If we look into the HTML source code, we see /debug:
And there we can find the source code of the web application:
fromflaskimportFlask, Response, request, render_template, request fromrandomimportchoice, randint fromstringimportlowercase fromfunctoolsimportwraps app=Flask(__name__) defcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass defGCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) deffederation(*args, **kwargs): ingredient=''.join(choice(lowercase) for_inrange(10)) recipe='%s= %s'%(ingredient, ''.join(map(str, [randint(1, 69), choice(['+', '-', '*']), randint(1,69)]))) ifrequest.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>We are provided with this web page:
There is an HTML comment on the index.html that points to a debugging URL (/debug):
In this /debug endpoint, the source code is found:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>Baby RE</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-re/</guid><description>We have a binary called baby:
$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped If we run it, it asks for a key:
$ ./baby Insert key: We can introduce something and see that it is not correct:
$ ./baby Insert key: 1234 Try again later. We can make use of ltrace to see every call to external functions (functions that belong to a library like Glibc):</description></item><item><title>babyreeee</title><link>https://7rocky.github.io/en/ctf/other/babyreeee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/babyreeee/</guid><description>We are given a binary called chall:
$ file chall chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=151528987cd274999ec93665ef2d6a7678c5107b, for GNU/Linux 3.2.0, stripped When we execute, it asks for the flag:
$ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{asdf} Flag wrong. Try again. Let&amp;rsquo;s open the binary in Ghidra to analyze the decompiled C code. This is the main function.</description></item><item><title>Base 2 2 the 6</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/base-2-2-the-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/base-2-2-the-6/</guid><description>We are given this string:
Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K
Since it has numbers, lowercase letters and uppercase letters, it seems to be encoded in Base64.
Actually, the name of the challenge is &amp;ldquo;2 2 the 6&amp;rdquo; (&amp;ldquo;2 to the 6&amp;rdquo;), so $2^6 = 64$.
We can decode it using a shell:
$ echo Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K | base64 -d CTFlearn{FlaggyWaggyRaggy}</description></item><item><title>basic</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</guid><description>We are asked to represent 51 in base 12. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 So the flag is ictf{43}.</description></item><item><title>basic-file-exploit</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/basic-file-exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/basic-file-exploit/</guid><description>We are given the C source code of a program that runs remotely:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define WAIT 60 static const char* flag = "[REDACTED]"; static char data[10][100]; static int input_lengths[10]; static int inputs = 0; int tgetinput(char *input, unsigned int l) { fd_set input_set; struct timeval timeout; int ready_for_reading = 0; int read_bytes = 0; if(l &amp;lt;= 0) { printf("</description></item><item><title>Bat Computer</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/bat-computer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/bat-computer/</guid><description>We are given a 64-bit binary called batcomputer:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Reverse engineering If we use Ghidra, we will see the decompiled source code in C for the main function:
intmain() { intres; intoption; charpassword[16]; charcommand[76]; setup(); while(true) { while(true) { memset(password, 0, 16); printf("Welcome to your BatComputer, Batman. What would you like to do?</description></item><item><title>BBGun06</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/bbgun06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/bbgun06/</guid><description>We are given a Python source code that asks for a signature. This is the main function:
defmain(s): rsa=RSA(2048) user, data=parseEmail() signature=rsa.sign(user) rsa.verify(user, signature) headers=generateHeaders(rsa, signature) valid_email=headers+data sendMessage(s, valid_email+"\n\n") try: forged_signature=recieveMessage(s, "Enter the signature as hex: ") forged_signature=bytes.fromhex(forged_signature) ifnotrsa.verify(user, forged_signature): sendMessage(s, "Invalid signature") ifdifferent(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, "An error occured") The function rsa.verify will do this:
defverify(self, message, signature): keylength=len(long_to_bytes(self.n)) decrypted=self.encrypt(signature) clearsig=decrypted.to_bytes(keylength, "big") r=re.compile(b'\x00\x01\xff+?\x00(.{15})(.{20})', re.DOTALL) m=r.match(clearsig) ifnotm: raiseVerificationError('Verification failed') ifm.</description></item><item><title>BitsNBytes</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/bitsnbytes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/bitsnbytes/</guid><description>We are given two PNG images called intercepted.png and original.png:
$ file intercepted.png intercepted.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced $ file original.png original.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced Both images look the same visually:
But they are different because their MD5 hashes do not coincide:
$ md5sum intercepted.png 88e9b5b97e4a615f1aa26d11dbcdec0d intercepted.png $ md5sum original.png 04e2562c19e680b6493b2a31d65c51e3 original.png Hence, we might think that there is some kind of steganography being used on intercepted.</description></item><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We do not have the source code of the binary, and it is stripped:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Reverse engineering Reversing the binary will be more challenging because we do not have the names of the functions.</description></item><item><title>Blackbox</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/blackbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/blackbox/</guid><description>We are given a server to connect using SSH. There is a binary called blackbox that is SGID:
blackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission As it can be seen, we have no read permission, so we cannot transfer the file to our machine, or decompile it, or debug it.</description></item><item><title>Blacksmith</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/blacksmith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/blacksmith/</guid><description>We are given a 64-bit binary called blacksmith:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments If we open it in Ghidra, we will see this main function:
voidmain() { size_tlength; longin_FS_OFFSET; intanswer; intoption; char*message_1; char*message_2; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setup(); message_1 ="You are worthy to carry this Divine Weapon and bring peace to our homeland!\n"; message_2 ="</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</guid><description>We have a website where we can write Markdown and transform the document to PDF:
By default, we have this Markdown content:
As we have a Node.js project, if we read package.json we can see the versions of the third-party dependencies:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>bloat.py</title><link>https://7rocky.github.io/en/ctf/picoctf/reverse-engineering/bloat.py/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/reverse-engineering/bloat.py/</guid><description>We are given a Python script called bloat.flag.py:
import sys a = "!\"#$%&amp;amp;'()*+,-./0123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"+ \ "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ " def arg133(arg432): if arg432 == a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68]: return True else: print(a[51]+a[71]+a[64]+a[83]+a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+\ a[81]+a[67]+a[94]+a[72]+a[82]+a[94]+a[72]+a[77]+a[66]+a[78]+a[81]+\ a[81]+a[68]+a[66]+a[83]) sys.exit(0) return·False def arg111(arg444): return arg122(arg444.decode(), a[81]+a[64]+a[79]+a[82]+a[66]+a[64]+a[75]+\ a[75]+a[72]+a[78]+a[77]) def arg232(): return input(a[47]+a[75]+a[68]+a[64]+a[82]+a[68]+a[94]+a[68]+a[77]+a[83]+\ a[68]+a[81]+a[94]+a[66]+a[78]+a[81]+a[81]+a[68]+a[66]+a[83]+\ a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+a[81]+a[67]+a[94]+\ a[69]+a[78]+a[81]+a[94]+a[69]+a[75]+a[64]+a[70]+a[25]+a[94]) def arg132(): return open('flag.txt.enc', 'rb').read() def arg112(): print(a[54]+a[68]+a[75]+a[66]+a[78]+a[76]+a[68]+a[94]+a[65]+a[64]+a[66]+\ a[74]+a[13]+a[13]+a[13]+a[94]+a[88]+a[78]+a[84]+a[81]+a[94]+a[69]+\ a[75]+a[64]+a[70]+a[11]+a[94]+a[84]+a[82]+a[68]+a[81]+a[25]) def arg122(arg432, arg423): arg433 = arg423 i = 0 while len(arg433) &amp;lt; len(arg432): arg433 = arg433 + arg423[i] i = (i + 1) % len(arg423) return "</description></item><item><title>Block Hunt3r</title><link>https://7rocky.github.io/en/ctf/htb-challenges/osint/block-hunt3r/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/osint/block-hunt3r/</guid><description>We are told that someone has been uploading images to Görli testnet (an Ethereum Blockchain) between 2020-07-30 and 2020-08-01. We need to find one image that contains the flag.
To interact with Görli we need to go to https://goerli.etherscan.io. We can find the range of block numbers within the dates specified manually going to https://goerli.etherscan.io/blocks/&amp;lt;number&amp;gt;. Poking around with the website, we find that https://goerli.etherscan.io/block/3134050 is the first block of the range and https://goerli.</description></item><item><title>Box</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/box/</guid><description>We are given this Python source code that encrypts the flag:
fromCrypto.Util.numberimportbytes_to_long flag=open("flag.txt", "rb").read().strip() TABLE=[ lambdaa, b: f"({a}+{b})", lambdaa, b: f"({a}-{b})", lambdaa, b: f"({a}*{b})", ] defbuild_box(s: bytes): e="(x)" forbins: e=TABLE[b%len(TABLE)](e, b) returneval(f"lambda x: {e}") box=build_box(flag) ct=box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 """ It is a strange way to encrypt a message. Basically, box is a set of operations that contain a single x, and then calling box with a given value means to substitute that value inside x and get the final result.</description></item><item><title>Brainy's Cipher</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/brainys-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/brainys-cipher/</guid><description>We are given this text file (brainy.txt):
++++++++++[++++++++++++++++++++++++++++++++++++++++++++.-----------.+.-------------.++++++++++++.------------.+++++++++++++.--------------.++++++++++++++++++++++++++. It corresponds to Brainfuck esoteric languages. If we use a tool like www.tutorialspoint.com, we can get the output:
In summary, we have:
p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 $p$ and $q$ seem to be parameters for an RSA cryptosystem, and $c$ must be the ciphertext. However, we need to find out what are $dp$ and $dq$.</description></item><item><title>BruXOR</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/bruxor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/bruxor/</guid><description>We are given this sequence of characters:
TCQ{rveyln'bH_varHuebcrqxetrHOXEj We are told that the encryption type is XOR, but we need to guess the key. For that purpose, we can perform a brute force attack using &amp;ldquo;XOR Brute Force&amp;rdquo; module from CyberChef. If we filter by CTFlearn, we get the key and the flag:
Flag: CTFlearn{y0u_Have_bruteforce_XOR}.</description></item><item><title>Cache Me Outside</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cache-me-outside/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cache-me-outside/</guid><description>We are given a 64-bit binary called heapedit and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit It is configured to use Glibc at the current directory:
$ ldd heapedit linux-vdso.</description></item><item><title>Character Encoding</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/character-encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/character-encoding/</guid><description>We are given these characters:
43 54 46 6C 65 61 72 6E 7B 34 35 43 31 31 5F 31 35 5F 55 35 33 46 55 4C 7D Since they are numbers and letters between A and F, they seem to be ASCII characters in hexadecimal representation.
For instance, 0x43 is the code for C, 0x54 for T and 0x46 for F.
To decode all the characters, we can use the following &amp;ldquo;one-liner&amp;rdquo;:</description></item><item><title>Chase</title><link>https://7rocky.github.io/en/ctf/htb-challenges/forensics/chase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/forensics/chase/</guid><description>We are given a PCAP file with some HTTP messages and TCP segments:
If we filter by HTTP protocol, we will see some requests and responses:
We might think that the cyber criminal found a remote file upload vulnerability and uploaded cmd.aspx and then uploaded nc64.exe to execute commands. Actually, we can see that the cyber criminal got a reverse shell on the Windows host:
At the end of the PCAP capture, we see that the cyber criminal tries to access a file named JBKEE62NIFXF6ODMOUZV6NZTMFGV6URQMNMH2IBA.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>We are given a ciphertext:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Close Enough</title><link>https://7rocky.github.io/en/ctf/other/close-enough/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/close-enough/</guid><description>We are told that some RSA implementation uses a prime number and the next prime number. We are also given the ciphertext:
4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 We got the source code as well:
from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open("key", "w") as f: f.write(key) m = bytes_to_long(flag.</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is call function gets and after that compare a local variable (code) with the value of a global variable (GOAL):
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = "</description></item><item><title>Compressor</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/compressor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/compressor/</guid><description>For this challenge we are only given a remote instance to connect to:
$ nc 157.245.33.77 31001 [*] Directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv Component List: +===============+ | | | 1. Head 🤖 | | 2. Torso 🦴 | | 3. Hands 💪 | | 4. Legs 🦵 | | | +===============+ [*] Choose component: We can choose the first one, for example:
[*] Choose component: 1 [*] Sub-directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv/Head Actions: 1.</description></item><item><title>Cookies</title><link>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/cookies/</guid><description>We are given a website that asks for a cookie:
Looking at the developer tools, we can see that we have a cookie name=-1. If we send snickerdoodle as the placeholder suggests, the cookie will change to name=0:
Let&amp;rsquo;s modify the value of the cookie using curl and show only the message:
$ curl mercury.picoctf.net:27177/check -sH 'Cookie: name=0' | grep -oE '&amp;lt;b&amp;gt;.*?&amp;lt;/b&amp;gt;' &amp;lt;b&amp;gt;I love snickerdoodle cookies!&amp;lt;/b&amp;gt; Now let&amp;rsquo;s use a loop in Bash to see if something change if we use another value as cookie:</description></item><item><title>cos1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 6 decimal places. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 100 decimal places. For this, we can use Wolfram Alpha:
And the flag is:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Cult Meeting</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/cult-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/cult-meeting/</guid><description>We are given a binary called meeting:
$ file meeting meeting: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=72d8b06e4ca750d5c24395d3349c3121b9b95283, for GNU/Linux 3.2.0, not stripped Reverse engineering Using Ghidra, we can read the decompiled source code in C. This is the main function:
intmain() { intret; char*pointer; charinput_data[64]; setvbuf(stdout, NULL, 2, 0); puts("\x1b[3mYou knock on the door and a panel slides back\x1b[0m"); puts(&amp;amp;DAT_00102040); fwrite("</description></item><item><title>CVE-XXXX-XXXX</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</guid><description>We have this challenge statement:
The CVE we&amp;rsquo;re looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.
We are told to search a CVE identifier for the first RCE vulnerability in Windows Print Spooler Service in 2021.</description></item><item><title>Da Vinci</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/da-vinci/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/da-vinci/</guid><description>We are given three JPEG images:
monalisa.jpg: Plans.jpg: Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg: $ file monalisa.jpg monalisa.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 300x300, segment length 16, comment: "CREATOR: gd-jpeg v1.0 (using IJG JPEG v62), quality = 92", comment: "Optimized by JPEGmini 3.9.20.0L Internal 0x8c97c7da", baseline, precision 8, 1280x1936, components 3 $ file Plans.jpg Plans.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 100x100, segment length 16, baseline, precision 8, 800x600, components 3 $ file Thepassword_is_the_small_name_of_the_actor_named_Hanks.</description></item><item><title>Don't Bump Your Head(er)</title><link>https://7rocky.github.io/en/ctf/ctflearn/web/dont-bump-your-header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/web/dont-bump-your-header/</guid><description>We are given a URL to interact with. Let&amp;rsquo;s use curl:
$ curl 165.227.106.113/header.php Sorry, it seems as if your user agent is not correct, in order to access this website. The one you supplied is: curl/7.81.0 &amp;lt;!-- Sup3rS3cr3tAg3nt --&amp;gt; It seems that we need to use a specific user agent (maybe Sup3rS3cr3tAg3nt works):
$ curl 165.227.106.113/header.php -H 'User-Agent: Sup3rS3cr3tAg3nt' Sorry, it seems as if you did not just come from the site, "</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>We are given a Python code to encrypt the flag, and the corresponding out.txt file:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>Emdee five for life</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/emdee-five-for-life/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/emdee-five-for-life/</guid><description>We have this website:
It seems that we need to compute the MD5 hash of the string and submit it:
$ echo -n Vzf9GeB5zAFDZ2M3oKSa | md5sum c03463878fee34e249962c4aef9af84c - But we were too slow&amp;hellip;
Hence we will need to script our solution in order to send the request as quick as possible. One important thing to keep in mind is to preserve the PHPSESSID cookie set by the server:
$ curl -I 134.</description></item><item><title>Encryption Master</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/encryption-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/encryption-master/</guid><description>We are given this text:
This is NOT going to be fun. TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE= We see a large string that is encoded in Base64. If we decode it we get another text:
$ data=TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE= $ echo $data | base64 -d Nice! Now keep going. 54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031 This time it seems like hexadecimal data. Let&amp;rsquo;s decode it again:
$ data=54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031 $ echo $data | xxd -r -p Two more. 1000110 1101001 1101110 1100001 1101100 100000 1000100 1100101 1100011 1110010 1111001 1110000 1110100 1101001 1101111 1101110 100001 100000 1010001 110001 1010010 1000111 1100010 1000111 1010110 1101000 1100011 1101101 110101 110111 1010011 1010110 111001 1000010 1010100 1010110 111001 1010001 1010101 1101011 111001 1010110 1010010 1000110 111001 1010000 1010010 1101100 111001 1011010 1010100 110001 1010110 111001 And now we have binary data.</description></item><item><title>Enhance!</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/enhance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/enhance/</guid><description>We have a file called drawing.flag.svg that has an image in SVG format:
At first glance, we don&amp;rsquo;t see anything, but if we inspect the XML code inside the SVG file, we will see the flag characters:
&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&amp;gt; &amp;lt;!-- Created with Inkscape (http://www.inkscape.org/) --&amp;gt; &amp;lt;svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="210mm" height="297mm" viewBox="0 0 210 297" version="1.1" id="svg8" inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)" sodipodi:docname="drawing.svg"&amp;gt; &amp;lt;defs id="defs2" /&amp;gt; &amp;lt;sodipodi:namedview id="</description></item><item><title>Enormous</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* m=bytes_to_long(open('flag.txt', 'rb').read()) n=1 foriinrange(5): n*=getPrime(2025) e=31 c=pow(m, e, n) print(f'{n= }') print(f'{c= }') And we have the ciphertext $c$ and the modulus $n$ of the RSA implementation. Notice that $e = 31$ is very small and $n$ is very large. Hence, we will be able to perform a 31-root to recover the plaintext $m$, because</description></item><item><title>Entity</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/entity/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we connect to the remote instance, we see this:
$ nc 134.122.106.203 30576 Something strange is coming out of the TV.. (T)ry to turn it off (R)un (C)ry &amp;gt;&amp;gt; Nothing really explanatory&amp;hellip;
Static code analysis This time, we are given the original C source code (chall.</description></item><item><title>Evaluation Deck</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/evaluation-deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/evaluation-deck/</guid><description>We are given this website:
However, the web UI is not that interesting&amp;hellip;
Static code analysis We also have the source code. The web application is built with Flask in Python. The following file is application/blueprints/routes.py:
fromflaskimportBlueprint, render_template, request fromapplication.utilimportresponse web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/get_health', methods=['POST']) defcount(): ifnotrequest.is_json: returnresponse('Invalid JSON!'), 400 data=request.get_json() current_health=data.get('current_health') attack_power=data.get('attack_power') operator=data.get('operator') ifnotcurrent_healthornotattack_powerornotoperator: returnresponse('All fields are required!'), 400 result={} try: code=compile(f'result = {int(current_health)}{operator}{int(attack_power)}', '&amp;lt;string&amp;gt;', 'exec') exec(code, result) returnresponse(result.</description></item><item><title>Exif</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/exif/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/exif/</guid><description>We are told to find the flag in this image:
However, the flag is not visible inside the image and it is not hidden in its content. However, we can find the flag in the file metadata.
We can extract metadata using exiftool:
$ exiftool Computer-Password-Security-Hacker\ -\ Copy.jpg ExifTool Version Number : 12.30 File Name : Computer-Password-Security-Hacker - Copy.jpg Directory : . File Size : 54 KiB File Modification Date/Time : - File Access Date/Time : - File Inode Change Date/Time : - File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/fast-carmichael/</guid><description>We got the Python source code of the server:
fromsecretimportFLAG fromCrypto.Util.numberimportisPrime importsocketserver importsignal classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defgenerate_basis(n): basis=[True] *n foriinrange(3, int(n**0.5) +1, 2): ifbasis[i]: basis[i*i::2*i] =[False] *((n-i*i-1) //(2*i) +1) return[2] +[iforiinrange(3, n, 2) ifbasis[i]] defmillerRabin(n, b): basis=generate_basis(300) ifn==2orn==3: returnTrue ifn%2==0: returnFalse r, s=0, n-1 whiles%2==0: r+=1 s//=2 forbinbasis: x=pow(b, s, n) ifx==1orx==n-1: continue for_inrange(r-1): x=pow(x, 2, n) ifx==n-1: break else: returnFalse returnTrue def_isPrime(p): ifp&amp;lt;1: returnFalse if(p.</description></item><item><title>Fasting</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</guid><description>We are given a host puzzler7.imaginaryctf.org:5005. If we send a GET request using curl, we have this response:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Using ffuf, we discover endpoints docs and redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Both of them are supposed to document API endpoints for people who want to consume the API:</description></item><item><title>Favorite Color</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/favorite-color/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/favorite-color/</guid><description>We are given a server to connect using SSH. There is a 32-bit binary called color that is SGID:
color@ubuntu-512mb-nyc3-01:~$ ls -l total 20 -r--r--r-- 1 root root 714 Sep 12 2017 Makefile -r-xr-sr-x 1 root color_pwn 7672 Sep 12 2017 color -r--r--r-- 1 root root 722 Sep 12 2017 color.c -r--r----- 1 root color_pwn 24 Sep 12 2017 flag.txt color@ubuntu-512mb-nyc3-01:~$ file color color: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Static code analysis We also have the C source code. Basically, what the program does is request two numbers and try to find one that breaks Fermat&amp;rsquo;s Last Theorem.
As a reminder, Fermat&amp;rsquo;s Last Theorem claims that there are no positive integers $a$, $b$, $c$, that satisfy the equation:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>We are given a 32-bit binary called fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments We do not have the C source code. This time, instead of reversing the binary using tools like Ghidra, we will analyze it with GDB.
First let&amp;rsquo;s execute the program:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Find Marher's Secret</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/find-marhers-secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/find-marhers-secret/</guid><description>We are given a some Python source code and a server to connect to:
$ nc 161.35.172.25 32275 Connected to the cyborg's debugging interface Options: 1. Encrypt your text. 2. Claim the key. &amp;gt; Static code analysis This is the relevant part of the code:
defchallenge(req): key=bytes.fromhex(KEY) assert(len(key) ==27) req.sendall(b'Connected to the cyborg\'s debugging interface\n') whileTrue: req.sendall( b'\nOptions:\n1. Encrypt your text.\n2. Claim the key.\n&amp;gt; ') try: response=json.loads(req.recv(4096).decode()) ifresponse['option'] =='encrypt': iv=bytes.</description></item><item><title>Find The Easy Pass</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/find-the-easy-pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/find-the-easy-pass/</guid><description>We have a 32-bit binary called EasyPass.exe which is a Windows PE file:
$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows If we execute the binary in a Windows machine, it will a password:
Since the password is wrong, we will see a message &amp;ldquo;Wrong Password!&amp;rdquo;:
A static code analysis with Ghidra won&amp;rsquo;t be useful. Hence, let&amp;rsquo;s use a debugger like x32dbg to debug the binary.</description></item><item><title>Fleet Management</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/fleet-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/fleet-management/</guid><description>We are given a 64-bit binary called fleet_management:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we open it in Ghidra, we will see this main function:
intmain() { setup(); fprintf(stdout, "%s%sFleet Management System %s\n", &amp;amp;DAT_001023e5, &amp;amp;DAT_001020e9, &amp;amp;DAT_001023e0); fprintf(stdout, "\n%s[*] Loading . . .\n%s", &amp;amp;DAT_001020f1, &amp;amp;DAT_001020e9); sleep(2); menu(); return0; } It calls menu:
voidmenu() { longin_FS_OFFSET; undefined8 uVar1; charlocal_13 [3]; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); memset(local_13, 0, 3); do{ fwrite("</description></item><item><title>fno-stack-protector</title><link>https://7rocky.github.io/en/ctf/other/fno-stack-protector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/fno-stack-protector/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
voidbad_function() { execve("/bin/sh", NULL, NULL); } voidvuln() { chardata[10]; read(0, data, 170); } intmain() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return0; } There exists a Buffer Overflow vulnerability. Notice that data is a character array of 10 bytes, and the program reads up to 170 bytes.</description></item><item><title>Forensics 101</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/forensics-101/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/forensics-101/</guid><description>We are told to find the flag in this image:
However, the flag is not visible inside the image and it is not hidden in its content. However, we can find the flag in the file raw content.
In order to extract printable characters from the image we can use strings and then filter by CTFlearn piping the previous command to grep:
$ strings 95f6edfb66ef42d774a5a34581f19052.jpg | grep CTFlearn CTFlearn{wow!_data_is_cool}</description></item><item><title>Format</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/format/</guid><description>We are given a 64-bit binary called format:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Reverse engineering After executing it, we see that the program only echoes what we enter:
$ ./format asdf asdf fdsa fdsa Using Ghidra, we can reverse engineer the source code and see what the program is doing:
intmain(EVP_PKEY_CTX *param_1) { longcanary; longin_FS_OFFSET; canary =*(long*) (in_FS_OFFSET +0x28); init(param_1); echo(); if(canary !</description></item><item><title>fs0ciety</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/fs0ciety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/fs0ciety/</guid><description>We are given a ZIP file called fsociety.zip:
$ unzip -v fsociety.zip Archive: fsociety.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 729 Defl:N 186 75% 08-15-2017 17:44 e126a116 sshcreds_datacenter.txt -------- ------- --- ------- 729 186 75% 1 file We see that it is password-protected:
$ unzip fsociety.zip Archive: fsociety.zip [fsociety.zip] sshcreds_datacenter.txt password: Hence, we can try to perform a brute force attack using rockyou.</description></item><item><title>Full Stack Conf</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/full-stack-conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/full-stack-conf/</guid><description>We are provided with this webpage:
At the bottom of the page we have a text input:
If we provide some data, we see a message:
However, the website tells us to pop an alert(). This is usually a proof of concept for Cross-Site Scripting (XSS) payloads. One of the simplest payloads for XSS is:
&amp;lt;imgsrc=xonerror=alert(1)&amp;gt; If we use it, we will see the flag in the alert (HTB{p0p..p0p..p0p...alert(1337)}):</description></item><item><title>GET aHEAD</title><link>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/get-ahead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/get-ahead/</guid><description>We are given a website that shows two background colors:
The red button uses a GET request and the blue one uses a POST request. We do not see anything.
Since the challenge name includes HEAD, let&amp;rsquo;s see if we can perform a HEAD request using curl:
$ curl -I mercury.picoctf.net:47967 HTTP/1.1 200 OK flag: picoCTF{r3j3ct_th3_du4l1ty_cca66bd3} Content-type: text/html; charset=UTF-8</description></item><item><title>Git Is Good</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/git-is-good/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/git-is-good/</guid><description>We are given a ZIP archive that contains a flag.txt file:
$ ls flag.txt $ cat flag.txt CTFlearn{REDACTED} But this is not the flag. Looking deeply in the folder, we find a .git directory, so we are into a Git repository (also, the chalenge name pointed this):
$ ls -a . .. .git flag.txt We can use git log to show previous commits (which are like snapshots of the project along time):</description></item><item><title>Glory of the Garden</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/glory-of-the-garden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/glory-of-the-garden/</guid><description>We are given a JPEG image called garden.jpg:
The file is recognized as a proper JPEG image:
$ file garden.jpg garden.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 2999x2249, components 3 However, if we show printable strings inside the file contents, we capture the flag (we can specify the length of the string to output):
$ strings -50 garden.jpg Here is a flag "</description></item><item><title>Gobustme 👻</title><link>https://7rocky.github.io/en/ctf/ctflearn/web/gobustme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/web/gobustme/</guid><description>We have this website:
At the bottom it points the use of gobuster and a dictionary of routes called dirb/common.txt:
As the challenge suggests, let&amp;rsquo;s use gobuster with dirb/common.txt:
$ gobuster dir -u https://gobustme.ctflearn.com -w $WORDLISTS/dirb/common.txt -q -r /call (Status: 200) [Size: 42] /carpet (Status: 200) [Size: 69] /flag (Status: 200) [Size: 15] /hide (Status: 200) [Size: 65] /index.html (Status: 200) [Size: 2712] /sex (Status: 200) [Size: 58] /shadow (Status: 200) [Size: 68] /skin (Status: 200) [Size: 120] Nice, let&amp;rsquo;s go to /flag and get the flag:</description></item><item><title>Gonna-Lift-Them-All</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/gonna-lift-them-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/gonna-lift-them-all/</guid><description>We got the Python source code used to encrypt the flag:
fromCrypto.Util.numberimportbytes_to_long, getPrime importrandom FLAG=b'HTB{??????????????????????????????????????????????????????????????????????}' defgen_params(): p=getPrime(1024) g=random.randint(2, p-2) x=random.randint(2, p-2) h=pow(g, x, p) return(p, g, h), x defencrypt(pubkey): p, g, h=pubkey m=bytes_to_long(FLAG) y=random.randint(2, p-2) s=pow(h, y, p) return(g*y%p, m*s%p) defmain(): pubkey, privkey=gen_params() c1, c2=encrypt(pubkey) withopen('data.txt', 'w') asf: f.write(f'p = {pubkey[0]}\ng = {pubkey[1]}\nh = {pubkey[2]}\n(c1, c2) = ({c1}, {c2})\n') if__name__=="__main__": main() We also have the output of the script:</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>We are given a 64-bit static binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Static code analysis We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Static code analysis We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.</description></item><item><title>Gunship</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</guid><description>We have a website with a nice style:
There is only one user input:
This is a Node.js application that uses pug as a template renderer (as shown in the available files from the challenge).
It also uses flat to parse JSON data, as shown in the following file called routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>H1 Thermostat</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/h1-thermostat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/h1-thermostat/</guid><description>We have an Android APK file called thermostat.apk:
$ file thermostat.apk thermostat.apk: Zip archive data, at least v0.0 to extract, compression method=deflate As it is shown an APK file is just a ZIP archive. Therefore, we can extract its contents:
$ 7z x thermostat.apk Scanning the drive for archives: 1 file, 2595443 bytes (2535 KiB) Extracting archive: thermostat.apk -- Path = thermostat.apk Type = zip Physical Size = 2595443 Everything is Ok Files: 569 Size: 4968479 Compressed: 2595443 $ ls AndroidManifest.</description></item><item><title>Hackerman</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/hackerman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/hackerman/</guid><description>We are given a JPEG image called hackerman.jpg:
$ file hackerman.jpg hackerman.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 960x540, components 3 Since it is a JPEG image, we can think of steganography using steghide. But it does not seem to work for the moment.
If we check the printable strings that are inside the image file, we will see a string that seems to be an MD5 hash (32 hexadecimal digits):</description></item><item><title>Hash the Filesystem</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/hash-the-filesystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/hash-the-filesystem/</guid><description>We are given a Python source code that asks to sign in and offers some functionalities. This is the main function:
defchallenge(req): fnames=initializeDatabase() file_record['admin'] =[fnameforfnameinfnames] req.sendall(b'Super secret file server for malicious operations.\n'+ b'Who are you:\n'+b'&amp;gt; ') user=req.recv(4096).decode().strip() ifuser=='admin': req.sendall( b'Administrator can access the server only via ssh.\nGoodbye!\n') return token=json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] =[] key=os.urandom(16) iv, token_ct=encrypt(key, token.encode()) req.sendall(b'Your token is: '+token_ct.encode() +b'\n') whileTrue: req.sendall( b'1. Upload a file.\n2. Available files.</description></item><item><title>Hello World!</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/hello-world/</guid><description>We are given a 64-bit binary called vulnerable:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments If we execute the binary, it seems that it does nothing:
$ ./vulnerable asdf fdsa 1 2 If we insert data from standard input (stdin), we make the program work:
$ echo asdf | ./vulnerable Hello asdf ! Let&amp;rsquo;s send 100 characters using Python and check if it crashes:</description></item><item><title>Here's a LIBC</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</guid><description>We are given a 64-bit binary called vuln and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln It is configured to use Glibc at the current directory:
$ ldd vuln linux-vdso.</description></item><item><title>Hextraordinary</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/hextraordinary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/hextraordinary/</guid><description>The challenge introduces us to ROXy, a coder that specializes in short cryptic hard to decipher secret codes.
We are given these hexadecimal values and we know that she has done something with them to generate a secret code:
0xc4115 0x4cf8 Actually, the name ROXy is a hint because she is using XOR cipher. If we operate both numbers using XOR, we get the secret code:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; hex(0xc4115 ^ 0x4cf8) '0xc0ded' So the flag is: CTFlearn{0xc0ded}.</description></item><item><title>Highlighter</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/highlighter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/highlighter/</guid><description>We are given a binary called highlighter:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra, we will see the decompiled source code of the main function:
intmain() { int__fd; longin_FS_OFFSET; undefined8 *where; undefined8 what; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setbuf(stdin, (char*) 0x0); setbuf(stdout, (char*) 0x0); __fd =open("flag.txt", 0); read(__fd, flag, 100); puts("Write what?"); __isoc99_scanf("%ld%*c", &amp;amp;what); puts("Where?"); __isoc99_scanf("</description></item><item><title>Highlights</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/highlights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/highlights/</guid><description>We are given a binary called highlights:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra, we will see the decompiled source code of the main function:
intmain() { undefined8 *address; FILE *fp; setbuf(stdout, (char*) 0x0); setbuf(stdin, (char*) 0x0); fp =fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What address (in hex) would you like to read?\n&amp;gt;&amp;gt;&amp;gt; "); __isoc99_scanf("%lx%c", &amp;amp;address, &amp;amp;dead); printf("</description></item><item><title>Hope you know JS</title><link>https://7rocky.github.io/en/ctf/other/hope-you-know-js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hope-you-know-js/</guid><description>We are given an obfuscated JavaScript file called good-luck.js. When running it on a simple HTML document it will show a prompt to validate the flag:
&amp;lt;!doctypehtml&amp;gt; &amp;lt;htmllang="en"&amp;gt; &amp;lt;head&amp;gt; &amp;lt;metacharset="UTF-8"&amp;gt; &amp;lt;title&amp;gt;Hope you know JS&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;scriptsrc="good-luck.js"&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Making use of Visual Studio Code Prettier formatter, I was able to find some patterns that where repeated along the code. For example, I started substituting expressions like +!![] or !</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>We are given a Python code to encrypt the flag (source.py), and we are also given dialog.txt and encrypted_messages.txt:
importos withopen('super_secret_messages.txt', 'r') asf: SUPER_SECRET_MESSAGES=[msg.strip() formsginf.readlines()] defderiveKey(key): derived_key=[] fori, charinenumerate(key): previous_letters=key[:i] new_number=1 forj, previous_charinenumerate(previous_letters): ifprevious_char&amp;gt;char: derived_key[j] +=1 else: new_number+=1 derived_key.append(new_number) returnderived_key deftranspose(array): return[rowforrowinmap(list, zip(*array))] defflatten(array): return"".join([iforsubinarrayforiinsub]) deftwistedColumnarEncrypt(pt, key): derived_key=deriveKey(key) width=len(key) blocks=[pt[i:i+width] foriinrange(0, len(pt), width)] blocks=transpose(blocks) ct=[blocks[derived_key.index(i+1)][::-1] foriinrange(width)] ct=flatten(ct) returnct classPRNG: def__init__(self, seed): self.p=0x2ea250216d705 self.a=self.p self.b=int.from_bytes(os.urandom(16), 'big') self.rn=seed defnext(self): self.rn=((self.a*self.rn) +self.b) %self.p returnself.</description></item><item><title>HTB Console</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/htb-console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/htb-console/</guid><description>We are given a 64-bit binary called htb-console:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Reverse engineering If we use Ghidra, we will see the following main function:
voidmain() { charcommand[16]; setup(); puts("Welcome HTB Console Version 0.1 Beta."); do{ printf("&amp;gt;&amp;gt; "); fgets(command, 16, stdin); console(command); memset(command, 0, 16); } while(true); } The above code only asks for user input and passes the string to console:</description></item><item><title>HyperStream Test #2</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/hyperstream-test-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/hyperstream-test-2/</guid><description>We are given this string with only A and B letters:
ABAAAABABAABBABBAABBAABAAAAAABAAAAAAAABAABBABABBAAAAABBABBABABBAABAABABABBAABBABBAABB The challenge says that it smells like bacon. In fact, there is Bacon Cipher and we can use it to decrypt the string in CyberChef:
So the flag is: CTFlearn{ILOUEBACONDONTYOU}.</description></item><item><title>IMC 1999, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-1999/</guid><description> getProblemPdf('en', '1999', '1')</description></item><item><title>IMC 1999, Problem 7</title><link>https://7rocky.github.io/en/imc/problem-7-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-7-1999/</guid><description> getProblemPdf('en', '1999', '7')</description></item><item><title>IMC 2000, Problem 3</title><link>https://7rocky.github.io/en/imc/problem-3-2000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-3-2000/</guid><description> getProblemPdf('en', '2000', '3')</description></item><item><title>IMC 2004, Problem 7</title><link>https://7rocky.github.io/en/imc/problem-7-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-7-2004/</guid><description> getProblemPdf('en', '2004', '7')</description></item><item><title>IMC 2004, Problem 8</title><link>https://7rocky.github.io/en/imc/problem-8-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-8-2004/</guid><description> getProblemPdf('en', '2004', '8')</description></item><item><title>IMC 2005, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2005/</guid><description> getProblemPdf('en', '2005', '1')</description></item><item><title>IMC 2005, Problem 8</title><link>https://7rocky.github.io/en/imc/problem-8-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-8-2005/</guid><description> getProblemPdf('en', '2005', '8')</description></item><item><title>IMC 2006, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2006/</guid><description> getProblemPdf('en', '2006', '1')</description></item><item><title>IMC 2007, Problem 7</title><link>https://7rocky.github.io/en/imc/problem-7-2007/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-7-2007/</guid><description> getProblemPdf('en', '2007', '7')</description></item><item><title>IMC 2010, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2010/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2010/</guid><description> getProblemPdf('en', '2010', '1')</description></item><item><title>IMC 2012, Problem 2</title><link>https://7rocky.github.io/en/imc/problem-2-2012/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-2-2012/</guid><description> getProblemPdf('en', '2012', '2')</description></item><item><title>IMC 2013, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2013/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2013/</guid><description> getProblemPdf('en', '2013', '1')</description></item><item><title>IMC 2013, Problem 6</title><link>https://7rocky.github.io/en/imc/problem-6-2013/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-6-2013/</guid><description> getProblemPdf('en', '2013', '6')</description></item><item><title>IMC 2017, Problem 6</title><link>https://7rocky.github.io/en/imc/problem-6-2017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-6-2017/</guid><description> getProblemPdf('en', '2017', '6')</description></item><item><title>IMC 2018, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2018/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2018/</guid><description> getProblemPdf('en', '2018', '1')</description></item><item><title>IMC 2019, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2019/</guid><description> getProblemPdf('en', '2019', '1')</description></item><item><title>IMC 2019, Problem 2</title><link>https://7rocky.github.io/en/imc/problem-2-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-2-2019/</guid><description> getProblemPdf('en', '2019', '2')</description></item><item><title>IMC 2019, Problem 5</title><link>https://7rocky.github.io/en/imc/problem-5-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-5-2019/</guid><description> getProblemPdf('en', '2019', '5')</description></item><item><title>IMC 2019, Problem 7</title><link>https://7rocky.github.io/en/imc/problem-7-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-7-2019/</guid><description> getProblemPdf('en', '2019', '7')</description></item><item><title>IMC 2020, Problem 2</title><link>https://7rocky.github.io/en/imc/problem-2-2020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-2-2020/</guid><description> getProblemPdf('en', '2020', '2')</description></item><item><title>IMC 2021, Problem 1</title><link>https://7rocky.github.io/en/imc/problem-1-2021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/imc/problem-1-2021/</guid><description> getProblemPdf('en', '2021', '1')</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/infinite-descent/</guid><description>We are given a Python with a weird RSA implementation (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Doneighbouring primes present a security risk?</description></item><item><title>information</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/information/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/information/</guid><description>We are given a JPEG image called cat.jpg:
The file is recognized as a proper JPEG image:
$ file cat.jpg cat.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 2560x1598, components 3 However, if we extract the file metadata, we will see something strange:
$ exiftool cat.jpg ExifTool Version Number : 12.30 File Name : cat.jpg Directory : . File Size : 858 KiB File Modification Date/Time : File Access Date/Time : File Inode Change Date/Time : File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.</description></item><item><title>Insane Bolt</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/insane-bolt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/insane-bolt/</guid><description>We have this game:
$ nc 206.189.125.243 30182 1. Instructions 2. Play &amp;gt; 1 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 [*] Help the 🤖 reach the 💎. 🔩 🔩 [*] You need to find the shortest route. 🔩 🔩 [*] You need to collect 500 💎 and at least 5000 🔩.</description></item><item><title>Insp3ct0r</title><link>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/insp3ct0r/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/insp3ct0r/</guid><description>We are given a website like this:
As the page suggests, we must inspect the HTML code of the website (shortcut: Ctrl + U):
We can see a piece of the flag. Let&amp;rsquo;s inspect the CSS file (mycss.css):
Alright, we got another piece. We can take a look at the JS file (myjs.js):
Perfect, we can join all pieces to form the flag: picoCTF{tru3_d3t3ct1ve_0r_ju5t_lucky?f10be399}.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</guid><description>We are given a PHP web application with a single functionality, that is to post an email address.
We can start by analyzing the source code. The file index.php shows that there are only two endpoints (GET and POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); We can see that Database.</description></item><item><title>Jeeves</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/jeeves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/jeeves/</guid><description>We are given a 64-bit binary called jeeves:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled We can use Ghidra to analyze the binary and look at the decompiled source code in C. This is main:
intmain() { charname[44]; intfd; void*data; uintcode; code =0xdeadc0d3; printf("Hello, good sir!\nMay I have your name? "); gets(name); printf("Hello %s, hope you have a good day!\n", name); if(code ==0x1337bab3) { data =malloc(0x100); fd =open("</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>We are given this Python source code:
fromhashlibimportsha256 fromCrypto.Util.Paddingimportpad, unpad importsignal importsubprocess importsocketserver importos allowed_commands=[b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE=32 defencrypt_block(block, secret): enc_block=b'' foriinrange(BLOCK_SIZE): val=(block[i]+secret[i]) %256 enc_block+=bytes([val]) returnenc_block defencrypt(msg, password): h=sha256(password).digest() iflen(msg) %BLOCK_SIZE!=0: msg=pad(msg, BLOCK_SIZE) blocks=[msg[i:i+BLOCK_SIZE] foriinrange(0, len(msg), BLOCK_SIZE)] ct=b'' forblockinblocks: enc_block=encrypt_block(block, h) h=sha256(enc_block+block).digest() ct+=enc_block returnct.hex() defrun_command(cmd): ifcmdinallowed_commands: try: resp=subprocess.run( cmd.decode().split(' '), capture_output=True) output=resp.stdout returnoutput except: returnb'Something went wrong!\n' else: returnb'Invalid command!\n' defchallenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.</description></item><item><title>Lazy Game Challenge</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/lazy-game-challenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/lazy-game-challenge/</guid><description>We are given a service that consists of a betting system. We bet a certain amount of money and we need to guess a number between 1 and 10 in less than 10 attempts. For example:
$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of !</description></item><item><title>Leet Test</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/leet-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/leet-test/</guid><description>We are given a 64-bit binary called leet_test:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If we open it in Ghidra, we find this decompiled source code in C:
uintwinner =0xcafebabe; voidmain() { longin_FS_OFFSET; uintrandom; inturandom_fd; intflag_fd; void*flag; charname[280]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); initialize(); urandom_fd =open("/dev/urandom", 0); read(urandom_fd, &amp;amp;random, 4); close(urandom_fd); random =random &amp;amp;0xffff; while(true) { printf("Welcome to HTB!\nPlease enter your name: "</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</guid><description>We are provided with this webpage:
It shows a directory listing. If we go to /mailer.php we will have this website to send emails:
The mailer.zip file contains the mailer.php source code. It is quite large to insert it here.
The key thing is that it uses PHPMailer, which is vulnerable to CVE-2016-10033 and CVE-2016-10045. In fact, there are public exploits like the one in www.exploit-db.com.
Basically, the exploit says to enter this payload as the email:</description></item><item><title>Login Please</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</guid><description>We are supposed to log in here: http://puzzler7.imaginaryctf.org:5001/:
If we inspect the HTML code, we will see a comment that points to /source:
So we have the source code used by the server:
constexpress=require('express') constcrypto=require('crypto') functionmd5(text) { returncrypto.createHash('md5').update(text).digest('hex') } constapp=express() constusers={ guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } constlocalIPs=['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false})) app.use(express.json()) app.get('/', (req, res) =&amp;gt;{ res.send(` &amp;lt;form action="https://7rocky.github.io/login" method="POST"&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="username"&amp;gt;Username: &amp;lt;/label&amp;gt; &amp;lt;input name="username" type="text" id="</description></item><item><title>Lookey here</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/lookey-here/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/lookey-here/</guid><description>We are given a large text file called anthem.flag.txt:
$ wc -l anthem.flag.txt 2146 anthem.flag.txt 2146 are a lot to search the flag by hand. Instead, we can use grep to find the flag given that they have a special format format (picoCTF{...}):
$ grep picoCTF anthem.flag.txt we think that the men of picoCTF{gr3p_15_@w3s0m3_4c479940}</description></item><item><title>looking glass</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/looking-glass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/looking-glass/</guid><description>We are provided with this webpage:
There is a feature to use ping command:
The problem might be related to command injection, because probably the server does something like this:
&amp;lt;?php $cmd ='ping -c 4 '.$_POST['ip_address']; system($cmd); Maybe not in PHP, but the concept is the same. Hence, we can try and add a semicolon to inject another system command (; id):
There it is, the server is vulnerable to command injection, which derives in Remote Code Execution (RCE).</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</guid><description>We have a ZIP file called flag.zip that contains a JPEG image and also a .DS_Store file, which is a temporary file for macOS machines:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>Maze</title><link>https://7rocky.github.io/en/ctf/overthewire/maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/overthewire/maze/</guid><description>This is a lab to practice some exploitation techniques, programming and reverse engineering. The lab consists of 9 levels, using a Linux/x86 architecture (all protections are disabled: NX, PIE, canaries, and even ASLR).
To connect to the first level, we are provided with the SSH credentials for maze0.
The initial recognition of the machine tells us that we have some SUID binaries that will be exploited to pass to the next level.</description></item><item><title>Micro-CMS v1</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/micro-cms-v1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/micro-cms-v1/</guid><description>We have a simple website that allows us to edit and create posts using Markdown:
Let&amp;rsquo;s click on &amp;ldquo;Testing&amp;rdquo;:
Now, we can try to edit the current post. A text area is shown in order to write Markdown code:
Markdown is a markup language similar to HTML but simpler and easier. Furthermore, Markdown supports the use of HTML tags as well. Hence, let&amp;rsquo;s try a Cross-Site Scripting (XSS) payload like:</description></item><item><title>Milkshake</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/milkshake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/milkshake/</guid><description>We are given an MP3 file called Milkshake.mp3. We can take a look at the printable strings or metadata:
$ file Milkshake.mp3 Milkshake.mp3: Audio file with ID3 version 2.4.0, extended header, contains:MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo $ strings -20 Milkshake.mp3 The Neptunes Present-Clones-ADTRCK 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CCOMM 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CTPE1 Chad Hugo/Pharrell Williams !</description></item><item><title>mixup</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</guid><description>We are given a flag.txt file that contains some Unicode characters. This is the hexdump of the file:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Mod 26</title><link>https://7rocky.github.io/en/ctf/picoctf/cryptography/mod-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/cryptography/mod-26/</guid><description>We are given a ciphertext:
cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_GYpXOHqX} We see that the message has more or less the format of a picoCTF flag (picoCTF{...}), due to the fact that there are 4 lowercase and 3 uppercase letters before {, and ends with }. Moreover, there are several _.
It seems clear that the encryption is based on a substitution algorithm (Caesar cipher). The most common algorithm is ROT13. Using CyberChef, we can decrypt the message using ROT13 and read the flag:</description></item><item><title>Model E1337 - Rolling Code Lock</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/model-e1337-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/model-e1337-rolling-code-lock/</guid><description>We have a simple website that requests a code to unlock:
We can put any number we want, and after a few seconds, we see it is incorrect:
There is nothing in the source code of the website. At this point, we can apply fuzzing to enumerate more routes if they exist:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://35.190.155.168/c33a5d03b6/FUZZ admin [Status: 200, Size: 287, Words: 25, Lines: 11] unlock [Status: 405, Size: 178, Words: 20, Lines: 5] [Status: 200, Size: 302, Words: 16, Lines: 13] There is an /admin route:</description></item><item><title>Model E1337 v2 - Hardened Rolling Code Lock</title><link>https://7rocky.github.io/en/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</guid><description>This challenge is extremely related to Model E1337 - Rolling Code Lock, specially for the cryptanalysis part. Go and check it if you have not done yet.
As in the previous challenge, we have a simple website that requests a code to unlock:
We can put any number we want and we see it is incorrect:
The difference with the first challenge is the length of the number, this time it is 64-bit long.</description></item><item><title>Morse Code</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/morse-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/morse-code/</guid><description>We are given this sequence of . and -:
-.-. - ..-. .-.. . .- .-. -. ... .- -- ..- . .-.. -- --- .-. ... . .. ... -.-. --- --- .-.. -... -.-- - .... . .-- .- -.-- .. .-.. .. -.- . -.-. .... . . ... As the title of the challenge suggests, it is Morse code. Hence, we must decode the sequence.</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</guid><description>We are given a website like this:
We must register a new account and login to view a nice dashboard:
The only functionality we have is to export the SVG images we see as PNG files. We can capture the request with Burp Suite:
After some research, we can see that there is a vulnerability regarding SVG conversion that leads to Local File Read (more information at security.snyk.io).
We will need to use the following payload to read /etc/passwd as a PNG image:</description></item><item><title>Nice netcat...</title><link>https://7rocky.github.io/en/ctf/picoctf/general-skills/nice-netcat.../</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/general-skills/nice-netcat.../</guid><description>We are given host and a port for a remote instance. If we stablish a connection using nc we get a bunch of numbers:
$ nc mercury.picoctf.net 22902 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 ^C These numbers seem to be the ASCII decimal representation of some characters.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</guid><description>We are given a 64-bit binary called notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
voidmain() { setbuf(stdout, (char*) 0x0); do{ notepad(); } while(true); } Basically, it runs notepad infinitely:
voidnotepad() { longin_FS_OFFSET; charoption; inti; undefined notes[136]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); for(i =0; i &amp;lt;128; i =i +1) { notes[i] =0; } puts("</description></item><item><title>Obedient Cat</title><link>https://7rocky.github.io/en/ctf/picoctf/general-skills/obedient-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/general-skills/obedient-cat/</guid><description>We are given a file. The flag is contained inside the file:
$ cat flag picoCTF{s4n1ty_v3r1f13d_28e8376d}</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/one-step-closer/</guid><description>We are given a Python code to encrypt the flag, and a Flask application that calls the encryption function:
fromCrypto.Util.numberimportlong_to_bytes, bytes_to_long, getPrime, inverse importrandom FLAG=b'HTB{--REDACTED--}' p=getPrime(1024) q=getPrime(1024) n=p*q e=257 defencrypt_flag(): a=random.getrandbits(1024) b=random.getrandbits(1024) flag=bytes_to_long(FLAG) msg=a*flag+b ct=pow(msg, e, n) return{'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} fromflaskimport* fromchallimportencrypt_flag app=Flask(__name__) @app.route('/', methods=['GET']) defindex(): returnrender_template('index.html') @app.route('/api/get_flag', methods=['GET']) defget_flag(): payload=encrypt_flag() returnjsonify(payload) if__name__=='__main__': app.run(host='0.0.0.0', port=1337) We can express the above RSA computations in mathematical terms (let $F$ be the flag in decimal format):</description></item><item><title>Personalized</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* fromrandomimportseed, getrandbits m=bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name=open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e=2*getrandbits(32)+1 p=getPrime(512) q=getPrime(512) n=p*q c=pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) foriinname)}!") print(f'{n= }') print(f'{e= }') print(f'{c= }') It uses a RSA implementation where we can provide a name that will be used as the seed for a Pseudo-Random Number Generator (PRNG). And then the public exponent $e$ is computed as 2 * getrandbits(32) + 1.</description></item><item><title>Pickle</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</guid><description>We are given a file called out.pickle. The flag is stored inside, we can visualize its contents in hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>PIN</title><link>https://7rocky.github.io/en/ctf/ctflearn/reverse-engineering/pin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/reverse-engineering/pin/</guid><description>We are given a binary called rev1:
$ file rev1 rev1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5f9af621b132c2028d8e689cbb5b707f3f3cd28, not stripped If we run it, the program expects for a PIN:
$ ./rev1 Masukan PIN = 1234 PIN salah ! Let&amp;rsquo;s debug it with GDB and disassemble main:
$ gdb -q rev1 Reading symbols from rev1... (No debugging symbols found in rev1) gef➤ disassemble main Dump of assembler code for function main: 0x00000000004005d6 &amp;lt;+0&amp;gt;: push rbp 0x00000000004005d7 &amp;lt;+1&amp;gt;: mov rbp,rsp 0x00000000004005da &amp;lt;+4&amp;gt;: sub rsp,0x10 0x00000000004005de &amp;lt;+8&amp;gt;: lea rdi,[rip+0xdf] # 0x4006c4 0x00000000004005e5 &amp;lt;+15&amp;gt;: mov eax,0x0 0x00000000004005ea &amp;lt;+20&amp;gt;: call 0x4004a0 &amp;lt;printf@plt&amp;gt; 0x00000000004005ef &amp;lt;+25&amp;gt;: lea rax,[rbp-0x4] 0x00000000004005f3 &amp;lt;+29&amp;gt;: mov rsi,rax 0x00000000004005f6 &amp;lt;+32&amp;gt;: lea rdi,[rip+0xd6] # 0x4006d3 0x00000000004005fd &amp;lt;+39&amp;gt;: mov eax,0x0 0x0000000000400602 &amp;lt;+44&amp;gt;: call 0x4004b0 &amp;lt;__isoc99_scanf@plt&amp;gt; 0x0000000000400607 &amp;lt;+49&amp;gt;: mov eax,DWORD PTR [rbp-0x4] 0x000000000040060a &amp;lt;+52&amp;gt;: mov edi,eax 0x000000000040060c &amp;lt;+54&amp;gt;: call 0x4005b6 &amp;lt;cek&amp;gt; 0x0000000000400611 &amp;lt;+59&amp;gt;: test eax,eax 0x0000000000400613 &amp;lt;+61&amp;gt;: je 0x400623 &amp;lt;main+77&amp;gt; 0x0000000000400615 &amp;lt;+63&amp;gt;: lea rdi,[rip+0xba] # 0x4006d6 0x000000000040061c &amp;lt;+70&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x0000000000400621 &amp;lt;+75&amp;gt;: jmp 0x40062f &amp;lt;main+89&amp;gt; 0x0000000000400623 &amp;lt;+77&amp;gt;: lea rdi,[rip+0xba] # 0x4006e4 0x000000000040062a &amp;lt;+84&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x000000000040062f &amp;lt;+89&amp;gt;: mov eax,0x0 0x0000000000400634 &amp;lt;+94&amp;gt;: leave 0x0000000000400635 &amp;lt;+95&amp;gt;: ret End of assembler dump.</description></item><item><title>Poor Login</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/poor-login/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/poor-login/</guid><description>We are given a 64-bit binary called login:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled We also have the C source code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int menu() { printf("*** WINBLOWS LOGIN *********\n" "1. Login into user.\n" "2. Sign out.\n" "3. Print flag.\n" "4. Lock user.\n" "5. Restore user.\n" "&amp;gt; "); int resp = 0; scanf("%d", &amp;amp;resp); while (getchar() != '\n'); return resp; } struct creds { void *padding; char name[32]; int admin; }; struct creds *curr; struct creds *save; char *fake_flag; int main() { char buff[64]; setbuf(stdout, NULL); setbuf(stdin, NULL); while (1) { switch (menu()) { case 1: // Login curr = malloc(sizeof(*curr)); printf("</description></item><item><title>POST Practice</title><link>https://7rocky.github.io/en/ctf/ctflearn/web/post-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/web/post-practice/</guid><description>We are told to authenticate on a given URL using a POST request.
First of all, let&amp;rsquo;s make a GET request to check if we can have the credentials, using curl:
$ curl http://165.227.106.113/post.php &amp;lt;h1%gt;This site takes POST data that you have not submitted!&amp;lt;/h1&amp;gt;&amp;lt;!-- username: admin | password: 71urlkufpsdnlkadsf --&amp;gt; And there we have it. Now we only need to use a POST request with this information. Using -d on curl to enter the request body sets the request method to POST by default, so there is no need to specify -X POST:</description></item><item><title>pqqp</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</guid><description>We are given this Python source code that encrypts the flag:
fromCrypto.Util.numberimport* p=getPrime(1024) q=getPrime(1024) n=p*q e=65537 m=bytes_to_long(open("flag.txt", "rb").read().strip()) c=pow(m, e, n) pqqp=(pow(p, q, n) +pow(q, p, n)) %n print(f"{n= }") print(f"{e= }") print(f"{c= }") print(f"{pqqp= }") And we have the output.txt file:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 First of all, we need to express $p^q + q^p \pmod{n}$ in another way.</description></item><item><title>Practice Flag</title><link>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/practice-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/practice-flag/</guid><description>This challenge is only an introduction. It shows the flag directly: CTFlearn{4m_1_4_r3al_h4ck3r_y3t}.</description></item><item><title>Pumpkin Stand</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/pumpkin-stand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/pumpkin-stand/</guid><description>We are given a 64-bit binary called pumpkin_stand:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Reverse engineering If we load the binary in Ghidra, we will see this decompiled C code for main:
voidmain() { longin_FS_OFFSET; shortoption; shortamount; FILE *fp; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); setup(); banner(); option =0; amount =0; while(true) { while(true) { while(true) { while(true) { menu(); __isoc99_scanf("</description></item><item><title>Pusheen Loves Graphs</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/pusheen-loves-graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/pusheen-loves-graphs/</guid><description>We are given a binary file called Pusheen. It we execute it, we will see a picture of a cat:
$ ./Pusheen ▐▀▄ ▄▀▌ ▄▄▄▄▄▄▄ ▌▒▒▀▄▄▄▄▀▒▒▐▄▀▀▒██▒██▒▀▀▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▄▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▀█▒▒█▌▒▒█▒▒▐█▒▒▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▀▌▒▒▒▒▒▀▒▀▒▒▒▒▒▀▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▄▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌▄█▒█ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▒█▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▌ ▀▄▄▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀ If we check the printable strings inside the file, there are a lot that start with e_ (actually, they run from e_0_0 to e_66_100). We can count them like this:</description></item><item><title>QR Code</title><link>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/qr-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/qr-code/</guid><description>We are given an image containing a QR code:
If we scan it, we will get this string:
c3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI= It seems to be encoded in Base64, let&amp;rsquo;s try to decode it:
$ echo c3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI= | base64 -d synt vf : a0_obql_s0etrg_de_pbqr But we don&amp;rsquo;t see anything readable. There seems to be a substitution algorithm such as ROT13. Let&amp;rsquo;s go to CyberChef and check it out:
We see: &amp;ldquo;flag is : n0_body_f0rget_qr_code&amp;rdquo;, so the flag is: CTFlearn{n0_body_f0rget_qr_code}.</description></item><item><title>Rebuilding</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/rebuilding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/rebuilding/</guid><description>We have a binary called rebuilding:
$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped If we run it, it requires to use a command line argument:
$ ./rebuilding Preparing secret keys Missing required argument Let&amp;rsquo;s open it in Ghidra and decompile it. This is the main function:
undefined8 main(intargc, longargv) { int__c; size_tlength; undefined8 ret; intchecks; inti; intj; if(argc !</description></item><item><title>Red Island</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</guid><description>We are given a website like this:
We can register a new account and then login to see this functionality:
This time we don&amp;rsquo;t have the source code for the web application, so we must find a clear vulnerability or get the source code somehow.
We can start thinking of Server-Side Request Forgery (SSRF). As in other challenges, we know that the web server listens on port 1337, so let&amp;rsquo;s try and get http://127.</description></item><item><title>Redaction gone wrong</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/redaction-gone-wrong/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/redaction-gone-wrong/</guid><description>We are given a PDF file called Financial_Report_for_ABC_Labs.pdf. It shows some text:
But there are some words that where hidden using a kind of black &amp;ldquo;background color&amp;rdquo;. However, we can still select the whole text using the mouse, and there is the flag:
Financial Report for ABC Labs, Kigali, Rwanda for the year 2021. Breakdown - Just painted over in MS word. Cost Benefit Analysis Credit Debit This is not the flag, keep looking Expenses from the picoCTF{C4n_Y0u_S33_m3_fully} Redacted document.</description></item><item><title>Reflection</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</guid><description>We are given a binary file called reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped If we open Ghidra and take a look at the decompiled C source code, we will see the main function:
undefined8 main() { longj; char*__format; byte flag_input[100]; intk; int_j; int_length; inti; intlength; printf("&amp;gt;&amp;gt;&amp;gt; "); fgets((char*) flag_input, 100, stdin); _length =0; _j =0; k =0; while(true) { length =_length; i =_j; j =(long)_j; _j =_j +1; if((flag[j] ^flag_input[i]) !</description></item><item><title>Reg</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/reg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/reg/</guid><description>We are given a 64-bit binary called reg:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We can use Ghidra to analyze the binary and look at the decompiled source code in C. This is main:
intmain() { run(); return0; } Let&amp;rsquo;s see run:
voidrun() { charlocal_38[48]; initialize(); printf("Enter your name : "); gets(local_38); puts("Registered!"); return; } The binary is vulnerable to Buffer Overflow since there is a variable called local_38 that has 48 bytes assigned as buffer, but the program is using gets, which is an insecure function because it does not limit the length of the input data, thus overflowing the reserved buffer if the size of the input data is greater than 48 bytes.</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* p=getPrime(512) q=getPrime(512) n=p * q phi=(p - 1) * (q - 1) d=getPrime(32) e=pow(d, -1, phi) m=bytes_to_long(open('flag.txt', 'rb').read()) c=pow(m, e, n) print(f'{n= }') print(f'{e= }') print(f'{c= }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' The encryption type is RSA, but the implementation is wrong. The issue is that the private number $d$ is relatively small (a 32-bit prime number).</description></item><item><title>Reverse Polarity</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/reverse-polarity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/reverse-polarity/</guid><description>We are given this stream of bits from a hard drive:
10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101 We need to represent it in readable characters. First, we can use Python to express the binary stream as a hexadecimal number:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; hex(0b10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101) '0x4354466c6561726e7b4269745f466c697070696e7d' Notice that we must add 0b to tell Python that the number is in binary format.
From the hexadecimal digits, we can foresee that these are ASCII characters (i.</description></item><item><title>Reykjavik</title><link>https://7rocky.github.io/en/ctf/ctflearn/reverse-engineering/reykjavik/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/reverse-engineering/reykjavik/</guid><description>We have a 64-bit binary called Reykjavik:
$ file Reykjavik Reykjavik: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9bc04368dbcefb4491573ac8feea3a32e31ed59f, for GNU/Linux 3.2.0, not stripped If we execute it, we see that it needs a command line argument:
$ ./Reykjavik Usage: Reykjavik CTFlearn{flag} $ ./Reykjavik 'CTFlearn{flag}' Welcome to the CTFlearn Reversing Challenge Reykjavik v2: CTFlearn{flag} Compile Options: ${CMAKE_CXX_FLAGS} -O0 -fno-stack-protector -mno-sse Sorry Dude, 'CTFlearn{flag}' is not the flag :-( Let&amp;rsquo;s run GDB to debug the program.</description></item><item><title>RIP my bof</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/rip-my-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/rip-my-bof/</guid><description>We are given a 32-bit binary called server:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code. Basically, what the program does is call function gets, which is vulnerable to Buffer Overflow:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system("</description></item><item><title>Robot Factory</title><link>https://7rocky.github.io/en/ctf/other/robot-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/robot-factory/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We are given a Dockerfile that starts with FROM ubuntu:18.04, so we take Glibc from the container and use pwninit to patch the binary:
$ docker run --rm -v "$(pwd)":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.so.2 /lib/x86_64-linux-gnu/libc.</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>We are given the source code of a server that runs a Digital Signature Algorithm (DSA):
fromCrypto.Util.numberimportgetPrime, isPrime, inverse fromhashlibimportsha256 fromrandomimportrandrange q, g=0, 2 whilenotisPrime(p:=2*q+1) orpow(g, q, p) !=1: q=getPrime(256) x=randrange(2, q) y=pow(g, x, p) defH(m): returnint.from_bytes(sha256(m).digest(), 'big') defsign(m): k=randrange(2, q) r=pow(g, k, p) %q s=(H(m) +r*x) *inverse(k, q) %q returnr, s defverify(m, r, s): u=inverse(s, q) returnpow(g, u*H(m), p) *pow(y, u*r, p) %p%q==r defmain(): print("Hello admin, here are the parameters!</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>We are given a host to connect to. It shows the source code used to encrypt the flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 fromCrypto.Util.numberimport* classRotator: QUEUE_LENGTH=10 def__init__(self): self.e=65537 self.m=bytes_to_long(open('flag.txt', 'rb').read()) self.queue=[getPrime(512) foriinrange(self.QUEUE_LENGTH)] defget_new_primes(self): ret=self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt;self.QUEUE_LENGTH): self.queue=[getPrime(512)] +self.queue returntuple(ret) defenc_flag(self): p, q=self.get_new_primes() n=p*q print(f"Public key: {(n, self.e)}") print(f"Your encrypted flag: {pow(self.m, self.e, n)}") rot=Rotator() print('='*80) print(open(__file__).read()) print('='*80) whileTrue: inp=input("Would you like an encrypted flag (y/n)? ") if'y'ininp.</description></item><item><title>RSA Beginner</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/rsa-beginner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/rsa-beginner/</guid><description>We are given these numbers:
e: 3 c: 174422460809195453539354885823735245900172562989776845322302 n: 245841236512478852752909734912575581815967630033049838269083 We have the exponent $e$, the modulus $n$ and the ciphertext $c$.
It is clear that we have an RSA cryptosystem. Let&amp;rsquo;s review how RSA works:
Two prime numbers $p$ and $q$ are chosen so that we have the modulus $n = p \cdot q$. Then an exponent $e$ is chosen (usually 3 or 65537) so that it is coprime with $\phi(n) = (p - 1) \cdot (q - 1)$.</description></item><item><title>RSA Noob</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/rsa-noob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/rsa-noob/</guid><description>We are given these numbers:
e: 1 c: 108193852288406505568171818194994500452464483136775497973720445 n: 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139 We have the exponent $e$, the modulus $n$ and the ciphertext $c$.
It is clear that we have an RSA cryptosystem. Let&amp;rsquo;s review how RSA works:
Two prime numbers $p$ and $q$ are chosen so that we have the modulus $n = p \cdot q$. Then an exponent $e$ is chosen (usually 3 or 65537) so that it is coprime with $\phi(n) = (p - 1) \cdot (q - 1)$.</description></item><item><title>runme.py</title><link>https://7rocky.github.io/en/ctf/picoctf/general-skills/runme.py/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/general-skills/runme.py/</guid><description>We are given a Python script and we are told to run it:
$ python3 runme.py picoCTF{run_s4n1ty_run}</description></item><item><title>SaaS</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/saas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/saas/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Static code analysis We also have the original C source code (chall.c):
#include&amp;lt;errno.h&amp;gt; #include&amp;lt;error.h&amp;gt; #include&amp;lt;fcntl.h&amp;gt; #include&amp;lt;seccomp.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;string.h&amp;gt; #include&amp;lt;sys/mman.h&amp;gt; #include&amp;lt;sys/syscall.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; #defineSIZE0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;amp;arch=x86-64&amp;amp;as_format=inline#assembly #defineHEADER"\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #defineFLAG_SIZE64 charflag[FLAG_SIZE]; voidload_flag() { intfd; if((fd =open("flag.txt", O_RDONLY)) ==-1) error(EXIT_FAILURE, errno, "open flag"); if(read(fd, flag, FLAG_SIZE) ==-1) error(EXIT_FAILURE, errno, "read flag"</description></item><item><title>Safe Opener</title><link>https://7rocky.github.io/en/ctf/picoctf/reverse-engineering/safe-opener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/reverse-engineering/safe-opener/</guid><description>We are given a Java source file called SafeOpener.java:
import java.io.*; import java.util.*; public class SafeOpener { public static void main(String args[]) throws IOException { BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder(); String encodedkey = ""; String key = ""; int i = 0; boolean isOpen; while (i &amp;lt; 3) { System.out.print("Enter password for the safe: "); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes()); System.out.println(encodedkey); isOpen = openSafe(encodedkey); if (!</description></item><item><title>same</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/same/</guid><description>We are given the source code in Python to encrypt the flag:
fromCrypto.Util.numberimportgetPrime, bytes_to_long m=bytes_to_long(open("flag", "rb").read()) n=getPrime(512)*getPrime(512) e=[1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) And we have the output of the program:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 The cryptosystem is RSA, but there&amp;rsquo;s a vulnerability. The flag ($m$) is being encrypted two times as
$$ c_1 = m ^ {e_1} \pmod{n} $$
$$ c_2 = m ^ {e_2} \pmod{n} $$
The problem here is that the same message is raised to a different power but using the same modulus $n$.</description></item><item><title>sanitize</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/sanitize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/sanitize/</guid><description>We are provided with this webpage:
If we look into the HTML source code, we see /debug:
And there we can find the source code of the web application:
fromflaskimportFlask, request, render_template, Response, url_for, g fromsqlite3importdbapi2assqlite3 fromfunctoolsimportwraps app=Flask(__name__) defget_db(): db=getattr(g, '_database', None) ifdbisNone: db=g._database =sqlite3.connect(':memory:', isolation_level=None) db.row_factory=sqlite3.Row withapp.app_context(): db.cursor().execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT);') withapp.open_resource('schema.sql', mode='r') asf: db.cursor().executescript(f.read()) returndb @app.teardown_appcontext defclose_connection(exception): db=getattr(g, '_database', None) ifdbisnotNone: db.</description></item><item><title>scrambler</title><link>https://7rocky.github.io/en/ctf/other/scrambler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/scrambler/</guid><description>We are given a 64-bit binary called scrambler:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the remote Glibc binary (libc.so_1.6), so we can use pwninit to patch the binary and use the provided library, so that the local and the remote exploits are equal:
$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.31-0ubuntu9.7_amd64.deb unstripping libc https://launchpad.</description></item><item><title>Search</title><link>https://7rocky.github.io/en/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/search/</guid><description>SearchSearch for any keyword inside CTF or HTB solutions &amp;lt;- MAIN Total: 0 let fuse const options = { findAllMatches: true, ignoreLocation: true, keys: ['title', 'summary', 'contents'], threshold: 0, } document.forms[0].addEventListener('submit', e = { e.preventDefault() executeSearch() }) function loadSearch() { fetch('\/en\/index.json').then(res = res.json()).then(data = { fuse = new Fuse(data, options) }) } function executeSearch() { const results = fuse.search(document.getElementById('search').value).filter(r = r.item.section !== 'imc') let searchitems = '' for (let result of results) { searchitems += `${result.</description></item><item><title>Secret Note</title><link>https://7rocky.github.io/en/ctf/other/secret-note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/secret-note/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
voidget_name() { longin_FS_OFFSET; charname[40]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); puts("Please fill in your name:"); read(0, name, 30); printf("Thank you "); printf(name); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } intmain() { longin_FS_OFFSET; charsecret[56]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts("</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/secured-transfer/</guid><description>We are given a binary file called securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped We also have a network capture file called trace.pcap.
Traffic analysis Starting with trace.pcap, we can use Wireshark to analyze the network capture file:
There is only one TCP segment that has data:
5f558867993dccc99879f7ca39c5e406972f84a3a9dd5d48972421ff375cb18c Reverse engineering We can use Ghidra to read the decompiled source code in C.</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>We are given a 32-bit binary called seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Reverse engineering This time we do not have the source code. However, we can use a reversing tool like Ghidra to decompile the binary into somewhat readable C source code. Here we have the main function:
void main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts("</description></item><item><title>Serpentine</title><link>https://7rocky.github.io/en/ctf/picoctf/general-skills/serpentine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/general-skills/serpentine/</guid><description>We are provided with a Python script that should print a flag, but it is not doing it:
import random import sys def str_xor(secret, key): # extend key to secret length new_key = key i = 0 while len(new_key) &amp;lt; len(secret): new_key = new_key + key[i] i = (i + 1) % len(key) return "".join([chr(ord(secret_c) ^ ord(new_key_c)) for (secret_c, new_key_c) in zip(secret, new_key)]) flag_enc = chr(0x15) + chr(0x07) + chr(0x08) + chr(0x06) + chr(0x27) + chr(0x21) + chr(0x23) + chr(0x15) + chr(0x5c) + chr(0x01) + chr(0x57) + chr(0x2a) + chr(0x17) + chr(0x5e) + chr(0x5f) + chr(0x0d) + chr(0x3b) + chr(0x19) + chr(0x56) + chr(0x5b) + \ chr(0x5e) + chr(0x36) + chr(0x53) + chr(0x07) + chr(0x51) + chr(0x18) + chr(0x58) + chr(0x05) + chr(0x57) + chr(0x11) + \ chr(0x3a) + chr(0x0c) + chr(0x5d) + chr(0x5c) + chr(0x52) + \ chr(0x42) + chr(0x50) + chr(0x5a) + chr(0x5d) + chr(0x14) def print_flag(): flag = str_xor(flag_enc, 'enkidu') print(flag) def print_encouragement(): encouragements = ['You can do it!</description></item><item><title>Shell time!</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/shell-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/shell-time/</guid><description>This challenge is the continuation of RIP my bof. Check it our first if you have not done it yet.
Now, the flag is stored at /flag2.txt, so we must do something more than redirect the program execution to system(&amp;quot;cat /flag.txt&amp;quot;), as in RIP my bof.
The first thing I came up with was Ret2Libc. The idea is to obtain a shell by calling system inside Glibc with &amp;quot;/bin/sh&amp;quot; as argument.</description></item><item><title>Shifted</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</guid><description>We are given this Python source code:
importstring importrandom flag=open("flag.txt").read().strip() mystery_num=random.randint(100,1000) new_alphabet=list(string.ascii_lowercase+string.digits+string.punctuation) enc_flag="" defshift(char): index=new_alphabet.index(char) new_index=(index+mystery_num) %len(new_alphabet) returnnew_alphabet[new_index] forcharinflag: enc_flag+=shift(char) mystery_num+=10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t What the script does is set an alphabet and a random number (mystery_num). Then, to encrypt the flag, it finds the index of the current plaintext character in the alphabet, adds it to the random number (modulo the length of the alphabet) and returns the character at that new index.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</guid><description>We are given a 64-bit binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
undefined8 main() { longin_FS_OFFSET; charlocal_118[264]; longlocal_10; local_10 =*(long*) (in_FS_OFFSET +0x28); setvbuf(stdout, (char*) 0x0, 2, 0); setvbuf(stdin, (char*) 0x0, 2, 0); puts("Send your string to be printed:"); fgets(local_118, 256, stdin); printf(local_118); puts("</description></item><item><title>Simple bof</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/simple-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/simple-bof/</guid><description>We have the C source code of a binary and a remote instance to connect to. Basically, what the program does is call function gets, which is vulnerable to Buffer Overflow, and then compare a local variable with a certain value:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer.</description></item><item><title>Simple Programming</title><link>https://7rocky.github.io/en/ctf/ctflearn/programming/simple-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/programming/simple-programming/</guid><description>We are given a file called data.dat and we are told to count every line that has a number of 0 that is multiple of 3 or that has a number of 1 that is a multiple of 2.
We can take a look at the first lines of the file:
$ head data.dat 0001100000101010100 110101000001111 101100011001110111 0111111010100 1010111111100011 1110011110010110 11100101010110111 10101101011 1111011101001 0001110001 Alright. The idea is to iterate the file on each line and add 1 to a counter (initialized with 0) if the condition is satisfied.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</guid><description>We have a simple web back-end that allows us to upload a .tar.gz file. As we have a Dockerfile, let&amp;rsquo;s use a Docker container locally:
On the source code we have a simple Python Flask application:
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 The file is being extracted and written to /tmp:
import tarfile, tempfile, os from application import main generate = lambda x: os.</description></item><item><title>Snakecode</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/snakecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/snakecode/</guid><description>We are given a binary file called chall.pyc, so we know it is a binary compiled using Python:
$ file chall.pyc chall.pyc: python 2.7 byte-compiled First of all, we can extract the Python source code using uncompyle6. Since it is compiled with python2.7, we can use a Docker container for that purpose:
$ docker run -v "$PWD":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.</description></item><item><title>Snowboard</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/snowboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/snowboard/</guid><description>We are told to find the flag in this image:
However, the flag is not visible inside the image and it is not hidden in its content. However, we can find the flag in the file raw content.
In order to extract printable characters from the image we can use strings and take the first values with head:
$ strings snowboard.jpg | head JFIF CTFlearn{CTFIsEasy!!!} Q1RGbGVhcm57U2tpQmFuZmZ9Cg== Exif Canon Canon EOS 6D Mark II GIMP 2.</description></item><item><title>So many 64s</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/so-many-64s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/so-many-64s/</guid><description>We are given a pretty large file:
Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZadGNFSmxSbGw1VTJ0V1ZXSkhhRzlVVmxaM1ZsWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVm14YU0xWnNXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0xNFlVMHhXbk5YYlVaclVqQTFSMVV5TVRSVk1rcElaSHBHVjFaRmIzZFdha1poVjBaT2NtRkhhRk5sYlhoWFZtMHhORmxWTUhoWGJrNVlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRWxhU0hCSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNSGhPUm14V1RVaG9XR0pyTlZsWmJGWmhZMnhXY1ZGVVJsTk5WbFkxVkZaU1UxWnJNWEpqUld4aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STlNHaFBVbTE0VjFSVmFHOVhSMHB5VGxac1dtSkdXbWhaTW5oWFkxWkdWVkpzVGs1V2JGa3hWa1phVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5UUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSGFGQlZiVEUwVmpGU1ZtRkhPVmhTTUhCNVZHeGFjMWR0U2tkWGJXaGFUVzVvV0ZreFdrZFdWa3B6VkdzMVYySkdhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWV3hrTkdGR1ZYZGhSVTVVVW14d2VGVnRNVWRWTWtwV1lrUmFXR0V4Y0hKWlZXUkdaVWRPU0U5V1pHaGhNSEJ2Vm10U1MxUXlVa2RUYmtwb1VqSm9WRmxZY0ZkbGJHUllaVWM1YVUxWFVraFdNalZUVkd4T1NHRkdRbFppVkVVd1ZtcEdVMVp0UmtoUFZtaFRUVWhDTlZaSGVHRmpNV1IwVTJ0a1dHSlhhR0ZVVnpWdlYwWnJlRmRyWkZkV2EzQjZWa2R6TVZZeVNrZGhNMmhYWVRGd2FGWlVSbFpsUm1SMVUyczFXRkpZUW5oV1YzaHJUa2RHUjFaWVpHaFNWVFZWVlcxNGQyVkdWblJOVldSV1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYxcEhhR2hOU0VKMlZtMTBVMU14VVhsVmEyUlVZbXR3YjFWcVNtOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0VDFOSFJrZFJiRnBwVmtWVmQxWnRjRWRWTVZwMFVtdG9VRlp0YUZSVVZXaERUbFphU0dWSFJtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZucFdkbFl3V25KbFJtUnlXa1prVjJFelFqWldhMlI2VFZaWmVWTnJaR2hOTW1oWVdWUkdkMkZHV2xWU2JGcHNVbTFTTVZVeWN6RlhSa3BaVVc1b1YxWXphSEpVYTJSSFVqRmFXVnBIYUZOV1ZGWldWbGN4TkdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkpIU2toVmJHeGhWbGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFZERk9TRkpyWkZKaVJuQndWbXRXVm1ReFduUmpSV1JXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVWJGcGhVMGRXU0ZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubFhhMXByVmpKRmVsRnFXbGRoTWxJMlZGWmFXbVZXVG5KYVIyaE9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xkV2JHTjRUa2RSZVZaclpGZGliRXBQVm14a1UxWXhVbGhrU0dSWFRWZDRlVlpYTVVkWFJrbDNWbXBTV2sxSGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hoalJXaG9VakpvVDFVd1ZrdE5iRnAwVFZSQ1ZrMVZNVFJXVm1oelZtMUZlVlZzVmxwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTWtwSVUydG9WbUpIZUdoV2JHUk9UVlpzVjFaWWFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRlpFUms5VFJrcHlXa1pLYVZKdVFuZFdiWFJYVm0xUmVGZHVVbXBTVjFKWFZGWmFkMDFHVm5Sa1J6bFdVbXh3TUZsVldsTldWbHBZWVVWU1ZXSkdjR2hWTUdSWFUwWktkR05GTlZkTlZXd3pWbXhTUzAxSFJYaGFSV2hVWWtkb2IxVnFRbUZXYkZwMVkwWmthMkpHYkROV01qVkxZa1pLZEZWdWJGaGhNWEJ5Vm1wS1JtVnNSbkZYYkdSb1RXeEpNbFpHV21GWGJWWlhWRzVLWVZJeWFFOVVWekZ2VjFaa1YxVnJaR3ROYTFwSVZqSjRWMVV5U2tkalNFNVdZbFJHVkZSV1dsWmxWMDQyVW14b1UyRXpRbUZXVm1NeFlqRlplRmRZY0doVFJYQldXVlJLVTFOR1ZuRlNiVVpZVm01Q1NWbFZXazlXTVZwSFYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pHbGlSWEJRVm0xNGExVXhXWGhWYkdoclUwZFNXRlJXWkRSbFZscFlUVlZrV0ZKcmJETldiWEJUVjJzeFNHRkZlRmROYm1ob1ZqQmFWMk5zY0VoU2JHUlhUVlZ3VWxac1VrTldhelZYVjFob2FsSlhhRzlWYWtwdlZERlZkMVpyZEU1aVJuQXdWRlpTUTFack1WWk5WRkpYVm0xb2VsWnRNVVpsVmxaelZteHdhVmRHU1hwWFYzQkhWakpPVjFSdVVsQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbHBGVW1zNVZGSnJjSGxYYTFwTFlWWktkVkZ1WkZkaVdGSllWbTB4VW1WR1pIVlZiWEJUVmpGS1dGWkdXbUZrTURGSFZtNVNhMUo2YkZkVmJYaDNUVVpzVmxkc1RsZFdiSEJaV1ZWV1UxWlhTa2RqUjJoV1RVZFNXRlV3V2t0a1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGSllhR0ZTVjJoVldXdGtiMkl4Vm5GUmJVWlhZa1p3TVZrd1dtdGhNa3BIWWtST1YwMXFWa3haYTFwTFpFWldkV0pHYUdoTldFSjVWbTF3UzFKdFZuTlNia1pZWWtkU2IxUlhlRXBOYkZwSFYyMUdXR0pXV2xoV1J6VkxXVlpKZVdGRk9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRiMVV5UlhwUmJVWlhWbTFOZUZscVJscGxSbVJaWTBkb1ZGSllRbGRYVmxKTFZURk9SMVp1UmxOaVZWcFpWbTAxUTFOV2JGWlhhemxYVFZad1NGWXllR3RXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwSGJHbFNXRUpSVm0weE5HRXhWWGhYV0doV1lrZG9jbFV3WkZOWFJsSlhXa1JTYkZac2NGbFVWbFpyVjBaS2NtSkVUbGRpV0VKVVZqSnplRk5IUmtabFJtUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVGxkaGVsWllWakZvYjJGc1NsaGhSemxXWVd0d2RsWkVSbFprTVZweVpFVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm0weGIyVnNXblJOVlZwc1ZteGFlbFp0ZUhkaFZtUkhVMWh3V0ZZelFraFdha3BQVmpGU2RWVnNRbGRpVmtwVlYxZDRiMkl4YkZkYVJsWlNZbFZhYjFSWGRIZFRWbFY1WkVjNVYySlZjRWxhVldSdlZqSktTRlZyT1ZWV2JIQjZWbXBHWVZkWFJrZGhSazVwVW01Qk1WWXhXbGRaVjBWNFZXNVNVMkpyTlZsWmExcGhWMFpzVlZOc1NrNVNiSEJHVlcxek5WWkdTbkpqU0d4WVlURndURmxXV2t0a1ZrWjFXa1prYVZkR1NsbFdiVEI0VlcxV1IxcElWbFppV0VKVVZtcEdTMWRHV2tkWGJVWnJUVVJHU0ZadE5WTmhNVW8yWWtaa1ZtSllhRE5VVlZwelZteGtjMVJzWkZkaVNFSmFWMVpXVjFVeFdsaFRhMlJxVWpKb1YxUlZaRk5YUmxWM1YydDBhMUl3TlVkVWJGcHJWR3hhV0dRemNGZGlXR2hVVlhwQmVGTkdTbGxoUjBaVFZqSm9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaWldsVmFhMVl3TVhGV2JrcFhWa1Z3VEZVeFdrZGpiVVpIV2taT1RrMXRhRlpXYlhoVFV6RktkRlp1VGxOaWExcFlXV3RrVTFaR1VsVlRiVGxwVFZad2VWWlhkREJWTURGWFlrUlNWMUo2VmxoV2JURkxVbXhPYzJGR1dtbFNhM0JaVm1wR1lWbFdTWGhpUkZwVFlsZDRUMVpxUmt0VFZsbDVaRWRHYUUxWFVrbFZNblJoWVd4T1JrNVdaRnBpUmtwSVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGT1pVWnNjVkpzY0d4U2JWSmFXVEJrYjFaR1NsbFJiR3hYWWxoU1dGZFdaRmRqTVdSMVVteE9hVkl4U25oV1JscHJWVEpXYzJKR1dtRlRSVFZZVkZaYWQwMVdWbGhsUldSWFRXdFdORmt3Wkc5WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMDFHV1hoVVdHaGhVbGRTVjFsclpGTlhWbXgwVFZaT2FrMVdjREJVVmxKRFZHc3hWMkpFVmxWaVIxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVW05WlZFNURVMVprVlZOcVVtaE5helV3Vm0xMGExbFdTWGxoUnpsVlZrVktURlpYZUdGak1WWnlXa2RvVGxaVVJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXeG9UbVZHV1hkWGJIQnJUVlp3ZVZwRlZURmhWa3AxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWbTB3ZUdJeVZuTlhiazVZWWxoU1ZWVnFSbUZUUmxsNVpVaGtWMDFWY0ZoWmFrNTNWMFpaZWxGcmFGZGhhM0JRVm1wR1YyUldUbk5XYld4VFRWVndWbFl4WkRSaU1rbDNUbFprV0dKc1NrOVZhMVpoWWpGU1YxZHVUazlTYkd3MVZHeFZOV0ZIU2taalJXUldUV3BHZGxacVNrdFRSbFp5VDFaV1YySklRbTlXYWtKclZHMVdkRkpyWkdoU2F6VndWVzB3TlU1R1dYaFZhMDVhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcHpWMGRTUm1SSGNHbFNiR3Q1VmxjeE1FMUhSblJTYWxwWFlrZG9XVmxVUm5kaFJteFhWMnQwYWsxck5VaFphMXByVlRKS1JtTkZNVmhXTTBKSVZrUkdXbVZHY0VsVGJXaFRUVEpvVlZaR1ZtRmtNV1JYVjJ0a1lWSkdTbFZVVmxVeFYwWlplV1ZIT1doTlZXOHlXV3RqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZSZUdKR1pGUmhNWEJaV1d4a2IxbFdjRmhrUjBaT1RWWmFlbFl5ZUd0aE1VbDNUbFZrVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVGJHeG9VakJhVkZacVNtOVdiR1JZWkVkMGFVMXJiRFJXYlRWSFZXMUtWbGRzYUZwaE1YQXpWRlphY21ReFpIUmtSMmhPWVROQ1NWZFhkRk5VTVZsM1RWaEdWMkpGU2xoVmExWjNWRVpXZEUxVk9WUldNRFZJV1ZWa2IxUnRTa1ppUkZwWFRWWndhRmRXV2xKbFJrNTFWR3hXYVdFelFuZFdWekI0VlRGUmVHSklVbXhTV0ZKelZtMHhVMWRzYTNkV2JYUlhUV3R3V0ZZeWVHOVdNVW8yVm14b1YyRXlVa3hWYWtaUFpGWkdjMXBIYkZOaWEwWTJWbTF3UjFsV2JGZFRXR2hwVWtad1ZGbHNaRFJVTVZweFVtdDBWRlpzYkRWYVJXUkhZVVV4V0ZWcmJGWk5ibEpvV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGa01XUklWbXRzVldKSFVuQlZha1pMVG14YWNsa3phR2xOVm13MVZXeG9kMVZzWkVoaFJtaFhZbFJHVTFSVlduZFNWa3B6WTBkNFYyRjZWalpYVjNSaFdWZEdWMU5ZYkdoU2VteFlWbXBPVTFkR1pGZFhiazVYVFdzMVNGWXlNVWRWTVdSSFUyeGFWMkpVUmpaVVZtUlhZekpLUjFkdFJsTmxiWGhYVjFab2QxSXhXWGhoTTJSWVlsaFNXRlJYZEhkVFZscElZMFpPVjFZd1ZqVldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNbEY0VWxob2FWSnRhRlpaVkVwVFYwWnNkR1ZGZEdwTlZsWXpWMnRhVDJGck1WaGxTR3hYVFdwV1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVekpPZEZOclZsVmlSMUp3VmpCV1MxWldXbkZUYm5Cc1VtdHNORlpITlU5VmJVcElWV3M1V2xZelVtaFZNRnByWXpGa2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZWHBzVmxadWNFZGtiRlY1WlVad2JGSnNXbmxaTUdRMFZUSkdObEpVUWxkV1JWcDJXWHBHVm1WV1NsbGlSbHBwVmtkNFdGZFhlRzlpTVZKSFYyNUtXR0pWV25GVVYzUmhVakZhU0dWR1RsVmlSbkF4VlZab2ExWXhTbk5qUmxKV1ZrVmFhRmt5YzNoV01XUnlUbFprVTJFelFscFdNV1F3WVRKSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVVbTE0ZVZZeU5XdGhSbHAwVld0c1dsWlhUVEZXYWtwTFYxWkdjbUZHY0d4aE0wSlFWMnhXYTFReFNuUlNhMlJTWWtkU2NGWnRkSGRXYkZsNFdrUlNhVTFyYkRSWmExcHJXVlpLYzFkc1RscGlSbHBvV1dwR1UxZEhVa2xhUmxKWFlrWlpNVmRyVm1wT1ZsbDVVMnhhYWxKWGVHaFdiR1JUWkd4YWNWTnJkRlJTYkZwNVZERmFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5V2tkb1UyRjZWbmRXVnpBeFVXc3hWMWRZYUZoaVIxSmhWbXBDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFHY0hwV2JGcFBZekZPY2s1V1RtbFRSVXBJVm14amVHVnJOVmRXV0dST1ZtMVNjVlZyVm1GWFJteHpZVWM1V0ZKdGVGaFdNblF3WVRGYWNsZHFSbGROYm1oMlZtcEtTMUp0VGtaV2JHaG9UVlZ3UkZaR1dtdFViVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWMnRhYjJKR1NYZFhiVVpYWWxSR1ZGWXdXbHBsVjFaSVQxZG9UbFpYT0hsWFYzUnFUbFphVjFkdVRsaGhhelZXVm14YWQyVnNXblJsUjNScVRWWktlbGRyV210aFZrNUdVMjFHVjAxV2NGaFdha1pXWlVaa2RWTnJOVmhTYkhCMlZsZHdTMkl4YkZkalJtaHJVakJhVDFSV1dtRmxiRmw1WlVkMGFFMVZiRE5VYkZaclZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWV0pIZUhCVmJYTXhZakZTV0dWRmRGZGlSMUpaVkZab2QxUnNXbk5qUm1oYVlUSm9URmRXV2t0T2JVcEhZVVp3YUUxWVFYcFhiR1EwVjIxV1ZrNVdhR3RTYkZwdldsZDBZVmRXWkZWUmJUbHFUVlpzTTFSV2FFZFZNa1Y1WVVkR1YyRnJOWFpaVlZweVpWZE9ObEpzYUZkTlNFSkpWMVpXYTJJeFVuTmFSVnBVWWtWd1dGUldXbmRoUm1SWFYyczFiRlpzU2pGV1YzaFhZVVV4VjJOR2NGaFdNMUp5VmxSS1NtVkdWbk5oUjNCc1lUQndVRlpYTUhoVk1XUnpZVE5rVjJKWVVsaFVWM1IzVjBaWmVXVkhPVmROVlc4eVZtMTRiMVl5UlhsVmEzaFdZV3RhVUZwR1drZGpNWEJJWWtaT2FXRXdXVEpXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwellrUldZVkpYVWtoWlZWVjRWMFpXY21KR1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHYTAxWFVrbFdiWFJ6VmxkS1NGVnVRbFpoYTFwTVZHMTRZV05zYTNwaFIyeE9WbTEzTVZaWGVHOWtNVlp6V2tWb2FGSnRhRmhaYkZKSFZURlNWbGR1WkZOV2EzQjZXVEJrTkZZeVJqWldhbHBZVmpOU2FGZFdaRWRXTVU1WllrZG9VMlZ0ZUZsV2JYQlBWVEZrUjFwR1pGaGlhelZZVkZkek1WTkdXWGxOVldSV1RWZFNTRlV5ZUdGV01rcFZVbXBhVlZadFVsaFpla3BMVWpGa2RGSnNUbXhpV0doWVZqRmFiMlF4U1hoWFdHaG9UVEpTV1Zsc1ZtRlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydGtWV0Y2VmxoV01GWkhUbFphZEUxVVVtaGhla1paVmxab2MxWldaRWhsUmxaWFRVZFNkbFpxUm5OamJIQkhWR3hvVjJKWVozZFdSbHBoVkRKR2NrMVdhR3hUUjNoWVZGZHdWMVZHV2tWU2JVWnJVakZLUmxaSGVHdGhWbHBHVm1wT1YySllRa05hVlZwTFZqRk9kVk5zYUdsU2JrSjNWbXBDVjFNeFRsZFhia1pVWVd4S1lWWnRNVk5UUmxwMFRsWmtXRkl3Y0VsV1YzTTFWMjFLVlZKdVdscGhhMXBvV1RGYVIyUkdTbk5hUlRWb1pXeFpNbFl4VWtOV01rbDRWbGhzVkdFeWFGZFphMlJ2Vm14YWRHVkhSazVOVm5CWldsVmtSMkZyTVZsUmEzQllZVEZ3VkZaSGVHRldWa3BWVVd4a1YxSldjREpYV0hCSFZtMVdWMU5zYkdsU01taFVXbGN4TkZkR1pGaGtSMFpVVFZkU1NGWXhhR3RYUjBweVRsaEtWbUZyV2t4VmFrWjNVbXhhVlZKdGFGZGhNMEY0VmxaYWIyRXhXWGhUYms1cVVteEtWMVpyVm1GaFJtdDVZek5vVjAxWFVubFViRnByVlRKRmVsRnNjRmRpVkVJeldsVmtTbVZXV25WVWJHaHBZWHBXV2xkWGVHOVZNVnBYVm01R1UySlZXbFZWYlhoelRsWndWbUZIZEZkTlJFWlhXVEJhYjFkdFJuSk9WRTVYVFVad2FGbDZSbXRrUjBaSFdrZG9hRTB3U2xKV2JURjNVakZWZVZWc1pGZGlhelZUV1d0a1UyTkdXblJrU0dSWFlrWnNORmRyVWtOV01ERnpVbXBTV0dFeWFGQldNR1JHWlZkR1NWUnNXbWhoZWxaRlZteFdZVmxYVWtoV2EyeFZZWHBzVkZsclpETk5WbHBJWlVaYVQxWXdXa2xWTW5SaFlXeEtkR1ZIUmxkaVJuQXpXbGQ0WVdOV1RuSlhiWGhUWWtoQ1lWZFdWbXRTTVZWM1RVaHNhRkpHY0ZoWmJHaERVMFprVjFkdGRGaFNhM0I1V1ZWa2QxVXdNWFZoUm14WFlXdEtXRlY2Ums5U01XUjFWVzE0VTAweFNsRldWM0JEVmpBMVIxZHNhRTlXVkd4WlZXMHhVMU5XY0ZaWmVsWlhZbFZXTkZZeWNFOVdNREZIWTBod1YwMUhVbFJWYlRGVFUwZE9TR0pHVG1sU00xRXhWbTE0YW1WRk1VWk5WV2hUWW14S1ZGbFhlSGRYUm14eVdrYzVXRlp0ZUZaVmJUVnJZVzFLU0dWR2FGZE5ibEYzV1ZkemVHTnJOVlpoUm5Cb1RWaENlVlpzVWt0VE1VcDBWR3RhYVZKdFVsbFZNRlpMVWtaYVIxZHRkRlZpVmxwSVdUQldjMVpIU2xoaFJsSlZWa1ZhVEZac1dtRlNNVnAwVW0xMFRsWXhTbGxXTW5SaFlqSktSMU5ZWkZoaVZWcFlXV3hTUjFaR1dYZFhiSEJzVmpGYVNWUXhaRzlVYkZwWVQwaHNXRll6VW5GVWJGcGhWakZrZFZSc2FHaGhlbFpYVm0xNFlXUXlWbk5YYmxKc1VqTlNjVlJXV2t0bGJHUnlWMjEwYUZack5VZFZNakZIVmpBeFYyTkdhRmRoYTFwWFdsVmFhMlJXVG5KT1ZtaFRZa2hDTWxac1pIZFRNa2w0WWtaa2FsSnRhSEpWYWtKaFZERlNWMWR0Um14aVJtdzFXbFZrTUdGRk1WWmlSRTVWWWtaYWNsWnNaRXRTTWs1SlUyeGtVMDB5YUc5V2FrSnJWVzFXZEZSclpHRlNNbmhaVldwS2IxWnNXbk5oU0dSU1lsWmFTRlpIZEd0V1IwcElaVWM1Vm1GclNtaFdhMXBoWTFaT2RFOVdaR2xTTVVwYVYydFdhMDFIUmxaTldFcHBVa1pLV0Zsc1VsZFRSbHBZVFZWMFYySkhVbnBaVlZwM1lVVXhXVkZZY0ZkU2JGcG9Xa1JHWVdSR1NuSmhSM1JUWWtad2RsZHNaREJaVm1SeldraE9WMkpWV205VVZscHpUVEZTVjJGRlpGZE5hM0I1V1RCYWIxWXlSWGhYYWs1WFVsWndWMXBWV210amJIQklZMGRzVjFadVFrcFdha293V1ZaUmVGVnVTazVYUmtwdlZXMTRkMWRHYkhOaFJ6bFhVbXhaTWxWdGREQmhNVXB6WTBSR1YxSXphRkJaVm1SR1pVZE9SMkpHYUZkTk1VcDVWbXhTUjFsV1NYaFdiazVYWWtaS2NGWnJaRFJrTVZwSFYyMUdhMDFzV2xoV01uaHZZVEZLUmxOc1pGVldWa3BJVmpCYWMyTnNWbk5VYkdST1ZsYzRlVlp0TVRSaU1WbDVVMnhXVTJFemFGZFpiR2h2VlVac05sTnJaRk5OVjFJd1dXdGFUMkZGTUhkVGJVWlhZbFJHTTFWcVJuTldNa3BIV2taU1dGSXlhSGRXVjNSaFpERmFSMkpJVG1GU1JrcFdWRlphZDJWR1ZuUmtSRUpYVW14d2VsbHJVbGRaVmtwWVZXdG9XbFpXVmpSV01GcFhZMjFLUjFkck5XbGlSWEIyVmpGYWEwNUdVWGhUYmtwUFZtMVNhRlZ0TlVOalJsWjBaRWhrVkZac2NEQmFSV1JIWVRBeFdGVnJiRmRpV0ZKNlZteGtTMU5HVm5WUmJGcG9ZVEZ3VFZaSE1UUlpWMDV6WVROd2FGSXllRTlXYlRFelRWWmFXR1ZIT1d0TlZscDZWMnRXYjJGR1NuUmhSbWhhWWtaS1NGWlVSbE5XYkdSMVdrWk9WMkV6UWpaWFZFSnJUa1paZVZKcVdsZGhiSEJaVm1wT1UyRkdaRmRhUldSWFRWVTFXbGxyWkc5Vk1sWjBaVVpzVjJKWVFsQldWRVpyVWpGd1IxcEdhR2xoZWxaWlZrWmtlazFXVGtkWFdHeE9WbGRTVjFSV1pGTlRSbFY1WlVkR1YwMXJjRlpWYlhCaFZsWmFkRlZzYUZwbGEzQk1WV3BHYTJSR1NuTlViWGhwVjBkb1dWWnFSbUZpTWxGNFUxaG9XRmRIYUc5VVZFcFRWMVpzYzJGR1RsaFNiRXBaV2tWb2ExWkdXbk5qUld4YVRVWndVRlpxUmxwa01WcHhWbXhrVjAweWFGRldNVnBoV1ZkTmVWUnJhR2hTYmtKUFdXMHhibVZzV2xoalJXUnJUVlUxU1ZVeWRHOWhWa3B5VGxac1ZtSkdXak5XVkVaaFpFVXhTVnBIZUZOV1JscEtWbGQ0YjJJeFdYaGFSV2hvVW0xNFdGUlZaRk5rYkZweFVtNU9hbUpJUWtsVU1XUjNZVlpLYzFkWWNGZE5ibEpvVmtSR2ExSXhUblZVYkZKcFVqSm9XbGRXVWtkVE1WcEhZa2hLV0dKVlduRlVWM014VTBac2NsZHNaRmROYTNCSVdUQm9jMVl5Um5KVGJXaFdaV3R3VUZwRldrOWpiRnB6Vm0xc1UwMVZjRE5XYlhCRFZqRk5lRmRzWkZoaWExcFZXVzAxUTJNeFZuUmpla1pVVm14YU1GcEZaRWRoVmtweVkwUkNWMVl6VFRGV01qRkxWbFpLZFZkc2NHaGhNWEJ2VjFSR1lWSXlVa2RUYms1aFVsUldiMXBYZUZwTmJGbDRWV3RPVjAxcmJEUldiR2h6VmtkRmVXRkdaRnBoTWxKMlZtMTRZV1JIVmtoU2F6Vk9WbTVDV2xkc1ZtdFNNa1p5VFZaa1dHSnRlRmhWYWs1dlkyeHNWbHBHWkdwTlYxSjZXV3RhYTJGSFJYaGpSRXBZVmpOQ1RGVnFTazVsUmxKMVZHMW9VMDF0YUZWWGJHTjRUa1prUjFwR1pHRlNSVXB5VkZkNFMyVnNXWGxrUm1SV1RXdHdTRmt3YUV0V1ZscHpZMFJPWVZac2NETlZiWGhoVmxaS2RHRkdaR2hOTUVZMFZteGFZV0l5UlhoWFdHaFVZbXMxY1ZWdGVFdFdNVnB5Vm0xR2FGSnRkRFZaZWs1dlZqQXhXRlZ1YkZWaVJuQnlWbFJLUm1Wc1JuTmpSbVJwVmtWSmVsZHNWbXRUYlZaWFYyNVdWV0pIYUhCWmExWjNWVVphZEdWSFJtdE5hekUwVmpJMVUySkdTWGRYYms1YVlURndNMVJWV25kV2JVWklaRWRvVTJKSVFYZFdiR1F3WWpGYWNrMVdhR2hTUlRWWVZGVmFkMWxXY0ZobFJXUnFZbFZhU0ZkclpHOWhSVEIzVTJ4S1YySlVSak5WYWtaV1pWWldjMXBHWkdsaGVsWlVWMWQwYTFVeVRrZFhibEpyVTBkU1dGbHJXbk5PUm1SeVZXeE9hRlpVUm5sWmExSlRWMjFGZUdOSVNsaFdiSEJNV1hwR2EyTXhVbk5qUjJ4VFlraENkbFl4WkhkU01WVjRXa1ZvVm1FeWVHaFZiWGhMVjBac2NsZHNjRTVXYlZKNVZtMHhkMVF4V25OaVJGWldUVzVvYUZsWGVFdFhSMVpJWVVaa2FWSXhTbFZYYTJRMFdWZE9WMVJ1U210U2JFcFVXV3RhZDA1V1drVlNiVVpYVFZac05WVXlkSE5WYlVaelkwWm9XbUpIYUVSVk1GcHJWakZrZEdSR2FGTmhNMEkxVmpKMGEySXhWWGxTYWxwWFltMVNXRlp1Y0VKbFJsWllZek5vVjAxWFVscFpWVnB2WVZaSmVGTnRhRmRpV0VKRVZtcEJNVkl4WkhOaFJUbFhZWHBXV0ZaR1pEQmtNbFpYVlc1T1dHSnJOVmxaYkZaWFRrWnJkMXBIT1ZkTlJFWklXVEJvZDFZeVNrZGpSa0phWld0YVVGa3ljekZXTVZKMFlrWm9VMDF0YUZwV2JURTBZVzFXU0ZadVNrOVdiVkpZVmpCa1UxUXhXblJOVms1cVZteGFlVlp0TVVkWFJrcHpWMjVvVjFKNlFURlpWRXBMVTBkV1IyRkdaRTVpYkVZelYxWmtlbVZIVG5KT1ZscG9VbTVDYjFSV2FFTk5iRnAwWTBWS2EwMXNXa2hXUnpWSFZrZEtTRlZzYUZwaE1Wb3pWVEZhWVdOc1ZuSmFSbWhwVm14d1NWZFVRbGRqTVZwSVUyeGFXR0pHU21GWlZFcHZVa1p3U0dWSFJsTk5XRUpHVmxkNFUxUnNXWGhUYTJ4WFlXdHZkMWxVUm10VFJrNXpWMnhvYVdFelFsZFdiWGhoVXpGT1IxWllaRmhpVlZweVZXeFNWMWRHV2toTlZ6bFZZa1p3V1ZRd2FITlhSbGw2Vlcxb1dsWkZXbWhhUlZwUFl6SktTR0ZHVWxSU1ZYQllWakZrTUZsWFVYbFdiazVZWW14S1QxWnNaRk5XUm14eVYydDBiR0pIVW5sWGEyaFBWakF4V0ZWclpGWk5ibEYzVm1wQmVGWXlUa2RoUm1Sb1lURndXRmRzVm1GaE1rMTVVbXRrVm1KWGVGUlVWRXB2VFd4YWMxVnJUbGROYkVZMFYydFdhMkZXVGtaalJteGFZbFJHVkZac1dsZGtSVFZXVkd4T1RsWnRkekZYYTFaVFVUSkdSazFXV21sU1JUVldXV3RhWVdOc1duTmFSWFJUVFdzMVNsVXllR3RWTURCNVlVYzVWMkZyU25KV1Z6RlhaRVpTY2xwSFJsTk5ibWhhVmxkd1MySXhXbk5YYms1b1UwZFNVMWxzV21GVFJscElaRWQwVjFJd2NFbGFWV00xVm0xR2NsTnRhRmRoTVhCb1dURmFUMlJGT1ZkYVIyeFRUVlZ3WVZZeWRGZGhNREZJVW14YVRsZEZjSEJWYTFwTFYwWnNjMVZzWkZSU2JIQlpWRlpXTUZZeVNraFZibkJhVmxad00xbFZWWGhYVmtaWlkwWmtVMkpJUW05WFZFbDRWVzFXUjJORmJGWmlXRkpVVkZjeGIxVkdaRmRWYXpsU1RWVTFXRmRyV205aE1VcHlUbFphVlZac2NIcFVWRVpUVmpKR1JscEdaRTVoTVZreVYxWldhMUl4WkhOWGExcFlZV3MxV0ZWc1duZE5NVlowWlVkMGFrMVlRa2xhUlZwclZHeE9SbE5yY0ZkTlZuQllXVlJLU21WR1ZuVlViVVpUVm01Q1ZsZFdaRFJaVm1SSFlraE9WbUV5VWs5VVZscGFUV3hXZEdSRVFtaE5WWEI2V1RCU1IxWXhTWHBoUmtKYVZtMVNSMXBWWkU5U01rNUhZVVprVGsxVmNEVldiWGhUVXpGT2RGWnJaRmRpYXpWdlZXcE9iMVpHV1hkV2EzUldVbTFTV1ZwRlpFZGhNREZXVGxWb1YwMVhhSHBXUjNoaFYwWldjMkpHV21oaE1HOTZWbXBDWVZZeVVraFVhMXBRVm0xU1dGbHJhRU5PYkdSVlVXMDVWRTFXYkROVVZsWnZWbTFGZW1GR2FGVldWMUpVVmpCYVZtVkdaSE5VYlhCT1lYcFdTVll5ZEdGVU1WbDVVMnhXYUdWcmNGaFpiRkpIVFRGV2NWSnVUbGhTYTNCYVdWVmtSMVV4V1hsaFJteFlWbXhLVEZscVJsZFdNV1IxVlcxMFZGSXhTbGRXUmxwaFpESldjMWRzYUd0U01GcFdXV3RXZDJWc2EzZGhTR1JZVWpCV05GVXllRk5YYkZwWFZtcFNWMDFIVWxoVmFrcEhVakZrY2s1WGJHbFdNbWN4Vm1wR1lXRXdOVWRWV0doVVltdHdVRlp0TVZOaFJsWjBUbFZPYWxKc1dqQmFSV2hyVmtaYWMyTkVRbUZTVjFKSVZqQmtTMVl4WkhOaVJtUnBWMFpLTWxkV1VrZFRiVlp6VW01V1VtSkdjSEJXYTFwaFVsWmFkR05GWkZwV2JWSkhWRlphVjFadFNsaGhSVGxYWWxoU00xUnRlR0ZqVms1VlVteGtUbFpzYjNkV1Z6QXhWREpHYzFOdVVteFNiV2hoVm10V1lXRkdXa1pYYms1WFlrZFNNRlZ0TVhkV01rVjZVVmhrV0dFeFdtaFdSRVpUWXpGa1dXRkdVbGhTTW1oWlYxWlNTMVZyTVVkWGJGWlVZVEpTVkZsWWNFZFhiRnBZVFZjNVZrMXNXakJhVlZwelZqSktXVkZzUWxkV1JWcHlWV3BHZDFJeGNFZGhSMnhvWld4YVdsWnJXbXRsYXpGWFZHdGtXRmRIZUU5V2JHUlRWakZTVjFwR1RsUlNiRlkxV2xWa1IxWXdNWEpqUmxwV1lsaENhRlpzV21Ga1JsWnpZVVp3YkdFelFrMVdWM0JIWVRKU1IxTnVUbFZpV0dod1ZqQmtiMWRXV25GU2JVWnBUV3hHTkZVeGFHOVhSbVJJWVVjNVZWWkZjRlJXTVZwell6SkdSMVJzYUZOaVJYQmFWMnRXYjJFeFdrZFhiazVxVWxkNFlWUlZXbmRWUmxweFVteHdhMDFXY0hoV2JYaHJWakF3ZVdGR1JsZE5WbkJvVjFaa1RtVldVbkpoUjJoVFltdEtVRmRYTUhoaWJWWnpWMnhvYWxKWFVuSlVWbFV4VTFaVmVXUkhPV2hXYTNCNVZHeGFjMVp0U2tkWGFrNVhWa1ZhYUZwRlZYaFRWbkJJWlVaT1YxSnNjRXRXYkdRMFlqSkplRmRZYUdGU1YyaHZWVzB4TkZkR1VsWmFSazVyWWtad2VGVnROVTloYlVwSlVXdHNWVTFYVWpOWlZscExZekZrV1dOR1pFNWliRXB2Vm10U1IyRXhTWGhVYmxaVllrWktjRlZxU205WGJHUlhWV3RrVkUxV2NFaFphMmhMVjBkS1ZsZHVSbFZXTTAxNFZUQmFjMk5zWkhOYVJtUk9ZVE5DU1ZkVVFtOWpNVmw1VW01S1ZHSlhhRmRhVjNSM1ZVWndSbGRyT1dwaVJuQjZWbTB4YzFVd01WWmpSRTVYWWxoQ1JGWnFSazVsUm1SeldrWm9hV0V4Y0ZaWFZ6QXhVVEpOZUZadVVtcGxhMXBWVm0xNFlVMUdjRVphUldSb1ZtdHdlVmt3VWtOV01WbDZWRlJHVjAxcVJreFdiRnBMWkZaa2MyTkhhR2hOV0VKMlZqRlNSMWxXU1hsVmEyUlVZbXMxYUZWc1VsZGlNWEJZWlVad1RtSkdiRFJXVjNSUFZqQXhjbUpFVWxkaVIyaDZWbXRrUm1WWFJrZGFSbkJvVFd4S01sWnRNVFJaVjFKSVZtdG9VMkY2Vms5V2JUVkRWMnhrYzFadGRGTk5hMXA1VkZaYWExZEhTblJsUm1oV1lXczFkbGt5ZUhOV2JIQkhXa2R3VGxZeFNqWlhWM1JoWVRKR1NGSllhR3BTUlhCWlZtcE9RMVJHVm5GVGF6VnNVbXhLTVZaSE1XOVZNREYwWVVaV1dHSkhUalJVYTFwclVqRndSMXBIUmxOU1ZYQjVWa1prTkZNeVZuTlhXR3hyVW0xU1YxUlhkSGRUUm10M1lVVjBWMVpzY0hwWk1GSlBXVlphYzJORVRsWmlXR2hvVm14YVMyUkhSa2RhUjJoT1RVVlpNRlp0ZUdGWlYwbDVVbGhvV0ZkSGFGVlpiWE14WTFaV2RHVkZkRmROVm5CNVZtMHhSMkZHU25Sa1JGWmFaV3MxZGxacVFYaFhSbFoxWWtaV2FWSnVRbmxXYkZKTFVtMVdjMUp1VG1wU2JWSndWbXRXU21Wc1pITldiWFJVWWxaYVdGWXlOVmRXVjBwSVlVaENXbUV4V2pOV1ZWcGhaRWRXU0ZKdGRFNWhla1V3Vm1wSk1WVXlTa2RUV0dSWVltczFZVmxVUm5kTk1WSldWMjVrVjJKVldrbGFSV1J2VlRKS1NWRllaRmRpUjFGM1dXcEdZV05yTVZkaFIyaFRVbFJXV1ZaR1ZtRmtNV3hYWTBab2JGSlhVbkZaYkZaaFUwWmtjbHBIT1doU1ZFSXpWVEo0UzFZeVNsVlNhazVXWVd0YVYxcFdXbGRqTVhCSFdrZHNhR1ZzV2xWV01XUXdZVEZWZVZSclpGaGliRXB5VlRCa1UxZEdiSEpYYms1UFVtMVNlVlpYZUU5aFJscFZVbTVzV21FeFNsUldNakZHWlVkT1NWTnNhRmRpU0VKTlYxaHdSMkV5VFhoVmJrNXFVako0VkZscmFFTmtiRmw0V2toa1UwMVdWalJYYTFadlZtMUZlV1ZIYUZaaVdHaE1WakJhYzJOc1pITmpSVFZYWWxaS05WWnRNSGhrTVZGNFYyNU9hVkpHV2xkVVZ6VnZZVVpzV0dWRmRGaFNNVnBKV1ZWYWEyRldTWGhUYkZaWVlUSlJNRmRXWkU5V01WSjFVMjEwVTJKRmNGVlhWM1JoWkRBMVYxZHJWbE5pVlZwWVZGWmFjMDVXVlhsa1NFNVdZbFZhZWxrd1dtOVhiVXBJWVVWU1ZrMUdjSEpXYWtaclpFZFNSMkZHVG1oTk1Fa3hWbXBLTUdFeVNYaFdXR3hUWVd4d1dGbHRNVk5YUmxwMVkwVktiRkpzV2xsWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVkdUblJoUm1ScFYwVktSVlp0Y0VKTlZrbDRXa2hPYUZKVWJGaFpXSEJYVjBaYVIxcEVRbXROYkZwWVZsYzFUMWRIU25KT1ZteGFZa1phV0ZSclduSmtNWEJJVDFaa1RsSkZXa2xYVkVKdlpERlplVk5yWkdwU2EwcGhXbGQwWVZWR2EzbGpla1pYVFZaS01GbHJXbTlWTURGMFlVWndWMkpVUlRCWlZ6RlhVMFphZFZOck9WZGlWa3BaVm1wQ2ExVXhVWGhYYmxKT1ZtczFjVlp0ZUdGbFZscDBUVlZrV0ZKcmNIcFdNalZ2VmpGS05sRlVSbHBXUlhCTVZUQmtWMUl5UmtkYVJUVnBZa1ZaZWxZeFdtdGxiVlpJVkc1S1QxWnNjRzlWYlRWRFlqRlNWMkZGVGs1aVJuQXdXVEJXUzJFd01YTlhhMmhYVW5wV1NGWnJaRXRUUmxaellVWndhRTFXYjNwV1ZFWmhXVmRPYzFadVNtRlNiV2h3Vm0xNGQxTldaRlZSYkdScVRWWndTVlV5ZUdGWFIwcEhVMjFHV2xaRmNIWlZhMXAzVTBkV1NGSnNUazVYUlVwSFZteGtORlV4VW5OWFdHaFVZVEo0V0ZsWGRIWmtNV3hWVW0xMFZGSnJOWHBXTW5odllWZEZlbEZzWkZkaVdHaG9WWHBHVDFJeFdsbGFSbWhwVmxad2VWWlhlRk5XTVdSSFYydG9UbFo2YkZaWmExcDNWMVpSZDJGSVRsaFNiR3cyVmxjeGIxZHNXa1pYYldoaFVsWndVRmw2U2t0VFIwWkhWV3hTVTFaWVFsbFdha1pyVFVac1dGVlliRmRpYXpWWldXMTRTMVF4V25OYVJrNVhVbTE0ZVZZeWREQmlSMHBJVlc1c1dHRXlhRkJXYWtGNFYwWldjbHBHV2s1aWJFWXpWbTF3UW1WR1dYbFVhMlJvVW0xU2IxbFVSbmRYUm1SelZtMUdhRTFyTVRWVmJYUnJWbTFLV0dWR1VsVldSWEIyVkZkNFlXTXhWbkpVYkdST1lrVlpNRll5ZEZkaE1rWlhWR3RhYWxKdGVHRlpiRkpIVmtaYWMxZHNaR3RTVkZaWFZrZDRUMVJzV25Sa2VrWllZVEZhVkZWVVNrZFNhekZYVjIxc1UxSlVWbGRYVjNSaFdWZE9jMWR1VG1GU1dGSlVWRmR6TVZOc1ZYbGxSM1JXVFVSQ05WbFZZelZXTWtaeVUyNUtWMVo2UmxoYVJWcFRZMnh3U0ZKc1RrNWliV2hoVm14a2QxTXlTWGhYYms1WVltczFiMVV3WkZOVk1XeHpWMjFHVkZKc2NFbGFSV1F3VmpGSmQyTkZiR0ZXVjAweFZtMHhSMk5zVG5SaFJtUm9UVmhDYjFkVVJtRlVNbEpHVDFaa1lWSXllRlJVVmxaM1dWWlplV1JHWkdoTlJFWkpWVzE0WVZSc1pFWmpTRUpXWVRGd1RGWXdXbk5qTVZaeldrWlNVMkpJUWxwV1JscFhUVVpaZVZOcmFGWmlia0poVm14YWQwMHhiRlpXV0doWVZtdGFXbGt3V210Vk1rcEhZMGM1V0dFeFNraFhWbVJUVWpGT2RWTnRhRk5OTVVwVlYxZDBZV1F5VW5OYVNFNWhVa1ZLWVZadE1WTmxiR1J5WVVVNVYwMXJjRmRXTWpBMVZsWmFjMk5JY0ZWV1JWcFVWbXBLUjFKc2NFZGFSVFZvVFRCSk1WWXhVa05aVjBsNFYxaHNVMWRIYUZsWlYzTXhWMFpXYzFkdVpGZE5XRUpYVmpJeE1HRnRTa2xSYTJ4YVRVZFNlbFpxUm1Ga1ZrWnlZMFprYUdFeU9UTldNVnBoVlcxV1IxWnVWbFJoZWxaWlZXMTBkMlJzV2xoTlZGSnJUVmRTU0ZscmFFOWhSa28yWWtab1ZtSllhR0ZVVjNoWFpFZFNSVkZ0YUU1V1dFSTJWMVJDVTFJeFdYaFRXSEJvVW10S1lWWnRNVk5TTVhCV1drVTVVMDFyY0VoWlZWcHJWR3N4Vm1ORVZsZGlXR2hVVldwR2MxWXhUbGxoUm1ScFlYcFdXVmRYZEdGVE1rNUhWMjVLWVZKR1NuSlVWbHAzVTBaWmVVMVZaR2hOUkVaNlZqSjRiMVl3TVhWaFNGcGFWa1ZhVEZWdGVFOWpNWEJIVm14a1YyRXpRa3BXYlhCRFdWZE5lVlJ1VGxkaWF6VldXV3RrVTFReFduTlplbEpzVm14d01GUldVbE5oVlRGWFlrUldWazF1YUZoV1ZFcEdaVzFHUjFwR2NHbFNNbWd5Vm14V1lXTXdOWE5VYmtwaFVtczFUMVpxUmtwa01XUllaRWRHVlUxcldrZFVWV2hyVmtkS1ZsZHNhRnBpUmtwSVZGUkdWMk5XU25WVWJHUk9ZVE5DU1ZZeWRHRlZNV1JIVTFoc2FGTkhVbGhXYWs1VFlVWndSVkp0UmxOTmEzQktWa2N4UjFVeFNuSmpSbVJYVW14d2FGcEVTbGRTTVZwMVZXMTBVMUpWY0ZsV1Z6RTBaREpXYzJKSVNsWmlSMUpoVm0xMGQxZFdXbGhrUnpsWVlrWndXRlp0Y0ZOV01ERkhZMFpvV2sxcVJreFZha1pyWTJzMVdHSkhiRk5YUlVsNVZtMXdSMWxYUlhkT1ZXUldWMGRvVlZsdGRIZFZSbHAwVFZaT2FGSnNXakJVYkZaUFlXeEtjMWRxUW1GU1YyaHlWbXRhWVdNeVRrVlJiVVpUVmpGS1NWZFdVa0psUm1SSFZtNUthVkp0VW5CV01GcExUbXhhZEdWSGRGUk5WVFZJVm0wMVYxVnRTa2RqUnpsYVZrVmFNMVpHV21GVFJURlZWV3h3VjAxRVZqWlhWbEpQWkRKR1IxTlliR3hTVkd4WVdXeFNSbVZzVWxkWGJVWllVakZhU1ZReFpEQlViRnB6WTBSYVYwMXVVbGhaYWtwSFVqRk9kVlZ0YUZOaVYyaG9WMWQwWVZNeFRrZFhiRlpUWWtVMVdGbHJaRk5OVm1SeVYyczVWMDFyVmpaVlYzQmhWMFphUmxOdVNsVmhNWEJoV2xaYVMyTldaSE5hUjJocFUwVktZVlp0TVhkVU1WVjVVbXRrWVZKdFVtaFZiR1JUVjBaU1YxWlVSbGhpUjNoNVYydGpOVlpyTVhOWGFrSmhWbFp3ZWxacVNrdFhWa1p6VVd4a1YxSldjSGxXVjNCSFpERkplR05GWkdoU01uaHZXbGQ0WVZkc1duSlhiWFJzWVhwR1dGWkhkR3RYUm1SSVpVVTVWMkpIVWxSV2FrWlRWakZ3UjFSc1VsTmlSbGt4VjJ4V2ExSXhXWGROV0VwcVVteHdWMWxzYUVOaFJscHpWMjFHYTFKc1ducFpWVnAzWWtkRmVsRnJNVmRXTTBKSVdWUktVMUl4VG5WVWJGWnBWMGRvZDFacVFtdGlNV1JYVjI1R1UySlZXbkJVVjNoSFRrWlZlR0ZIT1ZoU2JWSkpXVlZqTlZaV1drWmpSbEpYVFZad2VsbDZTa2RTTVZKellVWk9hVkpZUW1GV01uUlhZakpGZUZkclpGaGlhelZ4Vld4a05GbFdVbFpYYm1SV1VteHdlRlZ0ZUhkaE1ERlhZMGhvVjJKWWFISldha0YzWlZkR1IxSnNaRTVXYmtKdlZqRmFhMVJ0VmxkVmJrcG9VakpvVkZsdGRFdFZSbVJZVFVob2FXSldXbnBXTW5odllXeEtXRlZ1U2xWV2JGVjRWVEZhVm1WWFVraFBWMmhYWVROQ05WWkhlR0ZqTVZwMFUydGtXR0ZyTlZoV2ExWmhZVVp3UmxaWWFGUldia0pKV2xWYVQxWXhTbk5qUlhSWFlrZFJNRmxxU2twbFJtUlpZVWRHVTFZeWFIWldWekI0VGtaa1IxVnNXbUZTYXpWeVdXdGFkMlZHVm5ST1ZUbG9ZbFZ3U2xWWGRITldWVEZZVldwT1dsWnNjRXhaZWtaclYxZE9SMXBGTldsaVJYQjJWbTEwVTFJeVJYaFRXR2hWWW14YVZsbHJXa3RqUmxaeFUyMDVXR0pIVWxoV1YzUnJWa1V4VjJORmFGcGhNbWhNVmpCa1MxWnNaSFZTYkZaWFRUQXhORlpVUW1Gak1rNXpXa2hPWVZKdFVrOVpWRTVEVTFaa1ZWRnRPV3BOVm13MVZXMDFTMVpIU2xoaFJtUmhWak5TTTFaVlduZFNiR1J5VDFkd2FWSnVRalpXYlRCNFl6RlZkMDFXV21wU1JUVllXV3hvUTFKR1duRlNhelZzVW0xU2VsZHJXbTloVjBWNFkwWmFXRlo2UVhoVlZFcE9aVVphZFZWdGNHeGhNWEJXVm0weE5GbFZNVWRqUlZwaFVsZFNiMVp0ZEhkbFZtdDNWV3RPVjAxV2JEWldSbEpIVmpBeGNWSnJlRmRpUm5CTVdrWmFhMk15VGtoaFIyaE9WMFZLTWxacVJsTlNNV3hYVTFoc1ZtRXlVbFZaYlhNeFlVWldjMVZzWkdsTldFSlpXbFZhZDFSdFNrZGlSRkpYVmpOU1VGWnFRWGhqYlVwRlZXeGthVkl5YURaV2JYUnJVbTFXV0ZKclpHRlNia0p2VkZkNFMwMXNXblJOVkZKYVZqRktTVlp0ZEc5Vk1rWTJWbXM1VjJKVVZrUldNbmhyWXpGYWRHUkdUazVoTVhBMVZrWmFZV0V4WkVoVGJsSnNVbTFvVjFsWGN6RmtiR3Q1WlVoT1YySklRa2hYYTJSM1ZHeFplRk5xV2xoV00xSm9XVlJLUjFOR1NsbGhSM0JUVWxoQ1dsWnRjRTlSTVZKSFZtNUdWR0Y2Vm5OVmJYaExUVlphU0UxWE9WWk5SRVl3V1ZWYVYxZEhTa2hVYWxKVllURndjbFZxUm5kU01YQklVbXhPVTFaWVFqVldhMXByVGtaTmVWWnVUbGhYUjNoeVZXMHhVMVl4VWxoa1NHUlVVbTEwTTFsVlZqQldNVnB6WTBod1drMUdTbEJYVmxwaFl6Sk9SVlJzV21sWFIyaHZWbTE0WVZNeVVraFNhMlJoVWpKb1QxUlZWbHBOUmxwMFpVZEdXbFl3YkRWVmJHaHZWMFprU0dGR1ZscGlXRTE0V1RGYVYyUkhWa1prUm1ST1ZtNUNOVlp0TUhoU01rWkhVMjVTYTFKR1dtRmFWM014Wkd4YWNWRllhRmhTYkZveFdXdGFWMkZXU25WUmJteFhZa1pLVEZWdE1WZGpNVXAxVkcxd1UySldTbmRXYlhSWFUyMVdjMXBJVGxkaVdGSlZXV3hhWVZkR1dYbE9WbVJYVmpCd1NWbFZhRU5YYlVWNFYycE9WMVpXY0doYVJXUlhVMFpLZEdSRk5XaGxhMVYzVm0xd1NrMVdWWGxUYTJSVVYwZFNXVmx0Y3pGWlZteFZVbTVrVGsxV1NsZFdNalZyVmpKS1ZsZHJiR0ZTVjFKMlZsUktTMU5XUmxsYVJtUnBVakZHTTFkWGNFZFpWMDV5VFZaa2FGSXlhRlJWYkZKWFYxWmFSMVp0Um10TlYzaFlXVEJhYjJKR1NsaFZia1phWWtaYWFGVXdXbXRqYkhCSVQxZG9VMVpGU1hwV1ZFbzBVekZaZVZOc1ZsTmhhelZYV1ZkMFlWWXhjRmRYYkdScVRWaENTRmRyWkhOaFIxWnpWMnhXVjAxWFVYZFpWRVpXWlZaU2NscEdhR2xpUlhCNVZsUkNhMVV4WkVkaVNFcFlZbXMxVUZWdE1WTmxWbHBZWlVVNWFGSnNjRlpWYlRWelYyMUZlRk5zVWxkTmFrWkhXbFZrVDFOV1RuTmhSbVJwVTBWS1RsWXhhSGRTTWtWNVZGaG9WbUpyTlhGVmFrbzBWa1pzY21GRlRtdGlSbXcwVjJ0b2ExVXdNVmRXYWxKWVlURmFkbFp0TVVabFYxWklZVVphYVZkSGFFMVdha0poWXpKT2MxcElUbXBTVkZaWVdXeGFTMDVXV25STlNHaHJUVlpHTkZZeU5VOWhWa3BIVjJ4a1ZWWjZWblpaVlZwelYwZFdSbVJHYUZOTlZuQktWMVpXWVdFeVJsZFRXR2hVWWtaYVdWbFVTbEpOUm1SWFdrVTVWMDFXU2pGVk1qRXdWVEpLUm1OR1ZsaFdNMUpvV2tSQk1WWXhaSEpXYkU1cFZsWndXVlpHV21Gak1EVlhWbGhzYTFORk5WZFpiRlpoWld4cmQxZHRPVmhpVlhCSldWVldVMVpyTVVkalNFcFhZV3RhY2xwRlpGTlNNa1pIVkcxb1RrMUZhM2hXYlhCTFRVZEZlVk5ZYUZkWFIzaFVXVmQ0ZDFkR2JIUk5WazVZVW14d01Wa3dWa3RpUmtwelYyeHNXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWa2RVYmxKb1VtMVNjRll3Vmt0U1ZscDBZMFZLVGxacmJEUlhhMmhQWVVaS1ZXSkdhRnBYU0VKWVZqQmFZVkl4Y0VWUmJYUk9Za1p3V1Zac1l6RlVNV1JJVTI1S1QxWnRlR0ZaYTFwaFYwWlNjbGR1U210TldFSkpWREZhYTFSc1NrWlhhMnhZVmtWS2RscEVSbHBsVms1eVdrZHdVMkV3Y0doWGJHUXdXVlpXUjJFemJHcGxhMXBZVkZaYVMwMUdiSEpYYlRsV1RVUkdNRmxWV25kV01rcFZVbFJDV2xaNlJsaFZNRnBoWkZaT2NrOVdaR2xXYTNCYVZtMXdRMkV4VlhoVldHaFlZbXhLVDFadGN6RmpWbHAwWlVkR2JGWnNjREJVVmxaclYwWktjbU5JY0ZkTmFsWjJWbXBHUzA1c1JsVlNiSEJYVWxoQ1RWWlVRbXRXTVVsNVVtdGtZVkpVVm5CWmExWmFaV3haZUZkdGRHeGlWbHBKVmtjMVMxUXhXbk5qUnpsV1lsUldSRmxxUmxOV01rWkdWR3MxYVZKdVFYZFhWRUpYVXpKRmQwMVlUbGhoTW1oWVZXNXdWMU5HV25KYVJYUlVVbXhhZWxsVlduZGhSVEZYWWpOd1YxWkZXbWhYVm1SUFl6RmFkVk50UmxOaVYyaDNWbTB4TkdReFRsZGFSbFpTWWtkU2NWUldXbmRUVmxWNVpVZEdXRkl3Y0VoVk1qRkhWMnhhUm1OSVdsWmhNWEF6VlRCa1YxTkdTbk5VYXpWWVVsVndTRlp0ZUd0T1JsVjRWVzVPV0ZkSGFGVlpWRW8wVjBac1dHUklXbXROVjNoV1ZXMHhNRlpHU25KT1dIQlhUVzVvZGxsV1pFWmxiRVp6V2taa2FWZEhhRzlXV0hCSFZERkplRmRzYkdGU2JXaHdWbXhhZDJWV1dsaGxSazVYVFZkU1NGWXlkRzlVYkZvMllrWmFXbUV4Y0ROV01WcFNaREpHU1ZSc2FGTmlSM2N5Vm14amVHSXhaSE5YYTFwWVlsZG9hRlZzV25kVlJtdzJVMnQwVkZJd1draFdWM2hUVlRGYVdWRnNiRmRoYTFweVZGVmFjMWRHVmxsaVJtUnBZWHBXV2xkWE1UUlRNVkY0VjI1T1lWSnJOVmhWYlRFMFpWWlplV1JFUW1sU01IQkpWbGMxYzFkSFJYbGhSa0pYWVd0R05GWXdXbGRqYkhCSFYyczFhV0pGV1hwV2JURjNVVzFXUjFkWWJGVmhNbEp2VlcweFUySXhiRlZTYm1SWVVtMVNlbFp0TVVkaFJURnlUVlJXVm1KWVVuSldiVEZMVjBkV1IxVnNWbGRTV0VJeVZrWmtORmxYVFhoV2JrcFZZa2RTVDFsclZscE5SbGw1WkVaa2FFMXJXbGhXUjNSaFlXeEtkR1ZIUmxwaVJrcElWbXRhWVdNeFpITmFSM1JUVmtaYVdGWnJaRFJVTVZKelYyNVNhMlZyV2xsWlZFWmhWa1pXVlZOclpGTmhla1pZVmpJeGMxVXhTbFZXYkdSWVZqTlNhRmRXWkU5ak1XUjFWRzFHVTFkR1NsVldSbVI2VFZaT2MxWlliR3hTTTFKWFZGVlNRMDVXYkZaWmVsWlhUV3RhZVZVeU5VdFdNVm8yVW14b1lWSldjRlJaTW5oM1UwWktjMVJyTldsaVYyaG9WbTE0YTJReFRYbFRXR2hZWW1zMVdWbHRjekZpTVZWM1drWk9WazFYZUhwV01qRkhWa1pLYzJORmJHRlNWMUYzVm1wR1NtUXlUa1ppUjBaWFZqQXdlRlp0TUhoU01rNXpWRzVTYUZKdFVtOVVWbWhEWWpGa1ZWSnRSbFZOYkVwSFZERmFhMWxXU1hsbFJsSlZWbXhhTTFkV1dscGxWMUpIV2tkb1RsSkZXa3BXVnpFMFdWWlNjMXBGV21wVFJVcFhXVlJHZDFSR1dYZFhiazVxVFZaYWVsZHJXbE5WTWtwSlVXeHdWMUpzY0ZoVVZWcGFaVlpPY21GR1dtbGlhMHBvVm0xNFlXUXdNSGhpUmxwWFYwZG9XVlp0ZEdGWGJHdDNWMjEwVmsxcmNFcFZWekExVjBaYVJtSkVVbGRXZWtaWVZXcEtUMUp0U2tkWGJXeFlVbXR3VmxacldtcGxSMGw0Vm10a1lWSnRVbGRaV0hCelZURlNWMVpVUmxoU2JWSjVWakl3TldGRk1WWmpTR3hWWWtad2FGWnNXbUZqTWs1SlkwWldWMUpXY0ZWV2JYQkxVakZLYzJORlpHRlNWRlp2VkZaYWNtVldXWGhYYkdSb1RWVnNORmRyYUU5WFIwVjRZMFpzV2xZelRYaFdNRnBYWXpGa2RWcEZOVTVXYkc5M1YyeFdhMDFIUm5KTlZteFNZVEo0YUZWc1duZGpiRnBJWlVVNVUySkZOWGxaTUZwclZHeGFkVkZzYkZoV2JFcE1WVEl4VjFJeFduVldiRlpwVmxad1ZWWnRNREZSTVZweldrWmtZVkpHU21GV2JURlRVMFpzY21GRk9WZGlWVlkxVmxkek5WWldXbk5qUjBaVlZqTm9XRnBGWkZOU1ZrWjBZVVUxVjFkRlNUSldNVkpEVlRGSmVGZFlhRlJYU0VKdlZXMTBTMWxXV25STlZrNVRUVmhDVjFkclZUVlZNREZ5VGxWb1dsWldjSEpXUjNONFZtMU9SVlpzWkdsWFIyaFZWbGh3UjFReVVrZFhia3BoVW0xU2NGbFljRmRrYkZwWVkwVTVhVTFXY0VoV01XaHJWakpGZWxWc1pGWmlWRVpVVmpGYWQxSnNjRVphUjJoT1VrVmFXRlpIZUZkaU1WbDNUVlpvYUZOSVFsaFZhazV2WVVaWmQxZHNaR3BOYTNCSVZqSXhiMkZGTVVoUFZGcFhZbGhDUkZkV1dscGxWbFp5WVVaV2FFMVlRbEpXYlRCNFZURmtSMkpJU21oU1ZUVlFXV3RrVTFac1ZsaE5SRlpYVWxSR1dGbHJVazlXVmxwelYyNWFWMkpVUmtkYVZ6RkhVakpHUjFac1pGZE5WWEJXVm0xd1ExbFdXblJXYTJSaFUwVTFWbGxzYUVOVU1XeFpZMFprVkZac2JEVmFSV1JIVmxVeFYySkVWbFpOYm1oWVdWVmtWMk50VGtkaFJuQnBVbXR3U1ZaR1VrZFdNazVYVTI1V1ZXSkhhRlJaVkU1RFdWWmtWMVp0ZEZOTlZsWTBWakZvYzJGR1NuUmxSbXhYWWxob1RGWkZXbk5qVmtweldrWmtUbFl4U1hoV2JHTjRUVVphUjFOWWFGUmlSMUpZVlcxNGQyRkdjRVZUYkdScVRWZFNlbGxWWkRCVk1ERkhZMFprV0ZZelVsaGFSRXBYWXpKRmVscEhhRlJTTVVwYVZsZHdRMVl3TlVkV1dHeHNVbXMxV1ZsclduZFhSbHAwWTBaT1YwMUVSa2xXVjNodlZtMUdjbU5GYUZaaGExcHlXVEp6TVZkSFNraGlSbVJPWWxkT05GWnRNWGRTTVd4WVVsaGtUMVpYVWxkV01HUnZWbFpzZEdSSVpGWlNiSEF3VkZaYVQyRkdTbk5YYWtKVllrWmFVRmxYZUV0ak1XUnhVVzFHVTFZeWFIbFdiWFJoV1ZkTmVWUnJWbEppVlZwVVZtcEdTMU5XV25GUmJYUlVUVlpzTkZkcmFFOWhWa3AwVlc1Q1YwMUdjRXhVVjNoclZqRldjbHBHVW1sV2JIQTJWbGN3TVZZeFZuUlRhMlJxVTBWS1dGbFVSbmRoUmxaelYyMUdhMUl3TlVkWGExcDNWakpLVjFOcmFGZFNiSEJvVm1wR1lXUkdUbk5oUjJoVFZrZDRXVmRYZUc5Vk1EQjRWVzVTYkZJd1duRldiWE14Vm14V2RHVkhkRlZpUm5CNldXcE9hMVl4V2paUldHaFhVa1Z3U0ZsNlJrOWtWbFowWlVaT2FWWXlhRzlXYlRFd1ZqRnNXRkpyWkZoaE1YQlpXVzF6TVZkR2JISmFSazVPVW14YU1GUldhR3RXTURGeVZtcGFWbFp0YUhKV01HUkdaVVprZEdGR1pGTlNWbkJWVjFod1IyRXhaRmhTYTJSV1lrZG9WRlJYTVc5WGJGbDRWMnhPVkUxV1dubFVWbFpyVjBkS1IxZHNWbHBXUlhCVVZtdGFjMWRYVGtaYVJtaHBVbTVDV2xaR1dtcE9WbHB5VFZoT1dHRnJTbWhXYkZwM1pXeGFjVk5yZEZoV2ExcDZWVmQ0YTFZeFNsZGpTR3hYVmpOQ1NGcEVSa3BsUjA1R1drZG9VMDF1YUhaWGJHUTBXVlprYzFkdVNsaGlXRkp6V1Zod1IxZEdXa2hrUjNSWVVtMVNTVnBWVlRWV01rcElWV3hTVjJGcldsUldha1ozVWpGU2MxVnNUbWxTYkd0NFZqSjRWMkV4U1hoWFdHUk9WMFZ3Y1ZWdGVIZFdNV3h6WVVWT2FGSnNjSHBXTWpGSFlURktjMWR1Y0ZwV1ZuQXpXV3RrUm1Wc1JuSk5WbVJYVFRCS1NWZFdVa3RWTVVsNFZHNVdWV0pHV25CV01HUnZaREZhY1ZGdGRHbE5WMUpZVmpJMVIxVXlTbFpYYmtKVlZqTm9TRlJyV2xabFIwWklUMVpvVTJKV1NrcFhWbFpxVGxaYVYxZHJXbXBTYkVwWVZGWmFkMlZzYkRaVGEyUlRUVlpLZWxsVldrOWhWa3BaVVcxR1YwMXVVbGhaYWtwR1pVWmtjbHBHYUdsaGVsWjRWbGQ0YTA1R2JGZFZiRnBZWW0xU1YxVnRlSGRsUmxaMFpVaGthRTFFUmxoWk1HaHZWakpLV1dGSVNsZGhhMFl6V2xaa1IxSXhTbk5hUlRWWFltdEtkbFpxUm1GaE1WSjBWbXhrVm1KcmNHOVZha3B2Vmtac2RHUkZkRlpTYlZKWlZGVm9iMkZYU2xkWGJuQlhUVzVvZGxsWGVFdFhSbFoxVTJ4V1YySkdWalJXVkVaaFZtMVdXRlZyYUZCV01taFlXVlJPUTA1V1draGxSMFpxVFZad01GVXlkR3RYUjBaeVRsWm9WMkV4V21oWlZWcDNVbXhhV1dGR1VsZGlhMHBLVjJ4V1lWUXhXWGhUYms1cVVsaFNXRmxyWkZKTlJteHhVMnR3YkZKdFVscFpWV1JIVlRGWmVXRklXbGRXZWtJMFZHdGFhMUl4Vm5OWGJVWlRZWHBXZVZkWGRHRmtNbFpIVm01U1QxWlViRzlaYkZaM1UyeFdXR1JJVGxkV1ZFWlpWbGR3VDFkc1duTmpSWGhhWld0YWNsWXhaRTlTTVhCR1RsZHNhVkpZUWpKV2JURXdWVEZKZVZKWWFGUlhSMmhXV1cxNFlWWnNiSEpYYTNScVVteGFlRlV5TURWWFIwcElWV3hvVjFZelVuSldhMVY0VmpKT1JtRkdjR2hOYldoTlZtcENhMU14V25OYVNGWlRZa1phV0ZSVVFYaE9SbHBWVVcxR2FrMXJOWHBYYTJoUFdWWktkRlZyT1ZwV1JUVkVWVEZhYTFaV1JuUlBWM0JPVm0xM01WWlhNREZUTVZwSVUyeG9hRkp0VW1oV2FrNVRUVEZhVmxkdVpGTmlSMUo1VkRGa2QyRldTblZSYWxwWFlsUkNORmw2Umxaa01ERlhWMjF3VTFKVVZsbFhWM2h2VVRGS1IxZHVSbE5oZWxaelZXMHhVMlZzWkhKWGJUbG9WakJXTkZrd1dtRlhSbG8yVVZob1ZsWkZjRTlhVlZwaFpGWldkR05IZUdoTldFSlhWbTB3ZUU1R2JGWk5WV1JxVWxad2FGVnNaRk5pTVZwMFpFaGtiRlp0ZEROV1YzUlBWakF4VjJKRVdsZFNiRXBJVm1wQmVHTldTbkpsUm1ScFVtNUNUVmRyV21GaE1rMTVWR3RvYUZJeWFFOVdNRlpMVFd4YWNWSnNUbE5OVjNoWVZURm9jMVp0UlhsVmJGWmFZbGhOZUZsVldsZGpNVlp6V2tkc1RsZEZTbHBYYkZaaFpERlNkRk5yWkdsU1JrcFlWbXBPVTFWR1duRlJXR2hxWWxWd1JsWlhlR3RoVmtsNVlVUmFWMkpZVW5KVmJURlhWMFpLY2xwSFJsTmlhMHAyVmtaa05GTXdNWE5YYmxKT1ZrWktZVlpxUmt0VFZscDBaRWM1VmsxcldUSldiWE0xVmpKS1ZWWnJVbGROYm1oeVdYcEdZV1JIVWtkVWF6Vm9UVmhCTVZacldtRlpWMFY0V2tWb1ZHSnNTbk5WYlRGdlZqRnNXR042Um10aVIzUTFXbFZvVDFZeVNrbFJhMmhZWVRKU00xWkhlRnBsUms1eFYyeG9WMDB4U205WFZsSkxVakZPUjFOc2JHaFNNMEpVVld4b1ExZHNXblJqUlRsU1RWWktTRlp0TlVkV1IwWTJWbTVPVm1KWWFFeFVWbHBoVTBVeFdFOVdXazVTUlZsM1YxWldZVll4WkVoVGEyaFZZV3hLVmxsVVJuZGpiRlp4VW01a1UwMVlRa2xWYlhoUFZURmFXVkZxVmxkaE1YQnlWR3RhVG1WV1duVlViR2hZVWpOb2VWWlhNSGhWTVZsNFZXeG9hMU5IVWxWVmJURXdUVEZzVmxacVFsZE5WbkI2V1RCb2QxZHJNVWRUYkVKWVZteHdhRmw2U2s5U1ZsSnpWMjFzV0ZJeWFIWldiVEUwV1ZaTmVWVnJhRk5oTWxKb1ZXcEtiMVF4VWxaV2JIQk9VbXh3TUZwVlpFZFhiRmwzWWtSV1ZtSkhhSFpXTUZwclUwZEdSMVpzY0dsWFJURTBWMVJHWVZZeVVraFdhMXByVW0xU1QxWnROVU5PVmxwMFRVaG9VMDFyV2toVk1qVlRZVEZLUjFkdFJtRldNMDE0V2tkNFlXTldSbGxoUm1oVFlrWnZlRmRYZEdGV01rWlhVMjVXVW1KdGVGaFphMXBMVkVaV2RFMVdaR3BOVlhBeFZrY3hkMVV5U2xkVGJtUlhZbGhTV0ZVeU1WZGpNWEJKVkd4a2FWZEdTbFpYVjNoaFdWWmtSMWRZYkU5V2JWSllWbXBDZDFOV2JGWmhSVTVZWWxWV05GWXljRTlXTVZwWFkwZG9ZVkpYVWxoVk1GcExaRWRTUms1WGFHeGhNVll6Vm0weGQxTnJNVmRXV0d4VVlUSlNWVll3WkZOWFZteDBZM3BHV2xadGVGWlZiVFZyVkdzeFYxTnNaRmROYWxaeVZtcEtTMVpzWkhKaVIwWlRWakZLTWxac1VrdFRNVTVYVW14c1lWSnRVbkJWYWtaSFRURmtXR05GWkZwV01EVjVWRlphYTJGR1NYbGhSbEpXWWtaS1dGWXhXbUZTTVZwMFVtMTBUbFl6YUZsWFZFSmhZakpLUjFOc2FGWmlhMXBoV1d0YVlXRkdWWGRYYlhScVlraENTVlF4Wkc5Vk1WcEdVMWh3VjFaRmJ6QlZla1phWlZaT2MxWnNUbWhoZWxaWVYxWmtNRmxXV1hoalJtUllZa2RTY1ZSV2FFTlRSbVJ5V2toT2FGSXhXbnBXTW5oWFZqQXhXRlZZWkZwV1JWcFhXbFphVTJOc2NFZGhSMnhwVWxoQ05WWnNVa05oTVZWNFdrVmthVk5GY0ZsWmJYTXhWVVpXZEUxV1RteFdiSEJaV2xWVk5XRkdTbk5qUmxwV1lsUldlbFl5TVVabFJrNXpWV3hrVG1GcldraFhiRlpyVkRGT1YxUnVUbWhTYlZKd1ZUQldTMVJzV1hoaFNHUlRUV3RXTlZaR2FHOVdiVXB5VGxoR1ZtRnJiekJXYTFwelkyMUdSbFJ0ZEdsU2JYY3dWakowYjJFeFZYZE5WbVJYWVd4S1dWbFVSbUZrYkZwMFRWVmFiRll4V2tsWlZWcGhZVlprU0dGRk1WZGhhMHBvV1hwS1QyTXhjRWxVYlhCVFZrWmFXVmRYZUdGVE1EVlhWMjVTVGxOSGFISlVWbHBIVGtaWmVVNVZPV2hXYTNCSVZqSjRhMVpXV2paV2JscGFWbFp3ZWxZd1pGZFNiVkpIWVVaT1RsWnVRa3RXTVZwWFdWZEZlVkpzWkZSWFIyaFZXV3RhWVZkV2JGVlRiRXBPVW0xU1dGZHJWVFZXTURGWFUycEdWazFxUlhkV1ZFcExVbTFPUjFac2FGZE5NVXB2VjJ0U1FrMVdXWGhhU0VwWFlrVTFjRlpzV25kWFZscEhWMjFHYWsxRVZsaFdiR2h6WVRGT1JrNVdaRnBpUmxwb1dsZDRjbVF4WkhSUFZtaHBWbGhDU2xkV1ZsZFZNVnB5VFZWa2FsTkZjRmhaVjNSaFkyeHdSbHBHVGxOTmExcElWa2N4YjFSck1VWmhNMmhYWWxoQ1RGUlZaRVpsVms1WllVWmtXRkl6YUZWWFZtUTBaREZrUjJKSVVrNVdhelZaVlcxNGQwMVdhM2RXYTNScFVtdHdlbFl5ZUhOWGJWWnlUbGhhVjJGclJqUldNRnBYWXpKT1IyTkdaRmRpYTBsNVZqRmFZVmxXVG5SV2EyUlZZbXhLYjFWdE1WTmpSbGwzVm10MFUxWnNjREJaTUZaTFZHeGFjbUpFVWxoaE1taFFXVlZhUzFaWFNrZGhSbkJZVTBWS1dWWnFRbUZaVmtsNFkwVldVbUpZVWs5WmExcDNWMVphYzFsNlJsVk5WMUpKVlRJMVMxUXhXblJsUjBaYVlURndhRll3V2xOamJHUjFVMjEwVGxkRlNrcFdSRVpoWVRGU2MxTnJXbGhoTW5oWlZtdFdTMlJzY0VWU2JIQnNWbXMxZVZkclpIZFZNa1YzWTBkb1dHSkhVWGRYVmxwWFVqSkZlbUpIY0d4aE1YQlpWa1phWVZNd01VZGlTRXBZWWtVMVYxUldXbmRYYkZaWVpFaGtWMDFyY0ZaVmJGSkRWMnhhTmxKc2FGWk5SbkJvV2taYVQyTnJPVmRhUjJ4WFlUTkNhRlpxUm1GVk1VMTRWbGhvV0dKSFVuQlZNRnBMWTJ4VmQxcEdUbXBXYkhBd1dsVmFhMVJyTVZoVmJteFhWak5vVUZZd1drdGpNazVGVVcxR1YxWnVRbTlXYlRCNFV6RmFWMWR1VmxSaVIxSndWVzAxUTFSV1pISldiWFJYVFZWc05WVnRkR3RaVmtwVlZtNUNXbUV4V21GYVYzaGFaVVprYzFSc1RrNVdNMmhhVm10ak1WUXhiRmRVYTFwWVlrWktZVmxVU2xOa2JHeHhVbXhPVjAxcldrZFdSekUwVmpKS1YxTnNiRmRoYTJ3MFZXcEtSMUpyTVZkWGJXeFRVbXR3V1ZaWE5YZFdNVlpIWWtaa1dHRXpVbkpWYlhoaFRWWldXR1ZIZEdoU1ZFWllXVEJXTkZZeFNuTlhiV2hZVm0xU1QxcFZaRVpsYlU1SVlVWk9hVlpyY0ZGV2JURTBZVEF3ZDAxVlpHRlNiRnBUV1d0a1UyTldVbGRYYms1UFZteFdOVnBGWkRCaFIwcEdUbFZrVmsxdWFIWldiRnBoVmpKT1NHRkdaRk5XYmtKdlYxaHdSMkV5VWtkVGJsSnJVbXMxVDFWcldtRlRWbHB4VTJwQ1dsWnNWalJXVnpWUFYwWmtTR0ZHVmxwV1JXOHdWakJhYzFkSFVrbFhiWFJPVmpOb1YxWlhNSGhOUmxwSFUyNUtUMWRJUWxoVVZ6VnZaR3hzVjFwRldteGlSVnA2VjJ0YWEyRldaRWhoUnpsWFYwaENTRlpFUmtwbFJtUnpZa2RHVTJKWGFIZFdiWGhoWkRKV1YxZHNhR3hTYXpWWVZGWmtVMU5HV1hsa1J6bFZZa1p2TWxscldtRlhiVVY0WTBST1YwMVdjRk5hUkVwSFUxWlNjMkZHVG1sU00yTjVWbTE0YW1WSFNYaGFTRTVZWVRGd1dWbHNaRzloUmxaelYyNWtWbEp0ZHpKVk1uUXdWa1pKZDFkcmFGZFNNMmhRVm1wR1MyTXlUa2RpUm1ScFZrVkpNRlpIZEdGak1XUkhWbXhzYVZKdFVuQlpXSEJYVjJ4a1dFMVVVbFJOYXpFMFZtMDFSMVpYU2taT1dFWlhZbGhvVEZZd1dscGxWMUpGVVcxc1UwMUlRa3BXYkdNeFl6RlpkMDFZUmxOWFIxSmhWbXhhZDJGR2EzbGpla1pYWWtoQ1NGWXljekZoUjBWNFkwVndWMkpVUmpOVlZ6RlhVakZrV1dKR1ZtaE5iRXAyVmxjd2VGVXlTWGhpUmxaVFltMVNXVlZ0TVZObGJGcDBUVlZrYUZKVVJubFVWbEpYVm0xS1dWVnVTbGRpVkVaTVZqQmtSMUpyT1ZkalIyaE9WbTA1TmxaclpEQlpWbXhZVkZob2FsSlhlR2hWYlhoTFZERnNWVk5xVGs1U2JIQjRWVzB3TldGVk1WZGpSRUpXVFc1U2NsbFhlRXBsVjBaSFdrWndhVkl5YUZCWGJGWmhWMjFXUjFwSVRtRlNNMUpVVkZaYWQxTldXWGxrUmxwT1ZteEtlbFl5TlZOaE1sWnlWMnhzV2xaRldtaFdhMXBYVmxaT2NscEdUbWhsYTFwWlZtcEplR014VlhoVGJGWlhZa2RTV1ZacVRsTmhSbVJYV2tVNWFrMVhVakZXUnpGSFZURmtSMU5zVmxkU2JWSTJWRlphVDJNeFdsbGlSM2hUVFRGS1dGWkdWbE5STURWWFlrWmFXbVZzV2xoVVYzUmhaVlpWZVU1VmRGZE5WbTh5VlcxNGIxbFdTbGRqUmxKYVRXNW9NMVV3V2t0ak1WSnlUbGRzYVZZeWFHOVdiVEUwWVRKUmVGUlliRlJYUjJoWldXMXpNVmRXYkhSamVrWnBUVlpXTTFkcldrOVdhekZZWlVod1YwMXFSa2hXYTFwTFl6Sk9SbUpIUmxOV01VWXpWbTF3UjFOdFVYbFVhMXBwVWpCYVdGWnFRWGRsUmxwMFRVaG9VMDFyTlhwV1J6VlRZVVpLZEZWdE9WVldiV2hFV1dwR2ExWldTblJTYkZaT1lrVndTRlpFUm1GaE1XeFhVMWhzYkZKc1NsWldiWGhoVFRGa1YxZHNjR3hXTVVwSVYydGtiMVJzU2taWGEzQlhWbnBGTUZkV1dsTmpNWEJHVjIxd1ZGSlZjRmhYVmxKSFpERlNSMWRZWkZoaWF6VnhWRlphWVdWc1pISlhiRTVXVFd0d1NsVlhlSGRXTVVwelkwWm9WVlpXY0dGYVZscFBZMjFHUjFkdGJHbGhNSEJ2Vm0weE5GbFhVWGROU0docFVteHdXRll3Wkc5WFZscDBaRWRHV0dKSGRETldNakV3Vm1zeGNtTkZjRlpXZWtFeFZqQmFZVkp0U2tWVmJHUlhaV3RhV1ZaWGNFdFVNVXAwVTJ0a1dHSlhlRmxWYlhSM1ZteGFjbGR0Y0d4U01HdzBWbTEwYTFsV1NuUlZiR1JhVjBoQ2VsWlVSbE5XTVZwVlVteG9VMkpXU2pWV2FrbDNUbGRHUmsxV1dtcFRSM2hXV1d0YWQyRkdXbk5YYlVacVRXczFTbGt3V2xkV01VcFhZMFpXVjJKWVFreFZha1pMWXpKT1JscEhSbE5XUmxwMlZrWmFZV050VmxkWFdHaFlZa2RTYjFSV1ZuTk9SbVJ5WVVVNVdGSXdWalJaTUZwelYyeFplbFJZYUZkTlJuQllXWHBHYTJSV2NFWk9WVFZYWWtjNU0xWXllRmRoTURGSVVtNUtUbFp0ZUZOWlZFbzBZVVpXYzFkdVpHcGlSbkJKV2xWVk5WVXlTa1pPV0d4YVRVWndjbFpIZUdGa1ZrWnpZa1pvVjJKRmNFMVdWRWw0VmpGSmVGZHVWbGRpUmxwd1ZteGFkMVpXV25STlJFWlNUVlp3ZWxkcldtdFpWa3BIVTIxR1YySlVSbFJWTUZwelkyMUdSazlXWkdsV1Zsa3hWbXhrZWs1V1dsZFhiazVxVWpCYVZsWnFUbTlYUm5CR1drWk9VMVpyV2pCWlZWVXhWakZrUmxOVVNsZE5Wa3BFVmxSR1NtVkdaRmxoUmxKWVUwVktkbFpYTVRCVE1XeFhWMjVTVGxack5WUlVWbWhEVmpGa2NsWlVWbFpOUkVaNVZHeFdiMWRzV2xkalNFcFhVak5PTkZadE1VOVNWbHB6V2tkc1dGSXlhRlpXYkdoM1VqRlJlVlZyWkZoaWEzQm9WVzB4VTJOR2JGbGpSbVJyWWtad1dWa3dWVFZoVlRGWFkwVm9WMDFYYUhKV2FrcEdaV3hXYzFwR1dtbFdSVnBWVm1wR1lXUXhTbk5qUlZwaFVqSm9UMVZyVm1GWFJscElaVVprYVUxV2JETlVWbHB2WVVaT1NWRnNhRlpoYXpWMldWVmFXbVF4WkhOYVIzQk9ZVE5DU1ZacVNYaGlNa1pHVFZWb1VGWkdjRmhaYkdoRFVrWmtWMWRzY0d4V2JGcDVXVlZhVjJGRk1WbFJiRXBYWWxSQ05GWlVSbXRTTWtwSlUyMW9VMVpVVmxGWFYzUnJWVEZhYzFac2FFNVNSbHBZVld4U1IxZEdiSEpWYXpsWFZteHdlbFl5TldGV01rcFZVbXRrWVZaNlJraFZha3BIVWpGYWMxcEdaRTVXV0VKWFZtMHhkMUV4YkZkWGJsSlhZVEpTYUZVd1ZURldiR3h6WVVWT1ZVMVhlRnBaTUZwclZrWmFjMkpFVm1GU1YxSklWbXhWZUZZeVNrVldiRnBPWW0xb1dWZFdWbXRXTWs1MFZHdGthRkp1UW5CVmJYUjNVMVphUjFWclpGZE5helZZVlRJMVYxWlhTa2hoUmxKYVZrVTFSRmRXV210V01WcDBaRVpPVGxac1dUQldha1p2WXpKR1IxTnVVbXhTYlhoWVdXeG9iMVJHV2taWGJrNXFWbXR3ZWxkcldtdFViRmw0VTFob1YySkhUalJVVlZwaFVqRk9XV0ZHVW1sU01VcFpWbGN4TkdReVJrZGpSVlpVWWtkU2NWUldaRk5sYkd4V1drUkNWazFFUmtoWk1GcHJWMFpaZWxWc2FHRlNSWEJZV1hwS1JtVnNjRWhoUmxKVFRWVndZVlpzWkhkUk1WbDNUbFZrVjFkSGVITlZiWE14VjFac2NsZHVaRmhTYkhBd1dUQmFUMVl3TVVWU2EyeFhWak5vZGxadE1VZGpiVTVHWVVaYWFHRXhjSGxYVkVwNlRWWmtTRk5yYUdsU2JWSlBXV3hrVDA1R1duUk5XR1JUVFZkNFdWVnNhR3RVTVZwWVZXeGtWMDFIVW5aV2JGcHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSa2RUYms1WVlXdEtWbGxyV21GVlJteFlaVVYwYWsxWFVuaFZWekZIVlRGWmVXRkliRmRpV0ZKb1YxWmtUbVZXVW5KV2JFcHBWbFp3VlZadGNFZFRNVTVYVjI1R1VtSllVbFZVVmxwelRrWmtjbUZGT1doV2EzQXdWbGMxUTFZd01VZGpSWGhWVmpOb2NsWnFSbGRqYkhCSFZXMXNWMkpJUVRKV2JHTjNUVlpaZUZadVVsUmhNbEp4VlRCV1MxZEdiRlZTYm1Sb1VteGFlbFl5TVVkaE1VbDNUbFZrV0dFeGNETldha3BMVmpGT2NtRkdaRk5pU0VKdlZtMXdSMWxYVWtkVWJrNW9VakpvVkZaclpEUlhWbVJZWlVjNVZrMUVRalJXVnpWVFlrWkpkMWR1UmxkaVdFMTRWbTE0VjJSSFZraGtSbFpwVW01Q05sZFhjRTloTVZsNFYycGFVbGRIYUZoVmExWjNVMFpzTmxKck9XdFdiRm93V2xWYVQyRldXWGxoUnpsWFlsUkZkMVpxUm5OWFJrcHlXa1pvYUUxWVFscFhWekY2VFZaa1IySklTbUZTYXpWUFZXMTRZVTFHVWxkaFIzUlhUVVJHZVZadGNHRldiRnAwWVVoS1YwMUhVa2RhVlZwclpFZEdSMXBHVGxOV2JrSldWakZvZDFJeVJYaGFSbWhUWVRKU1YxbHNaRFJYUmxwMFRsVk9XbFpzY0RCVVZsSkRWakF4VmsxVVZsWmlXRkp5VjFaYVMyUkdWblJoUmxwcFVqRktWVlpxUm1GV01sSklWV3RzWVZKdGFIQlZhazVTWld4YWNWTnFRazVTTUZwSVZqSTFTMkZXU2tkalIwWlhZa1p3TTFwWGVGcGtNV1J6WTBkNGFWWldjRXRXYWtvMFlURlplRk5zWkdwVFIzaFlWbXBPUTFOR2NFVlNhM0JzVWpBMVIxbFZXazloVmtwVlZtNWtWMkpVUlhkYVJFRXhVakZrZFZOc2FHbFdWbkIyVmtaYVlWWXdNSGhWYkdSWVlsaFNXRlJYZEhkbGJGVjVUbFU1VjJKVmNFaFZNalYzVjIxR2NsZHRhR0ZTVjFKVVZURmFVMk5yT1ZkVWJXeFRZa2QwTkZadGRHdE9SMFp5VGxaa1dGZEhVazlXYlhoM1kxWlZkMkZGVGxwV2JFcFhWMnRqTlZaV1NuTmpTR2hXWWxSR1NGWlVTa3RXYXpWV1lVWndWMVp1UVhwWFYzUnJVbTFXYzFKdVNrNVdiVkpZVkZSQ1MxTldaRmRWYTNSV1RWVnNORlpITlZkV1YwcEhZMGhDVm1KR1NsaFdNVnBoVjBVeFZWVnRkRTVXTTJoWlZtcEpNVlV5UlhoVFdHUllZbFZhV0Zsc1VrWk5SbGw0VjIxR1YwMXJXa2xhUlZwWFlWWktkVkZZWkZkaVIxRXdXV3BHYTJSR1NsbGlSbHBwWWtoQ2FGZHNaREJaVm1SSFlrUmFVMkp0VWxSVVZscExaV3hzVmxkck9XaFdhM0JhVlZjeFIxWXdNWFZWYkdoWVZtMVNSMXBWV2xkWFYwWkhWVzFzYVZKWVFqVldiR1F3Vm1zeFYxcEdaR2xTYkZwVldWaHdWMVF4V25SbFNFNU9UVlpzTlZwRlVrTmhSMFkyVW01c1ZXSkdXbWhXYlhoYVpXMUdTVk5zWkdoaE1GbDZWMnhhYTFJeFNYaFRiazVoVWxSV1dGbHRkRXRrYkZweFVtMUdhRTFXU2pCV2JYaHJWbTFLY21OSE9WWmhhM0IyVm10YWMyUkhVa1prUmxwVFlsWktXbFpHVm05aU1rWllVMnhrV0dKdVFsaFVWelZ2Wkd4c1dHVkZkRmhTYkZveFZUSjRWMVl5U2tkalJGcFhVak5vYUZacVNsTlRSbFp5WVVkMFUySldTbGxXUmxaaFkyMVdWMWR1VWs1WFNFSlFWbTB4VTAxR1ZYbGtSemxYWWxWd2VWWXlNVzlXTWtwSFkwUk9XbFpXY0ROVmJYaGhWMWRHUjFwR1pHbFNiVGt6VmpGYVYxWnJNVmRXV0doVVlrZFNjVlZzYUVOWFJteHpZVVZPVkZKdGVIaFZNblIzWWtaS2RGVnVjRmhoTWxKSVZsUkdXbVZYUmtsWGJHUlhUVEJLVFZkWGNFZFhiVlpJVTJ0c1ZHSlZXbFJaV0hCWFYxWmFXRTFVVW10TmJGcElWbTAxVTFReFdsVmlSemxhWWtaYU0xVXllRmRYUjFKSVQxWmtUbFpYZHpKWFZsWnZXVlpaZVZKdVNtcFNXR2hZVkZaYWQwMXNjRmhsU0dSVFRWaENTRlpITVhOV1JrcFdZMFJLVjJKVVJYZFdWRVpPWlVaT1dXSkdWbWxoTTBKUVZtMHdlRlV5UmtkV2JrWlZZVEExV0ZWdGVHRmxiRnAwVGxkMFYwMUVSbGhaTUZKRFZsWmFjMU5zVWxkaE1WWTBWbTB4VDFKdFJrZGFSVFZwWWtWdmVWWXhXbXRsYlZGNVZteG9VMkV5VW05VmJYaGhWMFpTVlZKcmNHeGlSbkJaVkZaU1UxZHNXWGhUYTJ4WFlsaFNjbGRXV2twbFYwWkhZVVp3VjFKWE9UWldSbFpoV1Zaa1JrMVdiR0ZTYkZwUFZtMHhNMDFXV2xoTlJFWlVUVlp3U1ZVeWVHOWhSa3AwVlcxb1YyRnJOVlJVVkVaaFZteGtkVnBHVG1sU01VbzFWa1JHYTJReVJsZFRibFpTWVd4d1dGbHNVa05PUm13MlVteGFhMDFFUmxoV01qRjNWVEZLVlZac2JGaFdNMmgyVlZSR1MxSXhaSFZTYkU1b1pXeGFlbFpYTUhoVk1sWnpXa2hLV0dKVWJHOVdha0pYVGtacmQxZHRSbGhTYkc4eVZWWm9iMVpzV2taalJUbGhWbFp3YUZwR1dsZGtSMUpIVld4T1YxSnNjRk5XYlhocVpVVTFTRlZZYUZWaVIxSlhXVzF6TVZkR1duSlhiVVpZVW0xNGVsWnROV3RXTURGWVpFUk9WMkpVVmxCV2FrRjRWakpLTmxOc1dsZGlSWEJKVm0xd1FtVkhVbGhTYTJob1VteHdjRll3VlhoT1JscDBUVlJTVjAxck1UUlhhMmhMVkRGYWRGVnVRbHBXUlVveVZGWmFZV1JGTVVsaFJUbFRZbGhvV1Zac1dtOWpNVnBZVTJ0b1ZtSkhhR0ZaYkdodlZFWnNjVkpzWkdwTlZscDZWMnRrYzFSc1pFWlRiSEJZWWtaYWFGbFVSbE5qYXpGWFdrZHdVMUpWY0ZkV2JYaHJZakpTYzFkcmFHeFNXRUp5VkZaYWQyVkdXbGhsU0dSb1VsUkdXbFZYTlhOV01rcFpWVzFvV2xaRldsQlZNRnBoWTIxR1IxRnNaR2xUUlVvelZqRmplRTFHVFhkT1dFNVlZbXhLVDFacldrdFpWbHB4VVZSR2JHSkdiRFZVYkZZd1lVVXhWbU5JY0ZkTmJtaFVWakl4Um1WWFJrWlZiR1JPWW0xb2VWZFljRWRaVjFKSVZXdGtWV0Y2Vm05VVZtaENUVlphY2xkdFJscFdNRlkwVjJ0V2IxWkhTbk5UYms1V1lsUkZNRmRXV21GamJGcDFXa1prVTJKclNrcFhiRlpyVWpGYVIxTllhRmhoTW5oWFdXeG9iMk5zV25GVGExcHNZa1ZhZWxkcldtdFdNa3BYVWxoa1dGWnNTa2hXTWpGWFVqRlNkVlJ0UmxOTk1FcFZWbGQ0YjFFeFpITlhibEpxVWxSc1UxUldXa3RUUmxwMFRsVmtWMUl3V1RKV2JUVlBWbTFLV1dGRmVGVldiSEJvVlRCVmVGZEZPVmRYYXpWb1RUQktURlpzV21wTlYwVjRWMWhzVkdKSGVGTlpWRTV2V1Zac1dHUkhSbXBpUmxwNFZXMDFhMVV3TVhKWGEyeGhWbFp3VUZsclpFdFhWMFpIWVVaa1RsWXhSWGRXTVZwaFl6RlplRlZ1U21GU2JXaFpWV3BLYjJSc1dsaGpSVGxXVFZkU1dGWnROVWRWYlVwMFZXeFdXbUV4Y0doV01WcFRZekZhY1ZGc1pFNVdia0kyVjFSQ2IyUXhaSEpOVldSVVlrVktXVlp0ZUhkaFJtdzJVMnM1VTFac1NucFdNakZ6VjBaSmVXRklXbGRpVkVVd1YxWmFUbVZXVm5KaFJrNW9UV3hLYjFaWGNFdGlNVkY0Vld4YVYySklRazlWYlhoM1RVWndWbHBGWkZoaVJtd3pXV3RTVjFadFNraGhTRnBYVFVad2NsVXdaRWRTTVZwelkwZHNXRkpVUlRCV01WSkhXVlpaZVZWcmFGZGhNWEJ5VlcweFUxUXhXblJPVlU1UFZteHdNRlJWYUc5Vk1ERnlWMnRvVmsxcVZsUlpWRVpMVWpGa2RGSnRSbGROTURFMFYydGtORmxYVGxkU2JHeG9VbTFvVkZsclduWmxSbVJZWkVkR1YwMXJXbGhWTWpWWFZXMUtkR1ZHYUZwaE1YQk1Wa1ZhVjJSRk1WZGFSM0JPVmxoQmVGWnJZM2hrTVZWNVUyeGtWR0p0VWxoWmJHaFRWMFpWZVUxV1pHcE5XRUpLVmtkNGEyRldaRWRUYkZwWVZqTm9hRmRXV210U01XUlpZa1U1VjJKV1NsbFdiWEJEWkRGT1YySkdXbWhTVlRWWldXdGtVMU5zVmxobFJ6bFhUVVJHTVZsVmFFdFdNREZJVld4b1ZrMUdWVEZXYWtaclkyczFWMXBIYkdoTlNFSm9WbTB3ZDJReVVYZE5WbVJVVjBkb1dGWXdaRFJXVm14eVYyNWtXRlp0ZUhsV01qRkhWakF4V0dWSWNGcFdWMDB4V1d0a1MxSXhUblZqUm1ST1lXeGFlVlp0Y0V0VE1WcHpXa2hLYVZJd1dsUldiVFZEWlZaYWNscEVVbFJOVlhCNlYydG9UMkZHU25SaFJtaFdZa1phTTFscVJtdFhSMDVHV2tkb1RtSkZjRWxXVkVreFZqRmFTRkpxV21sU2JXaFhXV3RhUzFkR1dYaFhiVVpUVFZad01GVnRNVEJVYkZsNllVWnNXRlpGU21oWmFrcExVakZPYzJGR1dtbGhNWEJvVjFkMFlWbFhSa2RXV0dSWVlsaFNjVmxyYUVOVFZsRjRXa2M1VmsxV2NFZFZNV2gzVmpGYVJtSjZRbFpsYTFwaFdsWmFUMk14V25OVWJXaG9aV3hhV1ZZeFdtdE5SbXhYWWtaa2FsSnRVbGxaYTJSVFkxWlNWMkZGVGxSU2JIQXdWRlpvVDJGR1NYaFhibkJYVFc1b00xWnFRWGhYUmxaVlVXeHdWMUpWVmpSV1YzQkhZVEpPYzJORlpGaGlWM2hVVkZaV2QxZHNXWGhaTTJSc1VteFdORmRyVm10aFZrNUdZMFpzV21KWVRYaFdWVnBYWkVVeFYxUnRlRmRpU0VKYVYyeFdWazVYUmtkVGJrNXFVbXh3VjFsc1VsZGxiRmw1VFZWYWJGSnJOWHBXVjNoclZHMUdjbGRyYUZoaVJscHlWa1JHVDFZeFVuVlViV2hUWWxaS2QxWlVRbGRUTVZKelYxaG9hRk5IVWxSVVYzUlhUbFphUjJGSE9WZGlWWEI1Vkd4b1IxWnRSbkppZWtKWFlURndlbGt5TVVkU2JGSjBaRWRzVTJKWVkzZFdha293WWpKRmVGWllaRTVXYlZKWVdWZDRTMWRHVWxkYVJ6bHJZa2Q0V1ZwVlZqQlhSa3B6VjI1d1YwMXVhRE5aVlZWNFYxWkdjazFXWkdsWFJrcHZWMWh3UzFReVRYbFVhMXBYWWtaYWIxcFhlR0ZYVm1SWVpFYzVVazFWTlhwWGEyaFBWakpLVmxkdFJsZGlXR2hJVkd0YVdtVkhSa2hrUm1oVFRVWlpNVmRzVm1GaE1WcFhWMnBhVjJKR1NtRldiRnAzWld4WmQxcEdaRk5pVmtwSVZrY3hjMVV4V2tkV2FrNVhUVlp3V0ZkV1pFWmxWa3B6V2taU1dGSXlhRlpYVjNSaFdWWmtSMWR1U2xkaE0xSnZWVzB4VTFkR1pISldWRVpwVW10d01WVlhkSGRXTVZsNllVWkNXbFpzY0V0YVZWcFBZekZHYzJGR1pHbFdNbVEyVm0weGQxSXhVWGhYV0doaFVtMTRjRlZxVGxOV1JsSldWMjVrV0Zac2NFaFdNakZIWVdzeFJWWnNhRmRpUjJoNldWUkdUMUpyTlZkYVJuQnBVbXh3YjFkc1pEUmpiVkY0V2toU1VGWnRhSEJXYkdoRFUyeGtWMVpzWkZaTlZuQjVWRlpXYTJGc1RrWmpSbWhhVmpOU2FGa3llSGRTYkhCSFZHeE9UbUV4Y0VsV2EyTjRZakZTY2sxVldtaE5NbWhZV1ZkMFlXRkdXbkZUYTFwc1ZteGFXbGxWV210WFJrbDRVMnhDVjJGclNtaFhWbVJLWlVaYWRWVnJOVmRTYTNCYVZsY3dlRTVHWkZkalJWcFhZV3RLV1ZWdGRIZGxiRmw0Vld0MFYySlZjRnBXUmxKSFZqRmFSbEpxVWxkTlJuQllXVEZhUzJNeGNFZGFSM2hvVFZaWmVsWnRNVFJWTVVaMFZWaHNWMkV5VWxaWmJYTXhWa1pzY2xwR1RsaFNiRXBXVlZkME1GVXhXbk5qUkVKYVRVWmFURlpIZUdGamJVcEZWV3hvYUUxdGFGRlhWbFpoVXpGYVdGTnJaR2hTYmtKWlZUQldTMWRXV25GUmJVWmFWbXRzTkZrd1ZsZFZiVXBaVldzNVdtRXhjRE5XTVZwaFl6RnNObEpzVms1V01VcEtWbFJKTVZNeFVYaFhibEpzVWpCYVlWbFVSbmRoUmxsM1YyeE9hbUpIVWpGVk1qRXdWR3hrUmxOcmNGZFNSVnBvV1ZSR1UyTXhUbkpYYkdob1RXNW9XbFp0ZEZkVE1sSnpZMFZXVTJKSVFuTldiWE14WlZaa2NscElaRlpOYTFZeldUQmtiMWRIU2toVldHUllWbXh3V0ZWcVNrWmxiVXBJWTBkNGFFMVlRbHBXYTFwaFdWWk5kMDFWWkdsVFJYQlpXV3hTYzFZeFVsWlZhMlJPVW0xNFYxWXlOV3RXTURGeVkwWmFWbUpHU2tSV01uaGhUbXhLYzJGR1drNVNia0p2VjJ0YVlWUXlUbkpQVm1SaFVqSjRXRmxVVGtOWlZscDBUVmhrVWsxclZqUldiR2h2Vm14a1NHRkdiRnBpV0doTVZrUkdZV1JIVGpaU2JYQlhZa2hCZDFkc1ZtdFNNa3BIVjI1T2FsSkZTbFpXYlhoaFkyeFpkMWRyZEdwaVZUVktXVEJhYTFSdFJuTlhha3BYWWxoQ1NGVjZRVEZqTVVwelZteE9hVk5GU2xsV1YzaHZVVEZTVjFkc1ZsSmlXRkpZVkZaV2MwNVdWblJrUjNSYVZtdHdWbFp0TlVOWGJVVjRWMjFHWVZZemFHRmFWVnByWkVkU1NHVkhiRmRpU0VKTFZtMTBhazFXVFhoVldHaFlZbXMxY1ZWdWNITldNV3h6Vld4a1UxSnRlSGhWYlhoUFZqQXhjbGRyWkZkU00wMTRXVlphUzJSV1JsbGFSbWhYVWxWd1dWWlljRXRTYlZGM1RWWnNWV0pIYUc5VVZ6RnZWMVphV0U1WVpGZE5WVFZJVmpJMVMxbFdTbGxWYkZaV1lsaG9hRnBYZUhOV2JHUjFXa2RvVTFaRldsbFhWM0JQWkRGWmVGZHJXbGhpVjJoaFZtdFdZVmxXY0ZaWGJVWnJWbXMxTUZWdGVFOWhWbGw1WVVST1YySlVRalJVYTJSU1pVWlNjMXBIUmxOaVJuQlVWMWQwYTFVeVRsZFZiR1JZWW0xU1ZWWnRlRmRPVm5CV1dYcFdhRkpyY0hsWk1HaDNWbXN4ZFdGSGFGZGhhM0JIV2xWYWEyUkhSa2RhUms1WFltdEtkbFl4YUhkU01rVjVWV3RrVkdKck5WWlpXSEJYVjBac2RHUkZaRTVOVm5CNlYxUk9hMkpHU2xWU2EyaFhWbnBXVUZZd1dtdFRSMFpIVm14d2FFMXNSWGRXYWtKaFZURmtSazVXWkZWaVYyaFVXV3hvYjA1R1dsVlRha0pPVW14V00xUldXbUZVTVZwMVVXeHNXbFpGV2pOYVIzaHpWakZrZEZKc1pFNWhlbFpKVjFkMFlXSXhXWGROU0d4b1VrVndXRmxVU2s5T1JscHhVbXR3YkZKdVFraFphMlJIVlRKS1dHRklaRmRpV0dob1drUktWMVl4WkhOaFIzaFRZWHBXV1ZaR1dtdFZNVTVIVjFoc2ExSjZiRlpaYTFwMlRXeHNjbGR0UmxoaVZWWTBXVEJTVDFZd01WZGpSazVoVWtWd1NGVXhXbE5qTWtaSFZHMXNVMDB5VGpWV2JURTBZVzFXU0ZOWWFHRlRSVFZaV1ZSR2QxZFdiSE5hUnpsb1VteGFlbFl5Tld0V2JFcDBaSHBLVmsxdVVYZFdhMXBLWkRGa2NtRkdaRmROTW1oVlZteFNSMWxXWkZkU2JrNXBVbTFTYjFsVVJuZGxWbHBIVm0xR2FrMVhVa2hXYlhoellWWktkRlZ1UWxwWFNFSllWako0YTFkRk1WVlZiRkpPVm10Wk1GWnFTVEZVTVd4WFUyNUtUMVp0YUZkWmJGSkdUVVp3VjFkc2NHeFdNVXBHVlZjeGMxVXdNVWxSYTNCWFlrZE5lRmw2Um10VFJrcFpZa2RvVTJFd2NGbFhWbVF3VWpBMVIxZFlaRmhpUjFKeFdXdG9RMU5HV1hsamVrWm9WakJ3UjFZeGFIZFdNa3BWVW1wT1ZsWjZSbGhWYWtaclYxZEtSMVp0YUU1aVJYQXlWbXhqZDJWR1ZYbFRXR2hwVW14YVZGbHRNVk5YVmxaMFRWWk9iR0pHY0RCVVZsWnJZVVpLVlZKdWJGVldiRXBZVm0weFMxZFdWblZUYkdScFZrVmFUVlpxUW10V01VbDRWbTVPVjJKSFVsUldNRlpLWlZaYWNsZHRkRTlTYlhoWlZrWm9iMVl5U25KalJscGFZVEpTVkZaRVJuTmpiRnB6WTBVMVUySkhkekZYYTFaaFlUSkdSazFZU2xoaVIyaFlWV3BPVTJGR2JGaGxSWFJyVWpGYVNWVnRlSGRoVmtweVkwVnNWMkpZVW1oWFZtUk9aVVp3U1ZSdFJsTk5NVXBWVm0xMFlWbFdaRWRYYmtwaFVrWktWbFJXV2t0bGJGbDVUbFpPYUUxc1dubFdNbmh6VjJ4YVJsZHRhRmRoTVhCWVZteGFUMk5zY0VkVWJXaHNZVEZ3V2xadGNFcGxSMDE0Vmxob1ZHSkdXbGhaYTJSVFYxWmFjVlJzVG1oU2JWSllWMnRWTldGck1WaFZha1pYVW5wR1NGWlVSbXRTTVU1elZteGtVMkpXU1RKV1JscGhWREpOZUZkc2JHbFNNMmhVVkZSR1MxZEdXa2RXYkU1U1RVUldXRmxyV21GWGJWWnpWMnhvVlZZelVtaGFWbHBXWlZVMVZtUkdaRTVXYlRoNVZsY3hOR0l4YkZkVGJHUnFVbXhLWVZSWE5XOU5NVlYzVjJ0MGFrMVdTbmxVYkdSellWWlplV0ZIT1ZkaVZFVXdXVlJLVW1WR1VsbGlSbEpZVWpKb1dsZFhNWHBOVm1SWFlraFNhbVZyV25CVVZscFhUVEZrY2xkck9WZGhla1paV2xWb2QxWXdNWEZTYTJoWFlURndURmw2U2s5U2JVcElVbXhPVjAxVldYcFdiVEYzVWpGT2RGVlliRlZoTVhCd1ZXcENZVmRHV25GUldHUnNVbXh3TUZSVmFHOVZNREZ5VGxod1YxSjZWbFJaVlZwTFpFWldkRTlXVmxkaVYyaEZWMWR3UjJFeFdsZFRibEpUWWtaYVQxbHJWbmRUUmxwRlVtMUdhRTFYZUZoVk1XaHpZa1pLYzFOc1dsZGlXR2hvVkZSR2ExWXhaSE5qUjNoWFRWVndTVll5ZEd0aU1WSnpVMnRhV0dFelFsaFdibkJHVFVaa1YxZHNUbXBOV0VKSFZqSXhkMVpHU2xaalJtaFlWbXhLU0ZwRVJsTlNNV1JaV2tab2FXRjZWbmhXUmxwaFdWZFdjMXBJU2xoaVJUVlhWRmQwZDFOc1ZsaGxTR1JYVFZWd2Vsa3dXbTlXVmxwWFkwZEdZVlpzY0ZCWk1qRkhVakZrZEdKSGJHaE5TRUoyVm0wd2VFNUdiRmhWV0dST1UwZG9jRlZ0ZUhkWFJsbDNXa2M1V0Zac2NEQmFSV1JIVjBkS1NHUkVUbGROYWtWM1ZtMXplR050VGtaaFJuQk9VakF3ZUZacVFtdFNiVlpIVkc1S2FGSnRhRmhaYkZwTFZsWmFXR05GWkZWTmJFcFlWa2MxVTJGR1NuSk9WVGxWVm14YU0xWnRlRnBsUm5CRlVXeHdWMDFWV1RGV2JHTXhWREZzVjFScldrOVdNbWhYV1ZSR1lWUkdaRmRYYlVaclVsUkdXRlpITVRSaFZrbDRVMnBXV0Zac1dsZFViRnBhWkRBeFdWTnRjRk5pVmtwWlZrWmtkMUZyTVZkWGJrNVlZbFZhY1ZSWGN6RlRiR3QzVjJ4a1YwMVZjRmhaTUZwWFZqSktXVkZyZUZaaGExcE1XWHBLVDFKc2NFaFNiRTVYVW14d01sWnJXbE5STVU1eVRWWmtXRmRIYUZkWlZFRXhXVlphY1ZGdVRrOVNiR3cwV1ZWb1QxWnJNVmhWYTJ4YVZsWndlbFl5ZUZwbGJGSlpZVVprVGxKdVFsbFhXSEJIWVRKU1YyTkZaR0ZTVkZaWlZXeFdkMWRXV25SalJYQnNVbFJHU1ZWdE5WTldSMFY1WlVaT1dsWkZiekJYVmxwVFZteHdSMVJ0ZUdsU2JrSTBWbGN3ZUZJeVJYaFhia3BZWW0xNFlWUlZXbmRqYkd4V1drVmFiRlpVYkZaV1IzaHJWR3hhZFZGdE9WZGlSMDQwVm1wR1NtVkdaSFZXYkdScFVtdHdkbGRzWkRSWlZtUnpWMnhvVGxaRlNuSlVWM2hMWld4WmVXVkhPVlZpUm5CSVZUSTFTMVpXV25SVmJGSldUVVp3ZWxreU1VZFNhemxZWVVaT2FFMXFhRFZXTVdRd1dWZEplRmR1VWxSaVIzaHZWV3BDWVZac1duRlViVGxZVW01Q1IxZHJXazlWTVZweVYycENXbFpXVlhoV2FrWnJVbXhPVlZOc1pFNVdhM0JGVm14U1IxTnRWa2RhUm14b1VteEtXVlV3Vmt0a2JGcFlUVlJDVkUxWGVGaFdNalZUVkd4YWNrNVdVbFZXYldoRVZtcEdhMk5zV2xWV2JGcE9Va1ZhTlZkVVFsZGlNV1J6VjJ4a2FsTkZjRmhWYWs1UFRrWmFkRTFWT1ZOV2JIQjZWMnRrYzFkR1NYbGhSbHBYWWtkU00xVnFTazVsUm1SWllVWldhVkl6YUhaV1Z6QjRWVEpPUjJKR2JHcFNiVkpaVm0weFUxZFdjRVphUldSWFVsUkdlVlJzVm05V01ERnhWbXQ0V0Zac2NFeFZha1pQWkZaT2MxWnNaR2xUUlVZMlZteFNRMWxXWkhSV2JGcE9WbXh3YUZWcVNtOVVNVlp5Vm0xR1QySkdjSGhWTW5CVFlWVXhWMkpFVGxWV2JXaFlXVlZhVDFJeVRraFNiR1JvVFZad2IxWnJWbUZXTWxKSVZtdGFVRll6UWs5V01GWkxVMVphZEUxVVVtaE5WbXcxVld4b2QxVnRSWHBSYkdoYVlrZG9SRlZyV210V01YQkdUbGQ0VjJKRmIzaFdhMlEwWVRKR1dGSnFXbGRpUjFKWlZtcE9VMk5zV2xWU2JFcHNVbTFTTVZaSGVIZGlSMHBHWTBod1YySlVSVEJhUkVGNFVqRldjMXBHV21sU1ZGWjJWbTE0VTFJeFpFZGlTRXBXWWtkU1dGbFljRWROVm14V1YyMDVWMDFXY0VkWk1GWnJXVlphTmxKcmFGWmhhMW96VldwS1QxTkhTa2RVYXpWcFZqSlJNVlp0TUhoT1JsbDRZa1pvVlZkSFVsQldNRlV4Vm14c2RHUklaR2hTYkZvd1dUTndSMVpWTVZkalNHaFdZbGhTTTFsVVFYaFhSbFp6WWtkR1UxWXhTa2xXYlhoV1pVZE9jMXBJU21GU2JGcFlWbXBLYjJWV1duUmtSM1JVVFZad2VsZHJhRTloUmtwMVVXNUNWbUpZVWpOVk1WcGhVakZXY2xwR1pFNWhlbFpaVmxSSk1WWXhXbGhUYTJoV1lYcHNZVlpyVlRGU1JsVjRWMnh3YkZZeFNrbFZiWGhoVkd4WmVGTnJiRmRXUlZwMldYcEtSMUl4VW5KaFJscHBVakpvV1ZkV1pIcE5WbHBIWWtaYVdHSnRVbFJXYlhSM1RVWldkR1ZGT1ZWaVZWWTJWVmQwTUZZeVJYbFVhbEpXWVd0YVYxcFZXazlrVms1MFkwWk9hVlpyY0ZwV2JHTjRUa2RSZVZKclpHcFNWbHBWV1d0a1UxWkdVbGRYYm1ST1ZteHdXVlJXVWtOV2F6RldZMFprV2sxR2NIcFdha1poVG14S1ZWRnRSbE5TV0VKWlYxaHdTMU14VGxkVWJrNVlZbGQ0VkZSV1ZuZGlNVnAwVFVob1RsSXhSalJYYTFwclYwZEtTR0ZJU2xaaWJrSjZWakZhYzJOc1pIVmFSbWhUWWtoQmQxZFVRbUZVTVZsM1RWVldVMkV5YUdGVVZWcDNaR3haZVdNemFHcFdhM0I1V2xWYVlXRkhSWGhqU0d4WVZrVndObFJXV210VFJrNXlZVWRzVTJGNlZscFdWM2hYWXpBMVYxZHVVazVYUjFKVVZGWmtORmRXVm5OaFIzUlZUVlp3V1ZaWGVHdFdNREZJVlc1YVYySkdjSHBhUldSVFUxWndSMWRzVG1sVFJVWXpWbXRhWVZsV1VYbFNhMlJVWW1zMVdWbFhkRXRXYkd4eVYyMUdWbEp0ZUZsYVZWWXdZV3N4V0ZWdWFGWldla1pJVmxSR1dtVlhSa2xpUm1ScFYwWktiMVl4V210VWJWWlhWVzVLVjJKRmNIQldiRnAzVmxaYWRHTkZaRlJOVlRWWVYydGFhMVp0UlhkalNFNVdZbFJHVkZVd1dtRmtSVFZXWkVkb1YyRXpRWGRXYkdNeFVURlpkMDFWWkdwU1dHaFdXV3hvYjJGR2NFWmFSbVJVVWpGS1NGWlhjekZXTVZwSFYydHdWMkpVUWpOVVZscGFaVVphZFZWc1VtaE5iRXA0VmxjMWQyTXhiRmRYYmtwWFlsVmFUMVJXV25kVFJsbDVUVlZrVjFKcmNGWlZiWGhoVmpGWmVtRkVUbGRoYTBZMFZXeGFZV05XWkhOaFJtUnBVbGhDVWxZeWRGTlRNVWw0VTFob1ZXSkhlSEJWYWs1dlZrWmFjbHBFVWxoV2JWSlpXbFZhVDFVeVNsZFhibkJYVmpOb2NsWXdaRXRXYkdSellrWmFhR0V4Y0c5V1ZFWmhWVzFXUjJORlZsSmlSbHB3VlcwMVEwNXNaRlZSYkU1YVZteHNNMVJXYUZkV2JVcElZVWRHV2xZelVqTlZNRnBYWTFaS2NrOVhkRmRpUm05M1YxWldZVlF5UmxkWFdHeG9VbnBzV0ZSV1pGSmtNV1JYVjJzMWJGSnNTbmxYYTFwdllVVXhWMk5HVmxoV2VrSTBWbFJHYTFJeVNrbFRiVVpUWVhwV1VGWnRNVFJrTVU1WFZXeGthRkl6VWxoVVZWSkhaVlphZEdOSFJsZGlSbXcyVlZjeGIxWXdNVWRqUjJoV1lsaG9VRnBHV2s5ak1WcDBZVVUxV0ZKVmNGcFdha28wV1Zac1YxVlliRlZYUjJoeFZXeGtVMVl4YkhOYVJGSllVbXh3TUZSc1ZrOVhiRnB6WTBSQ1ZWWnNTa1JXYWtGNFZtc3hWVlpzWkZObGJGcFJWMVphWVZReFNuTmFTRTVXWWtoQ2NGVnRlSGRpTVZwMFpFZEdWazFXYkRSV01uaFhWVEpLV1dGSVFsWmhhelYyVkd4YVlXTldUbkZSYXpWVFRVWndTVlpxU1RGVE1rWlhVMnRrYWxJd1dsaFphMXAzVFRGd1dHVkdjR3ROVjFKNldUQmtOR0ZXV2xkalJYUlhZV3R2TUZsVVJscGxSazV6V2tkd1ZGSXphRmxXYlhCUFVURk9SMk5GVmxOaE0wSnpWV3BCTVZJeGJGWlhhemxvVm10d1ZsWnROV3RXTWtwVlVsaGtZVkpGUlhoVmFrWnJaRlpPYzJGSGJGZFdia0l5Vm10YVlWbFdXWGROU0doV1lrZFNXVmxzYUZOWFJsSllaRWhrYkdKR1ZqVlViRlUxVmpKS1ZtTkZhRlpOYWxZelZqSXhSMk5zWkhSaFIwWlRWakZLVlZaVVJtRlZNazV5VDFaa1ZXSlhlRlJaYTJRd1RrWmFkR1JIZEU5U01GcDVWR3hhYTFkR1pFaFZhemxYWWxob00xa3hXbFprTWtaR1ZHeHdWMkpGY0ZoV01uUnFUbFphVjFOdVRtcFRSMmhYV1d4U1IxTkdXbFZUYTNSWFlYcFdWMWxWV25kV01WcDFVVmh3V0ZZelVuSlZiVEZYWXpGS2RWTnJOVmRpVmtwWlZrWlNRMU14VGxkYVJtUldZVE5TVjFSV1ZuTk9SbHBJVGxaa1YxWXdjRWhaTUdoRFZtMUtSMU5zYUZkTlZuQm9WakJWZUZaV1ZuUmtSVFZYVFRKb1dsWnRjRXBOVmxWNVVsaG9WRmRIVWxsWmJGWmhWMFpzYzFWcldrNVNiR3cwVmpJeFIxWXdNWEpYYTJ4aFVsWndXRmxXV2t0a1ZrWlpXa1prYVZJeFJYZFhWM0JIWVRKU1IxTnNiR2xTYkhCd1dXdG9RMkZHWkhOYVJFSmFWbTFTU0ZsclVtRlZNa3AwVld4U1ZWWnNjRXhhVjNoelZteGtjazlYYUZkaE0wSmhWbFpqZUZJeFdYZE5XRlpXWWtkb1dWWnRNVk5TTVhCV1YyeGtXRll3V2toV1Z6RnpZVlpLV1ZGcVZsZGlSMUYzVm0xemVGWXhjRWRhUjJ4VFlrWndWbGRXYUhkV01WRjRWMjVTYkZORk5VOVVWbHB6VGxad1JsVnJUbWhTTUZreVZXMDFjMVpYU2tkWGJXaFhZbGhvWVZwWE1VZFRWazV6V2tkb2FFMUdiRFpXTW5oaFlURkplRk5ZYUZSaWF6Vm9WV3hTVjFkR2JIUmtSWFJyWWtad2VGVnRNVWRoUlRGWFUycENWMkpZYUhKV2JURkxZMjFPU0U5V1dtaGhNMEl5Vm0xMFlXTXlVa2hWYTFwclVteHdWRmxzV2t0WGJGcEhWbTA1YVUxcldsbFZNbmhyVjBkS2RWRnNhRlZXZWxaMldrZDRjMWRIVmtaa1JtaFRZa1p2ZUZaVVNqUldNVmw1VTJ0a2FsSkdjRmhWYWs1dllVWmFjVk5zVGxSU2JGcDVXVlZrTUZVeVNsZFRiR3hYVW14YWFGa3lNVmRXTVdSMVZXczFXRk5GU2xGV2JUQjRWVEF4UjFaWWJHdFNlbXhZV1d4V2QyVldXWGxOVnpsWFRXdHdTRmt3VWs5WGJGcFhZMFJPVm1KWWFHaFdNV1JIVWpGd1IxcEhiRk5pVkd0NlZtcEdZVll4V25KTlZtUlhWMGRvVlZsclpGTmpWbFp6WVVWT1dGSnRlSHBaVlZaUFZrWktkR1ZJYUZaTmJsSXpXV3RhUzJSR1ZuVmpSbWhvVFd4S1NWWnNVa2RYYlZaWVVtdHNXR0pIVWxoVVZFSkxWRlprV0dORlpGaGlWbHBKVlRKMGMxWkhTbFpYYkZKYVYwaENXRll4V21GWFJURlZWVzEwVG1KR2NFbFdiVEF4VlRGUmVGZHNWbWxTZW14aFdXdGFZVTB4VlhsbFJtUllVakZLU1ZReFdtdFViRnBZWkhwS1dGWnNXblpYVmxwYVpWWktkVk50Y0ZOWFIyaFpWa1phWVdRd01YTmpSbWhzVTBkU1ZGUldhRU5UUmxwSVRWaE9WMUpyY0ZkWk1GSkxWakpLVlZKWVpGZFdSVnBQV2xWYVQxZFhTa2RXYld4b1RUQktVVlp0TUhkbFJsVjVVbXRrVjJKcldsWlpWRUV4VjBaV2RHVkhSbXhpUm5Bd1ZHeGtNRll3TVVWU2JHaGFUVVpLUkZac1dtRmpNVTV6Vld4a2FFMVdXVEJXYlRCNFZERktkRkpyWkdGU1ZGWndXV3RXZG1WV1dYaFhiWFJzWWxaR05WWnRlRzlWTWtWNVZXMDVWbUpZYUdoV01GcFRWbFpLY21OSGVHbFNia0phVmtaYVUxVXhaSE5YV0doVVlUSjRXRmxzYUZOamJHUlhWMnR3YkZZd1draFpWVnAzVmpGS1dFOVVXbGRTYkZwb1YxWmFhMUpyTVZkaVIwWlRZa1p3VUZadE1IaE5NREZYVjJ4b1RsSkZXbFZVVmxwM1UxWlZlV1ZIT1doU2EzQXdWbGN4YjFZeVJuSk9WbEpWVmtWYWFGWnRlR3RrVm5CSFZHMXNVMDFWYnpGV2ExSkhZVEpSZVZKc1pGUmliRnBUV1ZkNGQxZEdiSE5WYTA1UFVtMTNNbFZ0ZUdGaE1ERkZVbXhvVjAxcVJqTldWRVpMVmxaYWMySkdhRmROTW1neVZsWlNSMU14U1hoYVNGWlRZa1UxYjFwWGVHRmxiRnBZVFVob1ZrMXNXbnBYYTJoTFYwZEtWV0pIT1ZkaGEwcFlWR3RhY21ReFpIUlNiR2hUWWtjNGVWWldXbTlpTVZwelYydGFhbEpVYkdoV2JGcDNZVVp3UjFkc1pHdFNNVXBJVmxkNFQxWXhTbk5qUms1WFlsaG9jVnBWVlRGVFJsWlpZVVpXYVZJeFNsaFhWekY2VFZaa1IxZHVTbGhpVlZwWlZXMHhOR1ZzV25ST1YzUlhUVVJHV1ZwRlVrOVdNa3BWVm14Q1YyRnJSalJXYWtwTFVsWmtjMXBHVG1sU1dFSktWbTB4ZDFGdFZraFZiR2hUWVRKb1ZGbHNWbUZYUmxKVlUyMDVXRlp0VW5sV2JURXdWVEF4Vm1KRVVsaGhNbWhNVmtSR1lXTnJOVmxSYkhCWFVsVnZlVlpHV21GWlYwNVhVMjVTVUZZelVrOVdiR1F6VFZaYVdHVkhPV3BOVm5Bd1ZXeG9jMVp0U2tkWGJVWmFZa2RvVDFwVlduTldiR1J6V2tkd1RsWnNjRFpXTW5Scll6RlNjMXBGV2xSaVNFSlpXV3RhWVdGR2NFVlNiRTVyVW1zMWVWZHJaSE5WTVVweVkwWnNWMkpZUWxCV1ZFWlhVakZrZFZKc1NsaFNNbWg0VjFkNFYyUXhTbk5YYkdoc1VqTlNiMVp0ZEhOT1ZteFdWVzFHVjAxcmNGcFdWelZMVm0xS1ZWSnNhRmROUm5CTVdUSjRkMU5HU25OVWJXeG9UVWhDYUZadGVGTlJNVmw0VkZoa1QxZEZOVmxaYlhoTFZERmFjbGRyZEZwV2JIQjRWVzEwTUZkR1duTmpSV3hoVWxkU1NGWXllR0ZqYlVwRlYyeGtWMlZzV2tWV2JUQjRVekZrV0ZKcmFGTmlSbHBZV1d0b1EyVldaRmxqUldSYVZqRktTRlV5TlZOaE1VcFZWbTA1VlZaRlNreFZNbmhoWXpGV2NtTkZOVmRpUlZrd1ZqSjBWMkl4V2toVGJrNVVZbXMxVjFsWGRFdGhSbHAwWlVkR2FrMVlRa2hXUjNoaFZHeGFjbU5HYUZkaGEydzBWV3BHV21WR1pIVlRhemxZVWpOb1dsZFdVa2RXYXpGWFlrWmtXR0V6VWxsV2JYUmhaV3hrY2xkdGRGZE5hM0JZVld4b2ExZEdXbk5UYTJoWFRXcEdXRlZxUmxOa1ZsSjBVbXhPVGsxRmNGWldiR1EwWWpGRmVGcElUbGhpYTFwVFdXeFNjMVV4VWxkV1ZFWlVVbXhzTlZSc1drOVdWMHBIWTBSQ1YxWXphSFpXYkZwaFl6RmFXV0ZIUmxkTk1tZzJWMVJLTkdReFRsZFZiazVZWVhwV2IxUlVRa3RVUmxwelYyMXdUbFl3VmpSV01XaHpWa2RLU0dWR1pGcGlXRkl6Vm0xNGMxWldTblZhUjNCcFVteHdORlpYTURGaE1WVjNUVmhLV0dFeWVHaFdiRnAzVlVac2NscEZkRmhXTUZwR1ZrZDRhMkZGTVZsUmJUbFhUVlp3YUZaSE1WZFNNVloxVTIxR1UySlhhRnBXVjNCUFlqRldWMWR1VW14U2VteFhWRlprVTFkR1duUk9WV1JXWWxWd01GWlhlRzlXVmxwelkwaHdWV0pHY0ZSWmVrWmhaRWRTUjFwRk5WZGlhMGt5VmpGa01GVXhiRmRYV0doWVlXeHdWRmx0ZUhkWFJteHpWV3RrVkZKdGREVmFWV1F3WVRGSmQxZHJhRmROYmsxNFZsUkJlRlp0VGtkalJtUnBVakZKZWxaWGNFZFdiVlpYVld4c2FGSnRhSEJaYTFaM1pERmFXRTFZY0U1V01EVklXV3RhVjFWdFNrbFJhemxXWWxob00xUlZXbmRXYkhCR1drWm9hVkp0ZDNwWFYzUlRWakZhZEZOcmFHaFRSbkJZVkZWYWQyTnNWWGRhUldSVFRWWndlbGt3WkhOWFJrcFZVbFJDVjAxV1NraFhWbHBhWlZaV2NtRkdaR2hOV0VKNVZsY3dlRlV4VVhoWGJsSlBWbFUxVUZadGVIZE5SbEpXWVVjNVZrMUVSbmxXTW5SdlZtc3hjVlpzVWxwV1JWcE1WV3BHYTJSR1NuUlNiR1JPVFVSRk1GWXlkR3RPUm14WVZHeGtVMkpIZUc5VmJURnZWa1pzY2xkdVdteFNiVkpaV2tWa1IxWXdNWEpYYkdoV1RXcFdXRlpYTVV0a1IxWkhZVVp3YUUxWVFrMVdhMVpoVmpKU1JrMVdaR0ZTTTBKUFZteG9RbVZHV25KWk0yaHJUVlpXTlZVeWVHdFdSMHBHVTJ4b1dtSkhhRVJWTUZwWFkxWkdXVnBIZUZOaWEwcEpWakowWVZsWFJrWk5TR2hVWWtad1dWWnFUbTloUm1SWFYyMTBVMDFYVWpGV1YzTTFWakpLVjFOc2JGZGlXRUpFV2tSR1QxWXlTa2RYYkdocFlYcFdXVmRYZUZkWlYxWlhWMWhzYTFKR1NsaFVWVkpIVFZac1ZtRkZkRmROUkVaSlZsZDRiMVpyTVVkV1ZFWlhZV3RhY2xreWN6RldNWEJJWWtkb1RsTkZTbTlXYlRCM1pESlJlVlZZWkU1V2JWSlZWakJrYjFkR2JIUmxSWFJYVm0xNGVWWXlOV3RYUmxwMFpVaHNWMDFxUmtoV2FrRjRWMGRXU1dOR1pGZE5NVXB2Vm10a05GTXlVbGRTYms1b1VtMVNUMWx0TVc1bGJHUllaRWRHV2xac2NGaFdNalZQWVZaSmQxZHNVbGRoYTFwTVZGZDRZV014Vm5Ka1JsSk9WbFJXV1ZaWE1UUmpNV3hYVTI1U1ZtSnJTbGRaVjNSaFUwWlNWVkp0ZEZoV01EVkhWMnRrYjFSdFJqWlNWRUpYVFc1U2RsWkVTa2RTTVU1MVZHeG9hVkl5YUZoWFYzUmhaREF3ZUZkWWFGaGlXRkpZVkZab1ExSnNWbGhOVkVKVllrWndlVmt3Vm5OV01rWnlWMjVhV21GclduSlZNRnBMVjFkS1IxZHRiR2hOV0VKdlZqRmtNRmxXYkZoU2EyUlhWMGRTV1ZsdGRIZGpiRkpYWVVWT1UySkdjRmxVVm1NMVZtc3hWMk5GWkZaTlYyZ3pWbXBHWVZKdFNqWlJiRnBvWVRGd2FGZHJVa0psUm1SWFYyNVNhRkpyTlhCV2FrcHZZakZhZEUxVVFsZE5WM2hZVm14b2IyRnNTbk5qUm14YVYwaENlbGt5ZUdGa1IxWklVbTE0YVZKdVFrcFdSbHBxVGxaYVdGTnNXbXBTVjFKaFZGVmFkMWRHV25GUldHaFlVbXhhV2xkclduZFdNVXBYWTBab1dHSkdjR2hXVkVwUFl6Sk9SbHBIYUZOTmJtaDNWbGQ0YjFFd05WZFhiazVXWVRBMWIxUldXbGRPUm1SeVZtMTBhRlpyTlVkWk1GcHpWMjFLV1ZSWWFGZFdWbkJZV2tWVmVGWXhVblJsUm1ScFUwVktZVll5ZUZkV2F6VllVbXRrVkdKck5YRlZiWGgzVmpGc2MxVnNaR3hpUm13MVZGWldZV0pHU25KT1dIQlhWak5vY2xaSE1VZGpiR1J5WVVab2FWSnNjSGxXYTFKSFZERlplRlZ1VmxWaVYyaFVXV3hhUzJReFdsVlJiR1JVVFZaS2VsWXhhRzloUms1SVZXeFNWVll6VWxoVWJGcGhVakpHU0U5V1pHbFdXRUkxVmtkNGIxSXhXblJTYmtwcFpXdEtXRmxVUm5kbGJHdDVUVlZrVTJKR1NqQmFSV1J6VlRKS1dWa3paRmRoYTI5M1dXcEtSbVZHV2xsYVJUVlhZbFpLV1ZkV1pEUlRNV1JYWWtaV1UySlZXbkpaYTFwM1RVWlNWMVp0Um1sU2JHdzBWakowYzFkc1dsZGpSMmhhVm14d2NsVXdaRWRTYXpGWFdrZG9hRTFJUW5aV01XaDNVekZSZVZSWWFHcFNWM2hXV1d4b1ExWkdXbkpYYlVaWVZtMVNXVnBWWkVkV1JURkZWbXhvVjAxcVZsUldSM2hQVTBkR1NWTnNWbGRpU0VKSlZrZDBZVmR0VmxaT1ZscFFWakpvV0ZsVVRrTlRWbHB4VTJwU2FFMVdjRmhXTW5CaFZqSktjMk5IUmxkaVJuQXpXbGQ0V21ReGNFZGFSazVwVm10d1NWZFdWbUZVTVZKelYyNVdVbUV6VWxoVVZscDNWMFprVjFwRldteFdhM0I2VjJ0YVUxZEdTWGxoUmxwWVZqTlNhRmRXV210V01rcEhWbXhTYVZKWVFsQldWekI0VlRGa1IxcElTbGRXUmxwWVZGVlNSMWRHVlhsalJXUlhZWHBHZUZWc2FHdFdNVnBHWTBWNFZtSlVSbEJWYWtaaFl6SkdSMXBGTlU1V1dFSXlWbXBLTUZVeFJuSk5WbVJZVjBkb2FGVXdWbmRYUm14eVZsUkdhbEpzY0hwV01qVnJWMFphYzJORmFGZE5ha1pJV1ZkemVGSldXbk5oUm1ScFVqSm9ObGRXVWtkVU1VcHlUbFprWVZKdVFuQlZiWGgzWWpGa2MxcEVVbXBpVmtZMFYydG9VMVZHV25SaFNFSlhZa2RvUkZVeWVHdFdNVnB6V2taYVRsWnVRalZXUmxwWFlUSkdjMVJyV21wU2JXaGhWbXBPVTJGR2EzbGxTR1JUWWtoQ1NGWkhlRTlVYlVWNFkwVnNWMkV5VGpSWmFrWlRZMnN4VmxkdGFFNU5iV2haVjFkNGIxRXhVa2RWYkZwaFVsWndjMVp0Y3pGWGJHeFdWMjEwV0ZKcmJEWlpWVnBYVjBaYWRGVlVRbUZTUlZweVZXcEtTMU5XVm5KT1ZtUm9aV3hhWVZac1kzaE9SMUYzVFZaa2FFMHlVbGhaVkU1VFkwWldkR1JJWkd4aVJtdzFXbFZvVDFkSFNsZFhibXhWWWtkb2FGWnFTa2RqYkVweFZXeGtUbEp1UWxsWFdIQkxWREZKZVZSclpHRlNiVkp3V1ZSQ2MwNVdXbkZTYlVaYVZtMTRXRlpITlZOV01rVjVWV3hhV21KWWFFeFpha1pYWkVVeFYxUnRjRk5pUjNkNlZtMHhNRTFHVlhoWGJrNXFVa1ZLWVZSVldtRlVSbHBJWlVkR2FtSlZjRVpXVjNodllVVXhkR0ZHUmxoV2JGcG9WWHBHWVZkR1RuSmFSMmhUWW10S1dsWlVRbGRUTVdSWFYyNUdVbUpWV21GV2JYUnpUa1pyZDFac1pGWmlWWEJhVmxkek5WZHRSWGhqUkU1WFRWWndhRmw2Um5OT2JFcHpWbXMxVjAxVmNFdFdiRkpLVFZaTmVGVllhRmhpYkVwelZXcENZVmxXYkZWU2JtUm9VbXhzTTFZeWVFOWhiVXBJVldwR1ZrMXFSWGRXUjNoclVteE9jbU5HWkZOU1ZuQnZWMVpTUjFVeVRYaFVia3BZWWtkb2IxUlhOVzlYYkZwMFpFWmtWRTFzU25wWk1GWlhWVEpLU1ZGdVRsZGlXRTE0V2xaYWEyTnNjRWxhUmxwT1lURlplbGRVUW10aU1XUklVMnRvVmxkSFVsbFdiWGgzVjBaV2NWTnJXbXhpVlhCSldUQmtOR0ZGTVZsUmJIQlhZVEZ3YUZkV1drNWtNREZXV2tkc1ZGSllRbHBYVjNoVFl6RlplRlZzV2xaaE1sSlBWVzB4TkZZeFdYbE9WM1JYVFVSR2VWa3dXbUZXYlVwSFUydFNWMDF1YUdoVWJYaExZekpHUjFkck5WTmlhMHAyVmpKMFlWbFdVWGxVYmtwUVZtMVNhRlZxU2pSWFJteFZWR3RPV2xac2NEQlVWbWhyVldzeGNsWnFVbGRpUjJoMlZtMTRhMU5IUmtkaVJuQnBWMGRvVFZaclVrZFpWMUpJVkdwYVUySllRbGhaYTJoQ1pERmtjMVp0ZEZOTmEzQklWakkxVDJGc1NrWlRiRnBYWWxob2FGa3llRnBrTVdSeVpFZHdhVlpVVmt0WFZFSmhZVEZTZEZKdVRsaGhhM0JZV1d4b1ExTkdWalpSVkVacVRWVndlbFp0ZUU5aFZrNUdVMnhzVjFZemFIWlZWRVpUVmpGa2MxWnNTbWxYUmtwWlZrWmFWMk13TlZkV2JsSnJVak5TWVZadGRIZFdiRnAwVGxWT1dHSlZWalJXTWpGSFdWWlplbUZIUm1GV1ZuQnlXa1ZrVTFOSFZraGlSbVJwVTBWS1RGWnRNVEJoYXpGWFZGaG9WbGRIYUZsWmJYTXhZMVpXZFdOSVRsZE5WM2g2VmxkNGExVXhTblJsU0doV1lsaG9VRlpxUVhoamJHUnlXa1prVTAwd01UUlhWbHBoVXpKU1YxSnNiR0ZTYldoWVZXeFdkMWRXV2xsalJYUlRZbFpHTTFSV1duTldWMHBJWVVjNVZWWjZSblpXTVZwaFYwVTFXVnBHWkU1V1ZGWkpWbXBKTVZNeGJGZFRiR3hXWWtaYVYxbHNhRzloUm5CWVpVaE9WMkpIVWpGWGEyUnZWVEZhUmxkc2JGaFdNMEpRV2tSR1dtVkdaSEpYYkdocFZqSm9XbFp0TUhoVk1WWkhZa1JhVTJKVlduSldiWE14VFVaV2RHVkZPV2hXYkd3MVdWVlNUMVl5U2xWUmFsSlZZVEpTVTFwVldsTmpNWEJJVW14T2FWSnVRbFZXTVdRd1lURlZlVlJzWkZaaVIxSlpXVzB4VTFaV1duUmxSbVJQVm01Q1YxZHJWbXRYUmtweVlrUk9XazFHV25aV2JYTjRZMVpLY21GR1pFNWliV2h2Vmxjd2VGUXhUbGRhU0U1WVlsZG9UMVl3VmtkT2JGcHpWV3RPYUUxV2JEUldSM1JyVmtkS2NrNVdXbHBYU0VKWVZqRmFWMk14V25WYVJsSlRZa2hCZDFkc1ZtdE5SbEY0VTI1T1YyRnNTbGhXYm5CWFZVWlpkMWR0ZEZSU01GcElWbTE0ZDFZeFNsaFBTR1JYWVd0S2FGbDZSbXRUUmxaeVlrWm9hVmRHU2xCV2JYQlBZakZaZUZkc2FFNVRSMmhQVlcxNGQxTkdWWGxPVlhSVlRWZFNTbFZYZUc5V1ZsbzJWbTVhWVZJemFIcFdha1ozVW14a2RHVkhiRk5XYmtFeVZtcEtNRmxYUlhsU2JHUmhVbGRvYjFWdWNITlhSbGwzWVVWT1ZGSnNjRVpWYlhSM1lrWktkRlZ1Y0ZwaE1sSklWbFJLUzFkSFJrbGFSbVJwVjBkb2IxZHJVa3RXTVZsNFdraE9hRkl6YUZSWldIQlhWMVphUjFkdGRGWk5WVFZJVmpGb2MyRXhTalppUmxwYVlURndNbFJYZUhOamJHUjBVbXhvYVZaV1dUQlhWRUpUVkRGWmQwMVdaR3BTYXpWb1ZXdFdkMU5HVlhoWGJFNXFUV3RhU0ZaSE1YTlZNREI1VkdwV1YySlVSVEJaVnpGWFUwWk9XV0ZIUmxSU1ZGWmFWMVpTUjJReFpGZGlTRTVoVW5wc2IxVnRlR0ZsYkZsNVRsZDBWMkpGY0RCYVNIQkxWbXN4ZFZWWVpGZGhNWEJMV2tSR2EyTnRSa2RhUm1ST1RXMW9WbFp0ZUZOU01XeFhXa1prVTJKck5YQlZiVEZUWWpGc1ZWSnVaR3hXYkhCSVZtMHhSMkZyTVZoVmEyaFhZbGhvZWxsV1drdGtSbFoxVVd4d1dGTkZTbGxXYWtvMFlURmtSazFXVmxaaVJrcFBWbTEwV2sxR1duRlRWRVpWVFZkNFdGVXlOVXRVTVZwMFlVWmtXbUpHU2tkVVZWcDNWakZrYzJOSGVGZE5WWEJIVmxaamVHTXhWWGROVld4U1lUTkNXRmxyWkU1bFJtdzJVbTEwVkZKcmNGcFphMlJ2VlRKRmQyTkdiRmhXYlZGM1ZXcEJNVkl4WkZsYVJtaHBVakZLZUZkWGRHOVJNVTVIVjFoc2FtVnJXbTlXYWtKM1VqRlplR0ZJWkZkTmEzQldWVzF3VDFac1dqWlNiR2hXWVd0YWNsWXhaRXRTTVZwMFlVVTFhVkpZUVhsV2JYaHFaREpXUjFaWWJGUlhSMmh3VlcxNFlWWkdiSFJOVms1WVZteGFNRlJXV2s5aVIwcEhZMFJDVlZac1duSlpWVnBMVmxaS2RXSkdWbGRpUlhCWlZtMHdlRk14WkZkV2JsWlVZa2RTY0ZaclZtRlVWbHB4VVcxMFYwMVZiRFJXYlRWUFZqSktTRlZzVWxkTlJscExXbFphWVdOc1pIUmtSVGxUWWxob1dsWnJXbTlpTVZsNVUyNUthbEpzY0dGWlZFcFRWa1phUlZKdVRtcGlSbkI2V1RCVk1WVXlTa2hrZWtaWVlURmFhRmxVU2tkU2F6RlpVMnhvYVZJeWFGbFdWM0JQVlRKR1IySkdhR3hTV0ZKeVZXcEdZVk5XVm5SbFNHUm9WbXR3ZVZrd1ZuTldNa3BaVlcxb1dGWnRVazlhVlZwM1UxWlNkRkpzVGs1TlZYQldWbTB4TUZsV2JGZGFSV1JZWW10d2FGVnJXa3RXYkZKWFYydDBiR0pHYkRWVWJGcFBZVVV4YzFkdWJGZE5ibWg2VmpKNFlWSnNaSFJoUm1Sb1RWaENXVlp0ZUdGVU1rNXpZMFZrVldKWGFITlpWRVozVjJ4YWRHTkZjR3hTTURFMFZteG9iMVpIU2tkWGJHaGFZVEpTVkZZeFdtRmpWbEp6Vkcxb1UySldTbGxXTW5SV1RsZEdjazFXYUZaaGExcFlWVzV3UjFOR1dsVlNiWFJUVFZVMWVsWnRlR3RWTWtwWFUxUktWMUpzY0doV1JFcE9aVVprYzJKSGJGTk5NbWhWVmtaU1IxTXhaRWRYYTJSWFlrVTFVMVJWVWxkWFJteHlWMjFHV0dKV1ducFdNbmh2VmxaWmVsVnRhR0ZXYkhCWFdsWlZNVlp0VWtkYVJUVlhZbFJvTlZac1kzaE9SMGw0WWtaa1ZHSkhVbkZWYlhoTFdWWlNXRTVYT1U1TlZsWXpWakowTUdGck1WZFRibXhWWWtkU2VsbFdXbHBsVjBaSVQxWmthVlpGVlhkWFZsSkxWVzFXUjFWc2JHbFNiRXBaVldwS2IxZHNaRmhOV0hCT1ZtMVNXRmxyYUZOaGJWWnlWMjVDVlZac2NGaFVWRVpyWTJ4a2NrOVdaR2hsYTFwYVYyeFdiMlF4V1hkTldFWlRZVEpvV0ZsVVJuZFVSbXcyVTJzNVUySlZjRWxWYlhoUFZqQXhWbGRZY0ZkaVZFWXpWV3BHYTJSR1ZsbGlSbFpvVFZoQ2QxWlhjRU5aVm1SSFYyNUdWR0pVYkZSV2JYaDNUVVpTVm1GSE9WZFNWRVpaVmxkNGIxWXhXWHBoU0hCYVZsWndURnBHV2tka1JUbFhZMFprVTFadE9UWldiVEUwV1Zac1dGUnNaRk5pYkVweVZXMHhVMVF4V25OaFJVcHJUVlp3ZWxkclVrTmhSVEZZWlVab1ZrMVhhSHBaYTFwTFl6Rk9jMWRzWkdsWFIyaHZWa1pTUjJFeFdYaGFTRkpUWWxoQ2NGVnFSa3BrTVZwWVRVaG9hazFXU2pCVk1uUmhWMFphUmxOc2FGcGhNbEpQV2xWYVlWSldTblJrUmxKVFlYcFZlRlpVU25wT1ZtUkhVMnhrYWxKdGFGbFdhazV2VmtaV2NWTnNUbXBOV0VKSVYydGFiMkZYUmpaV2JHeFhZbFJHTmxSV1ZYaFNNVlpaWVVab2FWSXhTbGhXUm1Rd1pERmtSMVpZYkd4VFJUVllWRmQwWVdWV2JIRlViWFJYVm14d1dGa3dXazlaVmxwelkwWkNXbVZyV25KYVJXUlBVakZTYzFwRk5XbFdNbWd5Vm0wd2QyVkZOVWRpUm1oV1YwZFNUMVV3Wkc5alJsWjBaVWhrV0ZKc2JETlhhMk0xVjBaYWMyTkVRbUZTVjFKSVZqQmtTMU5IVWtWVWJHUk9ZV3RGZUZkV1ZtRlpWMDUwVTJ0V1ZtSkdjSEJWYWtwdlpWWmFkR05GZEZOTmF6VXdWVEowVjFadFNraFZiVGxhVmtWYU0xbHFSbXRXVms1MVkwVTFWMkpIZHpCWFZFSlhZakpHUjFOdVNrOVdWR3hXVm0xNFlVMHhXblJsUm5Cc1VtNUNSbFZYZUhkV01ERldWMVJHVjJKSFRYaFdSRVp6VmpGU2NsZHJPVmROYldoWVYxWlNSMWxXVWtkYVJtUllZbFZhY2xWc1VrZFhSbHBJWlVjNVZrMXJjRmhWTW5CWFZqSkdjbUo2UWxwV1JWcG9Xa1ZhVDJNeFpIUmpSazVwVTBWS2IxWXhXbE5UTWtsNFZHdGtXR0pyTlZsWmJGWmhZMVpTV0dONlJsUmlSM1F6VmpKNGExWXdNVlpqUm1oYVRVWndXRlpxU2t0WFZrWnlaVVphYUdFeGNFMVhXSEJMVkRGS2MyTkZaR2hTTW1oeldXdGFkMDFzV25KWGJVWmFWakExTUZadGRHdFhSbVJJWVVac1dtRXlVbFJaYWtaVFZqRmFkVlJyT1ZOaVIzY3dWMVpXYjFReFduSk5XRXBxVTBkNFlWUlZXbmRTUmxweFVWaG9VMDFyTlVaV1IzaHZWakpLU1ZGdE9WaFhTRUpJV1ZSS1UxWXlUa1poUjNoVFlsWktkMWRXVWtOa01XUnpWMjVHVkdGclNsaFpXSEJYVjBaYVYyRklUbGRTTUZZMFdUQm9SMVpyTVVoaFJWSllWbXh3YUZsNlJtdGtWbkJJWTBkc1UySnJTa3RXTW5oWFZtczFWMVpZYkZSaE1YQlFWakJrTkZsV1VsWlhibVJxWWtad1NWcFZaRWRoTVZweVYyNXdXbUV4Y0haV2FrcExVbTFPUmsxV1pGZFNWM2N3Vm0xd1IxTnRWa2RhU0ZaWFlrZFNjRlZ0ZUhka01WcDBaVWRHYTAxV2NGaFdNalZUVkd4S1JsZHNUbFZXYkhBeldsZDRhMk5zWkhSUFYyaE9WbGhCZDFac1l6RlRNVnBYVjI1U1ZtSkdTbGRVVlZwM1lVWlpkMXBHWkZSU01VcElXVlZhVDFSc1RrWlNhazVYWWxob2NWcEVRVEZXTVdSMVZXeFNhVkpzY0ZWWFYzUmhVekZrUjFWc1dsaGliVkpoVm0wMVExZEdaSEpXVkZaVlRXdHdSMWt3VWtOWGJVVjRZMFpDV2xac2NGQlZiWGhQVmxaT2MxcEhiRk5oTTBKT1ZqSjBVMUl4VG5SV2EyUmhVbTE0YjFWdE1XOVhWbFYzVm10MGEySkdjRmxVVldodllWVXhXR1ZHYUZkTmFsWlFWakJrUzFOR1ZuTlJiRnBwVjBkbmVsZHNWbUZXYlZaWVZHcGFWMkpHY0U5VmExWmhUbFphU0dWR1pHbE5WMUo2VmpKNGEyRnNUa1pqUm1oV1lXczFVRlJyV21Ga1JURldUMVpPVjJKSVFqWldNblJyWXpGa1IxTlliR2hTYkhCWVdXdGtiMDB4Vm5GU2JFcHNWbXhhZVZkcldtOWhWMFY2VVcwNVYxWjZRalJXVkVwUFVqSktSMkpIY0ZOaVZrcDVWMWQwWVdReFpGZGhNMlJYVmtaYVYxbFljRWRsVmxKWFZXeE9XR0pWVmpSWk1GcHZWakZhTmxKcmVHRlNWbkJZV1hwR2QxSXhaSFJpUm1oVFRXMVJNbFp0TVhkU01XeFhWbGhvV0dKc1NsUlpWRXB2VlZaYWRFMVdUbWxOV0VKWldrVmtSMWRIU2tkalNIQllWMGhDU0ZsVVFYaFhSbFoxWTBaa1RtSnNTbTlXYTFKSFlURktkRlJyWkdoU2JrSllWRlJHU21Wc1duSldiVVpZWWxaYVNGZHJhRTlaVmtsNlVXczVXbFpGV2pOVk1WcGhaRVV4VlZWdGFFNVdhM0ExVmtaYVlWbFhSbGRUYTJScVVtMW9ZVmxyWkc5U1JsWnlWMjEwVjAxWFVqQmFSV1F3VlRKS1NWRnFXbGhXYkZwb1dWUktSMUpyTVZsVmJXaFRZVE5DV1ZkWGVGTlJNRFZIVjJ4V1UySkZjSE5WYlRGVFRWWmFTR1ZJWkdsU01IQkhXVEJvZDFZeVNsVlNWRUpoVWtWR05GVnFSbGRqTVhCSFYyMXNVMVpHV2pKV2JURTBWVEZKZUZwRlpHbFRSWEJYV1d0a1UxZEdiSE5XYm1SVVZtMTRWMWxWYUd0V01ERnlZMFphVm1KWVVuSlhWbHBoVG14S2NtRkdXbWhoTVc5NlZsZHdTMVF4U1hoalJWcFBWbFJXV0ZZd1ZrcGxWbHAwVFVob1QxSnNiRFJaYTFwdlZteGtTR0ZHVmxkTlIxSjJXVlZhVm1ReFduVmFSMmhUWWtad05GWnJaREJVTVZwV1RWWmthVkpGTlZoWmJHaFNaREZhY2xwRmRGUlNiRnA2V1d0a1IxVXhXWGhUYTJ4WFlsaG9WMXBWWkU5ak1YQkpWRzFzVTJKSVFuZFdWM0JMWWpKV1YxZHVSbEppVlZwaFZtMTBkMDFHV2toa1IzUm9VbXR3TVZWWE5VTldiVXBaVldwT1ZrMVdjR2hWYWtaWFkyeHdSMXBGTldobGJGcGFWbXhTU2sxV1dYaFhiR2hVWVRKb1YxbFljSE5aVmxweVZsUkdVMUpzVmpSV01uaDNZa1paZUZOcmJGWmlXR2hvVmtkNFdtVkdUbkppUm1SWFVsWndNbGRZY0V0U01VbDRWVzVLYUZKc2NIQlZha3B2VjFaa1YxcEljRTVXYkhCSVdXdGFZVmRIU25SVmJGSlhZbGhTTTFSVldsZGtSMVpHVDFaV2FWWldXVEpXVm1Rd1RVWlplVkpZYkZWaGJFcFhXVmQwWVZZeGNGWlhhemxyVm1zMU1Ga3dXazloVmxweVkwWndWMkpIVGpSVWEyUlNaVlpLY2xwSGNGTldiSEJXVjFkMGExVXhXa2RWYkdSWVltMVNUMVp0ZUhkWFZsSlhWV3RPVjJGNlJsZFpNRnByVjJzeFIyTkljRmRoYTFwb1ZHMTRTMVpXUm5SU2JFNVRWbFpyZDFac1pIZFNNa1Y1VkZoc1UyRXlhSE5WYlhoTFZrWmFjbGR0Um1sTlZuQXdWRlZvYjFSc1NYaFNhbEpZWVRGd2NsWXdaRVpsVmxaeldrWndWMUpZUWxWV2FrSmhWVEZaZUZwSVZtRlNhelZQVm0xNGRtUXhaRlZSYlVaVlRWWnNNMVJXYUV0WFIwcDBaVWRHVlZaV2NETlZhMXBoWkVVeFZtUkdaRmRoTTBJMVYyeFdZVmxYUmtoU1dHaHFVMGQ0V1ZsVVJtRmpiRlkyVW10d2JGSnNXakZWTW5NMVZqQXhkV0ZHYkZkU2JWRXdWVzB4VjFJeFpIVlZhelZZVWpGS1ZWWkdXbXRPUm1SWFZtNU9hRkl6VWxaVVZscDNWMVphV0dWSGRGZE5SRVpKVmxjMVlWWXlTa2RqU0hCaFVsZFNWRlV4V25kU01XUnpWRzFzVkZKVldYcFdiWFJoV1Zac1YxVlliRk5oTWxKVldXMXpNVmRXYkZoa1JYUlhZa2Q0ZVZZeU1VZFdiRXAwWlVac1lWWldXWGRaVjNONFYwWldkV0ZHV2xkbGExcEpWbXhTUjFkdFZsaFNhMnhwVW0xU2NGWXdXa3RpTVZsNFYyMTBWV0pXV2xoV1Z6VkxWakpLUm1OSVFsZGlSbkF6Vm14YVlXUkhUa1phUmxKT1ZsUldXVlpxU1RGU01WWjBVMnhzVm1KR1dsWldiWGgzWld4U2NsZHRkR3BpVlZwSFZERmtiMVl5UlhwUldHUlhZa2ROZUZWVVJscGtNREZXV2tkd1UxZEhhRmRXYlhCUFlqSk9jMWR1UmxOaVIxSnhXV3RvUTFOR1dsaE5XRTVYVFd0d1NsVldVa3RXTWtwSVZHcE9WVlpzY0dGYVZWcGhaRlpXYzFWdGFFNWlSWEEwVm14U1ExWXhUWGhhUldScFVteGFWRmx0TVZOaU1WWjBaVWRHYkdKR2JEVlVWbFpyWVVVeFZtSkVUbFZpUmxweVZqQmtSbVZIVGtWVWJHUm9ZVE5DVFZadGNFZFVNazUwVW10a1lWSnJOWEJWTUZaTFpHeGFkRTFZWkZOTlYzaFpWbGQwYTFaWFNuSk9WemxXWVd0d2RsWnJXbUZqYkhCRlZXeG9WMkpXU2xwWGJGWnFUbFphY2sxVlZsSmhiRXBZVm01d1YxWkdiSEpYYTNCclRWZFNNVlZ0ZUd0aFZtUkdUVlJTVjJKVVJUQldha3BUVTBaYWNtRkhkRk5pUm5CM1ZsY3dNVkV3TlhOYVJtaHFVbFJzYjFSV1duTk9SbGw1WTBkR1ZtSkhVa2xaVlZwdlZtMUZlRmRxVGxaTlJuQjZWRzE0UzJOck9WaGtSbVJwVW0wNU0xWXllRmRaVmxGNVVteGtXRmRIZUc5VmJuQnpWMFpzYzFWcldtdE5WbkI0VlcwMVQxZEdTbkpqU0d4WVlURndkbGxWVlhoWFZrWnpZMFpvVjJWcldUSldSbHBoWVRGSmVWTnJiRlJpVlZwVVdWaHdWMVZHV2xoTlZGSmFWbFJHU0ZaWGVHdGhSa2w2Vld4b1ZWWldTa2hhVmxwaFpFZE9TRkpzWkdsU2JrRjNWMVpXYjFNeFdYZE5WV2hXWVRKU2FGWnNXbmRqYkhCR1drVmtVMDFZUWtoV1IzaFBWakpLY2xOc1pGZGhhMXAyV2tSR1NtVldTbGxoUjBaVFlsZG9WVmRXVWt0Vk1WbDRZa2hPWVZKR1NsbFZiWGgzVFVaU2MxWnJPVmhpUm5CNldUQlNRMVpXV25OVGExSlhZV3RHTkZadGMzaFdWbHB6VjIxc1dGSnJjRFZXYWtaaFdWWk5lVlZyWkZkaWJFcHZWVzE0ZDJOR1ZuRlNhM1JYVm14d2VGVnRNVWRXTURGelUydHNWMVl6VW5wWFZscExaRWRHU1ZGc1dtaGhlbFpVVjJ4a05GbFhUbGRVYmtaU1lYcFdWRlJWV25kVFZscHhVMVJHVkUxcldsaFZNblJyWVd4SmQxZHNhRnBoTVhBelZGUkdkMWRIVmtkalIzUk9WakZLTmxkVVFtdE9SMFpYVjJ4a2FsSllVbGhaVjNSMlRVWnNWVkpzY0d4U2F6VjZWMnRrZDFaR1NYcGhSbXhYWWxoQ1VGVlVSazlTTWs1R1ZteE9hRTB3U25wV1YzQkNUVlpKZUdKR1dsaGhlbXh2Vm0xMGQxWnNXblJPVjNSWFRXdHdWbFZzYUd0WlZrcEdVbGhvVm1GclduSmFSbHBQWXpKR1NHSkdaRmRpYTBsNVZtMTBZVmxXYkZkWFdHUk9VMGRvVjFsclpGTlhWbXh6WVVaT1dGSnNTbGxhUldocllrZEtSMVpxVmxWaVJsVXhWbXBLUzFadFRrWmhSbHBPWVd4WmVsWnFTWGhTTWs1eldraFNhRkl3V2xSV2FrWkxWbFphVlZKdFJsWk5helY1VkRGYWExWlhTbGhsUmxKYVlUSlJkMVJyV21Ga1IxSklaRVU1VTAxR2NEVldSM2hoWVRGa1IxcEZhRlpoZW14WVdXeG9iMDB4YTNoWGJGcHJUV3RhUjFaSGVIZFdNa3BHWTBab1YwMXVVbkZVYkZwaFZqRk9kVlJ0Y0ZSU01taFlWMWQ0VTFJeFRrZFhiRlpVWVROU1dGbFljRmRXTVd4V1YyNWtWMDFXY0RGVlZtaDNWMFpaZWxWdVNsWmlWRVpZV1hwR1MyUldUbkpPVm1ScFZtdHdXbFpyV2xOUk1VMTRWR3hrWVZKdFVsZFpWRTVUVmpGU1YxWnVUazlTYkhCSlZHeGFhMVl4V1hkalJXaGFUVWRvUkZadE1VdFNNVTV6WVVaa1RsWnVRbTlXYWtKV1pVWmFWMVp1VW10U1ZGWllWRlJLYjFkc1duUmpSWEJPVm14V05WVnNhRzlXUm1SSVZXeHNXbUpHV21oV01GcHpZekZXY2xkck5WTmlSM2N3Vm1wSmVGSXhXWGROV0VwWVlUSjRhRlZzV25kWFJteFhWMnQwYTFacldscFhhMXByWVZaSmVGSllaRmhXTTBKSVdWUktVMUl4VG5OaVIyeFRZa2hDZDFkWGRHOVJNa1pIV2toT1lWSkZTbUZXYlRGVFUwWnNjbFZ0UmxaTmEzQXdWbGQ0VTFaV1duTmpSWGhoVmpOb2VsWnRlR3RqYXpsWVlVWmthRTB3U21oV2JGcHFaVVpKZUZkWVpFNVhSbHBYV1d0a2IxZFdXblJOVms1VFRWaENWMVl5ZUd0WFJsbDNWMnRvVjFaNlJucFpWbHBMVjFaR2NWWnNaR2xTTVVZelZtMHhlbVZHV1hoalJXUmhVako0VkZsclduZFdiR1JYWVVoa1YwMVdSalJXTWpWVFlrWk9SazVWT1ZWV2JIQjZWR3hhZDFKc1ZuSlViV2hUVFVacmVWWlhNREZqTVZwWVUydGtXR0pYYUZoWmJHaHZXVlp3V0UxVlpGUldhelY2VjJ0a2IyRkZNVWRpUkZwWFRXNW9hRmxVUmtwbFJrNVpZVVpTYVdGNlZtOVdWM2hUVmpGa1IySklVbXRTV0ZKeVdXdGFkMlZHVm5STlZXUm9VbFJHV0ZVeWNFTldNa3BaWVVoS1YySlVSa3haTWpGUFUwVTVWMWR0YUdoTk1FbDVWbTB4TUZsWFRYbFZhMmhXWVRGd2NsVnRlSGRXUm14elYydDBXR0pHY0VoV2JUQTFZVlV4Y2xkc2JGWk5ibWh5VmpCa1MyUldSbk5oUmxaWFpXeGFNbGRyWkRSak1XUklWbXRhYTFKdGFGUlphMXAyWlVaYVZWTnFVbGROVm13MVZUSjBhMkZzU2tkalJtaFdZV3MxZGxsVldtRmpWazV6Vkd4U1UySkdjRFZYVmxaclRVWlZlVk5zWkZSaVIzaFlWVzE0WVdGR2EzbE5WbVJYVFZkU01WWlhjekZYUms1R1UyeEdWMkpVUWpSV1ZFRjRVakZhV1dKSGRGTmxiWGhaVjFkNFYyUXlWbGRYV0d4T1ZucHNXRlJYZEhkVFJtdDNWV3M1V0dKR2NGaFpNRkpQVm0xS1dXRkhhRmROVjFKSVZXcEdkMUl4Y0VoaVJrNXBWa2QwTmxadGNFZFpWbGw0VjI1S1RsWnRVbGhXTUdSdlZsWnNjbHBHVG1wV2JGcDZXVlZXVDFkR1NuUmxTSEJhVmxaYVVGWnJXa3RrUjFaSllVWmFUbUpzU1hwWFYzUmhVekpTUjFadVZtcFNiV2h2VkZkNFMxTldXbk5WYTJSWVlsWmFXVlZ0ZEhOWFIwcElWV3hvVlZaRlNreFdSbHByVjBkT1JscEdhR2xXYkhCS1ZsUktNR014V2toVGJGcFlZa1pLWVZZd2FFTlhSbGw0VjIxR1dGSlVSbFpXVnpFd1ZHMUtSMk5GYkZkaVZFRjRWbFJHVW1WR1pITldiV3hUWlcxNGFGZFhkR0ZaVlRCNFZsaHNiRkp0VWxsVmFrWkxVMVpSZUZkdGRGVmlSbkJaV2tod1MxZEdXbk5YYmxwWVZteHdZVnBXV2t0a1ZrNTBZMFpPV0ZJeWFGcFdhMXBoV1ZkUmQwMVlUbXBTYldoelZUQmtVMVpHVWxkaFJVNVVVbXh3U1ZSV2FFOVdNVXB5WTBaa1drMUdTa3hXYWtwTFZsWktXVnBHWkZkU1ZuQlFWMnhXWVZReFpGaFRhMlJYWWxkNGIxUlVRa3RWVmxwMFRVaGtiRkpzVmpWVmJYUnJWakpLY2xkc1dscFdSVVY0VmpCYVYyUkhWa2hTYlhocFVtNUJkMVpIZUd0TlJsbDNUVlZXVTJKSGFHRlVWVnBMVWtaYWMxZHRSbXBOVlRWNlZsZDRhMkZGTVZkWFZFSlhZbFJDTkZaRVJrdGtSa3B5V2tkR1UxWkdXbmRYVjNSWFpHMVdWMWRZYUZoaVdGSnpXV3hhUjA1V1duUmxSemxXVFd0V05WWlhNRFZXYlVwWllVZG9WMDFHY0ZSV2JGcExZMjFPU0dWSGJGTmlhMHBoVm10YVlWVXhWWGhhU0U1WVYwZG9WVmxVU2pSWFJteHpZVVpPYW1KSFVsaFdNblIzWWtaWmQxZHJhRnBXVm5BelZtcEdTMWRGT1ZWWGJHUlRZa1p3YjFZeFdtRmhNVXB5VFZaa2FWSXdXbFJaYTFwM1ZVWmFkRTFJYUU1TlJFWllWako0YjFSc1NrWlhiRlpWVm14d00xVXhXbFpsVjFaSVQxZG9VMkV6UVhkV2JHTjRZakZaZVZKdVNrOVdiRXBXVm10V1lXRkdXblJsUjNSclZtNUNTRlpITVhOVk1ERldZbnBHVjJFeFNraFpWRXBTWlZaS2MxcEdVbWxpUm5CVVYxWmtOR1F4WkVkaVNFNVdZVEExVUZWdE1UTk5iRlowWlVkR2FFMUVSa1pWYlhodlZqQXhjVkpxVGxkV1JWcE1WbXhhWVdNeVNrZGhSbVJPVFcxbmVWWnNXbE5TTVUxNFUxaG9ZVk5HV2xSWmExVXhZakZ3V0dWSFJteGlSbkJaVkZWb2IxWnJNWE5YYm5CWVlUSm9URll3WkV0V1YwcElUMVprYUdFd2NGbFdSM1JoWTIxUmVGcElVbE5pUjJoVVdXdGpOR1ZXV2xkWGJUbHBUVlp3ZWxZeWRHRmhiRXBWWWtkb1YySkdjRE5aVlZwM1VqRmtjMXBIZEZOTlZYQkpWbXhrTkZReFdYaFRiazVxVW1zMVdGbHNhRzlqVm5CV1ZsUkdWRkpzV2xwWlZWcFhZVlpKZUZOc2FGaFdla1kyVkZaYWExSXhaSFZUYkdocFZsWndXbFpYTUhoT1IxWnpWMjVTVDFZelVsaFVWVkpIVjFad1JsVnJPVmROYTNCV1ZtMTRRMVl5Um5KU2FsSlhZV3R3VEZWc1dtdGpNWEJIVkcxc1UxZEZTa3RXYlRCNFpERkdkRlpyYUZaaVIyaFVXVlJLYjFaR2JITldiVVpZVW14S1ZsVXlNRFZYUmxwMFZXNXNWMkpVUlhkV1ZFRjRWbTFLUlZWc2FHaE5iV2hOVm10U1IxbFhUbkpPVm14U1lraENXRlZzVm5abFZscEhWMjFHV2xZd05WaFZNalZUVlVaWmVsVnJPVmRpUjFGNlZGWmFZVmRIVmtoUFYzQk9WbTVCZDFaWGVHOWpNVnAwVTJ0a1dHSlZXbUZaYTJSdlZERndWbGR1VGxkaVIxSjZWMnRrZDFSc1duTmpSRnBYVFc1U2NsbDZSbE5qTVhCR1YyeFNhVk5GU2xwWFYzUmhXVmRHUjJORlZsTmlSVFZ5Vlcxek1XVldaSEphU0U1V1RWVndlVmt3V25OV01rcFpVV3hDVjFaRldsaFZha1pyWkZaS2MxTnNhRk5OYldnMFZqRmtORll5VVhoVGJrNVlZa2RvYzFWcVRsTmlNVnAwWkVoT1QxWnRlRmRXVnpGSFZqQXhjbU5HY0ZkV2VsWk1WbTB4UzFaV1NuTmhSbVJPVW01Q1RWZFVTalJrTVU1SFUyNU9WV0pYZUc5VVZXaERZVVphZEdWR1RsSk5WbXcwVmtab2ExUXhaRVpPVm14YVlsaG9URlpFUm1GamJHUnlaRVp3VjJKSVFqUldWekV3VFVaa1IxZHVUbXBTVjNob1ZXeGtVMU5HV1hsbFIwWnFZbFZ3UmxZeWVHdFdNbFp6VjJ0V1YySlVRalJWZWtaclYwWktjbUZHVG1sU2JIQlpWMWQwYjFFeVZsZGFSbXhxVWxkU1lWWnFSa3RUUmxWNVRsWk9hRTFWY0ZaV2JUQTFWbFphUmxOcmVGWk5ibWhvV1hwR1YyTnRUa1pPVm1ScFVsWnJkMVpxU2pCV01rbDRWMnRvVkdKck5WVlpiWE14VmpGc1dHUkZkR2hTYkhBd1dsVmtSMkZyTVZsUmEyaFhVak5vYUZaSGVHRmpiVTVIWVVaa2FHRXlkekJXVjNCSFYyMVdSMXBJVmxSaGVteFpWV3BPYjFkc1pGZFZhMlJYWVhwR1dGbHJXbXRYUjBWNlZXeHNWMkpZVW1oYVYzaHJZMnhrZEdSR1pFNWhNMEpaVmxkNGIyRXhaRWRYYms1VVlUSm9XRlJYY0VkWFJsWnhVbXhPYTFac1NqQlZiWGhQVkdzeFJtTkdXbGRpUjFFd1dXcEdSbVZHY0VsVWJHaHBZVEZ3VkZkWGVGTmpNVlY0Vld4a1YxWkZXbFZWYlhoelRsWlNjMWRyT1ZkV01IQklXVEJTUTFZeFdYcGhTRnBYWWtad2FGbDZSbUZYVjBaSVVteGtUazF0WnpKV01WSkxUa2RSZUZSc1pGWmlhelZaV1Zod1YySXhVbFZSYTNSVlVteHdlbFl5TVhkVWJGbDNWbXBTVjAxWGFIcFdhMlJMVTBkV1IxcEdjR2xYUmtsNlZtMHhOR014V2xkVGJsWmhVak5DY0ZWdGVIZE9SbHBZVFVSR2FFMVdWak5VVm1oTFYwZEZlV1ZIYUZkaVJuQXpWbFZhYzJOc2NFWmtSbWhYVFVad1IxWnJaRFJoTWtaR1RWWnNVbUpVYkZoVVZscDNZVVphU0UxV1pGTk5WbG94VlRJeFIxVXlTbGhoUm5CWFZqTkNVRmxxUmxkV01XUjFWVzE0VTJWdGVGaFdSbHByVlRGa1IxZHVVazlXVjFKWFdXeFdkMDFHV2xobFJ6bFhWbXh3ZWxrd2FIZFdWMHBIWTBaU1dtVnJXbWhhUldSVFVqRndSazVXWkdsaE1HdDVWbXBHYTAxR1ZYaGlSbVJZVjBkb1dWbFhlSGRXUm14MFpVaGtXRkp0ZUhwV1YzUnJWa1pLZEdSRVZtRldWMUYzV1ZSR1NtUXhaSEpoUm1ST1ltc3hORlpzVWtKbFJscDBWR3RrYWxKdFVuQlZha1pLWld4YVdHTkZaRmRpVmxwWVZsZDRjMkZHU25SaFNFSmFZVEZhTTFwRVJtRlhSVEZaWTBVMVYwMUVWa2xYVjNSaFZqRldkRk5yYkZKaGVteFhXV3hvYjAweFVsWlhibVJYWWtoQ1IxZHJXbTloVmtwMFpETndXRll6VWxSV2FrWmhaRVpPY21GSGFGUlNia0paVmtaV1lXUXlUbk5XV0dSaFVsZFNWRlJXV25kbGJHdDNXa2hPV0ZKcmNGWlZiRkpEVmpBeFYxTnJhRmhXYkhCaFdsWmFWMk50UmtkYVIyaE9WMFZLTlZac1kzZGxSbFY0VlZob1dHSnNTbEJXYkZVeFZVWmFkR1ZJWkU1U2JFcFhXVlZqTlZack1VVlNibXhYVFc1U2RsWnRjM2hqVmxwelZXeHdWMUpXY0UxV1YzQkhZVEpTUjFOdVVsTmlSMUpQVkZWU1JrMUdXWGxrUjNSUFVtMTRXVlpIZUd0Vk1rcElaVWM1Vm1KVVJuWldhMXB6WTJ4a2RWZHRlRk5pVmtwYVYydFdhMUl4V1hkTldFcFlZa2RvVjFSWGNGZFhSbHBZVFZWMGExSXhXa2haVlZwM1lVVXhXVkZyTVZkaE1WcG9WbXBLVTFKck1WZGFSMFpUVFRCS1VGWnRlRzlSYlZaSFYyNUtXazB5YUhKVVZscFhUbFpWZVdWSGRGZFNNSEJIVlRKNGIxZHRTa2hoUlZKV1RVWndXRmt4V2tkWFZuQklaVVpPYVdFd2NFcFdha293V1Zac1dGSnJXazVUUjJoVldXdGFkMWRXV25GVWJUbG9VbTFTV0ZZeU1UQlZNREZZVldwR1YxWXpUVEZXYWtwTFZqRk9jMkpHWkdsWFJVcEZWMnRTUjFReFdYbFRhMlJZWWtkb2NGbFljRmRYVm1SWVpVWmtXbFl4V2xoV01XaHpZVEZLUjFOc2FGVldWa3BJVkZaYWMxWnRSa1prUm1ST1VrVmFTbFpzWkRSaU1WcHlUVlZrVjFaRldsaFpWM1JoWTJ4cmVXTjZSbGROV0VKSldXdGtiMVJzVGtaVGJUbFhZbFJDTTFwRVNsSmxWbFpaV2tVMVYySldTbFpXYWtKcllqRmtSMkpJVW14U1dGSllWbTB4TkdWV1dYbE9WM1JZVW14d01GcFZhSE5XTURGeFVtdG9WMkZyUmpSV01HUlhVMWRPUjFwR1pFNU5WWEIyVm0xMGEwNUdUWGxWYkdSVFltczFiMVZ0TVZOVU1XeDBUVmMxYkdKSFVsbGFSV1JIVjJ4YWMyTkdhRmROYWxaUVdWWmFTbVF4WkhOVmJHUm9ZVEZ3VFZaR1pEUlpWMDE0Vm01S2ExSnNTazlXYkZKWFYxWmFXRTFVVW1wTlYzaFlWVEkxVTFadFNuSlRiR1JhVmpOU2FGVXdXbE5XVmtwMFpFWm9WMDFFVmtoV01uUnJZakZTZEZKcVdsTldSVXBZVkZjMVUyUnNXa1ZUYTJSVFRWVTFNVlpIZUc5aFZrbDVZVVpvV0ZZelVtaGFSRUYzWlVaa1dXRkdhR2xYUmtwWlZrWmFiMUV4U25OV2JHaE9Wa1ZLVmxsclduZGxWbXQzVm01T1YwMXJXbmxaVkU1dlZqRktSbGR1U2xaTlJuQk1WakZrVDFJeFpIUmlSazVPWWxkb1lWWnFSbXRPUjBsNFZsaHNVMkV5VW5GVmJURnZZekZWZDFadVpHcGlSa3BZV1ZWV1QxVXlTa2RqUm14VlZtMU5NVlp0YzNoV01rNUdXa1phVGxZeVozcFdiWEJIV1ZaS2RGTnFXbEppUm5CeldWUkdkMkZHWkhKVmEwcHNVbXhzTlZWdGRHOWhSa3B5VGxaU1YyRXhjR2hXTVZwYVpWZFdTR1JGTlZOaVdHaFpWbTE0YjJJeVJuTlRiazVxVW0xNFlWWXdhRU5sYkd0NVpVZEdhMUl4V2tsVmJURTBZVlpLZFZGcmNGZFNiSEJ4Vkd4YVlWZEdUbk5YYlhCVFZqRkthRlpHVm1Ga01XUkhWMjVHVWxkSGFGbFZiWGhoVjJ4a2NsZHVaRmROVlhCWVdUQmFiMWRIU2tkWGJXaFhZV3RhY2xZd1drdGpiSEJIWVVkc1YwMHlhRlpXTVdONFRVWk5lRnBJVGxoWFIyaGhWRlJLVTJNeFZuUmxSbVJQVW0xU2VWWnRNVEJoUmxweVRsVmtXazFHY0hwV01qRkxWMVpTV1dGR1pGZFdia0paVjJ0V1ZtVkdXWGhWYmxKc1VtMVNjRlV3Vmt0WlZsbDVaRVprVjJGNlZsbFZiWFJyVmtkS2NrNVlSbFppV0dnelZtcEdjMk15UmtoUFYzQnBVbTVDTkZaVVNqQk5SbVJIVjI1S1dHSnVRbGRXYWs1dlkyeHNWMWRyY0d4U2F6VjVWRlphYTFZd01IZFRhMnhZVm14S1RGWlVSbHBsUmxaMVZteFdhVlpXY0ZWV2JYUmhXVlphVjFkclpGaGlSMUp5VkZaYVMyVnNXWGhoUnpsWFlsVldObFZYTlU5V2JVcFpZVVZvVldFeGNHaFZNR1JUVTBkU1IxcEdUazVUUlVreFZtdGtORmxYU1hoYVNGSlRWMGQ0VjFscldrdFhSbXhWVW01a1dsWnVRa1pWYlRGSFlXMUtWMU5yYUZoaE1sSjZWbFJLUzJOc1NuRlViR1JPWW0xb1dWWXhXbXRTYlZaSFkwVnNWV0pIYUhCWmExWjNaV3hhV0UxSWFFOVNiVkpJVmpJMVIxWlhTa1pPV0VwYVlURndNMXBWV2xabFYxSklVbTFzVTJKSGR6Qldha293WWpGWmQwMVlWbWhTUlRWWVZGVmFkMVZHVm5SbFJUbHFWbTFTZWxkclpITlhSa3B5WTBoYVYwMVhhRE5WZWtaU1pWWlNXV0pHVm1oTldFSlpWMWQwWVZsWFNYaGpSbWhzVWpCYVdWWnRNVk5YVm5CR1dYcFdWbUY2UmxkVWJHaDNWMGRGZVdGR1FsZGhhM0JNVm0xNGEyUkdTbk5hUjJ4WVVqSm9TbFpyWkRCWlZtUjBWbXRvVTJFeWFISlZiVEZ2VmtaU1ZsZHNjRTVXYlZKNlZtMHhSMkZGTVZkalJtaFhUVzVDYUZacVNrdFNNVTUwVW14a2FWSnVRWHBYYkdRMFYyMVJlR05GWkdGU2F6VndWbTEwZDFOc1pISldiVVpWVFZaS2VsWXlOVmRWYlVWNlZXeG9XbUV5VWxCVWExcFRZMnh3UmxkdGVGZGhNMEkyVmpKMFlWVXlSbGhUYTJScVVteEtXRmxYZEV0a2JGWlZVbTEwVjAxcmNFcFZNakZIVlRKRmVsRnNRbGRXZWtJMFZsUkdhMUl4Y0VsVGJHUlhVbXh3V1ZaR1ZsTlNNV1JIVmxoc2FsSlhVbGhaV0hCSFRWWnNWbUZIUmxoaVJuQjZXVEJvUzFack1VaFZhMmhXWVd0YWFGbDZTa2RTTVhCR1RsVTFWMVo2YXpGV2JURTBXVlpWZUZOWWJGVlhSMmhaVmpCa2IyTldWbk5hUms1b1VteGFNRlJXV2s5aGJFcHpZa1JPVjAxdVVYZFdha1poWXpKT1JtRkdaRTVoYTFwSlZtMXdRbVZHU2xkU2JrWldZa2RTV0ZSVVNtOWlNV1JYVm0xR1ZVMVZjSGxVYkZwdlZVWmFjMk5JUWxkTlJuQkxXbGQ0WVZaV1JuUlNiWEJwVm10Wk1GWXlkRzlWTVZaSFYyNVNhRk5GU2xoWmEyUnZVa1pWZVdWSGRGZE5WbkI2VjJ0YVlWUnNXblZSYWxaWFVteHdXRmxVU2tkak1WSnlWMjF3VTJKWGFHaFdiWEJQVlRKR1IyRXpiR3hUUjFKVVdXdG9RMU5HV2tobFJUbFZZbFZXTkZrd1ZuTldNa1Y1VkdwU1dtRnJXbFJaTW5ONFZteGtkR0ZGTlU1aVYyaGFWakZrTkdJeFJYaFZhMlJXWWtad2FGVnNXbmRqTVZwMFkzcEdXR0pIZUZkV01qRXdWMFpLY21KRVdscFdWbkJZVmpCYVlXUkdWbFZSYlVaVFVsWndlVlpYY0V0VE1VNVhWbTVLVDFadFVtOWFWM2hoV1ZaYWMxa3phRTlTTVVZelZGWmFhMkZGTUhsVmJHaGFWa1UxVkZrd1dsZGtSMUpKV2tkNGFWSnRkekZYYkZadlZERmtTRk5zWkZoaWJYaFdXV3RrYjJGR1duRlRhMlJxWWtWd2VGWlhlR3RVYkVwMVVXeHNXRmRJUWt4V1JFWktaVlpTY2xwSFJsTmlWa3AzVjFaU1EyTXdOVmRYYmtaVFlsVmFZVlp0TVRSWFJscElUbFpPVjAxclZqVldWM2hoVjIxS1dXRkZlRnBoYTFwWVdrVlZlRll4VW5SalJrNXBVak5rTmxadE1IaE5SVEZIVmxob1dHSnJOWEZWYTFaTFdWWlNWbGR0UmxWU2JIQkpXbFZrUjJGdFNsWmpSVnBYVmpOb2RsbFZWWGhrUjBaSFVteG9WMkpHY0c5V1dIQkhXVlprUjFSdVNtRlNNbWhVV1cxMFMxZHNXbFZSYkdSVVRWZFNXRll5TlVkVmJVcFdWMjFHVjJKWVVucFVhMXB5WkRGYWMxcEdXbWxXV0VKaFZteGtlazVXWkhSU1dHaHFVa1UxV0ZSV1duZGhSbXcyVW01T1QySkZjSHBXYlhNeFZqQXhWbU5GZEZkaVJrcExWRlphVG1WR1ZsbGhSbWhwWWtWd2VsWlhjRU5aVm14WFlrWldVMkp0VW05VmJYaHpUVEZaZVdWRk9XaGlWWEJKVmxkd1IxWnJNWEZTV0dSWFVqTm9jbFZ0ZUU5amJVNUhXa1pPVTFadVFuWldNVnBUVWpGVmVWUllhRlZpYTNCWldXdGtiMkl4VWxoT1Z6bFlZa1p3TUZwRldtdFdSVEZ6VTI1d1drMUdXbGhXVkVwTFUxWkdkVlJzWkdsWFJURTBWMnhhWVdFeVRuTmpSV3hoVW14d1QxbFVSbHBsYkdSVlVXMTBhVTFYVWtsVk1uUnZWbXhrU0ZWc2JGZGlXR2d6VmpCYVYyTldUbkpYYlhocFZsaENTbGRVUW10T1IwWkdUVlpzVW1KSVFsaFpWRVozWVVaa1YxZHJOV3ROUkVaWFYydGtjMVpHU2xsUmJIQllWak5vZGxaVVNrcGxSbHAxVkd4YWFFMUVWbEJXUmxwaFZqQTFWMVZzWkZwbGJGcFlWRlZTUjJWV2EzZFhiVVpYWWtac05sVlhlRk5YUmxwelkwVjRWbUpZYUhKWk1uTTFWMFpLYzFSc1RsZFdiWFF6Vm0wd2QyVkZOVWhTV0d4VlltdHdVRlp0TVZOaFJsWjBUVlpPVlUxWGVIcFhhMk0xVmpBeFYyTklhRlppVkVZeldXdGFTMVpXU25KaVJtUlhZbGRvTWxadE1UUmhNVTVJVW10a2FWSnVRbkJXTUdSdlZGWmFjbFZyWkZwV01VcEpWa2R3WVZVeVNraGhSbEphWVRKb1ExcEVSbUZTTVdSelZHeGFUbFl4U2tsV2Fra3hWakZXZEZKWWJGWmlSM2hoVm10V1lXRkdhM2xsUm5CclRWZFNlVnBGWkhkaFZscFZWbXQwV0ZaRlNtaFpWRVpUWkVaT2RWTnNVbWhOYm1oWlYxWmtNR1F3TlhOalJscFlZVE5DYzFWdE5VTlRiRnAwWlVaT2FGWnJOVWRWTW5oelZqRlplbUZJV2xaV1JWcFVWbXBHYTJNeVJraGpSazVZVW10d1dGWnJXbUZXTWsxM1RsVmtZVk5GY0c5VmJGSnpWMVpXY1ZGc2NFNWlSbkF3Vkd4V1QxZEhTbFpXYWxKWFRXcEdTRmRXV2xwbGJVWklZVWRHVTFZeFNsbFdWM0JIVlRKTmVGUnVVbWxTYlZKd1ZUQldTMVJHV25STlZFSm9ZWHBHV0ZaR2FHOVdiR1JJWVVac1dtSllUWGhaTVZwWFpGZE9TVlJzWkU1V00yZzJWbXhrTkdFeFZYaFRibEpzVTBkb1YxbHNhRzlWUmxweFVWaG9hbUpIVW5sWGExcHJWVEpXY2xaWVpGZGlXRUpNVlhwR1QxWXhTblZTYkdocFVqRktkMVpYY0VkU01EQjRWMnRrVjJKVldtRldiWFIzWlZaU1YxZHRkRmhTTUhCYVZWZDRVMVp0U2tkWGFrNVhUVlp3YUZZd1pFOVNhemxYVjJzMWFFMVlRa3BXYlhCTFRVZEplVk5yWkZSWFIxSlpXVzEwZDFZeGJGaGtSWFJvVW14V00xWXlOVTlXTWtwSVZXNXdXR0V4Y0hKV1IzaGhWMVpHYzJGR2FGZFNWWEJZVjJ4V1lWZHRWa2RhU0VwWVlrZG9jRlpxU205WGJGcDBUVWhvVmsxV1draFphMUpoVlRKS1ZsZHVTbGRpV0UxNFZGVmFWMlJIVmtaUFYyaFhZa2QzTVZkV1ZsTlVNVmw1VTJ4V1VtRnNTbFpaVkVwVFZURndWbGRzVG1wTldFSkpWVzE0VDJGV1NuVlJiRlpYVFZkUmQxbFVSbFpsVmxKeldrWmFhVkl4U2xwWFZ6QjRWVEZhVjFkdVVteFNiVkpRVm0wMVExWXhaRmxqUm1Sb1VtdHdlVmt3YUhOWGF6RklZVVJPVjJKWVRqUmFSbVJIVTBkR1IxcEhhR2hOTUVwSlZqSjRWMWxYUlhsVWJHUldZbXhLVkZsclZURlVNVkpZVFZjNWEySkdiRFJaVldoclZUQXhjbFpxVmxkV00xSnlWbXRrUzJOck5WZFhiSEJZVTBWS1dWWnFRbUZqTWxKSVZXdGFZVkpVVms5V2JUVkRUbXhaZUZWck9XaE5hM0JJVlRKNFYxVXlSWGxoUm1oWFltNUNXRlpyV21GV1ZrcDBaRVpTVTAxR2NFdFdWekUwV1ZkR1YxTllhRk5YUjFKWVdWZDBTMkZHYkRaU2JYUlVVbXhhZVZscldsTmhWbVJJWVVaV1dGWXpVblpWVkVaYVpVWmtjMkZGTlZkU2EzQlhWa1prTUZsWFZsZFZiR1JZWWxoU1dGVnFRbmROUm5CV1drVmtWMDFyY0VsV1YzaFRXVlpKZW1GSGFGZGlSbkJRV1RJeFUxSXhjRVpPVm1SWFVteHJlVlp0Y0V0TlJteFlVbGhzVTJKSFVsbFpWRVozVjBaWmQxcEdUbGhTYkVwWVZqSTFhMkZ0U2tkalNHaFdUVzVOZUZscldrdGpNazVGVW14a2FWZEhhRlZYVmxwaFUyMVdXRkpyYkdGU2JWSndWakJrYjJJeFpISlZhMlJvVFdzeE5GZHJhRTloUmtsNllVWlNXbGRJUWxoV01WcGhVakZrZEZKdGNFNVNSbHBKVm1wS05HRXlSa2RUYWxwcFVtMTRWMWxYZEV0Tk1WcDBaVWhPYW1KSFVqQmFSVnByVmpKS1NWRnNiRmRXUlc5M1dXcEdZV05yTVZsV2JXaFRZbGRvV1ZaR1ZtdFZNV1JIVmxoa1YxWkdXbGhVVm1oRFVqRlNjMXBIT1ZWaVIxSkhWV3hvYjFZeVJuSlhia1pWVm0xU1UxcFZXa3RYVjBaSVVteFNVMVpHV21GV01WcFRVakpSZUZwR1pHbFRSVFZvVlc1d2MySXhWblJsUjBac1lrWnNOVlJzWkRCV01rcEdZMFJDWVZOSVFreFdiWE40WkZaV1dWcEdaR2hOV0VKTVYydFNSMkV5VG5SU2EyUmhVbTFTVDFSWE1XOVdiRnAwWlVaT1UwMVhlRmhYYTFwclZUSktjazVZUWxaaVZFWlVXV3BHYzFaV1NuVmFSM2hYWWtoQ1NWWnRNSGhTTWtaeVRWWm9WbUV5YUZoWmJHaHZaV3hzVjFkcmRHdFNiRm94VlZkNGQxZEdUa1pUYkd4WFlXdHZNRmxVUm10U2F6RlhWbXhhYVZKcmNGQlhWbWgzVW1zeFIxZHVVazVTUlZwVVZGWmFkMWRXVlhsa1IwWlZUVmRTUjFZeU1VZFhiRnBHVjJwT1dsWldjRE5XTUdSWFUwWktjMkZHVGxkU2JIQlpWbXRTUjFsWFNYaFdXR3hUVjBoQ1UxWXdaRk5YVm14eVYyMUdhRkp0ZUZaVmJURXdWa1pLY21OR2NGcGhNbEoyVmxSS1JtUXlUa2RpUm1oWFRUSm9NbFpyVWtKTlZrbDRWMjVXVldKSGFHOVVWRVpMWlVaYVIxZHRPVkpOVlRWSVdWUk9hMVl4V2taWGJHUlZWak5TTTFVeFduZFNiRlp5VDFaa1RtRXpRbGRXVnpGM1ZERmFkRlp1U2xoaGVteG9WbXhhZDFWR1dYaGFSWFJUVFZad01GbFZWVEZoVjBwWVlVWm9WMkZyV25KVVZWcHpWakpLUjJGR1VsaFNNbWhZVjFkMGEySXlUWGhXYms1b1VtczFXRmxyV21GTlJsSlhWMnM1YVZJd2NFaFpNRkpEVmxaYWMxZHVTbHBXVm5CTVZteGFTMlJYVGtkWGF6VnBZbGRuZVZadE1YZFNNVTEzVGxoT1dHSnJjSE5WYlRGVFZrWldjMWR1WkdsTlYxSjVWbTB4UjFZd01YSk5WRlpXWWxoU2NsWnFTa3RUUmxaMVVXeGFhVlpGUlhoV1J6RTBXVmRPYzJORlZsSmlTRUpZV1d4b2IxZHNXbkpYYlRscFRXdGFlbFV5ZUc5aVJrbDVZVVprV21KSGFIWldSVnBoVWxaS2RWUnNaRmRoZWxZMFZtdGtlazFXVlhsVGJHUlVZa2hDV1ZsVVJtRmpiRlp4VTJ0a1UyRjZSbGhYYTJSM1ZURktWbU5HYUZkU2JVMTRWbFJLVTJNeFpIVlZhelZYVjBaS1ZsWlhjRWRaVms1WFZtNVNiRk5IVW05V2JYUjNaVlpyZDFadVRsZE5hM0JhVmxjeGIxZEdXblJWYkVKWFlXdGFVRnBHV2xOa1JrcHpWR3MxVGxaWVFsZFdiVEI0VFVaWmVHSkdaRmhYUjJoWldXdGtVMkZHVlhkaFJVNVdVbXh3TUZwVldtdFVNVnB6Vm1wV1lWSlhUVEZaVlZWNFl6RmtkV0pHWkU1aWJXZzJWbXBKZUZKdFZraFVhMmhvVW01Q1QxbHRNVzlXVmxwMFRWUlNhMDFWY0hwWk1GWnJWbTFLUms1WE9WVldSVXBMVkZWYVlXUkhUa1prUlRsVFlrVlpNVlpYTVRSaE1WcEhXa1ZzVW1KVWJGZFpiRkpHVFVaWmQxZHVUbXBOVmxwNlYydFZNVlJzV25WUmFsSlhWa1Z2TUZsVVNrZGphekZYWVVaYWFHRXhjRmxXVnpWM1VqRk9SMWRzVmxOaVdGSlVWRlpWTVdWc1duUmxSM1JXVFd0d1dGVXhVa3RXTVVwelkwZG9WMUpGY0U5YVZWcHJZekpLU0dKR1RrNU5iV2hXVm10YVUxSXhUWGhhUldSWVlUSlNXRmxyVlRGVk1WSldWV3hrV0ZKdGVIbFdNakZIVjBkS1YxZHVjRmROYm1oMlZteGFXbVZzVm5SaFIwWlhZa2hDV0Zkc1dsWk5WbHAwVld0a1lWSlVWbGhaYkZKdlRsWmFjMWt6YUU5U01HdzBXV3RhYTFaSFNraFZia1pXWWxob1RGZFdXbE5YUlRWWVQxVTFUbFpzV1hwV2Frb3dUVWRHY2sxV1pGUmliWGhXV1d0a1UyVnNiRmRYYkhCc1ZqQmFTVlF4V210aFZscEdWbGhrV0Zac1NreFdWekZYVWpGV2MySkhiRk5pUlhCYVZsZHdTMkl4WkhOYVJtaE9WMGhDVDFadE1WTlhSbXh5WVVaT2FHSldXbmxXTWpWRFZsWmFjMk5HYUZWV1JWcHlXVEo0YTJOck9WZGFSMmhzWVRGd1lWWXllRmRpTWxGNFYxaGtUbGRGV2xSWlZFcHZWMFpzVlZKdVpGVlNiWGN5VlRKek5WVXlTbFpqUld4V1lsaG9VRlpxUVhoV2JHUlpZMFprYVZaRldYcFdWM0JIVkRKU1IxWnNiR2xTYkZwdlZGWm9RMlF4V2xoalJVNWFWbTFTU0ZZeU5VZFZiR1JJVlc1T1ZtSllhRE5VVlZwVFZtMUdTRTlXV2s1U1JWbzFWa2Q0YjJReFdYaFRhbHBYWWtaS1lWWnNXbmRVUm5CR1YyeGthMUpVYkZoV2JYaHJZVlpaZVdGRldsZE5WMUl6VldwS1JtVkdaSE5hUmxKcFlrVndWVmRYZEdGWlZsRjRZa2hLVjJKdFVsVlZiWGgzVW14V2RFMVZaR2hTVkVaWldsVmFiMVpyTVZoaFNIQmFZVEZ3VEZsNlJrOWpNV1J6V2tkc1dGSXlhSFpXYTFwVFVqSkZlRmRZYUdGVFJUVnhWV3BPYjFkR1VsZFdibVJVVm14c05WcEZaREJoVlRGWFUyNXdWazF1VW1oV01HUkdaV3hHYzJGR1pHbGlhMHBJVmtaV1lXRXhXWGhhU0U1VllsaENUMVl3Vmt0VFJscHhVMWhvYTAxV2NFaFZNbmhoWVd4S2RHRkdiRmRpV0doTVZUQmFkMUpXU25OVWJFNU9WakZLWVZZeWRHRmlNa1pZVW1wYVYySnRhRmhWYlhoM1lVWmtWMXBHWkdwTldFSktWVEo0YjJGV1NsVldiR2hYVW0xUmQxcEVSazlqTVZwellVZDRWRkl4U2xsV1JscFhaREpXYzJFelpGaGlWR3hZVm0xNGQxZEdhM2RhUldSYVZteHdlbGt3V2tOWGF6RnhVbXRvVm1GclduSmFSV1JMVTBkS1NHRkZOVlJTVlc5NVZtMHdkMlF5VmtaT1ZXUnBVbTFvVjFZd1pGTlVNVlYzV2tjNWFsSnNXakJhVldoclYwWktjMkpFVGxoaE1rMHhWakJhWVdNeVRrVlJiVVpUVmpGS1NWWnFRbXRUTVU1SVZXdFdWV0pIVWs5WlYzUlhUVEZhZEUxWWNHeFNNRFV3VmtkMFlXRkdTblZSYXpsV1lXdEdNMXBWV21GalZrWjBaRVpPYVZac2NFbFdhMk14VXpKR1IxTnVVbWhTYldoaFdXdGFkMVJHV25OWGJVWllVakExUjFkcldsZFViVXBHWTBac1YyRXlUWGhXVkVwSFVqRk9kVk5yT1ZkV1IzaFhWbTB4TkZsVk1IaFhibEpzVW01Q2MxVnROVU5TYkZaWVpVaGtWMDFFUmxkV01WSkhWakpLU0ZSWWFGZFNSVnA2Vm1wR1UyTnNaSEpQVm1ST1lsZG9XVll4V2xOU01XeFhWV3RrWVZKdFVsbFpiRlpoWTJ4V2MxVnJaRmRpUm5CWldsVmpOVlpyTVhKalJXeGhVMGhDU0ZZd1pFdFNNV1IxVTJ4V1YxWnVRbmxYV0hCSFlUSlNWMVJ1VW1wU2F6VllWRmN4YjFkV1duSlhiWFJyVFZac05GWkhkR3RYUjBweVRsWnNXbUpHV21oWk1uaFhaRWRXU0ZKc1pHbFNiSEJhVjJ4V2EwMUdXbGhUYTFwcVVrVmFWMVp1Y0Vka2JGbDNXa1YwVTAxck5VcFZNbmhyWVVkRmVHTkdSbGRXZWtZMlZHeGFXbVZXU25KaFIyaFRZWHBXZGxkc1pEUlpWVEZ6VjI1S1dHSkZOVk5VVmxWNFRsWldkR1JIZEZoU2JWSkpXVlZhYzFkdFJYbFZiRkphWVd0YVZGWnFSbUZrVmxKeVQxWk9hVlpyYnpGV01WcFhWbXMxVjFwRlpGUlhSMUpZV1ZkNFMxbFdVbFpYYm1Sc1lrWnNOVnBWV25kaVIwcEhVMnh3V2xaV2NIWldha3BMVTFaR2RFOVdhRmhUUlVwSlYxWlNTMVV4V1hsVWExcG9VakpvVkZsWWNGZGtNVnB4VVcxMFZVMUVWbGhXTWpWUFYyc3dlVlZ1VGxaaVJrcElWVEZhVjJSRk5WZFViR1JUVFVoQ1NsWnNaRFJXTVdSelYydGFhV1ZyU2xsV2JYaDNWa1phZEdWSGRHcE5WMUl3V2xWYVQyRldTWHBhUkZwWFlsaENURlJWVlhoU01XUlpZa1pTYVZKdVFsRldiWGhyVlRGc1YxVnNXbGhpYlZKeFdXdGFkMU5XY0ZaYVJXUm9UVlp3ZVZZeU5YZFhiVVY0WTBoYVYyRnJjRXhWYlRGUFVtc3hWMXBHWkZOV00yTjNWbTB4ZDFJeFRuUldhMlJoVTBaYVdGbHJaRk5qUmxaMFpVaGthMDFXY0RCYVZXUkhZVEF4VjJOR2FGZE5hbFpVVmtkNFMxSnNaSE5VYkZaWFlraEJlbGRzWkRSaE1rNXpXa2hTVUZZeWFFOVdiR2hDWkRGYWMxbDZSbFJOVm5CWVZqSTFVMVp0U2tkVGJHUlZWbFp3TTFsVldscGtNWEJIV2taU1UwMVZjRWxYVmxaaFZERlNjMVJyV2xOaGF6VllXV3hvYjJOV2NFVlJWRVpYVFZkU01WWlhlRk5oVmtwelkwWldXRll6VW1oVmVrWnJVakZXYzFkc2FHbGlWa3BvVm0wd01WRXhaRWRhU0VwWFZrWmFWbFJYZEhkU01XdDNWV3RPV0dKVlZqUlpNRnBEVjJ4YWMyTkdRbFppV0doUVZteGFUMk14Y0VoaVJrNW9UVEJLVDFacVNqQlZNVWw0Vkc1U1YyRXlVbWhWYlRFMFlqRldkRTFYT1ZoV2JGWXpWbTEwTUdFeVNrZGpSbXhWVmxkb2RsbFdWWGhYUjFaSFlVWmtUbUZzV2xGV2FrSnJVekZPUjFadVRsSmlSbkJ3VmpCa2JtVnNaSE5XYlVaWFlsWmFXVlpIY0dGV01rcEhZMFU1Vm1FeFdtaFViRnBoVTBkV1IxcEhiRTVXTVVvMlZtcEtOR0V5Um5OVWExcHFVbTFvVjFsWGN6RlZSbEp5VjIxR2ExSlVSbGRVTVZwUFZqSktTVkZxV2xkTmJsSnlXWHBHYTFJeFRsbGlSMmhUWWtoQ1dWZFhkR3RpTURCNFZtNUdVMkpIVW5KVmJYaDNaVlprY2xkc1pHaFdhMncyV1ZWb1lWWXhXalpSYWxKYVlXdHdVRlZxU2t0VFZrNXpZVWRzYVZacmNGcFdiVEIzWlVaVmVGcEdaR3BTVm5CWldXeG9VMkl4VWxaVmEyUllWbXh3V1ZwRll6VldNREZ5WTBaYVYySllhRVJXYWtwSFkyMU9SbVZIUmxOV2JrSlpWMWh3UjJReFNYaGFTRkpwVW0xb1ZGUlhNVkpOYkZwMFRWaGtVMDFYZUZoV2JHaHZWMGRLYzFOc1VscFdSWEIyVmxaYVlXUkZNVmRVYld4T1YwVktXbGRyVm10U01XUklVMnRrYWxOSVFsbFdNR2hEVTBac1ZWRllhRmhTYkZveFdUQmFhMVJ0U25OVGJUbFhZVEZLU0ZsVVJrdGtSbEp5V2tkb1UySnJTbGxXUmxKSFUyMVdjMWR1U2xkaVZWcFpXV3hhWVZOR1pISmhSVGxhVm10c05sVlhjelZYYkZwR1YycE9WazFXY0doYVJWVjRWbFpXZEdGRk5WZGhNMEV4Vm10YVlWbFdiRmhTYkdSVVlUSlNjVlZ0TVc5WlZteHlXa2M1VTFKc1dubFdNakV3VmpBeFdGVnVjRnBOUjFFd1ZtcEtTMUl5VGtWV2JHaFhZa1p3YjFadGNFdFNNVXB5VFZaa2FWSnJjSEJWYkdoRFYxWmtXR1ZHVGxKTlJGWklWako0VjFVeVNsbFZiRkpWVmpOU00xVXllRlpsVlRGWVQxWmFUbFp1UWxkV2JURTBVakZrUjFkWWNGWmlWMmhvVld0V2QxZEdWbkZTYlVaWVZqQmFTRll5TVc5VWJVcEdZMFJLVjJFeGNGaFdWRVpLWlVad1IxcEdhR2xTTW1oUlZtcENhMVV4WkVkVmJGcFdZVEpTVDFadE1UUldNV3hXVm1wQ1dGSXdjRWhaYTFKaFYyeGFWMWRVUWxkaGEwWTBWakJhVjJOdFJrZFhhelZUWW10S1RsWXhhSGRTTVd4WVZGaG9hbEpYYUhOVmFrbzBWa1pzZEdSRmRGWk5WbkF3V1RCV01GUXhTbk5pUkZKYVlURndjbGRXV2s5U01VNXpXa1prVGxJeFNqSldha1poWXpKT2MxcElVbE5pUjJoVVdXeG9iMDVXV1hsa1IwWlZUVlp3VjFSV1dtOWlSa3AxVVcxR1ZWWldjRE5aTW5oaFkyeHdSbVJHVWxOaVJuQTJWMVpXWVdFeVJsZGFSV2hvVW5wc1dGbFVTbEpOUmxsNVRWWktiRkp1UWtwV1J6RnZWVEpLVjFOc1FsZGlXRUpNV1dwQk1XTXhjRWRhUm1ScFZsWndWbFpHV210Vk1VNUhWMjVTVDFaVWJHOVZiWFIzVFZaV1dFNVZUbGRpVlhCYVZsZHdUMVpyTVZkalIyaFdZV3RhV0ZreWVIZFNNWEJHVGxkb2JHSkdjR0ZXYlhoVFUyc3hWMWRZYUZoaVIyaFZXVlJLYjJJeFZuUmxSWFJhVm14d2VWWnNVa2RWTVVwMFZXeG9WMDFxUlhkV2FrRjRWakpPUlZGc1dtbFdSVm8yVm10a05GZHRWa2RVYmtwcFVtMVNXRlZzV25kTmJHUlpZMFYwVTAxVmJEUldWelZMWVVaSmVXRkdVbHBpUjFKMlZqRmFhMVl4Y0VsalJUVlhUVlZ3TmxkWGRHRlpWbVJJVTJ4c1ZtSkhhRlpXYlRGVFZrWndXR1ZHY0d4V1ZFWldWbGQ0WVZSc1NrWlhhM1JYVm0xUmQxUlZXbHBsVmtwWllrWldhR0pGY0doWFZtUXdXVlpaZUdOR1pGaGhNMUp4Vm0weFUyVnNaSEphU0U1b1ZteHNOVmxWV25kV01rcFZVVmhvWVZKRldreFpNbk40Vm14d1NHTkdUbGRpU0VKVlZtMXdRMkV5U1hoWGEyUldZa2RvY1ZwWGRHRldSbEpYVjI1T1QxWnVRbGRYV0hCWFlVWktjMkpFVGxwTlJuQjJWbTF6ZUdSWFJrbFRiR1JPVW01Q2FGZHNaRFJXTWsxNVVtdG9VMkpGTlZSV01GWkxWMnhaZUdGSVpGUk5WWEF3Vm0wMVQyRnNTbGhoUnpsV1lsaE5lRmw2Um5Oak1rWklUMVpvYVZKdGR6Qldha2wzVGxkRmQwMVdXbWxTUlRWV1ZtMTRkMk5zV25GVGEzUlVVakJhU2xaSGVHRmhWbVJHVFZSU1YyRnJTbWhXVkVaclUwWldjbUZHVG1sWFIyaFpWMWQwWVdSdFVYaGFSbFpTWWxWYVZsUldXbk5OTVZKWFlVVjBXRkl3Y0RCYVZWcHZWbFpaZWxGcmFHRlNNMmhoV2xaa1RtVnRSa2RhUlRWb1pXeGFTMVl4V2xkWlYxRjVVMnRvVTFkSGFIRlZNR1EwVjFaYWNsWnVaRTlpUmtwWVZqSXhNRlpHU25KT1dHeGFWbGRTZWxaVVNrZE9iRnB6WTBaa1YwMHlhRmxXYlhCQ1RWWkplRnBJVmxaaGVsWlpWV3BHUzFaV1drZFhiWFJQVW0xU1dGWnROVTloUmtsNlZXeGFWVlpzY0ROV01WcGhWMGRXU0dSR1pFNVNSVnBLVm14ak1WbFdXWGxUYTJScVUwaENhRlZzWkZOV1JsVjRWMjVrVTAxWFVucFdSekZ6VmtaS1ZsZFljRmRpV0ZKb1YxWmFjMVl4VmxsaVJrNW9UV3hLVmxkWE1YcE5WbVJYWWtab2ExSllVbGhaYTJRMFpWWlplVTFWWkZkaVJYQXdXbFZhYzFsV1dsZFhXR1JhVmpOT05GWXdXbGRrVjBaSFYyeGtiR0V4Y0VwV2JYaFRVakZrZEZac2FGTmhNbmh3VlcweFUyTkdXWGRYYTNScFRWWnNORll5TVRCV1YwcFhWMnhvVjFaNlZreFdha3BMVW0xT1NWRnNaR2xTYmtGNlZtMTRZVmxYVWtoVWExcGhVbXhLVDFac1VsZFhWbHB4VTFSR1ZrMVdTbnBYYTFaelZXMUtjazVXWkZwaVIyaDJXbGQ0VTJNeFpITlhiWGhYVFZWd1NWWXlkR0ZoTWtaWFYyeHNVbUV6UWxsV2JYaGhZMVpTYzFkdFJsZE5WMUo0VmpKNFQyRlhTa2xSYkd4WFlsUkZNRnBFU2tkU01rVjZZVVpvYUUxc1NubFdWM0JIVXpGT1IxZHNhR3BsYTFwWVZGVlNSMVl4YTNkYVJXUlhUV3R3U1ZaSGNGTldWbHBZVld0a1lWWnNjRXhaTW5oM1VqRldkR0pIYUd4aVJuQm9WbXBHYTAxSFJYbFRXR2hoVWxkU2NGVXdWVEZpTVZaMFkzcEdWVTFXU2xoV01qVnJZa1phYzJKRVZsVldiRXBFV1ZWa1IwNXNTbk5pUm1SWFRUQktSVlp0TUhoVE1XUllVbXRXVldKSFVtOVpWRTVEVkZaYWRHTkZaRlZOYXpVd1ZXMTBhMWxXU25KT1dFSldUVVphVEZwSGVHRmtSVEZaV2taT1RsWXphRnBXYkdRd1lURmFXRk51U2s5V2VteFhXVmR6TVdSc1duSlhiVVpxWWtoQ1JsWlhlRzlXTWtwWFUyeHdXR0pHV25GVWJHUkhWbXN4VjJGSGVGTmlWMmhaVm0xd1QySXlUbk5YV0dSaFVsaFNXRmxyWkZObGJHeHlWMjFHYUZJd1ZqUlpNR00xVmpGYVJsZHRhRmRXZWtaWVZXcEtUMUpzV25OVGJXeFRZa2hDTTFac1kzZE5Wa1YzVGxoT1lWSnRhSEZWYkZKellqRlNWMWR1VGs5U2JHdzFXa1ZrUjJGR1dYaFhibXhXVFc1b2VsWnFTa3RYVjBaRlZHeHdUbUp0YUZoWGExSkhZVEpPY2s5V2FHcFNNbmhZVm0wMVExTXhXWGhYYkdSYVZteEdOVlZ0ZUd0WFJtUklaVWM1Vm1KdVFucFdNRnBUVmpGd1IxTnRkRTVXTVVwWlZtcEtlazFYU2tkVGJrNVVZbTE0V1ZsVVJuZGtiR3hXVmxob1YwMXJOVWhXYlhodlZqSldjbE5VUWxkaVJrcElXVlJHU21WV1RuSmlSbEpwVmxad1ZWZFdhSGRXTVZaSFYyNVNUbFpHU25KVVZsVXhWMFphV0dWSGRHaFNhMncyVmxkNGIxWldXbGRUYTJoaFZteHdhRnBGWkU5VFJrcHpXa2RzVTJKWVkzbFdiRnBxWlVkSmVGZFlaRTVXVjFKeFZXcEtiMVl4YkhOaFJ6bFdVbTVDU0ZZeWN6VmhhekZYWTBSQ1dsWldWWGhXTUZwTFZtMU9SMk5HWkdoaE1qaDNWakZhWVdNeFdYaFdiR3hwVW14YVdWVnFTbTlsUmxwWVpVZDBWazFXYkRSWmEyaFBXVlpLTm1KSVJsWmlXR2hvV2xkNGMxWnNXbkpQVm1oVFRVaENTVmRYZEZOVk1WbDNUVmhHVTFkSFVsaFZhazV2VXpGd1ZsZHJPV3RXTUhCSVZtMTRhMkZXU25WUmFsWlhZbFJHTTFWNlJrcGxWbEpaWWtaV2FFMXNTbGxYVjNSdlVURmtSMVp1VG1oU1ZUVllWbTE0ZDAxR2NGWmFSV1JYVFVSR2VsVXlkSE5XTVVsNlVXMW9WMVpGY0V4V01XUkhVakpHUjJOSGFFNWlSVmt5Vm10YVlWbFdiRmRUV0doaFUwWktVVlpxU205VU1WcDBUbFZPVDFac2NFaFdNbmhyVmpBeFYxWnFWbFppVkZaTVZtdGtTMVpzWkhOaFJuQm9UVmhCZWxaR1VrZFZNVnBYVTI1U1UySllRbGhaV0hCWFRsWmtjbFp0Um1oTlZtdzFWV3hvYjJGc1NrZFRiR2hhWVRKU1UxUlZXbk5XVmtwelkwZDRWMkpJUVhoV1ZFbzBZakpHVjFOdVNtcFNia0paVm1wT1UyRkdaRmRhUldSVFRXczFSMVp0ZUU5aFJUQjNVMjV3VjFZelFrTlVWbHBLWlVad1NWTnRSbE5sYlhoWVZrWldVMUl3TVZkaVJscG9VakJhV1ZWcVFuZFRWbHBYVld0T1dGSnNjSHBaTUdoTFYyMVdjbGR1U21GU2JIQlFXWHBLUjFOSFNrZGhSazVvVFRCRmVWWnRjRWRaVjBsNVZWaG9WRmRIYUdoVmJHUlRWMVpzVlZOdE9XcGlSbHA0VmtkNFQxZEdXbk5YYWtKVlZteHdVRlpyV21Ga1ZrWnpXa1p3VjFac1ZYaFdiWEJMVXpGYWRGUnJWbE5pUm5CWVdsZDRXbVZzV25GVFdHaFRUV3MxZWxkcmFGTmhSa2wzVjJ4U1YyRnJXa3hXYkZwaFZsWktkRkpzV2s1aGVsWTFWa1JHWVdFeFdsaFRiR2hzVW14S1lWbFVTbEprTVZKeVYyMUdhMUl4U2tsYVJWVTFWVEF4UjJORVZsZFNNMmhvV1ZSR2ExSXhjRVpoUmxwb1pXMTRXVmRYZUc5aU1EQjRZVE5vV0dKSFVuRlphMXAzWlZad1JsZHRPVlpOYTNCS1ZWWm9hMVl4U25OalNFWlZZa2RTU0ZwRldrOWpiSEJJWWtaT1UxWkdXbHBXYTFwclpERkplRlJyWkdsU2JXaHhWRlJLYjJOV2JGbGpSbVJYVFZkU2VWZHJWbXRXYXpGWFlrUlNWazF1VW5wV2FrcExWMVpHY21GR2FGZGlWa3BWVm0xd1IxTXlVbGRWYmxKcFVtczFjRlp0ZEhkTmJGbDRWMnhPVTAxc1JqVldiWGhyVjBkS1NHRklSbFppUjFKVVZteGFjMk14WkhSU2JHaFRZa1paTVZaSGVGZE5SMFpIVTI1S2FWSkdXbWhXYkZwM1ZrWlplVTFWZEZSU2JGb3hWako0YTJGV1NuVlJibXhYWWxoQ1NGWnFTazlqYXpsWFdrWlNhVll6YUZsWFYzUnZVVEZrYzFkdVVtcFNXRUpQVm0xNFYwNVdWWGxrUjNSWFVtMVNTbFZYZUd0WGJVcFpWV3BPVjJKWWFHaGFSV1JYVTBaS2RHVkhiRk5oTTBFeFZtMXdTazFXVVhsU2JsSlVZVEpvVjFsWGRFdFdiRkpYVjI1a2FtSkdjRWxVVmxaaFlrZEtSbGR1YUZkaVdHaHlWbFJCZDJWWFJraFBWbWhZVTBWS1NWWnFTWGhWYlZGM1RWWmtXR0pYYUZSWmEyaERWMVphV0dWR1pHdE5hMXBJVjJ0b1QxbFdTa1pUYlVaWFlsUkdWRlV3V25OamJGWjBVbXhhVG1FelFYZFdiR1EwVlRGYVYxZHVUbXBTV0dob1ZtcE9iMlZzV25SbFIzUnFZWHBzV1ZsVldtdGhSVEIzVTIxb1YySkdjSEZhVlZwS1pVWmtXVnBGTlZoU2JIQllWMWQwYTJJeFpGZFhibEpPVm1zMVZGUldhRU5XTVZsNVpVZDBXRkpzYkROV01uUnZWakZhTmxKdWNGcFdiSEJNVmpGYVIyTldXbk5hUjJ4VFRWVlplbFp0TUhobGJWWkhWMWhvYWxKWFVtaFZha28wVmtac2NsZHVaRmRpUjFKWVdWVm9hMVl3TVZkU2FsSlhUV3BXVkZscldrOVNhelZXVDFaV1YySklRalpXUjNoaFpERktjMVp1U2xWaVYyaFVWRlZhY21WV1dsaE5SRVpxVFZad1dWVXlkR3RYUjBwWVlVWm9XbUpIYUhaWFZscDNWMFV4VmxwR1VsZGhlbFkyVmpKMGEySXlSa1pOVldScFVrWndXRlJYTlc5aFJteFZVbXR3YkZKck5WcFpWVnBUWVZkR05sWnRPVmRXTTJoVVZtcEdhMUl5U2tsVmJYUlRWMFpLZVZkWGRHRmtNbFpIVm01U1RsWlhVbTlWYkZKSFYwWlZlV05GVGxkTmEzQmFXVlZvUzFZeVNsVlNhM2hhVFdwR1VGVXdWVFZXTVdSMFlVZG9UazFGYkRWV2JUQjRUVVpzV0ZSWWJGWmhNbWhYV1ZSR2QyTnNWblJsU0dSWFVtMTRlbFl5ZERCWFIwcEhZMFZvVjJKVVFURlpWbFY0WTJ4a2MySkdXazVpYldoNVZtcENhMU15VWxkU2JrNW9VbXhhV0ZwWGVHRk5iR1J5V2tSU2FrMVhVa2xXYlhSaFlURktkR0ZHVWxwaE1YQXlXbFZhWVZaV1RuRlZiR1JPVm0xM01WWlVTakJoTWtaelUydGthbEp0YUZkWlYzTXhaR3hzVmxkdFJtcFdhelY2VmtkNFUxVXlTa2RqUkZaWVZteGFjbFJWV2xabFZrNXpXa1pTYVZJemFGbFdWekUwV1ZkR1IyRXpiRTVXYlZKWVZGWmtVMDFXV2xoamVrWllVbXMxUjFVeWVFZFdNa3BWVVdwU1YxWkZSalJWYWtaaFYxZEtTR1JHVG14aVdHaGFWakZrTkZZeVVYbFdiR1JZVjBkNFQxWnVjSE5YUmxKWVpFaGtWRkp0ZEROV1YzTTFWMGRLUjJOR2FGcE5Sa3BRVm0weFMxZFhSa2hoUm1ST1ZqRktTVlpYY0Vka01VbDRZMFZvYVZKck5YQldhMlF3VG14YWRHTkZaRnBXYkd3MFZqSTFTMVJzV25SVmJHaFhUVWRTZGxac1duTmpiSEJIVkcxd1YySkdjRFpYVmxaWFZERmtSMU51VW14VFNFSmhWbXhhWVZWR1duSlhhM1JyVWpGYVNsbFZXbUZVYlVwelUxaHdXRll6VW1oVmVrcFRVakZhZFZadGNGTmlWMmgyVmtaa05GTXhUbGRYYms1V1lUSlNXVmxzV21GWFZsWjBaRWhPV0ZJd2NFbFdWM2h2VmxaYVJsTnJlRmRTYkhCeVZqQmtUMUpzY0VkaFIyeFhZa2hDUzFac1VrdE5SMDE0VjJ0b1ZHSkdjRmxaYTFwTFdWWlpkMkZGVGxoU2JHdzBWakl4UjFkR1NsVlNiRnBYVm5wR00xWkhlRXRTYkU1VlVXeGthR0V4Y0RKWFdIQkhWVzFXUjFwSVRsZGlWM2hVV2xjeE5GWXhXblJOVkZKYVZqRmFlbFpYTlV0WFIwcEpVVzVPVjJGcldreFZNVnAzVW14a2RWcEdaRTVoTVZreVZsWmtOR1F4V1hsVGEyaFdZV3MxV0ZWclZtRmpiR3cyVW0xMGExWnNTakJaTUZwUFYwWkplV0ZIT1ZkTmJtaHlWRlZhYzFkR1VuVlViR2hZVWpKb2IxWlhlRk5qTVZwSFZXeGthRkpWTlZSVVZscExaV3hrY21GRk9XaFNiSEI1V1RCYWQxWnNXWHBSYTNoWFlXdHdURlpzV2t0WFZuQkhXa1prVTFadVFsRldNbmhYV1ZaUmVGcEdhRlJoTWxKWVdXeGtOR0l4VWxWUmEzUldWbXh3TUZSVmFHdGlSa3B6Vm1wV1ZrMVhhSFpXYWtwTFkyeGtjMWRzY0dsU2EzQTJWbXBDWVZsWFVraFdhMmhUWWxob1ZGbHJhRU5UYkZwSFZteE9WMDFYVWtoVk1qVlBZV3hPU1ZGdFJsVldWbkJvV2tkNFdtUXhjRVpYYlhoWFRVWndTMVpVU2pSaE1rWklVbGhrV0ZaRlNsaFpiR2hEVTBac1ZWTnJPV3RTYTNCNVYydGtSMVV4V2tkWGJtUllWak5TV0ZwRVJtdGpNV1IxVlcxNFUyRjZWbFpXUmxwV1pVVTFSMWRZYkU5V1ZHeGhWbTF6TVZOR1dYbGxSbVJZWWxWV05WWlhlRk5YYXpGSFkwZEdZVkpGV25KWk1qRlRVMGRLUms1V1pFNVdWemg1Vm0xd1MwMUdWWGhXV0d4VFlURndUMVl3Vm5kVlJsbDNZVVZPV0ZadGVGWlZNakExVjBaS2RGVnNhRmROYmxGM1dWUkdTMk14WkhWaVJsWk9WbTVDZVZkV1dtRlpWa3B6VjI1R1dHSkhVbFJaYTFwM1lqRlplRmR0Um1oTlZYQjVWRlphYTJGV1NYZFhiRkphWVRGd00xWlZXbUZrUlRGSllVVTFUbEpGV2xsV2FrbzBZakZTYzFOcldsaGlSbHBXVm0xNGQwMHhWWGhYYkZwc1ZqRmFTVlF4Wkc5Vk1rVjZVVmhrVjJKSFRqUlpha1phWlZaS2RWTnJPVmRpUlhCWFZtMTBWMWxYUmtkWGJsSnNVak5TY2xadE5VTlRSbHBJVFZoT1ZrMUVSbGRaYm5CSFZqSkZlRk5yYUZwV1JYQlRXbFphUzJNeGNFZFZiV3hwVW01Q1ZWWXhXbXRPUjFGNFdrVmthVk5GTlZkWlZFRXhWVVpXZEUxVVRrNWlSbG93V2xWa1IyRkZNVVZTYTFwV1lsaG9kbFpxUVhoalZrcHhWR3hrVjFKV2NFMVdiWGhoV1ZkTmVWTnJaR2hTYlZKUFZGY3hibVZXV25OWGJFNVRUVlV4TkZVeGFHOVpWazVIVjJ4U1dtRXhWWGhaYWtaM1YwZFdTRkp0ZUdsU2JrSmFWa1pXYjJJeFduSk5XRTVZWW01Q1dWbFVTbTlVUmxsM1drVjBWMVl3Y0VsVU1WcHJZVWRGZDJOR2JGZFNNMUpvV1RJeFVtVkdjRWxWYkU1cFVqSm9WVmRYZEdwT1IxWlhWMnhrV0dKVWJIQlVWbHAzWld4WmVXUkhSbWhpUlhCV1dXdGtiMVl5U2tkalJFNWFWbFp3TTFWcVJtdGpNWEJJWkVaT1RsSkdXa3RXTW5oWFlUSkplRlZ1VG1GU1ZuQlZXV3RrYjFkR2JITlZhMDVPVFZoQ1YxWnNVa2RWTURGeVkwVm9WMDF1VFhoV2FrWmFaVVpPZFdGR1pGZE5NbWh2VjJ0U1MxSXhTWGhYYmxaVllsVmFWRmxZY0Zka01WcEhWMjFHYTAxRVJraFpNRlpoWVVaSmVsVnVRbFppV0dnelZGVmFkMUpzVm5KUFZtUk9WbTEzTWxac1pEUlJNVmw1VW01S1UyRnNTbGhaVjNSM1ZFWldjMWR0ZEdwTldFSklWa2N4YzFVeFpFWlRhM1JYWWxSQ05GcEVSa2RrUmxweVlVWldhVkl4U2xaWFZ6RXdaREpOZUZadVVrNVdhelZ4VlcxNFlVMUdVbk5XYXpsWFZteHdNRlpYTlhOV01ERnhVbXRvV2xaV1ZqUlpNbk40VmxaYWMxcEdUazVOVlc5NVZqRmFWMWxXVG5SV2JHaFRZVEZ3VVZadE1WTlVNVlowWlVoa1ZWWnNjRWhYYTFKVFYyeFpkMDVXYUZaTmFsWlFWbXhrUzFKck5WWlBWbVJvWVhwV01sWnFSbUZaVmxwWFUyNVNVRll6UWs5V2JUVkNaREZhV0dWSE9XcE5WbkF3VlRKMGExZEhTbFpYYlVaYVlUSlNkbFpFUm5kV2JHUjFWR3hrYVZJeFNqWldNblJyWkRGU2MxZHVUbXBTUm5CWVZGYzFVMk5zYkRaU2JFNXFUVmhDUjFZeWVGTmhWazVHVTJ4d1dGWXpVbWhYVm1SSFVqSk9SbFpzVG1sU1ZGWjVWbGN4ZWsxWFZsZGFTRXBoVTBVMVYxUldWbmRsVm10M1YyNU9WMDFyY0ZwVlYzaERWakZhUmxkc2FGWmhhMXB5V2taYVMyTXhUbk5oUms1T1lsZG5NRlpxUm10T1JsbDVWVmhvVkdKck5WbFphMlJ2WXpGV2NWUnNUbWxOVm5Bd1drVm9UMVF4V25SbFJtUlhWbnBHU0ZacVFYaGpiVTVIWTBaa1YyVnNXazFXYlRCNFV6RmFWMU51VG1oU2JWSlBWVzAxUTFSV1pGVlRhbEpyVFZVMVNGVXlOVTlXVjBwWVpVYzVWVlpYYUVOYVZscGhaRWRTU0ZKdGFFNVNSbHBKVm10YWIyRXhVbk5hUlZwUFZtMTRZVmxzYUc5VVJscEZVbTFHYW1KSFVubGFSVnAzVmpKS1NWRnFVbGRXZWtWM1ZGVmFZVkl4WkhWVWJYQlRVbFZ3YjFaWGVHdFVhekZYVjI1U2FrMHlhSEZaYTJSVFZteFZlV1ZIZEdoV2JWSkhWRlZvYjFZeVNsbFJhM2hXWld0YWFGWnFSbXRrVms1elYyMXNVMDFWY0ZGV01XTjNaVWRKZVZac1pHRlNiWGh4Vld4a1UxbFdXbkZTYTNSVVZteHdXVnBGWkRCV01WbDNWMVJLVjJKVVFURldiRnBoWkVkR1JsUnNWbGRpU0VKdlYxUktOR0V5VWtkVGJrNXFVbTFTVDFWdGVISmtNVnB4VTJwQ1YwMXJiRFJXTW5SdlZrZEtjazVXVmxwaVdFMTRWbXBHYzJNeFZuSmFSM1JwVW01Q05GWlhNREZVTVdSSFUxaGtUMUpGY0ZkWmJGSkdaREZzVjFkcmNHeGlSbHBXVlcxNGIyRldTbk5qUkVwWFlURktTRll5TVZkV01WSjFVMjFzVTJFelFuWldSbU40WWpGa2MxcEdaRlpoTTFKWFZGVlNRMDVHV1hsa1J6bHBVbXR3TVZWWE5VOVdiVXBaVkZob1lWWldjR0ZhVm1SWFUwVTVWMXBGTlZOU1ZXdDNWbXhTU21Rd05WZGFSV1JZWW1zMVZWbFVUbTlXTVd4WVpFZEdWbEpzV25oVmJYTTFZV3N4Y21ORmJGcFdWbkJRVmtkemVGSnRUa2RYYkdScFVqRkZkMWRYY0VkU2JWWkhZMFZzVldKSGFIQlphMVozWlVaYVdHVkdUbXBOVmxZMFZsZDRhMWRIUlhwVmJGWldZbGhvTTFSVldsTmpNVnAwWkVaa1RsWlhkM3BXYWtaVFV6RlplVk5zVmxkaVJVcFlXV3hTUjFSR1dYaGFSV1JUWWxaYVNGWnRlR3RoVms1R1UyNWFWMkpHU2tSV2JURlhVakZ3Umxkc1FsZGlWa3BhVjFab2QxWXhXa2RXYms1WVltczFUMVJXV25OT1JsbDVaVWQwV0dKR2NIcFphMUpUVjBkRmVGZHVXbGRoTWxKSFdsWmtSMUl4WkhOalJtUk9UVzFvVGxadE1IaE9SMDE0VjJ4a1ZHSnNXbWhWYWs1RFkwWldkR1ZJWkU5U2JIQlpWRlZTUjJGRk1WZFdhazVWVm14d2VsWlhNVVpsVjFaSFdrWndhVkl5YURKV2JGWmhXVlphVjFOdVVsTmlSMmhZV1ZSR2QwNUdXblJOVkZKb1RXdGFSMVJXV25OVmJVcDBaVVpvVm1Gck5WUlpWVnBoVTBVeFYxcEdaRTVXTVVsNFZtMHhORll5UmxkVFdHeG9VbTVDV0ZacVRrTlZSbXh4VTJ4a1YwMVhVbnBaVlZVeFZrWkplV0ZHYUZkU2JIQm9XWHBCTVZJeFpITmhSM2hUWlcxNGRsWkdXbFpOVms1WFYyeG9iRkp0VWxoWmJGWjNWbXhXYzJGSGRGZFdiSEJIVmpJMWQxWXlTbGxoUjJoYVRWWndTRmw2Um5kU2F6VlhXa2RzYUUxSGREVldiWEJIVlRGRmVWTlliRlpYUjJob1ZUQldkMVF4V25OYVJrNVhWbTE0ZVZadGREQlhSbHB6WTBSQ1lWWlhhSEpaVlZwTFpFZFNObE5zV2s1aWF6QjRWbXhTUjFsWFRYaFVibFpxVW0xU1QxbFhkR0ZPYkZweFVXMUdWR0pXV2xsVmJYUnpWMGRLU0ZWdVFsZGhNVnBYV2tSR1dtVkdaSFJTYkZacFZteHdXVlp0TURGVE1rWkhVMjVLVDFaNmJGWldhazV2VkVac2NWSnRSbGhTTURWSFdrVmtjMVJzV25KWFZFSlhZa2RSTUZkV1dscGxWazV5WWtaS2FHVnRlRmhYVjNodllqQXdlRlZzV2xoaWJWSllXV3RvUTFJeFpISlhiVGxvVm10d01GcEVUbmRYUmxsNlZXeFNWMkZyV21oYVJWcFBZMjFHU0dGR1VsTmlhMHBhVm10YVYxbFhVWGxVYms1WFYwZFNhRlZzWkZOV1JsSlhWMjVrYkdKSGRETlhhMmhQVjBaS2NtTkdXbFppUmtwRVZtcEJlRll4VG5KaFJtaFhZa2hDYUZkc1dtRldNazUwVW10a1lWSXlhRTlXTUZaTFRsWmFjMWt6Wkd4U2JGWTBWbFpvYjFkSFNuTlRiRUpYWWtaVmVGWlZXbUZrUjFaSldrVTFVMkpGY0ZoWFZsWnFUbFphY2sxVlZsTmliWGhZVkZjMVUyUnNXblJqTTJocVZteHdlbFpYZUhkV01VcFhZMFV4VjFZelFraFpWRXBUVWpGT2RWVnNUbWxTTVVwUVZrWldVMUpyTVVkWFdHeHJVak5TVUZWdE1UUlhWbHBJWlVkMFZrMXJjRWxhVldNMVZtMUtWVkp1V2xkaE1YQjZXVEo0YTJSV1pIUmxSazVwVm10d1lWWXlkRmRoTVVsNFYxaGtUbGRGY0ZsWmEyUnZWakZTV0dOR1pGaFNiSEJaVkZaV01HRXhTWGhYYTJoYVZsWndNMWxWVlhoWFZrWnlUVlprYUUxV2NHOVdiWEJMVlRGS2NrMVdaR0ZTTUZwVVZGUkNTMVZHV25SbFJ6bFNZbFphU0ZZeU5VdFhhekI1WVVoS1ZWWnNjRmhVYkZwV1pWZFdTR1JHWkZOTlNFRjNWbXhrTkdJeFpIUlRhMmhvVW14S1dGUlZXbmRXTVhCWFZsaG9WMDFZUWtsWk1GVXhWMFpLVm1ORmVGZGlXRkp5Vkd0a1JtVldTbk5hUjBaVFZqRktWbGRYZEdGa01XUlhWMjVHVldKVWJHOVZiVEZUVjBaWmVVMVVRbFpOUkVaWlZsZDRkMWR0UlhoV1ZFWlhZV3R3VEZacVJrOWpNa3BIV2tkc1dGSlZjRVpXTW5SVFVqRlJlRmRZYkZSaE1sSlpXV3hrYjFaR1duTlZiR1JZWWtkU1dWcFZXbXRXTURGRlZtdG9WMDFYYUhwWlYzaExWbGRLUjJGR1ZsZGlTRUY2Vm1wQ1lXTnRVWGhqUldoUVZtNUNXRmxVVGtOWGJGcHpXa1JTYVUxV2NIbFVWbFpyWVd4S1dXRkhhRlppUjFKVVZtdGFWMlJIVGpaU2JHaFRUVVp3U2xkc1ZtdGlNVkp6VjI1T2FWSkdjRmhaYkZKRFRURndWbHBHU214U2JFb3hWVEp6TVZZeVNsZFRiR3hYWVd0S2NsUnJXbUZXTWtwSFZteFNhVkpVVmxsV2JURTBZekF3ZUZwSVNsaGhlbXhaVlcxNGQwMUdjRlpWYTA1WVlYcENObFZYZEc5V01ERjFZVWRvWVZKWFVsaFZha1pyWXpGa2RHSkdaRk5pU0VFeFZtcEdhMDFIUlhoVVdHaFVWMGRvVmxsdGVHRmpWbFowVFZaT1ZVMVhlRmxhVldSSFlrWmFjMk5FUWxwTlJsbDNWbXRWZUZZeVRrbGpSbWhvVFcxb1RWZFdXbUZUYlZGNFdraE9WbUpIVW05WlZFWjNWRlphUjFwRVVscFdNREUwVm0wMVMyRXhTbk5UYXpsWFlrWktXRll4V21GWFJURlZWVzF3VGxZemFGbFdWRWt4VlRGYWRGTnVTbFJpUjFKaFZtcE9VMkZHVlhkWGJFNVhWbXR3TUZwRldtOVZNREZGVm10b1YwMXVVbWhhUkVaYVpEQXhWbFpzWkdoaVJuQlpWbGN4TkdReVJrZGlSbFpVWVRKU1ZGUldWVEZYYkd4eVdrYzVWazFyY0VkWk1GcHZWMFpaZWxWdGFGWmxhMXB5VldwR2ExZFhSa2RoUjJ4WFZtNUNWbFpyV21GWlYxRjNUVlZrVjJKc1NrOVdhMVpMVm14c2MxWnNaRTlTYlhRelZtMDFUMWRHU25OaVJGcFhWak5vVkZZd1dtRmpNazVIV2tkR1YySklRbEZYV0hCTFV6RkplRnBJVW1sU01taFBWRlZXZDFkc1duRlNiVVpvVFVSR1NGWkdhSE5WTWtWNVZXeG9WMDFIVWxSV01WcHpZekpHUjFSdGNGZGlXR2cxVjFaV1YxUXhXa2RYYms1VFlXeEtXVmxVU2s1TlZscDBZek5vVjAxck5VZFhhMXBoVkd4WmVWb3pjRmRpV0VKSVYxWmFTMlJHVG5GWGJFcHBVakpvV1ZkWGRHOVJNa1pIV2toT1dHSlZXbFpVVjNNeFpXeHJkMVp0ZEZkaVZYQlpXVlZWTlZZeVNraGhSVkpZVm14d2FGcEZWWGhUVjBaR1QxWk9UbFpXYTNoV2JUQjNUVlpSZUZwRlpHRlNWMmhYV1d0a05GbFdiRlZTYkZwc1VtMTBOVnBWWkVkaE1VbDRWMnRrWVZKV1ZYaFdWRXBMVWpKSmVscEdhR2xTYkhCdlZtdFNSMWxYVG5KTlZteFVZa2RTYjFscmFFTlhSbHAwWTBVNVVrMVhVa2hXTWpWSFZrZEZlbFZzVmxaaVdHaE1XbFZhWVZkRk1WWmFSbVJPVWtWSmVsWkhkRk5STVZsNVUyeHNVbUV5YUZoWlYzUmhZMnhaZDFkcmRHcGlTRUpJV1ZWa2MxWXdNSGxoUmxwWFRWZE9ORlJWV2s1bFJuQkpWR3hvV0ZJeWFHaFdSbEpMVlRKTmVGWnVVbXhTYlZKUVZXMHhVMlZXV25STlZFSm9VbXh3ZVZSc1ZtdFhhekZIWTBod1YwMXFSa3hXTVZwVFYxZEdSMXBHWkZkaWEwcGFWakowVjFadFZrZFhXR2hXWW14S2MxVnRNVk5qUmxWM1ZtdDBXbFpzYkRWYVJWcHJWakpHTmxac2JGWmlXRkp5Vm10a1MyTnJOVmxTYkZwcFYwZG5lbFp0Y0Vkak1rMTVVbXRvVUZZelFuQlZiVFZEVGtaYVZWTnFRazVTYlZKSVZqSTFTMWRIU25WUmJHUlhZV3MxZGxreWVITldNV1J5WTBkNFUyRjZWalZXUmxwaFlURlpkMDFJWkZSaE1uaFpWbTE0UzFSR1dsVlNiSEJzVW14YU1WWnRlRmRoVmxwWFkwWldWMkpZVW1oWFZscGhWakZrY2xwR2FHbFNNVXA1VmtaYVlWTXlWbk5YV0dob1VucHNXRmxzVmxkT2JGWllUbFU1VjJKVmNGcFpWVlp2VmxkRmVHTkhhRlpOUjFKVVZUQmtVMUl4Y0VkVWF6VlVVbFZyZUZadGRHdE9SbXhZVTFob1lWTkdTbFJXTUdRMFZqRnNjbGRyZEZoU2JYaFdWVzAxYTFkc1duVlJhMXBXWWxSR1NGbFhNVXRXTVU1eVlVWm9hRTFzU2paV2JGSkxVekpPYzFOdVJsVmlSMUpQV1cweGIxZFdXWGhYYlhSVFlsWmFTRmt3Vm5OV1YwcElZVWhDV21FeFdqTmFWM2hoVjBVeFNXRkZPVk5pVmtwSlZtcEpNVkl4V2xoVGExcFBWMFZ3WVZsVVJuZE5NWEJXVjJ4YWJGWXhTa2xWYlRGelZUSktTR1I2UWxkaGEyOTNXV3BHV21Rd01WbFdiV2hUVWxSV1dWWkdWbUZrTVZaSFZtNVNiRkpVYkhGV2JURlRaV3hrY2xwSVRsaFNhM0I1V1RCb1lWWXdNVmhoUkU1V1pXdGFVMXBXV2xOWFYwcEhWbTFvVGxkRlNscFdNV1F3V1Zac1dGTllhR3BTYldoelZXcENZVmRXV25STlZrNVlWbTVDUjFkWWNGZFdiVVkyVW14a1ZXSkhhRE5XTUdSR1pWZEdSMUZzWkdoaE0wSk5WbTB4TkdFeVVrZFRiazVoVWpKNFdWVnFTbTlUYkZweVdrUkNXbFp0VWpCV2JYUnZWVEpGZVdGSVNsWmlWRVoyVm10YVUxWnNaSE5qUlRWWFlsWktObFp0TUhoU01rWkdUVlprYWxKdGFGaFVWelZEWVVaYWNWTnJkRk5OVlRVd1ZXMTRhMkZXU25WUldIQllZa2RSTUZZeU1WSmxSMDVHV2tkR1UyRjZWbmRXYlRFd1pERk9jMXBJU2xkaVZWcFdWRlphUzJWc1dYbE9WbVJXWWxWV05sWlhlRzlYYlVWNVZXeENWV0V4Y0ZSWk1uaDNVbXhrZEdWR1pHaE5NRWt5Vm1wS01GbFdWWGxTYkdoVVlUSlNjVlZ0ZUV0WFJteFlaRVYwYTJKR1dsWlZiVEV3VmpBeGNtTkZjRlpOYWtaSVZsUktSbVZzUm5OUmJHUlhaV3RKTUZac1VrZGhNVWw0WTBWc1ZHSkhVbGhWYlhoM1YxWmFSMVpzVGxOTlYxSklWbXhvYzJGc1NsaFZiR2hhVjBoQ1NGUldXbk5XYlVaSVVteG9hVkp1UWpaWFZFSnZVekZhY2sxVmFGWmhNbWhYV1ZkMFlXRkdiRFpUYTJSVFRWaENSMVJzVlRGV01WbzJZWHBHVjJKVVJUQlhWbHBXWlVaT1dXSkdWbGhTTW1oYVZtcENhMkl5VGxkV2JrNWhVbXMxYjFWdGVHRk5SbEpYVjJzNWFHSkZjSHBaYTFKUFZqQXhkVlZZWkZkaGExcG9XWHBLVDFKdFJrZGFSVFZvWVRGd1NsWnRNWGRSYlZaSFUyeGtVMkpyV2xkWmEyUlRWMFpTVlZOdE9XbE5WMUpZVm0weFIxWlZNVlpqU0d4VllrWndkbFpWV21Gak1rNUpVV3hrVGxKdVFreFhiR1EwV1ZaYVYxSnVVbE5pV0VKd1ZtMTBXazFHV1hsa1J6bFdUVlphU0ZZeU5WTmhSazVHVTJ4b1dtRXlVblpWYTFwV1pWZFdTR1JHWkU1V2JrSTJWakowWVZsV1VuTlhibFpTWVd4YVdGVnRlSGRYUm14VlUydGthazFXU25sV01qRjNWVEpLV0dGSGFGZGlXRUpRVmxSS1IxSXlSWHBpUjNoVVVqRktWVmRYZEc5Uk1VNUhWMnRvYkZKVWJGWlpiRlpYVGtacmQxWnVUbGROYTFZMVZrZHdVMWR0Um5KWGJGSmFUVzVPTkZadGVHdGtSMFpHVGxVMWFWWXlhR0ZXYWtaclRrZEplRkpZYUZaaE1sSlhXV3RhZDJGR1ZuTlhibVJxVFZad01Ga3pjRWRYUjBwSVpVWmtWMDFxUlhkV01GcExZMjFLUlZkc2NGZFdia0paVm1wQ1lWbFhVa2RXYkZaU1lsVmFWRlZzV25kbFZscFlZMFYwVkUxVk5WaFdiVFZMVkRGYWRGVnRPV0ZXTTJob1YxWmFZV014YTNwaFJUbFRUVlZaZWxaR1dtRmhNa1pHVFVoc1ZtSkhhR0ZXTUdoRFpXeGFkR1ZJVGxoV01EVkhWMnRhYjFVeVNrZFhWRVpYVWpOb2RsbFVSbHBrTURGWlUyMXdVMVl5YUZoV1JtTXhWVEpTYzFkdVJsTmlWVnBVV1d0V2QyVkdXbGhsUjNSVllrVndNVlZYZUhOWFJtUkpVV3Q0VjFKRldrdGFWbHBUWTJ4d1NGSnNUbWxXYTNBelZqRmFVMUV5VVhkTldFNVlZbXRhVkZsc1ZtRlhSbEpYVjI1a1RsSnNjREJhUldRd1ZqRkpkMk5GYkZkV00yaDZWakl4UzFkWFJrWmxSbkJvWVRGd1dWZHJWbFpsUmxsNFZXNVNhbEpyTlhCVmFrNXJUbXhhZEUxSWFFNVNWRVpJVm14b2IxZEhTbkpPV0VaV1lURmFURmRXV2xOV2JHUjBVbXhXVTJKSVFrcFhiRlpyVWpKR2RGTnNXbXBTVm5CWVZtcE9iMlJzYkZaV1dHaHJVakJhU0ZWdGVHOVdNa3BIWTBjNVYxZElRa2hYVmxwclVqRlNkVk50UmxOTmJXaFZWMWQ0WVZNeVVuTlhhMlJoVWtaS1ZGbHNXa2RPUmxsNVRsVmtWMUl3V25wVk1qRkhWakpLVlZKc1VsWmhhMXBVVm1wR1lXUldVblJoUms1b1RUQkpNbFl4VWtOV2F6VlhWMWhzVkdFeVVsVlphMlJ2VjBaU1YxZHVaR3BpUm5CNlZqSjBhMkV4U25KalNIQmFUVVp3Y2xsV1dtRmpiVXBGVkd4a2FWWkZTWHBXUmxwaFZXMVdSMk5GV21oU2JFcHZWRmN4YjJSc1dsaGpSVTVhVm0xNFdGbHJXbGRWTWtwMFZXMDVWbUpZYUhwVVZFWmFaVmRXUms5WGFHbFdXRUpLVm14ak1XUXhaSEpOVldoV1ZrVktXRmxYZEVkT1JsWnpWMjFHYW1KVldraFhhMXBQVlRGYWRWRnVXbGROVm5CVVZXcEdWbVZXVWxsaFJsWnBZVE5DV2xkWGRHdGlNa2w0Vld4b1QxWjZiRmxaYTFwM1RVWndSbGR0ZEZkU1ZFWjVWakowYjFZd01YVmhSbWhYVmtWd1RGVXhXa2RrVmxKeldrZHNXRkpyYkRaV2ExcGhXVlphZEZac2FGZGhNbWhSVm1wS2IxZEdVbFpYYkhCT1lrWndXRmRVVG10VU1WcHpZa1JTVjAxdVFtaFdWRVpoVW14T2RHRkdXbWhOVm5CSlZrWlNSMlF4V25OYVNGSlRZa2RvV0ZsdGRFdFRiRnBZVFZSU1ZVMVdiRE5VVmxwaFlXeEtjMk5HYUZwV1JWb3pXVlZhYTFZeFpISk9WM1JPVWtWYVdGWXlkR3RqTVZwSFUyeHNVbUpJUWxsV2JURnZUVEZzTmxOcmNHeFNiVkl4Vmxkek1WWXlSalpXYkZwWFZucEZNRmRXWkZkak1rcEhWMnh3YkdKR2NGbFdSbFpUVWpKV1YyRXpaRmhpVlZwWVdXeFdkMU5HVlhsa1JrNVhUVVJHTVZsVlpHOVdWMHBaWVVWNFdtVnJjRWhWYWtaclpFZEtSMkZHVGxkU2ExbDZWbTB3ZDJReVVYbFdhMlJVVjBkb1ZWWXdaRzloUmxWM1ZsUkdhVTFXV2pCWk0zQkhWbFV4VjFOc2JGVldiVTB4VmpCYVMyTXlUa2xoUmxwcFZrVmFTVlp0TVhwbFJscHlUVlpXVm1KSFVuQlZha3B2VFd4YWNWRnRkRlJOVlRWSVZtMDFWMVZ0U2tkalJUbFdZbFJXUkZaR1dtdFdWa3AwVW0xMFRsWXhTa3BXYkdRd1lqRlZlVk5yYUdoU2JFcGhXVlJLYjFFeGNFVlNiVVpUVFZkU2VsWkhlR0ZVYkZsNFUydHNWMkZyYTNoV2FrWlhaRVpLV1dKR1dtbFNNMmhvVm0xMFYxbFhSa2RoTTJ4c1VtNUNjbFJXWkZObFZuQkdXa2hrYUZac2NGWldiWFJyVmpGYWRGUnFVbFpoYTFwaFdsVmFhMWRYU2toU2F6Vk9UVVZ3V2xZeFdtdE5SMUp5VFZWa1lWSnRVbGxaYkdoVFZrWlNWMWR0Um14aVJuQXdXbFZWTldGR1duSmlSRkpXVFdwV2NsWnFSbUZPYkVaWllVWmFWMUpXY0ZWV2JYQkhaREZPVjFSdVRtRlNNbmhaVlcxMGQxZHNXbkpYYlVaWFRXc3hNMVJzV210V01rcHpVMjVLVm1Gck5WUlhWbHBoWkVkU1NWcEdaR2xTYmtGM1ZrZDRWMVF4WkVoVGJGcFhZV3hLV0ZSWGNFZFRSbVJYVjJ4d2JHSlZXa2xWYlRGSFZqRmFkVkZ1YkZoaE1WcHlWbFJHVDFOR1duSmhSMnhUWWxaS2QxWlVRbGRUTVZKSFYyNVNUbFpGU205WldIQkhWMFphUjJGSE9WZGlSMUpKV1ZWYWMxZHRTbGxVV0doYVRWWndXRnBHWkU5VFZsSnpXa1UxVjAweVp6SldiWGhyVGtkRmVGWllhRlJpYkVwelZUQmtiMVl4YkhOaFJ6bFdVbXh3ZUZWV2FHOWhiVXBJVlc1c1dHRXhjSEpXVkVwWFkyeGFXVnBHWkdsWFJVcE5WbGh3UjFReFdYaFRibFpUWWtkb2NGVnFSa3RrTVZwWVkwVmtVMDFFUWpSV01uUnJWakpLVmxkdFJsZGlXRkl6V2xaYVUxWXhaSFJrUm1oVFRVaENZVlpXWkRSVk1WcDBVMnRrV0dGck5WaFVWbHAzWVVaWmQxcEZPVk5oZW14WVZqSnpNV0ZGTVZsUmEzQlhUVmRSZDFkV1pFWmxSbkJHWVVaT1dGTkZTbGhYVnpFd1pERlplR0pJVG1oU2VteHZWVzAxUTFkV2NGWmhSVGxvWWxWd1NWWlhjRU5XYlVwWllVWm9XbFpzY0V4V01WcEhZMVprYzJGR1pGTldXRUpaVmpKNFYxbFdaSFJXYTJSaFVtMTRjVlZ0ZUhkalJscHhVMjA1V0dKR2NEQlVWbEpUWVRBeFZrMVVVbHBOUm5Cb1ZqQmtTMlJHVm5OV2JHUnBWMGRvYjFaR1ZtRmtNVXB6V2toS1VGWXlhRmhaVkU1Q1pVWmFWMXBJWkZWTlZtdzFWVEo0VjFWdFJuTlRiRnBhVmtWd1ZGWlVSbmRXYkdSelZHMXdUbGRGU2twV1Z6RTBWREpHVjFOdVZsSmlSbHBZVkZaa1VtUXhiRlZTYkZwc1ZteEtlbGRyV21GaFZrbDRVMnh3V0ZaNlFqUldWRVpoVmpGa2RWVnRlRk5pVmtwUlZtMHdNVkV4V1hoYVNFcFhZbGhTV1ZWdGRIZGxWbXh5VldzNVdHRjZSa2hXTWpWaFZqSktXVlJxVWxwTlZuQk1XVEl4UjFJeGNFWk9WMnhwVmpKb01sWnRlR3BrTWxaSFZWaG9WV0pIVW1oVk1GVXhWMVpzYzFwSE9WVk5WbXd6Vm0xMGExUXlTa2RqU0hCWFZqTlNVRmxWVlhoV01rcEZWV3hrVTAweFNubFdiWFJyVXpKT2NrNVdaRmhpU0VKWlZUQldTMWRXV25GU2JVWlhUV3N4TkZZeU5WZFpWa3B6VTJ4U1dtRXlhRU5hUkVacll6RmFkR1JGTlZOaVJWa3dWbFJKTVZReFdYbFNiazVVWWtkb1dGbHROVU5YUmxwV1YyeHdhMDFYVWpCYVJWcFRWVEF4UjJORmJGZGlWRVV3V2tSR1dtVkdUbk5oUmtKVVVqRktXVmRXWkRCVE1rWkhZa1JhVTJKWVVsVlZiWGhoWlZac2NsZHRPV2hXYlZKSVZUSjRRMVl5U2xsUmJFSmFZV3RhWVZwVldtdGpNa1pHVGxaU1UwMXRhRkZXYkdONFRrZFJlRlJyWkZkWFIzaFFWbXhvVTFac1VsZGFSazVVWWtaYVdWcFZZelZXTVZwellucEtWMkpVVm1oWFZscEtaVzFHU1dOR1pHaGhNVzk2VmxjeE5HRXlVa2hXYTJSVllYcFdWRlZ0ZUhkVE1WcDBZMFYwVGxKdGVGbFZiR2h6VlRKS1NGVnRhRlppUjFKMldXcEdWMlJYVGtsVWJHaFRZa2QzZWxkV1ZsZFVNVnBIVTI1U2JGSnNjRmRaYkdoVFRURnNjbGRyZEd0V2ExcDVXVlZhZDJGRk1YTlRhMnhYWWtaS1RGVjZSbXRUUmtweVlrZEdVMkpXU25kV2FrSnJZakpKZUZwSVNsWmhNMUpZVkZaYWMwNUdaSEpoUlRsb1VtdHNObGxWV2xOWGJHUkpVV3hvVjAxV2NHaFZha1pyWkVkU1IxZHJOVmRXUmxwS1ZtMXdSMkl5VFhsU1dHaFVZV3h3Y0ZWdGVIZFpWbXhWVW01a1RtSkdTbGxhVldoUFlXMUtTRlZxUWxaaVdHaDJXVlphWVZZeFpGVlJiR2hYVWxWd1ZWWnJVa2RYYlZGM1RWWmtZVkl6UWxSVmJGSlhWMFprV0dSSFJtdE5WbkJJV1RCV2ExZEhTblJWYkZKVlZtMW9SRlZxUmxOak1YQklUMVpXYVZJeFNraFdWM2h2WWpGWmVWSnVTbGhpYTFwV1ZtMHhVMVV4Y0ZaWGEzUllWakJhU1ZWdGVGTlZNVnBIVjIxR1YwMVdjRlJWYWtwU1pVWndSMXBIYkZSU1ZGWnZWbGMxZDJNeVNYaFdibEpzVWpCYWMxbHJXbk5PVmxKeldrUkNWMDFyY0VkWk1GSkRXVlpPU1ZGcmVGZGlXRTQwV2taYVYxZFdjRWRhUjJoT1YwVktUVll5ZEZOU01rVjVWRzVTVTJFeVVtaFZiVEZUVkRGU1dFMVhPVmRpUm5Bd1dsVmFUMVV3TVZobFJtaFlZVEZ3Y2xaVVNrdGphelZaVVd4YWFWWkZXbFZYVjNCSFl6RmFWMU51Vm1GU00yaFlXV3RvUTFOV1duUk5TR2hUVFd0YWVWUldXbTlXYlVWNVlVWm9XbUpIYUhaYVYzaHpWakZrY21SSGRGTmlSbTk0Vmxaa05HUXhaRWRVYTFwVVlrZDRXRmxYZEhaTlJteFZVbTEwVTJGNlJsaFdiWGhoWVZaS2NtTkdRbGRpVkVWM1ZqSnplRkl4WkhWU2JGSlhVbFp3VjFaR1dtdE9SbVJIVmxoc1QxWllVbFpVVmxwM1RVWnNWbGR0ZEZoaVZYQklWVEowYTFaV1dsZGpSRTVYWVd0YWNsbDZTazlUUjFaSFdrVTFWMWRGU2tsV2JYaGhZVzFXU0ZSWWFGZFhSMUpQVm14a05GVXhiRlZVYTA1WVVtMTRlVmRyVlRGaVJrcDBaSHBLVm1KVVJYZFdhMXBMWTIxT1IyTkdjR2hOYkVveVZteFNTMUp0VVhsVWEyUnBVbTFvV0Zsc1drZE5NVnBZWTBWS1RsWnJiRFJYYTFweldWWktkR0ZJUWxaaGExcE1XbFZhYTFkSFVraFBWa3BPVmxSV1NWWnFSbTlqTWtaMFZtNUtXR0pVYkZoWlYzUkxUVEZXY1ZKc2NHeFNNRnBLVjJ0YWExUnRSWHBSYkdSWFZucEdNMVpFUm1Gak1XUnhWMnhPYVZJeWFGaFhWbVF3V1ZkT2MxZFlhR0ZTV0ZKVVZGWmFkMDFHYkZaV1ZFWm9WbXR3V2xWV2FITldNa3BaWVVoR1lWSkZjRmhWYWtaaFYxZEtSMVZzYUZOTmJXZ3pWbXhqZUU1R2JGZFhhMlJwVTBaS1QxWnRjekZYVmxaMFpVZEdUbEpzU2xoV01uTTFZVlpKZDJORmFGcE5Sa3BFVm14YVlXTXhUbkpWYkdSb1lURndUVlp0ZUdGVE1rMTRZMFZrYWxJeWFFOVdiR2hEVm14YWRHTkZkR3hpVmxwSVZURm9iMWxXVGtkWGJGWmFZVEpTVkZrd1dtRmpiRnAwVW14V1YySklRalJXVm1ONFRVWlZkMDFXV21wVFIzaFdWRlphZDJOc1pGZFhhM1JYVm14d2VsWlhlSGRoUlRGMFlVVldWMkV5VVRCWFZtUlBWakZPZFZWc1RtbFRSVXBaVjFkNFlWTnRVWGhYYmxKT1ZrVktiMVJYZEdGU01WSldZVWhrVm1KVmNGWlphMXByVjIxRmVHTkZlRmROUm5Cb1dUSjRhMk14VW5OYVJUVlhZbXRKTWxZeFVrTldhekZYVmxoc1ZHRXlhSEphVjNSaFYxWnNWVkp0Um1oU2JYaFdWVEowYTFVeVJqWlNiSEJXVFc1b2RsbFdXa3BsVjBaSFlVWmtVMkpXU1hwV2JYQkhXVlpKZVZOclpGaGlSMmh2V2xjeE5GWldaRmhsUmxwT1ZtczFTRmRyYUV0WFIwcDBWV3hvVlZaV1NrUlVhMXBXWlZkTmVtRkdhRk5pU0VJMlZtcEplR0l4WkhSV2JrcHFVbXRLV0ZsWGRHRlZSbkJIVjJ4T2ExSnJjSHBXUjNNeFZHeGFXVkZzWkZkaVZFSTBWRlZhYzFZeVNrZGFSMFpUVmpGS1dsZFhNVEJrTWtaSFZtNUtXR0V6VWxoWmExcExWMFpaZVdSRVFtbFNNSEJJV1d0U1YxWlhTa2RqU0VwWFlsUkdURlp0ZUd0a1YwNUhZMFUxVTJKclNYbFdiWEJLWlVaS2RGWnNaRmRpYXpWV1dXdGFZVmRHV25ST1ZVNVBZa1p3TUZwVlpFZFdSVEZ5VFZSV1YxSXpVblpaVkVaTFZsWmFjMVZzV21sU2JrRjZWbXBHWVZsWFVrWk5WV3hvVWxSc1ZGbHJWbHBOVmxwWVRWUlNhRTFXY0VoWGExWnZZa1pLTm1KR1pGcFdNMUl6V2tkNFdtUXhaSE5hUjNSVFRWWndTbFpYTUhoa01rWlhVMWh3YUZKR1NsaFdhMVoyVFVac1ZWTnJaR3BoZWtaWVdWVmFZV0ZIUlhoalJteFhWbnBXTTFWcVJrOVNNV1J6Vm14T2FWZEdTbFZXUmxwV1RWZFdjMWR1VW14U00xSlhWRmQwZDFkR1ZYaFZhM1JYVFZWd2Vsa3daRzlXTVVwR1kwVTVZVlpXY0hKWmVrcExVMGRLUjFSck5VNWlWMmhZVm0xNGEyUXhTWGhVV0doaFVtMVNXVmxVU2xOaFJsWnlWbXQwYW1KR1NsaFhhMXBQVmtaS2MyTkljRnBXVjJoUVdWVlZlRlp0U2paVGJIQm9UVmhDTmxadE1IaFNNazV6Vkc1T2FGSnNXbTlVVm1oRFYwWmtjMWR0ZEZaTlZUVkhWREZhYTJGR1NYbGxSbEphWWxoU1RGVXhXbUZrUjA1R1kwVTFWMkY2UlRCV2FrWnZZVEZTYzFkc2FGWmlhMXBYV1d4b2IxUkdaRmRYYkU1WVVsUldXVlF4VlRGVWJGcHpWMWh3VjJGcmIzZFVWV1JIWTJzeFYxcEdVbWxpV0doWFYxZDBhMVV5Vm5OaVJtUllZa2hDYzFacVFtRlRWbEY0VjIxMGFGWnNjRWRXYkdoclYwWmFjMU5yZUZkV2VrWllWV3BHVjJNeVNraGlSazVwVWxoQ1lWWnNaSGRTTVUxNFZteGtXR0pzU25OVmFrNVRWakZTVjFwR1RsaFNiR3cwV1ZWa01GZHNXbkpqUldoV1RXcFdTRll5TVVabFIwNUlZVVpXVjFadVFqVlhiR040VkRGS2MyTkZaR0ZTTW1oeldWUkdkMWxXV1hsbFJtUnBUV3hHTkZZeGFHdFViR1JHVjJ4U1dsWkZjSFpXTUZwelZsWktkVnBHVmxOaVdHTjVWbFJLTUUxR1ZYaFhiazVZWW01Q1lWUlZXbmRqYkZweFVWaG9VMVpyV25oV1YzaHJZVlphUmxkWWNGZFhTRUpJVmtjeFYxSXhjRWxXYkZwcFVteHdkbFpHV205Uk1sRjRWMnhvYWxKVk5XRldiVEZUVTBaWmVVNVZaRlppUjFKSlZsYzFUMVp0U2xsaFJFNVZWbFp3VkZadE1VZFRSVGxYV2taT1YxSldjR0ZXYlhoclRrZE5lRmR1VWxSaVIzaFhXV3RrYjFkR2JISmFSazVWVW14V00xWXllR3RoYlVZMllrWm9XR0V5VW5wV2FrWkxZekpPUmxkc1pHbFhSVXBKVmpGYWExSnRWa2RhU0U1aFVteEtjRmxyVm5kV1ZtUllaRWRHV2xac1JqUlphMmhMVmpKS2RGVnNWbFppV0dnelZXMTRWMlJGTVZaYVIyaFRWa1ZhTlZacVNqQmlNVnB5VFZab2FGTklRbUZaVkVaM1ZFWnNObEpyT1dwTlYxSjZWMnRrYzFkR1NYbGhTRnBYWVRGd1ZGVnFTa1psUm1SWllVZEdWRkpyY0ZWWFYzaHZVVEpPUjFadVJsTmhNMEp5VkZaYWQxZFdVbFpoUnpsb1lYcEdXRlV5Y0VOV2F6RjFWVzFvVjAxR2NHaFZiWGhQWXpKR1IyTkhhRTVpUlhCUlZqSjRWMWxXYkZkVGJHUlVZbXhLY2xWdGVFdFdSbXhaWTBaYWJGSnNjRlpWTWpWM1ZERmFkRlZyYUZaTmJtaHlXVmQ0UzJSSFJrZGlSbVJvWVhwV01sWnRkR0ZXTWs1WFZHNU9WV0pZUWs5V01GWkxVMVpaZVdSSFJtbE5hMXBaVlcxd1lWWXlTa2hsUm1oYVlrWktTRlJ0ZUZOV01WcFpZVVpPVGxac2NHRlhWbFpoWWpKR1YxTllhRlJpUjJoWVZXMHhVbVF4Y0VWU2JYUlRUVlp3V2xsclpEUldSa3BWVm14c1YxSnRVWGRYVm1SWFZqSktTVkpzVm1sWFJrcFpWbTB4TkdReFpFZGhNMlJZWVhwc1lWWnRlSGRsYkd0M1YydE9XR0pXV25sV01qVkxXVlpLV0ZWc1FsWmhhMXBVV1hwR2QxSnJOVmhpUm1ST1lsZGtOVlp0TUhka01sRjVWbXRhVDFaWFVuQlZiVEZ2VmpGWmQxcEdUbFZOVmxZelYydGpOV0ZzU25OWGFrSmhWbGRvY2xZd1drdGpNa3BGVkd4b2FFMXJNSGhXYWtKaFdWZE5lVlJyVmxKaVZWcFVWbXBHUzFOV1duRlJiWFJVVFZVMVNWWlhkRmRXVjBwSVZXczVXbFl6VWxoVVZFWmhaRVV4V1dOSGVGTk5SRlYzVm10a01GbFhSa2RUYmxaU1lYcHNWMWxYZEVkTk1YQldWMjFHYWxacldqQmFSVnBQWVZaYWMyTkZiRmRoTWsxNFZYcEtSMUl4VG5WVmJXaFRZbGRvYUZkWGRHRmtNVkpIVjI1T1dHSlZXbGxWYWtFeFVqRmtjbGRzWkZWaVZYQkhXVEJhYzFZeVJYbFVXR2hYVmtWd1NGVnFSazlrVms1eVQxWmtWMUl6YUZoV2JUQjRUa1pzVmsxSWFGaGliRXB6VlcwMVEyTXhWblJPVlU1VFlrWmFXVnBWYUd0V01ERkZVbXhrVjAxV1NraFdha3BMVTBaU1dXRkdaRk5TVm5BMlZtMXdSMVV5VG5OYVNFcFFWbTFTVDFsc1pHOVhWbGw0VjJ4T1UwMVhlRmhXVjNScldWWktkRlZzYkZwaVJscG9XVEo0VjJNeFZuSmFSbWhUWWtoQ1NsZHNWbXBPVmxweVRWaEthbEp0YUZkVVZ6VkRWMFphY1ZOclpHcGlWWEJHVmtkNFYyRldTWGhUYTJ4WFZucEdObHBWV2xwbFJuQkpWVzF3VTJKRmNGVldSbEpMWWpGa1IxZFlhR0ZTUlVwaFZtcEdSMDVXVm5Sa1IzUllVakJ3ZVZSc1duTlhiVXBIVjIxb1drMVdjRlJXTUdSUFRteEtjMVZ0YkZOTk1VWTJWbTF3UzA1SFJYaFhXR1JPVm14d2NWVnRNVzlaVmxKV1YyNWtXRkpzY0hoVk1uUXdWMFphY2xkdWJHRldWbkJvV1ZWa1JtVkhUa1pOVm1oWVUwVktUVlpyVWtkVE1rMTVWR3RhYUZKck5YQlZiRkpYVjFaYVdFMVVVbXROUkVaNlZqSTFTMWRIU2xaWGJVWlhZV3RGZUZSVldtRmtSMVpJWkVab1UySldTa3BYVmxaaFl6RmtkRkpZYkZaaVJrcGhXVmQwWVZaR1duRlNiVVpyVm14S2VWUXhXazloVmxweVlucEdWMDFXY0ZoV2JYTXhWakZ3UmxwR1VsaFNNVXBaVjFaa05GTXhiRmRWYkZwWVltMVNjMWxyV25OT1ZuQldWMjVrYVZJd2NFaFZNbmgzVjJ4YVYyTklTbGRTTTJoTVdrWmFSMk15U2tkaFJtaFVVbFZ3U2xZeFdsTlRNVlY0VjFoc1ZXRXhjRmxaV0hCelYwWmFjbGR0UmxoV2JWSlpXa1ZrZDFReFdsVlJhbEpYVFZkb2VsbHJXa3RrUmxaMFQxWldWMVpyY0VsV1ZFWmhWakpTUms1V1dtdFNiRnB3VlcwMVFtUXhaSE5XYlVaVlRWZFNlbFl5ZEdGaFYxWnlVMjFHVjJKR2NETldNRnB6VG14S2RHUkhkRmRpYTBwS1YxUkNhMk14VlhsVGJrcFVZVE5TV0ZSWE5XOVhSbHAwWTNwR1YwMVdjRnBaYTFwVFlVVXhXVkZzUmxkaGEwcHlWR3RrUjFJeFduVlViR2hwWWxaS2VGZFhkR3RPUm1SSFYxaHNhMU5IVW05VVZWSkhVbXhhZEdSSFJsZGlSbXcyV1ZWb1MxWXhXa1pTYWs1aFZsWndVRnBGVlRWV01YQklZa1pPVGxKR1JqTldiVEI0WkRGSmVGUnVVbGRoTW1oV1dWUkdkMkZHVm5GVGFsSlhVbXhLVjFZeU5XdFdNVnB6WTBSQ1lWSlhVa2hXTW5oaFpFWldjMkZHYUdoTldFSXlWMVpTUjFNd05YUlRhMlJWWWtaYVdGUlVTbTlUVmxwSVpFZEdXR0pXV2xsV2JYUnZWVVpaZVdGRk9WZGlSMUY2V2xkNFlXTldUbFZTYkZKT1ZtNUNXVlpxU1RGVk1WcDBVMnRrVkdKSFVsWldiRnAzVFRGc1ZsZHNjR3ROV0VKSVYydGFVMVV3TVZaalJXeFlWbXhhYUZaRVJsTmpNVkp5VjJ4T2FHRjZWbGxYVjNodllqSk9WMk5GVmxKV1JWcFlWRlprVTAxV1dsaGxSazVvVm10d2Vsa3dXbGRYUmxsNlZXMW9WbVZyV25KVmFrWlhZekZrYzJGSGJHbFdhM0J2Vm0wd2QwMVdSWGhhUldSWVltczFWMWxVU2xOWFJsSllaRVp3VG1KSGVIbFdNakExVjBkS1IyTkdhRnBOUm5CRVZqSjRZVll4V25GVWJVWlRVbFp3VVZadGVHRlVNazE0WTBWb2FWSnJOVzlVVkVKTFZERmFjVk5xUWxaTlZXdzBWa2MxVTFZeVJYbFZiV2hXWWxSRk1GbHFSbGRrUlRGWVQxWm9WMkpHV1hwV2JURXdUVWRGZVZOclpHcFNiWGhXVm14a2IyUnNiRmRXV0doWVVqRmFTRmxWV210VWJVWnpWMnhHVjJGclNuSlZla1pQVWpGYWRWUnNTbWxTYmtKM1ZtcENhMkl3TlhOWGEyaHJVakJhV1Zsc1dtRlhWbHBZWkVjNWFFMVZiRFZaVlZVMVZqSktWVlpyVG1GV1ZuQm9WbXBHZDFKV1JuUmlSVFZYVFZWd1MxWnNaRFJpTWtsNVVtNU9WV0V4Y0hGVmFrSmhXVlphY2xadVpGZFNiRnA0VlcwMWExVXhXbkpPV0d4WFRXcEZNRmxXV2s5U2JFNXlZa1prVG1Kc1NubFhXSEJIWVRGSmVGUnNiR2xTTW1oVVdXdG9RMWRXWkZoa1IzUnBUVVJDTkZadE5VZFZNa3BJVlc1S1ZtSllhRE5hVmxwclkyeGtjMXBIYUZkaE1uY3lWMVpXYjFsV1dYaFhhbHBTWVd4S1lWbFhkSGRWUmxaeFUydDBWRlpyTlhwWlZXUnpZVlphY21OR2NGZGlWRUl6V2xWYVZtVkdjRWRhUjNCVFZtNUNXbGRYZUZkWlZscHpZa2hLV0dKck5VOVVWbVEwWlZaYVdHVkZPVmROUkVaWVdXdFNZVmRzV2xoaFJYaFhUVzVvYUZacVNrOVNiVlpIV2tkc1dGSlVSVEJXYlhCSFdWWlZlVlJZYUdwU1YyaHdWVzB4YjFaR1VsaE5Wa3BPWWtad01GcFZXazlWYXpGWVpVWm9XR0V5YUZSV2FrcExVakpPUms5V1pHbFhSMmh2Vm14U1IyTXlUbk5qUldSVllsZDRUMVl3Vmt0WGJHUnlWbTEwVTAxWFVrbFZNblJyWVd4T1NWRnNiRnBXUlZwTVZXdGFjMVl4V2xsaFJtUk9ZVE5DUjFaclpEUldNVmw1VTJ4b2FGSnRlRmxXYlhoaFlVWmFSVkpyY0d4V2JFcDVXVlZhVDJGV1NYaFRibHBYVW14d2FGcEVTa3BsUm1SMVUyeGthVlpXY0ZsV1JtUTBVekZPVjFkdVVtdFNNRnBYVlcxNGMwNXNWbGhqZWxaWFRVUkdTRll5ZERSV2F6RlhZMGRvWVZKV1ZqUldiRnBYWkVkR1JrNVdaR2xYUjA0MFZtMTRhMDVIU1hsVldHaFhZbXhLVkZZd2FFTlZNV3h5V2tjNVdsWnRlSGxYYTJNMVZURktjMVpxVGxkTmFrVjNWbXBCZUZkR1ZuRlNiR1JUVFRKb2VWWnJaRFJoTVVwelZHNUthRkp0YUZoWmExcDNZakZaZUZkdGRGTk5WWEI1VkZaYWMxWnRTbGhoUmxKYVZrVTFSRll4V210WFIxWkhWR3hLVGxKR1drbFdha28wVmpGYVNGSlljRkppYXpWWFdWZDBSbVZHVlhkWGJrNVhZa2hDUmxWWGVHRlViVVY2VVdwV1YxWkZhM2hhUkVaYVpVWmtjVmRzU21oaVJYQlpWbTEwVjFsWFRuTldia1pUWWxoU2NsWnRlR0ZsVmxKelYyczVWazFyY0VwVlYzQkxWakpGZUdOR2FGZFdSVnBMV2xWYWQxSXhjRWRoUjJ4VFRXMW9OVlpzWXpGa01rMTRXa1ZrVm1KR2NGZFpWRXBUWXpGV2RHVklaRTVTYmtKWFZtMXpOVmRHU1hkalJXaGFZVEZLYUZZeWVHRldNV1JWVVd4a2FHRXdXVEJXYlhCTFZERkplVkpyYUZOaVJUVllWRlpXZDFOc1duTmFTR1JUVFd4R05GWkhkRzlWTWtWNVlVYzVWbUZyTlhaWk1GcFhaRVV4VlZSck5WZGlTRUYzVmtaYVUxVXhXbkpOVmxwWFlXeEtZVmxVUm5ka2JGcHpWMjEwVkZKc1ducFZWM2hyVkd4S2MxWnFVbGRpV0dob1dYcEtVMU5HVW5GWGJFNXBWakpvVlZkWGRHRmtNRFZIVjI1S1lWSkZTbFpVVmxwM1ZqRlNWMWR0ZEdoV2EzQkhWR3hhYjFkdFNraGhSazVoVWtWYWFGa3llSGRTYlZKSFZXeE9hVkp1UVRKV01WcFhXVmRGZVZKc1pGaGhNWEJZV1Zkek1WZFdXblJsU0dSWFRWaENWMWRyVlRWaE1VcHpVMjVzVjAxcVJucFdWRXBMVTFaR2MxRnNhRmRsYTFWM1ZsaHdTMVl4V1hoalJXUmhVbTFvY0Zac1duZFdiRnBIVjJ4a2FrMUVWa2hYYTJoTFlVWktWV0pIT1ZaaVdGSXpWRlphVjFkRk5WWlViR1JwVmxoQ1lWWnNaSGRVTVZweVRWWmthbEl5YUZkWlYzUmhWMFpyZVdWSVpGTk5XRUpIVkd4a2IySkhTa2RqUjBaWFlsaG9WRlV5YzNoV01XUlpZVVpvYVZJeWFGWlhWbEpMWWpKSmVGWnVVbXhTV0ZKaFZtMTRkMlZXV25OVmEyUldUVlZ3TUZaWGVHOVdNREZ4VWxoa1YyRnJSalJXYWtwUFVsWkdkRkpzVGxkaWEwcFNWbTEwYTA1R2JGaFVXR2hoVW14YVUxbHJaRk5pTVd4VlVtNWtUbUpIVWxwWk1GWXdWVEF4Vm1KRVVsZFNlbFpZVm0weFMxZFhSa2RWYkhCcFVqSm9NbFpxUm1GaE1XUklWbXRvVUZZeWVFOVdiWFIzVTFaYWNWTnFRbHBXYlZKSlZUSTFTMVF4WkVaWGJHaGFZa2RvVkZSVVJuZFhSMVpJWkVkd2FWSXhTWGRYYTFaaFZqSkdWMU51VW10bGEwcFlWbXRXWVdSc2JIRlNiSEJzVm1zMWVWbFZXbGRoUjBwR1kwWmtWMkpZYUdoYVJFcEhVakZhZFZKc1RtaGxiWGhhVm0xd1ExbFdUa2RYYkdoT1YwVTFWMVJWVWtkV01XdDNWMjVrVjAxcmNFbFdSM0JUVmxkRmVWVnNUbUZXYkhCTVdUSjRkMU5IVGtkVWJHUnBVMFZLVmxadE1YZFJNa1Y1VTFob1dHRXlVbGRaYTJSdlkxWndXR1JIUmxkU2JFcFlWakkxVDFReFduTlRiR2hZVjBoQ1dGWnFTa2RPYkVweVYyeGFWMDB3U2xWV2JURjZaVWRTV0ZKcmJHcFNiVkp2V1ZSR2QySXhXa2hOVkZKVVRWWndXRlZ0TlZOVk1rcEdUbFpTVjAxR1dreFdNbmhhWlVkR1NWcEdVazVXV0VGM1ZtMHdNVlF5Um5OVGJHaG9VbnBzVjFsc2FHOVVSbHB5VjJ4T1YwMVdjREZYYTFwM1ZqSktTVkZxV2xkTlZrcFFXVlJLUzFJeFRuVlViR1JvWWtWd1dWWlhOWGRXTVZaSFYyNUdWR0V6VWxWVmFrSmhVMnhWZVdWSFJtaFdNSEI1VlRKd1lWWXlSbkpUYldoWFZrVmFjbFV3V2xkamJIQklVbXhPVjFJemFGWldNV1F3WWpGR2RGVllhR0ZTYkZwVFdXeFdZVlpzVWxkWGJrNU9UVlpLV0ZadGVHdFdhekZ5Vm1wV1dsWlhVa2hXYkZwaFZqSk9SVlJ0UmxOTk1taG9WMnhhYTFSdFZuUlNhMmhxVW0xU2IxUlVRa3BOVmxsNVpVWmtXbFp0ZUZsVmJYUnZWVEZrU0dGSVJsWk5SMUV3VmpGYVlXTnNXblZhUlRscFVtdHdXVlpxU1hoTlJscEhVMjVLVDFkSGVHRldiR1JUWld4YVZWTnJaRTlpUm5CNldUQmFhMVl3TUhsaFJteFlWMGhDUTFSV1dscGxSbkJKVm14YWFHVnNXbHBXVjNCSFV6RmFWMWRyWkZoaVdGSlFWVzB4VTFkR1duUk9WVGxvVW10c05sWlhlR0ZXVmxwelkwUk9WMDFXY0doV01HUlhVMGRTUjFwRk5WTlNWbkJMVm0xNGFrMVdiRmRYV0d4VVlUSlNjVlV3YUVOaFJsWnpXa1pPVjFKc1ZqUldNalZyVlRBeFdGVnVjRmRTZWtaNlZtdGFTMVpzWkZsalJtUnBWMFpLYjFZeFdtRmpNVmw0Vm14c2FWSnJOVzlVVjNoTFZteGtXRTFZY0U1V2JWSllXV3RhYjJFeFNsbFZiR2hhWVRKUk1GcFdXbHBsVlRGV1drWmthVkpZUVhkWGJGWmhZekZzVjFkc1pGaFhSMUpoVm1wT1QwNUdXWGRYYkdSclZqQmFTRll5ZUd0aVIwVjRZMFZ3VjJKWWFGUlZha1pyWkVaYWMyRkdUbWhOYm1oM1ZsY3dlRlV5VGtkWFdHUllZVE5TY0ZSV1duTk9SbGw1VFZSQ1YxWXdjRmhXTW5odlZqRmFObFpyZUZkaGEzQk1WVzB4VDFOV1JuTmFSMnhUWW10R05sWnRNVFJaVm14WVZXdG9WV0V4Y0doVmJYaExWREZhYzFWc1pGaFdiR3cxV2tWa1IyRkZNVmRqUkVKV1lrZG9jbGxYZUU5U2F6VlhXa1p3YVZKcmNFbFdiWFJoVm0xUmVGcElVbE5pV0ZKVVZtdGFZVmRHWkhKV2JYUnBUVlpzTlZWc2FIZFZiR1JJVld4b1dtRXlVazlhVlZwWFZsWktjMk5IZEU1U1JWcFlWakowYTJReFZYaGFSV2hvVW0xU1dWWnFUbTlrYkd4eFUydGtVMDFyTlVkV01qRkhWVEpLVjFOc1dsZFdNMEpJVlhwR1QxSXhaSE5oUjNCc1lURndXVlpHV21Ga01VNUhWMWhzYTFOSFVsaFVWM1IzVm14V1dHTkZPVmRXYkhCNldUQmtSMWxXV2xkalIyaGhVbXh3V0ZsNlJsZGtSMFpHVGxkc1UxZEZSWGRXYlRFMFlXc3hXRlZZYkZWWFIyaHdWVzB4VTFkV2JIUmtTR1JZVW0xNGVsWnRNVWRXVlRGWFUyeG9WMDFxVm5KV2ExcExZekpLUlZac1ZsZGlSbkI1Vm0xd1IxTXlUblJVYTJSWVlrWndjRll3Wkc5aU1WcDBZMFZrV0dKV1dqQlZiWFJYVmxkS1NGVnRPVnBXUlVwaFZGVmFZVmRIVmtoU2JIQlhUVVJXV1ZZeWRHOVVNa1pIVTI1U1ZtSnJTbGRaYTJSdlVrWmFXR1ZHY0d4V01VcElWa2Q0VTFSc1dsaGtla0pYVmtWYWRsbHFSbUZYUms1eVlVZDRWRkpWY0ZoWFZtUjZUVmRTYzFkdVNsaGlWVnB4V1d0b1ExSnNXbGhsUnpsWFRXdHdXRlV5ZUhkWFIwcEhWMjVHVldKSFVraFdiWE40VmpKR1NHVkdUbWxXTW1oYVZtMHhkMVF5U1hsU2EyUllWMGRTYUZWc2FGTlhSbXh5V2taT1RsWnNXakJhVldRd1lVWmFkRlZyWkZWV2JFcFVWakJrUzFJeFpIUmhSbVJvWVRGd2VWWlVRbUZaVjA1MFUydG9VMkpGTlhCV2JYUjNWVlpaZUZkc1RsVk5WVlkwVjJ0YWExZEhTa2RYYkZaYVZqTlNURmt5ZUZOV01XUjFWR3M1VTJKSGR6RlhWRUpyVWpGYWRGTnJhRlpoTW5oaFZteGFkMlJzV25STlZWcHNVbTFTZUZaSGVHRlViRXAxVVdwYVYxSjZSVEJWZWtwUFkyczVWMkZIZEZOaVZrcDNWbGN3ZDA1Vk1IaFhXR2hZWWtkU1lWWnRlRWRPVmxaMFpVZDBXRkp0VWtsYVZXTTFWbTFLZFZGdWNGZE5SbkI2V1hwR1YyTnNaSFJrUlRWWFltdEpNRlpzWTNkTlZsRjRXa1ZrVkdKcmNIRlZNR1EwVjFac1ZWTnNUazVOVm5CV1ZUSjBNRll3TVZaT1dIQmFUVVp3ZGxacVNsZGpiRTVWVVd4a2FWSnJjRWxYVmxKSFUyMVdWMVJ1U21sU2JFcHdWbXhhZDFaV1pGZGhTR1JYVFZaYVNGWXlOVk5VYkZwSFUyNUtWVlpzVlhoV01GcGhWMGRXU0dSSGFGTmhNbmN5Vm14a05HSXhXbGRYYkdSVVlUSm9hRlp0ZUhkaFJuQkdXa1U1VkZKcmNIcFhhMlJ6VlRKS1dWa3piRmRpUm5CeFdsVmtTbVZHWkZsYVJUVlhWakZLZUZaWGNFdGlNVmw0WWtoT2FGSjZiRmRWYlRWRFUwWlplV042Vm1oaGVrWllXVEJTUTFkc1dsZFdXR2hYVFVad1RGWnRNVTlTTWs1SFdrZG9hRTFxYUROV2FrWmhXVmROZUZkWWFGZGlSM2h3VlcxNFlWZFdWbkZUYlRsc1VteHdXVnBWWkRCV2F6RlhZa1JTV21FeWFGQlhWbHBMVWpGT2MySkdXbWxYUjJkNlZrWldZVlV5VFhoWGJrcFFWbTFvY0ZWdE5VTk9iR1JWVVd4T1VrMVdjRmhXTWpWUFZrZEZlRk5zYUZwV00xSklWR3RhWVdSSFRYcGhSbVJYWWtoQ05sWnFTWGhqTVdSSFUyNUthbEpHV2xoWlYzUmhZVVprVjFkck5XeFdiRnA1VjJ0YWEyRlhTa1pqU0ZwWFZucEZNRnBFU2s5U01WcDFVbXhPYUUweFNsbFdiVEUwWkRKV1IxWnNhRTVXVjFKWVdWaHdSMWRHYkhKVmJFNVhUVVJHTVZsVldtOVdNVnBHWTBWNFZrMUhVa2hWTVZwSFl6RmtkR0ZIYUd4aVJtdzFWbTEwYTA1R2JGZGFTRkpYWWtkb1YxbFVTbTlqVmxaelZXNU9XRkp0ZUhsWlZWWlBWREZhYzJORmFGZE5ha0V4Vm10VmVHTnNaSFZqUmxwT1lXeGFWVmRYZEdGVGJWRjRXa2hPYUZKdVFtOVVWbWhDWld4YVIxVnJaRlpOVm5CWVZUSTFUMkZzU1hwVmF6bFhZV3RhVEZSdGVHdFdWa1owWkVVNVUwMUdjRmxXVkVreFZESkdWazFJYkdoU2JXaFlXVlJHWVUxc1VsWlhiazVYVm10d2Vsa3daRFJXTWtwSlVWaG9WMVpGYnpCWmFrcEhWakZPZFZOdGNGTmlhMHBhVm0xd1QxVXlSa2RhUm1SaFVsUnNjVlJXWkZObFZscDBaVVU1YUZKVVFqUlZNalZ2VmpGS2MyTklTbGRXUlVZMFZtcEdhMk50UmtobFJrNXBWbXR3TWxadE1IaE9SMDEzVGxaa2FWSnNjRzlWTUdSVFYxWldkR1ZJVGs5aVIzaFhXVlZrUjFkSFNsWlhibXhYVFdwR2RsWXlNVmRqYkdSMVUyMUdVMkpJUWxGWFdIQkxVakZPU0ZOclpHRlNiVkp3V1ZSQ2QwMXNXblJOU0dSc1VqRkdORlV4YUc5V1JtUklWV3M1VmsxSFVuWldha1p6WTJ4d1IxUnNhRmRpV0dnMlYxWldZVlF4WkVkVGJrNVVZa2Q0YUZWc1pHOWpiR3h5V2tWMFUwMVdjSGhXYlhoWFlWWktjMVpZYUZkaVdFSk1WWHBHWVdSR1VuSlhiV2hUWWtoQ1VGZFdaRFJYYlZaelYyNUdWRmRIYUZSVVYzTXhaV3hrY21GR1RtaFNhMnd6VmpKNFUxWXlSbkpYYTNoWFRWWndhRlpzV2t0a1JrcDBaRVUxVjFZelkzaFdiR040VFVkRmVGZHNhRlJpUjJoelZXMHhORll4YkhOaFJrNWFWbXhLV1ZwVlpFZGhNVXBWVW14d1dHRXhjRlJaVldSWFkyeGtjMk5HWkZkTk1tZ3lWMWR3UjJFeFNYaGpSVnBvVW14d2IxcFhNVFJYVmxwSFZtMUdXbFpVUWpSWlZFNXZWMGRLU0ZWdVNsWmhhMXBvVlRKNGEyTnNaSFJrUmxacFVtNUJlRlpXV205aE1WbDRVMjVPYWxORldsWlphMlJUVWpGd1YxZHJPV3BpU0VKSldUQmFUMVV4V2xsUmJscFhZbFJGTUZsVVJsWmxSbEp5V2tab2FWSnNjRlpYVmxKUFZURmFWMVp1VW14U01GcFBWbTB4TUUweFdYbE5WV1JYVFVSR1JsVlhjRmRYYkZwWVlVaHdWMDFHY0doWmVrWnJaRlpPYzFkdGJGZFNWbkJhVmpGb2QxSXhUWGxWYkdSVlltdHdVRlp0TVZOalJscDBaRWhrV0dKR2NIbFdNbmhQVldzeFZrMVVVbGRTTTJoeVYxWmFTMlJHVm5OYVJuQlhVbFJXVlZadE1UUmpNazE0V2toU1UySkhhRlJaYTFwYVRWWmFTR1ZHWkU1U01GcElWVEkxUzJGV1NrZFhiVVpYWWtad00xWnJXbUZqTVdSMFVteE9hVlpVVmt0V2FrbDRVakZWZUZOc1pHcFNlbXhaVm10V1lXRkdWbkZUYkU1VVVteGFlVmxWWkhOVk1WcEhWMnhzVjFKc1NreFpha1pyWXpGa2RWVnRjRk5YUlVwUVZtMHhORll3TlZkV2JrNW9VbnBzV0ZWdE1WTlRWbHBZWlVoT1dHSlZjRWhXTWpGdlZqQXhSMk5JY0ZwbGExcFlXVEo0YTJOck5WZFViV3hUVFRKT00xWnRNWGRUYlZaSFUxaG9XRmRIVWs5V01GWjNWMVpzVlZOcVVsZGlSa3BZVmpJMWEyRnRTa2RqU0doV1ZtMW9kbFpVUVhoWFJsWnpWMnhhYVZkSGFIbFhWbHBoVTIxV1IxTnNiR0ZTYldoWlZUQldTMU5XV25GVFdHaFdZbFpHTTFSV1dtdFhSMHBZWVVaU1dtRXlhRVJXTVZwaFYwZFdSMXBIZEU1aE1YQkpWakowYjFReGJGZFRhMXBVWWxWYVdGbHNVa2RXUmxWM1YyNU9WMVpzU2pCVU1WcHZWVEF4UjFkVVJsZGlSMDE0VlhwR1lXUkdUbk5pUmxwb1lYcFdiMVp0Y0U5aU1sWnpWMjVTYkZJelVuRlpXSEJ6VjFac1ZsZHRkR2hTVkVJelZUSXhiMVl5U2tkalNFWmhWbFp3UzFwVldtdFhWbkJHVGxab1UySklRbGxXTVdRd1lUSkplR0pHWkdsU2JXaHlWVEJrVTFaR1VsZGhSVTVYVFZac05WUldVa05oUjBwV1kwVndWbFl6VW5aV01uaGhWMFpXZFdOR2NGZFdNVXBaVjFod1IyRXlUbGRXYms1aFVqSjRWRlJXVmxkTk1WbDRWMnhPVW1GNlJsaFZNV2h6VmtkRmVWVnRhRlppV0dneldUQmFWMlJGTlZaVWJHaHBVakZLV2xaR1ZtOWlNVnB5VFZaa2FWSkdTbGhaYkZKWFZrWnNjbGRyT1ZSU2JGb3hWa2Q0WVdGV1pFaGhSemxYVW14YWFGcEVSbUZrUmtweVlVZDBVMDF0YUZWV2JYUlhXVlpKZUZkc2FFNVdSa3B3VkZaa1UyVldVbGRXYlRsb1VtczFTRmt3V205WGJGbDZWV3BPVjFKV2NHRmFWVnAzVW14d1IxVnNaR2hsYkZreVZtcEtNR0V5U1hsU2ExcE9WbGRTY0ZWclduZFhSbEpZVGxjNWFGSnRlRlpWYlhSM1lrWktjazVXY0ZwV1ZuQlVXVlprUjA1c1duUlBWbVJYVFRKb1ZWWnRjRWRoTVVsNVUydHNWbUpZVWxSV01GcExaVlprV0dSSFJtdE5iRnBJVm0wMVUxUnNXbGhWYlRsV1lrWktTRll3V2xabFYwNUdWR3hrVG1FelFtRlhWbFp2VXpGWmVWTnNWbE5oTTJoaFZGZHdSMVZHVlhkV1ZGWlhUVmRTTUZsVlpHOVVhekZHWWtSV1YySlVRalJVVlZwelYwWlNXV0pHV21oTmJXaFlWMVpTUjJReVRuTldibEpzVTBkU1dGVnRNVFJsYkZsNVpFUkNXRkl3Y0VoWk1GWnZWakpLVlZGVVJscFdiRlkwV1RKNGEyTXlTa2RYYXpWcFlsZG9OVlp0Y0VOaE1VMTVWV3hrVTJKck5XOVZiWGhoVjBad1dHVkhSazVpUjFKNVYydFNVMkZyTVZoVmEyeFhZbGhTYUZsVVJrdGtSMFpIVld4d2FFMVlRWGxYYkZaaFdWWmFWMVJ1UmxaaVIxSlBWbTB4TTAxV1dsVlRha0pvVFd0YWVsVXlkR3RoYkVwMFlVWmtXbFl6VFhoYVIzaHpWbXhrZEZKdGNGZGhlbFkyVm10a05GVXhWWGxUYTJScVVrWmFXVlp0ZUdGamJGSldWMnhhYkZack5YcFhhMXBUWVZaSmVtRkdiRmRXZWtVd1YxWmtSMUl5UlhwaVJUVlhZbFpLV1ZaR1dtdFZNREZYVjJ4b2FtVnJXbGxWYlhNeFVqRlZlV1ZGWkZkTmEzQldWVmR3VTFZeFdrWlNhbEpXWVd0YWFGWXhaRXRUUjFKSFZHMTRhVmRIYUdGV2FrWnJUa1paZVZWWWJGZGlSMUpaVmpCa05GUXhXblZqU0U1WVVteEtXVnBGYUd0V1JrcDBaRVJPVjFZelRURldNR1JMVWpKT1IyRkdjRTVTYTNCUlZtMHdlRk14WkZoU2EyaG9VbTFTVDFacVJrdFRWbHBZWTBWa2EwMVZiRFJaTUZadllWWktjazVZUWxkaE1sRjNWRzE0WVdSSFRrWmFSbkJYWWtkM01GWnFTVEZUTVZKelYyNVNhRkpzU21GWlZFcFRWa1phYzFkdVRtcGlTRUpJVmtjeGMxUnNXbkpqUm1SWFZrVnZNRlpFUm10U01VNTFWVzE0VkZJemFGcFhWbEpIWkRGU1IxZHJhR3hTV0ZKeVZXcEdZVk5zYkZaWGJVWlZZbFZ3ZWxVeGFIZFhSbGw2Vlcxb1dGWnRVbEJhUlZwVFkyMUtTR05HVG1sV01tZ3lWbXRhWVdJeFJYaFhiR1JoVW0xU1dWbHNhRk5XVmxKWFZtNWtUbEpzY0VsYVJXaFBWMFpKZDJORmJGZFdNMmgyVjFaYVdtVnNWbk5hUjBaVFVsWndlVmRVU2pSV01rNXpZMFZvYWxKVVZsaFpiR2hxWkRGYWNWTnFRbWxOVm13MFZqSjBiMVpIUlhsaFJtUmFZbGhTVEZkV1duTmpiR1IxV2taV1UySkhkekJXYWtsNFVqRmtSMU5zVmxOaVJuQllWbTV3UjAweFdraGxSWFJUWWtVMVZsVlhlR3RoUjBWNFkwUktXRmRJUWtoV1Z6RlhVakZ3U1ZSc1pHbFdNMmhWVjJ4amVFNUdXWGhYYmxKT1ZrWktZVlpxUm1GbGJGcFlUbFYwV0ZJd2NFcFZWelZQVmpKR2NsZHJlRlpOVm5BelZXMTRhMlJXY0VkYVJUVm9UVlpyZVZac1dtdE9SMUY0VjFoc1ZHRXlhRmRaVjNNeFYwWldjbFp0UmxwV2JrSlhWakp6TlZkR1dYZE9WV3hhVmxad1VGWkhNVXRYUjBaSVQxWmtUbUp0YUhsV1JsWmhZekZrUjFWdVZsVmlSMmhaVldwS2IySXhXbGhsUms1cVRWWndTRlpYZUd0aFJrcFdUbFpTVlZac2NFeGFWM2hyWTIxR1JrOVhhRk5pU0VJMVYxUkNZV1F4V25OWFdIQlNZVE5vV0ZsWGRIZFVSbHB6VjJ0MFdGWnVRa2hYYTFwclZURmFkVkZzUmxkTmJtaFlWMVphVW1WR2NFZGhSbEpvVFd4S1dWZFhlR3RPUjBsNFZXeFdVbUV6VWxkV2JYaDNUVVpTVm1GSGRHbFNhM0I2Vm0xd1YxWnJNVmhoU0ZwWFlXdHdURmt5ZUd0ak1XUnpZMGRzVTJFelFUSldiWEJEV1Zac1dGVnJhRmRoTW1oVVdXeG9iMVpHYkhKaFJVNVVZa1p3U0ZadGVFOVdNREZZVld0b1ZrMXFWbEJaVjNoUFUxWkdkRkpzVmxkV2JrSnZWMnRrTkZkdFVYaGFTRkpyVW14S1dGbFVSbmRPVm1SWFZtMUdhMDFXYkRWVk1uUnJWMFphUmxOc2JGZGhNVm96VkcxNFUxWXhaSFJrUm1oVFlrVndOVll5ZEd0U01WVjRWMnRrV0dKdFVsbFdhazVUVjBad1JWSnRkR3BOVjFJeFZsY3hORlV5UmpaV2JGcFhVbXh3VjFwVlZURlNNV1JaWWtVNVYxWkhlR2hXYlRGNlRWWk9SMWRZYkd4U2JWSlpXV3hXVjA1V1dsaGxSazVZWVhwR1NGa3daRWRaVmtwR1YyNUtXazFxUmxSVk1HUkxVbXMxVjFwRk5WZFdlbWcxVm0weGQxTXdNVWRXV0doWFYwZDRWRmxVUm5kVU1WbDNWbTVrVmxKc2JETlpWVlpQVjBaYWRHVkdXbFpOYWtFeFZqQmFTMlJHVm5OaFJtUk9ZbXhHTTFkV1VrZFRNazE0V2toV2FWSnNXazlXYlRWRFpWWmtWMWR0UmxwV2EzQjZWakkxUjFkSFNraFZiRkphWVRGd00xbHFSbHBsUm1SMFVtMW9UbFpZUWpWV1JscGhZVEpHVjFOWVpGaGlSa3BoV1ZSR2QwMHhXbFpYYlVaclVsUkdTbGxWVlRGVWJFcEdWMnhzVjJGcmJ6Qlpha1pUWXpGT2NsZHNhR2xTYkhCWFZtMHhOR1F3TUhoV1dHaFlZa1p3YzFacVJtRlRWbEY0V2tjNVZrMXJWalpWVm1oclZqSktTRlZVUWxoV2JIQmhXbFphUzJSV1RuSlBWbVJYWVROQ1dWWnJXbGRaVjFGNVVtdGtXR0pyTlZsWlZFNVRZMnhhZEU1VlRsUlNiVko1Vm14U1IxWXdNVVZTYkdSYVltNUNURlpxU2t0WFZsWjFVbTFHVjFZeFNsUlhiRnBoVXpKTmVHTkZaRlppUjJoVVZGY3hiMVl4V25SalJVNW9UVlpXTkZkcldtdFhSMHB6VTI1T1ZtRnJTbWhaYWtaWFpFZFdTVnBHVG1sU2JGa3hWMnRXYTAxR1pFZFRia3BxVTBkNFlWUlZXbmROTVZsM1drVmFiRlpzV25oV1IzaHJWakZLV1ZGcmFGaGlSbHB5VmtSR1NtVldUbkphUjJoVFlsWktVRlpHV2xka01EVlhWMjVTYTFKck5WTlpiRnBIVGxaYWRHUkhkRmROYTNCNVZHeGtiMVp0U2xWU2JscGFZV3RhVkZacVNrZFNiRkowWlVaa2FWTkZTa3BXYlRCNFRrWlJlRlpZWkU1V2JXaFhXVzAxUTFkR1VsaE9WazVyWWtkNGVWWXlkREJVTWtwV1kwVnNWVTFXY0hKWlZXUkdaREpPUjJKR1pGTk5NVXB2VjFSSmVGVnRWa2RqUld4V1lrVTFjRlZxU205V1ZtUllaRWR3VDFJeFdsaFdNbmhyVjBkS1ZXSklRbFZXYkhBeldsZDRXbVZYVWtoU2JXaHBVbGhDVjFkWGRHdGlNVmw1VTJ0a2FsSkZOV0ZXYkZwM1RURldjVkp0ZEdwTldFSkpXa1ZhVDFSc1NrZFhhM1JYVFc1b1dGbFVTa3BsUmxaMVZHMUdVMVp1UWxaWFYzUnJZakZrUjJKSVRtaFNlbXh4Vm0wMVExWXhXbk5WYTJSWFVtdHdlbFl5ZUhkWFIwVjRWbGhvVjJGcldtRmFWVnBQWXpKR1IyRkdaR3hoTVd0NVZtdGFZVmxYUlhoWFdHeFVZVEo0Vmxsc1pHOVdSbXhaWTBaa1dHSkdjREJVVmxKVFYyeGFWVkpyYUZwTlJscG9XVlZhUzFaWFNrZFhiSEJZVTBWS1NWWnFSbUZrTVVwelZtNUtVRlp0VWs5WlZFNURWakZhZEUxVVVsSk5WbXcxVlcwMVMxVXlSbk5UYkdoYVZqTlNNMVpGV2xkak1XUjBaRWR3VGxkRlNrbFdhMk40WXpGVmVGcEZXbFJoTTFKWVdXeFNRMDVHY0VWU2EyUnJVbXh3ZVZsVldtRmhWa2w1WVVaV1dGWnNTa3haYWtaaFVqSktTVlJzWkdsV1ZuQmFWbGN4TkZNeFduTldXR3hPVWtaYVdWVnRlSGROUmxwWVRsaE9WMDFyY0ZaVmJHaHJWakZhUmxKcVVsZGlWRVpNVld4YVYyTXlSa2hoUlRWcFZqSm9UMVp0TVRCVk1VbDRZa1pvVldKcmNGQldiVEUwVlRGc2NtRkZUbGhTYkZwNlZtMDFZV0pHV25OalJXaFhUV3BHU0ZZeWVGcGtNRFZYWVVaYVRtRnNXbFZXYkZaaFYyMVdjMVp1U2xCV2JWSndWV3BHUjA1c1drZFhiVVphVm0xU1NWWnRkRzlWUmxsNlVXczVWMkpVVmtOYVJFWmhWMGRXU0U5WGNFNVdia0YzVmxSS01HRXhaRWhUYkZwWVlsVmFZVmxVU2xOa2JGcEZVbTVrVjJKSFVqRldSM2hyWVZaSmVGTnFXbGROYmxKeVdrUkdVMk14WkhWVWJYQlRVbTVDV1ZaR1l6RlZNazV6WWtSYVUySkZOWEZVVm1oRFVqRlplV1ZHVG1oV2F6VkhWVEo0ZDFkR1dYcFZiV2hZVm0xU1NGVnFTazlTYkZwelZHMXNVMVpHV2pWV2JHTjRaV3N4V0Zac1pHRlRSWEJvVlRCVk1WWXhVbGRXYm1Sc1ZtMTBNMVl5TlU5V01ERnlZMFp3VmxZemFFUldha1poVW14a2MyRkdXbWhoTVhCNVYydGFZVk15VFhoVWJrNW9VbXMxVDFsc1pHNU5SbHB4VW0xMFQxSnNiRFZXVm1odlZrZEtjazVXYkZwaE1sSjJXWHBHVjJOV1VuTlViV3hPVm01QmQxZHJWbTlVTVZGNFYyNVNiRkp0VWxoV2JuQkhVMFphY1ZGWWFHcGlWVFZJV1RCYWExWXlWbk5YYXpGWFlsUkNORlY2Um1GV01VNTFWRzFvVTJKV1NsQldWekF4VVRGU1YxcEdWbFJoYkVweVZGWlZNVk5HVlhsT1ZUbFhWakJ3V1ZwVll6VldWbHBZWVVWU1dsWldjR2hhUldSWFVqRlNjMU5yTlZkaVdHTjNWbTEwWVdJeVJYaFZXR2hoVWxad1VGWnRNVFJaVm14ellVYzVWVkpzY0VaVmJURkhZVzFLU0ZWdWJHRlNWbkF6Vm1wS1MxTldSbkZWYkdSWFpXdFdNMVpHVm1GaE1VbDRXa2hXVldKWVFsUldhazV2WWpGYVdHVkhkRlpOVlRWSVZqRm9jMkpHU1hkWGJrWmFZa1phTTFWdGVGcGxWMVpJWkVaa1RtSkdjRFpXYWtvd1ZqRlplVk5zVmxKaGJFcFhXbGQwWVdOc1dYZFhhM1JxWWxWYVNGWkhNWE5WTWtwSlVXeHdWMDFYVVhkWmFrWkdaVlphYzFwSFJsTmlXR2g0VmxkNGExVXhiRmRYYmtaVFlUTlNWVlZ0ZUZkT1ZsSnpWMnM1YUZKVVJsZFpNRnBoVmpKS1ZWRlVSbGRpUm5Cb1ZXMTRUMk50VmtkWGF6VnBZbGRvZGxZeGFIZFNNVmw1Vkc1U1ZXRXhjRkJXYlRGVFkwWldjMWR1U210TlZuQjRWVEp3UTFZd01YSmlSRkpYVFc1U2RsWnJaRXRqYXpWWFZteHdhVmRGTVRSV2JYQkhZekZrU0ZWcldtdFNNbWhVV1d0b1FtUXhaSE5XYlhSVFRXdGFlVlJXV25OVmJVVjVZVVpvVm1Gck5YWlpWVnBoVTBkV1NGSnRjR2xXVkZaSlYxWldZV0V5UmtoU1dHeHJaV3RLV0ZacVRrTlRSbGw1VFZaa1UwMVlRa3BXYlhoVFlVZFdkR1ZHY0ZkV00wSlFXV3BHYTJNeGNFZGFSbHBvVFd4S1dWZFdhSGRTTVdSSFlraEtXR0pZVWxsVmFrSlhUbXhhV0dWSVRsZE5hM0JhVmxjeGIxbFdXWHBoU0VwYVRXNW9jbHBGWkZOU01YQkdUbGRvVGsxRmNHRldiWGhyVGtkSmVWSllhR0ZTVjFKWldXMXpNVlpXYkZWVGJUbFlVbXhLV1Zrd1ZtdFhSa3B6VjI1b1ZtSllhRkJaVkVaaFl6Rk9jVkZzV21sWFIyaFJWbXRrZW1WR1NuUlVhMlJZWWtkU2NGVnFSa1prTVdSWVkwVmtVMkpXV2toWk1GWnpWbGRLU0dGSVFscFdSVm96Vm10YWExZEhWa2RVYlhCT1ZteFpNRlpzWkRSaE1WbDRWMnRhV0dKR1dsZFpiR2h2Wld4U2MxZHNUbXBOVjFKNVZERmFhMVl3TVVsUmEyeFlWa1ZLVkZWVVJscGxSbVJaWTBkb1ZGSnVRbGxYVjNSaFpESkdSMkpFV2xOaVZWcFpWbXBDWVZOV1ZuUmxSM1JWWVhwR01GZHVjRXRXTURGWFUydDRWV0V5VWxOYVZWcFRZekZ3UjFkdGJHaGxiRnBoVmpGYWIyUXhXWGxUV0doV1lrWmFVMWxVVGxOV2JGWjBaVWhrYkdKR2JEVlVWbWhyVmxkS1IySkVUbGRpV0VKVVZtcEJlRmRIUmtsalJtUm9UV3hLVFZaVVFtdFdNVWw0WTBWa2FsSXllRmxWYlhSelRteGFkRTFJYUU5U01ERTBWako0YTFaSFNuTlhiV2hXWVdzMVJGa3dXbGRrUjFaSldrVTVVMkpJUWxwV1JsWlRVakpHUmsxV1pGZGhhelZXVm0weGIxUkdXWGRhUlZwc1ZqRmFTVmxWV210aFZrcDFVVmh3VjJKR1dtaFpla3BQWXpKT1JsZHRkRk5pVjJoWlZrWldZV1F4U1hoWGJrcGhVa1pLYjFSWGRHRlNNVkpYVjI1T1ZtSlZjRlpaYTFwdlZsWmFjMk5FVGxwV1ZuQm9WVEJWZUZZeGNFZFVhelZYWWtjNU5GWnNVa3BsUmtsNFZsaHNWR0pIYUc5VmJUVkRWMFphY1ZSclRsWlNiWGg0VlcxNGExWXdNVmhWYWtaWFZucEZNRlpVU2xka1IxWkhZVVprVTJKSVFubFdiRkpIWVRGSmVGcElWbFpoZW14WVZtcEdTMWRHWkZobFJtUnJUVVJHU0ZZeWVHOWlSa28yWWtab1YySllhRE5hVjNoeVpESkdTVnBHWkZkTlNFSkpWMVJDWVZVeFpIUldia3BZWWxkb2FGVnNaRk5XUmxaeFVtNWtVMkY2VmxoWGEyUnpZVVV4U0dSRVZsZGlXRUpJV1ZSQmVGSXhXbGxoUjJ4VFlsWktXbFpxUW10aU1XUlhZa1pvYkZOSFVsaFZiVEUwVFVad1ZtRkhkRmhTYTNBd1dsVm9kMVl4V1hwVmJrcFhZVEZ3VEZwRlpGTlNWbHAwVW14a1YwMVZXWHBXTVZwVFVqRk9kRlZZYUdGVFJYQnZWVzB4VTFReGJIUmpNMmhQVW14d2VsWlhkRXRpUmtwelkwUkNWMUl6VW5KWlYzaExaRVpXZFZGc1dtaGhNWEJNVjJ4a05GbFdaRWhVYTFwaFVtMVNjRlp0ZUhkWFZscHpXa1JTYWsxcldraFZNalZUWVVaT1JsTnRSbHBXUlZwb1ZGUkdkMUpXU25SU2JHaFRWa1ZhWVZkVVFsWk5WbGwzVFZWV1YyRXllRmxXYWs1VFlVWmFjVkpzWkd0U2F6VjVXV3RhUzJGSFZuUmxSbWhZVmpOb2RsbHFRWGRsUmxaelYyeG9hV0pXU2xsWFYzUnZVVEZKZUZwSVNsaGlWR3h2Vm0xMGQwMUdjRVZVYm1SWVVteHNObFpYZUZOV01rWnlWMjFvWVZKV2NGQlpNakZIVTBkR1IxVnNUbWxoTUhCaFZtMTBZVll4YkZoVldHeFZZbXMxV0ZZd1pGTmhSbFp6V2taT1YxSnNTbGhXTWpWcllrZEtTR1JFVGxoaE1taFFWakJhUzJOdFRrZFhiRnBwVW10d1JWWnRjRUpsUmxsNFZHNUthRkp0YUZoWmEyaERZVVprYzFkdFJsZE5helV3VlcxMGExbFdTWGxoUlRsWFRVWmFURlJzV21Gak1XdDZXa2Q0VTJKR1dUQldiRnB2WWpGa1NGTnVUbFJpUlVwWVdXdGFWbVZHV2xaWGJVWnJVakZhU2xkclZURlZNa3BHWTBab1dGWnNXbkZVYkZwaFkyc3hWbFpzVG1saVdHaFpWa1pqTVZVeVVuTlhibEpxVFRKb2NWWnRlSGRsYkZwWVpVaGtWMDFWY0ZoWk1GVjRWakZaZWxGcmFGcFdSWEJVVldwR1QyUldWbk5VYld4VFRWVndVVlpyV2xkVk1VcHlUVlZrV0ZkSGVISlZhazVUVlVaV2RFMVVVbGhXYkhCSldsVmtNRlpyTVhKalJXeGhWbGROTVZadE1VdFdWa3AxVjJ4a2FFMVlRalpYVkVvMFlUSlNWMXBJVW14U2F6VndWbTEwZDFsV1dYbGtSbVJvVFZWc05GWXhhR3RVYkdSR1kwWnNXbUV5VW5aV2FrWlRWMGRPUjFwR2FGTmlTRUphVmtaYVYwMUhSWGhUV0doWVlUSm9ZVlpzV25kTk1XeFdWbGhvV0ZacldubFVWbHByWVVVeFYyTkhPVmRpV0VKTVZsUkdTMk5yTVZkYVIwWlRUVVp3VlZaR1VrTlRNVlpIVjI1U2JGSjZiRk5aYkZwaFUwWlplVTVWZEZoaGVrSTFXVlZvUzFaV1duTmpSbWhWWWtad1YxcFdaRmRUUjFKSFdrWk9UbE5GU2tsV2JGSkxUa2RKZUZwSVVsUmhNbWh2Vld4YVMxWXhVbFpYYm1SWVVtMTBORll5ZEd0WFJscDFVV3RzWVZaV2NGQlpWbVJHWkRKT1JtTkdaR2hoTWprelZqRmFZV014WkVkVGJrcFlZWHBXVlZWcVNtOVdiR1JZWkVkR2EwMVhVbGhXTWpWSFZsZEtWV0pIT1ZaaVZFWlVWakJhV21WVk1WVlJiRnBPVWtWYVdsWnNaSGRTTVZsNFYxaHdWVlpGV2xoWlYzUjNWRVphY1ZKck9XcE5hM0JJVjJ0a2MxZEdTbFpqUlZwWFRXNVNWRlZxUmxKbFJtUlpZa1pTYUUxc1NscFhWM1JyWWpKT1IySkdiR3BTYlZKWlZtMHhVMWRXY0ZaWGJYUllZa1pzTkZZeWVHOVdNREZZWVVod1dsWkZXa3hWYWtaUFl6SkdSMVpzWkZkaE0wSktWbXRhWVZsWFRYaFhibEpUWVRGd2NsVnRNVk5VTVZaeVZtMUdWR0pHY0hwWGExSlRZVlV4VjJOSWJGVldiRnB5Vm1wR1lWSnNaSE5oUm5CWFRURktiMWRVU2pSamJWWllWR3BhVTJKSFVrOVdNRlpMVTJ4a1dHUkhkR2xOVmtwNlZrZDBZVlpIU2xWaVJtaGFZa1pLUkZSVVJuZFNWazV6VTIxNFYySkdjR0ZXTW5SV1RWWlplVk5zWkZSaVJuQllXVmQwUzJOc2JIRlNiWFJUVFd0d1NsWlhNVFJWTVdSSFUyeHNWMkpVUWpSVWEyUlhWakZrV1dKRk9WZE5NVXBhVmxjeE5HUXdNVWRqUmxwb1UwVTFXRlJWVWtkbFJsWjBaRWM1VjAxcldubFZiWEJUVmpBeFNGVnNhRlpOVjFKUVZXcEdkMUl4Y0VaT1ZUVlhWMFZKZVZadE1IaE5SMFYzVGxWa1ZWZEhlRmRaYTJSVFZrWnNkR042Um1sTlZsb3dWRlphVDFaVk1WaGxSRUpWVm0xTmVGbHJaRXRUUmxaellrZEdVMVl4U2tsV2FrbzBXVmROZVZSclpHaFNiVkpQV1ZkNFlWVldaRmRYYlVaVVlsWkdORmRyYUU5V2JVcElWVzA1V2xaRldqTldSbHBoVWpGd1JWVnNjRmROUkVVd1ZtMHdNVk15UlhoVGJrNVVZWHBzV0ZscldrdFhSbGw0VjIxR1dGSlVSbFpXVnpGM1ZHeFplbUZHYkZkV1JXdDRWbFJHWVdSR1RuVlRiRkpwVWpGS2FGWnRjRTlWTWtaSFZsaGtXR0pGTlZoV2JYUjNUVVp3UmxkdE9WZE5SRVpHVm0xMGIxWXdNWFZWYmtwYVlXdGFWRnBGV2t0alZtUnpWR3hrVTFaWVFscFdhMXBxVFZaVmVWVnVUbGhoTVZwVldWUktVMVpHVWxkV1ZFWk9WbXh3U1ZwVll6VmhSbHB5WWtSV1dsWldjSFpXTUZwYVpXeFdkR0ZIUmxOU1ZWbDZWMnhXWVdFeFpGaFNhMlJvVWpKNFdWVnRkSGRYYkZweVYyMUdhVTFWVmpSVk1qVlBWakpLU0dGRk9WZGhNVnBNVm0xNGMyTnNaSFZhUjNoWFlsaFJlbFp0TURGVU1WbDNUVmhLV0dKdGVHRldhMVV4Wkd4YWNWSnJkRk5pUjFJeFZUSjRZVlJzU25WUmF6RlhZV3RhY2xaRVJrcGxSbkJKVlcxc1UyRjZWbEJYVjNocllqRnNWMWR1UmxOaVdGSlFWV3BDYzA1R1duTmhTRTVXVFd0V05WWlhOVWRXYlVwVlVtNWFXbVZyV2xkYVJFWmhaRlp3U0dOSGJGTmhNMEphVmpGYVYxWXhVWGhXV0d4VVlUSlNjVlZ0TVRSV2JGcDBUVlUxVGxac2NEQlplazV2VmpBeGNrNVZaRmhoTVhCb1ZrZDRXbVZXYjNwalJtUnBWMFZLU1ZZeFdtRlRNbEpIVkc1R1dHSkZjSEJWYlRWRFpXeGtWMVZyWkd0TmExcElWMnRvUzFadFJYZGpTRTVXWWxob2VsUnNXbGRrUjFKSVQxZG9VMkV6UWpWV1IzaGhWVEZaZVZKWWFHcFNNbWhZVkZaYWQxbFdjRmRhUm1SVVVqRktSMVJzV2s5aFZtUklZVVp3VjJKVVJUQlpha3BLWlZaS2RWUnNVbWxoZWxaNFZsY3dlRTVHYkZkWFdHUm9VbFUxYzFsclpEQk9WbkJXV2tWa2FFMVZiRFJXTW5SelZtMUtWVkpVUWxwV2JIQk1Xa1phUjJOdFRrZGFSazVwVTBWS05GWnJaRFJaVm14WFdrVmtWV0pyTlZsWmJHaERWa1phY1ZKcmRHaFNiSEJJVm0weFIyRXdNVmhWYTJoWFRXcFdTRlpYZUd0VFIwWkhZa1phYVZkSGFHOVdha28wWVRKT2MxcElWbUZTYlZKUFZteG9RMWRXWkZWUmJVWnBUVmRTU1ZVeWRHdFhSMHBZWVVab1dsWXpVbWhaTW5oYVpERmtjbVJIY0dsVFJVcEpWMVpXYTJNeFdYZE5TR3hvVW14d1dGUldaRTlPUmxKV1YyczFiRkp1UWtwV1IzaHZWMFpKZVdGSGFGZFNiRXBNVmxSS1RtVkdXblZWYlhoVFlsWktVVlpYTUhoVk1sWlhWMjVTVGxaRlNtOVZiWGgzWlZaU2MxWnRkRmhoZWtaSVdUQm9kMVl3TVhGU2EzaFhUVlp3VkZZeFpFZFNNWEJIV2taa2FXRXdjR0ZXYWtvd1ZqRmFkRlpyWkZoWFIyaFhXVzE0UzJNeFZuUk5WazVxVW14V00xWnRkREJYYkZwellrUldZVkpXY0hKV2FrcEhUbXhhYzJKR1dtbFhSa3A1Vm0xMGExTXlUbkpPVm14VFlrWndjRll3Wkc1bGJGcDBZMFZrYWsxck1UVlZiWFJ2VlVaWmVsRnVRbFppVkZaRVZHdGFZVlpXVG5GUmF6VlRZbFpLU1ZacVNURlRNV1JJVTI1V1VtSkhVbGhaVjNNeFpHeHJlV1ZJVGxkTlYxSjVXVEJrTkZVeVJqWldhbFpYVW14d2FGbFVSbHBrTURGSldrWlNhRTF1YUZwV2JURTBVekZTUjFkc1ZsTmlTRUp6VlcxNFlVMVdXblJsUm1Sb1ZteHdXRmt3V2xkV01rcFpWVzFvV0Zac2NHaFdha1pyWTJ4d1IyRkhiRk5OVlhBMVZtdGFZVmxXVFhsV2JrNVlWMGRvYjFWdWNITlhSbXh6Vm14a1QySkdXbGxVYkZVMVZqSktWbU5HY0ZwV1ZscDJWbXhrUm1WSFRraGhSbHBPVWpGS1ZWWlVRbXRWTVVsNFkwVmtWV0Y2VmxWVmJGWnlaVVphZEdSSGRFOVNiWGhaVlRGb2IxbFdUa2RUYkZKWFRVZFJNRlpxUm5OamJHUnlaRVpvVTJKWWFGZFdWekF4WVRGa2MxZHVWbEpoTVhCWFdXeFNSMU5HYkZoTlZYUlhUVlUxZVZsVldtOWhSVEZ6VTJwYVYySkdTa3hWZWtwUFl6Rk9kVkpzVm1sU01VcFFWMWN3ZUdJeFpGZFhXR2hZWWxoU1ZGbHNXbUZUUm10M1ZtNU9WMVl3Y0VsWlZXaERWMjFGZUZkcVRtRldNMmhvVmpCVmVGTlhSa1pQVms1cFZtdHdTbFp0Y0VwTlZrbDRWMnhvVkdFeGNGQldNRlozV1Zac1ZWSnVaRTVOV0VKWFZqSjRZV0pHV1hoVGEyeFdZbFJHZWxaVVNrdFRSMUkyVVd4a2FHRXlPVE5YVjNCSFYyMVJkMDFXYkZkaVYyaFVWV3hTVjFkV1drZFdiVVpyVFZaYVNGWnROVk5pUmtwVllraEdWMkpVUmxSYVYzaHJZMnh3U1ZSc2FGTmhNMEkxVjFSQ2IxbFdXWGROVm1ob1VrVTFWMXBYZEdGVk1YQlhWMnhPV0ZZd2NFaFdiVEZ2Vkd4a1JsTnNjRmROVjFGM1YxWmFjMWRHVGxsaFIzQlRZbGRvZWxaWGNFTlpWbVJYVjI1U1RsWnJOVmxXYlRWRFVqRmtXV05HWkZkaVZWa3lWVzE0YTFaWFNraGhSRTVYVFVkU1IxcFdaRWRTTVVaeldrZG9hRTB3U2s1V2JUQjRUa2RGZVZWclpGUmlhelZvVldwS05GZFdWbkZUYlRsVVlrWndlVmRyVWtOWGJGcDBWV3BDVjJKWVVuWldWRXBHWlZkR1NWTnNXbWxXUlZveVZtMTBZVlV4V25OYVNFNXFVbFJXV0Zsc1drdE9iRnAwVFVob1UwMXJXa2RVVmxwcllXeEtkR0ZHYUZWV2VsWkVXVlZhWVdOV1RuSmtSazVPVmxSVmQxWlhNVFJoTWtaWFUyNVdVbGRJUWxsWmEyUlNUVVpaZVUxV1NteFNNRFZIVjJ0a1IxVXlSalpXYm1SWFlsUkZkMXBFUms5ak1YQkpVMnhrYVZaV2NGZFdSbHBoVXpKV2MxZFliRTlXYlZKWFdXeFdWMDVzV2xobFJ6bFlZbFZXTlZaWGVFTldWMFY0WTBaU1drMXVhRE5WYlhoclpFZFdSMXBIYUU1TlJXdDVWbTF3UzAxR2JGZFdXR3hUWWtkb1ZWbFVTbE5qVmxaMFpVVjBXRkp0ZUZsYVJWWXdZVEpLUjFkc1dsWmlWRVYzVm1wQmVHTnRUa1pqUmxwT1lXdGFTVlpzVWt0U2JWWnpVbTVPVW1KSFVsaGFWM1JLVFVaYWMxVnJaR2hOVld3MFdUQldjMVpIU2toVmJHaFdZbGhvTTFZeFdtRlNNVnB6Vkd4T1RsWXhTa2xXYlhodll6SkdjMU5zYUZaaVIyaGhWakJvUTFOR1VsZFhiazVYWWxWYVNWVnRlRzloVmtwMVVXcGFXRlpGU25aVmVrWmhZMnN4Vm1GR1dtaE5iV2hZVjFaa01GbFhSa2RpUkZwVVlUSlNWRlJXYUVOU01WSnpWbFJHVjAxV2J6SlpXSEJIVmpKS1ZWSlVRbGhXYkhCWFdsVmFUMWRYU2tkV2JHaFRUVzFvWVZadGNFTmhNa2w1Vkd4a1YySnJOV2hWYlhNeFlqRldkR1ZIUms1U2JFcFlWakp6TldGSFNrWmpTSEJhWVRGS1VGWnFRWGhrVmxaWldrWmthR0V4Y0c5WFdIQkxWREZLZEZKclpHRlNWRlp2V1ZSR2QxTnNXblJOV0dSU1lsWmFTRlV5ZUd0Vk1rcHlWMnhrV21FeVVsUldNRnBUVmxaT2RFOVhiRTVXTVVwWlZtMHdlRkl4V2xaTlZscHFVMGQ0VmxsclduZGtiRnBXVjIxR2FrMXJOVXBWVjNoclZHeEtkVkZyZUZoaVIxRXdWMVphWVZZeFNuVlZiRTVwVjBWS2QxWnRNVEJYYXpGSFYxaHNhMUo2YkZkVVZscGhVMFpaZVU1V1RtaFNhelZIVlRKNGIxZHRSWGxWYmxwV1lURndWMXBXWkZkVFIxSkhXa1UxVjJKclNUSldha293V1Zac1YxVnVUbGhpYkZwVFdWZDRZVmRHVm5SbFNHUllVbTE0VmxVeWRHdGhhekZYVTI1c1YwMXFSak5XVkVwTFYwZEdTR0ZHWkdsWFJVcFJWbXhTUzFJeFNYbFNXSEJwVWpOb1ZWVnFSa3RXVm1SWVpFYzVVazFWTlVoV01uUnZZa1pLVldKR1dscGlSbHBZVkd0YWNtUXhXblZVYkdST1lURlpNVlpyWkhkVk1XUjBVbTVLV0dKR1NtRlVWelZQVGtaYWRHVkhkR3RTTUZwSFZHeFZNV0ZXV1hsaFIwWlhZV3RhY2xSclpFcGxSa3BaWVVaYWFFMXNTbGhYVjNSaFpESkdSMVp1VGxoaWJWSnhWRlphZDAxR2EzcGpSV1JZVWpCd1NWcFZXbXRXTURGeFVsaGtWMDFHY0V4Wk1qRkxVbFprYzJOR1pGZGlhMHBhVm0xd1ExbFdiRmhWYTJSWFlrWmFVMWxzVm1GV1JsWnpWMjVrYkZac2NGbFpNRll3VmtVeFZrNVdhRmRpVkZaTVZrUkdZV1JHVm5SUFYwWlhUVEpvYjFZeFdtRlpWMDE0WVROd2FGSlViRlJVVmxaYVpXeGFSMWR0Um1oTmExcEhWRlZvYzFadFNraGhSMFpYWVRGVmVGWnJXbkprTVdSeldrZDBVMDFWY0V0V01uUnJUa2RHVjFOdVVtdGxhMXBaV1d0YVlXUnNXa1ZTYlhSVVVtczFlbGRyV205aFYwcFpZVVprV0ZZelVuSlpha3BIVWpGa2RWSnNVbWhOYkVwNFYxZDBWMlF5VmtkWGJHaHNVak5TVmxsclZuZE5WbFpZWlVoT1dGSnRVa3BWVjNRMFZqRktSbGRyZEdGV2JIQlVXVEo0ZDFOR1NuTlViV3hYWVROQmVsWnFSbUZWTVVWNVZGaGtUMVp0VWxsWmJYUmhWa1pzYzFadFJscFdiSEF3VkZaU1UxZEdTbk5qUld4VllrWndVRlpxUVhoamJGcHhWbXhrVjAweWFHOVdha2w0VXpGa1dGSnJXbXhTYmtKdldWUkdkMWRXWkhKV2JGcHNVbXhzTkZaWE5WTmhiRXB5VGxoQ1ZtRnJOWEpVYlhoaFpFVXhTV0ZGTlZOV1JWcEpWbTE0YjJJeFpFaFRia3BQVjBWYVYxbFVSbUZVUm1SWFYyeE9WMkpIVWpCVmJYaFhWVEpLU1ZGcmNGaGlSbHB5VldwS1IyUkdUbk5YYlhCVFZtNUNXVlp0Y0U5aU1sSnpZa1phVjFkSGFISlZha0poVTBaV2RHVkhPVmROYTNCSVdUQmpOVll4WkVsUmEyaFlWbXh3Y2xWcVJsTmtWazUwVW14T1RtSlhhRlpXTVdONFRVWk5lRnBJVGxoaVJscFRXV3RrVTFaV1VsZGFSazVZVW14c05WUnNWbXRXYlVwV1kwWmtWMDFxUmtoV2FrcExWMVpXZFdOR1ZtaE5XRUkxVjJ0U1IxbFhUWGhqUldSWVlsZDRXRll3Vmt0aFJscDBaVWQwYkdGNlZsaFhhMmhUVlRGa1NHRklSbFpoTVZWNFZqQmFVMVl4WkhWYVIyaFRZbGhqZVZaWE1ERlVNVkY1VTJ0YWFsTklRbGhaYkdoT1pVWmFjVkZZYUZkaVZUVkhXa1ZhYTJGV1NuSmpSWGhYVW14d2FGWkhNVmRTTVZwellrZG9VMkpYYUhkWFYzUlhaREpXYzFkc2FHcFNWVFZoVm0weE5GZEdiSEpYYkdSV1RXdHdNRlpYTURWV2JVcFpZVWh3VlZaRldtRmFWbVJYVW1zNVdHRkhiRmRYUlVwTFZtMTRhMlF4U1hoWGJrcE9WMFZhVkZZd1pGTlhSbFp4VkcwNWFtSkdXakJhVlZVMVlXMUtWazVWYUZoaE1YQlFWbFJHWVdSV1JuVlhiR1JPVm01Q1ZWWlhjRWRXYlZaWFZXeHNhRkpzV25CWlZFNURWMnhrV0dSSGRHbE5hMncwVmxkNGIxUXhXalppUm14YVlURndNMVJWV25kU2JHUjBaRVprVTFaRldqWldWRWt4WkRGa2NrMVZaRmhpUjJoWVZtdFdkMVJHVlhoWGEyUnJWbXhLZWxkclpITlhSa3BWVWxSQ1YwMXVhR2hYVm1SR1pWWlNkVlJ0Y0ZOV00yaHZWbGN4TkdReFVYaGlSbFpUWWtoQ2MxbHJaRk5XYkZaWVRWUkNhRlpVUmxsV1YzUnpWbXN4ZFZWdVdsZGlXR2h5VlRCYVYyTXlTa2RhUjJ4WVVqSmtObFp0Y0VOWlZsbDVWR3hrVldKcmNGbFpiR2h2WTBaYWMyRkZUbFJpUjFKV1ZWY3hNRlF4U1hkWGEyUlZWbXh3ZWxaWE1VdFRWa1p6WVVad1YxSldiM3BYVmxaaFlURlplRnBJU2s5V00xSlBWV3RXWVZkR1dYbGtSM1JxVFZad1NGVXllSE5WYlVwSlVXeHNWMkZyTlhaYVIzaGhWbFpPY21OSGVGTmlTRUY0Vm10a05GbFhSa1pOVlZaWFlrVktXRlZ0ZUhkaFJscHhVVlJHVjAxV1ducFhhMXAzWWtkS1IyTkdiRmRTYkZwVVZXcEtWMVl5UlhwYVJtaHBWbFp3V1ZkWGRHRmpNRFZ6Vm14b2JGSnJOVmxWYlhoM1pXeHJkMVpxVWxkaVZYQmFXVlZvUzFkck1YVlVWRVpYVFVad1RGbDZSbE5qTVZKeldrWmthVmRHUmpaV2JUQjNaREpSZVZacldrOVdWMmhVVmpCa05GWnNiSFJrU0dSV1VteHdNRlJXV2s5aFJrcHpWMnBDVlZac2NGQldiRlY0VjBkV1NXTkdhR2hOYXpCNFZtMXdRbVZHV1hsVWEyeG9VbXh3Y0ZaclZscGxiR1JZWkVkR1ZFMVdjRmhWTWpWTFlWWktkRlZzYUZwaVIxSjJWRmQ0WVdSRk1WVlZiV2hPVmxSV1NsWlhNVEJoTWtaWFUyNVdVbUpyU2xoVVZXUlRaR3hhUjFkdFJtcGlSbHA1VjJ0YWQxWXdNVlpqUlhCWFlUSlNNMWRXV2xabFZrNXlZVWRvVTJKRmNHaFhWbEpMWWpGRmVHTkZWbE5pVlZwVVZGWmtVMlZzV2tobFIwWlZZa1pzTkZVeWRITldNa1p5WVROb1YyRnJXbGhhUlZwTFYxZEtSMWR0YkZOTk1taHZWbTB4TUZZeGJGaFNhMlJvVFRKNGMxVnROVU5qYkZKWFdrWk9iRlp1UWtkWGEyaHJZVVphYzJOR1dsZGlXRkYzVmpCYVlWSnNUblJoUm5CWFVsWndWVmRyVm1GVU1sSlhWRzVPVm1KWGFFOVpiVEZ2VjJ4WmVGZHRkRTVTTVVZelZHeG9UMkZzU25OalJteGFWa1UxUkZsNlJsZGtSVFZXVkd4U2FWSnVRWGRYYkZaaFZESkdSMWR1U2s5V1YxSlhWRmMxYjJWc1duRlNiSEJzWWxWYVNsWXllR0ZXTVVwWFkwWldWMkpZUWtoWlZFcE9aVlpLY21GSGNGTmhlbFphVmxjeE1HUXhaRWRYYmtwWVlsVmFXRlJYYzNoTk1WSnpWbTEwV2xack5VZFpNR00xVm0xS1IxTnVjRmROVm5CWVdURmFSMk15VGtaT1YyeFRZbXRHTTFaclpEUldNVkY0V2tWb1ZHSkdjRmhaVjNoTFYwWlNXR05GWkZSU2JWSllWako0ZDJKSFNsWlhhMnhhVmxkU1NGWlVSbHBsUms1ellrWmtWMDB3U2tsV2JGSkxWRzFXUjFWdVZsWmlWM2hVV1d4YVMyUXhXbFZSYkdSVVRWWktTRll5TlZOVWJGcEdVMjA1V2xkSVFraFdNRnBoVWpKR1NFOVdaR2xTTVVwS1YxWldZV014WkhSVGJHeFZWMGRvWVZSV1duZFhSbkJIV2tVNVZGWnNTbnBYYTFVeFZqQXdlVnA2U2xkaVdHaHlWR3RrUm1WR1dsbGhSbEpwWWtWd2VsWlVRbXRpTVZsNFlraE9hRko2YkZkVmJYaDNaVVpXVjJGSE9XaGlWWEJKVmxjMWMxZEhSWGhqU0VwWFZrVkdNMXBFUVhoV1ZsWnpZVVprYVZORlNuWldiR2gzVXpGVmVGZFlhRlJpYXpWd1ZXcENZVlpHYkhOYVJ6bFlWbXh3V1ZwVldtdGhNREZZVld4b1YwMXVhSHBaVjNoTFYxWldjMVZzY0dsU2JrSkpWa1pTUjFVeFdYaGFTRlpWWWtkU1dGUlZhRU5UYkdSWFZtMXdUMVpzY0ZoV01uQmhWVEpLYzJOR2FGVldiSEF6V1ZWYVdtUXhXbFZTYkdoWFltdEtTVll5ZEZaTlZsbDVVMjVLVkdFelFsaFpiR2hEVkVaU2NsZHVUbGROV0VKSFdWVmFVMkZXU25WUmJIQllWbnBGZDFwRVJscGxSMHBKVkcxb1UyVnRlSFpXVnpFMFV6RlplRmRZYkd4U1dGSndWVzEwZDAxR1dsaGpSV1JZVWpCV05Ga3dhRXRXTVVsNllVZG9WMDFXY0VoWmVrWjNVakZ3U0dKR1pGTldiR3cyVm0weE5GVXhTWGhhU0ZKWFlUSlNWbGx0ZUdGV01XeHlWMjVrV0ZKc1ducFdiVFZyWVVaS2MyTkVRbUZTVm5CeVdWUkJlRll4U25GVmJIQk9VbTVDYjFacVFtdFRNV1JYVm01V1ZHSkhVbkJXTUdSdllqRmtjMXBFVWxwV2F6VkhWRlphYzFaWFNrZGpSVGxhVmtWYVlWUlhlR0ZXTVhCSldrWldUbFp0ZHpGV1ZFbzBWakZXZEZKdVRsUmlSbkJoVm10V2QxWkdXbFZTYm1SWFlrZFNlbFpITVhkVWJHUkdVMnR3VjFaNlJUQldSRXBIVmpGT2RWWnNTbWxTYkhCWlZrWmFhMVZ0VVhoaVJsWlRZa1p3YzFadGVFdGxiR1J5VjIxR2FGWnJiRFJWTW5oM1YwWmFObEZxVWxkV1JWcG9WbXBHYTJSV1ZuUmxSazVwVm10d1VsWnRNSGROVmtWNFYxaG9ZVkp0ZUhGVmJURlRZakZXZEdSSVpHeFdiWFF6V1ZWb1QxZEhSalpTYTJ4YVZsWktVRlpxU2t0WFZsSnhWVzFHVTJKV1NrbFdWRUpyVWpGSmVHTkZhR2hTTW1oUFZGVldkMU5zV25GVGFsSlhUVmQ0V1ZWc2FITldiVVY1WVVaU1dsWkZjRlJaVlZwWFpFZE9ObEpzYUZOaVdHZDNWMnRXVjAxSFJYbFRhMlJwVWtaS1lWWnNaRzlqYkZwVlVWaG9hbUpHY0hoV2JYaHJWakF3ZUZOdWJGZGlXRkp5VlhwS1QyTnJOVmRhUm1ocFUwVktXbFpVUWxkVE1XUlhWMjVHVW1KVlduRlVWM2hMVTFaYVdHUkhSbHBXYTNCV1ZtMXpOVll5U2xWV2ExSlZZbGhvWVZwVldsZGphemxZWVVVMWFFMHdTa3BXYkZKTFRrWlplRlpZYkZOWFIzaHZWVzB4YjFkR2JIUk9WVTVZVW14d2VWWXlNVWRXTVZweVkwUkNZVkpXY0ZSV1ZFRjRVakpPUm1SR1pGZGxhMVYzVmpGYWExSXhXWGhVYkd4b1VtczFXVlZxUmt0WFZtUlhXa1JDVkUxcldraFphMUpoVlRKS1dWVnNWbFppV0dob1dsWmFjMk5zWkhOVWJXaFhZbFpLU2xkV1ZtRldNV1JIVjFod1ZtSnNjRmRXYTFaaFdWWndWbGR0ZEdwTmExcEhWR3hhYTFVeVJYcFJiR2hYWVRGd2NsUlZXbk5YUmxweldrWmFhVkl4U2xwWFYzaHZWVEZrUjFadVJsSmliVkpQVlcwMVExWXhaSEpXYlhSWFRVUkdlVmt3Vm5OV01WbDZZVVpTV0Zac2NFdGFWekZIVTBkR1IxcEhiRk5pYTBwU1ZqRlNTbVZHVlhoVFdHaHFVbFp3VUZadE1WTlhSbFowWlVoS2JGWnNjREJaTUZZd1ZHeEtkR1ZHYkZaaVIyaDZWbFJLUzFOR1ZuTmlSbkJYVWxadmVsWnFRbUZYYlZGNFkwVmtWV0pIYUZSWmJHaHZUbXhhYzFwRVFsVk5Wa1kwVlRJMVQyRnNUa2hoUm1SYVlrZG9WRlJVUm5OamJHUnlaRWQwVjJFeGNEVlhWbFpoWkRKR1JrMVlUbFJoTW5oWVdXdGFTMVJHVmpaU2JYUlVVbXR3ZVZsclpFZFZNa3BYVTJ4c1YxWXphRmhhUkVaclZqRmtjMkpIY0ZOWFJrcFpWa1prZW1WRk5VZGFTRXBvVW0xU1dGbHNWbmRYYkZaWVpVWk9WMDFyV25sV01uUTBWMnhhVjJOSGFHRlNWbFkwVmpGa1QxSnJOVmRhUjJ4WFlUTkNTMVp0TVhkVE1EVklVbGhzVTJFeVVsVlpWM2gzWTBaV2NWRnRSbGhTYlhoNldWVmFUMVJ0U2tkVGJHeGhWbGRvVUZsWE1VdFRSbFp4VVd4YWFWZEhhREpYVmxwaFdWWlplRnBHVmxKaVIyaFlWV3hXZDFaV1duSlZhMlJZWWxaR00xUldXbXRaVmtsNlVXeFNXbGRJUWxoWmFrWmhWMGRTUjFwSGRFNVdWRlpKVm0xNGIySXhaRWhUYTFwUFYwVmFWbFpxVGxOaFJsVjNWMjFHVkZKVVJscFdSM2hoVkd4S1JsTlVSbGRoTWxJelZtcEdXbVZXVG5OV2JFNVhVbFZ3YUZadGNFOVVNRFZIVjI1R1UyRjZiRmxXYWtKaFUwWnNWbHBJVGxaTlJFWXdXVlZhYTFZd01WZGpSbEpXWld0YVYxcFdXbE5qTVhCSFdrZHNhRTFZUWxkV01XUTBWVEpOZUZwR1pGZGliRXBQVm10YVMxZFdXblJPVlU1VFRWZFNlVlp0TVRCaFJrbDNZMFprV2sxR1dqTldiWGhhWld4V2RWZHNaR2hoTUZrd1YydGFhMUl4U1hoU2JrNXFVbTFTVDFSVlVsSmtNVmw0Vld0MFQxSXdWalZXUnpWVFZrZEZlVlZ1UmxaaVZFWlVWakJhVTFZeFduVlhiWGhYWWtkM01GWXlkRk5STWtaR1RWWmFUbFpHU2xkVVZtUnZaV3hhYzFwRldteFdiRm94VlZkNFlXRldXa1pYYkZaWVZrVkthRmRXWkU5ak1XUjFVMjF3VTFaR1dsVlhWM1J2VVRGT2MxcElTbGRpV0ZKVVZGZDBZV1ZXVWxkWGJUbFhZbFZXTlZsVldtOVhiVXBJWVVoYVlWWXphSHBXYWtaclkyMVNTR1JHVG1sU2JUazBWbXhhYTA1SFVYaGFSV1JWWVRGd1ZWbHJaRFJYUm14WVpFaGFUbEp0ZUZaVmJURXdWVEpHTmxKc2FGZGlXR2hvV1ZaYVMyTnRUa2RSYkdoWFlsZG5lbFpYTVhwbFJrbDRXa2hXVm1GNlZsUlZiRnAzVmxaYVIxZHRSbXROVjFKWVZteG9jMkV4U1hkWGJGcFZWbTFTVkZWcVJscGxWMVpJVDFab2FWWllRa3BYVmxadldWWlplRk5zWkdwU01GcG9WV3RXWVdOc2JEWlRhemxVVWpGYVNGZHJWVEZXTVdSR1UydHNWMkpZYUdoWlZ6RlhVMFpTV1dGR1pGaFNNVXBRVm0xNGEwNUdWWGhpUmxaVllUQTFXVlp0TVRSbFZsbDVUVlZrYUZKcmNEQmFWVnBoVm0xS1ZWSllaRmRoTVhCTVdUSXhUMUl5VGtkalIyaE9Za1Z2ZVZadGVGTlRNVXAwVlZoc1ZXRXlVbkJWYlRGdlYwWnNjMWRyWkU1TlZuQlpXVEJXUzFSc1duSmlSRkpZWVRGd2VsZFdXa3RrUjBaSlVXeGFhR0V4Y0UxWGJGWmhZVEZrU0ZWcmFGQldhM0JQVm14U1YxTldXbkZTYlRscVRXdGFNRlp0TlV0WFIwcFZZa1pvV2xZelVreFVWRVpYWTFaS2RWUnRjR2xTYkc5M1ZsY3hOR0V4VW5SU1dIQlNZa2RTV0ZadWNFZE5NVnBGVW0xR2FrMVhVbmhXTW5oUFlWWkplV0ZHYUZoV2JWRjNWMVprVDJNeFpGbGhSMFpUVmpGS1ZWWkdXbUZrTURGSFlraEtZVko2YkZaWldIQkhVakZyZDFkdVpGZE5hMXA1VmpJMVMxWldXbGhWYTJSaFZsWndhRll4WkV0U01WWnpZVVpPVG1KWFozcFdiWGhxWlVVMVIySkdaRmRYUjJod1ZUQldkMkZHVm5SamVrWlhUVlphTUZwVlpFZFViRXAxVVd4a1dsWlhVWGRXTUZwTFl6Sk9SVkZ0UmxOV2EzQlJWbTF3UzFNeFdsZFRiR3hoVW01Q1dGWnROVU5VVmxwMFpVZEdWRTFzU2xsV1IzUnJWMGRHTmxadVFscGlSMUoxV2xaYVlXUkZNVmxhUms1T1ZsUkZlbFpIZUc5VU1XUklVMjVLYWxORk5WZFpiRkpIVmtaYWNsZHNaR3BOVjFJeFYydGtjMVJzV1hoVGFsWlhZbFJDTkZSVldsWmtNREZYVjIxc1UxSnJjRmxYVjNoVFZqRldSMkpHYUd4U1dFSnpWbXBDWVZJeFVYaFhibVJvVm10c05GVXljRXRXTVZvMlVsUkNXRlp0VWxCWmVrWjNVMVpXZEdSR1RsZFNNMmhXVmpGa05HSXlTWGhhU0U1WVltdHdXVmxzVW5OalJsSlhWMjVPVDFac1ZqVlViRll3WVVkS1JtTkljRnBOUjFKSVZqSjRZVkp0VGtkVmJHUm9UVmhDYjFaWGVHRlRNbEpYVlc1U2FsSXllRlJaYlhSS1RXeFplRlZyVGxkaGVrWllWbXhvYzFaSFJYbGhTRXBoVmpOU2FGWXhXbk5XVmtwMFVtMW9VMkpZYUZkV1ZFb3dZVEZWZVZKcVdsTmlTRUpYVkZjMWIyUnNiRmRYYTNCc1ZqQmFTRmxWV210Vk1rcFhVMWh3VjJKWVFraFhWbHBLWlZaT2NscEdhR2xTTW1oMlYyeGplRTVHV2xkYVJtaHNVbXh3VDFadGN6RlRSbVJ5WVVWMFdGSXdjREJXVjNodlZsWmFWMU5yVWxWaE1YQlhXbFprVG1WdFJrZGhSazVwVTBWSk1sWnRjRXBsUjBsNFdraFNWMkpyY0hGVmJYUkxWMFpzV0dSSFJsWlNia0pJVmpKNFQyRXhTbkpqU0hCWFVqTk5lRlpIZUdGWFZrWnpXa1prYVZaRlNUQldSbFpoWXpGWmVWTnJaR0ZTTUZwVVZtcEdTMWRzWkZoTlZFSnJUV3RhU0ZadE5VdFhSMFY2Vld4b1dtRXhjRXhXTUZwYVpWZFNSVkZ0YkZOTlNFSkpWMWQwVTFZeFdsaFRhMlJxVW10S1lWWnNXbGRPUm13MlVtMTBhMVl3Y0VoWGExVXhZVmRLV0ZwNlNsZGlXRUpNVkd0YWMxWXhUblZVYlVaVVVtdHdkbFpYTUhoVk1rbDRWV3hrYUZKVk5WbFdiWGgzVFVad1ZscEZaRmRXVkVaNVZHeG9kMWRyTVVkWGJrcFhZa2RTVEZZd1pFZFRWbEp6WTBaa1UxWnRPVFpXYlhCTFRrWnNXRlZyYUZWaE1YQnhWV3BPYjFaR1VsWlZhMXBPVW14d01GcFZZelZoVlRGWFkwVnNWazF1VW5KV01HUkxVMGRHU0ZKc2NGZFNXRUpWVm0xMFlWZHRWa2RhU0ZKVFlsaENXRmxyVm5kT2JGcHlXVE5vYVUxV1ZqVlZNbmhyVmtkS1NHVkdhRlZXZWxaVVZtcEdVMk14Y0VaYVIzQm9aV3RhV1ZkV1ZtRlpWMFpJVWxob2FsSnRlRmhXYm5CWFRURldjVkpyT1ZOTlYxSjZWbTE0VDJGV1pFZFRiRlpYVW14d1YxUldaRmRqTVdSMVZXMTRVMDB4U2xoV1JtUXdaREZrUjFaWWFGWmhNMUpZVkZaV2QyVnNhM2RhUnpsWFRWVndSMWt3VlRWWlZscFhZMGhLV21WcmNFeFZNR1JMVWpGU2NrNVZOV2xXTW1oWVZtMHhNRmxXVlhoVFdHaFZWMGRvYUZWc1pGTlhWbXhWVTJ4T1dGSnRlSGxXYkZKSFZtc3hWMU5zWkZkV00yaHlWakJhUzJSSFZrbGlSbVJPWVd0YVNWWnFRbXRUTVZsNFdraFdhbEp0VWs5WmJURnZUV3hhZEdWSFJsaGlWbHA2Vm0wMVUyRkdTWGRYYkdoYVlUSm9SRll3V210ak1XUnpWMnMxVjJKSVFYZFdiR1F3WVRGc1YxTnNWbGRpUjJoaFdXdGFTMlJzVW5OWGJVWnFUVmQwTmxsVlZUVlZNREZJWkhwQ1dGWXpVbWhaVkVaaFUwWk9jbUZHV21saE1YQllWMWQ0YjJJeFVrZGFSbVJZWWtVMVdWVnNVbGRYVmxGNFZsUkdWV0pHY0hwV01XaDNWakpHY21JelpGVldWMUpJV1RKemVGWXhjRWRWYld4cFYwZG9XRll4WkRCaE1WVjVWbTVPYVZKdFVsbFphMmhEWXpGYWNWRnRSbFJXYkVZMFZqSXhNR0ZHV25OalJXUlhZa2RvY2xZd1dtRmpNVTV5WlVaa1YyVnJXbGxXVjNCSFZqSk5lVk5yYUdsU2F6VndWV3hvUTFsV1duTmFTR1JVVFd0c05GZHJhRTlaVmtwMFlVVTVWMDFIYUVSV1JFWmhaRVV4VjFSc2FGTmlXR2cxVjFaV1lWUXlSa2hUYkdSWVltMTRXRlJYY0ZkU1JscHpWMjFHYWsxck5VaFpWVnBYVmpGS1YyTkliRmhXUlc4d1dWUktUMk5yT1ZkYVIwWlRUVzFvZWxkV1VrZGtNV3hYVjFoc2JGSnRVbkJVVjNoSFRrWlplR0ZIZEZWaVIxSkhWako0VTFkc1drWmpTRnBYVFVad2VsWnNXa3RrVm5CSFZteE9hVmRIVGpWV2JGSkxaV3MxVjFaWWJGUmlSbkJ4Vld4a05GWXhiSE5oUnpsV1VteHdlRlZXYUc5V01rcElWV3h3V2sxR2NISlpWbHBoVW14a1dXTkdaRmROTUVwSlZtdFNTMVV4U1hoWGJrNXBVako0VkZsclduZGtiRnBIVjIwNVVrMXNSalJXTW5odllXeEtWazVYUmxkaVZFWlVWVEJhV21WVk5WWmFSbHBwVWpGS1NsWnNZekZVTVZwMFUyeHNhRkpGTlZaV2JGcDNWa1phZEUxVlpGUlNWR3hZVmpKek1WVXhTbGRpZWtaWFlUSlJNRmxxU2xKbFJtUlpZVVpTYUdKSVFsbFhWM1JoVXpGc1YxZHVUbGhpYlZKV1ZXMDFRMUl4V1hsbFIzUm9UVlZ3VmxscldtOVdNa3BaWVVoS1dsWnNjR0ZhVm1SSFVteGtjMXBGTlZkTlZXdzJWbXhrZDFNeFNuUldhMlJoVTBVMWFGVnRlRXRqUm14eVZtNWtWMVp0VWxsYVJXUkhWMnhhYzFKcVVscGhNbWhNVm1wS1MyUkdWbk5XYkZwcFYwZG5lbFpYTVRSV01sSkdUVlphWVZJeWFGUldhMVpoVjJ4a2MxWnRSbWxOVm5CNVZGWmFiMkZHVGtsUmJVWmFWa1ZhTTFaRlduTk9iRXB5VDFkd1RsWXhTalpXTW5Scll6RmtSMU5ZYkdoVFJuQllXVlJHZDFaR1ZuRlRhMXBzVW0xU1dsbFZaRWRXUmtwVlZtNW9WMVl6UWxCWmFrWnJVakZXYzFwR1pHbGlWa3BXVm0weE5HTXdOVmRqUlZwaFVrVktiMVpzVWtkWFJsVjVUbGhrVjJGNlJqRldWekZ2VmpBeFNGVnJaR0ZXTTJoSVdYcEtSMUl4Y0VoaVIyeG9UVWhDU2xadGRHRldNV3hZVWxob1dGZEhhR2hWTUZVeFZteHNjMkZGVGxWTlZtd3pWbTEwTUZaR1NuTmpTR2hXVFZkb2RsbFVRWGhXTWs1R1lVWmFUbUp0YUc5WFZtUTBVekpTU0ZKclpHbFNiVkp3VmpCa2IxUldXbFZSYlVaclRWVndXRlV5TlU5V1YwcEdUbFU1VjJGcldreFhWbHBhWlZkU1NGSnRiRTVoTVhCYVZsY3hkMWxXV1hsVGJsSm9VbTFvVjFsc2FHOU5NV3hXVjIxMFYwMVlRa2hYYTJSM1ZHeGtSbE5yZEZkV1JXOHdXV3BLUjFZeFRuTldiR1JwVWpKb1dWWlhNSGhWYlZGNFkwVldVMkY2YkhGVVZscDNaV3hzVmxwRVVsZFNhMncwVlRKNGMxWXhTbk5qUm1oaFVrVndXRmw2U2tabGJIQkhZVWRzVjFJemFGcFdiVEI0VGtkUmVGcEZaR2hOTWxKb1ZXeGtVMWxXV25SbFNHUnNZa2QwTTFZeWRFOVhSMFkyVW01b1ZtSllVblpXYlRGSFkyeGtkVk50UmxOV01VcE5WbFJDYTFNeFRraFNhMXBQVm14S1ZGWnNZelZPVmxwMFRVaGthMDFzUmpWV2JYUmhWREZhV0ZWdVFsWmlWRVoyVm1wR1dtUXhjRWRVYkZaT1ZteFplbFl5ZEdwT1YwWnpVMjVPV0dGclNtaFdiR1J2WTJ4WmQxZHJkR3BOYTNCR1ZrZDRiMkZGTVhKTlNHaFhZV3RLYUZkV1pFNWxWbEp5Vm14S2FWWldjRlZXYlhCSFV6Rk9WMWR1UmxKaVdGSlZWRlpWTVZOV1dsaGtSbVJYVmpCd1NWWlhjelZYYkZsNlZXeG9WVlpGV21oYVJWVjRWMWRPU0dWR1RrNVNSbFl6Vm0xMGEwMUdiRmhTYTJSVVlteGFVMWxZY0hOV01XeFlaRVZrVGsxWVFsZFdNakZIWVd4YWNsZHFRbUZTVm5CUVdWWmFZV015VGtaaVJtUm9UV3N4TkZaWWNFdFNNVWw0Vkc1V1ZtSlhhRlJaYkdSdllVWmtXR1JIUm10TlZrcElWakkxVDFkSFNsWlhiR3hXWVd0RmVGVnFSbXRqYkdSeldrWldhVlpZUWtoWFZFSmhZekZaZVZKWWJGVlhSMmhZVm10V2QxTkdWbkZTYXpsclZtczFlVlF4V210V01VbDZZVVpvVjJKVVFqUlVhMXB6Vm1zeFNXRkdhR2xpUlhCNlZsY3dNVkV5VFhoV2JsSlBWbFUxVkZscldtRlhWbkJXWVVkMFYwMUVSa1pWYlhoclZqQXhWMU5yYUZkaGEzQk1WVEJhVTFkWFJrZGFSazVUVm01Qk1sWnRNWGRTTVZWNVZHNU9ZVk5GY0ZGV2JURlRWREZzYzFwSE9WaFdiR3cwVmpKNFQxVXdNVmhsUm1oWFZqTlNjbGRXV2t0a1JsWnpZa1p3YVZKc2NHOVhWRW8wVmpKTmVGWnVTbUZTYldoVVdXdG9RMU5zV2tkWGJFNVdUV3RhU0ZZeU5VdGhWa3BIVTJ4a1ZWWjZWa1JXTUZwYVpERmtkRkp0Y0U1V01VbzJWakowWVZZeVJsZFRibFpTWWxkb1dWbFVSa3RSTVhCV1YyMTBWMDFXU2pGV1Z6RjNWVEpHTmxadVpGZGlWRVYzV2tSR2EyTXhaSFZUYkdocFYwWktlVlpHV2xkWlYxWlhWV3hrV0dKWVVsbFZha0ozWlZaU2MxZHVUbGhpVlhCSVZqSXhiMWRyTVZkalJsSlhUVWRTVUZSdGVFdGpNVlowWWtaT1RrMVZXVEpXYlRGM1V6QTFTRkpZYUZoWFIxSlBWbTE0ZDJOV1ZuUk5WemxhVm14S1YxWXlOV3RYUmtwelkwaG9WazF1VVhkV01GcGhZMnhrZFdKSFJsZFdia0p2VjFaV2ExSnRWa2hVYTFwT1ZtMW9XVlV3Vmt0VVZscHlWV3RrVkUxck1UVldSM1JoWVVaS2NrNVlRbFppUmtwWVZqRmFZVmRGTVZWVmJYUk9Va1ZhTmxacVNURlRNV1JJVTJ0YVQxWnJOVlpXYlhoV1pVWndWMWRzVGxkTlYxSXdXa1ZhYjFVeVNsZFRhM0JZVm14YWFGbFVSbXRqTVdSeVYyeE9XRkl5YUZwV2JURTBaREpHUjJFemFGaGhNbEp5Vm0xNFMyVldVWGhYYXpsb1ZtdHNObGRVVG10V01ERlhZMFpvV21GcldsTmFWVnByWkZaT2NrNVdaR2xXTW1oWlZqRmFVMU13TlVkaVJtUllZbXMxV1ZsdE1WTmpNV3h5VjI1T1QxWnVRbGRXTWpWcllWWkpkMk5GYUZaTmJtZ3pWako0WVZZeVRrbFRiR1JUVFRKb1RWZHJXbUZTTWsxNVUydGthRkp0YUZWVmJGWjNVMnhaZUZkc1RsUk5WbFkwVmpGb2MxWlhSWGhqUjJoV1lXdEthRlpyV21GamJHUjBVbXhvYVZKdVFscFhiRlpoWVRKRmQwMVdhRlppUjJoWVZGZHdWMVpHYkZobFJYUllWbXRhTVZaSGVHRmhWa3B5WTBWc1YxWkZXbWhXYWtwVFVtczFWMXBHVm1sU01VcFZWa1pXWVZkck1WZGFTRTVYWWxWYVZsUldaRk5sYkZsNVpFZEdhRll4V25sVk1uaHpWakpLV1dGRVRsZGhNWEJvV2tWa1YxTldjRWRVYXpWWFlUSTVNMVl5ZUZkaE1rMTRWbGhzVkdKcmNGVldhMVpMVjBac2NscEZPVTVOV0VKWFZqSjBkMkpHV25KalJuQmFWbFp3ZGxsV1pFWmxiRVp6WTBab1YyVnJTVEJXUjNSaFl6RlplRlp1VGxoaVIyaHdXV3hhUzJWR1pGaGtSM1JQVW14c05GZHJhRXRXTWtwV1YyNUNWbUpZYUROV2JYaHpZMnhrZEZKc1pFNVdWM2N5VjFaV2IxTXhXWGhUV0hCb1VqSm9hRlZ0ZUhkVFJuQkdWbFJXVjAxWVFrbFphMXBQVkd4S1IxSnFUbGRpVkVJMFdrUkdTbVZHVW5WVmJHUm9UV3hLYjFaVVFtRlpWbVJIWWtoS1lWSnJOWEZWYlhoaFRVWndSbUZIZEdoTmEzQkpWbGMxZDFkSFJYaFRiRkpYVFc1b2FGcEZXbGRrVjA1SFdrVTFhV0pYWjNsV2JYUnJUa1pzVjFOdVRsVmliRnBWV1d0YVlWZEdVbFZUYlRsVlZtMVNlbGRyVWxOWFIwcFhWMnhzVjJKWVVuWldWVnBoWXpGa2RWRnNXbWxXUmxwRlZsUkdZVmxXV2xkVWJGWlRZa1pLVDFadE5VTlhWbHB4VTFSR1ZrMVdjREJWTW5SclZrZEtTRlZzV2xkaVJuQXpWRlJHZDFkSFZrbFRiWGhYVmtWYVdGWXlkR0ZVTWtaSVZtNVNiRkp0ZUZoVVZ6VlRZMnhzTmxKc2NHeFNiVkl4VmtjeGIxUnJNWFJoUm14WVZqTm9kbGxxU2s5ak1rNUhZVWR3YkdFeGNGbFdSbHByVlRKV2MxcElTbGhpVkd4dlZtcENXazFzV25ST1Z6bFhUVlpzTmxWWGRGTlhSbHB6WTBkb1dtVnJXbkphUmxwTFl6RmFkR0pHWkZOTk1taG9WbTE0YW1Rd01WZFNXR2hVVjBkb2FGVXdWbmRYUmxweVYyMUdWMkpHU2xsYVJXaHJWVEF4V0dSRVRsZFdNMUpRVmpCa1MxWnNXbkZWYkhCT1VtNUNSVlpxU2pSWlYwMTVWR3RrVW1KR2NIQldNR1J2VlZaYWRHVkhSbFZOYXpFMFdUQldiMkZXU25KT1Z6bFZWa1ZLVEZaRVJtRmpWazV4VVd4YVRsWlhkekJXYTJNeFZURlplVkpZYkZaaVYyaFhXV3hTUmsxR2JIRlNiR1JyVWpGYVIxcEZXbTlXTWtwSFYxaHdWMkpVUlhkVVZXUkdaVlpPY2xwSGNGTmlXR2hYVm0xNGEySXlVbk5pUm1SWFYwZG9XVlZxUm1GVFJteFdWMjEwVldKVlducFdNbmhYVmpKRmVWVlVRbGhXYlZKUVdUSnpNVll4Y0VkWGJXeFRZa2hDV2xZeFpEUmhNa2w0VTJ4a1dHSnJXbFJaYkZaaFkyeFNWMWR1Wkd4aVJtdzFWR3hhVDJGRk1WWmlSRlphVmxaVk1WWnFTa3RXVmtwWlkwZEdWMDB5YUc5WFZFWmhWREpPVjFKdVVtbFNWRlpZVkZaV2QxTXhXbk5hUkZKcFRXdHNOVlZ0TlU5V1YwVjRZMGhHVm1GclNtaFhWbHBoWTJ4YWRWcEdaRk5pUm5BMFZsY3dNV0V4VlhoWGJrcFBWMGQ0V0ZSWGNFWk5SbXhYVjJzNVUySkZOWGxaYTFwclZHMUtjMU5zYUZkU2JIQm9Wakl4VW1Rd01WZGFSbWhwVmpOb1ZWWlhNREZSTVdSWFdrWm9hMUl6VW5CVVZWSkRUa1phZEU1VlpGWk5hM0JKVmxjMVMxWnRTbGxoUkU1aFZteHdjbGt5ZUd0ak1YQklZVVprYUUxdVkzbFdNVnBYWWpGc1YxZFlhRmhoYkhCVFdWZDRTMWxXYkZoa1NHUldVbXhhZUZVeWREQldSbHB5VGxod1dsWlhVbnBaVmxwaFkyMU9TRkpzWkdsU01EUjZWMnhXWVZadFZrZGpSV1JoVWpOQ1ZGbHJhRU5oUm1SeldrUlNXbFl3YkRSV01qVlBWbTFGZVZWc2JGWmlWRVYzVkZSR1dtVlZNVVZXYkdST1VrVmFOVmRVUW1GWlZsbDVVMnhzVm1Kc2NGaFpWM1JoWVVaV2RFMVZPVk5pU0VKSlZXMTRhMVJyTVhSaFJuQlhUVzVTYUZkV1dsWmxWbEpaWWtaV2FFMXRhSFpXVjNoVFZqRmtWMVp1VGxkaVNFSlBXV3RhZDAxR2NFWmFSV1JYVFVSR1dWcFZXbTlXTWtwSVlVaGFWMDFIVWt4WmVrWlBZekZXYzJOR1pGTlhSVWw1Vm0xNFlWbFdiRmhWYTFwT1ZtMVNWbGxzWkRSVU1WbDNWbXQwV0dKSFVubFdiVEV3VlRBeFdGVnJiRlpOYmxKeVdWZDRUMU5XUm5OaVJtUk9VakpvUlZaVVFtRmpNVnBYVW14c2FGSnRhRlJaYTFwMlpVWmtWVkZ0Um1oTlZrb3dWVEkxVDFaSFNsVmlSbWhhVmtWYVRGVXdXbk5XVmtweVpFZDBVMkpGY0RWV01uUnJZakZWZVZOdVNsUmlSM2hZVlcxNFMxTkdWWGxOVm1ScVRWZFNNVlV5ZUd0aFZscFhZMFp3V0ZZemFHaFhWbHBQVWpGd1NWTnRhRk5XUjNob1ZtMHhNR013TlhOV2JHaHFaV3hhV1ZsclduZFNNVmw1WTBVNVYyRjZSbGhaTUdSdldWWktWMVpxVWxkaVJuQllXa1ZrUjFKck5WZGFSMmhPVFVWV05GWnRNVEJaVm14WFlrWmthVkp0YUZSWmEyUlRWbFpzVlZOc1RtcFdiRm93VkZaak5WZHNXblJsU0d4WVlUSk5NVlpVUmt0ak1XUjFZa1prVG1GclZqTldiWEJDWlVaa1IxWnVSbEppVlZwVVZtcEdSMDB4V25OVmEzUlVUVlUxV0ZWdE5VZFhSMHBJWVVab1dtRXhjRE5aYWtaclZqRldjbVJHVGs1V1dFSTFWa1phWVdNeFduUlRiR2hvVW14S1lWWnJWVEZTUmxsNFYyMTBXRkl4V2toV1IzaExWR3hLUjFkcmJGZGhhMjh3Vm1wR1ZtVldUbkpYYlhCVVVsUldXRmRYZUZOU01WcEhWV3hrV0dKVldsVlZha1poVTJ4a2NscElUbFpOUkVaS1ZWZDBiMWRHV2taVGJscGhVa1ZhWVZwV1drOWpNVnB6Vkd4a1UxWllRblpXYkdRd1ZqRkpkMDVWWkZkaWExcFVXV3RrVTJOV1VsZGhSVTVVVW14c05WUldhRTlXYXpGWFkwVm9WMDF1YUhwV2FrRjRWakpPU1ZkdFJsTlNWbkJNVjJ4V1lXUXhTWGhqUldSb1VqSjRWRlJYTVc5VmJGcDBZMFZPYUUxV1ZqUlhhMVpyVm0xS1IyTkdaRnBXUlhCVVdYcEdWMlJIVmtsYVJUVlRZbXRLV0ZadE1YcE9WbVJIVTFoa2FsSlhhR0ZaVkVaTFlVWlplV1ZIUmxkTlYxSldWVmQ0YTJGSFJYZFhWRUpYWVd0S2FGWnFTazlrUmtweVdrWm9hR1ZzV2xWV1JscFhaREZPYzFkdVRtRlRSMUpVVkZkMFYwNVdXbGhrUnpsWFVqQldOVlpYTURWV2JVcFpWRmhvVjFKRlducFpla1pyWTJ4a2RHVkdaR2xUUlVZelZtdGFZVlV4VlhoWGJrcE9WbXh3V0ZsWGVFdFpWbXhWVW01a2EySkdjSHBYYTFZd1lXc3hWazVZY0ZwV1ZuQXpXVlZWZUdNeFRuRlRiR1JwVmtWVmQxZFljRWRoTVU1SFYyNUthVkl3V2xSWmJHUnZWbFprV0dWSE9XbE5SRlpZVmpGb2MyRXhTWGRYYkZwVlZteHdNMVpxUmxOV01XUjBaRWRvYVZKWVFraFdWRW8wV1Zaa2RGSllhR3BTTW1oWVZteGFkMkZHVm5OWGF6bHFZbFpLU0ZaSGN6RmhSVEIzVTJ0b1YySlVRak5hVlZwS1pVWmFXV0ZHYUZoU01taFZWMVprZWsxV1pFZGlSbFpUWVROU1ZWVnRlRmRPVmxKWFYydDBhVkpyY0RGVlYzUjNWbXN4Y1ZKcmFGZFdSWEJNVldwS1QxSXlTa2RoUm1ST1RWVnZlVlpzV2xOUmJWWklWRmhvWVZOR1dsWlphMlJUWTBaYWMxZHVaR2hTYkhBd1ZGWlNRMkZyTVVWV2EyaFlZVEpvVEZsVldrdFdWMHBJVDFaYWFWZEdTWHBXUmxwaFZqRmtSazVXV2xWaVIxSndWbXhvUTFsV1duTmFTR1JWVFZad2VWUldXbXRoYkVsNVlVWmtXbFl6VW1oV01GcHlaVmRXU1ZwR1RrNVhSVXBJVmtkNGEySXlTa2hUYTJScVVqQmFXRmxzYUc5V1JsVjVZek5vVjAxWFVscFpWVnB2WVZaSmVXRkdXbGhXYkVwTVdXcEtTbVZHV25WVmJYaFRWMFpLYUZadE1UUmtNbFpYVjI1T1ZtRXlVbGRVVmxaM1RVWmFXR1ZIT1ZkTlJFWjRWV3hvYTFZeVJuSlNhbEpYWVd0d1VGVnNXa2RqTVdSMFlrWmtVMVp0T0hsV2JURXdZVEExUjFwSVVsZGhNbEpXV1cxMGQyTkdWblJOVms1WVVteGFlbFl5Tld0VWJVcElWV3h3V2sxR1dYZFdWRUY0Vm0xS1JWVnNaRk5sYkZwWlZtMHdlRk14WkZoU2EyUldZa2hDY0ZWcVNtOU5iRnB4VW0xR2FFMVhVa2RVVmxaWFZUSktSbU5GT1ZkaVIxRjZWRlZhYTFaV1JuTmFSbVJPVm14Wk1WWlVTVEZWTVZwMFUydGtWR0pIYUdGWmEyUnZWREZ3VmxkdVpGZE5WMUl3V2tWa2QyRldTWGhUYWxaWFVrVmFhRlpxU2tkV01VNTFWbXhLV0ZJeWFGbFdiVEUwWkRKU2MySklSbE5pU0VKelZXMHhVMlZHV1hsbFJUbFhUVlZ3VjFrd1duTlhSbHAwVlZoa1lWSkZXbEJWYWtaclpGWktjMVJ0YUd4aVdHZzBWbXRhWVZsWFVYbFdiazVoVTBWd2FGVXdWVEZXTVZKV1ZXdGtWMDFYZEROV01qVnJWakF4Y21ORmJGZFNNMEpVVm14a1JtVldWbk5VYlVaWFlraENWVmRyV21GVk1rMTRXa2hTYVZJeWFFOVVWVlozWVVaYWNWSnRkRTlTYkd3MFdXdGFiMVpYU2toVmJHUmFZVEpTVkZZeFduTmtSVEZYVkd4V1RsWnVRWGRYYkZadllURmtSMWR1VW10U1JuQmhWRlZhZDJOc1duRlJXR2hUVm10d2VWWXllR0ZXTURCM1UyeFdWMkpVUmpaYVZXUlRWMFpLY21KSGNGTmlWa3AyVjFaU1IyUXlTWGhYYTJoT1ZrWktWVlJXV25kWFJsWjBUbFpPVmsxcmNFZFViRnBUVmpBeFIxZHJlRmROYm1oaFdsVmtSMU5XY0VkVmF6VlhWMFZHTTFadE1IZE5WbEY1VW01T1ZHSkhhRzlWYm5CelZqRnNjMkZGTld4U2JYY3lWVzAxVDJGck1YSlhhMnhWVFZad2RsbFdXa3RrUjFJMlVXeGthR0V5ZDNwV1IzaHJVbTFSZDAxV1pGaGlWM2hVVld4U1YxWXhXblJOVkZKclRXczFlbFl5TlVkV1IwVjZWV3hXVm1GclNtaFZNbmhoVTBkV1NGSnRhRmRpVmtwSVZrWmFVMVV4V1hsU2JrcFVZbGRvV0ZaclZtRmpiRlYzVjJ4a2FtSlZXa2hXUnpGelYwWkplV0ZHY0ZkTlYxRjNWMVprVTJSR1ZsbGhSMFpUWWtad1ZGZFhlRmRaVmxwelZXeGtXR0pyTlU5VVZscExWMFpzVmxacVFsaFNhMnd6V1RCU1ExbFdXbGRqU0ZwWFlrWndZVnBYZUVkamJVWklVbXhPVGsxdGFHOVdNbmhoWVRGU2RGWnVVbE5oTWxKb1ZXeFNWMkl4Y0ZobFIwWlVUVlpzTkZZeWVHdFhiRmw0VW1wV1ZrMXVVblpXVkVaclUwZEdTVkpzV2s1U01VVjNWbXBHWVZsWFRuTlhibFpoVWxSc2NGVnRkSGRYVmxweFUxaG9UbEpzY0VoVk1qVkxWREZrU0dWSFJsZGlSMUpVV2xkNFlWWldUbkphUlRscFVtNUNObGRVUW1GaE1WbDNUVWhzYUZKdGVGaFpiR2hEVVRGU1YxZHJjR3hTYmtKS1ZtMTRZV0ZIVm5OWGJIQlhWak5DU0ZWNlJtRldNV1J5V2tab2FWZEdTbEZXVnpCNFZURmtSMWR1VWs5V1ZHeHZWVzEwYzA1c1dsaGxSMFpYVm14d2Vsa3dVazlXTURGWFkwZG9WMDFIVWxoVk1HUlRVakZ3Ums1V1RsTldia0pNVm0weE5HRnJNVmRpUm1SWVYwZDRWVmxVU2xOalZsVjNZVVZPYUZKc1ducFhhMXBQVmpGS2MxWnFVbGROYWxaeVZsUkJlRmRHVm5WalJtUlRaV3RhTmxadGRHRlRNVnB6V2tac2FsSnRVbkJXTUZwTFlqRlplRmR0Um1wTlZtdzBWbTE0YzJGV1NuSk9WemxWVmpOb1RGWnRlR3RYUlRGWlkwVTFWMkpXU2xsWFYzUmhZakpGZUZOc2JGWmlSMmhoV1ZSS1VrMUdjRmRYYkhCc1ZsUkdWMWRyV210aFZrcFpVVmhrV0dKR1dtaFpla1p6VmpGa2MxcEdhRmhTTVVwb1ZtMXdUMVF3TlVkWFdHUllZa2RTY2xacVFtRlRSbGw1WlVkMGFWSXdWalJaTUZaM1ZqSktXV0ZHVWxaaGExcHlXa1ZhWVdNeVJrZFViV2hPWW0xb00xWnNZM2RsUmxWNVZHdGtXRmRIVWxsWlZFNVRZMFpTVjFkdVRrOVNiR3cxVkZaU1ExWXhXWGRqUm1oWFRXNW9kbFpxUm1GT2JGcHlaVVprYUdFelFrMVdWekI0VkRGT1YxSnVUbUZTTW5oVVdXMTBSMDVzV25STlZGSmFWbTE0V1ZaWGRHOVdWMFY0WTBkb1ZtSllhRXhXUkVaaFl6RldjMXBHYUZkaVNFSTBWbFJHVTFJeFduSk5WbVJVWW01Q1dWbFVSbUZsYkZwWVRWVjBhbUY2VmxoWGExcDNZVlpKZVdGRVNsaGlSMUV3VmxSS1RtVkdjRWxVYkdocFYwZG9XVlpHV2xka01VNVhWMWhzYTFJd1dtOVVWM1JoVjBaWmVXVklUbFppVlZZMlZWZDRjMVl5U2xsaFIyaGFUVlp3VkZsNlJtdGtSa3B6V2tVMVYwMVZiekJXYlhCTFRrWlJlVkpzYUZSaE1uaFRXV3RrTkZkR2JITlZhMXBPVW01Q1JsVXlkR3RWTURGeVZtcGFXbFpXY0haWlZWVjRZekZPZFdKR1pGZE5NRXBKVmxod1IxUXhTWGhhU0U1b1VqTkNjMWxVUm5kWFZscEhWbXhPVTAxV2JEUlpWRTVyV1ZaS1dGVnNhRlZXTTFJelZURmFZVk5IVGtkVWJHUlhZa2hDV2xac1pEQmhNV3hYVjI1T2FsSllhR0ZVVnpWdlRURldjVkpzWkd0U01IQkpXVlZrTkdGV1NuVlJiVGxYWWxoQ1NGbFVRWGhUUmtwWllrWlNXRkl5YUc5V1YzaHJWVEpPUjFaWVpGZFdSVnB3VkZaYVlVMUdhM3BqUldSWFZsUkdXRlV5ZUc5V01ERnhWbTVLV21FeGNHaFpla3BMVWxaYWMxWnNaR2xTV0VKR1ZqRmFWMkV4U1hkT1dFNVVZbXMxY0ZWdE1WTlhSbEpWVVd0MFUxWnNjREJVVldodlZrVXhXRlZzYkZaaVdGSllWbXhrUzFOR1ZuUlBWbkJYVWxSV1JWWnJXbUZaVjFKSVZHdGFZVkpzV2s5WldIQldaREZhV0UxVVFtaE5WM2hZVlRJMVMxUXhaRVpUYkdSVlZsWndhRlpGV25kVFIxWklVbTEwVTFaRldtRldNblJoVkRGU2MxZFljR2hTYmtKWVdXdGtVbVF4YkZWU2JVWllVbXMxTVZVeWN6VldNbFowWlVab1dGWnRVWGRhUkVwVFl6RmtkVk5zYUdsV1ZuQjRWMWQwYjFFeFNuTlhiR2hzVW5wc1dGUlhkSGRYUmxWNVpVaGtXRkl3Y0VoV01qVkhWbGRLUjJOSGFGcE5iazQwVm0xNFlXTXhUblJoUjJ4VFYwVktZVlp0TUhkTlYxRjRWMWhvV0dFeVVuQlZNRlozVjFac1ZWUnJUbXBpUmtwWVYydGFUMVJzV25OWGFrSmhWbGRSZDFsVldtRmtSbFp5V2taV1YySkZjRlZXYlhCTFV6RmFWMU5zVmxKaVIxSnZXVlJPUTFaV1dsVlJiVVphVmpBMU1GVnRkRzloTVVweVRsaENWbUpVVmtSVVZFWmhZekZyZWxwRk5WZGhNVmw2VmtkNGIxUXhiRmRUYmxKb1UwVmFWMWxyV2t0bGJHeHhVbXhPVjAxWFVqRldSM00xVlRKS1NHUjZSbGhXUlVweVZXcEdZV1JHVG5KaFJscG9UVzVvYUZadGVHRmtNbEp6VjI1U1RsWldjSE5WYlRGVFpVWmFTR1ZIUmxWaVJYQXhWVmR3WVZZeFNqWlNWRUpXWld0d1VGa3ljelZXTWtaSVpFWk9hVlpyY0ROV2JHTjNaREExVmsxSWFGaFhSM2h6VlcweFUxbFdXblJsUldSUFZteGFNRnBWWkRCWFJrcDBWV3RzWVZaWFRURldiVEZMWkZaR2RXTkdaRTVTYmtJMlYxaHdSMVl5VG5OYVNGSnJVbFJXV0ZsdGRFcE5SbHB6V1ROa1RsWnNSalJYYTFaclZrZEtjbU5JUmxaTlIxRXdWakZhYzFaV1NuVmFSM1JwVWpOb1dGWnRlRzlpTVdSSFYyNUtXR0p1UW1GVVZWcDNaR3hhY1ZOc1pHcGlSMUpXVlRKNGExVXlTa2xSYlRsWVZteEtTRlV5TVZkV01WSjFVMjFzVTJKRmNIZFdiWGhoWkRGYVYxcEdaR2hUUjFKWVZGWmFZVk5HV1hsbFJ6bFZZa1p3U0ZVeU1VZFdNa3BIVTJ0b1ZrMUdjR2hXTUdSWFUwZFNTR0ZHVG1oTmJtTjVWbTE0YTA1SFNYaFhiR1JZWWtkU1ZWbFVTbTloUmxwMFpVaGthRkp1UWtkWGExVTFWa1pLY21OSWNGaGhNbEo2VmxSS1MyTnNTbkZVYkdST1ZtNUNXVmRYY0VkVWJWWkhXa1pzWVZKVVZsaFdha3B2VjBaa1YxVnJkRlpOYTFwSVZqSTFUMWRIU25SVmJrWmFZVEpvUkZWcVJtdGpiRnAwWkVaYVRsSkZXbUZXVm1Rd1lqRlplRk5ZY0doU2EwcFlXVmQwZDFSR2EzbGxSVGxxVFZoQ1NGZHJaRzloUlRGWlVWaHNWMDF1VWxSVmFrWlBaRVphYzFwR1VtbFNNMmgyVmxkd1ExbFdXa2RpU0U1aFVucHNXRlp0TVZOWFJscFlaRVJDVjJGNlJsaFphMUpUVjIxRmVXRkZlRmhXYkhCTVZHMHhTMUl5UmtkWGJXeFlVakpvVGxadGNFZFpWbFY0VjFob2FWSkdjRmhaYTJSdlZrWlNWbUZGVGxSV2JWSlpXa1ZhVDFack1WZGlSRTVWVm0xb1dGbFZXa3RqYkU1ellVWndWMUpXY0ZsV1IzUmhXVmRPVjFOdVVtdFNNMUpZVkZWb1ExTldXblJOVkZKb1RXdGFXRlV5TlZkVmJVWnpWMnhvV21KSGFFUlZhMXB6VmxaS2NrNVhlRk5oZWxaaFYxWldhMUl4V2tkVGJGWlhZa2Q0V1ZacVRsTmtiRlpWVW0xMFUwMVdjREZXUnpGdlZURmFWVlpzYkZkaVZFVXdXa1JCZUZJeVRrWlhiVVpUVmpGS2RsZFdhSGRTTVdSWFYyeG9iRk5GTlZoVVZsWnpUbXhhV0UxWE9WaFNiSEI2V1RCV05GbFdTbGhWYTJoV1RWWndTRmw2Um10a1IwcEhXa1pPYVZORlNraFdiVEI0WkRGTmQwNVZaR2xTYlZKVlZqQmtiMkZHVlhkWGEzUnFWbXhhZWxaWE5VOVhSa3AwWlVoc1dsWldXbEJXUkVaaFl6Sk9SbUZHWkU1aGEwVjRWbTE0Vm1WR1pFZFdia3BwVW14d2NGWnJXbUZVVmxwMFpFZDBWRTFYVWtsVmJYUnJZVVpLZFZGdE9WVldiV2hEV2xkNFlWSXhWbkphUjNST1ZqRktTbFp0TVRCaU1WVjVVMnhzVW1KSGFHRldNR2hEVjBaU2MxZHRkR3BpUm5Bd1ZXMHhjMVJzV25Sa2VrWlhWak5vZGxscVNrZGpNVTV5V2tkd1UySlhhRmxYVjNoVFVqRlZlRlZzV2xoaWF6VllWbTEwZDJWc2EzZGFSRkpXVFd0Wk1sWnRjR0ZXTURGMVZXNUtZVkpGV21oVmFrWlBWMWRPU0dGR1RtbFhSMmhhVmpGa05HSXhSWGhXYTJSWFlrWmFWRmxZY0hOV1JsSllZM3BHVTAxV2NEQmFWVlUxWVVaS1ZWRnFUbFpOYWxZelZtcEdXbVZzUm5KVWJGWlhZa2hDVEZkc1ZtdFRNVWw0V2toT2FGSXlhSE5aYkdodlRXeGFkRTFJYUU1U01VWTBWakkxVDFkSFNuTlRiazVXVFVaVmVGWXdXbE5XTVdSMVZHczVhVkpzY0ZwWGJGWlhWREZrU0ZOc1dsaGliWGhYV1d0a2IyUnNXblJOVldScVlrZFNNVlV5TVVkVk1rcEpVV3hHV0ZkSVFreFZha1pQVTBaT2NscEhSbE5pVmtwM1YxWlNRMlF3TVhOWGJsSk9VMGRTYzFWcVJrZE9SbFY0WVVjNVYxSnRVa2xXVjNNMVZtc3hTRlZ1V2xkaGExcDZXVEo0ZDFJeFVuTmhSbVJwVjBkbk1sWXhXbGRaVmxGNFdrVmtWR0pyTlZWWmEyUTBZVVpXYzFwSE9XcGlSM2g1VjJ0V01GVXdNVmRqU0doWFlsaG9XRmxXV2t0ak1WcFpZVVprYVZkRlNrMVdXSEJIV1ZkU1IxVnVTbUZTTTBKVVdXeGFTMVpXWkZobFIzUnBUVVJHZWxZeU5VZFdSbVJJWVVaU1ZWWXpUWGhhVjNoclkyMUdSazlYYUZOaE0wRjRWbFpqTVZReFpITlhhMXBZWVdzMVdGUldXbmRqYkZwelYyczVhbFpzV25wV01uTXhZVWRXYzFkVVJsZGhNVXBJVjFaa1JtVkdaSE5oUmxKcFVqSm9lbFpYTVRSVE1XeFhZa1pXVkdKRmNISlVWbHBMWlZaWmVVMVZaR2hpUm5CNVZHeG9iMVl4V1hwaFNFcFhVbnBHUjFwVldtdFdWa1p6V2taa1UxWnVRWGxXTVdSM1VqSkZlRk5ZYUdwU1ZuQnZWVzE0ZDJJeGNGaE5WRkpZVm14d1NGWnRNVWRYYkZwVlVXcFNXbFpGTlhaV01HUkxVMFpXZFZOc1dtaGhNWEJ2VmxSS05HRXlUbk5hU0ZKclVteGFjRlZ0TVROTmJHUlhWbXhPV2xadFVraFdNalZQVjBkS1NHRkdhRlpoTVZvelZUQmFWMk5XU25KUFYzUlhZa1Z2ZDFkVVFtRlZNVnBIVTJ4YWFsSnVRbGhaVkVaM1kyeHdSVkpyY0d4U2JFcDVWMnRrYzFVeVNsaGhTR2hYVW14S1RGbHFSbXRTTVZaellVZHdiR0V4Y0ZaWFYzUnJUa1paZUZkWWJFNVdSVXBZVkZWU1IxSnNWbGhqUm1SWVlrWndXVlpHVWtkV01ERkhZMGRvV21WclduSmFSbHBQWXpGa2RHSkdaRk5XYmtKaFZtMTRVMUV4YkZkV1dHeFZZbXhLVkZsVVNsTlZNV3h5V2taT2FsSnNjSGhWTWpBMVZHMUtSMk5JYkZkTmFrWklXVlpWZUZac1duRldiRnBPVmpKb01sWnFRbXRUTWsxNFZHNVdVMkpHY0hCVmFrcHZWbFphZEdORlpGWk5WbXcwVmpKNFYxVXlTa2RUYkZKYVlUSlJlbFJXV21GVFIxWkhXa1UxVTJKV1NqWldha2t4VXpKR2MxUnJiRkppUjJoV1ZtcE9RMWRHVm5KWGJVWnJVbFJHVjFkclpIZGhWa2w0VTJwV1dHSkdXbWhaVkVwSFZqRk9kVlpzU21sV1IzaFpWbTF3VDFFeFRrZFhia1pVWVhwc2NsVnRlR0ZsVm14V1draE9WazFFUmpGWlZWcHpWMFpaZWxWdVdsWldNMDQwV1hwR2EyUldWblJqUms1WVVsVndVVlp0TUhoT1JsbDNUbFprVjFkSGVISlZhazVUVjBaV2RFMVdUbFJpUmxwWldsVmtNRmRIU2xaalJuQlhWak5DVUZacVNrdFhWMFpJWVVkR1UxWXhTbGxXVkVKaFV6Sk5lVkpyWkZWaVYzaFVWakJXUm1WV1duUk5XR1JVWWxaYVNGVXhhRzlYUm1SSVZXczVWMDFHV2pOV01WcHpWbFpPY1ZWc1pHbFNhM0JaVm1wSk1XRXhVbkpOVm1ScVUwZG9WMVJYTlZOamJGcEZVMnQwVTAxck5VcFphMXAzVmpGYWRWRnViRmRpUmtwRFdrUktWMWRHU25KV2JGSnBVakZLV1ZkWGRGZGtNVTVYVjFob1dHSllVbGRVVmxaelRrWmFXRTVXWkZkV01IQlpXbFZhVTFaV1dqWlNibHBYWWtad2FGWXdaRmRTTVZKeldrVTFWMDFWY0ZwV2Frb3dXVmRGZUdKR1pGUmhNWEJWV1d4V1lWZEdiRmhrUjBab1VtNUNXVnBWYUU5V01WcHpVMnBHVjFKNlJucFdWRXBHWlZkUmVtTkdaR2hoTWpoM1YxZHdSMWR0VmxkVWJrNXBVbXh3YjFsWWNGZGlNVnAwWTBVNWFVMXNXbnBXTWpWVFlrWkplbFZ1UmxwWFNFSjZWakZhYzFac1pIUmtSMmhUVmtWSmVsWlVTWGhpTVZsNVUydGthbE5GY0ZaWlZFcFRWREZ3VmxkdGRGaFdNSEJJVmxjeGMxVXdNSGxoUkVwWFlrWktSRlpxU2xKbFJtUjFWR3hvYVdGNlZtOVdWekY2VFZaYVIxVnNaR2hTVlRWWVZGWmFjMDVXVW5OYVJFSlhZWHBHZVZrd1ZuZFdiRmw2Vlc1YVYwMXVhR2hXTUZwWFpGZE9SMk5HWkZkTlZYQmFWakZvZDFJeVJYbFViR1JYWW1zMWFGVnFTalJXUmxKV1ZXeE9UMkpHYkRWYVZWcHJZVVV4Vms1VVFsZGlXRkoyVm10a1JtVldWblJoUmxwcFZrVmFNbGRVUW1Gak1XUllWR3RrWVZJeWVFOVdiVFZEVjJ4YVIxZHNUbEpOYTFZelZGWm9TMVF4WkVsUmJHaFhZV3MxZGxreWVGcGtNWEJHWkVkd2FHVnNXbGhXUkVaaFZqRlplVk5yYkZKaGJIQllWV3BPYjJGR2NFVlNhM1JxVFZad01WVXllRmRoVmxsNVlVWldWMUpzV21oWk1qRlhWakZrYzJGRk5WTlNWbkI0VmtaYVlXUXhaRmRXV0d4clVqTlNXVlZxUW5kWFZteFdWMjA1V0dKVmNFbFpWV2hoVjBaYWMyTkVUbGROUmxZMFZtMTRkMUl4Vm5OYVIyaHNZa1pyZVZadGNFdE5SMFY1VTFoc1UyRXhjRTlXYkdSVFkwWldjbGR1WkZoU2JFcFpWR3hqTldGR1NuUmxSbHBXWWxoU00xbHJXa3RqYXpWWFkwWndWMVp1UWxWWFZscHJVakExYzFkdVVsQldiVkpZVkZSS2IxWldXblJqUldSb1RWVnNOVlV5ZEhOV2JVcFpWV3hTVjAxR2NFeGFWbHByVjBkU1NGSnRkRTVpUm5CSlZtMHdNVlV4VW5OWGJHaFdZbFJzVjFscldrdFRSbGwzVjJ4YWJGWXdOVWRXUjNoclZHMUZlbEZ0UmxoV2JGcDJWWHBHV21WV1RuTldiRTVvVFRKb2FGWkdaSGRTTVZaSFZsaGtWMVpHV2xoVVZtUlRUVVpzVmxwSE9WVmhla1pIV1d0U1YxWXlTbFZSYWxKVlZsWndlbFl3V2xOWFYwcEhWMjFvVG1KWGFGbFdNVnBUVWpKUmVWUnVUbGRpYkVwelZUQmtVMWRHVm5STlZGSnNZa1pzTlZwRlVrTlhSa2wzWTBWb1drMUdXblpXYWtwTFZsWkdWVkpzY0ZkaVJsa3dWMVJLTkdFeVRYbFRhMlJZWVhwV2NGbHNaRzlPVmxwMFkwVk9hRTFWTVRWV1YzaHJWVEpLY2s1WE9WWmlXR2hvVmpCYWQxZEhWa2hTYXpWcFVqRktOVll5ZEZOVk1rWnlUVlpvVm1FeWVGaFpiR2hUWVVac1ZWSnJkR3RTTUZwSVZsZDRkMkZGTVZsUldHeFlZa1phYUZkV1dtRldNVkoxVW14YWFWSXhTbEJXYlRCNFRUQXhWMWRzVmxSaGEwcHZWRlphYzA1V1ZuUk9WVGxYVWpCd1NWbFZXbTlYYkZwR1YyMW9XbFpXY0hwV2JYaHJaRVpLZEdSR1RsZFNWbkJhVm1wS01GbFhTWGhXV0d4VVlUSlNjVlZyV21GWFZscDBaVWRHYUZKc1dsWlZiWGgzWVRBeFJWSnNjRmRXZWtaMlZsUktTMWRYUmtkalJtUnBWa1ZWZDFaWWNFZFdNVWw0VjI1T1YySkZjRmhWYkZwM1YxWmFSMWR0ZEZaTmJGcFlXV3RhWVZsV1NrZFRiR1JWVmxaS1NGVXdXbkprTWtaSVQxWmtUbFpZUWpaWFZFSnJZakZzVjFOcldsTmhiRXBYV1ZkMFlXRkdXWGhhUlhSVVVqRktTRlpIY3pGVWJGcFpVVzFvVjJKWWFISmFSRVpHWlZaV1dWcEZOVmRXTVVwNFZsY3hOR1F5UmtkV2JsWnFVMFUxV1ZWdGVFdFhWbkJHWVVkMFdGSXdjRWxhVlZwclZqRlplbFJVUmxkTlIxSk1WV3BLVDFJeVJrZGpSVFZUWVROQ1VsWnRNSGRsUmsxNFdrWm9VMkV5YUc5VmJURlRWREZhY1ZKcmRGUldiSEJaV1RCV2EyRXdNVlppUkZKYVRVWmFkbGxXV2t0amF6VlpVV3h3VjFKVmNGbFdSM2hoV1ZkU1JrMVZiR2hTTTFKUFZteFNSazFXV25STlJFWlVUVlpLZWxZeU5WTldiVXBJWlVab1ZWWlhVbFJhUjNoYVpVWmtkVlJ0ZEZOTlJGRjVWbGN3ZUdNeFVuTlhia3BxVW0xU1dGWnJWbk5OTVZKelYyMTBVMDFWTlRGV1Z6RTBWa1pKZW1GR2NGaFdiRXBJV2tSR1UxSXhaSEpoUjNoVFYwWktlVlpYY0VkWlZrNXpZa1phV0dKVldsWlpiRlozWld4VmVHRklaRmhTYkd3MlZsY3hiMVp0Vm5KalJsSldZV3RhYUZwR1dsTmtSMDVIVkcxc2FFMUlRbUZXYlRCNFpERkplRlJZYUZWaVIxSlpXVzF6TVZZeGJGVlRiRTVZVm0xNGVsWXlNVWRYUmxwelYycENZVkpYYUZCWlZXUkxVbTFPUlZGc1pGZE5NbWd5VmpGYVlWZHRWbk5XYms1aFVqQmFWRlZzV25kbFZtUlZVMnBTVjAxck5YcFpNRlp2WVd4S1ZWWnNhRnBpUjJoeFdrUkdZV05XVG5GUmJXeE9WbTEzTUZacVNqQmlNVnBJVWxoc2FGSnRVbUZaYkdoVFZFWmtWMWR1VG1waVIxSXhWMnRhVjFVeVNraGtla0pYWVd0c05GVnFSbXRTTVU1elZteE9hVkp1UWxsV2JUVjNVakF3ZUZkcmFHeFNXRkpVV1d0Vk1WWnNWbGhsUjNSb1VqQldORmt3VWt0WFJtUkpVV3RvVjFaNlJsaFZha1ozVTFaU2MxcEhiRmROTW1oV1ZqSjRhbVZGTlVkWFdHaFlZbXhLVDFacldrdFpWbHB4VW0xR2JHSkdjRmxVYkZZd1YwWkpkMk5GYUZwTlIyaFFWbXBLUjJOc1pISmxSbHBPWW0xb2IxWlVRbXRXTVU1SVZXdG9hRkp0VW5CVk1GWkxZVVphYzFkdGNHeFNhMncwVjJ0V2ExZEhTbkpPVm14YVlsaFNNMWRXV25OWFIxSklVbXh3VjJKclNsaFdha3A2VGxaa1IxZFlaRTlXVjNoaFZteGFkMVZHV2tobFJYUnJWbXRhTVZZeWVHdGhWbHBHVjFod1YyRXhTa3hWTWpGU1pEQXhWMkpHVm1sWFJVcFZWMWQ0YTJJeVZuTlhiRlpTWWxoU1YxUldXbmRUUmxwWVpVZDBhRkpyY0ZkVWJGcFhWbTFLV1dGRVRsWk5WbkJVVm1wS1IxSnJPVmRhUlRWWFYwVkpNVll4VWtOWlYwVjRXa2hLVGxaWFVsVlpWRTV2VjBac1dHUklaRlZTYkhCNlZqSjBNRmRHV25WUmEyaFlZVEZ3Y2xaVVJtRmtWa1p5VFZaa1RtSnRhRzlXTVZwaFZHMVdSMk5GWkdoU2F6VnZWRmQ0UzFkR1pGaGtSM1JwVFZad1NGWlhlRzlVYkZvMllrWnNWbUpZYUhwVWExcHJWbFpTZEU5V1ZrNVdXRUYzVjJ4V1lXSXhXWGROV0VaWFlrVktZVlp0ZUhkVlJsWjBUVlU1VTAxcmNFaFpNRnByVlRGYVIxZHNXbGROVmtwSVYxWmFXbVZXVm5KaFJtUm9UVzFvVlZkWGVHOWlNVnBIWWtoS1dHSklRazlXYlhoM1UwWmFkR1ZGT1ZkTlJFWlpWbGQwYjFack1YRldiRUphVmpOb1VGVXhXa2RrUmtwelZteGtWMkpyU25aV01uUnJUa1prZEZWWWFHcFNWbkJaV1d4b2IxZEdVbFpYYm1SVVRWWndWbFV5Y0ZOaFJURnlWMnRzVm1KSGFISldNRnBoVW14T2MyRkdjR2xTTW1oRlZsUkNZV014V2xkVWJrcFFWak5TVkZsVVRrTk9WbGw1WkVkMFUwMVdWalJXTW5SclYwZEtkRlZzYkZkaGF6VlVWakJhZDFKV1NuUmtSM0JPVmpGSmVGWnNZM2hPUmxWNVVtcGFWMkpHY0ZoVmJYaDNWakZ3VmxaVVJsTk5WMUphV1d0Vk5WWXhXa2hsUjJoWFlsUkdObFJXV2s5U01XUlpZa2Q0VTJKV1NscFhWM2hYVmpBMVYxZHNhR3hTYXpWWldWaHdSMU5HYTNkYVJXUmFWbXR3UjFZeU5VdFhhekZ4VW14U1ZrMUhVa3hWYlhNeFZqRndSazVXWkZkbGJXY3hWbTB3ZDJWSFVYaFVibEpYWVRKU1ZWWXdaRFJXUm14VlVtNWtWVTFXYkROV2JUVnJWbXhLYzJKRVRscFdWbHBRVmpCYVlXUkhWa2RYYkZwT1lXdEZlRlpxUW1GVE1sSkhWbTVPYUZKdFVrOVpiWGhIVFRGa1YxVnJaRlJOYXpFMFYydG9WMkZXU25OWGF6bFhZbFJXUkZwV1dtdFdNV1IwVW14d1YyRXpRalpXYWtreFVqRmtTRk5yYUZaaVJrcGhXVlJHZDAweGJIRlNiSEJzVW0xU01GVnRNVzlVYkZwWlVXcFdWMUpzY0doWlZFcEhWakZPV1ZwR2FHbFNhM0JvVjFaU1IyUXdNSGhYYkZwWVlsVmFjbFZzVWtkVGJHeFdWbFJHVldKRmNFZFdNbmh6VmpKR2NtSjZRbGRoYTFwb1ZUQmFTMlJXVW5OVmJXeG9UVmhDV0ZadE1IaE9SMUY1VW10a1ZtSkdjRmxaYTJSVFkxWlNXR1JIUmxSV2JrSkhWako0YTFaWFNrZGpSRUpoVTBoQ1NGWXdXbUZqTVdSMFlVWndhR0V4Y0hsWGExWmhVekZrV0ZKcmFHcFNhelZVVm10YVlWZEdXblJOVkVKWFRWZDRXVlZ0ZEd0V01rcHpVMjVPVm1Gck5WUlpNbmhYWkVkU1NWcEZOVk5pV0ZGNlZtcEplRTFIUmtkVGJGWlNZV3MxVjFSV1drdFRSbHB4VTJ0YWJGSnJOWGxaVlZwM1ZqRktWbGRVUWxkV00wSklXVlJHYTFkR1RuSmFSbFpwVmpKb2QxWlVRbGRUTVdSelYxaG9XR0pZVWxCVmFrWkhUa1prY2xkdGRGaFNNSEI2VlRJMVQxWnRSbkpUYldoYVRWWndlbGt5ZUhkU1ZsSnlUbGRzVTJKSE9UTldNbmhYWVRGSmVWSnNaRlJpYXpWeFZUQmtORlpzYkhKWGEzUlVVbXh3TUZsNlRtOWhNVmwzVjJ0b1YxWXphRE5XYWtaYVpVWk9jbUpHWkZObGExVjNWakZhYTFSdFZsZFVia3BoVWpKb1ZGbHNXa3RWUmxwSFdUTm9hVTFXY0hwV01qVlBWMnN3ZVZWdVRsWmlXR2hvVkZWYVlXUkhVa2hrUjJocFVsaENXbFpzWTNoaU1WcDBVMnhXVTJKc2NHRlVWVnAzWld4WmVGcEZPVk5OV0VKSVdWVmFhMkZXV25KalJuQlhUVlp3V0ZscVNrWmxSbHBaV2tVMVYySlhhRmhYVnpBeFVURmtSMVZzYUU5V2F6VnlXV3RrTkdWV1dYbGtSRUpWVFd0d1Yxa3dWbk5XVlRGWFkwaEtXbFpYVWtkYVJFcEtaVzFPUjFwR1pFNU5SWEJLVmpGU1NtVkdWblJXYTJScVVsZDRWVmxyV21GalJsWnhVbXQwVmxKc2NEQlVWVkpIVldzeFZrNVZhRmROYm1oWVZtdGFZVkpzWkhOV2JGWlhZbFpLVlZaR1ZtRldNbEpHVGxaYWExSnRhRlJVVldoRFYyeGtWMVp0Um1sTlYxSjZWakZvZDFadFNsaGhSbWhWVmxad00xcFhlRk5rUjFaR1pFZDBWMkpyU2tsV2JHUTBWREpHUmsxSVpGUldSWEJZV1d4b1UyTldjRlphUlhCc1ZtczFlVmxWV2xOaFJURnpVMjVvVjFZelFreFpha1pyVWpKS1NWUnRhRk5sYlhoNFZtMHdNVkV4V1hoWGJrNVdZVEpTV0ZWdGRIZGxiRmw1WlVoa1dGSXdWalJXYkdodlZqSkdjbGR0Um1GV1ZuQlFXWHBLUjFJeVJrZGFSM2hvVFZkME5WWnRkR0ZaVm14WVVsaG9XRmRIZUZWWlZFbzBWbXhzYzFwSE9WZFNiWGhhV1RCYWExZEhTa2RqUkVKVlZteEtWRll5ZUdGV1ZrcHlZVVp3VGxKc2NHOVhWbFpoVXpGYVdGTnJaRmhpU0VKWlZUQldTMU5XV25GU2JVWnJUVlZ3ZWxadE5VdFZSbHAwVldzNVdsWkZOVVJXYWtaaFpFVXhWVlZzU2s1V2JYY3hWbGN3TVZNeFZYbFNiazVVWWtkb1lWWnFUbE5OTVZwR1YyeE9hMUl4V2tkVU1XUjNWR3haZUZOcVdsZE5ibEp5V1hwR1ZtVkdjRVpYYkZKb1RURktXVmRYZUZOUk1EVkhZMFZXVTJFeVVuSlZiWGgzWlZac1ZsZHRSbWhXYTJ3MVdWVmFWMWRHV25OVGEzaGFZV3R3UzFwVldtRmtWbFowWlVaU1UwMVZjRFJXYkdONFRrZE5kMDFJYUdGVFJYQmhXbGQ0WVdOR1ZuUmxTR1JPVW14d1dWcFZaRWRXTWtwV1kwWmFWbUpZVW5aV2FrcExWMVpTY1ZWc2NFNWlhelF3Vm0xNFlWbFhUWGhqUldSVllYcFdUMVpzWXpWT1ZscHhVbTFHVjAxWGVGaFdSelZUVmpKS1NHRkdVbHBXUlZvelZsWmFZV1JGTVZkVWJGWk9WbXh2ZDFkc1ZtOWhNVnBYVjI1T2FsSlhhRmxaVkVaTFZrWlplV1ZHY0d4U2F6VjVWMnRhVjFZeVNrbFJhbHBYVFZad2FGVjZTazlrUmxKeVYyeENWMkpXU25kV2JYUmhXVlpLUjFwSVNsWmhNbEpoVm1wR1MxSXhVbGRYYkdSV1lsVndXVmxWVlRWV01rWnlWMnQ0VmsxdWFHaFdiRnBQWTFaR2RHSkZOVmRpYTBZelZteFNTMDFIU1hsU2EyUlVWMGRTV1Zsc1ZtRlpWbXhWVTJ4T2EySklRa2xhVldSSFZUSktTRlZxUmxkU2VrWXpWbXBLUm1Wc1JuRlhiR1JPWW14S2VWZHJVa2RWTWsxNFdraFdWV0pZUWxSVmJUVkRWMVphUjFsNlJsWk5helY2V1d0U1lWVXlTa1pPV0VaVlZtMW9SRlZxUmxwbFYxWkhWRzFvVjJGNlZraFdWRW8wWkRGa1IxZFljRlppVjJoWlZtMHhVMU5HVm5GVGEzUlRUVlp3ZWxaSE1YTlZNVnBIVjJwU1YwMVdjSFphUkVaS1pVWndSbHBIUmxSU1dFSnZWbFJDYTFVeFdYaFZiR1JYWW0xU1dGUldaREJOTVZsNVRWUkNWMDFFUm5sWk1GcDNWMnhhV0dGRmVGZE5ha1pJV1RJeFQxSXhWbk5qUjNob1RWaENOVll4VWtwbFJrbDRWR3RvVjJFeVVsWlphMlJ2VmtaYWMyRkZTazVXYkhBd1drVmtSMWRzV25SbFJteFhWbTFvZWxacVNrWmxWbFp6WWtad2FFMXNTakpYV0hCSFZtMVJlR05GWkZWaVYzaFBWbTE0ZDA1c1duTmFSRUpvVFZkU1NWVXlkR3RYUjBwSVpVWmFXbUV5VW5aV1ZWcGhZMVpHV1dGSGNHbFdWRlpKVjFSQ1lXRXhXWGxXYmtwWVlXdHdXRmxYZEhaTlJtUlhWMnQwYWsxWVFrcFdSM2hMWVZaS2RWRnNRbGRXZWtGNFZWUktTbVZHY0VkV2JGSllVakpvVlZaR1dsZGpNRFZIVm01U1QxWlViR0ZXYlhSelRsWndWbGRzWkZkaVZYQklWakp3UzFsV1dYcGhSMmhhVFZad1RGcEZaRTlUUjFaSFZHeGtVMVp1UWt0V2JURXdXVmRKZVZKWWFGWlhSMmhvVld4YWQxVkdXblJOVkZKYVZtMTRlbGxWWXpWV1ZrcHpZMFZhVm1KVVJraFpWekZMVTBaV2RXSkhSbE5XYmtGNlZtMXdTMU14VGxkU2JrWldZa2RTV0ZscmFFTldWbHBZWTBWMFZFMVZOVWhXUnpWTFdWWkplV1ZHVWxaaVdHZ3pWbXBHYTFkSFVraFNiR2hwVm10Wk1GZFhkR0ZaVmxsNFdrVm9hRkp0YUdGWmExcFdaVVpWZVdWSVNtdE5WMUl3V2tWYVYyRldXbGxSV0dSWVZteGFhRlpxUmxwbFZrcDFVMjFzVTFKcmNGaFhWM2hUVWpGa1IxZFlaRmhoTTFKeFdXdGtVMlZzV1hsTldFNVdUVVJHVjFrd1drZFdNREZZVkdwT1lWWlhVa3RhVmxwaFl6RndTRkpzVG1sWFIyZzBWbXhrTkdFeFZYaGlSbVJZWW10YVZGbFVUbE5XVmxwMFpVaGtXRlp1UWtkWGExSkRWakF4VjJKRVRsZE5Wa3BNVm1wS1MxWldSbFZTYkdScFVtNUNiMWRyVm10U01VcHpWVzVPVjJKSFVuQlZNRlpMWkd4WmVGVnJkRTlTTUZZMVZsZDBhMVpIU25KT1dFWldZbFJHVkZaRVJsZGpiRnB6VjIxMFRsWnVRWGRXUmxadllURlNjMWR1VGxkaGJFcFlXV3RrYjJSc1pGZFhhM1JZVWpCYVNWUXhXbUZVYkVwelkwYzVWMkpZUWtoWmVrcE9aVVphZFZOdFJsTk5NVXAzVmxjd2VFMHlWbk5YYmtaVVZrVmFWbFJXWkZOVFJsVjRZVWQwVlUxVmNFZFpNRnByVjIxS1IxTnJaR0ZTUlZwNlZtcEdhMk50VWtoalIyeFhWa1phU2xacVNqQlpWMFY0VjFoc1YySnJjRlZXYTFaTFYwWmFjVlJyVGxWU2JGcDRWVEp6TVdKR1NuVlJhM0JYWWxob1ZGbFdXa3BsVjBaSldrWmtWMUpWY0ZsV1dIQkxVakZKZUZwSVZsWmlXR2hVVkZWYWQyVldXa2RYYlVaYVZtczFTRll4YUhOaE1VbzJZa2hDVm1KWVVqTlVWbHBYVjBVMVZrOVdaR2xXV0VKaFZtdGFiMkl4YkZkWFdIQm9VMFZ3WVZSWE5XOWpiSEJHV2taT1UwMVlRa2RVYkdSelZUSktjbEpZYUZkaVZFSTBWR3RrU21WV1NsbGhSMFpUVmpGS1dsZFhNWHBOVmxwWFlrWldWV0pVYkZoVVZtUTBWMVp3UmxwRlpGZFdhM0F3V2tWU1YxZHRWbkpPV0ZwWFlXdEdORll4V2tkamJVcEhZMGRvVGxkRlNsSldNVnBYVm0xUmVWVllhRlZpYTFwVldXdGtVMVF4V25ST1ZVNVhWbXh3ZVZaWGRHdFZNa3BYVjJ0b1drMUdXbnBXYkdSTFUwZEdTVkZzY0doTlZtOTZWMnhXWVZsV1pFaFdhMlJWWWxoQ1QxWnRlRnBOUmxweldrUlNhRTFYVWtsVmJHaDNWbTFLUjFkc1pGcGlSMmgyVkZSR1UxWnNaSE5VYlhCT1ZtNUJkMWRyVm1GaE1WSnpWMnhvYTAwelFsaFpWM1JoVmtaV05sSnNjR3hXYXpWNlZtMTRhMkZXU2xaalJteFlWak5vVkZWcVJsTlNNV1JaWVVkR1UxWXhTbFZYVjNoaFdWWk9SMWR1VW14U00xSnZWbTF6TVZJeFZYbE9WMFpYVFd0d1NGVXlkRk5XTWtwVlVteG9WbUZyV2pOVmJYaHJZekZHYzFwSGJGZGhNMEpvVm1wR1lXSXlVWGhYV0doWVlUSlNXRmx0Y3pGWFZteDBZM3BHVlUxV1NsaFdNalZQVkRGS2MySkVWbUZXVjFGM1ZqQmtTMUl5VGtWUmJVWlhWbTVDTWxadGNFSmxSbVJJVW10c1dHSkhVazlWYlRWRFpWWmFWVkp0UmxOTmJFcEhWREZhYTFkSFNsaGxSbWhXWWtad01scFdXbHBsUm1SeldrWndWMkpIZHpGV2EyTXhWREZrU0ZOdVRsUmlSa3BoV1d0a2IxSkdhM2RYYkdSclVqRmFTbGRyVlRWVk1rcEpVV3h3VjFKc1dsUlZha3BIVW1zeFYxcEdaR2hoZWxaWFZtMHdlR0l4VWtkWFdHUmhVbFp3YzFacVJtRlRWbXhXVjIxMGFGWnJjREZWVm1oM1ZqSktSMWR0YUZwbGExcG9XWHBLVDFKc2NFaFNiRTVPVFVWd1VWWnRNWGRTTVUxM1RsaE9XR0pyV2xWWlYzaExZakZTV0dSSFJsTk5Wa3BZVmpJMVQxWnRTbFpqUkVKaFZsWndkbFp0TVVkamF6VlhWV3h3VjFadVFtOVdWRUpXWlVaWmVHTkZaR0ZTVkZaWVZGWldjMDVHV25STlNHaFBVbXhzTlZWdGVHdFdSbVJJWlVjNVZtSlVWa1JXTUZwaFkxWlNjbFJzV2xOaVdHZzBWbGN4TkdFeFdYZE5WbWhXWVd0YVdGWnVjRVpOUmxwVlUyeGthMUl4V2toWlZWcHJWVEpLU1ZGdWJGZGlSa3BJV1ZSR1NtVkdjRWxXYkZwb1pXMTRXVlp0Y0VkVE1XUkhXa1pvYkZKdFVuSlVWVkpIVTBaWmVXVkhPV2xTYTI4eVdXdGFiMVl5U2xsaFJFNWhWak5vZVZwRVNrZFRWbkJIV2taa1RsTkZTa3BXTVZKRFdWWlZlRnBJVWxkaWEzQlpXV3hrYjJGR1ZuTmFSazVYVW14YWVGVnROV3RWTWtZMlZteG9XR0V5VW5wWlZWVjRVMGRTUlZac1pHbFhSVXBKVjFaU1FtVkdTWGhYYkd4b1VqSjRWRmxzV2t0WGJGcHhVVzEwYVUxWFVsaFphMXB2WWtaT1NGVnNhRlppVkVVd1ZGVmFkMVp0Umtoa1JtaFRZVE5CZDFkc1ZtOWtNVmw0VjFod1ZtSnJjRmhaVkVaM1ZFWndSbHBHVGxOV2JIQXdWVzE0YTFZd01WWlhXSEJYVFZad1ZGVnFSazlrUmxaWllVZEdWRkpZUW5aV1Z6QjRWVEZSZUdKSVVtcE5NbWhRVlcxNGQyVnNXbGhrUlhScFVtdHdlbGt3VWtOV01VbDZWVzVLV2xZemFFeGFSVnBYWkZaR2MxZHRhR2hOV0VKTlZqSjRhMDVHYkZkYVJXaFZZVEZ3YUZWdE1WTmpSbHAwWlVoa1dGWnNjSHBYYTFKVFlXc3hjbGRyYUZaTmFsWlVXVlZhVDFKc1RuUlNiSEJYVWxad2IxWkdVa2RrTVVwWFUyNVNVMkpIYUZSV2ExWmhXVlprVlZGc1drNVdiR3d6VkZaV1YxWXlSWGxsUm14WFlXczFWRmxWV21GalZrcHpXa2QwVTJGNlZqVlhWM1JoVXpKR1NGWnVVbXhTYldoWlZtcE9iMlJzYkhGUldHUnNVbXhhZWxZeWVHOWhWMHBYVTJ4c1dGWXpVblpWVkVaS1pVWndTVk5zYUdsV1IzaDJWbTB4TUdRd01VZGpSVlpWWW0xU1dWVnRlSE5PYkZwWVpVWk9WMDFyV25sV01qRnZXVlpLVjJOR1FscE5ha1pJVlRCa1IxSXhWbk5VYld4b1RVaENhRlp0TVRCWlZsbDRZa1pvVmxkSGVGWlpiWE14VjBaWmQxcEdUbWhTYkZwNlYydGFUMVl4U25OVGJHaFhUV3BXY2xsclpFdFRSMUpGVkd4b2FFMXRhRkZXYWtKaFV6Sk9kRlJyWkZoaVJuQndWVzEwZDFKV1duUmpSVXBzVW14c05GWkhOVXRoUmtwMFlVWm9XbUV5YUVSWlZWcHJZekZrZEZKc1pFNWhlbFYzVmxjeE1HRXhiRmRUV0d4b1VsUnNXRlJWV21GVVJsSnpWMjFHYWsxWGREWlhhMlEwVlRKS1IxZFVRbGRpUm5CMldXcEdhMU5HVG5WVWJGSnBVbFZ3V1ZkWGRHRldiVlpIVjJ4YVdHSlZXbkpWYWtaaFUyeGtjbFpVUmxaTmEzQkhXVEJhYjFkR1duTlhia1pWWWtad2FGa3ljM2hXYkZwelZHMXNhVmRIYUZwV2ExcHFUVlpWZVZWdVRsaGliRXB4VkZSS2IyTldXblJsU0dSc1lrWndXVnBWYUd0V01ERldZMFpvV2sxR1ZqUldha1phWld4R2NtRkdjRmRTV0VKVlZsZHdSMVF5VWxkV2JrNVZZbGQ0VkZSV1ZuZFZWbHB5VjJ4a1ZrMVZjSGxVVmxaclYwWmtTR1ZJU2xaaGF6VlVWbFZhVjJSRk1WVlZiR2hYWWtoQ1NsZHNWbXROUmxweVRWaEthbEpYZUdoV2JHUk9UVlphZEUxVmRGZFdhM0F4VmpKNGEyRkZNVmxSYWxwWVZrVnZNRmxVU2xOV01YQkpWVzE0VTJGNlZuZFdiVEV3WkRGc1YxZFliR3RTYlZKdlZGWldjMDVHV1hoaFIzUlZZa2RTUjFrd1duTlhiVVY1Vlc1YVYyRnJXbFJXTUdSUFVqRndSMkZHVG1sVFJVcGhWbXRhWVZZd01VaFNXR2hVVjBkb1dWbFVTbTlaVmxwelYyNWtUazFYZUZkV2JHaHZWMFphY2xkdWJGVldiSEJ5V1ZWVmVGWXlUa2hQVm1ScFYwVktUVlpzVWtkVE1rNXlUVlprWVZJd1dsUlVWVnAzVmxaYVIxVnJUbFJOVmxwSVZqSTFVMkpHU2paaVJrNWFZa1p3YUZVd1dscGxWVFZXWkVab2FHVnJTVEZYVmxadlV6RmFWMWR1VG1wU2JXaFdXV3RhZDFZeGNGZGFSbVJVVWpGS1NGZHJXazlVYkU1R1UydHNWMkpHU2t4VWEyUktaVVp3U1ZWc1VtaE5iV2gyVmxkNFlWTXhXWGhWYkZwWVltMVNXVlZ0TVRCT1JsbDVaRWQwV0ZKc2NERlZWM1J6V1ZaYVYyTkdRbHBXYlZKSFdrUktUMUp0VGtkYVIyaG9UV3ByZWxacVJtRlpWMDE0V2tWa1ZHSnJjRmxaV0hCWFZsWldjVk50T1ZkaVIxSlpXa1ZrUjJFd01WaFZiR2hYVFdwV1NGWnNaRXRXVjBwSVQxWmFhVlpGV2xWV2FrSmhWMjFXVmsxV1ZsSmlSbkJQVld0V1lWZHNXbk5hU0dSVFRWWnNORll4YUhkV1ZscEdWMnhvV2xZelVqTldSVnBoWTFaS2NrOVhjRTVoTTBKSlZqSjBhMk14WkVkVGJGcHFVbFp3V0ZSWE5WTldSbFp4VW14S2JGSnRVbHBaYTFwVFlVVXhjMU5zY0ZoV00xSnlXV3BLVDFJeVNrZGlSM0JUWWxaS1dsWnRNSGhWTVdSWFkwWmFXR0pZVWxsWmExcHpUa1paZVdWSE9WZE5SRVpaV1ZWb2QxZHNXa1pYYTNoV1lXdGFVRmw2U2tkU01WcHpXa1prYUUwd1NrdFdiWFJoV1Zac1dGUllhRmhpYkVwVVdWUkdkMk5zVm5STlZrNVZUVlphZVZadE1VZFdSMHBIWTBod1dHRXhTbFJaVmxWNFZqSk9TV0pHVmxkaVJuQjVWbTF3UjFsV1NuTmFTRTVvVW01Q1dGUlVSa3RpTVdSVlUycFNhbUpXV2xsV1IzQmhWVEpLU0ZWck9WZE5SbHBNVlRKNGExZEhVa2hrUjJ4T1ZtdHdObFpyWkRCWlZscElVMnhXYVZKdGFHRlphMXBMVWtaU1ZWSnVaRk5XYXpWNlZUSXhORll5U2tkalIwWlhUVzVTVjFSV1dscGxWazV6V2taU2FWSnVRbGxYVm1Rd1V6Sk9jMkpJUmxOaVdGSlVWRmQwZDFOc1dsaE5WRkpXVFZkU1NGVXllSE5XTWtwVlVXcFNWV0V5VWxoV2FrWnJWMWRLUms5V1pFNU5WWEJoVm14amVFNUhVWGROVldScVVteHdiMVV3VlRGWFJsSldWV3RrYkZKc1dqQmFSV00xVmpBeFJWSnJhRnBOUmxrd1YxWmFTMWRHVm5OaFJscE9WakZLVVZaWGNFZGtNVWw0WTBWYVQxWlVWbGhXTUZaS1pWWmFkRTFJYUU1U01GWXpWR3hXYTFaV1pFaGxSbHBYVFVkUk1GWnRlSE5XVms1eFZXMXNUbFpzYjNkWGJGWnZZVEpHYzFOdVRtbFNSVFZaV1ZSS1RtVkdiSEphUlhSVVVteGFlbGxyWkVkVk1WbDRVMnRzVjJGcmJ6QlhWbVJPWlZaU2NscEhhRk5pU0VKUVYxWmtORmxXVmxkWFdHaFlZbFZhVlZSWGVFdFRWbFowWkVjNVZsSnNjSHBXTW5odlYyMUtTRlZ1V2xaaVJuQnlXWHBHYTJSR1NuTmpSbVJPVmxoQ1MxWnRkR3ROUm14WFYydG9WR0pIZUc5VmJYaExXVlpaZDJGRlRsaFNiR3cwVmpJeFIxZEdTbFZTYTFwV1lsaG9WRlpITVVabFIwNUdZa1prVjFKWGREUldiRkpMVWpGSmVGUnVWbFppVjJoVVdXeGFTMkZHWkZkVmEyUnJUV3RhU0ZaWGVGZFZNa3BXVjI1R1ZWWnRVbFJVVlZwWFpFZFdTRTlXV2s1U1JWcEhWbTB4TUdJeFdYZE5XRlpXWWxkb2FGVnJWbUZaVm5CRlVWaG9WMkpHY0hwV1IzaHJWVEZhV1ZGc2NGZGhNWEJ4VkZaYVZtVldWblZVYkdScFlURndWVmRYZUc5Vk1WcFhWbTVTYW1WclduTldiWGh6VGxaU1YyRkhkRmRoZWtaNVdUQmFjMWRzV2xkalNGcFhUVVp3WVZwWGVGZGtSMFpJVW14T1UxWldiRFpXTW5oWFdWZEZlRnBHYUZOaE1sSnZWV3BLTkZkV1ZuUmtTR1JZWWtad2VWWXlNVWRoVlRGV1ZtcFNWazFxVmxCV2FrcExVMGRHUms5V1pHaE5WbkJOVm0weE5HTXlUbk5hU0ZaaFVqTm9XRmxzYUZKbGJGcDBUVVJHVlUxV2JETlVWbWhMVjBkS2RHVkhSbGRoTVZWNFdrZDRZV05XU25Ka1JrNXBVakZKZUZaVVNqUlpWbEp6VTI1V1VtRjZSbGhaVjNSaFkyeGFSVkpyY0d4U2JrSktWbGN4YzFVeVJqWldiRUpZVmpOb2NsbHFSbk5XTVdSMVVteE9hVmRHU2xGV1YzQkRZekExUjFkdVRtaFRSVFZYVkZkMFYwNVdXbGhPVldSWFlsVndWbFZ0TldGWGJWWnlWMnhrWVZKRldtaGFSbHAzVTBkT1NHSkdUbWhOTUVwaFZtcEdZVll4V1hoVldHaFhWMGQ0VlZsVVNsTmpWbFowVFZSU1YySkdjREJVVmxVeFZHeGFjMk5FUWxwbGF6VjJWbXBCZUdOck5WWmFSbWhvVFZoQ2IxWnJaRFJYYlZaWFlqTndhbEp0VW5CV01GWkxVMVpaZUZkdFJsUk5iRXBJVmtjMVIxZEhTa1pqU0VKV1lsUldSRnBYZUd0V01WWnlXa2QwVG1FeGNFbFdNblJ2VXpGYWRGSllaR3BUUlRWWFdXeG9iMlZzVW5OWGJHUnJVakZLU1ZReFpHOVZNa1Y2VVdwV1YxSXphR2hXVkVaYVpWWktXV0ZIY0ZOTmJXaFpWa1phWVdReGJGZGpSbHBZWWxoU2NsVnFSa3RTTVZKelYyczVWV0pHY0ZoWlZFNXJWakpLVlZKVVFscGhhM0JMV2xaYVMyUldVbk5WYld4b1pXeGFORlpzWTNkbFJUVkhZa1prYVZKc1dsUlphMXAzWXpGV2RFMVVRazlTYkd3MVdsVlZOVll3TVVWU2JteFhUVzVTY2xacVJrcGxiVVpIVld4a1YxSllRazFXVkVaaFVqRmtWMk5GWkdGU2F6VndWVEJXU21WV1duUmtSazVVVFZWc05GVXhhRzlaVms1SFYyeFdXbUpIYUVSV2ExcHpaRWRTUm1SR2FGTmlTRUYzVjFSQ1ZrNVdWbkpOVm1oV1lUSm9XRlJYY0ZkVFJscHlXa1ZhYkdKR1ducFdiWGhoWVZaa1NHRkZNVmhpUmxwb1YxWmFhMUpyTVZkWGJVWlRZbFpLVUZaWGRGZFRiVlp6VjJ0b2ExSnJOVk5VVmxwelRsWlZlV1ZJVGxaaVZWWTFXVlZhYjFkc1dYcFZiV2hhVFc1b1lWcEVSbXRqYlZKSVkwZHNWRkpWY0VwV01WcFhZVEpOZUZkWVpFNVRSM2h2VlcxNGQxZEdVbGRhUlRsUFVteEtWMVl5Y3pGaVJrcDFVV3R3VjFJemFIWldNRnBLWlZkR1NHRkdaRk5pUlhCTlZteFNTMVJ0VmtkWGJsWldZbGhvVkZsc1drdFZWbHBZVFVob1ZrMXNXbGhXTWpWVFZHeGFSbE50T1ZaaVdHZ3pXbFphVTJNeFduUmtSbWhvWld0YVNWZFVRbTlrTVZsM1RWaEdVMkV6YUZoVVZscDNWa1paZUZwRlpGTk5XRUpJVjJ0YWEyRlhSWGRqUjBaWFlXdHZkMVpxUm1Ga1JscHlXa1pvV0ZJeWFGaFhWekUwVXpKTmVGWnVVazVXYXpWeFZXMTRWMDB4V25Sa1JFSllZa1p3ZWxsclVsZFpWa3BYWTBoS1YyRnJjRWhVYlhoaFl6SktSMWR0YkZoU2EzQTFWbTB4TUdFeFRYbFVia3BQVm0xNFZGbHJXbmRqUmxsM1drYzFiR0pHY0RCWk1GWnJZV3N4Y2sxVVZsWmlXRkoyVmxWYVdtVnNSblZSYkZwcFZrWmFSVlpIZEdGWlZscFhWRzVHVW1GNlZsUlpiRnBMVTFaYWNWTlVSbFJOVjFKSlZUSTFWMVZ0U2toVmJHaGFWak5OZUZwSGVISmxWMVpKVkd4a1RsWXhTalZYVkVKclRrWlZlVkpxV2xkaGJGcFlWVzE0ZDJGR2JGVlNiSEJyVFVSR1NsZHJXbE5oUlRGMVlVWndWMkpVUlRCVmVrWlRVakZrYzFac1RtbFRSVXA2VmxjeE5GbFZNVmRYYmxKc1VtMVNiMVp0ZUhkWFJtdDNWMnhrVjAxcmNGcFdWekZ2VjBaYWMyTkhhRmRoYTFweVdUSjRkMUl5UmtoaVJrNU9WbGhCTVZadGRHRlpWbXhYVkZoc1YySnJOVmxXTUdRMFZVWmFjMVZ1VGxwV2JIQXdXVE53UjFaR1duTmpSbXhoVmxad1VGWnFSbUZqTWtwRlYyeGtWMDB5YURKV2JYaHJVekZKZVZScmFHaFNiSEJ2V1ZST1ExTldXbFZSYkZwUFZteHNOVlZ0ZEd0V1YwWTJWbXhXVm1KR1dubGFWVnBoWkVkU1NHUkZPVk5OUmxreFZsUkdiMkl4WkVoVGJrNVVZa1phWVZaclZuZFdSbHB6VjI1T2FtSklRa2xVTVZwdlZUSktXV0ZHWkZkV2VrRjRXVlJHV21WR1RuVlViWEJVVWpKb1dGZFhlRk5TTVU1SFlrWldVMkpWV25KV2JYUmhaVlpzVmxkdE9XaFNWRVo2VlRKd1lWWXlTa2RUYTNoV1pXdHdVRmw2Ums5a1ZrcHpWbTFzVTAxVmNGRldNV04zWlVkSmVGcEdaRmhYUjJoWldXeG9VMVpHYkhOWGJVWlVVbTEwTTFadE5VOVdNVmwzWTBWc1dsWlhhRVJXTWpGR1pVWmtjVlJ0UmxkTk1taHZWbXBDVm1WR1RsaFNhMXBRVm1zMWNGWnRkSGRUYkZwMFRVaGtUbFpyYkRSV01uaHZWa2RLUjFkdVFsWk5SbHBvVjFaYWMxWldTblZhUlRWT1ZtNUJkMWRzVm1GWlYwcEhWMWhvVkdFeGNGZFdibkJIWkd4c1ZscEdaR3BpUjFKNldUQmFhMkZXU1hoVFdIQlhWbXhLU0ZsVVNrNWxSbkJKVkcxR1UwMHdTbFZXUm1ONFlqSkdSMWR1VWs1V1JrcHlWRmR6TVdWc1duTmhSM1JhVm10d1dWWlhlRk5YYkdSSlVXdG9WMDFHY0hKWk1uaDNVMFU1V0dGR1RsZFNWbkJNVm14YWFrMVdiRmRYV0dST1ZtMW9iMVZyVlRGV01YQllaRWRHVmsxWVFsaFdNbmhQVjBaWmQxZHJiRnBOUm5CUVZtcEJkMlZYUmtkaFJtUk9WakZGZDFkWGNFZFNiVlpIV2toS1lWSnRhSEJaVkU1RFYyeGtXR1ZHWkZwV2JWSllWakkxVTFSc1duSk9WbXhYWWxSV1JGWnFSbXRqYkZwMFpFWmtUbFpZUWxkV1Z6RXdXVlpaZVZOc2JHaFRSbkJZV1ZkMFIwNUdhM2hYYlVacVRWWmFlbGRyV2s5VWF6RjBZVVpLVjJKR1NrUlpWRVpLWlVaU2MxcEdWbWxoZWxaWlYxZDBhMVV5VGtkV1dHUlhZVE5TVlZsclduZGxWbVJ5Vld0T1dHSkdjREJXVjNCRFZqSktXV0ZIYUZkU1JWcG9XWHBLVDFJeFNuTmFSMmhvVFRCSmVWWnRjRU5aVjAxNFYyeGtWbUpyY0ZaWmExcExWMFpzY21GRlRrOVNiSEJXVlRJMWExWnJNWEpYYTJSVlZteHdjbGxYZUV0a1IwWkhZVVpXVjJWc1drVlhWbFpoV1ZkT1YxUnVTbXRTTTBKUFdWaHdWMU5zV2xoTlZGSm9UV3RhV0ZVeU5WZFZiR1JKVVd4c1dtRXlVbE5VVlZwYVpWVXhWMU50ZUZOTlJGWklWakowYTFJeFZYbFNhbHBYWW0xU1dGbHNVa1prTVhCRlVtczVWMDFZUWtoWGExcHJZVlphVjJOR1pGZFNiSEJvVlhwS1YyTXhaRmxpUlRsWFlsWktXRmRYZUZkV01EVnpWMnhvYkZKNmJGaFdiWGgzWld4cmQxVnJPVmROUkVaSVdUQm9TMVl5Um5KWGFrNVdZbGhvY2xwRlpGZFNNWEJJWVVVMVRsSlhkRFZXYlRGM1V6QXhSMkpHWkZkWFIyaG9WV3hrVTFaV1dYZGFSRkpwVFZaYU1GcFZhR3RYUmxwelkwaG9WMUl6YUZCWlZWcExaRVpXYzJGR1pFNWhhMVl6Vm0xd1FtVkhUblJVYTFwb1VtMVNjRll3Wkc5V1ZtUlhWMjFHVkUxWFVsaFZiVFZQVlcxS1NGVnNhR0ZXTTFKTFZGVmFZV014Vm5KYVIyaE9WbGQzTUZkVVFsZGpNVnBJVTJ0b1ZtSkhhRmRaYkdodlRURlplRmR0UmxOTlZuQjZWa2Q0VDFSc1dYaFRhMnhYWWxob2RsbDZTa2RqTVU1ellVWmFhVkl5YUdoV2FrSnZVVEZPUjJOR1dsaGlSMUp4VkZkMFlWTldjRVpYYlhSVllrWndNVlZYZEc5WFJscEdVMnhvVldFeGNHaGFSVnBQWXpGYWMxUnRiRk5XV0VKWlZqRmFhMDFHYkZoU2EyUnBVa1p3VlZsVVNsTldSbEpYWVVWT1UwMVdTbnBXYkZKSFZqQXhXRlZyWkZaTlYyaDZWbXBLUzFkV1JuSmxSbFpYVm01Q1dGZHNWbUZUTWxKWFZHNUtUMVp0VW5CV2JYUjNXVlphZEdORlRtaE5hMncxVlcxMGExWXhaRWhWYkdoYVlsUkdWRll4V2xka1JURlZWVzE0VjJKSVFqWldiR1F3WVRKR1NGTnJXbXBUU0VKaFZGVmtiMDB4V25GUldHaHFWbXh3TVZVeWVHdFViRXAxVVcwNVdGZElRa3hXUkVaTFpFWktjbHBIUmxOV1JscDJWMVpTUjJReFRuTlhXR2hZWWxoU2MxbHNXbUZUUmxWNVpVZDBXRkl3Y0hsVWJHTTFWbTFLVlZKc1VscE5SbkJZV1RGYVQyUkZPVlpQVjJ4VFRWVndXbFp0ZUd0TlIwVjRWMnhhVGxac2NIRlZNR1EwVm14c2NsZHVaR3BpUjFKWVZqSjBNR0V4V25KWGFrWldWak5vYUZsV1dtdFRSbTk2WTBab1YwMHdTa2xYVmxKTFZHMVdTRlJyV2xkaVJuQndWakJXUzJReFduUk5WRUpZWVhwR1NGWXhhSE5oTVVvMllrWmtWVlpzY0doVk1GcGFaVlUxVjFSdGFGTmhlbFpJVmxSS05HSXhaSFJTV0d4V1lteHdWMWxVUm5kV01YQlhXa1prVkZJeFNraFhhMVV4VmpKS2NsTlVTbGRoYTI5M1YxWmFjMVl4Vm5WVWJHaHBZa1p3VkZkV1pEUlpWbVJIVm01U2JGTkhVbGxWYlRFMFZteFZlV1JIZEdoaGVrWllWVEkxYzFZd01YRlNhazVYVmtWd1RGWXdaRWRUUjBaSFdrZHNXRkpWY0ZKV2JYaFRVekZKZUZOWWJGTlhTRUp3VldwT2IxWldWbkZTYTNSWFZtMVNXVnBGWXpWVmF6RldUbFZvVjAxdVVuWlphMXBMVmxkS1IxZHNjR2xTYkhCWlZrZDBZV050VVhoWGJsWlZZa2RTVDFsVVJscE5WbHB5V2toa1ZrMVhVakJWYlRWTFYwZEtSMU50UmxWV2VsWlFWR3RhWVdSSFZraGtSM1JUVFVad1NGWkhlRlpOVjBaWFYxaHNhRkl3V2xoWlYzUmhZMnhTY2xwRmNHeFNhM0JhV1ZWYVlXRkZNWE5UYkdoWVZqTlNhRnBFU2tkU01WcDFWR3hvYVdKV1NuaFdSbHBoWkRBeFIyRXpjR3BTVjFKWlZXcENkMU5XY0ZaWGJYUlhUVVJHZUZWc2FHdFdNREZIWTBWNFdrMXFSa3hWYkZwcll6Sk9SMXBHWkdsaE1IQmhWbTB4ZDFFeGJGZGlSbWhXWVRKU1dGbHJXbUZWTVd4elZtMUdWMUpzV25wV01qVnJZa1phYzJOR2JGcE5SbGwzVm10VmVGWnJOVmRoUm1ScFZrWmFUVlpyVWtkWlYxSkhWbTVTVUZZd1dsaFVWRXB2WWpGWmVGZHRSbHBXTURFMFdWUk9kMkZHU2xWaVJsSlZWbXhhWVZwWGVHRlNNV1IwVW0xb1RtRXhjRWhXUmxadll6RmFkRk5yYUdoU01GcFlXVlJHVm1WR1duSlhia3ByVFZkU2VsZHJaREJWTURGV1kwVjBWMDF1VW5KVWEyUkhWakZPZFZWdGRHeGhNWEJhVjFkMFlWbFhVbk5YYTFaVFlsaFNWVlZ0Y3pGbGJHUnlWMjA1YUZZd2NGcFpWVnByVjBaWmVsVnVTbHBoYTNCSVZXcEdhMlJXU25OVmJXaE9Za1Z3TkZZeFpEQldNbEY1Vm10a1dHSkhhSE5WYWs1VFZteHNjbFp1WkU1V2JGcFpXbFZvVDFkR1NuUlZhM0JXVmpOUk1GWnFSa3RTYkdSeVpFZEdWMkpJUWxWWFZFbzBaREZPUjFOdVRsVmlWM2hZV1ZST1FtVnNXbkZTYlVaV1RWVldOVlpHYUd0VU1WcDBWV3hzV21KWVVtaFdhMXB6WXpGYWRGSnNjRmRpU0VGM1ZrWmFVMVV4WkVkVGJrNXFVbGQ0VmxsclduZFZSbHB4VVZob2FtSkdjSGhXYlhoclZqQXdlV0ZIT1ZkaGEydzBWWHBHYTFkR1NuSlhiWGhUWW10S2RsZFdVa2RrTVdSWFdraEtWMkpHY0hOVmJYaHpUa1phV0U1V1RtaGlSWEI1Vkd4b1ExWnRSbkpPV0VwVllsaG9hRnBGVlhoVFYwWkdUbFpPVjFKV2NFcFdiVEUwWWpKSmVGcEZhRlJpYTNCUVZqQldZVll4YkZWU2JVWlZVbTFTV0ZZeWVFOVdNa3BJVldwQ1ZtSllhRmhXVkVwTFUxWkdjbU5HYUdsU2JIQjVWbGR3UzFJeVVrZFViazVZWWxoQ1ZGWnROVU5YVmxwMFkwVTVhVTFzU25wWmExcGhWakZrU0dGSVNsWmhhMHBvVlRCYVYyUkhWa2hQVm1ST1lUTkNTVmRVUW1wT1ZsbDRXa1ZzVW1FeWFGbFdiWGgzWTJ4V2NWSnNUbXRXYXpVd1ZXMTRUMVJ0U2xoaFJscFhUVmRPTkZSVldrNWxSbkJKVkd4b2FWSnNjRlJYVjNSclZURmFWMVZzWkdGU2F6VlpWVzE0YzA1V1VuTldiWFJYWWxWd1Yxa3dXbXRXTURGeFVtdG9WMkZyY0V4V01WcFhaRmRPUjFadGFFNVhSVWt4VmpKMFUxSXhiRmhVV0docVVsZFNXVmxzWkRSWFJsbDNWbXQwYUZKc2NEQmFWV1F3WWtkR05sWnNhRmhoTW1oVVZsUkdhMU5IUmtsU2JGcG9UVlpXTkZacVFtRlZNVmw0V2toV1lWSXlhRlJaYkdocVpWWmFXRTFFUmxWTlZrWTFWVEowWVdGc1RrbFJiR2hhWWtkb1QxcFZXbUZqVmtaWllVWmthVlpVVmtoWGExWmhZVEpHVjFOdVNtcFNXR2hZVlcxNGQyRkdXa2hOVm1SVFRWWndlbGxyWkc5Vk1rcFlZVWhrV0ZZelVsaGFSRXBYWXpGa2MyRkhjRk5XVkZab1ZtMHdlRTVHWkVkaVNFcFlZa2RTVjFSWGRIZE5SbHBZVFVSV1YySlZjRnBaVldoM1ZsWmFSbGR0Um1GV2JWSllWVzF6TlZkSFJraGlSbVJZVWxWd1RGWnRNVFJoTWxGNFUxaG9XR0pyY0U5V01GWmhWa1paZDFwR1RsaFNiRnA0Vmtjd05XRnRTa2RYYWtKaFZsWlZNVmxYTVV0V2F6VldZVVpvYUUxWVFsRldiRkpIV1ZkU1YxSnVWbGhpUjFKUFZtMDFRMVpXV2xoalJXUlhZbFphV0ZaWGVITmhSa3B6VjI1Q1dsWkZOVVJXTW5oclYwZFNTR1JIYkU1aE1uY3dWbXhrTkdJeFVYaFhhbHBwVW0xNFlWbFVSbmROTVZKV1YyNWtVMkpIVWpCYVJWcHJWVEZhUmxkcVdsZFdSV3Q0V2tSR2EyTnJNVlphUm1ocFVqSm9XVlp0ZEZka01WSkhWbGhvV0dFeVVuSldiWGhMWld4a2NscElUbGhTYTNCV1ZXeFNRMVl3TVhWaFIyaFlWbTFTUjFwV1dsTmtWbEowWTBaT1YwMHlhSFpXYkdONFRrZFJlRlZZYUdsU2JGcFVXV3RvUTJNeGJISmFSazVYWWtaYVdWUldVa05oUmxwVlVteHNWMVl6VW5wV2JYTjRaRlpXZFZkc1pHbFhSMmg1VmxSQ1lWWXlUWGxUYTJSaFVqSjRXVlZxU210T2JGcDBZMFZPV2xac2JEVldSM2hyVmxkS2NtTkdiRnBpUjJoMldUQmFZV015UmtaVWJGSnBVakZLVjFaV1kzaE5SbEY0VTFoa1dHRXlVbFpXYlhoM1pXeGFXRTFWZEZSV2ExcDZXVlZhZDFZeFNsZGlNM0JZVm14YWFGbFVSbHBsUm5CSlUyczVWMDB4U2xCV1YzUlhXVlprUjFkWWJHdFNNMUp4VkZaYWQxTkdWWGxsU0U1V1lsVndTbFZYZUhOV01rWnlUbGhhWVZJemFHaFdiRnBQWTIxT1NHVkdUbWxUUlVZMFZtMTBhMDVHYkZoU2ExcE9WbFphV0ZsclZrdFhSbFowWlVoa2FGSnNjSGhWVmxKSFZqQXhWMWR1Y0ZoaE1YQXpXV3RrUzFJeVRrZGlSbVJUWWtad1ZWWlhjRXRXTVZsNVVsaHdZVkp0YUhCV2JGcDNWMVprV0dSSFJtcE5SRlo2Vm0xNGIySkdTbkpPVm14V1lsaG9NMXBYZUhKa01WcHhWV3hrYVZaWVFtRlhWbFp2VXpGa2NrMVlWbFZXUlZwWVZGVmFkMVJHYkRaU2JFNXFUVlpLZWxkcldtdGhWbVJIVW1wYVYySlVRak5hUkVwU1pWWmFjbGRyT1ZkV01taFZWbXBDYTA1R1duTmlTRkpyVTBkU1YxVnRlSGROUmxKWFYyczVhRkpyY0hwV01uQkRWbFphYzJOR1FsZGlSbFkwVmpCa1YxTlhUa2RoUjJoT1lYcENORlp0TVhkUmJWWkhWMWhzVldFeWVHOVZiWGgzWTBaYWNsWnNjR3hpUjFKWldrVmtSMVpGTVZkalJtaFdUV3BXVEZsV1drdGtSbFp6WVVad2FWSXhTakpXUm1RMFdWZFNSazFXVmxaaVYyaFBWbXhTVjFOc1dsaE5WRUpvVFd0YVdGVXlOVmRWYlVweVUyeG9WVlpYVWxSYVIzaGhVakZrZEZKdGNHbFNiSEExVmpKMFlXUXhXWGROVmxwcVVsaENXRmxVU2xOTk1XUlhWMnhhYkZack5YbFpWV1J2VlRKS1JtTkhhRmhXYkVwTVdXcEdSbVZIVGtaV2JFNXBWbFp3VlZaR1dtdFZNbFp6VjJ0b2JGSXdXbFpaYTFwelRrWlZlV1JJVGxkTmExcDVXVlJPYjFZeVJuSlhiR2hoVWxad1RGWXhaRXRTTVdSMFlrWk9UazF0YUhaV2JUQjRUVVpaZUdKR2FGTmhNbEp2VkZSS05HTXhWblJPVlU1cVlrWktXRmRyV2s5aVJscDFVV3RrV0dFeWFISlpWVnBoWXpKT1IxZHNaR2xYUmtZelZtcENZVmxXU25OVWJsSm9VbTVDV0ZWc1duZFdWbVJ5Vm0xR1ZVMXNTbGhXUnpWUFZtMUtXR0ZGT1ZwaVZFWjJWako0V21WR1pIUmtSVFZUVFZWWmVsWkhlRzlVTWtaelUyNU9hbEp0ZUdGV2ExVXhVa1pzTmxKc1pHdFNWRlpYVmtkNFUyRldTblZSV0dSWVlrWmFhRlpFU2tkU01XUjFVMnM1VjFZeFNsaFdSbU14WWpKV2MxZHVSbE5pU0VKeldXeFdZVk5zV1hsbFIwWlhUVlZ3V0Zrd1dsZFdNa3BaVVd0b1dsWkZjRTlhVmxwTFkyMUdTR05HVG1obGJGcGhWbXhqZUUxSFVYaGFSV1JZWW10d1dWbHNWbUZYUmxKWVl6Tm9UazFXU25wV2JURXdWMnhhY2s1VlpGcE5SMDB4Vm0weFMxSXhUblZqUm1ST1ZtNUNXVmRVUm1GU01rMTVWR3RhVDFZeWVGUlpiWFJIVFRGYWNscEVVbGROVmtZMFYydFdiMVpIU2tkalJtaGFWak5vVEZZd1dsTlhSMDVHV2taU1UySldTbGxXYWtvMFpESktTRk5zV2xoaE1uaGhWbXhrVTFOR1dsVlNiSEJzVW1zMWVsbHJXbXRXTURCM1UydHNWMkpHU2t4V1J6RlhVakZXZFZac1dtbFdNMmhWVjFkNFlWTXlVWGhYYkZaU1lrZFNWVlJXV2t0VFJsbDVUbFpPVldKR2NFZFZNakExVjJ4a1NWRnJhRmROUm5Cb1ZXcEtSMU5GT1ZkYVIyeFRUVlZ3UzFZeFdsZFpWMDE0V2toU1ZHSkhlRlpXTUdSdldWWlNWMWR1WkZoU2JrSklWMnRWTlZaR1duTlRibkJZWVRGVmVGWnFRWGRsVm5BMlUyeGthVmRIYUhsV1IzUnJVbTFXUjFkc2JHaFNiRXB3V1d0V2QyVnNXbFZSYlhScFRWWnNORmxyYUU5aFJrbzJZa1prVm1KWWFETmFWVnBYVmpKR1NFOVhhR2xXV0VKS1ZteGpNV014WkVoU1dHaHFVMFZ3V0ZaclZrZE5NWEJGVVZob1YxWnNXbnBaVlZwcllWWk9SbE51V2xkaVIyZ3pWWHBHVm1WR1pGbGhSbEpwWVhwV2QxWlhjRU5aVmxwSFlraE9ZVko2YkZsV2JYaDNWMVp3VmxkdGRHaE5SRVpaVmxkNGIxWXdNWFZoU0hCYVZqTm9URll4V2xkak1WWnpZMGRzVTJKclNrcFdhMXBUVWpGVmVGZFlhR0ZUUmxwV1dXdGtVMWRHVWxaaFJVNVVZa2RTV0ZadE1YZFVNVnB6WTBab1YwMXVRbWhXVkVwTFl6Sk9SMkZHVmxkaVNFRjZWMVpXWVZkdFVYaFhiRlpUWWtkb1dGbHRkRXRUVmxsNVpFWmFUbFpzYkRWVk1qVkxWa2RGZWxGc2FGcGlSMmhFVmtWYVUyTnNaSFZVYkdST1YwVktTRmRXVm1GVk1rWlhVMjVXVW1KSVFsbFdibkJHWkRGd1JWSnNjR3hTTUhCS1ZrY3hiMVV5Vm5SbFNGcFhWbnBGTUZWNlJscGxSbVJaWWtkNFUxZEdTbmRXVnpFd1pEQXhSMWRzYUdwU1YxSlpWV3BDVjA1R2EzZGhSWFJYVFZWc05sbFZaRzlXTURGWFkwVm9XbVZyV2pOVmFrWjNVMGRLUjFwR1RsZGlSM2N5Vm0wd2VFNUdWWGhUV0doaFUwWktXRmxVU2xOV2JHeDBaVWRHVjAxWGVIbFdNalZyVjBaS2MxZHVjRmRpVkZaeVdWVmFTMk15VGtWUmJVWlRWbTVDZVZkV1VrSmxSbGw0VTI1R1ZtSklRazlWYlRWRFlqRmFjVkZ0ZEZSTlYxSllWbTAxVjFaSFNraFZia0pYVFVkU2RsbHFSbXRqTVhCRlZXeHdWMkY2VmtoV1JscGhZekZhV0ZOclpHcFNWR3hoVm10V1lWbFdVbGhsUjBaWFRWaENTbGRyV2xkVWJGcDBaSHBHVjFaRmJ6Qldha1pYWkVaS2RWUnNVbWxTYmtKb1ZtMTBWMlF4V2tkWGJGWlRZbTFTV0ZsclpGTmxiRnBJVFZoa1ZXSkhVa2RWTW5SM1ZqRmFObEpVUWxkU1JYQklWbXBHVDJSV1duTlRiV3hUWWtoQ1dsWnJXbUZoTVZaMFZWaG9hVkpzV2xSWmExcDNZekZhZEdWRmRHeGlSMUo1VmpJeFIyRkdXbkppUkZKV1RXNW9NMVl3V21GT2JFWnhWV3hrVjFKV2NHOVdiWEJIWVRKU1YxWnVVbXhTYXpWd1ZtMTBkMVZzV25STlNHUk9WbXRXTkZZeGFHOVpWa3AwWlVoR1ZtSlVSbFJaYWtaWFpFZFNTVnBIZUZkaVdGRjZWMVpXYjFReFpFaFNhbHBUWVRKNFlWWnNXa3RWUmxweFUydDBXRlpzU25oV1Z6RkhWVEpLVjFOcmJGZFdSVXB5VldwR1NtVkhUa1poUjJoVFRXMW9VRlpHVmxka01VNXpWMjVHVkdGc1NsaFVWbVEwVjFaV2MyRklUbGRpVlZZMVdWVmFVMWRzV2taalJsSmFWbFp3V0ZwRlpFOU9iRXB6WVVaT2FWZEhaRE5XTW5SWFZqQXhTRkpZYkZSaE1sSndWV3RhUzFsV1duTmFSemxxWWtad1ZsVldhRzloYlVwSFkwaG9WMkpZYUhKV2FrRjNaVVpPZFdKR1pHbFhSa3A1Vmxod1MxUXlUbkpPVm1SaFVtMW9jRlV3Vmt0WGJGcFZVV3hrVkUxWFVsaFdNalZIVlcxS1ZsZHVSbFZXTTJoTVZURmFZVmRIVWtoU2JIQlhZVE5DVjFadE1YcE9WbGw1VTJ4V1YyRXhTbFpaYkdodldWWndWbGRzWkdwaGVteFpXVlZWTVdGRk1IZFRhM0JYWWtaS1RGUnJXbHBsUmxwWllrWk9XRkl6YUhaV1Z6QjRZakZrUjJKSVVrOVdWVFZaVlcxNGQyVldXWGxOVldSWFRWWndlVmt3VWtOWlZrcFhZMFpTVjFaRlJqUlZha3BQVW0xU1IxcEdaR3hoTVZZelZtcEdZV0V4U1hoWFdHaFZZa2Q0YjFWdGN6RlhWbFp4VW10MFdGWnRVbGhYYTFKRFZrVXhjbGRyYUZwaE1VcG9WbFJLUzFkV1ZuTldiRnBwVjBkb2IxZHNXbUZqTWs1eldraE9WV0pYYUZoWmJGcExVMnhrVjFadFJsZE5WMUpJVmpGb2QxWnRTbk5qUm1SWFlURmFhRmRXV25kV2JHUjBaRWR3VG1FeGNFaFdSM2hoWVRGVmVWSlljRkppUjJoWVdWUkdkMk5zVWxaWGJrNVlVbXh3ZWxkcldtRmhWa2w0VTJ4d1dGWXphSFpXVkVaclVqRmFkVkpzU21saVZrcFFWbGN3TVZFeFdYaGFTRXBYWWxoU1dGUlZVa2RsVm10M1ZtNU9WMDFXYkRaWlZWcFRWMFphYzJORmRHRldla1pJVlRCa1IxSXhjRWhpUms1cFlUQndVMVpxUmxOVGJWWkhWbGhvVkZkSGFIRlZiRnAzVlVaYWRFMVdUbGhTYkZvd1dsVm9TMkpHV25OalJFSmFUVVpaZDFaSGVFdGtSMVpIWWtaYWFWSXlhRFpXYkZKTFV6Rk9SMVp1VG1sU2JrSllWV3hhZG1Wc1duRlJiVVpZWWxaR05Ga3dWbXRXVjBwSVlVWlNXbUpIYUhaVWJYaGhZekZ3UlZGc1ZrNVdhMWt3VmxSSk1WUXlSbk5VYTJob1VtMVNZVmxyWkc5V1JsSlZVbTVPYW1KSFVubGFSV1F3VmpKRmVHTkVWbGhXYkZwb1drUktSMUpyTVZsVWJGSm9UVzVvV1ZkWGRHRlRNVkpIVm1wYVUySllVbFZWYlhSM1pWWnNjbHBGWkZaTmEzQllWVEo0YzFZeFdYcGhSbWhoVWtWYWNsWnFSbXRqTWtwSVkwWk9XRkpyY0ZwV2ExcHJaVzFXUms1VlpHRlRSWEJ2VlcweFUxZEdiSE5XYm1SWVlrWmFXVnBWV2s5V01ERnlWMjVzVjAxdVVUQldNbmhoVmpKT1NHRkhSbE5XYkZrd1ZtcEdhMVF4U25KT1ZtUmhVako0V0ZsVVRrTlRNVnAwVFZoa1ZFMUVWa2xWYkdoelZUSkZlVlZzVmxwV00yZ3pXVEJhVjJOV1JuUlNiR2hUWWxob05sZFdWbUZVTVZKMFUydGtWR0pIZUdoV2JHUnZWVVpzV0UxVmRGUlNiRnA0VlZkNFlXRldaRWhoUkVwWVZteHdhRmRXV2xwbFJuQkhWbXhLYVZJeWFGbFdWM2hYWkRGYVYxZHVTbFpoTWxKWldXeGFSMDB4VWxkWGJYUmFWbXRzTmxWWGVGTlhiR1JKVVd4b1dtRnJXbWhXTUdSVFVqRndTR1JGTlZkV1JscEtWbTB4TkdJeVNYaGFSV2hVWVRGd1VGWXdWbUZXYkZweFZHeE9hRkpzVmpOV01qRkhWa1pLVlZKc2NGZFNNMmhvVmtkNFMxSnNUbFZTYkdSb1RXeEplbFp0Y0VkWGJWWlhWRzVPVjJKRk5WaFZiRlozWVVaYWRHTkZPVlZOUkZaSVZqSTFSMVV5UmpaaVJteFhZV3RLYUZVd1duTldiSEJKVkd4YVRsSkZXWGRYVmxaaFlURlpkMDFXWkdwU2JFcFhXbGQwWVZZeGNGZFhiRTVxVFZoQ1NGZHJaSE5oUlRGWlVXeGtWMDFYVVRCV1ZFcE9aVVp3UjFwR1pHbGlSWEJRVm0xMFlWTXhaRmRYYmxKUFZsVTFWRlJXWkZObFZscDBUVlJDYUZKcmJETlpNRnByVjJzeFIxZHFUbGRpV0doaFdsZDRWMlJXWkhOYVIyaG9UVVpyZDFZeWRHRmhNVWw0VTFob1UySnJOWEZWYlRGVFZERlNWbFZzU210TlZtdzBWbGQwTUZReFNYZFdhbFpYVW5wV1ZGWnJaRVpsVmxaMVVteGFhVlpGV2xWV2FrSmhWVEZaZUZkdVZsaGlXR2hZV1d0a00wMUdXWGxrUms1U1RXdGFSMVJXV21GVWJGcEhVMnhrVlZadFVuWmFWM2hoWXpGd1JsZHRlRmRpUm05NFZsWmtORmxYUmxkWGExcFlZa1phV1ZaclZrdGhSbVJYV2tVNWFrMVhVakZWTWpGM1ZURmFSMWRzVmxoV00xSjJWVlJHVDJNeGNFbFRiR1JwVjBaS1ZWWkdaREJaVjFaWFZXeGtXR0pVYkZoWmJGWlhUbFpzVmxkdE9WaGlWWEJKV1ZWb1lWbFdXWHBoU0hCWFlXdGFjbGt5TVZOVFIwNUlZVWQ0YVZKdVFtaFdiWFJUVWpGc1YxZFlhRmhYUjFKUFZUQmtOR0l4Vm5OVmEyUllVbTE0V1ZwRmFHRlViRXAwVld4b1dHRXhWVEZXYWtGNFZtMU9SVkpzWkZkbGExWXpWbXhTUzFNeFRsZFNiazVTWWtkb1dGbHJWbmRUVm1SeVZXdGtWVTFXYkRSWGEyaFhWbTFHTmxac1VsWmlSbkF6Vm1wR1lWSXhaSFJTYlhST1VrVmFTVlp0ZUc5ak1WRjRWMnhzVm1KR2NGWldiWGgzVFRGU1ZsZHRSbGhTTVZwSldrVmFiMkZXV2xsUmEyeFhWa1Z2ZDFsVVJtRldNV1J6V2tkd1UxSlVWbGxYVm1Rd1dWZE9jMkpFV2xSaGVteFZWV3BHWVZOR1pISlhiWFJXVFd0d1NsVlhNVzlXTWtaeVlqTmtWMkZyY0VkYVZscFRWMWRHUjFwR2FGTk5WWEJSVm0weE5HRXdOVWRXV0docFVteGFWbGxVUVRGWFZsWjBUVlJTYkZadFVubFdiRkpIWVZaS2NtTkVRbUZUU0VKTVZtMHhTMWRYUmtWVWJIQm9UVmhDYjFkVVNucE5WbVJZVTJ0a2FGSXlhRTlXTUZaTFZteFplRmRzWkZkaVZscEpWbGQwYjFVeVJYbGhSemxXWWxSR1ZGa3dXbHBrTVhCSVQxZHNUbFl4U2pWV2JHUXdZVEZhY2sxV1dtbFNSa3BaV1ZSS2IxZEdXbk5hUlhSVVVqQmFTVlF4V2xkV01VcFhZMFV4V0dKR1dtaFhWbHBLWlVkT1JtSkhjRk5XUmxwWlYxWm9kMVl4VGxkWGJrWlRZbFJzY1ZSWGRIZFRSbFY0WVVoa1YySlZjRlpaYTFwdlYyMUtTR0ZHVWxWV1JWcGhXbFprVjFJeGNFZGhSazVPVmxoQ1RGWnFTakJaVjBWNFZXNVNVMWRJUWxOWmEyUlRWMFphZFdORlpFNU5WbkJHVlcweFIyRXhTbk5qUkVaV1RXNW9kbGxWWkZka1IxWklUMVprYVZkSGFHOVhhMUpDWkRKV1IxZHVWbE5pUlRWd1dXeGFTMVpXV2tkWGJVWlVUVVJHU0ZscmFFdFpWa28yWWtaYVdsZElRa2hWYWtaelpGZE9SbVJHWkU1aE0wSmhWMVpXYjFJeGJGZFhiR1JYVjBkb1YxbFhkSGRVUmxaeFVtNWtWRkpyY0hwV1IzaHJWR3hhV1ZGdGFGZGhhMXB4V2xWVk1WSXhVbGxpUmxaWVVqSm9XVmRYTVRSVE1WRjRWMjVTYW1WcldsaFVWbHBoVFVad1ZscEZaRlZpUlhBeFZWZDRhMWRzV2xoVldHUlhUVVp3VEZsNlNrOVNWa1owVW14T1YyRXpRbEpXYlRGM1V6Rk5lRmRzWkZSaVIzaG9WVzAxUTFkR1duUk9WVTVWVm14d01GcFZaRWRXUlRGelUyeHNWMUl6VW5KV01HUkhUbXhhZFZGc2NHbFNNVW94VjJ4YVlWbFhVa1pOVm14aFVtczFUMVpzVWtabGJGcElaVWM1VlUxWFVrbFZNalZMWVd4T1JrNVdaRnBpUmtwSVZtdGFZV05zWkhOYVIzQk9WakZKZUZZeWRHdGpNVkp6VjFob1ZHRnNXbGhaYkZKRFRrWlNWbGRzV210TlJFWllWakl4YzFVeFNuSmpSbXhZVmpOb1ZGWnFSbGRTTWtwSFlVZDRVMWRGU25wV2JYQkRXVlpKZUZWWWFGaGliVkp2Vm0xMGMwNUdWWGxqUlhSWFRWWnZNbFZzVWtOWFJscDBWV3hDV21WcldqTlZNVnBYWkVkU1IxUnNaRk5OTW1oWFZtcEdhMDVIU1hsVFdHaGhVMFUxV1ZsdGRIZFhWbXh6Vlc1T2FsSnNTbGhXTWpWUFZERmFjMVpxVmxWaVJsbDNXVlZrUzFKdFRrbGpSbkJPVWpGS1NWWnFTalJaVmtwMFZHdGtWbUpIVW05VVZtaERZakZhV0dWSFJsUk5iRXBZVmxjMVUyRnNTWGxsUmxKYVlsaFNTMVJYZUZwbFJsWnlWR3hrYUdWcldsbFdiWGh2WXpGYVNGSlliR2hUUlhCb1ZtcE9VMkZHV1hoWGJrNVhWbXR3TUZWdE1XOVZNa3BaWVVaa1YxWkZiM2RaVkVaV1pWWktjVmRzVG1sVFJVcFlWa1pqTVdJeVVuTmlSbVJZWVROQ2MxWnFRbUZUUm14V1YyMTBWazFyY0ZoVk1XaDNWakpLV1ZGcmFGaFdiSEJMV2xaYVQyTnNjRWRoUjJ4VFRXMW9NbFl5ZUdwbFJUVkhWMnhrWVZKdGFITlZiWGgzVkRGYWRHTjZSbFJTYlZKNVdWVldNRmRHU1hkalJFSlhWak5vZGxac1dtRldNVTV5Vld4V2FFMVlRbGhYYkZwclZHMVdkRkpyWkdoU2F6VndWVEJXU2sxc1duUmpSWEJzVWpCc05GZHJhRk5XTWtweVkwaEdWbUpZVWt4V01GcHpWMGRTU0ZKc1dsTmlhMHBKVm1wS05GUXlSWGhUYmtwcVUwaENXRlZxVGs1bFJscElaVWRHV0ZaclducFhhMXByWVZaYVJsTlVRbGRTYkZwb1dYcEdXbVZXVG5KYVIwWlRUVVp3VlZadGNFZFRNV1J6V2tab1RsWkZTbkpVVjNSaFUwWmFkRTVWZEZoU01GWTJWbGQ0YjFkdFJYaGpSWGhYVFVad1lWcFdaRk5TVmtaMFlrWk9UbE5GU2twV01XUXdWVEZaZUZkc2FGUmhNbEp4VlcxMFMxbFdXbk5YYkdSUFVtMTNNbFZ0TVRCaE1WbDNZMFZvV0dFeFZYaFpWbVJMVjBad05sTnNaR2xYUlVwTlZrZDBZV014V1hoVWJsWlZZbFZhVlZWdGRIZGtiRnBZVFVob1ZrMXJiRFJXVjNocllVWktWazVXYkZkaVdHZ3pWRlZhZDFac2NFWmFSbVJYVmtWYU5WWkhlRzlrTVdSeVRWVmtXR0pyY0ZoWmEyUlRWRVpaZDFwRlpGUldiRXA2V1RCYWExVXhXblJQVkZwWFlsaENURlJyV25OWFJsWnlZVVpXYUUxWVFuaFdWM0JQWWpGYVIxVnNXbFpoTVhCUFZXMTRkMDFHY0ZaWmVsWm9WbFJHV0Zrd1ZuTldhekYxVlc1S1YwMUhVa3hWTUdSSFUwWktjMk5HWkZOWFJVcFdWbTB4TUZsV1pIUldhMlJoVTBaS1ZGbHNhRU5YUm14eVZtNWtUMkpHY0hsWFZFNXZZVlV4VjFacVZsWk5ibWh5Vm10a1MxTkhWa2RoUmxaWFpXeGFWVlp0Y0VkVk1rMTRZMFZhWVZJelFtOWFWM1JoVjFaa1YxWnRSbHBXTUZwSlZXeG9iMkZzU25SbFJtaFhZbTVDV0ZSVVJsZGpWa3B5VDFaT1RsWXhTalpXYlRFMFZESkdWMXBGWkZSaVJscFlWVzE0ZDFZeFVsZGFSbVJxVFZkU01WWlhNVFJWTURCNFUyeG9WMUp0VVhkYVJFWnJVakZhV1dGR1dtaE5NVXBaVmtaYVYyUXlWbk5oTTJSaFVucHNXRlJXVm5kU01XdDNWbFJXV2xac2NGaFpNR2hMVjIxV2NtTkZlRlpOUjFKTVZXcEdVMk5yTlZaT1YyeFhUVzFvV1ZadE1IaE5SbXhYVmxob1ZGZEhhRlpXTUdSdllVWldjMXBHVGxoV2JYaFdWVEo0VDFkR1NuUmxTR3hYWWtaS1NGWnRjM2hXTVU1eldrWmtWMDB5YUhsV2FrSmhVekpTU0ZacmJHbFNiVkpQV1ZkMFlWTldXbkZSYlhSVVRWWnNORmRyYUZkaGJFcDBWV3M1V21KVVJuWlVWM2hoWkVkV1NGSnNhR2xXYkhBMlZtMHdNVlV5UmtkVFdHUllZa2RvWVZsVVNtOVNSbGwzVjIxMGFrMVhVbnBXTW5NeFZqSktTVkZZWkZkaVIxRjNXVlJHYzFZeFRuTldiR1JwVWpKb2FGZFhkR0ZUTWxKelZXNU9XR0pWV25GVVZtUXdUbXhzVmxaVVZsWk5SRVpKV2tod1ExZEdXWHBWYldoYVZrVmFhRlV3V2s5amJVWkhWMjFzYUUxWVFsbFdNV1EwWWpKSmVGVnJaR0ZTYlZKWldXdFZNVmRXVm5OVmJHUllWbXhHTkZac1VrZFdWMHBIWTBod1YwMVhhRE5XYWtwSFkyMUplbHBHVmxkV01VcEpWMVJLZW1WR1dYaGpSV1JXWWxkNGNGWXdaRzlYUmxsNFdrUkNhRTFXVmpWV2JUVlBZVlpLZEZWc2JGcGhNbWhFV1hwR1lXTldSblJTYkZKWFlrVlpNRlpxU1hoTlIwWkhWMjVPYWxKWFVsaFphMlJ2WTJ4WmQxZHRSbXBOVlRWNVdsVmFhMVl5Vm5KWGJHeFhWak5DU0ZacVNrNWxWazV5WVVkc1UyRjZWbmRXVjNodlVURnNWMWR1VG1GVFIxSlZWRmQwYzA1R1pISmhSVGxhVm10d01GbFZWVFZXTURGSVlVVlNWMUpGV21oYVJWVjRWakZTYzJGR1RtbFhSMmN4VmpGYVYxbFdVWGxTYTJoVVlrZFNXVmx0TVRSWFJsSllZMFprVTFKc2NIcFdNakZIWVdzeGNrNVZhRnBXVm5CWVZtcEdTMVl5VGtsaVJtaFhVbGM0ZDFkV1VrdFVNazV5VDFaa1lWSXdXbFJVVnpGdlpXeGtWMVZyWkd0TlYzaFlWakZvYzJKR1NuUlZia0pWVmpOb1NGUnJXbHBsUjBaSVpFWldhVkl4U2toV2FrbzBWVEZrYzFkcldtcFRSbkJZVkZWYWQyVnNXbk5YYTNSclZtNUNTRlp0ZUU5aFZtUklWR3BXVjJKR1NreGFWM014VmpGYVdXSkdVbWxTYmtKNFZsZDRhMDVHV1hoaVNFNW9VbnBzVjFWdGVIZGxSbFpYWVVjNVYwMXJjRWxXVjNoM1Yyc3hSMk5JU2xwV2JIQm9WVzE0YTFkWFRrZGFSbVJPVFVWd1NsWXhXbE5UTVZWNFUxaG9XR0pyTlhCVmFrbzBWa1pzY2xkdVpHdGlSbkJJVmpJd05WVnJNWE5TYWxKWFRXNW9kbGxYZUV0V2F6VllVbXhrYVZaRldsVldWRUpoVjIxV1ZrNVdXbUZTYlZKVVZGVm9RMVl4WkZoa1IwWldUVlpzTlZVeWVITmhSa3BHVGxaYVYySkdjRE5XYTFwaFpFVXhWbHBHVWxOV1IzaFpWakowWVZReFdYaFRiR1JxVWpCYVdGbHNhRzlqYkZKeVdrVndiRkp0VWxwWlZWcHZWMFpPUmxOdVdsZFdSVXAyVlZSR2MxWXhaSFZVYkdocFlsWktWMVpYTURGUk1VNUhWMWhzYTFJelVtOVVWbFozVm14c2NsZHRPVmhoZWtaSVdUQm9TMVl4V2taWGJXaGhVbFpWTVZac1dtdGpNWEJJWWtaa1UxWnNXWHBXYlhCSFdWWnNXRlJZYUdGU1YxSlhXVzF6TVdGR1ZuUmpla1pxVW0xNGVWWnROV3RpUmxwelkwWnNWVlpYYUhaV2JYTjRWakZLY1ZWc1pFNWhiRnBSVjFaV1lWTXhXblJVYTJ4VVlrWmFXRmxyYUVKbGJHUnpXa1JTYUUxck5YcFdiVFZMVmxkS1dHRkdVbGRoTVZwb1ZqSjRhMk14V25SU2JXeE9WbTVDTlZaR1dtRmlNa1pIVkd0c1VtSlZXbUZXYTFaaFRURmFSbGR1VGs5aVJYQjVWREZrZDFSc1dYaFRhbHBYVFc1U2NsbDZSbXRTTVU1WllrZG9WRkp1UWxsWFZsSkhaREZhUjFadVJsUmhNWEJ6VlcweFUxZHNiRlphUldSWFVtdHdlVmt3V2xkWFJsbDZZVWhhVmxaRmNGQlZha1poWkZaS2MxUnRhRTVOUlhBMVZtdGFZVmxYVVhoYVJtUldZa1p3YjFWdWNITmlNV3haWTBWa1dGSnNWalZaTUZaUFZqSkdObEpxUmxkV2VrWjJWbXBCZUZJeVRraGhSbHBwVjBkb1VWZFljRXRTTVVsNVZHdG9hRkpVVm5CVmJHaERWV3hhY1ZOcVVsZE5WM2hZV1d0YWExWkhTa2hWYkZaYVlsaG9URmt5ZUZka1IxWkdaRVprVTJKWWFHRlhWRUpoV1ZkS1IxTnVUbXBTYkhCWFZGZHdWMDB4V2tWU2JVWnJVbXhhZVZsVldtRlViVXAwWVVoc1dGWnRVVEJWZWtwVFUwWktjbHBIYkZOaVZrcDJWMVpvZDFZd01YTlhibEpyVWpCYVdGUlhjekZYUmxwSVRsVTVWMVl3Y0ZwVlYzTTFWakF4UjFkcmVGWk5WbkJoV2xaa1UxTkdTblJpUlRWb1RWaENZVlpzWTNoa01XeFhWMWhzVkdFeWFITlZiVEZ2V1Zac2NsZHJkRlJTYkVvd1dsVmFUMVl3TVZkalJuQmFWbFp3VUZaSGVHRmpNazVJVW14b1YySkdjRzlYVjNCTFVqRlplRlJzYkdoU2JFcHdWV3BLYjFkV1dsaE5TR2hXWWxaR05Ga3dWbGRWTWtwWlZXeFNWVlpzY0ROV01uaHpZMnh3UlZWc1pGTmhNMEpYVm0weE5HTXhXWGhUYmxKV1YwZFNXVlp0TVZOWFJscHhVMnQwVkZacmNIcFdiVEZ6VjBaS2NtTkdjRmRpVkVJMFZHdGtVbVZHY0VaYVIyaE9UV3hLV2xkV2FIZGpNV3hYVjI1U2JGTkhVbk5aYTJRd1RURlplV1JGT1ZoU01IQllWakkxYzFZd01YRldhM2hZVm14d1RGWXdXbGRqTVVaelYyMW9hRTFZUWxaV01XaDNVakpSZUZOdVNrOVdiV2h3VlcweFUxUXhiSE5hUjNSUFZteHdNRlJWYUd0aE1ERnpVbXBXVjJKWVVtaFdSRVpoVjBaV2RWRnNXbWxXUlZveVZtMXdSMWR0VVhoalJXUlZZa1phVDFadGVGcGxiRmw1WkVkd1QxWXdXbnBWTWpWUFYwZEdjbE50YUZkaVIxSjJXVEo0V21ReFpISmtSM0JPWVROQ1IxWnJaRFJpTWtaR1RWaEtUbE5IYUZoWlYzUkxZVVprVjFwRk5XeFdiRXA1Vm0xNFMyRldXbGRqUmxaWFlsaENTRlY2Ums5V01XUjFVbXhLYVZkR1NsWldSbHBXVFZaT1YxZHNhR3RTYlZKWVZtcENkMU5XV2xoamVsWllZa1pzTmxaWGRHdFpWbHBYWTBoS1YyRnJXbWhhUlZwTFl6Sk9SMXBGTlZOU2JGbDZWbTE0VTFNd01VZFhXR2hZWW14S1ZWbFVTbE5qVmxWM1ZtdDBWMDFYZUZsYVJXaHJZVEpLU1ZGc2FGZE5ha1pJV1ZSR1NtUXdOVlphUjBaVFZtNUNVVlpyWTNoU01EVnpWMnhzWVZKdFVsaFZiR00xVFRGYWRHTkZaRnBXTVVwSVZrYzFTMkZHU25OalNFSlhZVEpSTUZsVldtRmtSMUpIV2tad1YxWkZTVEJYVjNSdlVqRlZlVk5zYkZaaVIyaFlXV3hvVG1WR1VsZFhia3ByVFZad1ZsVnRlR3RVYlVWNlVXdHdXR0V5YUROVlZFWnJVakZrY2xkc1VtbFNNbWhvVjFaa01HUXhUa2RXYmtaVFlYcHNjbFp0Y3pGbFZsRjRWMjEwVjAxVmJEWlpWVnB2VmpKS1ZWRnFVbFZoTVhCNlZtMXplRk5YUmtkaFIyeHBVbGhDTmxac1kzZE5Wa1Y1VkZob1YySnNTbEJXYkZVeFZrWnNjbGR0UmxoV2JrSlhXVlZrTUZZd01VVlNhMXBXWWxob2NsWnFRWGhXTVU1eVlVWmthR0V6UWsxV1ZFSmhWVEZrV0ZKclpHRlNhelZVVm0wMVFrMXNXblJOV0dSVFRWWldOVlpITlU5WlZrNUdZMFpHVjJKVVJsUldSRVp6WXpGd1NFOVdhRmRpUjNjd1ZtcEtORlF4VlhkTlZtaHNVbTFvV0ZacVRsTmpiR1JYVjJ0MGExSnNXbnBaYTFwM1lWWktjMk5IT1ZoV1JXOHdWbXBLVG1WR1duVlRiVVpUWWxkb1ZWZFhkRzlSTVU1eldraE9WMkpZUWxCV2JYaDNaVlpTVjJGRmRHaGlSWEF3V1ZWYWExWldXalpXYTFKWFRVWndhRmt4V2s5amJIQklZMGRzVjFaNmFEVldiRnByVGtkUmVGZFlhRlJpUjFKeFZXNXdjMWRXYkZWU2JVWm9VbXh3UmxVeWN6RmlSa3AxVVd0d1YxWjZSak5XVkVwSFRteGFkVnBHWkZkU1ZYQlpWbGh3UzFOdFZrZGFSbXhvVW0xb2NGVnNVbGRXYkZwSFdrUkNhazFFVmtoV01uUnZZVEZKZWxWc2JGWmhhMG96V2xaYVUyTXhaSFZVYkdocFZsaENTVlpxU1hoaU1XUnlUVlprYWxKc1NsaFVWV1JUVlVaU2RHVkZkR3BOVmxvd1dXdGFUMVJyTVZaWFZFcFhZbFJHTTFWNlFURlRSa3BaWVVab1dGSXhTbEJXYlRFMFpESk9WMVp1VWs1V2VteGhWbTE0UzFZeFdYbE9WM1JZVW10d2Vsa3dhRzlXYXpGMVZWaGtWMDFHY0doWk1uaHJaRmRLU0ZKc1pGZGlhMHAyVmpGYVYyRXhTblJXYTJoVllURndUMVp0TVc5WFZsVjNWbXQwVlZac2NIbFdWM1JyVmtVeGNrMVVWbGRTTTFKb1YxWmFTbVZYUmtkVmJGWlhaV3RhTWxkc1pEUmhNV1JJVld0b1UySllVazlWYTFaaFRteGFjVk5VUmxSTlYxSkpWVEo0WVZkSFNsWlhiR2hhVmpOU1IxcFZXbE5XYkdSMFVtMTBVMDFWY0VwWGExWmhZakZWZVZOc1pGUmhNMEpaVm0xNFlXRkdiRFpTYlhSclVtdHdXbGxyV21GaFZrcHlZMGRvV0ZadFVYZFhWbHBoVWpGa2RWSnNUbWxXVm5CNVZtMHhORk15VmxkVldHaFlZWHBzYjFadGRITk9iR1JWVkcxMFYwMUVSbGhaTUZwdlYyMUdjbGRzVG1GV1ZuQnlXa1phVDJOck5WZGhSazVZVWxWdk1GWnRlRk5STWtWM1RsVmthVkp0VWxkWmExcDNWMVpzZEUxV1RsZFNiRm93V2xWb2EySkdTbk5YYkdoYVZsZE5NVlp0YzNoU1ZrcDFZa1pXYVZKc2NHOVdiWEJIVTIxV2RGSnJiRmhpUjFKdldWUk9RMVJXV2xWU2JVWlRUV3hLUjFReFdtdGhSa3AwWVVaV1ZtSkdXak5WTW5oYVpVWmtjMVJzVWs1V2JGa3dWbXBHYjJNeFdsaFNXR2hxVW5wc1YxbFhjekZrYkZweVYyNU9hazFYVW5sYVJXUXdWR3haZUZOc2JGZGlSMUYzVmtSS1JtUXdNVmRoUmxwcFltdEtXVlpHWkhkV01VNUhWMjVLWVZKWFVuRlphMVV4Wld4c1ZsZHVaRmhTYXpWSFZUSjRjMVl5Um5KVGJXaFlWbXh3WVZwV1drdGpiVXBIVm0xc1UwMVZjRlpXYTFwWFdWWmtjazFWWkdGU2JGcFRXV3hTYzFaR1VsZFhibVJzVm14S1dGWnRNRFZoUmtweVkwWm9WazF1YUhwV2FrcExWMWRHUlZSc2NGZFdia0kyVmtjeE5GTXlVa2hWYTJoclVtMVNjRmxVUW5kVE1WbDRWV3RPYUUxck1UUldiR2h6VmtkS2NtTkdWbHBXUlRWVVZqQmFVMWRGTlZoUFZtaFRZa2hCZDFkVVRuZFNNVmwzVFZaa2FsSnVRbUZaVkVaM1ZrWnNWbFpZYUZoV2ExcDZWVzE0YTJGSFJYZGpTR3hYVWpOU2FGbDZSbHBsUmxwMVZHeG9hVkl5YUhkWFYzaGhVekpXUjFwR2FHdFNNRnB5VkZaVk1WZEdhM2RYYlVaYVZtdHdXVlpYTURWV1ZscHpZMFJPWVZac2NHRmFWbFV4VjFad1IyRkhiRmRXYkd0M1ZqRlNRMkl4YkZkWFdHeFRZbXR3Y1ZWc2FHOVdNV3h6Vld0a1ZsSnNXakJaZWs1dlZqQXhXVkZyYUZoaE1YQlFWbXBCZDJWV1VuRlViR1JwVmtWSk1GZHJVa2RUYlZaSFZXNVdWbUpIVW05VVYzaExZakZhVlZGdFJscFdiVkpJV1d0b1MxbFdTbkpPV0VaV1lsaG9hRlJWV25kV2JVWklaRWRvVGxKRldsbFhWRUpUVVRGc1YxZHNhRlpoTW1oaFZtdFdSMDVHV25GVGF6bFRUV3RhU0ZkclZURmhSMHBIWTBaYVYySllVbkpVYTFwT1pVWk9kVlJ0UmxSU1ZGWlhWMWQwWVZsV1pFZGlTRXBvVWxWd2MxbHJaRk5sYkdSeVZXeE9hRkpVUm5sVWJHaDNWMGRGZVdGR1VsZFdWbkJoV2xaa1IxSnJPVmRhUjJ4VFRXMW9SVll5ZEZOU01XeFlWRmhvYVZKR2NGUlphMXBMVkRGYWRFNVZUbGhXYkhCNFZURlNSMVpyTVZkalJFSldUVzVTY2xaclpFdFRSbFp6VjJ4a2FWSnVRWHBXUmxKSFl6RmFjMXBJVG1wU00xSlBWakJXUzFOV1dYbGtSMFpXVFZaV00xUldXbUZoYkVwWVpVWnNWMkpZYUdoWlZWcGhVbFpLYzFSdGNFNVdhM0ExVm1wS05GUXlSa2hTYWxwWFlrZDRXVlpxVG05a2JHeHhVMnM1VjAxck5VZFdiWGhMVmpGS1YyTkdiRmRTYkhCeVZsUkJlRll4WkhOaFIzaFRZWHBXZGxadE1UQmtNbFp6WVROa1dHSkhVbGxWYlhoelRteGFXRTFYT1ZkaVZscDVWakkxUzFadFJuSlhiR2hhWld0YWNsbDZTa2RUUjBwSVlrWmthRTB3U2pKV2JUQjNaREpSZDAxV1pGTlhSMmhvVld4a1UyRkdWWGRXYm1SWVVteHdlVll5TVVkV01rcEhVMnhzWVZKWGFISldWRUY0VjBkU1JWUnNaRmROTVVwUlZtcENhMU14V25OWGJrWldZa2hDVDFWdE5VTlNWbHB4VTJwU1dsWXdNVFZXUjNSclZXMUtSMk5JUWxkTlIxSjJWbFphWVdSSFZraFNiRlpPWVhwRk1GZFVRbGRpTWtaWFUyNUtUMVo2YkZaV2ExWkxWRVphUlZKdFJtcFdhelY0VlZkNFlWUnNXbGhrZWtKWFlUSk5lRlpVUmxwbFZrcFpZa1phYVZZeWFGaFhWM2hUVW1zeFIySklSbE5pUjFKeVZXeFNSMWRXVVhoWGJUbFhUV3R3U0ZZeGFIZFdNa3BWVWxoa1ZWWlhVa2RhVmxwUFkyeHdTR05HVG1sWFIyaFlWbTB4TkdFeVNYbFZiazVwVW0xU1dGWXdaRzlYVmxaeFVtMUdWRkp0ZUZkV01qRXdWbGRLVmxkdWNGZE5ibWhJVm1wS1IyTnNUblZUYkZwc1lURndVVlpYY0VkWlYxSlhWVzVPVkdKWGVGUlpiWFJMVFRGYWRHTkZUbWhOYTNBd1ZtMDFUMWxXVGtaT1ZtaGFZa1phYUZZd1duTmpNV1IwVW14b1YySklRa3BYVkVKclVqRlpkMDFZU21wU1YyaGhWRlZhVmsxV1duUk5WVnBzVW0xU01GbFZXbGRoVmtwMVVXMDVWMVpGU25KV2FrWktaVWRPUm1GSGJGTldSbHBaVmtaYVYyUnJNWE5YYmxKcVVsaFNVRlZxUWxkT1ZsWjBUbFU1VjFZd1ZqUlpNR2hIVm0xS1ZWSnVXbGRoYTFwNlZqQmtUMDVzU25OWGJFNXBVbGhCTVZadGNFcGxSa2w1VWxob1ZHSkdXbFJaYTJSVFZteFNWMWR1WkZaU2JIQjRWVEowTUZaR1duSlhibWhYVFc1b2NsWkhNVXRqTVU1MVlrWm9XRk5GU2tsWFZsSkhVMjFXUjFWdVRtbFNNbmhVVkZjeGIxWldaRmhrUnpsU1RWZFNXRmRyV205aE1VbDZWVzVDVlZaV1NrUlVhMXBoWkVVMVZscEdXazVoTTBKSVYxUkNiMVF4V1hsVGJHeG9VakpvYUZadGVIZGpiR3Q1WlVkMGExSlViRmxaVlZwclZHeEtjMkV6YkZkaVJuQnhXa1JCTVZZeFpGbGhSbWhvWWtoQ1ZGZFdaRFJUTVdSSFYyNUtWMkp0VWxkVmJYaGhaVVpWZVdSRVFsWk5SRVo1V1RCV2MxZHJNVWRqUmtKYVZteHdhRmt5TVU5U1ZscHpXa1UxVjAxVldYcFdha1poWVRGV2RGWnJaR3BTVjFKb1ZXcEtiMVF4VWxobFJYUllWbXh3TUZwRlpFZFhiRnB6WWtSU1dtRXhjSHBaVjNoTFYwWldkVlJzWkdsWFIyaE5WbXBDWVZsV1pFaFdhMXBRVm0xb1ZGUlZhRU5YUmxwMFRWaGtWazFYVW5sVVZsWnJZV3hPUjJOR2FGcFdNMUpvV1ZWYVUyUkhWa1prUjNCcFZteHdTbFpYTVRSVU1WbDVVMjVLVkdKSVFsaFVWbVJ2VFRGV2NWTnNTbXhTYXpWYVdWVmtSMVpHU25KalNHUlhWbnBDTkZscVJtRlNNVlp6WVVVMVYyRXpRbEJYVjNSaFpEQXhSMVZzWkdoU00xSlhWRlZTUjFkV2NGWlhiVGxYVFd0d1NWbFZhR0ZXTURGSVZXdDRXbVZyV2xCWmVrWlhZekpPUjFwR1RsaFNWV3cxVm0weE5GbFdiRmRpUm1oV1lURndUMVp0TVZOV2JHeHpXa1JTVlUxV2JETldiWFF3VjBkS1NGVnViRmRpVkVWM1ZsUkJlRmRHVm5KaVJscE9ZbXhLZVZkV1pEUlVNVTVYVW01T2FWSnRVazlWYWtwdlVsWmFWVkZ0Um1wTlZuQllWVzE0YzJGR1NuUmhSbEphWVRGd01scFZXbXRXVmtaMFVtMW9UbFpyYjNkV1ZFa3hWREZhU0ZOc1ZtbFNiV2hoVm10V1lWUkdWWGRYYms1WFZtdHdlVnBGWkRCVk1rcEdZMFJXVjAxdVVuSlpha1pXWlZaT2RWTnNVbWxTTTJoWlZsY3hORk14VGtkV1dHeE9WbTFTY1ZSV1pGTk5WbFY1WlVkMGFGWnNjRmhaTUZwM1YwWlplbUZIYUZoV2JIQlFWV3BHZDFOV1RuUmhSazVYVWpOb2IxWnRNSGhOUjAxM1RsaE9WMkpIYUhGYVYzaGhWMVpzY2xkdVpGTk5WbXcxV1RCVk5WWXlSalpTYkdoYVRVZFNkbGRXV2t0V01WcHhWV3hrYVZKdVFsbFhhMVpyVWpGS2NrNVdaR0ZTTW1oUFZGVldWMDVHV25STlZFSmFWbTE0V0ZscldtdGhWa3AwWVVaU1dtRXlVbFJXYkZwelZsWk9jMVJ0Y0ZkaVJtOTNWa1phYWs1V1pITlhibEpzVTBkNFdWbFVTazVOVmxwVlVtdDBhazFYVWpGWmExcHJWRzFHY2xacVRsZGlXRUpEV2xWYWExSXhXblZTYkVwcFZsWndWVlp0Y0VkU01EQjRWMjVPVm1FelVsVlVWbFV4VjBaV2RFNVZaRmhTTUhCSldWVmFiMWR0UlhoalJFNWFZV3RhY2xacVJsZGpiVkpIVkdzMVYxZEZTVEZXYTFwaFdWZE5lRmR1VWxSaVIyaHZWVzE0UzFsV1duSldWRVpUVW14c05GWXlNVEJYUmtsNFYydG9WMUl6YUV4V1IzaExVakZrY21KR1pHaGhNamgzVm0xd1IxWnRWbGRVYmtwWVlsaENWVlZzVWxkWFJtUllaVVpPVTAxV2NFaFdWM2hyVjBkS1ZsZHNWbFpoYTFwb1ZUSjRhMk5zY0VsVWJGcE9Va1ZhUzFaV1pEQmlNV1JIVjJ0YVZHSnNjR2hWYTFaaFdWWndWMWRyT1dwTlZuQjZWa2Q0YTFVeFdsbFJibHBYWWtkUmQxWnFSa3BrTURWV1drWmthV0V4Y0ZWWFYzUnJWVEpPVjFWc1pHaFNWVFZWVlcxNGMwNVdVbGRoUlRsWFlYcEdXRmt3Vm05V01ERjFVV3Q0VjJGcmNFeFdiRnBMVmxaR2MxcEdaRk5XYmtKTlZqSjRWMWxYVVhoVGJrNXFVbGRvY0ZWdGVFdFdSbGwzVm10MFdGWnNiRFJYYTFKRFlVVXhWMVpxVWxoaE1WcHlXVlphVDFKck5WZGhSbkJwVmtWYVZWWnRlR0ZaVjFKR1RWWldWbUpIVWs5V2FrNXZWMFprVjFadGRFNVNiR3d6VkZaV1YxVXlTblJsUjBaVlZsWndNMWxWV21Ga1JURldaRVpvVjJKR2IzaFdWRW8wWWpGWmVWTnJiRkppVkd4WVZXNXdSazFHVmpaVGF6bHJVbXR3ZVZkcldtOWhWbGw1WVVoYVYxSnNjSEZVYkZVeFl6RmtkVlJ0UmxSU01VcFdWa1phWVZJd05VZFdXR2hvVW5wc2IxbHJWbmRYUm10M1YydE9WMDFyY0VoVk1uaHZWakF4UjJOSFJtRlNSVnBvV1RJeFQxTkhWa2RhUjJ4VVVsVlplbFp0ZEdGV01rbDVVMWhvVmxkSGFGVlpiWE14WTBaV2NsZHJkRnBXYlhoV1ZXMDFhMkV5U2tkalJFSmhWbGRSZDFacldrcGtNV1J5WVVaa2FWZEhhSGxXYTJRMFUyMVdSMVJ1UmxSaVIyaFlXV3RhZDJJeFduUk5TR2hXWWxaYVNGZHJhRmRXTWtwV1YyeFNWVlo2Um5aV2JGcHJWMGRTU0ZKdGRFNVNSbHBKVm1wSk1WTXhiRmRUYTFwVVlrWndWbFp0ZUhkTk1WcHhVbXhPVjAxWFVqQmFSV1J2VmpKRmVsRnJhRmRTTTJob1dXcEdhMlJHVG5KaFIyaFRZWHBXYjFaWGRGZFpWMFpIWVROc2JGTkhVbFJaYkZwTFUwWmFXR1ZGT1doV2EzQXhWVlpTUzFZd01WaFZXR1JhVmtWYVMxcFZXbUZYVjBaSFlVWm9VMDF0YUZkV01WcFRVekExUjFwRlpHbFRSVFZ2Vlc1d2MxZEdVbGRoUlU1WFRWZFNlVlpzVWxkaFIwWTJVbXh3VmxZelVqTldha1pMVG14S2RXTkdaRmRTV0VKTlZsUkdZVkl5VWxkalJXUmhVbTFTVDFSVlZuZFViRmw0V2toa1ZFMVdiRFJXTVdodldWWk9SMWRzVWxwaE1Wb3pXVEJhWVdNeFpIVmFSMmhUWWtoQmQxWkdXbE5STWtWM1RWVldVMkV5YUZoVVZ6VlRaR3hzVlZKcmNHeGlSbG93VkRGYVlXRldaRWRUV0hCWFVteHdhRlpxUm10U2F6VlhWMnhXYVZJeFNuZFdiWGh2VVRGc1YxZHVUbUZUUjFKV1ZGWmFkMlZXVWxkWGJYUm9Za1ZzTlZsVldtdFhiRmw2Vlcxb1YwMUdjSGxhVm1SWFUxWndSMVJyTlZoU1ZYQkpWbXRrTkdFeVNYbFRhMmhVWVRKU2NWVnFRbUZYUm14ellVYzVWMUpzVmpWWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVlhSa2RYYkdoWFlrVndUVmRYY0V0VGJWWkhWMjVXVm1KWWFGUldNRnBMWVVaYWRFMVVVbXROYkZwWVZqSTFUMVp0UlhsVmJHUlZWbXhhTTFSVldtRlhSMVpJVDFaa1RsSkZXalJXVjNodllURlplVkp1U2xOaGJFcFlXVmQwZDFWR1ZuTlhhMlJxVFZkU01GbHJXbXRWTVZwMFQwaHNWMkpVUlhkWlZFRXhVakZ3U1ZWc1pHaE5iRXBYVjFjeE1HUXlUa2RXYmxKT1ZtczFXVlZ0ZUdGbGJGbDVUbGQwVldKVmNFbFdWM2gzVjJzeFIxZFlaRmRXUlVZMFZtMHhTMUpXVm5OYVJrNXNZa1p3V2xadE1IZGxSazE0V2tab1UyRXlVbGRaYTJoRFkwWldjVk50T1U1aVJuQjRWVzB4UjJGRk1WaFZhMlJWVm14YVdGWlVTa3RTYlU1R1QxWmthVkl4UmpaV1JsWmhZVEZhVjFKdVRtRlNiVkpQVm0xNFdrMVdXbFZUVkVaV1RWWndNRlV5ZEd0V1IwcElZVWRHV21FeVVuWldSRVozVm14a2RWcEdaRTVXTVVsM1YydFdhMlF5UmxkVFdHaFVZV3hhV0ZWclZtRmhSbHB4VTJ0a1YwMVZOVEZXYlhoTFYwWkplV0ZHYkZkaVZFVXdXa1JLVTJNeVNrbFNiRTVwVTBWS2VsWlhNSGhWTWxaSFYxaHNiRkpVYkZoVVZsWjNWakZyZDFkdVRsaFNiSEF3Vmxab2ExbFdTa1pYYkVKV1lXdGFjbHBHV2t0ak1WSjBZVWQ0YVZkSFp6QldiWFJoV1Zac1dGVlliRmRpYXpWb1ZUQldkMkZHVlhkV1ZFWlhUVlpLVjFaWGRHdFdNREZZWkVST1YwMXFWbkpXYWtGNFkyMU9SbUpHWkZOTk1FcFZWbTE0YTFKdFZsZFdiazVWWWxWYVdGbHJhRU5XVm1SeVYyMUdWazFyTVRSWGEyaFRZVlpKZVdGRk9WVldWbG96V1ZWYVlXTldTblJrUlRsVFlrZDNNRmRYZEdGaU1WcFlVMnRvVm1KSFVtRlpWRXBUVmtaWmVGZHVUbXRTVkVaWVZrZDRWMVJzV25WUldHUllZa1phZGxsVVJtdFNNV1IxVlcxMFUxSnVRbWhXUmxaaFpESk9jMWR1UmxKWFIyaFVWbTEwZDJWV1dYbGxSMFpYVFVSQ00xVXllRmRXTWtwVlVtcGFZVlpYVWxSV01GcExZMjFLU0dOR1RtbFdhM0F5VmpGYVUxSXlVWGxUV0doWVlUSm9UMVpyV2t0V1ZsSlhWMjVrV0ZKc1dqQlViRnBQVm1zeGNtTkZaRlZpUm5CVVZtcEtTMUl5VGtsaVIwWlRVbFp3YjFkWWNFZGtNVTVYWTBWa1ZXRjZWbTlVVmxweVpVWmFkR1JIUm1sTmF6RTBWbXhvYzFVeFpFaGxSemxXVFVaVmVGWnFSbk5qTWtaSVQxWldVMkpJUWpWV2FrbDRVakpHZEZOcmFGWmhhMHBYV1d4U1IyVnNXa2hsUjBaclZtdGFXbGRyV210Vk1rcEhZMFJLV0ZZelFraFdWRXBPWlVaU2MySkhhRk5oZWxaMlYxZDBWMlF4WkhOYVJtUldZVEpTY2xSWGN6RmxiRmw0WVVkMFdsWnJjRmhaTUdoUFZqSktXV0ZIYUdGV00yaHlXVEo0YTJSV2NFZGFSVFZYVjBWS2FGWnNXbXRPUmxsNFYxaHNVMkpyY0ZWWmJHUnZWMFphY2xadFJscFdia0pYVmpJMWExWkdXbk5qUkVKV1lsaG9VRmxWWkZkak1XUnpVbXhrYVZaRlNUQldSM1JyVlRKU1IxWnNiR2hTTUZwVVdXdGFkMVpHWkZobFJtUmFWbXh3ZWxaWGVHdFhSMHB5VGxVNVZWWnNjRXhXTUZwelZteGFjVkZzYUZOaE1uZDZWMVJDVTFFeGJGZFhiR1JxVTBad1dGbHJXbmRaVm5CWVpVVmthbUpWV2tsVmJYaFBWR3N4ZEdGSE9WZE5ibWhvV1ZSR1UyUkdXblZWYkU1b1RXeEtiMVpYZUZOV01rbDRZMFpvYkZJd1dsVlVWbHB6VGtaWmVXVkhkRmhpUm13MFZXMXdWMVpyTVhWVmJscFhWa1ZhY2xVd1pFZFRWa3B6VjJzMVUwMVZWak5XYlhCSFdWWnNXRlJ1VGxoaWJGcG9WV3hTYzJOR1ZuUmtTR1JZVm14d2VGVXhhRzlVYkVwelkwVm9WazFxVmt4V1JFWnJVMGRXU0ZKc1pHbFNNVXBWVjJ4a05GbFdXbGRVYmtwaFVsUnNjRlZ0TlVOT2JHUlZVVzFHYUUxV2JETlVWV2h6WVVaS2RHVkdiRmROUjJoRVZWUkdVMVl4WkhOalIzaFRZbXRLUzFadE1UUlpWMFpJVm01T1dHSklRbGhXYWs1RFUwWldObEp0UmxkTlYxSjVWMnRhYjJGV1pFZFRiRVpYVm5wQ05GWlVSbXRTTVdSMVZXczVWMVpIZUhaV1Z6RXdZekExYzFkc2FHeFNNRnBZVm0xNGQyVnNhM2RWYXpsWFRVUkdXRmt3Wkc5V01ERklWV3hvVmsxSFVsUlZha1ozVW1zMVYxUnNUbGRpYTBwTlZtMHdlRTVIUm5KTlZtUnBVbTFTV1ZZd1pEUldWbXhWVTJ4T2FsWnNWak5aVlZaUFlVWktjMWR1Y0ZoaE1YQlFWbXBHUzJNeFduRlZiR1JPWVd4YWVWWnNVa0psUm1SSFZtNVdhbEp0VWxSYVYzUmhUbXhhZEdSSFJsUk5WbkI2VjJ0YWMyRnNTblJWYmtKWFRVWndURmxxUmxwbFJtUjBVbTF3VGxadGR6QldiVEUwWXpKR1YxTnVTazlYUlVwWFdXeFNWMUpHV2xaWGJVWnJVbFJHU2xsVldtRlViRmw0VTJ4c1dGWXpVbWhaYWtwR1pVWk9jMkpHV21sU01taG9WMVpTUzFWck1VZGpSbVJZWWtoQ2MxWnNVa2RXTVdSeVYyMTBhRlpyY0ZwVlZtaHJWMGRLUjFkdGFGcGxhMXA2Vm1wR2EyTXhjRWRoUm1oVFRWVndiMVp0TVhkVU1WRjNUbFZrV0ZkSFVsbFphMlJUWTFaYWRHUklaR3hpUjNRelZqSXhNRll3TVhKalNHeFdUV3BXYUZacVNrdFhWbFoxVW0xR1YxWnVRa3hYYkZwaFZUSlNWMVZ1VGxaaVYzaFVWRlJLYjAxc1duTlpNMlJzVW14V05WWkhkR3RYUm1SSVZXeG9XbFpGTlZSV2JGcGhaRWRXU1ZSck9WTmlSM2N4VmtaYVUxRXhXWGhYV0dScVVtMW9XRlJYTlc5a2JGcHhVbTFHVDJKR2NIbGFWVnByVkd4SmVGTnJNVmRoYTBweVZXcEdTbVZHV25WVWJYQlRUVzVvVlZkWE1UQlRNVkp6VjI1U2FsSlhVbUZXYlRFMFYwWlZlR0ZIT1ZkTmEzQjVXVEJrYjFadFNsbGhSWGhYVWtWYWVsa3llR3RrVm5CSFlVWmthVkl6WTNoV01uUlhZVEZKZVZKcldrNVdiVkp4Vld0V1MxWXhiSEphUnpscVlrZDRXVnBWVlRWVk1rWTJWbXhvV0dFeGNETlpWbHBLWlZkR1JWTnNhR2xTTVVWM1ZteFNTMVJ0VmtkalJXeFZZa2RvY0ZZd1pHOVhWbHBIVjJ4a2EwMVZOVmhXTVdoellURkpkMWR0T1ZWV00xSm9WakJhV21WWFZrbFViRnBwVmxaWk1sWldaRFJqTVZsNVUyeHNhRkl5YUdGVVZscDNWa1pzTmxKdGRHdFNhM0I2VjJ0Vk1WWXdNVlppZWtKWFlsaENURlJyV2xKbFZrcHpZVVpTYUUxdWFGUlhWM1JyVGtaa1YxZHVSbFZpUlRWdlZXMDFRMUpzVlhsamVsWm9ZWHBHV1ZaWGNFZFdiVXBaWVVaQ1dsWnNjRXRhVlZwUFpGZEdSMkZHWkU1TlZXOTVWbXhhVTFJeFVYaFRXR2hoVTBVMWIxVnNVbGRYVmxaelZXeGtXRlpzY0VoWGExSkRZVEF4Vms1WWNGZGlXR2h5Vm0weFJtVnNWbk5oUmxaWFRURkplbFpVUm1GWlZrNUlWR3RhVUZadFVsaFphMmhEVG14a1ZWRnRkRk5OVjNoWVZqSjRhMkZzU1hsaFIyaFdZbGhvTTFZd1duTk9iRXB6V2tkMFUwMUdjRWhXUjNocll6RlZlRnBGV2xOWFIxSllXV3hTUmsxR2JGaGpNMmhZVW14YVdsbHJXbGRYUmtsNVlVaGtWMVo2UWpSV1ZFWnJWakpLU1ZWdGRGUlNNVXBhVmxjd2VFNUhWbk5YYmxKT1ZsZFNXRlpzVWtkWFJsVjVaVWM1VjAxRVJuaFdiVFZMVmpGYVJsSnFVbGRoYTNCTVZXeGFZV014V25OYVIyeFRWMFZLUjFacVJtRldNa1Y0VkZob1dHSnNTbFpaVkVaM1lqRldkRTFXVGxWTlYzaFpXbFZrUjFReVNrZGpTR2hXVm5wRmQxWlVTa3RXTVdSeVlrWmtVMDB4U2xsV2JYaHJVekZPUjFadVVsQldia0pZVld4U1YxSldXbFZSYlVab1RXc3hORmt3VmxkV2JVcEdUbFU1V2xkSVFrZFVWbHBoVmxaT2NWRnRhRTVXTTJoWlZsUkpNVlV4V25SVGEyUlVZa2RvWVZacVRrNWxSbHBWVW14T1YySkhVakJWYlRFd1ZUQXhWMk5GYkZkaE1sRXdWbFJHVTJNeFpITmlSa3BZVWpGS1dWZFhlRk5TYlZGNFlrWldVMkpWV2xsVmJYTXhaVlpzVmxwRVVsZFNhM0JYV1RCYWIxZEdXblJWYWxwVlZtMVNWRmw2Um10a1ZrNXpZVWRzVjFadVFqUldNV1F3WWpGRmVGTnVUbGhpUjJoelZXNXdjMWRHVWxoa1NHUllVbXhXTlZwVmFHdFhSa2wzWTBWb1YwMXFSblpXYWtaTFVteGtjMXBIUmxkaVNFSlJWMWh3UjJReFNYbFNhMmhwVWpKNGIxUlZhRU5rYkZwMFpFZEdWMDFYZUZsV1ZtaHpWbTFLY2s1WVFsWk5SbG96VmpGYWMxWldVbkpVYlhCcFVtdHdXVll5ZEdGVU1rcElVMnRrYWxKdGVHaFdiRnAzWTJ4YWNWRllhR3BpVlRWSVdWVmFZVlJ0U25SaFJteFhZV3RLY2xWNlJrOVNNVnB6Vm14S2FWTkZTbGxXVjNodlVURldWMXBHYkdwU1dGSldWRlpXZDAxR1ZuUmtSM1JXWWxWd1NWWlhOVU5XYlVwVlZtdFNWVlpGV21oYVJWVjRWbFpXYzJOR1pHbFdhMjh4Vm10YVlWWXlSWGhpUm1SVVltczFXVmxyVlRGWlZteFZVMnhPVjFKdGRETldNbmhQVmpBeFdGVnFSbGRTTTAweFZsUktTMUl4WkZWU2JHUlRUVEpvV0ZaSGVHRmhNVWw0Vkd4c1lWSXpRbFZWTUZaTFlVWmFSMVp0ZEZaTlZUVklWMnRhYTFkSFNrbFJiazVhWVRGd2FGcFZXbUZUUjFaSVpFWmFUbFp1UVhoV1ZtUTBZekZrUjFkcldsaGlWMmhYV2xkMGQxVkdhM2xqZWxaWFRXdGFTVnBGV2s5aFZscHlZMFJPVjJKSFRqTmFSRUV4Vm1zeFNXRkdhRmhTTW1oYVYxZDBhMVV4YkZkWGJsSnNVbGRTVUZWdGVIZFhWbEp6VmxSV1YwMVZiRE5aTUdoM1ZqQXhkV0ZHUWxkTmFrWk1WV3BHVDJSWFRrZGFSVFZUWW10S1ZsWnRNWGRTTWtWNVZXeGthbEpYVW1oVmJYTXhZMFpXZEU1VlNrNVNiSEI2VmxkME1GUXhTbkpOVkZaV1RXNVNjbFpyWkV0amF6VlhZa1p3YVZaRlZYZFdha1poWXpGYVYxTnVWbUZTTTBKd1ZXcE9iMWRXV25GVGFrSk9VakJhZVZSV2FFdFVNVnBZWVVab1dtSkhhSFphUjNoaFkxWk9jMXBIY0dsU1ZGWlhWbFprTkdFeVJsZFRia3BxVWxkNFdWWnRlRXRUUmxWNVRWWmtWMDFXU2pGVk1qRnpWVEpLUm1OSVpGZGlXR2hvV2tSR1lWWXhjRWRhUjJoVVVqRktXVlpHV21GWlZrNUhWMWhzVDFack5WWlphMXAzVTBaVmVVNVZkRmRXYkhCNlZteG9iMVl3TVVkalIyaFhUVWRTV0ZVd1pGTlRSMFpIVkcxb1RtSnRUalZXYlRFMFlUQTFTRk5ZYUZoaVIxSlpXV3RrVTFaV2JGVlRiVGxvVW14d01GcFZhR3RoUmtwMVVXdGtXR0V4VlRGV2ExcExZMjFPU1dOR2FHaE5iRW8yVm14U1MxTXhaRmRoTTNCcFVtMVNjRlZ0TlVObFJtUnpWbTEwVkdKV1draFhhMXB6V1ZaS1ZWWnNhRmRoYTFwTVdsVmFZVmRIVGtaa1IyeE9WbTEzTUZkWGRHOVVNa1pIVTJwYWFWSnRVbGRaYkZKWFVrWlZkMWRzY0d4V01EUXlWbTB4YjJGSFZuSlhiR3hZVmtWS1ZGVlVSbXRqTVdSeldrWmtXRkl5YUZsV1JsWmhaREZTUjFkdVVrNVdWR3hVVkZkek1WTkdaSEphUnpsb1VsUkdlRmxWVWs5V01rWnlWMjFvV0ZadFVrOWFWVnByVjFkR1IxcEhiRk5OTW1nelZteGplRTVHYkZkYVJtUlhZbXRhVlZsc1VuTmpNVlowWlVoa1dGWnVRbGRYYTFKRFZqSkdObEpzYUZwaE1VcFVWakl4Um1WWFJrZFJiR2hYWWtoQ1RWWkhNSGhUTVU1WFUyNU9XR0pYZUZsVmFrcHZaR3hhY2xkc1pGcFdiRlkxVmtab2IxZEhTbkpqUmtaWFlsUkdkbFpyV2xOV2JVWkdWR3hTVjJKV1NscFhhMVpoVkRGYWNrMVdaR2xTUlRWV1ZtMHhiMU5HV2xWU2JYUlVVbXhhZWxsVldtRmhSMFkyVm1wS1YxZElRa2hhUkVaaFl6RndTVk5zUWxkTk1VcFpWa1pXYjFFeFRsZFhibEpPVmtaS2IxUlhkR0ZYUmxWNVRsWmtWbUpWV25wV01uaHZWMjFLU0dGRlVsWmhNWEI2Vm14YVMyTnJOVmhsUms1b1pXeGFhRll4V2xkaE1VbDRWMnRrVkdKR1dsaFphMlEwVjFaYWNWUnNUbXRpUmxwV1ZXMHhNRlV3TVZkalJFWlhVbnBHZGxaVVJtRldWbHB6WWtaa2FWWkZWWGRYYTFKTFZqRkplRmR1VmxaaGVsWllWbXBHUzFkV1drZFdiRTVUVFd4YWVsWnNhSE5oTVU1R1RsWm9WVlpzV25wVWJYaFhWMFV4V0U5V1pFNVdia0pJVjFSQ1YwNUdXWGROVm1oV1lUSm9WMWxYZEhkVFJsWnhVMnM1VkZJd2NFaFdSM014WVZaWmVWVlVSbGRpVkVWM1dWUkJNVkl5U2tkYVIyeFRZbGRvVjFkWGRHdFZNVnB6WWtoU2ExSXdXbGRVVm1RMFYyeHJkMWR0ZEZkTlZYQjZWVEo0YTFZd01YRldia3BYWVRGd2FGbDZTazlUVjBaSFYyczFWMkV6UWtwV2JURXdWbTFXU0ZSdVRtRlRSVFZ2VlcxNGQxUXhiSFJsUlhSc1ZteHdlRlZYTVRCV1JURlhZMGh3V0dFeWFGQlpWVnBMWkZaR2RFOVdWbGRpVjJoRVYyeGtORmxXU1hoV2JrcGhVak5TVDFacVJrdFRiRnAwVFZSQ2FFMXJXbnBWTVdoM1ZtMUdObUpHYUZwV00xSm9Wa1ZhVTJSSFZraGtSbVJYWVRGdmQxZHJWbFpPVmxWM1RWVmthbEp0ZUZoWlYzUjJUVVpzVlZOclpHcE5WVFY2V1d0YVlXRldTWGxoUjJoWFlsaENVRlpVUVhoak1WWnpWMnhvYVdGNlZsbFdiVEV3WkRKV2MyRXpaR0ZTUmtwWFZGZDBXazFzV25SalIwWlhUVVJHTVZaWE5VdFpWa3BHVjIxb1ZtRnJXbEJXTVdSUFUwZEdSMVJ0YkZoU01taGhWbXBHYTA1SFNYaFNXR2hYWVRKU1dGbHJXbUZXUm14WlkwaE9WMUpzU2xsWk0zQkhWVEF4VjJORVFtRldWbFV4V1ZWYVMxWldSbkZVYkZwT1lXeFplbFp0Y0VkWGJWWnpVbTVLVldKR1dsaFphMmhEVkVaa2MxWnRkRlJOVld3MFYydG9UMkZHU1hsaFNFNWFZa2RvZGxSWGVHRmtSVEZKWVVVMVUwMVZXVEJXYWtreFZERmtTRk51VGxSaVJVcFlXVmR6TVZaR1dYZFhiRTVZVWpGS1NsZHJXbXRoVmtwelkwUmFXRlpzV25KVVZWcHJZekZrZFZOdGNGTldNVXBZVjFkMGEySXlVbk5YYmxKT1ZsZFNjVmxyWkZOTlZsVjVUVlZrVmsxcmNFcFZWM2hIVjBaa1NWRnJlRlpoYTFwUVZUQmFUMk5zY0VoU2JFNXBWbXR3TTFZeFdsTlJNazEzVGxaa1dHSnNTazlXYTFaTFdWWmFkRTFVVWxoU2JYaDVWakl4TUZkR1NuUlZhMnhYVmpOTk1WWnRjM2hUUmxaMVYyeGthR0V4Y0RaWFZFbzBaREZKZUZWdVRtaFNiVkp3VmpCa2JrMXNXWGhYYkdSYVZteEdORmRyVm10V1IwcHlUbFpXV21FeVVUQlpWVnBYWXpGd1NFOVhjR2xTTTJnMVZqSjBWMDFHVlhkTlZtUnFVMGRvV0Zsc2FHOVhSbXhYVjJ0MGFrMVdjRnBaVlZwcllWWmtSbE5yTVZkWFNFSklWMVprVTFJeFZuVlRiR2hwVmpKb1ZWZFhkRzlSTVZaSFdrWmtZVkpHU2xsWmJGcGhaV3haZVU1VlpGZFNiVkpKV1ZWYVUxWldXWHBVV0doaFZqTm9jbGt5TVVkU01WSjBZVVpPYUUxdVpEWldiWEJMVGtaVmVGZFliRk5pYTNCWldWUk9iMWRHYkhKWGJtUm9VbXh3ZWxZeWREQmhNVXB5WTBod1YwMXVUWGhaVldSWFl6RmtWVkpzWkdoTlZYQkpWakZhYTFKdFZrZGFTRTVvVW14S2NGVnFTbTlsYkZwWVRWUlNWRTFYZUZoWmExcFhWa2RLUm1OSVNsVldiSEJNV2xaYVdtVlZNVlphUjJoT1ZsZDNNRlpVU2pCak1XeFhVMnhrVjFaRldsaFdhMVpIVGtaV2NWTnJPVk5XYkhCNlYydGFUMVJyTVhSaFNGcFhUVlp3VkZWcVNrWmxSazVaWVVkd1UxWnVRblpXVnpFMFpESkplR05HYUU1V1JrcFpWbTB4VTFkV2NGWlplbFpvVmxSR1JsVlhjRk5YYkZwR1RsaGFWMDFIVWt4VmFrcFBVMVpPYzFac1pFNU5WWEIyVm14a2QxSXhiRmRVYTJoWFlUSjRhRlZ0TVZOVU1XeFZWR3RPVkZKdFVsWlZWekZIWVZVeFYySkVUbFZXYldoWVZtMHhTMk5zWkhOWGJIQm9UVmhCZWxkV1ZtRlpWMDVYVTI1S1VGWXpVbGhaYTFaMlpERmtWVkZ0UmxaTlZsWXpWRlpvVTJGR1NuUmxSbWhWVm0xU1UxUlZXbUZXVmtweVkwZDRVMkpGY0RWV01uUmhZakpHVjFOdVRtcFNiSEJaVm0xNFMxVkdXbFZTYlhSVFRXdHdTRmxyWkhkVk1rcFhVMnhzVjFKc2NISlVhMXBhWlVaa1dXSkZPVmROTVVwWlZrWldVMUl4WkVkaE0yUldZVEpTV0ZsclduZE5SbXhXVldzNVYwMUVSa2haTUdSSFdWWlplbUZHYUdGU2JIQlFXWHBHYTJSSFNrZGFSazVYWW10S2FGWnRjRWRpTWxGNFUxaG9WVmRIZUZkWmEyUlRWbXhzZEdSSVpGWlNiSEF3VkZaYVQyRnNTbk5qUkVKaFVsZG9jbFl3WkV0U01rNUpZa1prVG1KdGFGRldiR1I2WlVaYWNrMVdWbFppUjFKVVZGUktiMlZXV1hoWGJVWlVUV3hLU0ZadE5VOVpWa3AxVVd4b1ZtSkdTbGhXYkZwaFpFZE9SbHBHV2s1V2JYY3dWbXBKTVZZeFdsaFNhbHBwVW14S1lWbFVTbTlTUmxWNVpVZEdWRkl4V2tsVmJURnZWR3hhZEdSNlFsZGhhMXAyV1ZSS1IyTXhUbk5oUjJoVFlsZG9WMVp0Y0U5Uk1XUkhWbTVLV0dKVlduRldiWFJoVjJ4c1ZsZHNUbFpOYTNCSVdXcE9iMVl5Um5KaVJGSldZV3RhVjFwVldrOWpNWEJJWTBaT2JHSllhR0ZXYlRFd1ZqRnNXRkpyWkZkaWExcFZXV3RWTVZaV1ZuUmxSMFpzVm0xNFYxZHJhRTlXYXpGWFkwVm9WMDF1YUhwV2FrWkxZekpPUjJGSFJsTlNWbkI1VjFod1IyRXlVbGRXYmxKcVVtczFXVlZzVm5kVlZscDBUVWhvVGxJd01UTlViRlpyVjBkS2NrNVhPVlpOUmxWNFZqQmFWMk5XUm5WYVJsSlRZbGhSZWxacVNURlVNV1JJVTJ4YWFsSnVRbGhXYWs1U1RVWmFjVk5yZEZoV01GcEpXVlZhZDFSc1duVlJiRlpZWVRGYVYxUnNXbHBsUmxwMVZHeFdhVll6YUZWV2FrSlhVbTFXUjFkdVVrNVhSMUpWVkZWU1YxTkdiSEpYYlRsWFVqQldOVlpYZUZkV01ERklWV3hTVjAxV2NIcFdiRnBQWTFaV2MxcEhiRk5oTTBKYVZtMXdTazFYUlhsU1dHeFVZVEpTY1ZWdGVIZFdNVkpZVGxaS2EwMVdjSGhWVm1odlZqSkdObFpzY0ZwaE1YQXpWa2Q0UzJSV1JuRlRiR1JwVjBWS1RWWlljRWRUYlZaWFZXNUthVkl5YUZSWmJGcExWbFphUjFWcmRHbE5hMncwVmpGb2IxZEhTbFpYYkd4YVlrWndhRlV3V25Ka01WcDFWR3hrVTAxSVFrcFhWbFp2VVRGWmQwMVZaRmhoTTJoWVdXdGFkMk5zV1hkYVJrNVRUVmhDU1ZwRlZURldNREZXWTBad1YyRnJiM2RYVm1SR1pVZEtSMXBHVW1oTldFSldWMWQ0VjFsV1pFZGlSbWhyVWpCYWIxVnROVU5YVm5CV1YyNWthVkpzY0ZaV2JYaHJWbFV4VjJOSVdsZFdSVVkwVlRGYVIyTnRSa2RhUms1T1RXMW5lVlpzWkhkU01XeFhWMWhvWVZOR1dsWlpiR2hEVmtaWmQxcEhPV2xOVm5Bd1dUQlZOV0ZWTVhOWGJuQlhUV3BXVkZscldrcGxiRloxVW14d1dGTkZTalpXYWtaaFl6RmFjMXBJVW10U01taFVWbXRXU21Wc1dsVlRXR2hwVFZac05WVXlkR3RoYkU1R1YyMW9WMkpHY0ROVmVrWjNWbXhrZEdSR2FGZGlhMHBJVmtkNFlXSXhWWGxUYTJ4U1lrZDRXRlJXWkZKa01XeFZVMnR3YkZJd2NFaFhhMlJ6VlRKS1dHRkliRmRXUlVweVZsUkdZVkl4Vm5OYVIyaFRWbFJXV1ZaR1dtRmpNRFZYVld4a1ZtRXdOVzlWYWtKM1ZqRnJkMVp1WkZkaVJtdzJWbGMxWVZZd01YVmhSMmhYVFVad1dGcEdaRTlTTWs1SFdrWmtUbFpZUW1GV2FrWnZaREZKZVZKWWJGVmlSMUpZV1cxek1XRkdWbkZUYWxKWFVteEtXRlp0ZUd0VWF6RlhZa1JTVjAxdWFGQldWekZIVG14S2MyRkdXazVXTW1nMlZtMTBhMUp0VmxkV2JsSm9VbXh3Y0ZZd1pHNWxiR1JWVVcxR1YwMXNTa2RVYkZwaFZsZEtTR0ZJUWxaaGExcE1Wako0WVZJeFduUlBWMnhPVm01Q05WWkdXbUZoTWtaWFUydGtWR0pIYUdGWmExcExWMFphY2xkdVRtcGlSMUo1VkRGYVUxVXlTa2RpTTJoWFlUSlJNRmRXWkVkV01YQkdZVWRvVTJWdGVGbFdWekUwV1ZkR1IyTkZWbE5pVlZweVZXMTBkMlZXYkZaYVJFSldUVVJHTUZsVldsZFdNa3BaVld4b1dGWnNjRXRhVlZwcll6SkdSazVXWkZOaE0wSXpWbXRhWVdFeFZYbFdiR1JXWWtkU1dGbHNVbk5pTVZaMFkzcEdWRkp0ZEROV01qQTFWMGRLUjJKRVdsZFdNMEpRVm1wR1MxWXlUa2hTYlVaWFZtNUJlbFpYTVRSa01VbDRWbTVPWVZJeWFITlphMXB5WlZaYWRHTkZkRTVTTUZZMVZURm9jMVV5UlhoalJUbFhZa2RTVkZrd1dsZGpiR1IxV2tab1UySkZjRnBXUjNocVRsZEdSMU51VW14U2JIQlhXV3hvVTAweGJISlhhM1JxWVhwV1dGa3dXbmRXTVZwMVVXeFdXRlpzY0hKVmFrRXhZekZrZFZWc1FsZGlWa3BaVmtaU1MySXhXbGRYYmxKcVVsZFNiMVJXVm5OT1ZsVjVaRWhPVjJKVmNGcFdWM2hUVmpBeFIyTkZlR0ZXYkhCeVZqQmtVMU5HU25Sa1JUVnBVbTVDU2xadE1IZE5WbFY0Vlc1T1dHSkhhRmRaYkZKelZqRnNjbGRyZEZSU2JHd3pWako0WVdKR1dYZE9WV1JYVWpOb2NsWkhNVVpsYkVaMFVteG9WMkpHY0RKV1dIQkhWMjFXVjFSdVRsZGlSVFZ2VkZSS2IyRkdXa2RhU0dSVFRWWmFTRlpzYUd0V01WcEhWMnhvVlZadFVsUlVWVnB6Vm14d1NFOVdWbWhsYTFwSVYxZDBVMVl4V1hsVGJGWlNZV3hLVmxac1duZGxiRmwzVjJ4T1dGWXdjRWhXTWpGdlZHMUtXR0ZHYkZkTlZuQlVWV3BLVW1WV1VuVlViR1JwWWtWd2VsWlVRbXRWTVdSSFZtNVNUbFpHU25OWmExcHpUbFp3UmxWclRsaFNhMnd6V1RCV2IxZHJNVWRYYmxwWFlXdHdURlpzV2tkV1ZrcHpZMFprYVZKc2EzZFdNVkpMVGtkRmVWUlliRlJoTWxKWldWaHdWMk5HYkhOYVJ6bFBWbXh3TUZrd1ZrOWhSVEZXVFZSV1YxWXphSEpXVkVwTFkyczFXRTlXV21sWFIyaHZWbXBDWVdReFpFaFdhMmhUWVhwV2NGVnFSa3RPVmxsNVpFWk9WazFyV25sVVZscHZWbTFGZVdWR2FGcGlSMmhVV1ZWYWMxWldTbkprUjNSVFRVWndTVlpzWkRSa01rWkdUVlpzVWxkSGVGbFphMXBoWVVaa1YxZHRSbGROVmtveFZXMTRZV0ZXU1hoVGJFSlhZbFJDTkZSVVFYaFdNV1J6Vm14U2FHRXdjSFpXUm1Rd1dWZFdjMVpZYkd0U00xSnZXV3RXZDAxR2JGWlhiWFJZWWtac05sWkdhRzlaVmtsNllVaHdWMkpZYUhKYVJWcExaRWRPUjFwSGFHeGlSbXQ1Vm0weE1HRXdOVWRXV0doWFYwZDRWVmxVU2xOalZsWnlWMjFHV0Zac2NEQmFWV1JIWVcxS1IxTnNaRmROYm1ob1dXdGFZV05yTlZsalJtaG9UVmhDVlZkV1dtRlRiVlowVW10a2FWSnRVbGhhVjNSV1pERlplRmR0ZEZOTlZXdzFWV3hvZDJGV1NsVldiR2hhWWtad1RGWXhXbUZTTVdSMFpFWmFUbEpGV2xsV2FrbzBZakpHZEZadVNsaGlSM2hYV1d4b1RtVkdWbkZTYkZwc1ZqRmFSMWRyV210VWJVVjZVV3hrVjFadFVqTldWRVphWlVaa2NsZHNUbWhpUlhCWVYxWmtNRmxYUmtkWFdHaGhVbGhTVlZWcVJrdFRSbHBJVFZSU2FGWnRVa2xaVldSSFZqSkdjbGR1U2xWaE1YQmhXbFphVjFkWFNrZGFSMnhUVFZWd1lWWnRjRU5oTURWSFZWaG9XR0pzV25GVk1GVXhWMVpXZEdWRmRGaFdia0pIV1ZWa01GWXhTbkpqUkVKaFVsWktVRlpxUmxwbGJGSlZVbXhrVGxJeFNrMVdWM0JMVkRGSmVWSnJaR3BTVkZaVVdWUk9RMVZzV25STlNHUnNVbXN4TkZkcldtOVZNa1Y1WVVjNVZtSlVSbFJXUkVaaFkxWktjbVJHVWxkaVNFSmFWMVJDVjJFeVJYZE5WbHBwVWtaS1lWUlZXbUZrYkd4WFYydDBhbUY2VmxwVlYzaHJZVVV4YzFKcVRsZFNla1V3VjFaa1UxTkdVbkpYYlVaVFltdEtXVmRYZEd0Tk1ERkhWMjVHVkZaRldsVlVWbHBMWld4WmVVNVdUbWhTYTNCNlZUSXhSMWRzV2taalJsSlhZVEZ3YUZsNlJtdGtWbEowWTBkc1ZGSlZjRXBXYlhScVpVZE5lRlZ1VGxoaWEzQnhWVzB4VTFkR1duSldibHBPVW14d1JsVnRNVEJWTURGV1RsUkdWMVo2UlRCV2ExcEtaVzFHUjJOR2FGZGlSWEJKVjJ0U1IxVXhTWGhhU0Vwb1VqTm9WRll3V2t0bFZscFlZMFZrV2xack5YcFphMXBoVjBkS1ZsZHNXbHBpUmxveldsZDRWbVZIUmtsYVJtaFRZa2QzTWxac1kzaGlNV1JIVjI1U1ZtSkZTbWhWYkZwM1ZrWnJlVTFWZEZSU01EVklWa2N4YzFZd01YUmFNMnhYWWxoU2FGZFdaRXBsUmtwWllVWm9hVkl4U205V1Z6QjRWVEZrVjJKSVRtaFNhelZZVm0xNFMxZEdXblJPVjNSVllrVndlbGt3Vm5OWlZrcFlZVVpDVjAxR2NFdGFSRXBQVW0xS1IxcEdaRTVOYldkNVZtcEdZVmxXWkhSV2JrNVhZbXMxYUZWcVFtRldSbFp6VjI1a2JGWnRVbFpWTW5CVFZqQXhjazVZY0ZwTlJscDJXVmQ0UzFaV1duTmhSbkJwVWpKb2VGZHJVa2RaVjA1WFZHNUdVbUpYZUU5V2JURXpUVVphY1ZOcVFtbE5WbkJKVld4b2MyRkdTblJWYlVaYVlrZG9WRlpGV210V01XUjFWRzF3YVZJeFNYaFdNblJoVmpGVmVWTnJhR3RsYTBwWVdWZDBjMDVHVm5GU2JYUlRUVlUxZWxadGVFOWhWa3AxVVd4c1YySlVWak5WYWtGM1pVWmtjbUZIZUZOWFJrcFZWMWQwVmsxV1duTldiR2hzVWpOU2IxVnFRbGRPUm10M1ZXdDBXRkp0VWtwVlYzUnZWakZhTmxKc2FGWmhhMW96VlRGYVUyTXhjRWhpUm1ST1RXMW9WMVpxU2pSaGJWWkdUbFZrV0ZkSGFGbFpiWGhMVkRGYWNsZHJkRnBXYkhCNFZXMHhSMkpIU2tkalJteFZZa1paZDFZd1drcGtNazVHWTBaYVYyVnNXbEZXYlhCTFVqSk9jMXBJU214U2JIQlBWbTAxUW1Wc1dsaE5WRkpvVFd4S1dGa3dWbXRaVmtwVlZtMDVWVlpzY0hsYVZscGhZekZrZEdSRk9WTk5WVmt3Vm1wR2IyTXhXa2hTV0d4b1VtMVNZVlpxVGs1bFJsbDNWMnhrYW1KR2NEQlZiWGgzVmpKS2NsTnNhRmRoYTNBMlZHeGFhMUl4WkZsYVJUbFhWak5vYUZadGVHRmtNVlpIVjJ0b1RsWllVbGxWYWtKaFUxWlJlRmR0ZEZWaVZYQXdXVlZvYzFZeFNuTlhiV2hhWld0YWNsVnFSbGRrVmxwelZtMXNVMDF0YUdGV2JHUjNVekpKZVZOWWFGaGlSMmh6Vlcxek1XTldVbGRYYm1SVVVteHdXVnBWWkRCaFJrcHlZMFprVldKR2NGUldiRnBoWXpKT1JtVkhSbGROTW1oNVYxUkplRkl4U25KUFZtaG9VbXMxY0ZVd1ZrcE5WbGw0Vld0T1dsWXhSalJXTWpWUFYwWmtTVkZzVGxwV1JUVjJWakJhYzFkSFVrbGFSbFpUWWtoQ05sWnFTakJOUm1SSFYyNVdVbUV5YUZsWlZFWjNZMnhhVlZKdFJtdFdhMXA2VlcxNGExUnRTblJoUm14WFRWWndhRlpYTVZkU01rNUdXa2RvVTJKRmNIWldSbVEwVXpGa1YxcEdhR3hTTTFKUVZXcENjMDVHV2xobFJtUldZbFZXTmxaWGVHdFdNa3BaWVVST1ZWWldjRlJXYlRGSFUwZFNTR0pHVG1oTk1Fa3lWbTB3ZUdReFdYaFhia3BPVm0xb2IxVXdXbmRYUm14WVpFaGtWVkp0ZERWYVZXUXdZV3N4V0ZWdWNGcE5SMUo2VmxSS1JtVnNSbFZUYkdScFYwVktSVll4V21Gak1XUkhWbTVLYUZKdFVtOVVWekZ2Vmxaa1dHVkhPV2xOVm5CSVdXdG9TMkZHU2xaT1ZsWmFZVEZ3TTFVd1dtRmtSMVpHVDFaa1RsSkZXbHBXYkdRd1lqRmFjazFZUmxkaVJVcGhWbXBPYjFWR1ZYaFhhMlJyVW10d2VsWnRlR3RXTWtweVUyNWFWMDF1VW5KVWExcHJaRVpXV1dGSGNGTldia0phVjFkNGIySXhaRWRWYkZwWVltMVNWVlJXV25kV2JGVjVZMFpPYUZKVVJubFdNblJ6Vm0xS1NHRklTbGROUm5Cb1ZXMTRUMk15UmtkalIyeFRUVzFvUmxac1VrTlpWMDE0VjJ4a1ZXSnJjRkZXYWs1VFZrWnNWVlJyVGs5V2JHdzFXa1ZrTUZVd01WZFdhbEpYVFc1U2NsWXdaRXRrUmxaellrWmthR0Y2VmxWV2FrSmhaREZLVjFOdVVtdFNNMEpQVm1wR1NtVkdXbk5aTTJoUFVteFdOVlZ0Y0dGV01rcEhZMFpvVm1KWWFETldha1ozVm14YVZWSnNUazVXTVVwaFYxZDBWazVXV1hoWGEyaHNVakpvV0Zsc1VrZE9iRkpYVjJzNVUwMVhVbHBaYTJRMFZUSktWMU5zY0ZoV00yaFlWbXBCTVZZeFpITmhSM2hUWVhwV1dsZFdhSGRTTVU1SFlUTmtZVkpYVW1GV2JYUjNVakZaZVU1VmRGaGhla1o0VlcxNFUxWnJNVWhWYTNoV1lsaE5lRlpxUm5kU2F6VlhXa1prYkdKWFkzaFdiVEIzWlVkUmVGUllaRTVXVjFKWVZqQmtiMWRHV1hkYVJGSlhVbTE0VmxWdE5XdFdWVEZYWWtST1YySlVWbkpXYlhoTFl6SktSVlJzY0ZkV2JIQlJWbXBDWVZsWFVraFdhMlJZWWtad1QxbFhkRVpsUmxwMFkwVmtWRTFyTVRWV1IzUnJXVlpLZEZWck9WcGlWRVoxV2xkNGExZEhVa2hTYkdocFZtdFpNRll5ZEc5VE1rWkhVMjVTVm1KSGFGWldhMVozWkd4d1YxZHRkRmROVm5CNlZqSXhORlV5U2toa2VrWlhZVEpSZDFscVJsZFNNV1IxVld4YWFWWkhlR2hXYlhSWFdWVXdlR0pJUmxOaVdGSllWRlphWVdWV1pISlhibVJYVFd0d1NWcEljRU5XTVZwR1lUTm9WMkZyV21oYVJWcFBZMnhrYzFWdGJGTk5iV2hZVm0weE1GWXhUWGhWYTJSWVlrWndXVmxzVm1GamJGWnpWV3RrVkdKSGVGZFdiRkpIVmxkS1JtTkZaRmROYm1oNlZtcEtSMk50U2paUmJHUm9ZVEZ3YjFaVVFtRlRNbEpYVlc1T1ZtSlhlRzlVVm1oRFYwWmFkRTFJYUU5U01VWTFWVzEwYTFadFNrZGpSbXhhWVRKU1ZGa3hXbE5YUjFKSVVteFNWMkpyU2toV2FrbzBZVEZhV0ZOclpHcFNSVXBvVlRCb1ExTkdXWGRYYlVacVRWZFNNRmxWV25kaFIwVjRZMGhzV0dFeFdtaFZla1pyVjBaT2NscEdhR2xXTTJoVlYxWlNUMUV4WkhOWFdHaFlZa1UxVkZSWGVFZE9WbFowWkVkMFdGSXdjSHBWTWpWUFZtMUdjazVXVWxwTmJtaG9Xa1ZWTVZac1VuTlZiRTVwVTBWS1MxWnJXbUZpTVZGNFYyNUtUbFpXV2xSWmEyUlRXVlpzZEU1VlRsVlNiSEI0VlRKME1GZEdXbk5YYWtaV1lsUkdTRlpxUmxwbFJrNXpWV3hvYVZKdVFtOVdXSEJMVkcxV1NGUnJXbUZTYkhCd1ZXcEtiMVpXV2tkWk0yaHBUVlpzTkZZeU5WTmhiRXBXVGxjNVZWWnNjRmhVYTFwclkyeGtkR1JHYUZOTlNFSTJWbFJKTVZReFduUlNia3BVWWxkb1lWbFhkR0ZYUm5CR1drWmtWRlp1UWtoV1J6RnpWVEpLUjJFemFGZE5ibEpZV1ZSQmVGSXhjRVphUmxKcFlUTkNlRlpVUW10T1JteFhWV3hhV0dKdFVrOVVWbHB6VFRGa2NsWnRSbWxTYkhCNlZqSTFiMVl4U1hwaFNFcFhZV3RhVEZacVNrOVNhekZYV2tkb2FFMVlRblpXYkdSM1V6RlNkRlpzWkZWaWEzQm9WV3BLYjFaR2JITlhhM1JyVFZad1dWcFZZelZWYXpGV1RsaHdWMDFYYUhwWlZFWkxZMnMxVjFac1ZsZGlSbkEyVmtkMFlWWnRWa2hTYTJoUVZtNUNXRmxZY0ZkVFZscHhVMnBTVmsxWFVqQlZiR2h2WVd4S1dXRkhSbFZXVm5BelZqQmFjMDVzVG5KYVJrNXBVbXR2ZDFkc1ZtdGpNVlY1VTI1S1UyRnJOVmhaVkVaM1lVWnNjVk5zU214U2JGb3hWa2Q0YjJGWFNrWmpSbWhZVm5wQmVGVlVSbk5XTWtwSFZteE9hV0pXU25aV1Z6RTBZekF3ZUZwSVNsZGhhMHBZVkZaYWMwMHhhM2RXYms1WFZsUkdXRmt3YUV0WGJGcFlWV3RrWVZKRmNGQlZha3BMVWpGd1IxUnJOVTVXV0VJeVZtcEdVMU50VmtkV2JsSlhZVEpTY1ZWc1pEUldNV3h5VmxSR2FsSnNXbmhWTWpBMVZqRmFkRlZzYkdGU1YwMHhWbGN4UzFZeFNuRlZiR1JPWVd4YVVWWnFRbXRUTVVweVRsWmtWV0pHV2xoWmEyaENaV3hhUjFadFJscFdNVXBIVkd4YVlXRXhTblJoUmxKVlZsZG9RMXBWV21GV01YQkZWVzFzVGxZeFNqWldha1p2WkRGYWRGTnNhR2hTTUZwV1ZtNXdWMlJzVWxWU2JHUnFWbXR3TUZwRlpIZFViR1JHVTJ0d1dHRXhXbWhXUkVaVFl6RmtkVlpzU21oTk1FcFpWMWQ0YjJJeVRuTlZia3BZWWtWd2MxVnRNVk5YYkd4V1YyeE9hRll3V1RKV2JUVnZWakZhTmxKcVdsVldiSEJ5VldwS1MxTldVblJoUms1c1lsaG9ORlp0TUhkTlZrVjRWMWhvV0dKck5WZFpWRXBUVjBaV2RHUklaR3hpUm13MVdsVm9hMWRIU2tkalJtaGFUVVp3ZGxZeWVHRmpNazVHWkVkR1YxWnVRbEZYV0hCTFVqRkplVkpyWkdGU00yaHZWRlprTUU1V1duUmtSMFphVm0xNFdWVnNhRzlXUm1SSVlVZG9WazFHY0doV2JGcHpZMnh3U0U5WGNGTmlTRUkyVm1wSk1XRXhaRWhUYTJScVVtMTRWbFpzWkc5a2JGcEZVbXR3YkZKdFVqRlpNRnByVkcxR2MxZHNWbGRoTVVwSVZqSXhWMk14V25WVWJXaFRZa1p3V1ZadE1UQmtNVTVYVjI1R1UySlZXbkpVVmxaM1pXeGFkRTVWZEZaU2JIQXdWbGR6TlZkc1drWk9WVkpYWVd0YWFGcEZWWGhXVmxaelUyczFWMkpZWTNoV2JHTjNUVlpOZUZaWWJGTmlhelZWV1d0a2IxbFdXbkZVYkU1T1RWWndSMVl5ZUd0aGF6RllWV3BDWVZKWFVqTldSM2hyVW14T2NtSkdaR2hOYXpRd1YxaHdSMVp0VmtkalJWcFlZa1pLYjFSVVJrdFhWbVJZWlVaT1VrMUVWa2haTUZaWFZUSkZlVlZ1U2xaaVdHZ3pXbFphYzFac1pIUlNiV2hYWVRKM01WZFdWbUZXTVdSSFYyNU9WR0V6YUdGWlYzUmhZVVpXY1ZOcmRGUldiRXA2VjJ0a2MxWXhXblZSYlVaWFlrZE9ORlJyV2s1bFJtUjFWR3hrV0ZJemFGQldWM1JoV1Zaa1YxWnVVbXhUUjFKUFZXMTRkMWRXVW5OaFJUbFhUVVJHZVZrd1dtRldiVXBJWVVoS1YyRnJXbWhWYlhoTFkxWldjMXBIYkZkU1ZuQk9WbXhrTkZsV1dYbFVXR3hUWVRKb2IxVnNVbGRqUmxweFUyMDVWVTFXY0RCVVZsSkRWbXN4Vm1KRVVscGhNWEIyVm14a1MyTnRUa2RSYkdScFZrVlZkMVpzVWtkak1rNTBVbXRhVldKSGFGUlphMXAzVG14YWRFMUVSbHBXTUhCSVZqSTFUMkZzU2xoaFJtaFZWak5DU0ZVd1dscGxWMVpIWTBkMFRsSkdXbGxYVmxaaFdWWlNkRkp1VGxoaVJscFlXV3RhWVdGR1dYbE5WbVJxVFZad01WVXllRU5XTWtwWFUyNWtWMVl6UWtoVmFrRXhZekZrY2xwR2FHbFdWbkJvVm0wd2VGVXhUbGRYYmxKclVucHNWMVZ0ZUhOT2JGWllZM3BXVjAxcmNGWldiWFJQV1ZaS1JsZHRhRmROUjFKWVZUQlZOVmRIVGtaT1ZtUnBZVEJaZWxadGVGTlRNREZJVWxob1lWSlhhRlZaYTFwM1YxWnNjMVp0UmxwV2JYaFdWVEo0VDJFeVNrZGpSVnBXWWxSV2NsWnFTa3RUUmxaeFVteGtVMDB5YUhsWFZscGhVMjFXUjFSdVJsaGlSMUpQV1cxNFMyVldaSEpWYTJSV1RXc3hORmRyYUZkV1YwcFpVV3hTVm1KVVZrUldNVnBoVWpGc05sSnNXazVoZWxZMlYxZDBVMWxXVlhsVGExcFBWMFZhVmxadE1XOVNSbFp4VW14d2JGWXhXa2hXUnpGdlZqSkdObFpyYUZkV1JXOHdXa1JHYTFJeFpGbGpSbHBwVmpKb1dsWnRNSGhWTVU1SFZtNUdWR0Y2YkZSWmExcDNaV3hhU0UxWVRsWk5WbkJJVmpKd1YxWXlTa2hVYWxKaFZqTk9ORll3V21Gak1YQklVbXhTVTFkRlNuWldiRkpEVm1zeFYxZFlhRlppUjFKWVdXMHhVMk14V25STlZFSk9UVlpzTlZSc1ZUVldNREZGVW01c1drMUdjRE5XYlhoYVpXMUdSbFZzWkdoaE1YQnZWbGN4TkdFeVRYbFNhMlJZWWxkb2IxUldhRU5PVmxsNVpFZEdXbFpyTVRWV1JtaHZWbGRLY2s1WE9WWmlXRTE0VmtSR2MyTXhjRWhPVlRWVFlraENORlpYTUhoTlJsRjRVMjVPYVZKR1dsaFdiVEZ2Wkd4YWNscEZkR3BoZWxaWVdXdGFkMkZGTVhOVGFrcFlWMGhDU0ZacVNrOVdNVloxVkd4V2FWWXphRkJXYlRBeFVXMVJlRnBJU2xkaVZHeFdWRlphUjA1R1dYbE9WazVwVW10d01GWlhlRzlXTWtwMVVXdG9WazFHY0doWk1WcEhWMWRHU0dOSGJGZFdSbHBLVmpGU1ExbFhSWGhYV0d4WFltczFXVmxZY0VkWFJteHpWV3RPVDFKc1dUSlZiVEZIVmpBeFZrNVVSbGRTZWtaMlZsUktTMVl4VG5OUmJHUlhaV3RHTkZaV1VrZFZNVmw0WTBWa1YySkdTbTlaYTFaM1pWWmFSMWRzV2s1V2F6VklWbXhvYzFReFdsVmlSbWhYWVd0S00xWXhXbmRXYkd3MlZteGtWMkpJUWxwWFZsWlhWVEZrYzFkc1pHcFNNbWhvVld4a1UxZEdWbkZTYkU1cVRWVTFlVlJzV210aFZtUklWR3BPVjJKVVJYZFhWbVJLWlZaS1dXRkdXbGhTTW1odlZsZDRZV1F4VmtkWGJsSk9Wa1pLWVZadE1UUmxiR3hXV1hwV1YxWnJjSHBaTUZaaFZtMUtWVkpyYUZwV2VrWk1WVEJhVjJSWFNraFNiRTVYWW10R05sWnRNWGRUTVUxNFZHeGtVMkpyV2xkWmEyUlRWMFp3V0dSR1pFNU5WbkJJVm0weFIyRkZNVlppUkZKWVlUSm9XRlpzWkV0WFZrWnpWV3hrYUdGNlZqSlhWM0JIV1Zaa1NGWnJhR3RTYkhCUFZteFNWMU5XV25GU2JUbHFUV3R3U0ZVeGFHdFhSMHB5VjIxR1dtRXhjR2hVVkVaWFpFZFdSMk5IZUZkTlZuQktWMnRXWVdFeFVuUlRhMlJxVWtad1dGbFhkSFprTVZweFVteHdiRlpyTlhwV2JYaExZVWRLUm1OR2FGaGlSMUYzVjFaa1QyTXhaRmxhUm1ob1RURktlRmRYZUZkWlZrNUhWMnRvVGxkRk5WZFVWM1IzVTJ4V1dHVklaRmROUkVaWlZsWm9hMWR0Um5KWGEyUmhWbXh3YUZsNlJuZFRSa3B6Vkcxc1dGSXlaekJXYlhoclRrZEZlRlpZYUdsU2JWSlpXVzEwWVZaR2JGVlViRTVYVm14YU1GcFZXbXRVTVZwelUyNXdWMDF1VFRGWlZWcExWbFpLYzFwR2NFNVNia0p2Vm0xd1MxTXhXbGRTYkZaVFlrZFNjRlZ0TlVOaU1WcFlUVlJTVlUxck5UQldiWFJyVjBkR05sWnVRbHBpUjFKMldrZDRXbVZIUmtsYVJrNU9WbTEzTVZacll6RlZNVnBZVWxob2FsSnJTbGhaYkZKSFZrWnJkMWRzWkdwTlYxSXhWVEl4TUZSc1duVlJhbEpYVmtWd00xVlVSbHBrTURGWlUyMXNVMUpyY0ZsV1JtTXhWVEpTYzFkdVNtRlNXRkp4V1Zod1YxZEdXblJsU0dSb1ZtMVNSMVJXVWxOV01rcFpVV3RvV21WclduSlZNRnBYWTJ4a2RHUkdUazVpVjJoV1ZqRmtNR0l4Um5SVldHaGhVMFUxV0Zsc2FGTldSbEpZWkVkR2JGWnNTbGhXTWpWUFZtMUtWbFpxVmxwV1ZuQjJWbTB4UjJOck5WbFhiSEJYVm01Q2IxWlVRbXRXTVU1SFUyNVNhbEl5ZUZoV2ExcGhVMnhaZUZkc1pGcFdNRlkxVlcxMGIxVXhaRWhsU0VwaFZqTlNURll3V21GalZsSnlWR3hTVTJKSGR6RldSbHBoWVRGVmQwMVdiRkpoTTBKWVdXeG9iMVpHYkZaYVJtUnJVakZhU0Zrd1dtdFdNREIzVTJ4R1dGWXpRa2haVkVwT1pVZE9SbHBIUmxOaVNFSjJWa1prTkZNeFpGZGFSbVJvVTBkU1ZGUldaRk5UUm14eVlVVjBXRkl3Y0ZwV1YzaHpWbTFHY2xOc2FGVmlXR2hvVmpCa1YxTldVbk5hUlRWb1RUQkthRlp0ZUdwbFIwbDRZa1prV0ZkSVFtOVZNRlozV1ZaU1dFNVhPV3BpU0VKSFYydGFUMVV3TVZsUmEyUlZZa2RTZGxaSGMzaFNiVTVJVW14a2FWZEhhSGxXUjNSclUyMVdWMU5zYkdoU01GcFVWbXBHUzFkc1pGaE5XSEJPVm14d1dGbHJXbGRXUjBwVllrWnNWbUpZYUV4V01WcHlaREZhZEdSR2FGTmhNMEkyVm1wSk1XSXhXblJUYkd4b1VtdEtZVlpyVm1GaFJtdzJVbXM1YWxaclducFdNakZ6VjBaSmVXRkdTbGRpV0ZKeVdsY3hWMUl4VG5WVmJGWm9UV3hLV2xkWGRHdFZNazVIVm01R1UyRXhjSEpVVm1SVFYxWnJkMVp0ZEZaTmEzQllWakowYjFkck1VZFhibkJYWWtkU1RGVXdaRWRUVmtaelkwZG9UbFp0T1RaV01uaFhXVlpzVjFwRmFGZGhNbEpXV1d4b1ExUXhXblJsUm5CT1VteHdlbGRyVWxOaFJURllWV3RzVm1KSGFETldiVEZMVWpGa2MxcEdjR2xTTW1neVZrWlNSMVV4V25OYVNFNVZZbGhDVDFadE5VSmtNV1J5Vm0xR2FFMVdTbnBXTW5odllUQXdlbEZzYUZwV00xSm9WbXRhVjA1c1NuTmpSM2hYWVhwV05sWnRNVFJoTWtaWFUyeGFhbEp0ZUZsV2FrNXZWa1pXY1ZKc1RsTk5WMUphV1ZWa1IxVXhXWGhUYkZaWVZqTm9hRmRXV2s5U01XUjFWVzE0VTAweFNuWldiVEY2VFZaSmVGWlliRTlXTUZwWVZGZDBkMU5HVlhsa1JrNVhUV3R3VmxWdGVHOVdiVVp5VjJwT1ZtSllhSEpaZWtaSFl6RndTR0pHWkdoTk1FcHZWbTF3UjFsWFNYbFZXR2hZVjBkNFZWWXdaRzlXTVd4eVYyMUdWazFYZUZaV1IzaFBWakpLUjFkcVFtRldWMmh5V1d0a1MxSXlTa1ZXYkZaWFlsZG9lVlp0ZUd0VE1VbDVVMnRXVldKSFVuQldNRlpMVmxaYWRHTkZTbXhTYlZKSlZXMTBjMkZzU25SVmJUbFZWak5vVEZaR1dtRldWa1owWkVaa1RsWlhkekJXYkdNeFZESkdjMU51VWxaaVJrcFlXVlJHZDFsV2NGZFhiVVpxVm10d01GVnRlSGRXTURGRlVsUkNWMDF1VWxoWmFrWmhaRVpLV1dKSGFGTmlSWEJvVjFkMGEySXhTa2RoTTJSWVlrZFNjbFZxUm1GVGJHUnlWbFJXVmsxcmNFcFZWM2gzVmpGS2MxZHNVbFpoYTNCSVZXMXplRll4Y0VkYVIyaG9aV3hhV0ZadE1IZGxSMGw0Vld0a1dGZEhVbWhWYkZwM1l6RmFjVkp0UmxSV2JYaFhWakl4UjJGR1duSmpSRVpXVm0xb00xWnFTa3RTTVdSMFlVWm9WMkpJUWxGV1ZFSmhXVmRPYzFwSVVtdFNhelZQVkZaV2QxZHNXWGhYYkU1VFRXeEdNMVJzYUU5WFJtUklaVWhLVm1GclNtaFpha1pUVjBkU1NGSnNUazVXYTNCWlZtcEpNVlF4V25SVGJGcHFVbXh3WVZsVVJuZGxiRnB4VTJ0MFdGWXdXa2RhVlZwaFZHeEtkVkZ0T1ZoaE1WcFhXbFZhV21WSFRrWmFSbFpvWld4YVdWZFhkR3BPVlRWSFYyNU9WbUV6UW5OVmJYUnpUa1phYzJGSVRsZFNNSEJKV1ZWak5WWnRTbFZXYTFKWFRVWndhRmt4V2xOamJGSnpWMnhPYVZkSFp6QldiRkpMVGtkRmVGZFlaRTVXYldoWFdXMDFRMWxXV25OWGJGcHNVbXh3ZVZZeWRIZGlSbGwzVjJ0b1dsWldjSEpXVkVwTFUxWkdkRTlXYUZoVFJVcEVWa1phWVZOdFZrZGpSV3hWWWxkb1ZGUlVTbTlXVm1SeldUTm9UMUl4U25wV01uUnJWMGRLUjJORk9WZGlXRTE0VmpCYVdtVlhWa2hQVjJ4VFlUTkJkMVpzWkRSaU1WcFhWMWh3Vm1Gck5WaFVWelZ2Wld4YWRHVkdaR3BoZW14WVYydFZNVlV4U2xkalJuQlhUVlpLUkZkV1dsWmxSbkJKVld4a2FXRXpRbHBYVjNocllqSkdSMVp1VG1GU2F6VllWVzE0WVdWR1ZuUk9WM1JXVFd0Wk1sWnRlRzlYUjBWNVZXNXdXbFpXVmpSVk1HUlRVbFphYzFwSGJGaFNWWEJLVmpGYVUxRnRWa2RUV0doWVlrZDRiMVZxU2pSV1JteHpWMnQwV0dKR2NIaFZWekV3WVZVeFdGVnNhRnBoTVhCMldXdGFUMU5HVm5OaFJscHBWa1ZWZDFaR1ZtRmtNVnAwVW10b2ExSnRhRlJaVkU1Q1pERmtjMVp0T1d0TlZtdzBWakZvZDFadFNuSmpSbWhhVmtWYU0xWkZXbmRTYkhCSFZHeE9WMkpJUVhkV1Z6RTBZVEZaZDAxV1dsaFhTRUpZVkZaYWQxWkdWbkZTYXpsclVteGFXbGxWWkVkV1JrcFpVVzVhVjFaNlFqUldWRVpTWlVkS1NWVnRjRTVOYldoUlZsY3hOR1F5Vm5OWGJHaHJVbGhTY0ZWdGRIZGxiR3QzVld0T1YwMVZiRFpXVnpWTFYyeFplbUZGZUdGU1ZuQllXa1phUjJNeFpIUmhSMmhPVjBWS1RsWnFTalJoTURWSFlrWmtZVkpYYUZaWlZFWjNZVVpXZEUxV1RtcFNiSEF3V2xWb2ExZEdXbk5qU0hCWVlURktWRmxYYzNoamJHUnlZVVphVG1Gc1dsVlhWbFpoVkRGS2MxUnVVbE5pU0VKWVZXeGFkMkl4V2tkVmEyUnJUVlZ3V0ZVeU5WTlZNa3BJWVVaU1YyRXhXbWhYVmxwclZsWkdjMWRyTlZkaVIzZDZWa1phVjFZeFdYbFNXR3hzVW0xNFdGbFhjekZXUm14V1YyMUdhbFpyY0hwWGEyUXdWVEpHTmxacVZsaFdNMUpvVlhwS1IxTkdXblZWYlhoVFlsZG9XbFp0Y0U5aU1sSnpZa2hHVWxkSFVuTlZiWGhoWld4WmVXVkhPV2hXTUhCWVZUSjRjMWRHV1hwVmJscFdWa1ZhUzFwVlduZFRWazV6WVVkc1YxSXphREpXYlRCNFRVZFJkMDFWWkdwU1ZscFdXVzB4VTFkV1ZuUmxTRTVQWWtad1dWcFZXazlXTURGeVYyNXNWMDFxUm5aWFZscExWakpPUjFGc2NFNWhhMXBKVmxSQ2ExSXhTWGhXYms1VllsZDRiMVJWYUVOaFJscDBUVlJDV2xac2JEUlphMXB2Vm14a1NHVkdXbHBpV0UxNFZqQmFXbVF4Y0VkVWJXaFRZa1p3TmxZeWRHRlVNVmw0VTI1T1ZHSkhhRmhVVjNCWFkyeHNjbHBGZEZSU01VcEdWa2Q0YjJGRk1YUmhSa1pYWVd0S2FGVjZTazlrUmxKeVdrWm9hVkp1UW5kV1Z6RXdaREZLVjFkdVVtcFNWWEJ6VlcxNGMwNUdXa2hPVlhSb1VtdHdNRmxWV205WGJVVjVZVVZTV2xaV2NISlpla1pyWkVaS2MxcEZOV2hsYkZZelZteGplRTFIUlhoaVJtUlVWMGQ0YjFWc1VuTlhSbEpXVjIxR1ZWSnNTbnBXTWpGSFlXc3hXR1JFV2xoaE1sRXdWbFJLUzFJeFpGVlJiR1JwVW01Q01sZFhjRWRoTVU1SFZHNVdWV0pHU25CVmJGWjNWMVprV0dSSFJsZGlWbHBJVmpKNFlWZEhTbFpYYmtwV1lXdGFhRlV5ZUd0amJGcFZVbXhhVG1FelFraFhWRUpoWWpGa1IxZHVUbGhpYTFwV1dXdGFkMkZHYTNsak0yaFhZa1p3ZWxaSE1YTmhWbVJJWVVad1YyRXhjSEZVVmxwV1pWWldkVlJzYUdsaVJYQjRWa1pTUzJJeVRsZFhibEpzVTBkU2MxbHJXbmRYVm5CV1lVZDBWMDFFUmxkWk1GcHZWMnN4UjFacVVsZGhhMXBoV2xkNFIyTnRSa2RqUm1SVFYwVktWbFpzWkhkU01WRjVWV3hrVjJKck5WWlpiR1EwVmtaU1YxWnVaRlpXYkhCNVZqSjRhMVpyTVZaalNHeFZWbXhhY2xZd1dtdFRSMVpKVTJ4YWFHRjZWbFZXYkZaaFZqSlNSazFXVmxaaVIyaFlXV3RvUTFOc1pITldiWFJPVW14d2VWUldhRXRoYkVwWVpVZG9WMkpIVWs5VVZscGhaRVV4Vm1SR1pGZGhNMEY0Vm1wS05HRXlSa1pOVm14U1lXeHdXVlpyVm5aTlJteFZVMnhPVjAxck5VZFdNbmhEVmpKR05sWnVaRmRXUlVwWVZYcEdhMk14WkhWU2JGSm9ZVEJ3V0ZaR1dtRldNRFZYVm01T2FGSXpVbFpaYTJSVFVqRnJkMWR1VGxoaVJuQkhXVEJhVTFZeVNsbGhSMmhoVWxkU1dGVXhXbmRUUjFaSVlrWk9hV0V3Y0doV2JYUmhXVlpaZDAxVlpGZFhSM2hWV1ZSS2IxWXhiSFJPVlU1YVZteHdlbFl5Tld0VWF6RllaVVprVjJKSGFIWldNRnBoWTJ4a2RXSkdWbGRpU0VKNVYxWldWbVZHV1hsVWEyaFFWbTFTY0ZZd1ZrdFNSbHBIVjIxMFZXSldXa2hXVnpWWFZqSktSMU51UWxaaVJsb3pWakZhYTFkSFZraFNiRkpPVm14d1NWWnFTVEZWTWtwSFUycGFhVkpyTldGWmExcDNZVVpWZDFkc2NHeFdWRlpYV2tWYWIyRkhWbkpUVkVaWVZteGFkbFZxUm1GV01XUjFWRzF3VTJKWGFGZFhWM1JoWkRGWmVHTkdaR0ZTYlZKVlZXcEdTMU5HWkhKWGF6bFZZa1UxUjFVeWRITldNa3BIVTJ0NFZXRXlVa3RhVlZwM1UxWldjMVZ0YUU1aVYyZ3lWbXhrTkZsV1RYaFhXR2hXWWtad1dWbHRNVk5YVmxaMFRWUkNUMUpzYkRWYVJXUXdWMFpLYzJORVJsWldNMUo2VjFaYVlWWXlUa2RSYkhCWFlsWktTRmRyVWt0VU1VcDBWR3RrWVZJeWFHOVVWM0J5Wld4YWNWSnRSbHBXTURFMFYydFdhMVpIU25KalJteGFWMGhDV0Zac1dsZGpWazUwVDFaa2FWSXhTbHBYYTFaclVqSkZkMDFXYUZaaVIyaFlWRmR3VjFOR1duTmFSWFJYVmpCd1NWUXhXbUZoVmxwR1YyeFdWMkZyU21oV01qRlhWbXN4VjFac1NtbFNia0pRVmxkMFYxbFdaSE5YYms1aFUwZFNWRlJXV25OT1JsbDRZVWhrVjFac2NFZFdNbmh2VjJ4WmVsVnFUbGRTVm5Cb1dURmFTMk5yT1ZoalJUVm9UVEJLU2xacVNqQmhNazE0V2tWa1ZHSkdjSEZWYkZwM1YwWlNXRTVXVGxkU2JGcDRWVzE0UzJKR1NuUlZiSEJhWVRGd1ZGbFZWWGhqTVU1elkwWm9WMDB4U25sWFYzQkxWREZKZVZOclpHbFNNMEpVV1d4YVMxZHNXblJOU0doV1RWZFNXRmt3V21GWFIwcFpWV3hzV21FeGNIcFVhMXBhWlZkV1NFOVdaRTVTUlZwYVYxWldiMlF4WkhOWGExcFlZVE5vVjFsWGRHRlZSbXcyVTJ0a1UwMVdjSHBYYTFwcllVVXdkMU5yZEZkaVdGSm9WMVphYzFkR1VsbGhSbWhwWWtWd1ZWZFdVa2RrTWs1elZtNVNUbFpyTlZaVVZscGhaVlphZEUxVlpGZFNNSEJJV1RCb2QxZEhSWGhUYkZKYVZteFdORlpxU2s5VFYwcEhWbXhrYVZKdVFqVldiVEYzVWpGc1YxTnVUbUZUUlRWdlZXMDFRMWRHVWxWU2EzUnBUVmRTVmxVeWNGTmhiVXBYVjJ4c1YxSXpRbWhXVkVwTFUwWldjazlXWkU1U2JIQk5WbFJLTkdFeFpFaFZhMmhyVWpKNFQxWnRkSGRPYkZweVdrUkNXbFpzY0VsVk1uaFhZVlpLZEdGSFJscGhNWEJNVld0YVUxWldTblZhUms1WFlYcFdObFpVU1hoT1JsbDVVMnRrYWxJd1dsaFVWelZUVmpGU1YxZHNjR3hXYXpWNlYydGFVMkZXU25WUmJHeFlWbTFSZDFWNlNrOWpNa3BKVW14T2FWZEdTbFZXUmxwclZURmtjMXBJU21GU1YxSlhWRlpXZDJWV2EzZFhiazVYVFd0d1ZsVlhjRk5XVjBWNVZXeG9WMkZyV25KV01XUkxVbXM1VjFwRk5VNVdXRUpvVm0xNGFtVkZOVWhWV0dST1ZsZFNjVlZ0ZUhkaU1WVjNWbFJHV0ZKc1NsZFdWM1JyWWtaS2MxZHFRbUZTVjAweFZtcEJlR05zWkhWaVJscHBWMFZLVlZadGNFSmxSazVIVm01T2FGSnNjRTlXYWtaTFZWWmFXR05GZEZWTlZXdzBXVEJXYTFsV1NsVldiRkpXWWtaYWVWcEVSbUZrUjA1R1drZG9UbEpGV2twV1YzaHZZakZhVjFwRmFHaFNiRnBZVkZWa1UyUnNXblJsU0U1clVqRmFTVlZ0TVhkV01rcEhZak5rVjFKc2NHaFdSRVpoVm1zeFYyRkhlRk5pV0dodlZtMTRhMVV4VGtkaVNFcFlZbFZhY1ZSWGN6RlNiRlpZWlVoa1ZXSkZjSHBaYTFKUFZqSktXVlZzWkdGV1ZuQmhXbFphVTJOdFNraGpSazVwVmpKb01sWnJXbXBsUjBsNFZXeGtZVkp0VWxsWmJGWmhWbFpzYzFkclpFOVNiVko1V1ZWVk5WWXlTbFpqUld4WFZucFdSRlpxU2tabFIwNUlZVVphYVZKdVFubFhXSEJIWVRKU1IxTnVUbXBTYlZKUFZXdGFXazFzV1hoVmEwNVhUVlpzTkZZeU5WTldSMFY1Vld4V1dsZElRbnBXTUZwelkyeHdTRTlXVGxOaVJXOTNWMnhXWVdReVNrZFhXR2hVWVRKNFZsUldXbmRYUmxwSVRWVmFiRkl3TlVkWmExcHJWakZLV0dSRVVsZGlSa3BNVldwR1NtVkdVblZXYkZwcFZqSm9WVmRYZUdGVE1rWkhXa1prVm1FeVVuSlVWM1JoVTBaYVdHVkdaRlpOYTNCNVZHeG9SMVl5U2xsVmFrNVZWbFp3TTFWdGVHdGtSVGxYVjJzMVUxSldjRWhXYlRCNFRVZEplRmRZWkU1WFJscFhXVzEwZDFsV2JGaGtSMFpYVW01Q1IxWXljelZoYlVwSVZXcENXazFHY0ZCV2FrRjNaVmRHUjJOR1pHbFdSVll6Vm0xd1MxUXlVa2RYYmtwaFVtMW9jRmxVUm5kV1ZtUllaVVprV2xac2NGaFdiVFZUWVRGT1NGVnVUbFppV0doNlZHeGFVMVl5UmtaUFZtUm9aV3RhTlZkVVFtRmpNV1J6VjJ4a2FsTkdjRmhVVlZwM1dWWndXR1ZHWkd0U01GcElWakl4TkdGRk1WbFJhbFpYWWtkU00xVnFTa1psUm5CSFlVWk9hRTFzU25aV1YzQkxUa1prUjFkdVVrOVdWVFZZV1d0YWQyVldXWGxOVldSWVlrWnNORlZ0Y0U5V1ZscHpWMjVLVjJGcmNFeFpla1pQWTJzNVYxcEhhRTVXYmtKT1ZtMHdlRTVIVFhsVVdHaFlZbXMxYUZWc1VuTldSbXh6WVVaS2JHSkdjREJVVlZKSFZsVXhXRlZyYUZaTmFsWlFXVlphUzFJeVRrZGhSbVJvWVhwV01sWnRkR0ZYYlZGNFdraFNVMkpZUWs5WldIQlhVMVpaZVdSSGRGTk5WbXcxVlRKMGMxVnRTa1pYYkd4WFRVZG9SRlpGV2xkT2JFcHlZMGQ0VTJKclNrdFdiR040WXpGVmQwMVlVbWhTYTBwWVZXMTRZVmRHY0VWU2JYUnFUVmRTTVZWdGVFOWhWbHBYWTBoYVYxSnNXbFJWYWtaUFVqRmtjbHBIYUZSU1ZGWllWa1prTUZZd05WZFhiR2hzVW5wc1dGUlZVa2RUVmxwWVpVWk9WMDFFUmxoWk1HaDNWMjFXY21ORmFGWmhhMXBVV2tWa1QxSXhjRWhpUm1oVFRXMU9ORlp0Y0VkWlZsbDRWMWhvVmxkSGFGbFpWRXBUVjFac2RHTjZSbGRTYlhoWldsVldNRmRHV25SbFJscFdUVzVOZUZaSGVHRmpNazVGVVd4d2JHRjZWakpXYlhCQ1pVZE9jazVXV21GU2JXaHZWRlpvUTJJeFduSmFSRkpZWWxaYVdGbHFUbmRoYkVwMFZXNUNWMDFHV2t4Vk1WcGFaVVprZEZKc1VrNWlSWEJKVm10ak1WSXhaRWhUYTFwcVUwVktWMWxzVWxkU1JuQllaVWQwVjAxV1dubFhhMlF3VkcxRmVHTkZiRmROYmxKMlZrUkdhMU5HVG5OWGJHaHBVbTVDVjFadGNFOVVNRFZIVlc1S1dHSklRbk5XYkZKWFZqRlJlRmR0ZEZkTlJFWktWVmQ0ZDFkR1duTlhia1pWWWtad2VsWnFSbXRYVjA1SVlVWk9UbUpYYUZwV2ExcGhXVmRSZUdKR1pHcFNiSEJaV1d4b1UyTnNWbkZTYTNSVFRWWktlbFl5Y3pWaFJscDBWV3RzV2xaV2NETldha3BMVjFaR2NtRkdjR2hoTTBKTVYyeGFZVk15VWxkVmJrNVdZbGQ0Y0ZWc2FFTlhWbGw0V2tSQ2FFMUVWa2haYTFwcllWWktjMWRzVmxwaE1WVjRWakJhVjJSRk1WVlJhemxUWWtkM01WZHNWbFpPVmxsM1RWVldVMkp0ZUZoVVZ6VlRZMnhhY1ZKcmNHeGlWVnBJVmxkNGExWXhTbGxSYXpGWFlsaENTRlpFU2s5V01XUjFWRzFHVTFaR1duZFhWM1JYWkcxV1YxZHVVbXRTYXpWVlZGWldjMDVHVlhoaFJ6bFhWakJ3U1ZwVll6VldiVXBWVW01YVdrMUdjSHBhUldSVFVtMVNSMkZHWkdsVFJVcEtWbXBHYjJReFNYbFNiRnBPVm0xb1YxbFVTbTlYUmxKWVkwWmtWRkpzY0ZsYVZXUXdWa1pKZDFkcmFGcGhNWEJvV1ZaYWExTkhSa2hQVm1Sb1lUSTRkMWRXVWt0VU1rMTRZMFZzVjJKVldsUlpiRnBMVlVaYWRHVkhPVkpOVjFKWVYydGFWMVZ0U2xaWGJrSlZWbTFTVkZVeFdsWmxWMUpJWkVkb2FWSlhkekZYVmxaaFlqRlplVkpZYUZoaGF6VllWbXhhZDJWc1VuUmxSVGxxWVhwc1dGWkhNWE5XUmtwV1kwVjBWMDFXY0ZoWFZscFNaVVpXZFZWc1VtbGlSWEIyVmxkMFZrMVdaRWRpU0VwaFVtdHdUMVZ0TVRSbFJsWjBaRWRHYUUxRVJrWldiWGh2VjBkRmVHTklXbHBXYlZKSVZHMTRZV015UmtkaFJtUnBVbGhDUlZacldtRmhNVTUwVm10a1YySnJOV2hWYlRGdlkwWldjVkpyZEZaV2JIQlpWRlZvYjFack1YTlhiR2hYVFdwV1ZGWkhlR0ZTYkU1MFQxWmFhVmRIWjNwWGJGcGhWVEpOZUZkdVVtdFNiV2h2V2xkMFlWTldaRlZSYlRsclRWWnNNMVJXYUVkVk1rVjZZVVpvVlZac2NETldhMXBhWlVad1JscEdUazVYUlVwSlZqSjBZV0V5UmxoU1dHUnFVakJhV0ZsWGRIWmtNVnB4VW0xR2ExSnNjSGxYYTFwdlYwWkplV0ZHYUZoV2VrVXdWWHBLVG1WR1duVlZhelZYWVhwV2VGWlhNVFJXTURCNFYyNVNhMUpGU2xsWmExcDNaV3hzY2xWc1pGcFdhM0JZV1RCb1MxWXlSbkpqUldoVllsaG9hRmw2U2tkU01YQkdUbFprVG1KWFp6RldiVEV3WVRBMVIySkdaRmhYUjJob1ZUQlZNVll4YkhKaFJVNVlVbXhhZWxZeU5XRmlSMHBIWTBSQ1drMUdXbkpaVjNONFkyc3hWVlZzWkdsV1JscFJWakZhWVZNeFdsZFhia3BRVm0xU2NGWnJXbUZTUm1SeVZXdGtXbFpyYkRSWGEyaFBXVlpLVlZac1VscGlSbkJNVlRGYVlXTldUbFZTYkZKT1ZqRktTbFpVU1RGV01WWjBVMnRvYUZKdGFHRldhazVPWlVad1NHVklTbXhXTVZwSlZXMTRVMVV3TVZkalJXaFlWa1ZLY2xScldsWmxWa3B4VjJ4a2FHSkdjRnBXYlRFMFdWZEdSMkpJUmxSaE1sSllWRlpWTVUxV1duUmxSWFJvVmpCd1dsbFZXbk5XTWtwWlVXeENWbFpGV2xCVmFrWmhWMWRLUms1V1pHbFdhM0JXVm10YVlWWnJNVlpOVm1SWVlteEtjMVZ0TVZOaU1WcDBaVWhrV0ZKdGRETldNbmhyVmpBeGNtTkdjRmRXZWtaMlZqQmFZV015VGtoaFJtUm9ZVEZ3ZVZkVVNqUmtNVWw1VW10b2FWSnJOVTlXYkdoQ1RWWmFkR1JIUmxwV2JIQjVWRlphYTFsV1NsaFZiR3hYVFVkU2RsbHFSbFprTVZwVlVtMXdVMkpHYjNkWGExWnZWREZTY2sxV1pHbFNSbHBXVm0xNFlXTnNXbkZSV0docVlsVTFTRmt3V25kV01WbDVXak53VjJKWWFISlZla1pLWlZaU2NtRkhhRk5pU0VKMlYxWlNUMUV4VGxkWGJGWlRZbFZhVjFSWGMzaE9SbXQzVm0xMFYxWXdXVEpXYlhoVFYyMUZlVlZZWkZWaE1YQm9Xa1ZWZUZaV1ZuUmhSMmhzWVRGd1dsWnNVa2RpTWtsNFdrVm9WR0pyTlZWWmExcExXVlpzYzJGR1RrNU5WM1F6VmpJMWExZEdTWGhUYTJSaFVsWndkbFpVU2t0WFYwWkhXa1prVjJWclJqUlhWbEpIVjIxV1IxUnVWbFZpVjNoVVZXeFNWMWRXWkZoa1IzUnBUV3hLZWxZeGFHdFhSMFY2Vld4b1YyRnJTak5WTUZwelZteGtkR1JHV2s1aVJuQTFWbXBLZDFsV1dYbFRhMlJVWVROb1YxcFhkSGRWUm13MlVtczVhMVpyY0hwV2JURnpWVEF4Vm1OR1JsZE5WMDR6V2xWa1NtVkdjRWRhUm1oWVVqSm9XbGRYZUc5Vk1WcEhZa2hPV0dKVldsVlZiVEV3VFRGYWRFNVZPVmROVm13eldUQldjMWRzV2xoaFJWSlhUV3BHUjFwVldtdGpWbEowVW14a1RrMXRhSFpXYlhCRFZtMVdSMVJzYUZOaE1YQlJWbTF6TVdOR1duUmtTR1JVWWtad01GUlZhR3RVYkZweVlrUlNWMDF1YUhaV2EyUkxVakZrZFZGc1drNVNiSEJ2VmpGYVlXTXhXbGRUYmxaaFVsUldUMVp0TlVKa01XUnpWbTFHV2xZd2NFaFdNV2h2VmtkRmVHTkdaRmRpYmtKSVdrZDRjMVpzY0VkYVIzQnBVakZLTmxkVVFtRmhNa1pYVTFob1ZGZElRbGhXYlhoTFUwWnNWVk5yTld4U2JrSktWa2N4UjFVd01IZFRiRlpYVW0xT05GbHFTa2RTTVdSMVZXczFWMUpyY0hsV1JtUjZUVmRXYzFkdVRtaFNNMUpoVm0xMGQxZFdXbGhsUms1WVlrZFNTbFZYZEc5V01ERkhZMGhLV2sxdWFETlZNRlUxVjBkR1IxUnNaRk5XYmtKTlZtMTRZV0ZyTVZkaVJtUllWMGRTVDFadE1XOWlNVlp5VmxSR1YwMVlRbGxhUldSSFZtc3hXVkZzYUZkTmJtaFFWakJhV21ReFpISmlSbkJPVW01Q1VWWnRjRUprTWxaWVVtdGthRkp0VWs5V2FrWkdaREZrV0dORlpGTmlWbHBJVjJ0b1MxbFdTblJoU0VKYVZrVTFSRll5ZUd0WFIxWkhXa1p3VjJKV1NsbFdha2t4VlRGU2MxZHVTazlXYlhoWVdXeFNWMUpHV25GU2JYUnFZa1p3TUZwRldtdFViRnBaVVd4a1YxWjZSWGRYVmxwYVpWWk9jMkpIYUZSU2JrSlpWMVprTUZJd05VZGhNMmhZWWxWYWNWUldXbUZsYkdSeVYyczVWV0Y2UmpCWlZWcExWakpLUjFOclVscFdSVnBMV2xWYVUyTXhjRWRXYld4b1pXeGFXbFl4WkRCaE1WVjVWR3RrVjFkSFVsaFpWRTVUVmxac2NsZHVaR3hXYlZKNVZsZDBUMWRIU2tkalJFSlhWak5DUkZacVNrdFhWMFpJWVVaa1UxSldjRzlYV0hCTFZERkplRk51VG1GU01taHZWRlJDU21WV1duUmpSVTVhVmpBeE5GWXllR3RXYlVweVkwWmFXbUV4Y0V4V01GcHpZMjFHUmxSck9WTmlTRUpYVmxSSk1XRXhXbkpOV0VwWVlUSlNWbFp0ZUhkamJHeFlaVVYwYTFJd1draFpWVnBYVmpKV2MxZHJWbGhXYkZwb1YxWmtUMVl4VW5WVGJYUlRUVEJLVUZkV2FIZFdNVTV6VjJ4b1RsWkdTbTlVVjNSaFYwWlZlVTVXWkZaaVIxSktWVmQ0YzFkdFJYbFZiRTVWVmxad1lWcFdWWGhXTVU1MFpVWk9UbEpHV2tsV2Frb3dZVEZKZUZaWWJGTmhiSEJZV1cweFUxZEdiSE5WYTFwclRWaENSbFZ0Y3pWV01ERlpVV3RvV0dFeGNISlpWbHBoVmpKT1IxcEdaRk5pU0VKdlZsaHdTMVl5VFhoYVJteHBVbFJzV0Zsc1drdFhSbVJZWlVaa1YwMUVWbnBXTW5odllrWktObUpHYUZkaVdHZ3pXbGQ0Y21ReFZuSlBWbVJPVWtWYVNWZFVRbTlUTVZsNVVtNUtXR0ZyTlZkWmJHaHZZMnh3UmxwR1pGTk5XRUpKV1ZWVk1WUnNTbGhrUkZaWFlsUkdNMVY2UVhoU01rcEhXa1prV0ZJeWFHOVdWM2hyVlRGYVYxZFlaR0ZTUmtwd1ZGWmFZVTFHY0ZaaFIzUllVbXh3ZWxrd2FHOVdNVWw2WVVaQ1dsWldjRXhhUlZwWFl6SkdSMXBGTldoaE1WbDZWbTB4ZDFGdFZraFVibEpWWVRGd2IxVnRNVk5qUmxsM1drYzVWMVp0VWxoV01qRkhWa1V4V0ZWc2FGWmlWRlpRVmxjeFMxTkdWbk5oUjBaWFRURktURlpHVm1GWlYwMTRWbTVLWVZJeWFFOVdiR1F6VFVaa1ZWRnNaR3BOVm5CSlZUSjBiMVp0U2toaFJtUmFZa2RvZGxSVVJscGxSbVIwVW14T1RsWnVRalpXYTJRMFZERlNjMWRZYUZSaE1uaFlXV3hvYjJSc2JEWlRhMlJxVFZVMWVsbFZXbUZoVmtsNVlVZG9WMkZyU25aVlZFWlBVakpPUjFkc2FHbFNNVXA0Vmtaa01GbFdUbGRqUlZwWVlsaFNWbGxyV25kTlZsWllaRWM1V0ZKc2NFZFZNbmh2VmxkRmVHTkhhR0ZTVm5CUVdYcEdZV014VW5SaVJrNVhWMFZLV2xacVJtRmhNREZIWWtab1UyRXlVbkJWYTFwM1ZsWnNWVk5zVGxkU2JFcFlXVlZXVDFVd01WZFRibkJYWWtaS1NGWnFRWGhYUmxaeVdrWmFUbFl5YURaV2JYQkxVekZrVjFKdVNteFNiRnBZVm0wMVExZEdaSE5XYlVaVVRXeEtXRlpITlV0VU1WcDBWVzVDVjJKWVVqTlhWbHBoWkVkT1JsUnRhRTVoTW5jeFZsY3hNR0V4V1hoYVJXaFdZa2RvWVZsc1VrZFdSbGw0VjJ4a2ExSlVSbFpXVnpFMFZqSktTVkZxV2xkaVIxRjNXVlJLUjFOR1RuSlhiWEJVVTBWS2FGWkdWbXRpTURCNFYyNUdVbGRIYUhGV2JYaDNUVlpWZVdWSGRGVmlSWEF4VlZjd05WZEdaRWxSYTNoWFVrVmFURnBGV2t0amJIQklVbXhPVjFKc2NESldNVnBUVWpKUmVGUnVUbGhYUjJoWldXeG9VMk14YkhOWGJVWlVVbXhXTlZwVlpEQlhSa2wzWTBoc1ZXSkhUVEZXYlRGTFZsWktjMVZzY0U1U2JrSlpWMVJHWVZReVVrWlBWbHBRVmpKNFZGUldWbmRYYkZwMFpVZDBUbEl3VmpSV01uaGhWR3hhYzJOSVJsWk5SMUV3Vm0xNGMyTnNaSFZhUjNCcFVqRktXVlpxU2pCTlIwVjRWMjVLV0dGcldsZFdhazV2WVVac1YxZHRkRlJTYlRrMldUQmFiMVl3TUhkVGEyeFlWbXhLVEZaSE1WZFRSbEp5VjJ4a2FWSnVRbmRXYWtKWFV6SlJlRmR1VWs1V1JVcFpXVmh3UjFOR1dYaGhTRTVvVFZWdk1sbHJXbXRXVmxwelkwZG9WazFHY0dGYVZsVXhWakZTZEdGR1RtaGxiRnBKVm14U1MwNUhTWGhhU0ZKVFYwZDRWMWx0ZUhkV01XeFZVbTVrVjAxWVFsaFhhMXByVmtaSmVGTnJhRmhoTVZWNFZtcEtTMk5zVGxWVGJHUm9ZVEk1TTFZeFdtRmpNVmw0Vm01V1ZXSkhhSEJaYTFwM1ZrWmtWMXBFVWxwV2JWSklWbTAxVTJKR1RraFZiR3hXWWxSRk1GWnRlRlpsVjFKSVpFZG9hR1ZyV2xsV1ZFa3hZekZaZDAxWVJsTmhhelZZVm10V2QxUkdXWGRhUldSVVVqQmFTRmRyWkhOWFJrcFdZMFpLVjJKWWFGUlZla1pLWlVaT1dXSkdUbGhUUlVwM1ZsZHdUMkl4V2xkV2JrWlRZVE5TV0ZadE1WTlhWbkJHV1hwV1ZtRjZSbGRVYkZadlZqQXhkVlZ1V2xwaE1YQk1WbXhrUzFJeFpITmpSMnhUWWtoQ1dsWnJaREJaVjA1MFZWaG9XR0pzV2xaWmEyUlRWREZzVlZKc2NFNVdiSEI1VjJ0b2ExWnJNVmhWYWtKV1lsUldURll3WkV0U01VNTBVbXhXVjJWc1dsRldSM1JoV1ZkU1NGWnJhR3RTTTFKVVZGVmFkMU5HV2tobFJscE9WakJhV0ZZeGFITmhSa2wzVjJ4b1dsWXpVbWhaVlZwelZsWkdXV0ZHVGs1aE0wSkpWMVpXWVZReVJrWk5XRTVVWWtoQ1dWWnVjRVprTVdSWFYyMUdWMDFyY0VoV2JYaFBZVmRLVjFOdWFGZFNiSEJvV2tSQmVGSXlUa2RYYlVaVFZqRktXbFpYY0VOa01VNVhZMFphV0dKWVVsaFVWVkpIWlVaV2MyRkhkRmROUkVaSVdUQldORmRyTVhGU2EzaFdZa1p3V0ZsNlJtdGphelZZWWtkc1YwMXRhRWhXYlRCM1pVZFJlRlJZYUZSWFIzaFdXVzF6TVZac2JIUmxSWFJwVFZaYU1GUldZelZYUmtwMFpVaHdWMDF1VVhkV2JGcExaRVpXZFdOR1pHbFdSVnBKVm1wS05GZHRWa2RVYms1b1VtMVNjRlpyV21GVVZscHlWV3RrV2xZeFNraFdiVFZQVm0xS1NWRnNhRlppUmtwWVZXeGFXbVZHWkhSU2JIQlhUVVJGTUZkV1VrOWtNV3hYVTFod2FGSnNTbGhaVkVaM1lVWlZlRmRzY0d4V01VcEpWVzB4YjFSdFJYaGpSRnBYVmtWdk1GbFVTa2RqTVU1MVZXMW9VMDFHY0ZsWFZtUjZUVlphUjFkcldsaGlTRUp6VlcweFUyVnNaSEphUkVKV1RVUkdWMWt3VmpCV01ERjFWVzVLVldFeVVraFdha1pQWkZaV2RHUkhlR2hOU0VKYVZqRmtNR0V4Vm5SVldHaFdZa1p3V1ZscmFFTmpNVnAwWTNwR2JHSkdiRFZVVm1oclZtc3hjbU5JYkZaTmJtaDZWbXBHWVU1c1NsVlJiRnBzWVRGd1VWWlhjRWRoTWxKWFUyNU9WV0pYZUZoV2JUVkRWbXhaZUZwRVFsZE5iRVkxVm0xMGExZEhTa2hoU0U1V1lXczFWRlp0ZUhOamJGcDFXa1UxVjJKR2NGcFhiRlp2VkRGa1IxTnVUbXBTVjFKWVZGZHdSMlJzV25STlZtUnFZbFUxUjFReFpFZFdNVmw0VTJ4R1YxWjZSVEJhUkVaUFVqRk9kVlJzVm1obGJGcFFWMWQ0YTJKdFZsZFhibEpyVWpCYVlWWnRNVFJYUm1SeVlVWk9WMDFyY0hsVWJGcHpWMjFLV1dGRmVGZFNSVnBvV1RKNGEyTnRVa2RhUlRWWFlUTkNXbFp0TUhkbFJrbDRWVzVPVkdKck5YRlZiVEZ2V1ZaYWMxcEhPVlpTYkhCNFZWWm9iMkZ0U2tkalNHaFhZbGhvY2xacVFYZGxWMFpJVDFaa2FHRXlkekJXV0hCSFlURlplRlp1VG1sU01taFVXV3hhUzJSc1drZFhiVGxTVFVSV2VsZHJXbGRXUjBaelUyNUtWVlpzV25wVWExcGhWMFUxVms5WGFGTmhNMEkxVmtkNGIxRXhXblJUYTJob1VsWktXRlJWV25kaFJtdzJVbTEwYTFJeFNrZFViRnBQVmpGS1YyTkZjRmRpVkVVd1dXcEtTbVZHY0VaaFJsSnBZVE5DVVZacVFsZFpWbGw0WWtaV1UySlZXbFpWYlRGVFYwWlplV1ZGT1ZkTmEzQkpWbGR3UTFadFNsbGhSbWhYVmtWd1RGVXhXa2RqYlU1SFlVZHNVMkpJUWpWV2JHUjNVekZKZVZWclpGVmlhelZaV1d4b1ExWkdXblJPVlU1WVZteHdNRmt3VlRWaFZURnpVMjV3V21FeGNHaFdha1pyVTBkR1NWTnNXbWhoTUhCdlZsUkNZVll5VWtoV2EyaFFWbTFTVDFsVVRrTlRWbVJWVVcxd1QxWnNiRFJYYTFaelZXMUZlV0ZHYkZkaVdHZ3pXVEo0VjJOV1NuTlViWFJYWVhwVmQxWlhNVFJVTVZKMFUyeG9hRkpzY0ZoVVZtUlNUVVprVjFkck5XeFdiRm94VmtkNGIyRkZNWE5UYlRsWFZqTlNhRlY2Um1GU01rcEpWR3hvYUUxc1NsRldWekUwWXpBMVYxVnVUbGRpV0ZKWVZGWldjMDB4V1hsT1dHUlhZWHBHZUZWdGRHOVdNa1p5WTBWNFYySkdjRXhaZWtaWFl6RmtkR0ZIYUU1WFJVcFhWbTB3ZUdReFNYaGlSbWhXWWtkU1YxbHRlRXRpTVZaMFkzcEdhVTFXU2xaVlYzUjNWRzFLUjJKRVVsZFdNMUpRVm1wS1IwNXNXbk5oUm1ST1ZqSm9ObFp0ZEd0U2JWWlhWbTVPVjJKSVFtOVVWM2hMVFd4YWNWRnRSbFpOVm13MFYydG9WMWxXU1hwUmJrSldZbFJXUkZSdGVHRmpWazV4VVcxb1RtRXhXVEJXVkVreFV6SkdjMVJyYkZKaVZWcFdWbXhhZDAweGEzbGxTRTVYVFZkU01GVnRNWGRoVmxwWlVXdGtWMkV5VVRCWlZFcEhWakZrY2xkc1VsaFRSVXBaVmxjeE5HUXlSa2RYYkdoT1ZtMVNWRlJYY3pGU01WbDVUVmM1VmsxcmNFZFpNR2hoVmpGS2RGUnFVbHBoYTNCVVdYcEdhMk15UmtoalJrNVhWa1phYjFadE1IZGxSVFZIV2tWa2FWTkZjRmxaYTJSVFZqRlNXR1JJWkU1U2JIQlpWRlZTVjFZeVNsWmpSbkJhVmxkb00xWnNXbUZTYkdSMFVtMUdWMkpXU2xsV1Z6RjZUbFprU0ZKcmFHbFNiVkpaVld4V2QxUkdXblJOVkZKb1lYcEdXVlpXYUc5WlZrNUdZMFU1VjJKSFVuWldha1poWTJ4YWNtUkdhRk5pV0doYVYydFdWMkV4VVhoVGJrNVlZbTVDV0ZSWGNFZFRSbXhZVFZWMFYySkhVbmxaVlZwdllVVXhXVkZzUmxkaVJrcElWMVprVTFZeFNuVldiR2hwVWpGS1VGWnRNREZSTVZwWFYyeG9hbEpYVWxoWmJGcGhWMFphV0dWSVRtaFNhM0I2VmpJMVExZHNXa1pPVlZKWFRXNW9jbFl3WkZOVFIxSklZa1UxYUUxdVkzZFdiWGhyVGtkSmVGVllhRmhoYkhCd1ZXMHhORmxXYkZWU2JtUk9UVlpLVjFZeU5XdFZNa3BJVldwQ1lWSldjSEpXVkVaaFVteGtjVlpzWkdoaE1qa3pWMWR3UjFkdFVYZE5WbXhYWWxkb1ZGbHNaRzlYVmxwMFpFWmthMDFXU2toV2JHaHZWMGRGZVZWdVNsZGlXR2hNV2xkNGEyTnNjRWxVYkdoVFlUTkNOVmRYZEZOWlZsbDVVbGhvYWxJeWFGbFdiWGgzWVVad1JsZHRSbXBOYTFwSVYydGtiMVJ0U2xoaFJrNVhZbFJHTTFWNlNrcGxSbkJHV2taYWFWSnVRbHBYVjNSdlVURlJlR0pJU2xoaWJWSlpWVzB4VTFac1draE5WRUpYVmxSR1dGa3dhSGRYYlVWNFUyeFNWMkZyUmpSYVJscEhaRWRHUjFwR1pGTldia0oyVm14amVFNUdVWGxWYTJoVFlUSlNXVmxzWkc5VU1WcDBUbFZPVkdKR2NIbFdNbmhQVlRBeGMxSnFVbGROYWxaUVYxWmFUMUl4VG5OVmJIQm9UV3hLTWxacVFtRmpNbEpJVld0YWExSnNTbkJWYlRWRFYyeGFSMWRzVGxaTlZuQlhWRlphYTJGV1NrWk9WbHBYWWxob00xbFZXbk5YUjFaR1pFZHdUbUY2VmtsWFZsWmhaREZaZUZOc1pHbE5NMEpaVm0xNFlXRkdiRlZTYkhCc1VtNUNTbFV5Y3pWV01EQjRVMnhDVjFZelVsaFhWbHByVWpGa1dXSkhkRk5OTVVwNFZrWmFZV1F4VGtkV1dHeHNVMFUxVjFsc1ZuZFRiRlpZWlVoT1YwMXJjRlpWYlRWaFZsWmFSbGR1Y0ZWaVdHaFFXVEl4VDFOSFZrZFViV3hYWVRKM01GWnRNVFJoTWxaeVRWWmtXRmRIZUZSWlYzaDNWMFpzY2xkdVpGaFNiSEF4V1RCV1lWUnNTblJWYkdoWVlURndjbGxYYzNoamJVNUdZVVprVG1KdFozcFhWM1JyVXpGSmVWUnJaR2xTYlZKVVdXdGFkMVpXV2xoalJYUlhUVlpzTlZWc2FIZFpWa3AwWVVoQ1YySkdjRE5XTVZwclYwZFdSMXBIZEU1V1ZGWkpWbTE0YjJNeVJYaFRia3BQVm0xb1ZsWnNXa3RUUmxKWFYyNU9WMkpJUWtsVU1WcHJWakF4U1ZGdFJsaFdiRnBZVkd0YWEyUkdXblZUYlhCVFZqSm9XRmRXWkRCWlYwNXpZMFZhWVZKWVVsUlVWM1JoVTBaYVNHVkhkRlpOYTFZMFdXdFNZVll5U2xWUmFrNWhVa1Z3VTFwV1dtRmpiR1J5VDFaa1YwMXRhRlpXYlhCRFlUQTFSMWR1VG1sVFJrcHlWVEJrVTFZeFZuUmxTR1JPVW14S1dGWXljelZoUmtweVkwaHdWMDF1UWtSV2JGcGhZekpPUjFGc1pHbFNiRmt3Vm1wQ2ExWXhUbGhVYTJSb1VqSm9UMWxZY0VOT1JscDBUVmhrVW1KV1draFdNV2h6VmxkRmVXVkhPVlppV0dneldUQmFZV05zV25OalIzaHBVakZLV2xkclZtdFNNVnBHVFZaa2FsSnRhRmRVVjNCWFZFWnNWMWRyZEd0U2JGcDZXVlZhZDJGV1NYaFRha3BYVW0xUk1GZFdaRk5TYXpGWFZteGFhVll5YUZCV2JYaFRWakZPYzFkc2FFNVdSVXB2VkZkMFlWZEdWWGxPVm1SV1lsVndlVlV5ZUc5V1ZscFlWV3hTWVZJemFHaFZha1pyWkVaS2RHTkhiRk5pU0VFeFZtcEtNRmxYVVhoWFdHUk9WbXh3Y1ZWc2FFTlhSbXhWVTJ4T1RrMVhVbGhXTW5oaFlrWmFjazVZYkZwV1YxSjJWbFJLUzFKdFRraGhSbWhYWWtWd1RWZFhjRWRTYlZaSVZHdGFWMkpGTlhCV2JGcDNWbFphUjFkdGRGWk5iRnA2VmpKMGIySkdTWGRYYkZwYVlURndlbFJyV2xabFYxSkpWR3hrVG1FeGNEVlhWbEpQWWpGWmVWSnVTbGhpUjJob1ZXeGFkMVJHV1hoYVJYUlRUVmRTTUZscldrOVVhekYwWVVoYVYySlVRalJVVlZwYVpVZEtSMkZHVG1oTmJFcDJWa1pTUzA1SFRYaFdibEpQVmxVMWNWbHJXa3RYUm1SeVYyczVhVkpzY0RGVlYzUnJWMGRGZVdGSVNscFdWbkJvV1hwS1QxSXhaSE5hUjJ4WVVtdFplbFp0Y0VOWlZteFhVMjVPVldKc1NtOVZha0poVmtaV2MxZHVaRmRXYlZKYVdUQldhMVpWTVZoVmJHeFdUVzVTZGxsVldrdGphelZYVld4a1RsSnNjRTFXYWtvMFYyMVdSMk5GVmxaaVYzaFBWbXhhV2sxR1duSmFSRUpvVFZac05WVnROVTloYkVweVRsWm9XbFpGV21oWlZWcHlaVVprYzFSc1pFNVdia0Y0VmpKMGEwNUhSbGRUYmxaU1YwZFNXVmxyV21GV01WSnpXa1ZrVTAxWFVqRlZNakZ6VlRGS2NtTkdhRmRTYlUxNFdXcEtWMk14WkhWU2JFNXBVMFZLZWxkWGVGZFpWazVYWWtaYVlWSlhVbGRVVmxaM1YwWnJkMWRzWkZkTmEzQmFWVmQwYjFsV1NrWlhhM1JoVm14d1VGa3lNVWRUUjA1SFZHMW9iR0pHY0doV2JYaHFaVVV4U0ZWWWFHRlNWMUpaV1cxMGQxZFdiSE5XYlVaWVVtMTRXbGt3Vm10WFJrcDBWVzVzVjAxcVJYZFdha0Y0WTIxT1NXTkdXazVoYkZwTlZtMHdlRkl5VG5KT1ZtUldZa2RTVDFadE5VTlhWbVJWVW0xR1UwMXJNVFZXUjNSaFZERlplV1ZHVWxwaVdGSklWRlJHWVdOc2NFVlZiR1JPVm10Wk1GWXlkRmRpTVZwSVUydGthbEp0YUdGV2FrNXZWRVpaZDFkc1RsaFNNRFZIVjJ0YVUxVXlTbGRUYkd4WFlXdHZNRnBFU2t0VFJrNXpWMnhvYUUxdWFHaFdiWGhyVlRGT1IxZHNWbE5pU0VKelZXMXpNV1ZzYkhKWGJYUlhUVVJDTTFVeWRITldNa3BIVTJ0NFYxSjZSbGhWYWtaWFpGWmFjMWR0YkZkTk1taFdWakZrTkZsV1RYbFZXR2hZWWtaYVUxbHJaRk5XVmxKWFYydDBWRkpzYkRWVWJGcFBWbGRLUjJORlpGWk5ha0V4VmpKNGExTldSbkpoUm1ST1VtNUNiMVpYY0V0U01VNUdUMVprWVZJeWVGUlVWbFozVXpGWmVGZHNaRnBXTURFMFYydG9VMVpIU2tobFJscFhUVWRTZGxkV1dsTldNV1IxV2tab1UySnJTa2xXTW5SV1RsWmFSMWR1VGxSaWJrSlpXVlJHVm1WR1duRlJXR1JzVm01Qk1sVXllR3RoVm1SSVlVaHNWMUl6VW5KVmJURlhVakZrYzJKSGFGTmlSWEIzVjFkMFYyUXlWbk5YYkZaU1lsaFNjRlJXV25OT1JteHlZVVU1YUZKcmJ6SlphMXByVm0xS1dXRkVUbUZXVm5CWVZtcEtSMU5GT1ZoaFIyeFhWMFZLUzFadGVHcE5WMDE0V2tWb1UxZEhhSEZWTUZaM1YwWmFjbFpyWkU1TldFSkdWVlpvYjFZeFduTlhibkJhVmxad2NsbFdXazlTYkU1MVYyeGthVkl5WjNwV1dIQkhWbTFXUjFwR2JHaFNiRXB3V1Zod1YyUXhXbGhqUlU1YVZteHdTRmxyYUU5WlZrbzJZa1pzVjJKWWFETldNVnAzVm14a2RHUkhhRTVTUlZwYVZteGtOR0l4V1hkTldGWm9VMGhDWVZacVRtOVVSbGw0VjJ4a2FrMVdXbnBaTUdSelZUSktjbE5yY0ZkaE1YQlVWV3BHVm1WR1pGbGhSMFpVVW14d1YxZFhkR3RWTVdSSFZXeGFhRkpWTlZWWmEyUlRWMFphZEUxWVpGVk5WbkI2V1RCYWIxWXdNWFZSYldoWFZrVndURmw2U2s5U01rWkhWbXhrYVZORlJqWldNVnBYV1Zaa2RGVllhRmhpUmxwVVdXdGtiMWRHYkhSa1JYUlVWbXhzTlZwRldtRlViRnB6WWtSU1YwMXVVbkpXTUdSR1pXeEdjMkZHY0dsU01taEZWbGh3UjFVeFdYaGFTRXBQVmpOb1ZGUlZhRU5UVmxsNVpFZEdWazFyV2xoVk1XaDNZVVpLZEdGR2JGZGhhelZVV1ZWYWExWXhaSE5qUjNoVFRVaENTMVpyWTNoaU1WVjVWbTVTYkZOR2NGaFdibkJDWlVaV1ZWSnRkRmROYXpWSVZqSXhiMVV4V2tobFJteFhVbTFSZDFwRVJrOVdNV1J6WVVkd1UxWXhTbHBXVjNCRFZqQTFWMWRzYUU5V01GcFlWRlphZDFJeFdYbE5WemxYWWxWd1dsbFZhRXRYYlZaeVkwVjRWbUZyY0VoVmFrWjNVbXMxVms1V1RsaFNWWEJWVm0weGQxTXdNVWRXV0doVVYwZG9hRlV3V2t0WFJteFZVMnhPYUZKc1ZqTldiVFZyVjBaYWRHVkliRmhoTWsweFdWZDRTMk15VGtsaFJscE9ZV3RGZUZkV1ZtRlRNazE1Vkd0V1VtSlZXbFJXYlRWRFpWWmFjVk5xVWxwV01VcEpWbTEwYTJGR1NuVlJhemxXWWxSV1JGbHFSbUZqVmtaMFpFWlNUbFp1UWpaV01uUnZWakZhU0ZOcmFGWmlhMHBZVkZWYVYwNUdVbkpYYlVaVFRWWndNRlZ0ZUd0VWJVcEdZMFZ3VjJKVVJYZFhWbHBYVWpGa1dXSkhhRk5pVjJob1YxWlNTMVZ0Vm5OVmJHUllZbGhTV0ZSV1duZGxiRnBJWlVaa1ZXSkdjREJhU0hCSFZqRmFSbUo2UWxkaGExcFlXa1ZhUzJSV1VuTlZiV3hUWW10S2IxWnRNVEJXTWxGNFYydGtXR0pHV2xSWmJURlRWMFpzY2xwR1RteGlSbkJKVkZab2ExWlhTa2hWYTJSV1RXNVNNMVpxUm1GT2JFcFZVV3hrVTFKWVFrbFdiWEJIVkRKU1YxZHVUbFJpVjNoVVdXdG9RMWRzV25KWGJVWm9UVlphTUZaV2FHOWhWa3B6VjJ4U1dtRXhjRE5aZWtaaFpFZFdSbVJIZUdsU01VbzFWbXBKZUZJeVJrZFhia3BwVWtaS1YxUlhOVzlOTVZsM1YyMUdUMkpGV25oV1YzaHJWakZLVjJOSE9WZGlXRUpJV1ZSS1UxWXhXblZWYlhoVFlYcFdkMVp0TVRCa01WWnpWMjVTVGxOSFVrOVdiWFJYVGtaWmVHRkhPVnBXYTNBd1dsVm9SMVp0U2xWU2JGSmFZV3RhV0ZwRlpGTlRWbkJJWlVaa2FWZEdSalpXTVZwWFlqRlJlRnBGYUZOaGJIQlVXVlJLTkZsV1duTlhhM1JXVW14d2VGVXlkREJYUmxwelUyNW9WMVo2UmtoV1ZFcExWakZPY21KR1pGZFNWWEI1Vmxkd1IxTnRWa2hVYTFwb1VqSm9WRlJYTVc5VlJscEhWbXhrYTAxVk5YcFdNalZIVmtkR2MxTnNhRlZXYlZFd1ZqRmFWMk15UmtsVWJHUlhUVWhDU2xac1pEUmhNV1IwVTJ4c2FGSllhRmhaVkVaM1pXeHJlV1ZIUmxkV2EzQjZWbTF6TVZZeVJYcFJiVVpYWVRGd2FGbFhjekZYUmtwWllrWlNhRTFzU25kV1YzUmhVekZzVjFkdVRtRlNlbXh4V1d0YWQxWnNWbGRoUnpsb1lsVndTRmt3YUc5V01rcFpZVWhLVjJGclJqTmFWVnBQWkZkS1IxcEhiRmhTYTNBMVZteG9kMU14VVhsVWJrcFBWbTFTYUZWdE1XOWpSbFYzVm10MFdHSkdjRlpWVjNoclZrVXhXRlZzYUZkTmFsWklWbGN4UzFac1pIVlNiRlpYVFRKb1RWWlVSbUZaVm1SSVZXdG9VMkpJUWxoWlZFNURWakZhZEUxWWNFOVdiR3cxVlRKNFYxWXlSWGhUYkZwYVlrZG9kbGRXV25kV2JHUnpXa2R3YUdWdGVGcFhWbFpXVFZkR1JrMUlaRlJoTTBKWVdXdGFTMVJHVW5KWGJIQnNVbXh3V2xscldrOVhSa2w2WVVoYVYxWjZRalJaYWtaclVqSktTVlZyT1ZkV1ZGWmFWbGN4TkdReVZsZFhXR3hPVmxkU1dGUldXbmRsVm10M1ZXdE9XbFpyY0ZoWk1GcFRWakZhUmxKcVVsWmhhM0JRVlcweFUxSXhjRWRhUjNob1RWWlplbFp0Y0VkWlYwVjRVMWhvV0ZkSGFGWlphMlEwWWpGV2RHTjZSbGhXYkZwNFZXMTBNRmRHV25SVmJHaFlZVEZLUkZaclZYaGpiR1J5WVVad2FFMVZjRzlXYkZKTFV6RmtWMVp1VGxkaVJuQndWakJrYjJJeFpITlhiVVpxVFdzMWVsZHJhRTlXVjBwWVlVWm9XbUpHY0V4Vk1uaHJWakZhZEZKc1pFNVdNVXBKVm1wR2IyUXhXblJUYms1cVVtMVNXRmxVUm1GaFJtUlhWMjVrVjJKSFVqQmFSV1IzVkcxRmVHTkZhRmRTTTJob1dWUkdWbVZXU2xsalJrcHBVakpvV1ZkV1VrZGtNazV6Vld4YVdHSnJOVmxWYlhoM1pXeGtjbGR0Um1oV2EydzBWVEo0ZDFkR1dqWlNhbHBWVm14d1lWcFZaRXRUVmxKeldrZHNVMDFWY0ZKV2JUQjRUa2RSZUZwR1pGWmlSMUpZV1d4b1UxZFdWbkZSYm1SVVVtMTBNMVp0TVRCV01ERkZVbXBHVmxZemFFUldha3BIWTJ4a2NtVkdaR2hoTTBKUlZsUkdhMVF4U1hoalJXaHBVbTFvVkZSWE1WSk5iRnAwWlVkMGEwMVZiRFZXVm1odlZsZEZlV0ZHWkZwV1JYQlVWbTE0YzFkWFRrZGFSbWhUWWxobmQxZHJWbGROUmxwR1RWWmthbE5IYUZkWmJGSkdaREZhU0dWRmRHdFNNVnBJV1d0YVlWUnNXWGxoUkVwWFlXdEthRmxVUms5U01WcDFVMnhDVjJKSVFsQldWM0JIVW0xUmVGcEdhR3BTVjFKWVZGZHpNV1ZzV1hsT1ZtUmFWbXR3TUZsVldsTlhiVXBJWVVoYVZXSkdjR2haTVZwUFkxWkdjazVXVG1sVFJVcGFWbXhTU2sxV1VYbFNiazVWWVRKb2IxVnRNVk5XYkZwMVkwWmtWVTFZUWxkV01qVlBZVzFLU0ZWdWJHRlNWMUl6VmtjeFIwNXNXbkphUm1SWFpXdFZkMWRXVWt0U01WbDRZMFZhYUZJeWFGUlphMXAzVjJ4YWRFMVVVbXROYTFwSVZteG9jMVJzV25SVmJHeFdZbGhTTTFwV1duTmpiSEJHV2taYVRtRXpRbGxXVkVreFlURlplVkp1U2xSaWEzQmhXVmQwZDFNeGNGWlhibVJVVm1zMWVsWXlNVzlVYlVwR1kwUktWMkV4Y0hKYVZ6RlhVbXMxVmxwSFJsUlNXRUoyVmxkNFUyTXlTWGhXYmxKclUwVTFVRmxyWkRSV01WbDVaVVU1V0ZJd2NFbFdWM1IzVm14WmVtRklXbGRoYTBZMFZtcEtUMU5IUmtkWGJXaG9UVmhDTlZZeWRGZFpWazE1Vld0b1ZXRXhjRkJXYlhNeFZrWnNjbUZGVGxSTlZuQXdWRlpvYTFaRk1VVldhMnhXWWtkb2VsWlVTa1psVmxaelZteHdWMDB5WjNwWFZFSmhWakpTUmsxV1ZsWmlSMUpQVm1wT2IxZHNaSEpXYkdST1VteEtlVlJXV210aGJFcEdVMjFvVjJKSFVuWldWVnB6VjBVeFZtUkdVbE5pUm5BMFZsWmplRkl4VlhoWGJsWlNZbTE0V0Zsc2FFTlVSbFkyVW1zNVYwMVZjREZXUnpGelZUSktWMU5zYkZkV00yaHhWR3hWZDJWR2NFZGhSM0JUVmpGS2FGWnRjRUpOVjFaWFZXeGtXR0pyTlZoVVYzUjNWMVpzVmxkc1RsaGlWWEJKVmxjMVlWWXdNVmRqUjJoV1lXdGFhRnBGWkZOU01XUnlUbFprVGxaWVFrdFdiVEI0VGtkSmVWSllhRmhYUjJoWldWUktVMWRXYkhKYVJ6bFhZa1p3TUZSV1l6VlZNVXB6VjI1b1ZtSllhRkJaVjNONFYxWkdjbUpHVms1V2JrSlpWMVphWVZOdFZrZFVia3BvVW0xU1dGUlVTbTlOYkdSWVkwVmtXR0pXV2xoVk1qVlhWa2RLU0dGSVFscFdSVm96Vm1wR1lXUkZNVWxoUmxwT1ZteFpNRmRVUW1GWlZtUklVbGh3Vm1KSGVGaFpWM1JMWVVaVmVGZHNaR3RTTVZwSVZrZDRZVlJzV25WUmEyeFhZV3RzTkZWcVJscGtNREZYV2tkd1UySkZjRmhYVm1Rd1pERlZlR05HV2xoaWJWSlVWRlpvUTFOV2JISlhiRTVXVFZad1NGWXlOV0ZXTWtwSVZGaG9ZVkpGY0U5YVZscFBWMWRHUjFwSGJHbFNXRUkyVm14a2QxRXhiRmhVV0docFUwVndXVmx0Y3pGVlJscDBaVVYwYkdKSFVubFdWM1JQVmpBeFJWSnViRnBOUmxweVZqSnplRkl4VG5KVmJHaFhZa2hDVVZaVVJtRlNNazUwVm10a1lWSXllRmxWYkZKU1pERlplV1JIUmxwV2JHdzBWMnRhYTJGc1NsaFZiV2hXWVd0d2RsWkVSbHBrTVZweVpFWldWMkpIZHpGWGExWmhWREZWZDAxWVNsZGhiRnBZVlc1d1YxWkdXbFZUYTFwc1ZteGFNRmxWV21GaFZtUkdUVlJTVjJFeFNraFdWRVpyVW1zeFYyRkdRbGRpU0VKM1ZsY3dNVkZ0VVhoWGEyUllZbFJzYjFSV1dsZE5NVkpYVjIxR1ZXSkdjRWhXTW5odlZtMUtWVkp1V21GV00yaG9XWHBHZDFKc1pIUmxSbVJwVW0wNU5GWnNXbXRPUm14WVVteGtXR0V4Y0ZsWmExcGhWMVphY2xacmRHaFNiVkpZVjJ0Vk5XRnJNVmhWYWtaV1RXcEdNMVpVUm1GU01XUnpWbXhvVjAweFNqSldWbEpIVkRKTmVHTkZiRlJpUjFKd1ZqQmFTMVpXV2tkYVJFSmFWakZhV0ZaWGVHdFhSMHBWWWtab1dtSkdXbGhVYkZwelZteGtkRTlXYUdsV1dFSktWMVpXYjFsV2JGZFhXSEJvVTBoQ1dGbFhkR0ZqYkd0NVRWWk9WRkl3TlVsWlZXUTBZVlpLZFZGdGFGZGlXRkpVVldwR2MxWXhaRmxoUm1oWVVqRktVRlpVUW10T1IwbDRWbTVPVm1FeVVsbFZiVEUwVjFad1JtRkhSbFZpUlhBd1ZsZDRiMWRIUlhoV1ZFWlhZV3RHTkZadE1VOVNWa3B6V2taa2JHRXhXWHBXYlhoVFV6Rk5lRlJzWkZOaWF6VlRXV3RrVTJOR1dYZFdhM1JVVm14d1dsa3dWbXRXVlRGWFlrUlNXR0V5YUZoV1ZFcExVakZPYzJGR1dtbFNia0Y2Vm0weE5GbFdTWGhhU0ZKVFlsaENUMVZyV21GWFZscDBaVWM1YWsxcmNFaFZNV2hyVjBkS1NHVkdaRnBXTTFKTVZGUkdWbVZHWkhWYVJtUnBVakZKZDFkclZtRmlNa1pYVjJ4c1VtRXllRmhXYTFaMlpERnNWVkp0UmxkTlYxSjZWMnRrZDFVeFNsVldiR3hZVm0xUmQxZFdaRTlqTWtwRlYyeFNhR1Z0ZUZaV1YzQkhXVlpPUjFwSVNsZFdSVnBZVkZaa1UxSXhWWGxrU0U1WFRXdHdXbGxWWkc5WGJGbzJVbXhvVmsxR2NGUldNV1JIVWpGd1IyRkdUazVXV0VKU1ZtMHdlRTVIUlhkT1ZXUlhWMGRvY0ZWdGVHRldiR3hWVVZSR1dGWnNXakJVVmxKVFlrWmFkRlZ1YkZkaVJrcElXVlphUzJOdFRrVlJiVVpVVTBWS1RWWnRNSGhUTVdSWVVtdFdWV0pJUW05VVZtaERZakZrVlZOdWNFNVdiVkpaVlRKMGEyRkdTWGxoUlRsWFRVWmFURlp0ZUZwbFJtUnpXa1prYVZac2NFcFdiR1F3WWpGVmVWSlliR2hTZW14WFdXeFNSMVpHYTNkWGJIQnJUVmhDU1ZReFpITlViRmw0VTJwV1YySkhVWGRaVkVaaFkyc3hWMWR0YkZOU2EzQmFWMVpTUzJJeFpFZFhiazVoVWxoU1ZWVnFRbUZUVmxGNFYyeGtWMDFFUWpWWlZWVjRWMGRLUjFkdGFGaFdiVkpVVlcxemVGWXhXbk5YYld4VFlUTkNVVll4WkRCWlYxRjNUbGhPV0dKcldsUlpiRkp6WTFaU1dHUkhSazVTYkhBd1ZHeFdNRmRHU1hkalJscGFZVEZ3ZGxZeWVGcGxiRlp5WlVaV1YxSldjRmxYVkVaaFV6Sk5lVlJyYUd4U2F6VlBWVzAxUTFSR1duRlRha0phVmpCV05GWlhOVk5WTVdSSlVXeE9XbUV5VWxSV01GcGhaRmRPUmxwRk5VNVdia0pIVmxjd2VGSXlSbkpOVm1oV1ltMW9XRlJYTlc5VlJteFhWMnR3YkZZd1draFpWVnB2VmpKS1YxSnFUbGROVm5CeVZrUktUbVZHY0VkaVIyaFRUVVp3VlZacVFtRlRNVnBYVjJ0a1dHSlZXbkpVVlZKSFUwWnNjbGR0UmxkTlZuQkhWakl3TlZZeVNsbFZhazVYVFc1b1dGWnFTa2RUVmxKeldrVTFhRTB3U21oV01WcFhZakZKZUdKR1pGUmhNWEJ4VlcweGIxWXhiRmhrUjBab1VteHNORmRyVmpCVk1ERlhWMjV3V2xaV2NGQldSekZMVjBadmVtTkdaR2xYUjJoNFYyeFdWazFXU1hsVGEyUmhVbTFvYjFSWGVFdGtNVnBWVVcxR1ZFMVdSalJXTWpWVFlXMVdjbGRzYkZkaVdHZ3pWRlZhZDFac2NFWmFSbFpwVWxoQ05sWlVTalJpTVZsM1RWaFdWVlpGV21GV2JYaDNVekZ3UlZOck9WTmlWVnBJV1RCVk1WVXlSWHBSYTFwWFlsUkZNRmRXV25OWFJsSlpZVWRHVkZKc2NGWlhWM1J2VVRGa1IxZHVVazlXVlRWV1ZtMTRkMDFHY0ZaYVJXUlhVbFJHZWxVeWVITldNVWw2Vlc1S1YwMUhVa2hVYlhoaFpGWkdjMk5IYkZOTlZXOTRWako0WVZsV2JGaFZhMXBPVm0xNGFGVnRjekZVTVZwelZXdGFiR0pHY0VsYVZXTTFWbFV4V0ZWcmJGWk5hbFpNV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGWlYwNXpXa2hPWVZJelFrOVdha1pLWlVaWmVXUkhkR3BOVmtwNlZqRm9iMVpIUm5OWGJHaGFZa1pLUkZScldsZGpWa3B6WTBkMFRsSkZXbUZXYTJRMFZUSkdWMU5ZYkdoU2JXaFpWbXBPYjFaR1duRlNiR1JUVFZoQ1NGZHJXbTloUlRCM1UyNXdWMkpZUWtoWFZscFBVakpLU1ZOc2FHbFdWbkIyVm0wd2VGVXhUa2RXV0d4cVVqQmFXRlJXVm5aTmJGWnpWV3RPV0ZKc2NEQldWM2hEVjIxV2NtTkdRbFppV0dob1dYcEdUMlJIU2tkVmJFNVhWMFZLYUZadGNFZGhNRFZJVTFoc1ZGZEhhR2hWTUZVeFYxWnNkR1JJWkZoV2JYaDZWbGMxVDJGc1NuTlRiR3hoVWxkU1NGbHJaRXRTTVZweFZtMUdWMVl3TUhoWFZscGhVekpPZEZOclZsZGlTRUpZVm0wMVEyVldXbkZUV0doVVRWVTFTVlZ0ZEhOWFIwcElWV3hTVjJKVVZrUlpha1poVjBkV1NGSnNVazVpUlhCWlZteGpNVlF4YkZkVGJsSldZbFJzYUZacVRtOVpWbEpXVjIxR2ExSXhTa2xhUldRMFlVZFdjbGRzYkZkaVdHaDJXWHBHWVZOR1RuSmhSbHBwVW14d2FGZFdVa3RpTVVwSFYxaG9XR0pyTlZoV2JYUjNUVVpXZEUxWVpHaFdhM0I2V1RCU1UxWXhXa1ppTTJSYVZrVmFWMXBXV2t0alZtUnpWRzFzVTAxdGFHRldNVnBUVXpGVmQwMUlhRmhpUmxwVVdWUk9VMWRHYkhOV1ZFWlVVbTE0VjFZeU1UQldhekZ5WTBaa1ZWWnNTbFJXYWtwTFVqRk9jbVZHWkZkU1dFSlFWMnhXWVdReFRsZFhiazVZWWxkb2MxbHJXbmRYYkZwMFkwVk9XbFpyTVRSV01qVlBWMGRLU0dGSVJsWmlSMUpVVjFaYVlXUkhUalpTYkdoVFlraEJkMVpIZUdGVU1rWlhVMjVLVDFaWGVGaFdibkJDVFZaYWNWTnJkRmhXYkZwNFZrY3hSMVl5U2tsUmFsWllZVEZLU0ZkV1pGTldNVloxVkcxR1UxWkdXblpXUmxKRFV6SkdSMWR1VW14U00wSnpWV3BDYzA1R1pISldiWFJZVWpCd2VsVXllR3RYYlVWNFYydDRWMDFHY0hwV01HUlRVMFpLYzFkc1RtbGhNSEJLVm0xd1MwNUdVWGxTV0doVVltdHdjVlV3YUVOWFJsWnhWR3MxYkZKc2NFbGFWV1JIVjBaYWNsZHVjRmhoTVhCeVdWWmFZVkpzVGxWUmJHUlRZa1p3YjFacVNYaFdNVTVIVkc1S1lWSXdXbFJaYkdSdlYyeGFXR05GZEdsTlYxSjZWMnRhYjJFeFNYcFZiR1JWVmpOU2FGVXdXbUZqTWtaSVpFZG9VMkV6UWxoV1IzaGhZVEZhZEZOc2JHaFNSVFZXVm14YWQwMHhXblJsUjNSclVqRktTRlp0Y3pGV01rcHlVMVJLVjJKVVFqUmFSRVphWlVkS1IxcEdVbWxTTW1oWFZtMTBWMWxXYkZkWGJrNVlZa2RTVUZWdE1UTk5iRlowVFZSQ2FFMVdiRE5aTUZadlYwZEZlRlpZYUZwV2JWSk1WakJhZDA1c1RuTmFSMnhZVWxWd1RWWXllRmRaVmsxNVZXdGtXR0pyY0c5VmJYaGhZakZTV0UxWE9XdGlSbkJaVkZWU1IxVnJNVmRTYWxKYVlUSm9WRlpIZUdGT2JVcEhZVVprYVZkSFozcFdSbFpoVlRGWmVGWnVUbFZpVjJoUFZXdFdZVmRHWkZWUmJUbHJUVmRTZVZSV1ZtdFhSMHB5WTBab1dtSkdTa2hXUlZwWFpFZE9ObEpzYUZOV1IzaFpWbTB4TkdFeFZYaFhiR3hTWVhwR1dGbFVSbmRYUm1SWFYyNU9XRkpzV25sWlZWcFhZVVV4V1ZGdWJGZFdNMmhVV1hwR1lWSXlTa2xUYkdScFUwVktVRlp0TVRSa01XUlhWV3hrVm1KRk5XOVZiRkpIVjBacmQxWnRPVmhTTUZZMFZqSTFkMVl4V2paU2EzaFhZa2RTVEZWcVJuZFNNazVJWWtaT2FFMHdTa3BXYlhSaFZqRnNWMXBJVWxaWFIyaG9WVEJhWVZac2JITmhSVTVWVFZad01GcFZhR3RVTWtwSFlrUldZVkpXY0doV1IzaGhZekZPZFdOR1pFNWhiRnBaVm14amVGSXlUWGhVYms1b1VtMVNiMVJXV25abFZscEhWbTFHYWsxV2NGaFdSelZMV1ZaSmVsRnRPV0ZXTTFKb1ZqRmFhMVl4V25SU2JIQlhUVVp3U2xaWGVHOWlNa1p6VTI1U2JGSnRhRmhaYlRWRFYwWlNWVkpzWkdwV2EzQjVWREZhVDFSc1dYaFRhbHBYWWxSRk1GWkVTa2RXTVhCR1drWlNhVkpzY0ZsV1Z6RTBaREZaZUZWc1pHRlNiVkp4VkZaa1UwMVdXbGhOVkZKV1RVUkNORlV5ZUc5V01VcDBWVmhrWVZKRlduSlZha1poVjFkR1IxZHRhRTVOVlhCYVZtdGFZVll5VVhsV2JrNW9UVEpTYUZWdWNITlhSbEpYVm01a1UwMVhkRE5XYkZKWFYyeGFjMk5HYUZwTlIyaE1Wakl4VjJOdFRrWmxSbHBPVWpGS1RWWlhjRWRWTWs1eVRsWmFUMVl5ZUZoVVZ6RnZWMVphZEUxSWFFNVNiWGhZVm14b2IxWkdaRWhoUmxwWFRVZFNkbGxWV2xkak1YQkhWR3hvVjJKWWFGZFdWRW8wVkRGa1IxTnVVbXhUUjNoWVdXdGFTMU5HV25Sak0yaFhUVlUxZWxkcldtdFdNREI1WVVoc1YyRnJTbWhWZWtwVFUwWmFjbUpIYkZOaVZrcFFWMVprTUZsV1RsZFhia1pTWWxoU1ZWUldXbk5PUm1SeVlVWmthR0pGY0RCV1YzTTFWMjFLVlZKdVdsVldNMmhvV2tWa1YxTkdTbk5oUjJ4WFlraEJNbFp0TUhkTlZsVjVVbXRrVkZkSFVsbFphMlJ2V1Zac1ZWTnRPVk5TYkd3elZqSXhNR0ZyTVZoVmJuQlhUVzVOZUZacVNrdFRWa1paV2taa2FWSXhSak5YVmxKSFl6RlplRlJ1VGxkaVIxSndWV3BLYjJGR1pGaGtSMFpVVFd4S2VsWlhOVTlYUjBwV1YyNUdWVlp0VVhkVWJYaHpWbXhhVlZac1drNVNSVnBLVjJ0b2QxRXhaRWRYV0hCV1lsZG9ZVlpyVm1GaFJsVjNWMnM1YW1KVldraFdNakZ6WVVVeFdWRnNiRmROVjFFd1dXcEtTbVZHVm5KYVIwWlRZbFpLV2xkWGRGWk5WbVJYVm01T1ZtSkhVbGxXYlhoSFRrWmFjMVZyWkZkV01IQklXVEJvZDFZd01WaGhSRTVYWVd0d1NGa3lNVXBsYkhCSFZteGtWMDFWY0VwV01WSkxaVzFXUjFkWWFHcFNWMUpYV1d4a05HTkdXWGRhUnpsWVVteHNORmRyVWtOaFJURlhWbXBXVjJKVVZsQlpWbHBMWkVaV2MySkdjR2hOYldoRlYxaHdSMWxYVGxkU2JsSlRZa1pLV0ZsclZscE5SbHB4VTFob1RsSXdXa2hXTWpWUFlXeEtXRlZzYUZwaE1sSjJXVEo0V21ReFpIUlNiWEJPVmxSV05WZHNWbUZoTVZsNVZtNUtXR0pIZUZoV2FrNURVMFphY1ZOck5XeFdhelY1V1ZWa2MxVXlSalpXYm1SWFZqTm9kbFZVUm5OV01XUjFWRzFHVkZJeFNsWldSbVF3WXpBMVIxcElTbWhTVkd4aFZtMTBkMDFHYkZaV1ZGWlhUVVJHU1ZsVlZsTldNVXBHVjIxb1lWSldWalJXYWtaVFl6SkdSMVJ0YkZoU01tTjRWbXBHWVZZeGJGZFZXR3hUWVRKb1ZWbHJaRk5YVm14MFRWUlNXRkpzU2xsWk1GcHJWVEZLYzJOSWNGZE5ha1pJV1ZkemVHTnJOVlpoUm5CWFZtNUNXVlp0Y0VkVE1WbDVWR3RzYVZKdGFGaFZiR00wWkRGa1YxVnJkRlZOYXpWNVZERmFhMWxXU1hkWGJGSlZWbnBHZGxwWGVHdFdNVlp5V2tkMFRsWXphRmxXYWtadll6SktSMU51VWxaaWEwcFdWbXBPYjFOR1VuSlhiSEJzVWpCYVNWcEZXbGRoVmtsNFUydG9WMkZyYnpCV1ZFWnJZekZrY2xkdGNGUlNia0paVmtaV1lXUXlWbk5YYms1WVlUTlNjbFp0TlVOVFJscDBaVVU1YUZadFVrbFdSM0JYVmpKS1IxTnJlR0ZXTTAxNFZtcEdZVmRYU2tkVmJXeFRZbXRLTkZac1pEUmhNRFZIVjFob2FWTkZOVzlWYm5CelZqRldkR1ZJWkd4U2JGcFlXVlZqTlZZd01YSmpSV3hYVmpOb00xWXljM2hTTWs1SlUyeHdWMkpJUW05V1Z6RTBZVEZrV0ZSclpHRlNiVkpQVkZWV2QxTnNXblJrUms1VVRWWldORlV4YUc5WFIwcHlUbGhDVm1GcmJ6QldhMXB6WTJ4a2RWcEhkR2xTYmtKSlZtcEpkMDVXVm5KTldFNVRZV3hLV0ZSWE5XOWtiR3hZWlVWMFYyRjZWbGxWYlhocllWWmFSbGRzVmxkV1JVcG9Wakl4VjFack5WZFhiVVpUWWtoQ2QxWlhjRWRUTVU1elYyNU9XbVZyV2xaVVZscDNUVVpWZVdWSVRtaFNhM0JIVkd4YVlWWXlTa2RqUkU1WFlURndhRnBGVlhoV2JIQkhWV3hPVjFJemFGcFdiWEJMWldzeFYxWllhRlJpUjFKd1dsZDBZVmRHYkZWVGJFcE9VbTE0ZUZVeWVFdGlSa3AwVld4d1dsWldjRlJaVldSTFUxWkdjMkpHYUZkTk1VcHZWbGh3UjJNeFdYaGFTRlpWWWtkb2NGbHNXa3RXTVZwWVRVUkdVazFWYkRSV01XaHpZa1pKZWxWdE9WVldiRm96Vm0xNGMyTnNaSFJQVm1ST1lUTkNZVmRXVm05VE1XUnpWMjVPYWxJd1dtaFdiVEZUVTBaV2RHVkhkR3BOV0VKSFZHeGFhMVJzV2xoa2VrcFhZbGhvY2xwRVJrNWxSazUxVld4a2FFMXNTbTlXVkVKV1RWZEdSMVp1VW14U1dGSnhWVzB4TkdWV1duUk9WM1JYVFZad01GWlhlSE5aVmtwWVZXdG9WMDF1YUdoWmVrWkxZMVpXYzJOSGFFNWlWMmhPVm0weGQxTXhUWGxWYTJSWFltczFXRmxyV25kalJsbDNXa2MxYkdKR2NGbFVWbEpUVmpBeGMxTnJaRlZXYkhCb1YxWmFTbVZYUmtkVmJHUm9UVlp3YjFacVNqUmhNazE0VjI1U1UySlhlRTlXYlRWRFRsWmFSMWR0Um1sTmExcElWa2QwYzFWdFNsWlhiVVpYWVRGYWFGUlVSbUZTYkdSMVZHczVhVkpZUWpWV1JFWnJaREZTYzFkWWFGUmhiSEJZVkZjMVUyTnNiRFpTYlhSVFRWVTFXbGxyWkc5V1JrcDFVV3hzV0Zac1NraGFSRVpoVWpGYWRWSnNVbWhOV0VKNlZsY3dlRlV4WkhOaVJscGhVbGRTV0ZWdGRIZFdiRnAwVGxjNVYwMVdiRFpWVjNoRFYyMUdjbGR1U2xaaGExcFlXWHBHZDFJeGNFaGlSMnhYWVROQ1dGWnRNSGRsUlRWSVZGaGtUMVp0VW5GVmJGcDNZVVpXY2xacmRHbE5WbkI2VmxkMGExZEdTbk5XYWxaVllrZG9jbFpxU2tkT2JFcHhVbXhrVjJWcldqSldiWEJDWlVaT1IxWnVTbUZTTUZwWVZGUktiMU5XWkZsalJYUlRUVlZzTkZrd1ZtOWhWa2w1WlVjNVZWWlhhRVJWTW5oaFpFZFNTRkpzWkU1V00yaGFWbGQ0YjJJeFpFZGFSV2hvVWpKb1YxUlZXbFpsUmxwMFpVaE9hazFyV2tkV1IzaFhWR3hhZEdRemNGZGlWRVYzVkZWYVlWSXhUblZVYlhCVVVqSm9XRlpHV210aU1sSnpZa1pXVWxkSGFGaFVWM014VWpGc1ZsZHRSbFZpVlhBd1dWVmpOVmRHV25SVlZFSldaV3R3VkZVd1drdGpiSEJJWWtaT2FWWnJjRE5XYlhCRFlUSkplRlZzWkZoaVJscFRXV3hXWVdOc1VsZFdibVJZVW14V05WUnNWVFZXTVZsM1kwVmtWV0pHVlRGV2FrcEhZMnhrY21WR2FGZGlTRUpvVjJ4YWExVXhUa2RUYmxKcFVsUldiMVJXYUVOWlZscHpXVE5vYTAxWGVGaFdNV2h6VmtkS2MxTnRPVlppVkVaMlZtcEdjMk15UmtoUFZUVk9Wak5vV0ZacVNYaE5SbGwzVFZac1VtRXlhRmxaVkVwVFRURmFTR1ZIZEZOaVJUVjVXa1ZhYTFZeFNsaFBTR1JZVmpOQ1RGVnFSbHBsUjA1R1YyMUdVMkpGY0hkV1YzQkxZakZrVjFkc2FFNVRSMmhYV1d4YVIwNUdhM2RXYkdSV1RXdFpNbGxyYUVkV1ZscHpZMFJPWVZZemFIcFdiWGgzVWxaR2MxcEdUbWhOYm1OM1ZteFNTMDVIVVhoWFdHaFlWMGhDVTFsVVJrdGhSbFp5Vm0xR1ZsSnNXbmhWYlRFd1YwWlpkMk5GWkZWTlZuQnlWakJhUzJOdFRrZGpSbVJPVmpGRmQxWnRjRWRqTVdSSFYyNU9ZVkp0YUZsVmFrNXZaV3hhV0dWR1RtcE5WM2hZVmpJMVUySkdUa2hWYms1YVlUSlJkMVJVUmxwbFYxSkdUMVpvVTAxSVFsbFdha2t4WXpGWmQwMVlSbGRoTTJoWlZtMTRkMVJHV1hkWGJHUnFUVlZhZWxZeU1XOWhSVEZaVVd4YVYwMVhhRE5WYWtwU1pVWk9kVk5yT1ZkaVYyaDNWbGN3ZUZVeFVYaGlTRTVoVWpOU1VGWnRlSGROUmxKV1lVZDBhRTFFUm5wVmJYQlhWakpLV1ZWdGFGZFNSVnBvVmpCYVYyUldSbk5YYld4WFVsWnZlVlp0TVhkU01XUjBWVmhvYWxKWFVsWlphMXBoVkRGYWRHVkdjR3hpUm13MVdrVmtkMVF4V1hkWGJuQldUV3BXVUZZd1pFZGpiRTUwWVVaa2FWSXhTakpYVkVvMFYyMVJlRnBJU210U00wSlBXVlJPUTFJeFduSmFSRkpwVFd0YVIxUldhRXRVYkU1SVlVWm9XbFl6VWt4WlZWcHJWakZ3Ums1WGVGZGlSWEExVm0weE5GTXlSbGRYYkdScVVteGFXRmxzYUVOVFJsWTJVbXM1VjAxWFVqRlZiWGhMWVZaa1IxTnNXbGRTYkhCWFZGWmFUMVl4WkhOaFIzUlRZbFpLV1ZadGNFTmtNVTVYVjJ4b2FtVnNXbGxaYTFwelRteGFXR1JIZEZwV2JIQllXVEJvUzFZeVJuSlhiV2hoVWxad1RGbDZTazlTTVhCR1RsWk9VMkpHYkRaV2JURTBWVEZOZDAxVlpGaFhSMmhaV1cxNFMxWldiRlZUYkU1cVZteFdNMVp0ZERCV01ERllaVVpzWVZKWGFISlpWRXBMVTFaR2MyRkdaRTVoYTFwSlYxWlNSMU50VVhkT1ZscGhVakJhVkZadE5VTlZWbHB5V1ROb1UwMUVWbnBXTW5oeldWWktkRlZzYUZaaVIwMHhWRlJHWVdSSFRrWmFSbkJYVFZWd1NWWnJZekZUTWtaSFUyNU9hbE5GU2xoWlZFcFNUVVpzVmxkdFJtdFNNVXBJVjJ0YWQxWXhXa1pUVkVKWVZqTlNkbFZxUmxabFZrNXpZa1phYVZJeWFGbFhWM2h2VkcxV1IxVnNaRmhpYTNCeVZGWmFkMVpzVm5SbFIzUlZZbFZXTmxWWGRIZFhSMFY1WVVST1ZsWkZXbkpWYWtaclkyeGtjMVZ0YkZOTmJXaHZWakZhYTAxSFVYaFVhMlJYWW10YVZGbFljSE5qYkZwMFkzcEdiRlpzUmpSV01qRXdWakF4Vm1KRVdscFdWbkIyVm1wS1MxWldSbkZWYkZab1RWaENObFp0TVhwbFJrNVlVbXRrYUZJeWVIQlZiR2hEVG14YWMxa3paRTVXYTFZMVZrWm9iMVl5U25OVGJFSlhZa1pWZUZaclduTmpiR1IwVW14b1YySnJTbGhYVmxaclRVWlpkMDFWVmxOaE1YQlhXV3hvYjJOc1duRlJXR2hYVFZVMWVWbFZXbXRoUjBWNlVXc3hWMVpGU21oV1ZFWnJWMFpLY2xwSFJsTmhlbFpWVm0wd01WRnJNWE5YYmxKT1YwZFNWRlJXV2xkT1ZscElUbFU1V2xack5VZFpNRnBIVmpKS1ZWSnNVbGRTUlZwNldYcEdkMU5GT1ZkaFJtUnBVak5qZDFadGNFdE9SbEY0Vmxoa1RsWnRhSE5WYlRGdlYwWmFjVlJzVG1waVIxSllWakowTUdFeFNuTlhibkJhWVRGd00xbFdXa3RqTWs1SVQxWm9WMUpYT0hkV2JYQkxWRzFXUjFkdVZsUmlWVnBVV1d4YVMyUXhXbGhOUkVaU1RWZFNlbGRyYUU5V01rcFpVV3hDVjJKWWFETmFWbHBUVmpKR1JtUkhhR2xTV0VKYVYyeFdhMkl4V25KTlZXaG9VbFpLVjFSVlduZFpWbkJGVW01a1UySldTa2hXUjNNeFZqQXhWbUpFVWxkaVJrcE1WR3RhV21WR1pGbGhSbWhwWWtad1ZGZFhNSGhPUm1SWFYxaGthRkpWTlZWVmJURTBWbXhWZVdWRk9WZE5SRVpZVlRKd1IxWXhXalpTYWs1WFZrVndTRlJ0ZUdGak1rcEhXa1pPYVZaVVVYZFdNV1IzVWpKRmVGZFlhR0ZUUmxwVldXdGtiMk5HV1hkWGEzUnNWbXh3U0ZZeU1VZGhhekZGVm10b1YwMXVVblpaVkVaS1pXeFdjMkpHV21oaE1HOTZWMnhhWVZVeVRYaGFTRlpWWWtkb2NGWnNhRU5UVmxweFUxaG9hVTFYVW5sVVZtaFhZVVpLZEdGSGFGWmlSMUpVVmpCYVZtUXhaSEprUjNCT1YwVktTbGRYZEdGVU1rWlhWR3RhVkdKWGFGaFpWM1IyVFVaYWNWTnJXbXROUkVaWFYydGFiMkZXU1hsaFJscFlWbXhLU0ZwRVNrOVdNVnAxVTJ4a2FWWldjRmxXUmxwaFpEQXhWMkV6WkZkaVdGSnZWRmQwZDFOR2JISlZhemxZVWpCV05GWXhhR3RXTVZwR1VtcFNXazF1VFhoV2JURlBVakZrY2s1WGJHbFdNbWN4Vm1wR1lWWXlSWGhUYmxKWFlUSm9WbGxVU2xOV1JteHlXa1pPV0ZKdVFsbGFSVnAzVkcxS1IyTkZiR0ZXVjFKSVZqQmtTMVl4WkhOaFJscE9ZV3hhVFZkV1ZtRlRiVlpZVW10a1ZtSklRbGxWTUZaTFYxWmtjbHBFVW1oTmF6RTBXVEJXVjFadFNrbFJiR2hYWVRGYWFGUnRlR0ZqVms1VlVteFNUbFl4U2twV1ZFb3dXVlpSZUZkdVNrOVdiSEJZV1d4b2IxZEdVbkpYYkU1cVRWZFNlbGRyWkRCVk1ERldZMFZ3V0dFeFdtaFpha1pXWlZaT2MxcEdVbWhOTUVwYVZtMHhORmxYUmtkaVJGcFRZbGhTY2xWdGRIZFhiR3h5VjIxR2FGWnJjSGxaTUdSdlYwWmFkRlZZWkZoV2JIQm9WV3BHYTJSV1NuTlViV3hYVm01Q05WWnRNSGhPUmsxNVZteGtWbGRIYUZsWldIQnpZakZhZEdWSVpHeFdiWGd4V1RCV2ExWXdNVVZTYkdoYVRVWndkbFpxU2t0WFZsSlpZVVprYUdFeGIzcFdWekUwWkRGSmVGWnVUbWhTYXpWUFZteG9RMWxXV25GU2JVWm9UVVJXU0ZaR2FHOWhWa3AwVld4a1dtRXhjRE5XTVZwelpFVXhWMVJ0Y0U1V00yZzFWbXBKTVZReFVYaFhibFpTWWtkU1dGUlhjRmRqYkd4WFYydHdhMDFyTlVkWlZWcGhWRzFLZEZvemNGZGhhMjh3VjFaYVdtVldVbkppUmxKcFVqRktWVlpHVWt0aU1rbDRXa2hLV0dKVldsUlVWM2hMVWpGUmVGZHRkR2hTYTJ3MVdWVlZOVll5U2xWV2ExSlZZa1p3YUZwRlZYaFhWbkJIVkdzMVYyRXhhM2RXYlhCSFlqSk5lRmRzYUZOWFIyaHhWVzB4TkZsV1dYZGhSVTVzWWtac00xWXlNVWRoYlVwSVZXcENWbUpZYUhaV2FrcExWakZPYzJOR1pGTmlTRUpWVmxaU1IxWnRVWGROVmxwWFlrVndiMWxyVm5kWFZscEhWMjEwYVUxc1ducFphMmhMVjBkRmVsVnVTbFppV0dob1ZGVmFVbVZHWkhOYVJtUk9WbTVDTlZkVVFsZGpNVmw0VjJ0YVdHSlhhRmhaVjNSM1ZERndWMWRyZEdwaVZWcElWVmQ0YTJGV1duSmpSbHBYVFZkUk1GZFdXazVsUmxKMVZHMUdVMkpXU2xsWFYzaFhXVlprUjFWc1pHRlNhelZ6V1d0YWMwNVdjRVphUldSb1VteHNORll5TlhOV2F6RjFZVWh3VjJGcmNFeFdNV1JIVWxaU2MxcEhhRTVYUlVwMlZqSjBWMkV4V1hoVWJHUnFVbGRTVmxsWWNGZFhSbXhWVTFSV1RrMVdiRFZhVlZwcllVVXhjazFVVWxkaVIyaDZWbXRrUzJOdFRrZFdiR1JvVFZad1RWWnFRbUZqTWs1elkwVmFVRlpVVms5V01GWkxWMFphZEdWSE9XbE5WbFl6VkZaYWEyRnNTblZSYlVaYVZrVmFNMVpyV25OV2JGcFpZVVpvVjJFeGNEWldWekUwWVRKR1NGSllaR3BUUjNoWVZXcE9VMk5zVm5GU2EzQnNVbTFTTVZadGVGZGhWa2w1WVVoa1dGWXphR2hWZWtwWFVqRndSMkZIZEZOTk1VcFJWbGN3ZUZVeFRrZFhXR2hvVTBVMWIxUldWVEZUVmxwWVRVUldWMVpzY0ZoVk1uUnZWbTFLV1dGSGFHRlNWMUpVVlRCYVMyTXhjRWhpUms1cFYwZE9OVlpxUm1GV01rbDRWRmhvV0ZkSGFGbFpWRVozVmtac1dHTjZSbWhTYkhCNlZqSTFhMVpzU25WUmEyUlhZa1pLV0ZacVFYaFhWa1p5WWtad2FFMVlRbEZXYTJRMFV6RkplRk51UmxWaVIxSndWbXRXU2sxR1pISlZhMlJVWWxaYVNGWlhOVmRXYlVwSVZXMDVWVlo2Um5aV2FrWnJWakZXY2xwSGRFNWhNWEJKVm0wd01WSXhXa2hTYms1VVlrZG9WMWxzYUc5VVJscHhVbXh3YkZaVVZsbGFSVnByVkd4YWRWRnFXbGhXUlVwVVZWUkdjMVl4VG5OaFJscG9UVzFvV1ZaR1l6RmlNa1pIWTBWYVdHSkhVbkZVVjNSaFUwWnNWbHBIT1ZWaVIxSkhWVEZvYzFZd01WZGpSbEpXWVd0YVQxcEVRVEZYVmxaelZXMW9UbUpGY0ZoV01XUXdXVlpzVjFwRlpHbFRSVFZaV1ZST1UxZEdXblJOVms1c1lrZFNlVlpYZUU5WFJrbDNZMFpvVjAxdWFISldiR1JMVWpKT1NHRkdhRmRpU0VKTlYxaHdTMVF4VGxkU2JrNWhVako0VkZSWE1XOVNiRnAwVFZoa1UwMXJWalJYYTFadlZtMUZlV0ZHVWxwaE1YQm9Wa1JHWVdSRk5WWlViR2hYWWtoQ05GWlVSbE5TTVZweVRWWmthbEpGU2xkVVZ6VlRZMnhhY2xwRmRGUlNiRnA2VmpKNGEyRldTblZSV0hCWFVteEtTRnBFUm10VFJscHlZa1pTYVZkSGFGbFdiWFJYV1Zaa1IxZFliR3RTTUZwV1ZGZDBZVk5XV25ST1ZrNXBVbXR3TVZWWGVITldNa3BaWVVkb1dsWldjR2hWYkZwUFkyeHdSMVJ0YUd4aE1YQm9WbXhqZDJWSFNYaFdXR2hVWW1zMWNWVnRNVFJYUmxaMFpVaGthbUpHY0ZsVVZscExZa1pLZFZGcmFGaGhNbEpJVmxSR2ExSnNUblZqUm1SWFpXdEpNRlpzVWtKbFJsbDRXa2hPYUZJemFGUlpXSEJYWkd4YWRFMVVRbXBOUkZaNldXdGFZV0ZHU1hkWGJHaFZWbXh3ZWxSdGVGZFhSMUpIVkd4b1UySklRalpYVkVKcllqRmtkRlp1U2xoaWEzQm9WVzE0ZDFSR2JEWlNiVVpyVWpCd1NGZHJXazlVYXpGMFlVYzVWMkpVUlRCWlZ6RlNaREF4VjFwR1RsaFNNbWhXVm1wQ2EySXlSa2RXV0dSWFltMVNXVlp0TVRSWGJHdDNZVVU1VjAxRVJsaFZNbmh2VmpBeGNWWnVTbHBoTVhCb1dYcEtTMUpXV25OalJUVlRZa2hDVWxadGNFTmhNVTE0VTFoc1ZXRXlVbTlWYlRGVFkwWldjVk50T1U1aVJuQXdXVEJXTUZVd01YSk9XSEJZWVRKb1dGWnJaRXRTTWs1SlVXeGtUbEl4U2pKV2JGcGhXVmRTU0ZacmFGTmlSbHBQV1Zod1JrMUdaRlZSYkdSYVZteEdORll5TlZOV2JVcFZZa1phVjJFeFdreFdSVnBYWTFaS2RGSnRkRk5XUlZwWFZteGtORmxXVW5OWGJHaHJaV3RLV0ZsVVNrNWxSbHBWVW14d2JGWnJjRnBaYTFwaFlWWlplV0ZHYUZoV00yaFVWVzF6ZUZJeVNrbFNiRTVwVWpGS2VWWlhjRWRaVmtsNFkwVmFXR0pVYkZoVVYzUjNVMFpaZUdGSVpGZE5hM0JXVld4b2ExWldXbGhWYTJSaFZteHdVRmt5ZUhkVFIwNUhWRzFzV0ZJeWFGbFdiVEIzWlVVMVIxUllhRlJoTWxKWldXMTBkMWRHV1hkYVJ6bFlWbXhhZUZWdE1VZFdSa3AwWlVaa1YwMXFSWGRXYkdSTFZteGtkV05HWkU1aWJXaFpWbXBDWVZkdFZuTldibEpvVW0xU1ZGVnNXbmRWVmxwWVkwVmtXbFl4U2xoV1Z6VlBXVlpKZVdWR1VscGhNbWhFVmpKNFdtVkdjRVZWYldoT1lUSjNNRlpVU2pSaE1XUklVMjVLV0dKR1NtRlphMXBoWVVaYWNWSnNUbGROVjFJeFZrZHpOVlV5U2toa2VrWlhVak5vYUZaRVNrZFNhekZYVjIxd1UxSlZjRmxXYlhCUFlqRmFSMWRZYkd4U01GcFVXVmh3VjFZeFdsaGxSM1JvVWpCV05Ga3dhSE5XTWtaeVUyNUtWMVpGV2xCVmFrWlBaRlpXZEdKR1RsZFNiSEJhVm10YVlWWXlVWGhVV0doWVltczFhRlZyV2t0alJsSllaRWhPVDFac1dqQlViRlUxVmpGWmQxWnFVbHBOUjJoSVZtMHhSMk5zVG5SaFJtaFhZa2hDYjFkVVNqUlpWMUpYWTBWa1lWSnJOWEJWYlRWQ1RVWmFjMWt6WkU1V01GWTBWbXhvYjFkSFNuSmpSa0pYVFVkUk1GWXdXbE5YUjA1R1YyczFVMkpZYUZsV2FrcDZUbFpWZVZOcldrOVhSM2hoV1ZSR2QyTnNXa2hOVlhScVRWVTFlbGxWV210Vk1rcEpVVzA1VjJGcmJEUldWekZTWkRBeFYxcEhSbE5pVjJoM1ZtMXdUMkl4V2xkWGJHaE9Va1ZhVTFSV1pGTlhSbVJ5VjIwNWFFMVZiRFpXVnpWRFZsWmFWMU5yVWxWaE1YQm9Xa1ZWTVZac2NFZFhhelZvVFRCS1MxWnRlR3BOVmsxNFYyNVNWR0pIZUc5VmExVXhZVVphZEdWSVpHcGlSM1ExV2xWa01HRnJNVmxSYTJ4YVZsWndjbGxWVlhoa1ZtdDZZa1prVGxadVFsbFhWM0JIWXpGWmVGcEdiR2hTYldodldXdG9RMVpHWkZkYVJGSlVUVmQ0V0ZscldtOWhNVTVJVld4a1ZtSllhR2hhVlZwV1pWZFNSVkZzWkZOaVNFSTFWa2Q0YjJReFpITlhiR2hXWW01Q1lWWnRlSGRoUm10NVRWVTVWRkpyY0hwWGEyUnpWVEF4UlZWcVdsZE5ibWhZVjFaYVlXUkdXbkphUjNCVFZqRktiMVpYY0U5Uk1WcEhZa2hLYUZKVk5XOVZiVEZUWld4a2NsVnNUbGhpUm13eldXdFNVMVl3TVhGV2JFSlhZbFJHUjFwV1dsZGpNa3BIVjIxc1YxSldXWHBXYTFwVFVqRmtkRlpzV2s1V1ZscFlXV3RrVTFReFZuSldiVVpQVm0xU1ZsVlhNVWRYYkZwellrUldWazF1YUhwV2JURkxZekpPUjJGR2NGZE5NVXB2VjFaV1lWWXlVa1pOVmxwUVZtczFjRlV3Vmt0VGJGcFlUVlJTYUUxV1NubFVWbWhUWVVaS2RWRnNhRlZXZWxaVVdWVmFhMVl4WkhOVGJYaFhZa1Z3WVZkV1ZtRmlNa1pZVW1wYVYySlViRmhXYWs1RFZFWlNjbGR0UmxkTlZuQXhWa2Q0YTJGV1RrWlRiRUpZVmpOU2FGcEVRWGhTTWs1SFYyeG9hR1Z0ZUZoWFZtaDNVakZrVjJOR1dsaGlWR3haVldwQ1YwNVdiRlpYYkU1WFRXdGFlVmt3VmpSV2JVWnlZMFpDVm1KWVRURldha1ozVTBkS1IyRkdUazVpVjJkNVZtMHdlRTVHVlhoVFdHeFZWMGQ0VmxsdGN6RmpWbFp6V2taT1YySkhlSHBYYTFKVFZsVXhWMkpFVGxkaVdGRjNWakJrUzFOR1ZuVmlSbVJwVmtWV00xWnNVa0psUm1SSFZtNUthVkpzY0U5WmJYaExaVlprVjFwRVVsVk5WVFZZVlcwMVQyRldTblZSYkdoV1lrWndNMVpHV21GWFIxSklVbTF3VGxadGR6Qldha28wWXpKR1IxTnVVbFpoZW14aFZtdFZNVkpHVm5GU2JVWnFZa2hDUmxaWGVHdFViRnAwWkhwR1YxWkZiekJaYWtwSFVqRk9kVlZ0ZUZOaVdHaFpWMWQ0YjJJeVJrZGlSbHBZWWxWYVZGWnRkSGRsVm10M1drUlNWMDFyY0VkWk1GSlhWMFphYzFkdGFGZFNSWEJJVm1wR1QxZFhSa2RWYld4cFUwVktXbFpzWTNoT1IxRjVVbXRrYWxKV1dsVlpWRTVEWXpGV2RFMVdUazVXYkZZMVdsVmtNR0ZHV25OalJtaGFUVVp3ZWxacVJrdGtSbFpWVVd4YWJHRXhjRkZXYlhCSFlUSlNWMVp1VW10U2F6VlBWVzAxUTFkV1duTlpNMmhQVWpBeE0xUnNhRTlXTWtwSVlVaEdZVll6YUdoV01GcFRWbXhXY2xwR1VsTmlSM2N4VjJ0V1UxVXhXWGxTYWxwVFlrZG9ZVlJWWkZOa2JHUlhWMnQwVjAxV2NIaFdWM2hyWVZaS2RWRnNiRmhoTVZweVZXcEdTMk5yTlZkYVIwWlRUVzVvV2xaWGNFSk5SVEZIVjI1U1RsWkdTbTlVVlZKWFUxWlZlR0ZJVGxkaVIxSkpXVlZhYjFkdFNsbGhSWGhYWVRGd1lWcEVTa2RTYkZKelYyczFWMDB5WnpGV2Frb3dZV3MxVjFwSVRsaGliRXB6VlRCa05GZFdiRlZUYXpWT1ZteHdWbFZ0ZERCaGF6RllWV3BHV21FeGNISldSekZIWTJ4YWNWUnNaR2xYUlVwRVYyeFdZV0V4V1hoVGJsWlVZbFZhVkZsclduZGtNVnBZWTBWa1UySldSalJXTWpWVFlXeEtXVlZzVmxWV2JGb3pWRlZhVm1WSFJrbGFSMmhUWVROQmQxWnNZM2RPVmxwWFYxaHdhRkpYVW1oVmExWmhZMnhhY1ZKc1pHcGlWa3BJVmtkek1WWXdNVlpqUlhCWFlrWktTMVJXV2twbFJuQkdZVVpTYUUxdGFGaFhWekV3VXpGWmVHSkdhR3RTTUZwV1ZXMTRjMDVXY0ZaYVJXUm9UVlZzTTFSc1ZtdFdWVEZYWTBkb1YxSjZSa2hVYlhoaFkxWmtjMXBIYUdoTmFtZ3pWbTB4ZDFJeFduUldiR1JWWW10d1dWbHNhRU5XVmxaelZXeGtXRkp0VWxsYVZWcFBWVEF4VjJORmFGZFdNMmh5VmpCa1MxWnNaSE5XYkZwb1lURndiMVpVU2pSaE1rNXpZMFZzVldKR2NFOVZhMVpoVXpGYVYxcEVRbWxOVjFKSVZqSjBZVlpIU25OalIyaFdZVEZhYUZkV1duZFdNV1J5VDFkd1RsWnVRalpXYTJRMFlURlZlRmRzYkZKaWJIQllXV3RrVW1ReFduRlNhM0JyVFVSV1YxZHJXbXRoVjBWNFkwWldXRll6VW5KV1ZFcFBWakZXYzFwSGFGTldWRlpXVmxjeE5HTXdOVmRWYkdSb1VsUnNXRmxZY0VkWFJtdDNWbTA1VjAxRVJqRlpWV2gzVmpKR2NsSnFVbGRoYTNCUVZURmFhMlJHU25OVWJFNVhZbXRLVGxacVNqUldNV3hZVlZob1ZGZEhhSEZWYkdSVFlqRldjVk5xVWxkU2JFcFpWRlpqTlZadFNrZGpSRUphVFVaYVVGbFZWWGhXTVZweFZXeG9hRTFXY0hsV2JUQjRVekZKZVZSclpHRlNia0pZVld4b1ExWldaRmxqUldSWFRXeEtTVlp0ZEhOWlZrcFZWbXhTV21KWVVreFdNRnBoWkVVeFdXTkZPVmRpVmtwSlZsUkdiMkV5Um5OVGJHaG9VakJhWVZaclZtRlVSbXhXVjJ4d2JGWXhXa2xWYlhoclZHeFplRk5zWkZkV2JWRXdXVlJLUjFOR1NsbGFSbWhYVWxWd1dWZFdaREJUTWtaSFYyNUdWR0Y2YkhKVmJYUjNaVlprY2xkdE9XaFNNVnA2VmpKNFYxZEdXalpTV0dSV1pXdGFWRmw2Um10WFYwWklZVVpTVTAxVmNGWldhMXBoWVRBMVIxcEdaRmhoTWxKdlZXNXdjMkl4YkhKV2JtUllVbTEwTTFZeWRFOVdNREZ5WTBWb1ZrMXVhSFpXYWtwR1pVZE9TRkp0UmxOU1ZuQnZWMVJKZUZVeFNYaFhiazVWWWxkNFZWVnNWbHBsYkZwMFpFZEdWMDFyYkRWVk1XaHZWbXhrU0dGR1ZscGlXRTE0V1RCYVYyTnNaSEprUm5CWFlsaG9WMVpYTURGaE1rWjBVMnRrYVZKRk5WaFVWM0JHWkRGYWNsZHJjR3hTYlZKNVdWVmFhMVJ0U25SYU0zQllWbXhhVjFwVlpFNWxSbEoxVkd4a2FWSXhTbmRXYlhSWFZtMVJlRnBHYkdwU1dGSlhWRlpWTVZOR1duUk9WWFJvVm10c00xWXllRk5XVmxvMlVtNWFWMkpHY0hKV01HUlRVMFpLZEdSSGJGZGhNV3QzVm1wS01GbFdXWGhYYkdoVVlteEtWMWxyV2t0V2JGcDBaVWhrVGsxV2NIaFZiWGhQVmpBeFdGVnFRbUZTVjFKMldWWmFTMVpXV25KalJtaFhZa1p3YjFkV1VrZGhNbEpIVkc1S2FGSXlhRlJaYTFaM1ZqRmFkR1JHWkZwV01WcDZWakkxVDFkSFJYbFZiR3hYWVd0S2FGVXdXbk5XYkdSeVQxZG9WMkV6UVhoV1ZscFRVekZaZDAxV2FGWlhSMUpoVm10V1lWTXhjRlpYYlVaWVZqQmFTRmxWV205Vk1ERjBZVVprVjAxV2NGUlZla0V4VWpGd1JscEhiRlJTVkZaMlZsYzFkMk14WkVkVmJHUm9VbFUxV0ZSV1duTk9WbkJXWVVkMGFGWnJjSGxaTUdoM1Ztc3hkVkZyYUZkaVZFWk1WakZrUjFKdFZrZGpSbVJwVTBWS1RsWXlkR0ZaVmtsNVZGaG9VMkpyTlc5VmJURlRZekZzVlZGdVNtdE5WbXcwVjJ0b2ExVnRTbGRYYTJ4WFVtMW9kbGxYZUV0WFJsWjBZVVphYVZaRldsVlhWRUpoV1ZkTmVGcElWbUZTYlZKd1ZXMDFRMU5XV25GVFdHaE9VbXh3ZVZSV1dtRlVNVnBZWVVab1ZWWXpRbGhXYTFwaFVsWktkRkpzWkZkTlNFSktWa1JHWVZsWFJsZGFSV1JVVjBoQ1dGVnRlSGRoUmxweFVtMTBVMkY2VmxoV01uaFhZVlpKZUZOdVpGZGlXR2gyVlZSR2MxWXhaSFZVYlVaVVVqRktWMVpHV21Ga01sWlhWV3hrV0dKWVVtOVphMVp6VGxac1ZsZHRkRmhpUm13MlZsY3hiMVl3TVVkalNHeGhWbTFTV0ZVeFduZFNNVkp5VGxab1UxWllRa3BXYlhSclRrZEZlVk5ZYkZSaE1taFZXVlJLVTJOV1ZuRlJiVVpZVW0xNGVsbFZZelZXTVVwelZtcFdXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWbGhTYTJSWVlrZG9XRmxyVm5kVVZtUllZMFYwVkdKV1draFdNalZYVm0xS1dXRkdVbGROUm5CTVdWVmFZV1JGTVZWVmJYUk9Za1p3V1ZacVNURlVNVnAwVWxoc1ZtSkhVbFpXYlhoaFRURlNWbGR0UmxoU01WcEpWREZhYTFSc1NrWlhhbEpYVmpOb2RsbFVSbHBsVmtwMVUyeE9hR0pGY0ZsWFZtUXdaREZXUjFadVRsaGhNbEp4VkZaa1UwMUdiSEpYYlhSV1RWWndNRlF3YUhOV01rcFZVbGhrV2xaRlJYaFZha1ozVTFaV2MxcEhhRTVpUlhCWVZqRmplRTFIVVhsVWEyUlhZbXhLVDFadGN6RlhWbFowWlVkR2JHSkdiRFZVYkdRd1ZsZEtWbU5GYkZkV00yZ3pWakp6ZUZJeFpGbGFSbVJYVWxWWk1GWnRNSGhUTVVwWFZtNU9ZVkp0VW5OWmExcDNWR3haZUZkc1pGcFdhelV3Vm0xNGIxVXlSWGxWYkdSYVlUSm9SRmt3V2xkalZrcHlaRVUxYVZKdVFqUldWekI0VWpKR1JrMVdaR2xTUmtwaFZGVmFZV1ZzYkZobFJYUlhWbXh3ZWxsVldsZFdNa3BIWWpOd1YxSjZSVEJaVkVaclUwWldjbUZHVG1sVFJVcFpWMWQ0WVZNeFRuTlhiRlpVWVd4S2NWUldXbmROUmxWNVpFYzVhRkpyY0hwWk1GcHZWMjFLUjFOcmFGZGhNWEJvV1RKNGEyUldjRWRoUms1T1ZtNUNTbFl4VWtOaE1EVkhWMWhvV0dFeGNGbFphMlJUVjBac2NscEdTazVTYlZKWVZqSjRUMkZyTVZaT1dHeFhUVzVvZGxsVlZYZGxSazV6WWtaa2FWWkZTVEJXYkdONFZXMVdSMVp1VGxoaVIyaHdWVEJXUzJWc1duUk5WRUpyVFZkU2VsbHJhRXRYUjBwSVZXMDVWbUZyU2pOVmFrWnlaREZ3U0U5V2FGTmlTRUYzVm14YWIyRXhaRWRYYms1cVVqQmFhRlpzWkZOVlJsWnhVbTVrVTAxcldrbFpWVlV4Vkd4YVdWRlVRbGRpVkVJeldrUktWMUl4V2xsaVJtUnBZWHBXYjFaVVFsZGtNa1pIVmxoa1YxWkZXbkJVVmxwM1RVWndWbUZGT1ZWTlZuQXdXbFZhYTFZd01YRldia3BYWVd0R05Ga3lNVTlTTVdSelYyeGthVll5WjNsV2FrWmhXVlpOZUZOdVRtRlRSWEJ6VlcwMVExUXhiSFJqZWtKT1VteHdNRlJXVWxOaE1ERldUbFZzVjFJelVuSldiR1JMVTBaV2RWRnNXazVTYkhCTlZtMHhORmxYVWtaTlZteGhVbXR3VDFsVVJscE5WbHBWVW0wNWFVMVhVa2xWYkdoelZtMUtTRlZ0UmxwV1JYQlVXa2Q0Y21WR1pIVmFSbWhUVFZWd1NsWlhNVFJoTVZWNVUydGFhbEp0ZUZoWlYzUnlaVVphUlZKc1NteFNiVkl4Vm0xNFMyRldTWGhUYkhCWFlXdEtkbFZVUm10U01rcEhWMnhvYUUweFNuaFdSbVF3WkRGS2MxZHJhR3hUUjFKV1dXdFdkMDFXVmxoalJYUlhUV3R3VmxWdGNHRlpWbHBZVld4U1YwMUdjRXhaTWpGTFVqRldkR0pHVGs1V1dFSlNWbTE0YW1Rd01WZFNXR3hUWVRKU2FGVXdWVEZoUmxaeVYydDBXRkpzU2xsWmVrNXZWREZhYzFkcVFtRlNWMDB4Vm0xemVHTnRUa1phUmxacFVtNUNWVlp0Y0VKbFJrbDRXa2hLYkZKdFVrOVpiVEZ2WVVaa2MxWnRkRk5OVlRWWVdUQldhMVp0UmpaV2JHaFhUVVphU0ZSVVJtRmtSVEZKV2tVMVYySkZXVEZXVnpBeFZERmFTRk5yYUdoU2VteFhXVzAxUTJWc1duRlNiazVxVFd0YVIxUnNaRFJWTWtwWldUTnNWMVo2UVhoV1JFcEhZMnN4V1ZOc2FHaE5ibWhYVmtaYVlXUXlVbk5pUm1SWVlUTlNjbFZxUmtwTmJGWllaVWQwYUZJd1ZqVmFSRTUzVmpGSmVtRklTbFppVkVaVFdrUkJlRll4Y0VkaFIyeFhUVEpvVmxac1pEUlZNVmw0VjFob1dHSnNTazlXYTFwTFkyeFNXR042Um14aVJtdzFWR3hXYTFZeFNYZFdhbHBYVmpOb1dGWnRNVWRqYkU1MFlVWmFUbUp0YUc5V1ZFSnJWakZPUjFOdVVtaFNiVkp3Vm0xMGQxTldXbkpYYlVaV1RWWldORll4YUhOVk1rcHlZMFpXV21KSFVuWldNRnBoWTJ4YWRGSnRjR2xTYkZsNlZtcEtOR0V5Um5SVGJGcFlZVEpvV0ZWdWNFZGxiRmwzVjJ0d2JGWXdXa2haTUZwclZHeFplRkpxVGxkTlZuQnlWbFJLVTFJeFduTmlSMmhUVFVad1ZWZFhkR0ZrTVZwSFdrWm9iRkp0VW1GV2JYaDNaV3hhV0dWSGRGaFNNSEI1Vkd4Vk5WWldXbk5qUlhoWFRVWndlbFp0ZUdGalZrWnpZVVpPYUUxdVpEWldNVkpEVlRGRmVHSkdaRmhpUjFKeFZUQmFkMWRHYkhKWGJtUmFWbTVDV1ZwVlZtdGhiVXBXVjJ0c1ZtSllhRkJXUjNONFpFZEdTRTlXWkU1aWJXaHZWMVpTUjFVeVVrZFhibFpXWWtVMWIxUlhlRXRpTVZwWVpVWk9WMDFyYkRSWk1GcHZZa1pKZDFkc1ZsVldiSEI2Vkd0YVdtVlhWa2hrUm1ocFVtMTNNRlpYTVhkV01WcHlUVmhXVm1Kc2NGaFdhMVpoWTJ4VmQxcEZaRlJXYTNCNlZqSnpNVlV3TVZaV2FrNVhZbGhDU0ZkV1pFNWxSbVJ6V2taU2FXSkZjRlZYVjNodlVUSk9SMVp1VW14VFJYQnpWbTE0ZDFkV1VsZFZhMDVvVFVSR2VWa3dWbTlXYXpGeFZteENWMDFIVWtoWk1uaHJZekZ3UjFac1pHeGlSbkJSVm10YVlWbFdiRmhVYkdSVFlrZDRiMVZxVGxOWFJsSldWMjVrVkZadFVsbGFSV1JIWVVVeFYxWnFWbFpOYm1oeVZsUkdhMU5HVm5OaFJtUnBZbXRLUlZaSGRHRlpWMDVYVTI1S2FsSXphRlJaYlhSTFV6RmFkRTFVVWxwV01GcEpWbTAxVDFkSFNrbFJiR2hYWVdzMVJGVXdXbGRPYkVwMFVteGtUbFl4U2pWV01uUmhZakpHVjFwRlpGUmlSVnBZVm01d1EwNUdXbFZTYlhSVFRWZFNNVlpYY3pWV01WcElaVWhhVjFaNlJYZFpla0V4WXpGa2MyRkhlRk5OUm5CWlZtMHhOR1F5Vm5OaE0yUldZWHBzV0ZSVlVrZFhSbXQzV2tjNVYwMUVSa2xXVjNodlZtc3hTRlZzVWxaaGExb3pWVzF6TVZZeFVuTlViR1JwWVRCd1RsWnRNSGRsUlRWSVVtNUtUbFp0VW5CVmJURlRWMVpaZDFwRVVsZFdiWGhXVlRKNFQyRnNXbk5XYWs1YVZsWmFVRmxWV2t0ak1XUjFZMFpvYUUxWVFsRldiWEJIVXpKTmVGZHVSbFppUjFKUFdWZDRZV1ZXV25OVmEwcHNVbTFTU0ZadE5WZGhiRXAwVld4U1lWWXpVbWhVYlhoaFpFZFNTRkpzVWs1V2JrSTJWakowWVdNeVJuTlRibEpXWW10S1dGUlZXbmRVUm14eFVteHdiRkp0VWpCVmJURjNWR3hhZEdSNlFsZGlWRVV3V1hwS1IxWXhUblZUYXpsWFpXMTRWMVp0Y0U5aU1WSkhWMjVTYkZJelVsbFZiRkpIVjJ4cmQxWlVSbGROYTNCWVZUSjRjMWRHV1hwVmJXaGFZV3R3UjFwVldrOWpNa3BIVjIxc1UwMXRhRzlXTVZwVFV6RldjazFWWkdwU2JWSlpXV3RvUTJNeFduTlZhMlJYVFZkU2VWWXlNVEJoUmxweVkwWndWbFp0YUhKV01HUkxVakZrZEdGR2NHeGhNWEEyVm0xd1IyRXlUWGhqUldSb1VtMW9WRlJXVm5kaU1WcDBUVmhrVlUxV1JqTlViRlpyVjBaa1NGVnNiRnBoTWxKVVdUSjRZV05XUm5SU2JGSlRZa2QzTVZkc1ZtdE5SMFpYVTFoa1YyRnNTbUZVVlZwaFRURmFjVk5yZEZoV01GcElWbGQ0WVdGSFJYaGpTR3hZWVRGYWFGZFdaRTVsVmtweVdrWldhVll5YUZCWFZ6QjRZakF3ZUZkdVRscE5NbEp6VlcxNFYwNVdXa2hrUjNSWVVtMVNTVlpYZUhOWGJGcEdUbFpTV2sxR2NGUldha1pyWkZaU2NrOVdUbWxTTTJONFZtdGFZVlV4UlhoWFdHaFlWMGRTY1ZWdE1XOVhSbEpZVGxjNWEySkdjSGhWYlRGSFZESktSMk5JYkdGV1ZuQnlXVlZrUm1Wc1JuSk5WbVJYWld0Sk1GWnJVa2RVTVZsNFUyNVdWV0pWV2xSVVZ6VnZWbFprV0UxVVFsTk5SRlo2VmpJMVUxUnNXa2RUYlVaWFlsUkZNRll4V21GWFIxSklUMVprVjAxR1dUQlhWRUpyWWpGYWRGTnNiR2hTV0doWVZXdFdZV0ZHYkRaU2JHUnFUVmhDU0ZsVldtdGhWa2w2V1ROb1YwMXVVbGhaVkVaS1pWWktjbGRyTlZkaVZrcDRWbGQwVjFNeFdYaGlTRXBoVW5wc2NWbHJaRFJYVm5CV1ZsUldWazFyV1RKV2JYaHZWMGRGZUdORVRscFdiSEJNV1RJeFQxSnRTa2RhUjJ4WVVtdHdkbFp0TUhkbFJsWjBWbXRrYWxKWGVGZFphMVV4WTBaWmQxZHJkRmRXYkhBd1drVmtSMWRzV25SVmEyaFlZVEpvVEZacVNrdFhWbFoxVVd4V1YySklRalpXUjNoaFZqSk5lVkpyYkdGU2JIQndWV3BHUzFOc1duTmFSRkpwVFZkU01GVnNhSE5XYlVZMllrZG9WMkpHY0ROV01GcGhZekZrY21SSGNFNWhlbFpLVjJ0V1ZrMVdWWGhUYkdScVVtMTRXRmxYZEhaa01XeFZVMnhLYkZKc2NGcFpWV1JIVlRGWmVXRklXbGRXZWtJMFZsUkdhMVl4WkhWU2JGWnBWa2Q0ZVZkWGRHdE9SMVpIVmxoc2ExSXpVbGRVVlZKSFpWWlNjMVp0ZEZkTlJFWjRWVzEwYjFZeFdrWmpSWGhYWVd0YVVGbDZSbXRqTVhCSFdrVTFUbEpZUWt0V2JYaHZaREZKZUZWWWFGUlhSMmhvVlRCVk1XSXhWbkZVYTA1cVRWZDRWbFZ0Tld0WFJscHpZMFZvVjAxcVJraFpWRUY0Vm1zMVZtRkdaRTVXTW1nMlYxWlNSMVF4VGtkV2JrNW9VbXhhV0ZSVVJrcGxiRnAwVFZSU1YwMVhVa2xXUjNSaFZVWmFkRlZzYUZwaE1taEVWRzE0YTFaV1JuUmtSazVPVmpOb1dWWnFTalJoTWtaelUxaHNhRkl5YUZkWmJHaHZUVEZaZDFkdVRrOWlSWEI2VjJ0a01GVXdNVWRqUldoWFVqTm9jbGw2UmxabFJuQkdWMnhPV0ZJeFNsbFhWM2hUVW1zeFIySkdhR3BOTW1oWlZXMTRZVmRzYkhKWGJHUllVbXRzTlZsVmFHdFdNVm8yVVdwU1YxWkZXbkpXYWtwTFUxWldkR1JHVWxOTlZYQmhWbXhqZDJWRk5VaFdiazVZWW14S1QxWnNaRk5YUmxwelZXdGtXRkpzVmpWYVZXTTFWakF4UlZKdWFGZGlWRlpNVm1wS1JtVkhUa1psUm5Cc1lUTkNUVlpYZUdGWlYwMTRWMjVPWVZJeWVGUlpiWFJLVFZaYWRFMUlhR3ROVld3MFZrWm9jMVpYU25OVGJGcGFWa1Z3VkZZeFduTmpiR1IxV2tkd1UySkhkM3BXTW5ScVRsZEdWazFXWkdwU1JVcGhWRlZhWVdOc1dYZGFSWFJYVFZkU2VGVlhlR0ZoVm1SSFUyeHNWMkpZYUhKVmVrWlBVakZhZFZWc1FsZGlhMHBaVmxkNFYyUXlSa2RYYTJSWFlsVmFZVlp0TVZOVFZscDBaRWM1VmsxcmNFcFZWM2h2VmxaYVYxTnNhRmROVm5CaFdsWmtVMU5GT1ZkV2F6Vm9UVmhDU2xac1VrcE5WbFY0VjI1U1ZHSnJjRlZaYTJSVFdWWnNWVk5zVG10aVJscDVWakl4UjFkR1NYaFhhMmhhVFVkUk1GWnFRWGhXYlU1R1lrWmthRTFzUlhkV2JGSkhWVEpOZUZwSVRtaFNNMUp6V1ZSQ2QxZFdXblJrUm1SYVZqRktlbGxyYUVkVk1rcFdWMnhzVm1KWVRYaGFWbHB6Vm14d1JWVnNaRk5oTTBKWVYxUkNZV0l4WkVkWGJsSldZV3h3VmxadE1WTldSbXcyVW0xMGExWnJOWHBaVldSelZqRmFkVkZxVWxkTlYxRjNXV3BHUm1WR1RuVlViR2hwVWpKb2VsWlhOWGRqTVdSSFZXeG9hMU5IVWxsVmJYaFhUbFp3Vm1GSGRGaFNhMnd6V1RCV2IxWXdNWEZXYTJoWFlrZFNURlV3V2xkamJVWkhXa2RzV0ZKVVVYZFdiVEYzVXpGSmVGUnJhRmRoTWxKV1dXeGtORmRHVWxoTlZ6bGFWbXh3TUZSVmFHOWhNREZYVW1wV1ZrMVhhSHBXVkVwR1pWWldjMkpHWkU1U01VcFZWMVpXWVZZeVRYbFNhMlJWWWtkb1ZGbHNhRzlPVmxsNVpFZEdWVTFXU25wV01qVlBWMGRHY2xOdGFGZGlSMUpUV2tSR2MxWnNaSFJTYlhSVFlrWndOVll5ZEdGV01WbDVVMnRhYWxKc1dsaFpWM1JMWTJ4V05sSnJjR3hTYmtKS1ZsY3hiMVV5U2xkVGJscFlWbXhLU0ZwRVNsZFdNV1J6Vm14S2FWWldjR2hXYlhCQ1RWVXhSMVpZYkd0U2VteFhWRmQwZDFJeFVuTmhSVTVYVFd0d1dsWlhjRTlXTVZwelkwZEdZVlpXY0hKWmVrWlRZekZhY2s1V1pGZGlSM1F6Vm0xd1MwMUdiRmhTV0doaFVsZG9WVmxVU2xOWFZteHlWMjFHV2xac2NIaFdSM2hQVmxaS2RHUkVWbUZXVm5CUVZtcEJlRmRHVm5GU2JHUlRUVEF3ZUZac1VrdFRNVTVJVldwYVUySkhhRmhWYkZaM1pWWmFXR05GWkZwV01VcElWa2MxUzJGR1NuTmpSemxWVm5wV2RsbFZXbUZrUjFaSVVtMTBUbUpGY0RaV2Fra3hWVEZTYzFkc1pHcFRSVFZYV1d4U1IxWkdjRlpYYlVaVVVqRmFTVlZ0ZUZkaFZrcFpVVmhvVjFadFVqTlhWbHBhWlVaT2NWZHNUbGRTVlhCWVYyeGtNR1F4VmtkaE0yeHFaV3hhV0ZSWGRHRlRWbkJHVjJzNWFGWnNjSGxaTUZKUFZqSktTRlJxVG1GU1JVVjRWbTF6ZUZOWFJrZGhSbWhUVFcxb1lWWXhaREJoTVZWNFlrWmtXR0pzU25OVmJHUlRWVVphZEdWSFJrNVNia0pYVjJ0U1ExZEdTbkpqUkVKWFZqTlNlbGRXV21GWFJsSlZVbXhrYVZaRldrMVhhMXBoVWpKU1dGUnJaR0ZTVkZaVVdXMTBTazFzV1hoaFNHUlRUVlpzTlZaSE5VOVpWazVIVTI1S1ZtSkdTbGhXTUZwelpFZFNSbU5GTlZOaVNFSTJWakZTVDJFeFVuTlhiazVUWVd4S1dWbFVSbUZqYkZweVdrVjBhbUpWTlVwVmJYaGhWR3hKZUZKWVpGZGhhMXBvV1hwR1lWWXhVblZVYkZab1pXeGFVRlp0TURGUk1WbDRWMnhXVkdGclNrOVZiWGh6VFRGU1YxZHRSbFZOVjFKS1ZWY3hSMVpXV2xkalJFNWhVak5vYUZreFdrOWpNWEJJWTBkc1UxWkdXbGhXYkZwclRrZEZlVkpzWkZSaWEzQnhWV3hrTkZkV1duUmxSWFJVVW14V05WUldXbXRXTURGWFUycEdWazFxUm5wV1ZFcExVbTFPU1ZwR1pHbFhSMmh2VjJ0U1IxbFdXWGhqUldSaFVqSm9WVlZxUmt0WFZscEhWMjFHV2xack5VaFdNV2h6VkRGYWNrNVdXbHBoTVhBelZUQmFWbVZWTlZaa1JtUlhZa2hDTmxadGVHOWlNVmwzVFZWa2FsSXlhRmhVVldSVFYwWlZkMXBHVGxSU01GcElWa2N4YjFSdFNuUlVhbFpYWWxSRk1GbFVRVEZUUms1WllVWm9hVkl4U2xwWFYzUnJWVEZhVjJKR1ZsUmlWR3h2VlcxNGQwMUdjRlpoUjNSb1VtdHdNVlZYZEd0WFIwVjRWbFJHVjJFeGNFeFpNakZQVTFkT1IyRkhhRTVpUlc4eVZtMTRVMU14VFhoYVJtUm9UVE5DY0ZWdE1WTmpSbFowVGxWT2JGSnRVbnBXYlRFd1ZrZEtWMWRyYUZoaE1YQjZWMVphUzFaV1duTmhSbVJvWVRGd1RWZHNWbUZaVm1SSVZHdGFhMUl5ZUU5V2JURXpUVVprV0dSSE9WVk5hMXBJVlRKd1lXRldTblJWYkdSYVlrWktXRlZyV2xaa01XUnpZMGQ0VjAxRVVYbFdiVEI0WWpKR1NGWnVTbGhpUjNoWlZtdFdTMVpHVmxWU2JYUnFUVmRTZWxkcldtdFhSa2w1WVVac1YxSnNXbWhhUkVaVFVqRmtkVlZyTlZkV1IzaFZWa1prZWsxV1RrZGFTRXBoVW5wc2IxVnNVa2RsUm14V1ZXczVWMDFyV25sV01qRnZWMFphZEZWck9XRldWbkJ5VmpGa1IxSXhjRWhpUms1T1RXMW5lbFp0ZUdwbFJUVkhZa1prWVZKdFVsaFpiWFJoVmxac2MxVnVUbXBOVmxvd1dsVm9hMWRHV25WUmJHUllZVEZLUkZacVNrZE9iRXB6WVVad2FFMVZjRlZXYWtsNFVtMVdXRkpyWkZKaVIyaFlXV3RvUTFSV1draE5TR2hVVFZVMVdGVXlOVTlYUjBwWVpVWnNWbUZyY0haYVIzaGFaVmRXU0dSRk9WTk5SRVV3Vm1wSk1WUXhaRWhUYmtwcVVtdGFXRmxzVWtka2JGcHlWMnhPVjJKVldrZFdSM2hUVmpKS1YxTnNjRmhoTVZwb1ZrUkdZV05yTVZkYVIyeFRVbFJXVjFadE1IaGlNVTVIVjJ4V1UySllVbFZWYlhoaFpXeHNWbGR0Um1oU01Ga3lWbTF3UzFZeFpFbFJhMmhoVWtWYWFGbDZSbmRUVms1elVXeGtUazFWY0ZwV2ExcFhZakZGZUZSc1pGaGliRXBQVm10YVMySXhVbGhrUjBaWVVteFdOVlJzV210V2JVcFdWMjV3VjAxdWFIWldNakZMVWpGT2NtRkdWbGRTVm5CWlZrY3hORk15VG5SVWEyaHNVbTFTY0ZWc2FFTmhSbGw0V2tSQ1dsWnNiRFZWYlhSaFZHeGtSazVXVmxwaE1sRXdWakZhWVdOV1VuTlViWFJwVW14d1YxWlhNSGhOUmxWM1RWWmthbEpGV2xoVmJuQkhaR3hhVlZKdFJsZFdiSEI2V1d0YWEyRldXa1pXV0dSWVlURktRMXBWV2twbFZsSnlXa1pvYVZaV2NGVldiWEJIVXpGa1YxZHJaRmRpUlRWVVZGZDRZV1ZzV25OaFNFNW9UVlUxUjFSc1dtOVdWbHB6VjI1d1ZXSllhRmhXTUZWNFYwVTVWMXBGTlZkaWEwcEpWakZTUTFZd05VZFhXR1JPVm0xb1YxbFVTbTlXTVd4WVpFaGtWRkpzV25oVk1uTTFWa1pKZDFkclpGVmlSMUo2VmxSR1lXUkhVa1ZXYkdScFZrVldNMVl4V21Gak1WbDVVMnRrWVZJeWVGUlpiRnBMVm14YWNWRnRkR2xOYTFwSVZteG9hMWRIUlhwVmJHUlhZbGhvTTFwVldsWmxWVEZGVm14a1YxWkZXbGxYVkVKVFVURmFXRk5yWkZoaVJVcFlWV3RXWVdGR2JEWlRhemxUWWxWYVNGZHJWVEZoUjBWM1ZtcFNWMkpVUlhkV2JURlhVMFpTZFZSdFJsUlNiSEI0VmxjeE5HUXhVWGhpUm1oc1VqQmFXVlp0ZUhkbGJHUlZWRzA1VjFKVVJsaFpNR2gzVjBkRmVXRkdRbHBXVm5CTVdrWmFSMlJGT1ZkV2JHUnBWakpvUlZZeWVHdE9SbXhYVTFob1YySnJjR2hWYWs1VFZERmFjVkpyZEZSaVJuQXdWRlpTUTJGRk1YSlhibkJXVFZkb00xWnRNVWRPYlVwSFlVWndWMDB4U205V2ExWmhWVEpTU0ZacmFHdFNiVkpZV1ZSR2RtUXhaSEpXYkZwUFZteFdNMVJXVm10aGJFcDBaVVpvV2xZelVqSlVWVnB6VmxaT2NscEhjRTVXVkZZMlYxZDBZVmxYUmxkVFdHeG9VakpvV0Zsc2FFTlZSbHBWVVZob2FrMVdXbnBXTW5odllWZEdObFpzYkZkaVZFVjNXa1JLVjJNeVJYcGFSMFpUVW10d1dGWkdaREJYYXpGelYyNVNhbEl3V2xoVVZWSkhUVlphV0U1VmRGcFdhM0JIVmpJeGIxWnRSbkpYYkVKWFRWZFNVRlV3WkVkU01WSjBZa1pvVTAxdGFHaFdiWEJIWVRBMVNGTllhRk5YUjJoWVdWUktVMWRHYkhKWGJVWlhVbTE0V2xrd2FFOVdNVXB6VTJ4c1drMHpRa2hXVkVGNFZqSk9SVkZ0UmxkV2JGVjRWMVpXWVZNeFdsZFNia1pWWWtad1QxbFhlRnBsYkZwMFkwVmtXR0pXV25wVmJUVkxWbGRLUjFkc2FGcGhNbWhFVmtWYWEyTXhXblJrUmxKT1ZsZDNNRll5ZEc5VU1rWkhVMWhzYUZORk5XRlphMlJ2Wkd4U1dHVkhSbXRTVkVaS1dWVlZNVlV3TVZaWFZFSlhZV3RyZUZaRVJtdFRSazUxVkd4U2FWSlZjRmxYVm1SNlRWWmFSMWRZWkZoaVJUVlpWV3BHUzFOc1pISlhiWFJvVm10d2Vsa3dVbUZYUmxwelYyNUtWVlpXY0hKWmVrWnJaRlpPZEdOR1RsZE5WWEJaVmpGa01HRXlTWGxWYms1WVlteEtUMVpzWkZOalZteHlXa1pPVGxac1ZqVlVWbFpyVm1zeGNtTkZjRlpXTTJoSVZqQmFhMU5XUm5KbFJscG9ZVEZ3VVZaVVFtRlVNazV6WTBWb1UySkZOWEJXYlhSM1RURlplRmRzVGxKTmF6RXpWR3hhYTFkSFNuTlRhemxYWVRGYVRGZFdXbUZrUlRGVlZXeG9VMkpZYURWV2FrbDRUVVprUjFOdVVsWmhNbmhZVm1wT1RrMVdXblJqTTJoVVVteGFNVll5ZUd0aFIwVjRZMFJhV0ZaRmJ6QmFSRVpLWlVaV2RWUnRhRk5pVmtwM1ZtcENhMkpyTVhOWFdHaFlZa2RTWVZadGVFZE9SbVJ5Vm0xMFYxSXdjSGxVYkZwWFYyMUZlVlZVUWxwV1ZuQllXWHBHZDFORk9WaGpSMnhUVFRKbk1WWnFTakJXTURGSFZsaGtUbFp0VW5GVk1HUnZWMFpzYzJGSE9WaFNiWGhZVmpKME1HRnJNVmRqUm5CYVZsWndjbGxXV210U2JFNXlUVlprV0ZORlNrbFdNVnByVlRGSmVGWnVWbFJpUjJod1ZtcEtiMVpXWkZoa1J6bFNUVlphU0ZkcldtdFpWa3BIVTJ4c1dtSkdjR2hhVjNoYVpWVTFWbHBHWkZOaVZrcEtWMVpXWVZVeFdsZFhXSEJWVjBkb2FGWnFUbTlqYkd0NVRWVmtVMDFXU2pCWlZWcFBZVVV4ZFZwRVdsZGlXRUpNVkd0YVZtVkdaRmxpUms1cFlUTkNXbGRXVWs5aU1XUkhZa2hLV0dKdFVtOVZiWGgzWld4WmVXUkVRbWhOVlhCNVdUQm9kMVl3TVhWVVdHaGFWbGRTV0ZsNlJtdFdWa3B6V2tkb1RsWllRa3BXYWtaaFlURktkRlpyWkdGVFJUVnZWVzE0UzJOR1ZuRlRiVGxzWWtad1dWUldVbE5XUlRGWVpVWm9XbUV4Y0ZoV2EyUkxVbTFPU1ZOc1ZsZGlTRUpOVjJ4YVlWZHRWbFpOVmxwaFVqSm9UMVpzWkROTlJscFZVMnBDYWsxWGVGaFZNbmhyVmpGYVJsZHNhRmRoTVZwSVZHdGFWMk5XVG5KUFZrNVhZa2hDTmxZeWRHRlVNVkp5VFZoU2FGTkdjRmhVVmxwM1ZrWldjVk5yV214U2F6VmFXVlZrZDFVeFduVlJibHBYVm5wRk1GcEVTa3BsUjA1SFlVVTFWMUpyY0ZwV2JUQjRWVEZrVjJOR1dscGxiRnB2Vm14U1IxSnNWbGhqUms1WVlrWndSMVJzYUdGV01ERklWV3Q0Vm1GcmNGQlZNVnBQWXpGYWMxcEZOVTVXV0VJeVZtMTRhMlF4U1hoaVJtUlZZVEpvV0ZsVVNqUmhSbFowVFZaT1ZVMVhlRlpXUjNSUFZrWktkRlZzV2xaV2VrWklXVlpWZUZZeVNrVlViRlpYWWxkb1dWWnRNSGhUTWs1eldraE9XR0pJUW05VVZtaENaV3hrVjFadFJscFdNRFZZVlRJMVMxVkdXWHBWYkdoYVlURmFNbHBFUm10V1ZrWjBVbXhhVGxac1dYcFdSbHB2VlRKR1IxTnVVbXhTYldoV1ZtMHhVMVV4VWxaWGJVWlhWbXR3ZVZrd1pEUlZNa3BHWTBSV1YwMXVVbWhaYWtwSFZqRk9kVlJ0Y0ZOaVNFSmFWbTB4TkZNeFZrZFhiRlpUWWxoU1ZGUlhkSGRUUm14eVdraGtWazFyY0ZoVk1uaHpWakZLYzJOSVNsVmhNWEJoV2xWYWExZFhTa1pQVm1ST1RWVndXbFpyV2xkVk1VbDRXa1ZrYUUweVVsZFpWRXBUVjBac2NsZHVaRTVTYlhoWFZsZHpOVll3TVVWU2EyaGFUVWRTU0ZkV1dscGxiVVpIWVVkR1UySklRbEZYV0hCSFlUSlNTRk5yWkdGU2F6VllXVzEwUzJGR1duUmpSV1JwVFd4R05GVXhhRzlXVm1SSVpVWmtXbUV5VWxSV2JYaHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSbk5UYms1cVVrVkthRlZzWkc5amJGbDNXa1YwVTAxck5VcFphMXByVkcxS2RHRkdSbGRpUjFJMldsVmFZV05yTVZkV2JGcHBVakZLVlZaR1VrdGlNbFpYVjFob1dHSlZXbFZVVjNoTFUwWmFkRTVWT1ZwV2EzQXhWVmQ0YjFadFNrZFRiR2hYWWtad2FGcEZaRTlTYkhCSFYyczFWMkpZWTNkV2JYQktUVlpaZUZkc2FGTmhiSEJ3VlcxNFMxbFdiRlZUYlRsVFVteFdOVnBWWkVkV1JrbDRWMnRzVm1KVVJuWldSM2hoWkVkU05sRnNaR2hoTVhBeVYxWlNTMUl5VFhoVWJrNW9VakpvVkZSVlduZFdNVnAwWlVkMFZrMXNTbnBXYlRWTFYwZEtWbGR1U2xaaVJrcElWbXBHZDFKc1pISlBWbFpwVW01Q1YxWnRNWGRaVm1SSFYyNU9XR0pYYUdGV2ExWmhWa1pzTmxKdGRHdFdiSEI2VlRJeGMxWXhTWHBoUm5CWFRWWndjbFJWV2s1bFJtUlpZVWR3VTJKSVFscFhWM2hYV1Zaa1IxVnNaRmhpYlZKUFZtMTRkMWRXVWxkVmEwNVhZWHBHUmxWdGNFZFhiRnBYWTBod1YwMUdjR0ZhVjNoWFpGWmtjMWRzWkZOV2JrSTFWakZvZDFJeVJYbFZiR1JYWW14S2NWVnRjekZYVmxaelZtNWtWbFpzY0RCVVZXaHZWREZLYzJKRVRsVmlSbHB5VmpCa1MxTkhSa2RSYkdScFVtdHdObFpxUW1GWlYwNVhVbTVPWVZKVWJGaFpiR2h2VjBaYWNWTllhRTVTYlZKSlZUSjRZV0ZzU25WUmJHaFdZbFJHZGxwSGVHRmpWazV5V2tkd2FWSXhTWGhYVkVKaFpERlNkRk51VW1oVFIzaFpWbXRXYzA1R1dsVlNhM0JzVm10d2VWZHJXbGRoVmxsNllVWldXRll6VW5KVVZWVjNaVVprZFZWck5WaFNNVXBXVjFkNFlWbFdUa2RXV0dob1VucHNXVlZ0TVZOVFZscFlZM3BXVjAxRVJraFdNbkJQVmpBeFYyTkljRmRpUm5CVVdUSjRVMk15UmtkVWJXeFRZbXRGZDFadE1UQmhiVkYzVGxab1UySnNTbFZaVkVwVFkxWldjMXBFVWxkaVJuQXdXbFZrUjJGR1NuUmxTR3hZWVRGWmQxWlVTa3RUUmxaeFVteHdhRTFZUVhwV2EyUTBVekpTVjFKdVZtbFNiV2hZV1d0b1EySXhXbFZUV0doV1lsWkdNMVJzV21GaFZrbDZVV3hTV21KR2NFeFdiRnBoVWpGV2NtUkhiRTVoTW5jd1ZtcEdiMkl4WkVoVGJGcFlZa2Q0WVZsclduZGhSbFYzVjI1S2EwMVdjREZXUjNoclZUQXhTVkZyY0ZoV2JGcDJWVlJHV21Rd01WWmFSbWhvVFRKb1dWZFhkR0ZrTWs1elYxaGtZVkpyTlZSVVZtaERVMVp3UmxaVVJsZE5SRVpYV1RCYWQxWXlTbGxSYTNoVlZsZFNSMXBWV25kU2JVWkhWVzFzVTJKclNtRldNV040VFVkUmVGZHVUbGhpYTFwV1dXeFNjMkl4Vm5ST1ZVNVlWbTVDVjFsVlZqQmhSVEZGVW14b1drMUdTa1JXYlRGTFYxZEdTVk5zWkZOTk1taG9WMnhXWVZReVRuUlVhMlJvVW0xU2NGVnROVU5rYkZsNFdraGtVMDFYZUZoV01XaHZXVlpPUjFkc1dscGlSMmhFVm10YVdtUXhjRWhQVjJ4T1ZtNUJkMWRVUWxaT1YwWldUVmhPV0dKdVFsaFVWM0JYVmtac2NsZHJjR3hpUmxveFZXMTRkMWRHVGtaVGFscFhZV3RhYUZsNlJtRmpNWEJKVlcxMFUwMXRhRlZXYlhSWFUyMVdjMWRzVmxSWFIyaHdWRlphYzA1V1ZYbGtSM1JvWWtVMVIxWXlNVzlXTWtwSFkwUk9WbVZyV2pOV2JYaHJaRWRTUjJGR1pHbGhNSEJKVm10a05GbFhTWGhXV0d4VVlUSjRVMWxyWkRSWFJsSlhXa1pLYTAxWGVGWlZNblIzWWtaSmQyTkZhRmhoTWxKNlZsUktTMWRIUmtsaVJtUlhVbFZ3ZVZac1VrZFpWa2w0Vm01T1lWSXlhRlJXYkZKWFYxWmFSMWR0Um1wTlJGWllWbGQ0YTFadFJYZE9WemxXWVd0S00xWnFSbkprTVZwMVdrWmthVkp0ZHpKV2JHTXhXVlpaZDAxWVZtaFNNbWhZVkZWYWQxZEdjRWRhUlRsVFRXczFTRmRyV210VWJGcFpVVzFHVjJGclduWmFSRVpLWlZaS1dXSkdWbWxTTVVwWlYxY3hlazFYUmtkV2JrWlVZV3hLV0ZWdGVFdFhSbHAwWlVkMFZXRjZSbGhaYTFKVFZqQXhkV0ZHUWxkV2VrWklWRzE0UzJNeVJrZFhhelZYVFcxbk1sWnRNVEJoTVVwMFZteGtWMkpzU205VmJYaDNZMFpaZDFwSE5XeGlSMUpXVlZjeFIxWXdNWE5UYTJSVllrWndhRlpzWkV0VFIwWkpVV3hhYUdFeGNFMVdha28wV1ZaSmVGZHVVbEJXTW5oUFZtMDFRMDVXV2tkWGJVWm9UV3RhV0ZVeWRHdFdSMHBJWVVkR1dtRXhjRXhXTUZwaFkyeGtkVlJ0Y0dsU01VbzFWa1JHWVZVeFZYbFRhMlJwVFRKb1dGbFVTbEpOUm1SWFdrVmtWMDFZUWtkWlZXUnZWVEpXZEdWR2JGZFdla1V3VjFaa1IxSXlUa1pXYkU1cFZsWndlVlpYTVRCa01sWlhZa1phWVZKRlNsZFVWVkpIVFVac1ZsZHNaRmROYTNCYVZsZDRiMWRHV25OalJYUmhWbFp3Y2xsNlNrZFNhelZYV2taT2FFMHdTWHBXYlhSaFdWZEZlRlpZYkZkaVIxSlhXV3RrVTFkR2JITlZiazVwVFZaYU1Ga3pjRWRXUmtwMFpFUk9WMDFxUVRGV01HUkxVakpLUlZkc1pGZE5NRXBSVm0xd1IxTXhXWGxVYTJoVFlsVmFXRlp0TlVKbGJGcFlUVlJTYTAxVmJEUldiVFZQV1ZaSmVXRklUbHBoTVhCNVdsWmFZV1JIVGtaa1JUVlRUVVpaTVZaVVJtOWpNVlY1VWxob2FsSlViRmhaYTJSVFZrWnJkMWRzWkdwaVIxSXhWMnRhYjFVeVNrWmpSbkJYVWpOb2FGWkVSbHBsUms1MVZHeG9hVkl6YUZkV2JURTBaREpPYzFkc1ZsSlhSMmhZVkZaVk1VMVdhM2RYYm1SWFRWWndNVlZYZUVkWFJscHpWMnhrWVZaWFVrOWFWVnBUWkZaV2MxRnNaR2xXYTNCYVZtdGFVMU15U1hoWGJHUllZbXhLY1ZWc1pGTmlNVkpYVm01T1QxWnNWalZhUldoUFZqSktWbU5HY0ZkV00yaFVWbXBCZUZJeVRrWmxSMFpYWWtoQ2VWWnFRbXRWTVU1SFUyNVNhMUpVVm5CVmJUVkNUV3haZUZwRVFscFdiWGhaVlcxMGExWkdaRWxSYkdSYVlUSlNWRlp0ZUdGak1XUnlaRVpTVTJKSVFqUldWekUwVkRGWmQwMVdaRmhpYmtKWldWUkdkMk5zV2tobFIwWllWbXRhV2xkcldtOVdNa3BIWTBSS1YwMVdjR2hXTWpGWFZqRlNkVk50YUZOaVNFSjJWa1pTUzJJeVJrZGFTRTVoVWtWS1lWWnFRVEZsYkd4eVZXMUdWazFyY0VsV1Z6VkhWbFpaZWxSWWFGWk5WbkI2Vm0xNFlWWldTbk5oUms1b1RUQktXVlp0Y0VkVk1VMTRWMWhzVTJKcmNGbFphMXBMVmpGYWNsWnRSbXhpUm5CNFZXMHhNRmRHV1hkalJXaFhUV3BHZGxaSGVHdFNiRTV6VTJ4a2FWWkZTVEJXUjNSclZXMVdSMXBJVmxWaVYzaFZWV3hvUTFkc1pGaE5TR2hXVFZkU1NGWnROVk5VYkZwSFUyNU9WMkpVUlRCV2FrWmhaRWRTUlZGdGFGTldSVnBIVmxjeE5HTXhXWGhYV0hCb1VqSm9XRmxzYUc5WlZuQllUVlZrVkZack5YcFpNRnByVmpKS1IyRXpaRmRpVkVZelZYcEdVbVZHVG5WVWJYQlRWakZLV1ZkWGRHdFZNazVIVmxoa1YyRXpVbkpaYTFwM1RVWndSbGRyT1ZaTlJFWlpXbFZhYzFZeFdYcFZibHBYVmtWd1IxcFdXbGRrUlRsWFYyMXNXRkl5YUhaV2JYQkRXVmRSZUZwRmFGZGhNbWhVV1Zod1YyTkdWbkZTYTNSUFZteHNOVnBGV2s5V2F6RnlWMjVzVlZac2NIWldiVEZHWlZkV1IyRkdjR2xTTW1oVlYxWldZV014V2xkVGJrcHJVak5TVkZSVlduZFRWbVJYVm0xR2EwMXJXa2RVVmxwelZXeGtTVkZzYUZaaWJrSkhWRlZhYTFZeGNFWk9WM2hUVFVSV1NGWnRNVFJaVjBaWFUxaG9WR0pGU2xoWmJGSkRUa1pTVlZGWWFGZE5WMUo2Vm0xNFUyRkhSWGRqU0ZwWFVtMVJkMWRXWkZkak1WcFpZa2QwVTAweFNuWlhWM1JYWkRBeFIySkdXbGhpV0ZKWldXdGFjMDVzV2tkaFJ6bGFWbXRzTmxsVmFIZFdNa3BaWVVoS1lWSldjRXhhUldSUFVqRndTR0ZIZUdsU2JYUTFWbTB3ZUUxSFJYZE9WV1JYVjBkb1dGWXdaRFJXVm14VlUyeE9hbFpzV25sV01qRkhWMFphYzJORVFtRldWMUpJV1ZjeFMxSXhUbk5hUm1ST1ltMW9iMWRYZEdGWlYwNXlUbFpzYWxKdGFHOVVWbWhEVmxaa1YxZHRSbFJpVmxvd1ZXMTBhMkZXU25SVmJHaGhWak5TVjFwRVJscGxSbVIwWkVaT1RsWlhkekZXVjNodlpESkdWMU5zVmxkaVIyaGhXV3RhZDFSR1dYaFhiVVpUVFZkU01GcEZXbUZVYkVwR1YyeHNWMkZyYnpCWmFrcEhaRVphZFZOc2FHbFNNMmhZVjFkNGIxUnRWa2RXYmtaVFlrWndjMVpxUm1GU01XUnlWMjEwVldKVlZqWlZWM2hyVmpGYWRGVnFUbGRXUlZwaFdsVmFhMk5zWkhOVWJXaHBVbGhDV1ZZeFdtdE5SbXhZVW10a1dGZEhhR2hWYkdoVFZsWldjVkpyZEZSU2JIQkpWRlpTVTJGR1duUlZhMnhhVmxkU1NGWnFTa2RqYkdSMVUyeFdhRTFZUW1oWGJGcGhWakZrV0ZOclpHRlNNbmh2V2xkNFlVMXNXbkpYYkU1VVRWWldORmRyV210aFZrNUdUbFprV21KWVRYaFdNVnBYWkVkV1JtUkdhRmRpYTBwSVZtcEplRTFHV2xaTlZscHFVMGhDWVZsVVJrdFhSbHB6VjIxR2ExSnNTbFpWYlhoclZHeEplRk5yTVZkV00wSk1Wa1JHU21WV1NuSmFSM0JUVmtaYVZWZFdVazlSTVZaelYyNVNUbE5IVW5OVmJYTjRUa1prY2xkdE9WWk5hMVkxV1ZWak5WWnRTbFZTYkZKWFVrVmFhRmt4V2t0amJWSkhWV3hrYVZORlNtRldNVkpEVmpKRmVGZFlaRTVYUlhCUFZtdGFTMWxXVWxaWGJVWnJZa2Q0V0ZZeWRIZGlSbGwzVjJ0a1ZVMVdjR2hXUjNoTFl6Sk9SazFXWkdoTldFSnZWakZhYTFVeFRrZFZia3BZWWxoU1ZGWnJaRFJXVm1SWVpFZDBUazFFUmtoWGExcHZZVEZKZDFkdE9WVldiSEF6V2xkNGEyTnNXblJQVjJoVFlUTkJkMWRzVm1GaU1WcFhWMnhvVm1KR1NtaFZhazV2WVVac05sSnRkR3RXYkVvd1drVmFUMVJzU2tkU2FsWlhZa2RPTTFwVlpGSmxSbVJaWWtaU2FFMXNTbmhXVjNSaFpERmtWMWR1VW14U01GcHZWVzE0ZDFKc1ZuUk5WRUpXVFVSR1YxUnNVa2RXTVZvMlVsUkNWMkV4Y0V0YVZ6RkhVakpPUjJGR1pHbFNXRUpLVmpKMFUxSXhWWGhUV0doaFUwVndiMVZxVG05V1JsbDNWMnQwYkZac2NGbFpNRlpyVjJ4YWNrNVljRnBoTVhCb1ZqQmtTMVpzWkhOWGJIQnBVbXh2ZWxkc1pEUldiVlpJVW10c1lWSnRhRlJaYTJRelRXeGFjMWt6YUdsTlZuQXdWbTAxUzJGc1NuTlRiR1JhVmpOU2FGbFZXbmRTTVdSelZHMTBVMDFFVmtsV2EyTjRZekpHUmsxVmJGSmlWVnBZV1d4U1EwNUdjRVZTYTNCc1VteEtXbGxWV2xkaFZrbDRVMnh3V0ZaNlJqWlVWbHBhWlVkS1IxWnNVbWxTVkZaYVZtMHdlRTVIVm5OWFdHeE9WbGRTV1ZWdGVIZGxiRmw1WTBWT1dsWnJjRmxaVlZwRFZqQXhSMk5GZEdGU1JYQlFWVzB4UzFJeGNFZGFSVFZPWWxka05WWnRjRWRaVm14WFdraFNWMkpyTlZoWmJYUjNZMnhXZEdWSFJsaFNiSEF3Vkd4V1QyRlZNVmRqUmxwV1ZucEZkMVp0YzNoV2F6VldZVVphVG1Gc1dsVlhWbVEwVXpGYVYxZHVUbWhTYmtKd1ZXcEtiMlZHWkhOV2JVWmFWakF4TkZadE5VdGhNVXBWVm14U1ZWWldTa2RVVlZwaFkxWk9jVlZ0YkU1V2JrSktWbFJLTUdJeVJrZFRhbHBwVW0xU1lWbHJaRzlrYkZwR1YyeHdhMDFYVWpGV1IzaHJWakpGZWxGWWFGZE5ibEp5V1dwR1ZtVldUblZUYkZKcFUwVktXbGRYZEdGWlYwNXpWbTVHVTJKWVVsUlVWbFV4Wld4YWRHVkZPV2hXYTNBeFZWZDRjMVl5U2xWV2FrNVdZbFJHVTFwVldtdGpiVVpHVGxaa1dGSnJjRlpXYTFwclpXc3hWMU5ZYUdsVFJYQlpXV3hvVTJJeFduUmxTR1JUVFZaYU1Ga3dXazlXTURGeVkwVm9WazF1VW5aV2FrWmhUbXhLYzJGR1dtaGhNVzk2VmxSR1lWVXlUWGhqUldocFVtMVNUMVJYTVc5V01WcHhVMnBTYUdKV1drZFViRlp2VlRKRmVWVnRhRlppVkVaMldUSjRWMk5XUm5SU2JIQlhZa2hDTmxac1pEQlVNVkY0VTI1T2FsTklRbUZXYkdSdlZVWnNWMWRyZEdwaVZUVkdWVmQ0YTFZd01IbGhSRnBYWWxSQ05GVnFTazlqTVhCSlUyMTRVMkpJUWxCWFZ6QjRZakpKZUZkc1ZsSmlXRkpZVkZaVk1WTldXbGhrUjNSYVZtdHdWbFp0ZUc5WGJVcFpWV3Q0VmsxV2NHaGFSV1JQVW0xU1JrOVdUazVXVm10M1ZtMXdSMkl5VFhoWGEyaFRWMGQ0YjFWdE1WTlpWbHB4VkdzMWJGSnNiRE5XTW5ocllXMUtSMk5FUWxaaVZFWXpXVlphU21Wc2EzcGlSbVJYWld0Sk1GWkdWbXRTYlZaSFdraFdWV0pHU205WlZFSjNZVVphUjFadFJtdE5WbHBJVmpGb2ExZEhSWHBSYms1WFlXdEthRlV4V2xKbFJtUjBaRVpXYVZaWVFYZFhWbFp2WXpGWmVGTnVUbGhpVjJoaFdsZDBZV05zVm5GU2JHUnJWbXh3ZWxadE1YTlZNREYwWVVkR1YySkhVak5WZWtwS1pWWk9XV0ZHYUdsU01taDZWbGN4ZWsxWFRsZFZiR1JZWW0xU1ZWVnRlSGRYVm5CV1drUkNhRkpyY0hsWk1GcHJWbGRLUjJOR1VsZGlSbkJvV1hwS1QxSnRWa2hTYkdST1RXMW9OVll4VWtwbFJrbDRVMjVLVUZadGFHOVZiWE14WTBaVmQxWnJjRTVXYkd3MFZsZDBUMWRzV1hoU2FsSlhUV3BXVUZZd1dtdFRWa1p6Vkd4d1YxSlVWakpXYWtKaFl6RmtTRlZyYkdGU2JGcFVXV3RvUTA1c1duRlRha0pPVW0xU1NGWXlOVmRWYlVWNVlVWnNXbFpGV2pOWk1uaGhWbFpLZEZKdGRGZGhNWEExVmtaYVlXRXhVblJUYmxKb1VtMTRXRlJXV25kamJGcFlUVlprVTAxV1dqRldSekZIVlRKS1YxTnVaRmhXYldnelZtcEtTbVZHWkhOaFIzQlRWMFpLZDFaR1dtRlNNRFZIWWtoS2FGSllVbGhVVjNSM1RVWmFXRTVWZEZoaVZWWTBXVEJTVDFsV1dYcGhSMmhYVFVkU1ZGVnRjelZXTWtaSVlrWk9hV0V3V1hwV2FrbzBWakZzV0ZOWWFGaFhSMUpQVmpCV1lWZEdiSEpXYTNSYVZteHdNRnBWYUd0V2JFcHpWMnBDVlZac1ZURldhMXBLWkRGa2NtRkdaRTVoYTFvMlYxWmFhMUp0VVhsVGFscFVZa2RTVDFadGRIZFNWbGw0VjIxR1YySldXa2hYYTFwellVWkplbEZzVWxkaVdHZ3pWakJhYTFkSFVraGtSbHBPWVhwV1NWWnRNREZWTWtwSFZHdG9WbUpIZUdGWlZFWjNUVEZWZUZkdVpGZGlTRUpHVlZkNFYyRldTbGxSYWxwWVZqTlNWRlpFUm1GV01XUjFWR3hvYVZJeWFGbFdiWFJYWkRGU1IxWllaR0ZTVjFKVlZXMTBkMlZzV25SbFIzUlhUV3R3ZVZVeWN6RldNa3BJVlZoa1dGWnNjSHBXTUZwVFYxZEdTRkpzVWxOaE0wSldWakZrTkdJeFJYaFZXR2hZWW1zMVYxbHJaRk5WUm14eVYyNWtiR0pIVW5sV1YzaFBZVVpLVlZKdWJGZE5ibEp5Vm14YVlXTXlUa2xUYkdST1VtNUNiMVpYTVRSVU1rMTVVbXRrYWxJeWVGUlpWRTVEVW14YWNscEVRbHBXYlhoWVZUSjRhMVpIU25KalNFcFdZV3MxVkZaclduTldWbEp5VkdzNVYySkhkekZYYTFaclRVWlZkMDFXWkZkaGJFcFlWRmMxVTJOc1dYZGFSWFJyVW14YWVsbHJXbXRoUjBZMlZteFdWMkZyU21oYVJFWlBVbXN4VjFwSFJsTmlWa3BRVm0xd1IxTXhiRmRhUm1SWFlsVmFjRlJYZEdGWFJtUnlWbTEwVjFJd2NERlZWM2h6VmpKR2NrNVlXbHBXVm5CWVdURmFSMVpXU25OYVJUVlhUVlZzTkZadGVHcGxSVFZIVmxoc1YySnNTbk5WYlRGdlYwWldkRTFXU210TlZuQjRWVlpTUjFZd01WaFZibkJhVmxaVk1WWnFSbUZXVmxwellrWm9WMDB5YUZsWGExSkhZVEpOZVZOclpGaGlSbkJ2V2xjeE5GZHNaRmhsUm1SYVZqRmFXRll4YUhOVU1XUklWV3hvVlZZelVqTlZNRnB5WkRGYWNWVnNjRmRoTTBJMlYxUkNVMVF4V25KTlZXaFdZVE5vVjFsc2FFNWxSbHB4VW01a1ZGSXdjRWxaVlZVeFZrWktWbU5IYUZkaVZFSXpXbFZWTVZJeVNrZGhSazVwWWtWd1dWZFdVa3RWTVZwWFYxaGtZVkpHU2xoVmJURTBWbXhXZEU1WGRGZFdWRVpZV1d0U1QxWXlTbFZXYmtwWFlsaG9URmw2U2t0U1ZsSnpZMFprVjJKSVFsSldiWEJEV1Zac1dGVnJhRmRoTWxKWldXdGFkMVF4YkZoa1JWcHNVbXh3TUZrd1ZtdFdSVEZ5VFZSV1YxSXpVbkpYVmxwTFpFWldjazlXY0ZkTk1VcHZWbFJHWVdFeFdYaFdia3BoVW14S2NGWnRkRnBOUmxsNVpFYzVWRTFyV2toVk1qVlRWbTFLU0dGR1dsZGhNVm96V2taYWQxZEhWa2hTYlhCWFlURnZkMVpYTVRSV01WSnpWMnhzVW1Gc2NGaFpWRXBPWlVaYVJWTnJaRmROVlRVeFZsZDRZV0ZXU1hsaFJtaFlWak5TYUZkV1ZYZGxSMHBKVW14T2FWTkZTbnBXVnpCNFZUQXhSMVp1VW14VFIxSllWRmQwZDFOV2NFbGpSVTVYVFd0d1NWWkdhRzlXTWtaeVYyeGtZVlpzY0ZCWk1uaDNVMGRPUjFWc1RsZFhSVXBoVm0xMFlWWXhiRmRpUm1SV1lUSlNXVmxyV25kWFZteHpWbTFHYW1KR1ducFdWM1JyVmtkS1NHVkdaRmRpUmtwSVZteGtTMUp0VGtaYVJtUk9ZbTFvTmxadGNFdFNNazUwVTJwYVVtSkhVbTlaVkVaM1lqRmFWVkZ0UmxSTmJFcFlWbGMxVDFadFNsaGxSemxWVm0xb1JGWXdXbUZrUlRGSllVVTVVMDFWV1RGV1Z6RXdZVEZhZEZOclpHcFNiWGhoV1ZSS1UxWkdhM2hYYkU1WVVqRktTVlZ0ZUZOV01rcHlVMnRvVjJGcmJ6QlpWRVpoVjBaT2NscEhjRk5TVlhCdlZsUkNiMUV4VGtkWFdHUllZbFZhY1ZSV1pGTk5SbXhXVjI1a2FGSXdWalJaTUdoelYwZEZlRmR0YUZabGExcHlWakJhVDJOc2NFZGhSMnhYVFRKb1ZsWXhXbE5VTVVWNFdraE9XRmRIYUZsWmExVXhWa1pTV0dWRlpFOVdiRm93V2tWa01GZEdTWGRqU0hCV1RXcFdVRlp0TVVkamF6VlhWV3h3VG1KdGFHOVhhMVpyVmpGS2RGVnJhR3hTYlZKd1ZXeGFjbVF4V25GVGFrSnBUVlpHTkZZeU5VdFViRnAwWVVaa1dsWkZjRlJXYWtaell6SkdSbFJzWkZOaVNFSTBWbFJLTUdFeVJuUlRiRnBwVWtad1dWbFVSbmRrYkZweFUydDBWRlpyV25wV1YzaHZZVlpLYzJOSE9WZGlXRUpNVmxSR1dtVkdXblZXYkZacFZqSm9WVlpHWXpGaU1sRjRWMnhvVGxKRldsTlVWbHAzVjBaWmVHRkhPVmhTTUhCYVZsZDRRMVp0Um5KWGEyaFZZVEZ3Y2xreWVHRmtSMUpJWVVaa2FHVnNXa2xXTVZKRFlUSkplRmR1VWxSaE1sSlZXVzAxUTFkR1duTlhibVJZVW01Q1IxWnNhRzlXTVZwelUyNXNWV0pIVW5wV1ZFcExVMFU1VlZSc1pFNWliV2haVjFaU1IxTnRWbGRUYms1aFVteEtjRmxZY0ZkbFJscFZVVzEwVDFKc2NIcFphMmhMVjBkRmVsVnNWbFppV0dnelZGVmFjMDVzVW5SUFYyaE9WbTEzZWxacVNqQmlNVmw0VjFod2FGSkZOVmhaVjNSaFdWWndWbGRyT1dwaVZYQklWMnRhVDJKSFJYaFdhazVYWVd0YWFGbFVSbE5rUmxweldrWldhV0V6UW05V1YzQkxZakZhUjJKSVRsaGhNMUpYVlcxNGQxTkdaRlZVYlRsb1ZsUkdXRmt3YUhkV01ERnhWbXhDVjAxdVRqTmFWbHBYWkZaU2MxZHRiRmhTTW1oMlZtdGFWMWxXYkZoVmEyaFdZVEpvY2xWcVNtOWpSbFp6WVVWT1dHSkdjSHBYVkU1dllWVXhWMk5FUWxaTmJtaFlWbFJLUzJNeVRraFNiRlpYVm01QmVsZHNaRFJYYlZaSFkwVmFVRlpyTlU5V01GWkxVMVprVjFadFJtaE5hMXBZVmpJMVMyRnNTblZSYkdoVlZteHdNMVl3V25OalZrNXlWMjE0VTJKSVFtRldNblJXVFZaWmVWTnNhR2hTYldoWlZtNXdRbVZHVmxWU2JYUlRUVlphZWxsVlZUVldNa1kyVm01c1dGWXpVbkpVYTJSWFZqRmtXV0pIZEZOU1ZYQlhWa1prTUdReFdYaGhNMlJYWW1zMVdGWnNVa2RYUm10M1lVVjBXR0pHY0ZsV1YzUnJXVlpLUm1ORmRHRldla1pRVldwR2QxSXhjRVpPVlRWVFYwVktURlp0Y0VkVk1VNTBWbXRrVjJKc1NsaFpWRXBUWTFaV2MxcEVVbGRXYlhoNVZqSXhSMkZzU25OWGJtaFdZbGhSZDFadGVFdGpNazVGVVd4V1YxWnJjRWxXYkdSNlpVWmFjazVXV21oU2JWSlBXVzB4YjFkV1duUmtSMFphVm10d2VsZHJhRTlXTWtwSFYyeG9XbUpHY0V4V2JGcGhVakZhZEZKc1pFNWlSWEJJVmtkNFlWbFhSWGhUYmxKb1VteEtWbFpzWkc5U1JsbDVaVWQwVjAxV2NEQlZiVEZ6Vkd4WmVGTnFXbGRoYTFwMldrUkdZV1JHVG5OaFIyaFRZbGRvVjFadGVHRmtNREI0WTBab2JGSnJOWEpWYWtaaFVqRndSbHBFUWxkTmEzQjVWVEowYzFZeVNraFZWRUpYVWtWd1NGVnRjM2hUVm5CSFZXeGtVMWRGU2xwV01XUTBZakZWZVZSc1pHcFNiSEJvVld4b1EyTXhXblJqZWtac1ZtMTRWMVl5ZUU5aFJrcFZVbTV3VmsxcVZuWldha1phWld4R2NtVkdjR2hoTVhCNVZsZHdTMU14VGxkVmJsSm9VbXMxYzFsc2FHOU9SbHAwVFVoa1RsWnJWalJXTVdodlYwZEtjazVXWkZwV1JYQlVWakJhVjJSSFVrbGFSM2hwVW0xM01WZHNWbTloTVdSSFUxaGtWMkZzU2xoWmEyUnZaR3hhY1ZOclpHcGlSMUl3VlcweFIxWXhXblZSYkVaWVYwaENURlZxUmtwbFZrcHlXa2RHVTAweWFIWldSbHByVFVVMVYxZHVVbXRTTUZwaFZtMHhORmRXVm5OaFJ6bFlVbTFTU1ZwVldsZFhiRnBHWW5wQ1YySllhSHBaZWtaM1UwVTVWMXBHVG1sWFIyaG9WakZTUTFsWFJYaGFSV2hVWVRKU2NWVnJWa3RXYkZwMFpVVjBWMUpzYkRWYVZXUkhWakZhY21OSWJGcFdWbkF6VmtkNFMyTXlUa2hQVm1oWFlrWndiMVpZY0VkWlZtUkhWRzVLWVZKdGFIQlZNRlpMVjJ4YVZWRnNaRlJOVlRWWVZqSTFSMVV5U2xaWGJrcFZWbXhhTTFwWGVHRmtSVFZXWkVaYVUySklRWGRXYkdSNlRsWmtjMWRyV2s5V1ZrcFlXVmQwWVdGR2NFWldXR2hYVm14YWVsVXljekZXTWtwWldUTm9WMkpIVGpOVVZscE9aVVphV1dKR1RtbGhlbFpXVjFkMGEySXhiRmRYYmtaVllrVTFUMVJXV25kU01WbDVaVVU1YUUxVmJEUldNblJyVmxVeFdGVnFUbGRTTTJoaFdsVmFUMk5XWkhOYVJUVnBZa1Z3TlZZeGFIZFNNVnAwVm10a2FsSldjRmxaYTFwTFlqRlNWVkpyZEZoV2JWSlpXbFZhVDFWck1VVldhMmhhVFVaYVdGWlVTa1psVmxaMVUyeGFhVmRIWjNwWGJGcGhZekZhYzFwSVVsTmlWMmhZV1ZSS00wMVdaRmRXYlVaWFRWZFNTRll5TlU5V1IwVjZZVWRHV2xZelVqTlZla1ozVm14a2RGSnRkRmRpUm05M1YyeFdZVlV4VlhkTlZscHFVa1pLV0ZsclpFOU9SbEp5V2tVMWEwMUVSa3BaVldSSFZrWktXVkZ0YUZoaVIxRXdWMVprVDFJeFduVlZiWGhVVWpGS1VGWlhNVFJrTVdSWFkwWmFZVkpYVWxoVVYzUjNWakZyZDFkdFJsZGlWWEJhVmxjMVlWWXlSbkpqUlhoWFRWWndWRmt4V2xkak1rNUdUbGRzYUdWc1JqTldiVEI0VGtac1YySkdhRlZYUjJoeFZXeGtVMVpzYkZsalJtUlZUVlp3ZWxkWWNGZFVNVnB6WTBob1ZtSlVSa2hXYWtGNFYwZFdSMkZHWkZObGJGcFZWbTF3UzFNeFRraFNhMlJXWWtoQ1dGVnNXblpsYkZwelYyMUdXbFl4U2tkVVZscHJWbGRLUjFkck9WZGlXR2d5V2tSR2EyTXhXblJQVjJoT1ZtNUNXVlpxU1RGVU1rWnpVMnhvYUZKdGVHRldhMVpoVkVaYWNsZHNjR3hXTVZwSVdUQmtORlV5UmpaV2FsWlhUVzVTYUZacVJscGxWazV5WWtaS2FHSklRbGxXUmxwaFpESkdSMVpxV2xSaGVteHlWVzE0UzJWV1dYbGxSVTVYVFd0d1dGVXlOV3RXTWtwWlZXMW9XRlpzY0V4VmFrWjNVMVpPYzFkdGFFNWlSWEJ2Vm0weGQxSXhUWGhUV0doV1lrZFNXVmxyWkZOV01XeHpWbTVrV0ZadGVGZFdiRkpYVmpBeGNsZHViRmROYmxFd1ZtMXplR1JYUmtoaFJtUnBVbTVDVVZkVVJtRlNNbEpJVTJ0YVQxWnRVbkJaVkVKYVpXeGFkR1ZHVGxSTlJFWkpWVEZvYzFVeVJYbFZiRlpYVFVkU1ZGWXhXbk5qTVZwMFVteHdWMkpZYUZkV1ZFbzBWREpGZVZOcmJGSmhNbmhvVm14a1UxTkdXbFZUYTNSVVVteGFlRlZ0ZUd0Vk1sWnlWMWh3VjJKWVFreFZiVEZYWXpGS2RWSnNhR2xTTVVwUVYxY3hORk15VmxkYVNFcFdZVEpTVjFSWGMzaE9SbVJ5WVVaa1YxWXdjRnBWVjNoVFZtMUtWVlpyVWxkTlZuQm9WV3BHYzA1c1NuTlhhelZvWld4Wk1sWXhaREJWTVd4WFZsaHNWR0V4Y0ZCV01GWmhWbXhhZEUxWE9WTlNiRnA0VlcxNGQySkdXWGhYYTJoWFVucEdkbFpxU2tkT2JGcHlZVVprVjFKWE9IZFhhMUpIWVRGSmVGcEdiR3BTYkhCd1ZtcEtiMWRzV25STlNHaFdUVlUxU0ZadE5VZFdSMFY2Vld4U1ZWWnNjRE5hVjNoaFUwVXhXVlJzV2s1V2JrSkpWbXBLZDFVeFdYZE5WbVJxVTBad2FGVnJWbUZUTVhCV1YyNWtVMkpJUWtsVmJYaFRWVEZrUmxOdVdsZGlSa3BFV1ZSR1ZtVkdaRmxoUmxwcFVqRktXVmRYTUhoVk1XUkhWV3hrWVZKRlNrOVVWbHB6VGxaU1YxVnJUbGROUkVaR1ZXMDFjMWRyTVVkalJFNVhUVzVvYUZZd1pFZFNiVlpIV2tVMWFHRXhjRXBXTVZKS1pVWlJlRk5ZYUZkaWF6VnhWV3BPYjJJeFVsZGhSVTVQVm14c05GWlhkSGRpUmtweVlrUlNWMUl6VW5aV2FrcEdaVlpXYzFkc2NHaE5iRW95Vm0xMFlWbFhUWGxTYTFwVVlYcFdXRmxyYUVKa01XUnlWbTEwVTAxWFVucFdNalZUWWtaS2RHVkdhRmRpVkVaMldsZDRZV05XVG5KWGJYaFhZa1p3TmxkWGRHRmtNa1pHVFZoT1ZHRnJjRmxXTUdoRFUwWmFkRTFXU214U01EVkhWMnRhVjJGV1dYcGhSa0pYWWxSRk1GcEVRVEZqTVdSMVZHMUdVMUpWY0haV1JscHJWVEZPVjFaWWJHdFNNMUpaVldwQ2QxTldjRlpYYlVaWVlsVldOVlpYTldGV01WcFhZMGRvV2sxV2NFaFdNV1JIVTBkT1NHSkdaRmRTYkhCTFZtcEdVMUV4YkZoU1dHaFlWMGQ0V0ZsdGRIZFhWbXhZWkVoa1dGSnRlRmxhUldoaFZHeEtkRlZzYUZkTmJsRjNXVmR6ZUZkV1JuSmpSbVJUVFRKb1RWZFdXbUZUTWxKWFVtNU9VbUpIVWxoYVYzUkhUa1phVjFWcmRGUmlWbHBJV1RCV2ExWXlTa2RUYkd4V1lXdHdkbFpzV21GU01XUnpXa2R3VGxKR1drbFdiVEF4VlRGUmVGZHNWbWxTTUZwWVdXeG9VMlZzVW5OWGJtUlhZa2RTZWxkcldtdGhWbHBaVVd0c1YyRnJjRE5WZWtaelZqRmtXV05IYUZOTmJXaG9Wa1phWVdReFVrZGpSVnBoVWxSc1ZWVnFSbUZUUmxwSVpVZDBWazFXY0RGVlYzUXdWakpLVlZKWVpGaFdiVkpMV2xaYVMxZFhSa2RYYkdoVFRXMW9kbFpzWkRSWlYxRjRWbXRrV0dKc1NrOVdhMXBMV1ZaYWRFMVVVbXhpUjNoWFYxaHdWMVl4V25KalNIQmFUVVphYUZadE1VdFdWa3B5WVVad1YyVnJXazFXVkVKaFZqSlNXRk5yYUZOaVJUVllXVzEwUjA1c1duUk5XR1JVVFZVeE5GWkhlR3RWTWtweVYyeGtXbUV5VWxSV01GcHpZMjFHUmxSc1pGZGlTRUphVjFSQ1YwMUdXa1pOVmxwUFZsZG9XRlZ1Y0ZkVVJtUlhWMnR3YkZZeFdraFdWM2hoWVZaa1NGb3pjRmRpV0VKSVdWUkdhMU5HVm5KaFJrNXBVakpvZDFadE1UQlhhekZIV2tab2ExSXdXbUZXYlhoelRrWmtjbFp0T1doU2EzQXdXVlZrUjFkdFJYaGpSbVJoVmxad1YxcFdaRmRUVms1MFpFVTFWMDFWYkROV01uUlhXVlpaZVZKc1pGaGlSM2hUVmpCa1UxZFdXblJsUjBab1VteHdlRlZ0ZUhkaVJscHlZMFJHVmsxcVJucFdWRVpMWTIxT1IyRkdhRmROTW1oVlZsZHdSMkV4U1hoYVJteGhVbTFvYjFSVVJrdGxSbVJZWkVkMFZrMXNXbnBXTVdoelZHeGtSazVXWkZWV1ZrcElWbXBHY21ReFpISmFSbVJPVWtWYVdsWnJaSGRVTVd4WFYyeG9WbUV6VW1oV2JYaDNZVVpzTmxKdVpGUlNhM0I2VmtjeGMxZEdTWGxhZWtKWFlsaG9jbFJyWkVabFJscFpZVWRzVTJKV1NscFhWekV3V1ZaYVIySkdWbFZpUlRWWVZtMTRkMDFHY0ZaaFIzUllVbXh3TVZWWGRHdFhSMFY0VTJ0U1YyRnJSalJXYWtwTFVsWlNjMXBGTlZkaE0wSk9WbTB4ZDFNeFRYaFhiR1JUWWtaYVZGbHJaRk5qUmxaMFRsVk9hVTFYVW5sV2JURXdWVEF4Vm1OSWNGZFdlbFpRVm1wS1MxTkdWblZSYkZwT1VteHdUVmRyWkRSWGJWWkhWbTVLYTFKVWJGUlVWVnBhVFZaYWMxcEVRbWhOVm5CSlZUSTFTMVF4WkVaWGJHUmFZa1pLU0ZacldtRlNWa3B6V2tkd2FWSnVRalpXYWtsNFRVWlNjMWR1VmxKWFIxSllWVzE0WVdSc2JGVlNiRTVxVFZkU01WWkhlR3RoUjBwR1kwWnNXRll6VW5KWmFrcFRZekZ3UjFwR2FHaE5NVXBhVmxkd1IxbFdUa2RYYTJoc1UwZFNiMVZzVWtkWFJscDBZMFpPVjAxRVJsaFpNR1J2VjIxV2NsZHRhRmRoYTFwVVdrWmFVMk14Vm5SaFIzaHBVbTVDVjFacVJtdE9SbXhYVkZob1lWSnRVbGxaYlhSaFZsWlpkMXBIT1ZkU2JFcFpXa1ZrUjFSc1NuTldhbFpoVWxkUmQxbFZaRXRTYlU1R1drWmFUbUp0YUhsV2FrbDRVekZPU0ZKcldsQldNRnBZVm0wMVEySXhXbFZSYlhSWFRWVTFTRlV5TlZOaE1VcDBWVzA1VlZadGFFTlVWM2hhWlVaa2MxcEdjRmROUmxreFZsY3hNR0l4VlhoYVJXaHNVMFZ3YUZacVRsTlVSbGwzVjIxR2FsWnNTbmxXUjNoVFZUSktWMU5zYkZkaGEyOTNXa1JLUzFJeFRuVlViRkpwWW10S2FGZFdVa3RWTWxKelYyeFdWR0V6VWxsVmFrSmhVMnhaZVdWSGRGWk5hM0JYVkZaU1UxZEdXWHBSYTJoYVZrVmFTMXBWWkU5U2JIQklZVVpPVGsxdGFGWldNbmhxWlVVMVNGVllhRmhoTWxKb1ZUQm9RMVF4V25GU2JVWnNZa1pzTkZsVmFFOVdWVEZYWTBac1YxWXphSFpXYlRGSFkyeE9jMkZHVm1oTldFSTFWMnRTUzFJeFNuSlBWbVJvVWpKNFdGWnRlSEprTVZwMFkwVndiRkl3YkRSWmExcHJWMFprU1ZGdE9WWk5SbG96VjFaYVUxZEZOVmhQVjNCcFUwVktTRll5ZEdGVU1WVjNUVlpzVW1FeVVsWlphMlJUWld4YVZWTnJkR3BpUlhCYVdWVmFhMkZXV2taVFZFSlhVak5TY2xVeU1WZFdNVTV6WWtkb1UwMUdjRlZXYlhCSFV6RmtjMXBHYUU1WFNFSlBWbTE0ZDFkR2JISlhiR1JYVmpCd1ZsbHJXbTlXVmxwMFZWUkNWMDFXY0ROVmJYaDNVbXh3UjFwR1pHaE5NRVl6VmpKMFYxVXhXWGhhU0ZKWFltdHdVRll3V25kWFJteFlaRVZrVDFKc2JEUldNblJyWVcxS1ZtTkZhRnBOUjFKMlZrZDRhMUpzVG5OVGJHUk9WbTVDV1ZadE1IaFZiVlpYVm14c2FGSnNXbkJaVkVaM1ZteGtXR1JIZEZaTlZrWTBWakkxVTFReFdsWk9WbWhYWWxob00xcFdXbUZYUjFKSVpFWmFUbUV6UWxsV2Frb3dZakZrY2sxVlpGaGlia0pZV1d0a1UxUkdWWGRhUldSVVZtdGFlbGt3Wkc5VWJGcDBUMVJhVjAxdWFGaFhWbHB6VmpGd1JtRkdaR2hOYkVwWFYxZDRiMUV4VVhoWGJsSnNVbTVDVDFWdGVIZGxiR1J5Vld4T2FGSlVSbGxXVjNSelZtMUtTR0ZFVGxkaVZFWk1WV3BHYTJNeGNFZGpSMnhUVFcxbmVWWnJXbE5TTVZWNFYyNU9ZVk5GTlZaWmJHaERWREZhZEU1VlNtdE5WMUo1Vm0weFIyRkZNVmRUYm5CWFRXNW9kbGxVUVhkbGJFWnpZVVp3VjAweFNtOVdiWFJoVmpBMWMxTnVUbXBTTTJoWVdWaHdWMDVzV25STlZGSm9UV3RhV0ZVeWVHRmhiRXAwWlVac1YyRnJOWFpXYTFwWFkxWktjMVJzVGs1V01VcGhWMVpXYTFJeFZYaFhXR2hVWWtaYVdWWnFUbTloUm1SWFYyczVVMDFYVWpGV1Z6RTBWVEF3ZUZOdVdsZGlWRVkyVkZaYVNtVkdXbGxpUlRsWFRVWndXVlpHWkRCa01VNUhWbGhzYTFKck5WaFVWM1IzVm14V2RHVkhPVmRpVlZwNVZqSndUMVp0U2xsaFNFcGFaV3RhU0ZsNlJuZFRSMHBIV2tkb1RrMUZjSFpXYlRGM1VqRnNXRk5ZYkZaWFIyaFpWakJrTkZaV1dYZGFSemxYVFZkNGVWWXlNVWRXYXpGWVpVWmFWMUl6YUZCV2FrcExVakZrY1ZGdFJsZFdNbWg1VjFkMGExTXhTWGxUYTFaWFlrWmFXRmxzWkc5bFZscDBaVWQwVkUxVmJEVlZNblJYVmxkS1NGVnVRbGROUmxwTVZteGFZV1JIVGtaVGJYaFRZbFpLU2xaWE1UQmpNV1JJVTJ0b1ZtRjZiRmRaVjNSaFZFWlZlRmR0ZEZoV01EVkhXa1ZhVjFSc1dsaGtla0pYWWtkTmVGWkVSbk5XTVU1elZteGthVkpyY0ZkV2JURTBXVlV4YzJOR1pGaGlWVnB5Vld4U1IxZHNaSEpYYXpsVllrWnNObGxWV25kV01rVjVWRmhvVjFKRlduSlZNRnBQWkZaU2MyRkhiRmROYldoWlZqRmtOR0l5U1hoVmEyUllZbXR3V1ZsdGN6RmpWbXh5V2taT1RsWnRVbmxXYkZKWFZtc3hjbU5GY0ZaV00yZ3pWbXBHUzJNeFpITlZiRnBvWVROQ1NWWlhNWHBsUmxsNFkwVmtZVkl5YUc5YVYzaGhWMFphZEUxSVpHeFNNR3cwVmxkMGExZEdaRWhWYldoV1lrWndNMWw2Um1GalZrcDBVbXhTVjJKWWFGaFdha2w0VWpKR1IxZHVTbXBTUlZwWFZtMHhiMDB4V25GVGEzUlRUVmRTTUZsVldtOVdNa3BKVVd4R1YxWkZTbWhXVkVaclYwWlNjbUZIYUZOaGVsWjNWbTB4TUdRd01IaFhibEpPVmtaS1YxUldXbk5PUmxwSVpVZDBXbFpyY0RCWlZXaExWbTFHY2xOdGFGcGhhMXBVVm1wR2EyTnRVa2hsUjJ4VFlsaGplRlpyWkRSWlYwVjRWMjVTVkdKR2NGbFpiVEUwV1ZaU1ZsZHVaR3hpUm13MVdsVmtSMVV5U2toVmJteGhWbFp3YUZaSGVFdGtWa1p6WVVab2FWSnVRbGhYYkZaaFYyMVdTRlJyV21GU2JGcHZXbGQ0WVZkV1pGaGtSM0JQVmxSV1NGWXlOVTlXYlVWNlVXNU9WbUpZVW5wVWExcGhZekpHU1ZSc1pGTk5TRUpLVjFaV2FrNVdXblJUYkZaWFlURktXRlJWV25kaFJtdDRWMnhPYW1KR1NucFdNbmhQWVZaa1NGcDZRbGRpUjA0MFZHdGtSbVZHWkZsYVJUVlhZbGRvV0ZkV1pEQlpWbVJIVjI1V2FsSldjRTlWYlhoM1ZteFZlV1ZIZEdoTlZXdzBWakowYjFkc1dsZGpTRXBYVmtWd1RGVXhXa2RrVjBwSFdrZHNVMkV6UWtwV01WcFRVakZPZEZaclpHcFNWM2hZV1d0YWQySXhjRmhOVkZKWVZteHdNRmt3Vm10V1JURllWV3RvV0dFeGNIWlphMXBMWkVaV2RWTnNWbGRXYTNCSlZsUkNZVmR0VmxoV2EyaFFWako0VkZsVVRrSmtNVnB6V2tSU2FrMVhVakJWTW5SclYwZEtTR0ZHV2xwV1JWb3pXbFphZDFKV1NuVmFSbEpUVmtkNFdWWXlkRlpOVmxWNFUyeGthbEp1UWxoVVZscExVa1prVjFkc1dteFNia0pLVmxkNGEyRlhSWHBSYkhCWVZqTm9jbGxxUm5OV01WWnpXa1pvYVdKV1NsWldWekI0VFRBeGMxWnVVazlXTTFKWFZGZDBXazFzV25SbFJ6bFlVakJXTlZaWE5YZFhiRnBYVm1wU1ZrMUhVbFJWYkZwaFl6RndTR0pHYUZOV1dFSkxWbTB4TkZVeFNYaFRibEpYWWtkU1ZsbHJaRFJqUmxaMFpVaGtXRlpzV25oVk1qQTFZVlV4VjJOR1dsWldNMmh5V1ZSQmVGWXhTbkZWYkdST1lXeGFVVll4V21GVE1rNXlUbFprYUZKdFVuQldhMVpXWkRGa2MxZHRSbHBXTVVwSlZsZDBWMVZ0U2toaFJsSmFZVEpvUkZSdGVHdFdWa1p6Vkd4S1RsWXphRmxXYWtvMFlqSkdSMVJyV21wU01GcFlXV3RhZDAweFdrWlhibVJUWWtoQ1NGWkhjelZoVmtwVlZtcGFWMkZyY0RaVVZtUkhWMFpLY1Zkc1NtaGlSWEJaVjFkNGIySXhXa2RXYmtaVFltczFXVlZ0ZUV0WGJHeFdWMnhrYUZZd2NFaFpNR2h2VmpGYU5sRnFVbGRXUlZwVFdsVmtTMUl5Umtoa1JrNU9VbTVDVWxZeFpEQlpWMUY1Vm10a1YySkhhRTlXYkdSVFYwWldjVkZ1WkZoU2JHdzFXbFZvVDFZeVNsWmpSbkJYVmpOb2RsWnFTa2RqYlU1R1pVWmFUbEp1UWxsWFZFcDZUbFpaZUdORmFHaFNNbWhQVkZWV2MwNUdXbkZUYWxKb1RVUldTRmxyV210WlZrcFlZVVphV2xaRldqTlpNbmhYWkVkV1NWcEhjRk5pU0VGM1YyeFdiMkV4V2tkWGJrNXFVMGQ0V1ZsVVJrdFdSbXhZWXpOb2FtSkhVbmxaVlZwaFZHMUdjMWRzVmxoV2JGcG9Wa1JHUzJNeFVuVlZiRTVwVTBWS1dWWlhlR0ZrTWtsNFYydGtWbUV5VW5KVVZsWjNWMFpWZVU1V1RsWk5hM0JKV1ZWYVUxWXlSWGhYYldoWVZteHdjbFpzV2tkak1XUnlUbFprYVZJelpEWldhMXBoVmpGWmVGZFliRk5YUjNoelZXMHhORmRHYkZoamVrWlhVbTE0VjFZeU1VZGhiRnB5WTBod1dHRXlVWGRXVkVwSFRteGFjVlpzYUZkTk1VcHZWbGh3UzFJeFRrZFhibFpXWWxob1ZGbHNaRzlYYkZwMFkwVTVhVTFzU25wWmEyaEhWV3hrU0ZWdVRsWmlXR2hvV2xkNFdtVlhWa2hQVjJoWFRVaENXVlpVU2pSak1XUkhWMWh3Vm1Kc2NGZFdhMVpoVXpGd1ZsZHVaRlJXYXpWNldWVmtjMVl4U1hwaFJFcFhZbFJDTkZSVlpGSmtNREZXV2tkd1UxWnNjRmRYVnpCNFZURmtWMVp1VW14VFJUVlFXV3RhZDFkV2NGWlhhemxYVFVSR2VWWXlOWE5XTURGeFVtNWFXRlpzY0V4V2FrcFBVakZHYzJORk5XaGhNWEJLVm14U1EyRXhTWGhUV0doWFltczFWbGxzWkRSaU1WSldZVVZPYVUxV2NEQlVWV2hyWVRBeGMxZHJaRlZpUmxwMlZtMTRhMU5IUmtkYVJuQlhVbGhDVlZacVJtRlhiVkY0WTBWa1ZXSlhhRlJaYTFwM1RteFplV1JIUmxWTlZtdzBWVEkxVDFaSFNraGhSbWhWVmpOQ1dGa3llSE5qYkhCR1pFWlNVMDFWY0VkV2EyUTBZVEZTZEZKdVNsZGhhelZZV1d4U1IwNXNjRlpYYlhSVFRWWndNVlV5TVVkVk1rcEpVV3hDV0ZaNlFqUlpha3BLWlVaa2RWVnRjRk5YUmtwV1ZrWmFhMVV4WkVkV2JsSlBWbGhTYjFWdGRIZE5SbXhXVjIwNVdHSlZjRWhaTUZZMFZqRmFWMk5JU2xwbGExcHlXa1ZhUzJNeGNFWk9WMmhzWWtaWmVsWnRlR3BsUlRGSVVsaG9ZVkpYYUZWWmEyUnZZakZXYzFWdVRscFdiWGg1VjJ0YVQyRXlTa2RqUkVKaFZsWndNMWxyV2t0a1ZrWnlWMnhhVjJWcldqSldhMlEwV1ZkTmVGcEdWbE5pUjFKdlZGZDRSMDB4WkZkVmEyUllZbFphV0ZaSE5WZFdSMHBJWVVoQ1ZtSlVWa1JaVlZwclYwZFNTRkpzVWs1aVJuQTJWbXBLTkZsV1pFaFRiRnBZWW10d1YxbFhkR0ZoUmxWNVpVZEdWRkl3TkRKV2JYaHJWRzFGZWxGcVZsZFdSVzkzV1dwR1dtUXdNVmxXYkZwcFVqSm9hRlp0ZEZkWlZteFhZMFphV0dKWVVuRlVWbHAzWld4YVNFMVlUbFpOUkVZd1dWVmFkMVl3TVZoVlZFSmFZV3RhUjFwVldtRmpiSEJIWVVkc2FHVnNXbUZXTVdRMFZqRnNXRlJzWkZaaVIyaHhXbGQwWVZaV2JISmFSRUpPVFZac05WUldVa05XTURGRlVtNXdWMDFxVm5wV2FrRjRaRlpXZFZkc1pFNVNNVXBOVmxkd1IyRXlVbGRVYms1aFVtczFWRlp0TlVOVVZsbDVaVVprYUUxV1JqUlZNalZQWVd4S1dHRkdVbHBoTVZWNFZrUkdjMlJGTVZoUFZtaHBVbTVDTmxZeWRGTlZNV1J6VjFob1ZHRnJTbGhaYkdodlkyeFpkMWR0ZEZSU01WcEtWVEo0WVdGSFJqWldiRlpYWWtaYWFGWnFTbE5TYXpGWFZteGFhVkl5YUZsWFYzUnZVVEZPYzFwSVRsZGlXRkpQVlcxNGQyVldVbGRoUlhSb1lrVndXVnBWWkc5V01rcElWV3M1VlZac2NHaGFSVlY0Vm0xU1IxcEdaR2hOTUVZMFZtMXdTMDVIUlhsU2ExcE9WbTE0VTFsWGVIZFhWbHB5Vm01YVRsSnRlRlpWTW5oUFZqQXhXVkZyY0ZkV2VrVXdWbFJLUjA1c1duVmFSbVJwVmtWV00xZHJVa2RoTVVsNFdraFdWV0pIYUhCV01GWkxaV3hhV0UxVVFtcE5SRlpZVm0wMVQyRkdTWHBWYkZwYVlURndNMVJWV21GWFJUVldWR3hrYVZaV1dUQlhWRUpYVGtaWmQwMVZaR3BTYkVwWVdWZDBZVTB4VlhkV1ZGWllVakZLU1ZscldrOWhWMFYzWVROb1YySllRa3hVVlZwYVpWWktXV0pHVG1saE0wSlFWbXBDVjJReFZrZFhiazVoVW5wc1lWWnRNVFJXYkZaMFRsZDBhR0pWY0VsYVZWcHZWakF4Y1ZKWVpGZGhNWEJNV2tWVk5WWldaSE5qUlRWVFltdEplVlp0TVhkVE1VMTRVMWhzVldFeWFGRldiVEZ2VjFaVmQxWnJkRlJXYkd3MFZqSXhSMWRIU2xkWGEyaFhWbnBXV0ZacVNrdFNNVTUxVVd4YWFWSnNiM3BXYWtaaFlURmtTRlZyWkdGU00xSlBWbTAxUTFkV1dYbGtSMFpvVFZad01GVnRjR0ZoVmtweVRsWmFWMkpHY0V4V01GcGFaREZrYzJOSGVGTk5SbkJMVm10amVHSXhVbk5YYkdoclpXdHdXRmxyWkU1bFJsWlZVbTFHVjAxWFVqRldSekYzVlRKS1dHRkdaRmhXTTFKb1drUkdXbVZIVGtkYVIwWlRZbFpLVmxaWGNFZFRNVTVIV2toS1dHRjZiRlpaYTFVeFVqRldkR05GT1ZkTmEzQmFXVlZvUzFaWFJYbFZhM1JoVmxad00xVXhXbGRqTVZaMFlVVTFhVll5WjNsV2JYaHFaVVUxUjFSWWFHRlNWMUpYV1d0YWQxZFdiSFJOVms1WVVteEtXRmxWVms5WFJrcDBWVzVzVjJKR1NraFpWbHBLWkRKT1IxcEdaRTVpYkVveVZtMXdSMU50Vm5OVmJHeG9VbTFTYjFsVVFscE5SbHAwVFVob1ZFMUVWbnBWTWpWUFdWWktWVlpzYUZwaVdGSk1Wako0V21WR1pITlViRXBwVm14d1NWWlVSbTlpTVdSSVUydG9iRkl5YUZkWmExcExWMFphYzFkc1pHcFdhelV3VkRGYWEyRldTWGhUYkhCWVlURmFjbFJWWkVkV2F6RlhZVVphYVZJeWFGbFdSbVIzVmpGT1IxZHVUbUZTV0ZKWVZtcENkMU5XVVhoWGJVWm9WbXh3UjFZeWVGZFdNa1p5VTIxb1YwMXFSbGhXYlhONFZqRmFjMU50YkZOaWEwcFJWbXhrTUZZeGJGZGFTRTVZWW1zMWFGVXdaRk5XUmxKWFYyNU9UMUpzYkRSWlZXaHJWakZhYzJORlpGZE5ibWgyVmpKNFdtVnNWbkZVYkdSVFZtNUNiMWRVUm1GVE1rNXlUMVpvYWxKVVZtOVVWRUpMVTJ4YWNWTnFRbWhOYXpFMFYydFdhMVpIU2tkalNFWldZa1p3TTFZd1dsTlhSVFZYVkd4a1UySkdjRFJXVnpFMFV6SktSMU51VWxaaVNFSmhXVlJHZDFaR2JGWldXR2hxVFZVMWVsa3dXbTlXTURCNVlVaHNXRll6UWtoWFZscEtaVVp3U1Zac1ZtbFNia0ozVmxkd1IxTXhaSE5hUm1oclVqTlNWMVJXWkZOWFJtdDNWbTFHV2xacmNFZFZNbmh2VjJ4a1NWRnJhRmRoYTFwVVdYcEtSMU5XY0VkYVJUVm9UVEJLYUZZeFdsZGlNV3hYV2toU1UxZEhhSEZWYkdodlZteHNjMVZyWkZWU2JGcDRWVEowTUZVd01YSk9WV3hhWVRGd1VGbFdXazlTYkU1eFUyeGthR0V5T0hkV01WcGhZekZaZUdORmJGWmlSMUp3VlcwMVExVkdXblJOU0docFRWWmFXRll5TlZOVWJGcHlUbFphVlZac2NHaGFWbHBoWkVVeFZscEdaRk5OU0VKSlYxUkNiMlF4WkVoU1dHaFVZa1pLWVZadGVGZE9SbHB4VTJzNVZGWXdjRWhXYlhocllWWktkVkZxVmxkaVZFWXpWV3BHYzFZeFRuVlViVVpVVWxSV2RsWlhNREZSTVdSSFZXeFdVMkV6VW5CVVZtUlRWbXhWZVdOR1RtaGlWWEJZVmpKNGMxWXhTWHBSYldoWFZrVndURlV3WkVkU01WWnpWbXhrVjJKclJqWldiRkpMVGtkRmVWUllhRmhpYkVweVZXcE9RMVF4V25SbFJuQk9WbXh3VmxVeFVrZFdSVEZYWTBWc1ZrMXVhRmhaVmxwTFpFZEdTRkpzY0doTldFSk5WbFJDWVZVeFdsZFRiazVoVWpOQ1dGbFljRmRPVmxweFUxaG9UbEpzU25wVk1uUmhWMGRLU0dGR2JGZGlXR2hvV1ZWYVlWWldTblJrUms1T1ZsUldZVmRYZEd0aU1WVjVVMnhvYUZKdGVGbFdiVEZTWkRGV05sTnJPV3BOYTNCS1ZXMTRUMkZXWkVkVGJHeFhVbXh3Y2xaVVJtdGpNWEJKVTIxR1UxWXhTbGhXUm1RMFdWVXhSMk5HV2xoaWJWSllWRmQwZDFac1ZsaGpSazVYVmpCV05Ga3daRzlYYlZaeVYyMW9ZVkpzY0ZoWk1uTTFWakZ3Ums1Vk5WZFhSVXB2Vm0weE5HRnRWa1pPVldoV1YwZFNUMVpzWkZOalZsWjBaVWhrYVUxV1ZqTldiRkpIVjBaS2MxTnNaRmRXTTFKeVZrZDRZV015VGtkaFJuQlhWakZHTTFadGNFSmxSMDV6V2toV2FWSnVRazlWYlhoeVpERmFkRTFJYUZOTmF6VXdWa2QwYTFWdFNrZGpTRUpXWWxSV1JGVXhXbXRqYkZwMFVteFNUbUY2UlRCWFZFSlhZVEZzVjFOc1ZsZGlhMHBZV1ZkMGQyTldjRlpYYlVaclVsUkdTbGRyWkRSVk1WcEdWMnRzV0ZZelVtaFpWRVpoVmpGd1JtRkhlRk5pU0VKWlZrWldhMVV5VW5OWGJsSnNVMFUxY2xWcVJtRlRWbFowVFZoa1ZrMXJjRWhaYWs1clZqRktjMk5IYUZkU1JWcG9WbTF6ZUZZeVJraGxSazVUVmxoQ1dGWnRNSGRsUmxKMFZtdGthVk5GY0doVmJHaFRWbFpXZEdWSFJteGlSM2g1VjJ0V2ExWnJNVmRpUkZKV1RXNVNlbFpxU2tkamJVbzJVV3hvVjJKV1NsQlhiRnBoVlRKT2MyTkZhR2hTYXpWd1ZUQldTMVZXV1hoWGJYUlBVbTE0V0ZadGVHdFhSMHB5VjJ4T1dtSkhhRlJXYkZwVFZqRmFkVlJyT1ZkaVNFSktWMnRXYTAxSFJrZFRia3BwVWtVMVdGUlhOVzlrYkZwelYyMUdVMkpIVW5sYVZWcDNZVWRGZUdOSE9WZFdNMEpJV2tSR1MxWXhXblZVYlhCVFlsWktVRlpYZEZkV2JWRjRWMjVTVGxOSFVrOVdiWE40VGxaV2MyRkhPVmRTTUhCNVZHeGFWMWRzWkVsUmJuQlhUVVp3ZWxreWVHdGpiVkpIWVVaT2FWSXpZM2RXYlhCS1pVWkplRnBGWkZSaVJscFVXV3RhZDFkR1duVmpSV1JPVFZad1NWcFZXbmRpUjBwV1YydG9XbUV4Y0hKV2FrWkxWMGRTUlZWc1pHbFNhM0JKVmpGYWExVXhTWGhWYmxaWFlrWktjRlZ0ZEhka01WcFlZMFZrVkUxcldraFdNalZUWVd4S1ZXSkdaRlZXTTFKb1ZUQmFZV015Umtoa1JtaFRUVWhDU0ZaSGVHRmlNVmw1VTJ4c1ZtRnJOVlpXYkZwM1RURldkR1ZIZEd0U1ZHeFlWMnRWTVZVeFNsZGpSV2hYWWxSQ05GUlZaRXBsUm1SWldrVTFXRkpzY0ZoWFZ6RXdaREZzVjJKR2FHdFNNRnBZVlcweE0wMXNWblJOVkVKb1lYcEdXRmt3YUhkWFIwVjVWVzVhVjFKNlJreGFSV1JIVWpKT1IxcEhiRmRTVmxsNlZtMHhkMU14VVhsVmEyUllZbXR3YUZWdE1XOWpSbXhWVW01a1YxWnRVbGxhVlZwclYyeGFjMk5HYUZkaVZGWlVXVlJHVDFOR1ZuVlViRnBwVjBkb05sWkhlR0ZWTVZsNVVtdGFVRlp0VW05YVYzUmhUbFprVlZGdFJtcE5WMUo2VmpKNGEyRnNUa2RqUm1oVlZsWndNMWRXV25kWFIxWkhXa2QwVTAxR2NFbFdha2w0VGtkR1JrMVdiRkpoYkZwWVdXdGtVMDB4Vm5GVGExcHNVbTVDU0ZsVldrOWhSVEZ6VTI1YVYxWXpRa3hVYTFwclZqRmFkVlZ0ZEZSU01VcGFWMWQwWVdReVZsZFhXR3hPVmxkU2IxWnNVa2RXTVZwMFkwWk9WMkY2Um5oV2JYaERWakpHY21ORmVGWk5SMUpJVlcxek5WWXhjRWhoUlRWWFltdEtUMVp0TUhkbFJUVklWRmhzVldKck5XaFZNRnBoWVVaV2RFMVdUbXBTYkZvd1ZHeFdTMkV3TVZoVmJteFhZbFJCTVZac1ZYaFhSbFp5WVVaYVRtRnNXbEZYVm1RMFZERk9WMUp1VG1GU2JGcFlXbGQ0WVUxc1dsaGtSMFpZWWxaYVYxUldXbXRaVmtsNlVXNUNWMkpHU2xoVk1GcHJZekZhZEZKc2NGZE5SbkJLVmxkNGIySXlSbk5UYmtwWVlrZG9ZVlpxVGxOaFJtdDVaVWRHVTFacmNIbFpNR1EwVlRKS2NsTnJkRmRpUjA0MFdYcEdWbVF3TVZsVmJXaFRZVEJ3V1ZaWE1UUlpWbVJIWTBWV1UySllVbkZVVm1SVFRWWldkR1ZGT1doV2JIQllXVEJvWVZZeFNuTlhiRkpXWVd0YVVGVnFSbXRqYkhCSVlVWlNVMVpHV2xsV2ExcHJUVVpaZDA1V1pGaGlSMmh6Vlc1d2MxZEdVbFpWYTJSVVZteHdXVnBWV2s5V01ERkZVbXhvV2sxSGFETlhWbHBMVjBaV2MxVnNXazVXYmtGNlZsUkNhMVF4VGtoVGEyUlZZbGRvVDFSVlZuZGhSbHAwWTBWa1dsWnNiRFJXTVdodlZteGtTR0ZHYUZkTlIxRXdWbXhhYzFaV1RuTlViWEJYWWtadmQxWkdXbE5WTVZsNVUydGthbEpGU2xaV2JYaFdaVVphU0dWSFJtcE5helZHVlZkNGQySkhSalpXYWtwWFlsaENRMXBWWkU5amF6VlhWMjFHVTJKWGFIWldSbHB2VVRKSmVGZHVTbUZTUmtwWldXeGFZVmRHYkhGVWJtUm9Za1Z3TUZaWE5VTldNREZIVjJ0NFZrMVdjR0ZhVlZwclpFWktjMVZyTldsU1dFSktWbTEwYWsxV1NYaGFSV2hVWVRGd2NWVXdWa3RXTVd4elZXeGtVMUp1UWtsYVZXUXdWakF4VjFkdWJGaGhNbEYzVmtjeFJtVkhUa1ppUm1ST1lteEtNbFpZY0VkWlYxSkhVMnhzWVZJelFsVlZiRkpYVjBaa1dHVkdUbE5OVm5CSVZqRm9hMWRIU2tsUmJrNVhZa1pLV0ZZd1dtRlRSVEZZVDFaYVRtRXhXVEpXVm1SM1ZqRlplRk5ZY0doU2JWSldXV3RhZDJOc2NFWlhhemxxWWxWYVNGWXlNWE5oVms1R1UyMUdWMkpVUWpSVWEyUlNaVlpLY2xwSGNGTldia0paVm1wQ2EySXhXbGRYYmtaU1lsVmFWRlJXV2tkT1JsbDVZM3BXVjFZd2NFaFpNRnB2VjJ4YVJrNVlTbGRoYTNCTVZqRmtSMU5IUmtkalIyaG9UVEJLVFZZeWVHRlpWazE1Vld4a1ZtSnJOVmRaYkdRMFkwWldjMkZGVGxoV2JHdzBWMnRTUTJGRk1VVldhMmhhWVRGd2NsbFdXa3RqTVdSelZXeHdhRTFZUVhwWFdIQkhWakpTUmsxV1ZsSmhlbXhZV1cxMFMxZEdXWGxrUm1Sb1RXdGFSMVJXV21GaFZrcEhVMnhvVlZaNlZsUlpNbmhyVmpGa2NtUkdaRTVXYmtKaFYxWldZV0V4V1hoVGJHeFNZWHBHV0ZacVRrTlVSbFY1VFZaa2FrMXJOVWRYYTJSdlZUQXhkV0ZHVmxoV00xSjJWVlJLVTJNeFpIVlZiWFJUWVhwV1ZWWkdXbXRPUm1SWFYydG9UMVpZVWxaWmExcDNUVVphV0UxWE9WZGlWVnA1Vkd4V1UxWXlSWGhqUjJoYVRWWndVRnBGVlRWV01rWkhXa2RzVkZKVmNFdFdiWEJIWWpKUmVGTlliRk5pUm5CUFZteGFZVlV4YkZobFJYUllVbXhLV1Zrd1dtdFdSa3B6WTBac1lWWlhVWGRXYTFwS1pERmtjbUZHY0doTldFSnZWMVphWVdFeFRraFNhMmhRVm0xU2NGWnJWbFprTVZwMFkwVmthRTFWTlVoV01qVkxZVlpKZDFkc1VscGlSbkJNVmxWYVlXUkhWa2hQVmtwT1ZqRktTVlpxU1RGVk1WSnpXa1ZvVm1KSFVsWldiWGgzWld4U2NsZHNjR3hTTUZwS1YydGFZV0ZXV2xkWFZFWllWbXhhY2xWcVJscGxWa3BaWVVab2FHRjZWbGxXYlhoaFpESldjMVZ1VW14U1ZHeHhXVmh3YzFkR1draE5XRTVYVFZad01WVlhkREJXTURGWVZWaGtXRlpzY0ZOYVZscExZekZ3UjFWdGJGTk5NbWhWVmpGa01GbFhVWGhhUldScFUwVTFiMVZzVlRGV1JsWjBaVWhrYkZKc1dqQlpNM0JIWVVVeFJWSnJXbFppV0dnelZtcEdTbVZ0UmtsWGJIQlhZbFpLU1ZaSE1UUlpWMUpHVDFaa1lWSnRVazlVVmxaM1pHeGFjMkZJWkZOTmExWTBWVEZvYzFaSFJYbFZia0pXWVdzMVJGWnJXbUZqVmtweVpFWm9hVkp1UWxwV1JscFRWVEpHY2sxVlZsZGhNbWhoV1ZSR2QyRkdXWGxOVm1ScVRWZFNlbGxyV21GaFZtUkhVMnBhVjFKc1NraFpNakZTWlZaS2NtSkhSbE5pVmtwMlYyeGtNRmxWTlVkWGJsSk9Wa1pLVTFSV1duTk9WbFY1WlVoT1YxWXdXbnBWTW5oclZsWmFWMk5FVGxkTlJuQjZWRzE0UzJNeGNFaGpSVFZZVWxWd1NsWnRkR3RPUmxGNFYxaHNWR0pyY0ZWWmJGWmhWMFpzV0dSSVdtdE5WbkI0VlRKMFlXSkdTblJWYkhCYVZsWndWRmxXWkV0U2JVNUhZVVpvVjJKRmNFMVdiRkpMVWpGSmVGZHVWbFZpUm5Cd1ZXcEdTMWRzV2xoTlZGSlVUVlp3ZWxac2FITlViRXBIVjJ4c1ZtSllhRE5hVjNoeVpESkdTRTlXWkdsV1dFSlhWbFphVTFJeFpITlhhMXBUWVd4S1dGbFhkSGRVUmxaelYyeGthazFZUWtkVWJGcHJWRzFLV0ZwRVZsZGlWRVl6VlZSS1JtVkdVbGxoUmxKWVVqSm9iMVpVUWxaTlZsbDRZa2hLYUZKVk5YQlVWbHBMVjFad1ZsWnFRbGROVm5CNldXdFNVMVl3TVhGU2EyaFhZbGhPTkZacVNrOVRWMDVIWVVkb1RtSlhhRTVXTVZwVFVqRk5lVlJ1U2s5V2JWSlhXV3RvUTJJeFVsaE5WemxUVm14d1NWcEZaRWRYYkZwMFZXdGtWVlpzY0ZoV2JURkxWMVpXY2s5V2NGZFNWRlpGVmxSS05GbFdXbGRVYmtaU1lraENXRmxzV2t0VGJGcFZVMVJHVmsxcmNFaFZNalZUWVVaS2RHRkhSbGRoYXpWUFdsVmFkMU5IVmtsVGJYaFhUVlp3UzFaclpEUmhNa1pYVkd0YVZHRXlhRmhaVjNSelRrWlNjbHBGWkZkTlZUVjZWMnRrZDFVeFNuTmpSbXhYVm5wRk1GcEVTa2RTTWtwSFZteFNhRTFzU2xsV1JscHZVVEZKZUdKR1dtRlNlbXhYVkZkNFlVMUdjRlpYYms1WFRWVndlbGt3Wkc5WlZrcEdZMFpDV21WclduSlpNakZIVW1zMVYxcEhiRmRoTTBKWFZtMTBZVmxXV25KTlZscE9WbTFTV1ZsdGVFdGpNVlowVFZaT2FVMVdjREJhVldoclYwWktkR1JFVGxkTmJtaHlWbXBCZUdOdFRrZGpSbVJYWld0YU1sWnFRbUZaVjAxNVZHdG9hRkp0VW05WlZFWjNaVlprVlZOcVVtdE5WV3cxVlcxMGIyRldTbkpPVlRsWFlrZG9RMVJXV21Ga1IxSklVbXh3VjJKWWFGbFdhMXB2WXpGWmVWTnVTazlXYlhoWVZGVmtVMlJzYkhGU2JHUnJWakExU2xaSE1YTlViRnB6WWpOa1dGWkZOVE5WYWtaaFVqRmtkVlJ0Y0ZOaVdHaHZWbTE0WVdReFZrZFhia1pUWWxWYWNWUlhjekZUYkd0M1YyNWtWV0pGY0hwWk1GSkxWakpLV1dGSVNsWmxhMXBMV2xaYVUyTnRSa2hoUms1cFZtdHdVVlpzWkhkU01VMTRXa1prV0dKR1dsTlpiR2hUVmpGU1YxWnVUazlTYlhRelZtMHdOV0ZHV25KalJFSlhWak5vZWxadE1VdFNNV1IxWWtkR1YxWnVRbTlYYTFaclZURk9TRlZyV2xCV2F6VndWakJrYjFsV1duUmtSMFpwVFd0c05GbHJXbXRXVjBWNVZXeFdXbUV4Y0doWFZscGhZMnhhZFZwSGRHbFNia0kwVmxjd2VGSXlSblJUYTJScVUwZDRhRlZzV25ka2JGcFZVMnQwVTJKVk5VaFphMXByWVVkRmVXUkVVbGhXYkVwSVdWUkdTbVZHVW5WV2JGcHBWMFpLZWxkV1VrOVJNV1JIV2tab2JGSjZiSEJVVjNNeFpXeHNjbGR0T1ZWaVJuQmFWbGQ0VjFadFNsbGhSMmhWVm14d2Vsa3llR3RqTVhCSVlVWmthRTB3UmpSV2JGcHJUa1pKZUZwRlpGaGlhelZ4VldwS2IxZEdWbkpXYlVaVlVtMTNNbFZ0Y3pWaE1WcHlZMGh3VjJKVVJucFdWRUY0Vm0xT1JWTnNaR2hOV0VKdlYxZHdSMUp0VmxkVWJHeG9VbTFvY0ZsWWNGZFhSbVJYVld0MFZrMVdjRWhaYTJoUFYwZEtWbGRzVmxaaVZFVjNWRlJHWVdSRk5WWlBWbVJPVm0xM2VsZFVRbGRqTVdSelYyeG9hRkpXU2xoVVZ6VnZZMnhWZUZkclpHcE5hMXBJVjJ0Vk1WWXlTbkpUYWxaWFlsUkdNMVZxU2xKbFJrNXpXa1prYVdGNlZsaFhWbWgzVmpGa1IxVnNaRmRpYlZKVldXdGFkMDFHY0ZaYVJFSlZUVlZzTTFadGNGTlhiVVY0WTBoS1YyRXlVa2haZWtwUFUxWkdjMWRyTlZOaVJ6azJWbXBHWVZsWFRYaFhiR1JWWW1zMVZsbHJaRk5XUm14eVdrUk9iR0pHY0hoVk1uQlRZVEF4Y21ORmFGZE5WMmh5VmtSR1MxSnRUa2RoUm5CcFVqSm9NbGRXVm1GWlZrNUlWbXRhYTFKck5YQlZha1pMVG14a1ZWRnRSbWhOYTFwWVZURm9iMVpHWkVsUmJHaFhZbGhvVEZVd1duTldWazV5VGxkNFUySnJTa3RXYTJONFVqRlZkMDFJWkZSaVJscFlWVzB4VDA1R2JIRlRhMlJUVFZkU01WWlhjekZXTVVweVkwaHNWMUp0VVhkWFZscFBVakZrZFZWck9WZGhlbFozVmxjeE1HTXdOWE5YYkdoUFZsZFNXRlJYZEhkWGJGcEhZVWM1V2xac2JEWlpWV2hMVjJzeGRXRkVUbFpOVm5CVVdYcEtSMUl4VW5SaFJUVk9VbGQwTkZadGNFZFZNVVY1VTFob2FWSnRVbGxXTUdSVFZERmFkRTFYT1dsTlZscDVWbXhTUjFZd01WbFJiR3hoVWxkU1NGWnRjM2hYVmtaellVWmtUbUp0YUZGV2FrSmhWMjFSZVZScldtaFNiVkp3Vm10V1lVMXNXbkphUkZKb1RWVndlbFpITlU5aGJFcDBWV3M1VjJGcldraFVWRVphWlVaa2RGSnRjRTVXTVVwSlZtdGtOR015UmtkVFdIQlNZa1pLWVZsclpGTmtiSEJZWlVkR1dGSXdOVWRXUjNoM1ZqSktWMU5zYkZkaGEydDRWbFJHVTJNeFpIVlRhemxYWWxob1dWZFhlRk5XTVVwSFZtNUdVMkpZVWxsV2FrRXhVMFprY2xkdGRHaFdiSEJZV1ZST2MxWXhXalpTVkVKYVZrVmFhRll3V2s5amJVWklZVVpPVTFaR1dscFdhMXBYWVRGVmVGTllhR3BTYlZKb1ZXeGtVMVpHVWxkV2JVWnNZa2RTZVZkcll6VmhSa3BWVVdwT1ZrMXVUWGhXYWtwTFZsWkdjVlZzVm1oTmJFcElWMnhhWVZZeVRuTmFTRTVTWWtkU2NGWnRkSGRYYkZsNFdrUkNhRTFXVmpWV1IzUnJWakZrU0ZWc2FGcFdSVFZVVm0xNGMyTnNaSFZVYXpsWFltdEtXRll5ZEZOUk1WcFdUVlphYWxOSVFtRlVWVnBMVWtaYWNWTnJkRmhXTUZwSldWVmFhMVV4U2xkalJ6bFlWMGhDVEZaRVJrcGxSazUxVkcxR1UwMXRhSFpXUmxKRFUyMVdWMWR1VW1wU1ZUVmhWbXBCZUU1R1dYbGxSM1JYWWxWd2VWa3dXbUZYYlVWNFkwVjRWMkV4Y0hwWk1qRkhVbXhTYzFWdGJGTk5WVzh5Vm0wd2QyVkZNVWRXV0dST1ZtMW9WMWx0TlVOWFJsSllZMFprVmxKdGVGaFdNblF3VlRBeFdGVnVjRmhoTVhCWVZtcEtWMk14WkhGVGJHUm9ZVEJ3YjFZeFdtRlpWbGw0Vlc1V1ZHSllVbFJVVkVKTFZVWmtWMkZJWkZkTlZUVllWMnRhYTFZeVNsWlhiVVpYWVd0S2FGWXdXbFpsVlRWWFdrWmFhVkl4U2t0V1ZtUTBZakZhVjFkdVRtcFNSVFZoVm14YWQwMHhWbk5YYTNScVlsWktTRmRyVlRGV01WcEhWbXBTVjJKVVFqTmFWVnBLWlVaYVdXSkdUbWhpU0VKWlYxY3dlRlV4WkVkaVNFNVdZVEZ3Y2xSV2FFTlNiRlowWTNwV2FHRjZSbHBWVjNSM1Ztc3hkV0ZJU2xwV2JIQm9WbXBLVDFOV1pITmFSazVwVm10WmVsWnFSbUZaVms1MFZtdGtWMkpyTldoVmJURnZZMFpzV1dOR1pGaFNiVkpaV2tWa1IyRXdNVlppUkZKYVZrVTFjbFl3WkV0V1YwcEhZVVprYVZkSFozcFhiR1EwWTIxUmVGWnVTbEJXYlZKUFZXdFdZVk5XWkZWUmJUbFVUVlpzTlZWdE5VdFhSMHB5WTBkR1lWWXpVak5XVlZwV1pERndSMXBHVGs1V2EyOTNWMWQwWVdFeVJrWk5TR1JVWW14d1dGbHNhRU5UUm14VlVWaG9VMDFyY0VoWlZWcFBWMFpKZW1GR1ZsaFdNMUp5V1dwR1lWSXlTa2RoUjNoVVVqRktXbFpYTUhoT1IxWlhZa1phVjJGNmJGbFZiWGgzWld4cmQxVnJUbGRXYkhCNldUQldORmRzV2taU2FsSlhUVlp3U0ZreWVHdGpNV1IwWWtaa1UxWnNiRFpXYlRCNFpERkdkRlpyYUZWaWJFcFdXVlJHZDJOV1ZuUmxTR1JWVFZkNFdWcEZaRWRXUmxwelkwaHdWMVl6VVhkV1ZFcExWakZrZFdOR1dtbFdSbHBSVm14amVGTXhUa2RXYms1b1VqQmFXRlJVUmt0VVJscEhWbTFHV2xZd01UUldiVFZMV1ZaSmVXRkZPVmRpUjFGNlZGVmFhMVpXUm5OYVIzQk9WbTVDU2xaVVNqQmlNVnAwVTJ0b2FGSnRVbUZaYTJSdlpHeFNWVkpzY0d4U2JWSXdWVzE0VDFSc1duVlJhbHBYWVRKUk1GWkVSbE5qTVdSMVZXMTBiR0V3Y0ZwV2JURTBVekZXUjJKR1ZsUmhNbEpVVkZaYVMyVldiRlpYYlVab1ZtdHNObGxWWkc5WFJsbDZWVzFvV0Zac2NISlZha1pYWkZaU2MyRkhiRmRXYmtKaFZteGtORlV4V1hoYVJtUlhZbXhLYzFWcVRsTldiR3h5VjI1a1RsWnNXbGxhUldNMVYwWktjMk5GWkZaTmJtaDJWbXhrUm1WSFRraGhSMFpUVm01Q1VWZFljRWRaVjAxNFZXNVNhVkpyTlZoV01GWkxWMnhhY1ZKdFJtaE5SRVpJV1d0YWIxVXlSWGxWYmtKV1lURndNMVpyV25Oa1JURlhWR3hrVTJKRmNGbFdha293VFVaU2MxTnVVbXhUUjNoWVZGYzFUazFXYkZaWGJIQnJUVlp3ZUZaSGVIZGhSMFkyVm1wYVYySllRa3hWZWtaclZqRktkVk50ZUZOaVJuQlpWbTB3TVZFeFpFZGFTRTVYWWxWYVZsUldaRk5YVmxaMFpFZDBXRkl3Y0VsWlZWcFRWbFphTmxKdVdsZGhhMXBvV2tWa1QxSnNVblJoUlRWb1RXNWplRlpzWTNoTlIwVjRWMWhvWVZKWGFGZFphMlEwV1Zac2NsZHRSbWhTYkd3elZqSTFUMkZ0U2tsUmExcFhWbnBGTUZacVNrdFhWMFpIWVVaa2FWWkZXVEpXUjNoaFYyMVdSMXBJVGxkaVJUVndWV3BLYjFkR1drZFpla1pwVFd4YWVsWXlOVTlYUjBwV1YyNUtWbUpZYUV4V2JYaFhaRWRXU0dSSGFGTk5SbGt3VjFSQ2FrNVdaRWRhUld4U1lUTm9XRlZyVm1GVVJuQkdWMnQwYW1KSVFrbFZiWGhQVmpGS2MyTkVTbGROVm5CVVZXcEtVbVZHVW5WVWJHaFlVakpvV2xkWGVHOVZNazE0WWtoT1dHSlZXbFZWYlhoWFRsWndWbHBFUWxkaGVrWjVXVEJvYzFZd01YVmhTRXBYVFdwR1IxcFdXbGRqTVZaeldrVTFVMkpyU2xaV2JURTBXVlpSZVZWcldsQldiV2h3Vld4U1YxZEdVbGRXYm1SWVlrWndNRlJWYUd0aVJrcHlZa1JTVjAxdWFHaFdSM2hoWXpKT1NWSnNXazVTTVVWM1ZtMHhOR015VG5OYVNGWmhVak5TY0ZWdE5VTlhSbHB4VTFob1UwMXJXbmxVVm1oTFZERmFXVkZzWkZkaGF6VjJXVEo0WVZOSFZrWmtSM1JYWVRGd05WZHNWbUZpTWtaWFUyNVdVbUpVYkZoVVZscDNZVVpWZVUxV1pGUlNiRXA1VmpKNGEyRldTblZSYm1SWFlXdEtXRlY2UmxkU01YQkhXa2RvVkZJeFNsbFdSbFpUVmpKV2MxZFlhR2hUUlRWdlZGWldkazFzYkhKWGJYUlhWbXh3ZWxrd1pHOVdhekZIWTBkR1lWWnNWWGhXYWtaVFpFZEdSMVJ0YUd4aVJuQktWbTE0VTFNd05VaFRXR2hoVTBaS1ZGWXdaRFJXTVd4MFpVaGtWMDFYZUZaVmJUVnJWakF4V1ZGc2FGaGhNWEJ5Vm10YVNtVkdUbkpoUm1ob1RWWldORlp0Y0V0VE1rNXpWR3hXVkdKSFVtOVpWRWsxVFRGWmVGZHRSbXBOVm13MFZtMDFWMVpYU2toaFNFSmFZVEZ3TTFacldtdFdNWEJGVld4d1YySldTa2xXYlRBeFZUSktSMVJyYUZaaVIzaFhXV3hTUmsxR1duUmxSbHBzVmpGS1NWcEZaRzloUjFaeVYyeHNWMVpGYTNoWmVrWnJaRVpLV1dGSGNGTlhSMmhvVm0weE5HUXhUWGhqUm1SaFVsZFNWVlZxUW1GVFJteFdWMjEwYUZacmNGcFZWM1IzVmpBeGRWVnNVbFpXZWtaVFdsWmFZV05zY0VoU2JGSlRWa1phWVZZeFpEQmhNa2w1Vkd0a2FWSnNXbFpaVkVFeFl6RnNjbGR1WkU1U2JYUXpWbTEwTUZaWFNrWmpSbHBXWWxSV00xWnFTa3RXVmxwelZXeHdhRTFZUWsxV1J6QjRVekZKZUdORlpGZGlSMUpZV1ZST1ExTnNXblJqUlU1YVZqQTFNRlpXYUc5WFIwcHpWMnhhV21FeVVsUldSRVp6VmxaS2MyTkZOVmRpU0VJMlZqSjBiMkV4WkhOWGJrNXFVbTFvV0ZSWGNGZFZSbXhZWlVWMGExSnNXakJaVlZwcllWWktkVkZZY0ZkaVJscG9Xa1JHU21WR2NFbFViRlpwVjBaS1ZWWkdWbE5XTVU1WFYyNUtZVkpHU25CVVZscFhUa1paZVdWSVRsWmlWWEJYVmpKNGIxZHNXWHBWYldoYVRXNW9WRmt5ZUhkU2JVNUlaVVpPYUUwd1NtaFdNVnBYV1Zac1dGSnJXazVYUlRWVldXdGtiMWRXV25GVWJFNW9VbTVDUmxVeWRHdFZNREZYWTBSR1YxSXphSFpaVm1STFZqRk9kV0ZHWkZOaVNFSnZWMnRTUW1WR1NYbFNXSEJxVWpOQ1ZGWnFSa3RYYkZwWVkwVk9hMDFWTlZoWk1GcGhWMGRLV1ZWc2FGVldWa3BJV2xWYVYyTXlSa2hrUm1ST1VrVmFTVmRVUWxkT1JtUnlUVmhHVTJFemFGZFphMXAzWTJ4c05sTnJPVk5OV0VKSVYydGtjMkZGTVVsUmJXaFhZbFJDTkZwRVJrWmxSMHBIV2tkc1UySlhhRmhYVmxKTFZURmtSMkpJU2xoaVZWcFhWRlprTkdWc1duUk5WV1JYVFZWd2VsWXlOWGRXTURGeFZtNUtXbUV4Y0doWmVrcFBVakpLUjJORk5WTmlSM2Q2Vm0weE1GWnRWa2RYYmtwUFZtMVNiMVZ0TVZOV1JuQllaVWRHVjFac2NIcFdWM1F3VmtVeFZtTkliRlZpUm5CeVZtMHhTMU5XUm5OaFJscHBVbXR3V1ZaWGVHRlhiVlpIV2toU1UySklRbGhVVlZKR1RVWmtWMVZyT1d0TmExcElWVEo0VjJGV1NuTlRiRnBYWWxob2FGZFdXbE5XTVdSMFVtMTBVMVpGV2xkV1ZtTjRZakZTYzFkWWFGUmhNMEpZVm1wT2IyUnNiRFpUYTJSVFRWWktlVll5TVhkVk1rcFhVMjFvV0Zac1NraGFSRVpUVWpKT1IyRkhlRk5pYTBwNVZrWmFhMVV3TVZkWGEyaE9WMGRTYjFadGRIZE5WbFpYWVVjNVYwMUVSakZXVjNoclZsWmFjMk5HWkdGV2JIQlFXa1phVDJNeFZuUmlSazVPWWxkb2FGWnRNSGRsUlRWSFlrWm9WV0pIVWxkWmJYTXhWMVpzY21GRlRtcE5WbkF3V1ROd1IySkhTa2RpUkZaVlZtMW9jbFp0YzNoamJVNUpZa1phVG1KdGFEWldiWEJIV1ZVMWMxTnNWbEppUm5CeldWUkdkMVZXV2xoalJXUm9UV3hLV0ZVeU5VOVdWMHBZWlVab1YySlVWa1JXYlhoYVpVWndSVkZzWkU1aVJWa3hWbTB4TUdFeFpFaFRhMmhvVTBVMVYxbFhjekZXUmxwMFpVaE9hbUpHY0RGWGExVXhWakpLUjJOR2NGaGlSbHAyVmtSR2ExSXhUblZWYkZwb1RUQktXRlp0Y0U5VmF6RkhWMjVHVTJFelVsUlphMlJUWlZad1JscEZaRmROYTNCS1ZWZDRWMWRHV2taaWVrSmhVa1ZhVUZWcVJrOWtWbEp6Vm0xc1YwMHlhRnBXTVZwVFZERkZlRlp1VGxoaWJFcFBWVEJrYjFWR1ZuRlJiazVQVW14YWVsbFZZelZXTVZwMFZXdHNXbFpXY0hwV01qRkxWMWRHUm1WR1pGTlNWbkJ2VjFSS05HRXlUblJWYTJSaFVsUldXRmxVVGtOWGJGcDBUVWhrVGxac1JqUldWbWh2VmtkS2NrNVlSbFppUjFKMlYxWmFZV014Y0VaT1ZUVlhZa2QzZWxacVNqQmtNa1YzVFZoS1QxWllRbUZVVlZwM1lVWmFTRTFWZEd0U01GcEpWREZhYTJGSFJYbFBTR1JYVFZad2FGVjZTbE5TTVZaMVUyMUdVMkpJUW5kV1ZFSlhVekZXUjFkc2FFNVNSVnBUVkZaa1UxZEdaSEpoUlhSWFRXdHdTRmt3YUU5V2JVcFpZVWh3VldFeGNHaFdNRlV4Vm1zNVYyTkdaR2hOTUVreFZtdGtOR0l4UlhoWFdHUk9WbGRvVjFsdGVHRldiRnAwWlVoa1dsWnVRbGRXTWpFd1lXc3hXVkZyYUZoaE1WVjRWbXBLUm1WSFJYcGhSbVJwVWpBME1GWkhkR0ZqTVZsNFZtNVdWV0pIYUhCWmExWjNWMFprV0UxVVFscFdiR3cwV1d0YVYxVXlTbFpYYkZwV1lsUkdWRll3V2xwbFYxWkdUMVprVG1FelFrcFdiR1IzVVRGYWRGTnNiR2hTYldoWVZtdFdkMVJHVlhoWGEyUnFZbFUxU0ZsVlpITlZNa3BKVVdwV1YySkhVak5WZWtaS1pWWldjbHBHVm1saGVsWmFWMWQ0YjFFeFdrZFhibEpQVmxVMVdWWnRNVk5YVm5CV1dYcFdhRlpVUm5sV01uUnZWakF4ZFZWdVdsZFNNMmhvVmpGYVYyUldTbk5XYkdScFVteFpNRll5ZUZkWlZtUjBWbXhvVjJFeWFISlZha3B2VjBac2MxZHJkRlJXYkhCV1ZURlNSMkZyTVZkaVJGSllZVEZhZWxaWE1VWmxWMFpIWVVaYWFFMVdjRzlXYkZaaFZqSk9WMU51U2xCV00xSllXVmh3Vm1ReFpGaGtSMFpWVFd0YVIxUlZhR3RXUjBaeVRsWm9XbUV5VWxSVVZFWlhZMVpLY2s1WGVGZGlSbTk0Vm10a05HSXlSa1pOV0U1VVlsUnNXRlpxVGxOaFJsWTJVbTFHVTAxcmNFcFdSM2h2WVVVeGMxTnNSbGRXZWtVd1dYcEJNVll4Vm5WVWJHUnBWMFpLV1ZkV2FIZFNNbFpYWVROa1dHSllVbGhVVlZKSFpVWldkR1JIT1ZkTmExcDVXVEJXTkZZd01WZGpSbWhoVW0xU1VGVnFSbUZrUjBaR1RsWm9VMVpYZERSV2JYQkxUVVpWZUZOWWFHbFNiV2hXVmpCa2IyTldWbk5hUms1WVZtMTRlbGRyVWxOWFJrcHpZa1JPVjJKWVVYZFpWVnBMWXpKT1JWRnRSbGRXTVVZelYxZDBhMUl3TlhOWGJrNW9VbTFvYjFSWE1XOVdWbHB6Vld0a2FFMVZOVWxWYlhSelZUSktSMk5IT1ZWV2JIQllWR3RhWVdOV1JuUlNiRnBPVm0xM01GWXlkRzlXTVd4WFUxaHNhRkpzU21GWmEyUnZWVEZTVmxkdFJtcFdhelY0VlZkek1WVXdNVWRYVkVKWFZrVnZNRlpxU2tkV01VNTFWVzE0VTAxR2NGZFdiWGhoWkRGWmVHTkdXbGhpYXpWWVdXdGFkMWRzWkhKYVJFSlZZa1p3VmxadGNGZFhSbHBHVTIxb1dsWkZjRWhXYWtaUFpGWk9kR05HVGxkU1ZuQmFWbXhrZDFReFZYbFNhMlJZVjBkNFQxWnRNVk5YUmxKWFZsUkdUbFpzY0VsVVZsWnJWbXN4Y21ORlpGcE5SMmh5VmpCYVdtVnNWbk5oUjBaVFVsaENWVmRZY0VkaE1rMTVVbXRhVDFadFVsUlpWRTVEVGxaYWNsZHRSbWhOVmxZMFZrZDBhMkZXVGtaalJteGFZa1pLZWxscVJuTmpNV1IwVW0xNFYySkhkekZYYkZacVRsWlplVk5zV21wU2JrSmhWbXhrYjAweFduTlhiVVpUWWtkU01GVnRNVWRXTWtwWFUyeHNWMVo2UmpaVWJGcHJVMFpLY21GSGJGTmlWa3BhVmxkNFYyUXhVa2RYYmxKT1ZrWktiMVJYZUVkT1JsVjRZVWM1V0ZJd2NIbFpNRlUxVmpBeFIxZHRhRmRoTVhCaFdrUkdkMUl4VW5OaFJrNXBVbTVCTUZadGRHcGtNRFZZVW01U1ZHRXlVbGxaVjNSTFlVWmFjMWRzV2s1V2JYaFpWRlpXTUZZeVJqWldiR1JhVmxad2RsbFZWWGhYVmtaelVteGthVkpyY0VsV01WcHJWVEZaZUZOdVZsZGlSMmh3VldwR1MxVkdXblJOUkVaU1RWWndXRll5ZUc5aGJFcFlWV3hvV21KR2NHaFdNRnBoVjBkV1NWUnRhRk5oTW5kNlZtcEtORll4V25SVGJHeG9Va1UxV0ZSV1duZGpiRmwzV2taT1UwMVlRa2xhUlZVeFlVVXhkVmt6WkZkaVdHaHlWR3RrU21WR1ZuVlViR2hvWWtoQ2QxWlhNSGhPUm1SSFlraE9WbUV5VWxoVmJYaHpUVEZaZVUxVVFtaGlWWEJJVmpJMWMxWXhTalpTYmxwWFVucEdSMXBWWkVabGJVcEhXa1prYkdFeFdYcFdNV1IzVWpGa2RGVllaRTVXYlhoWVdXeGtiMVpHYkhOYVJ6bFlWbXh3TUZwRldtdGhNREZYVTJ0b1YySkhhSFpXTUdSR1pWWldkVk5zWkdsWFJURTBWMnhrTkZsWFVraFdhMmhyVW0xU1QxbFVSbHBOYkZwWFdrUkNhMDFXYkRWVk1uaFhWVEpHY2s1V1pGcFdNMUl6VldwR2QxWXhaSE5VYlhSWFlrVnZkMVpYTVRSVk1WVjVVbGh3VW1Gc1dsaFphMlJUVFRGV05sTnJjR3hTYlZKNVYydGFZV0ZXU25WUmJscFhWak5vVjFSV1dtRldNVnAxVldzMVYyRjZWbGxYVjNSaFdWWmtWMVZzWkZkaVdGSnZWV3BDV2sxc1ZuUmxTRTVYVFZac05sWlhOV0ZXTWtaeVVtcFNWMDFIVWtoVmJGcFRZekpPUjFwR1pHbGhNSEJUVm0xNGEyUXhUWGhWV0doVVYwZDRWRmxVU2xOWFZteHpXa1JTYWxKdGVGWlZWelZyVmtkS1IyTkVRbHBOUmxwUVZqSjRZV015U2tWV2JHUlRUVEpvZVZadGRHdFRNazE0Vkc1V1ZHSkdjRzlaV0hCWFZsWmFjVkZ0Um1wTmF6VjZWMnRvVjFkSFNsbFZhemxYWVd0YVRGWnFSbUZXTVd0NllVVTFVMkpGV1RCV1ZFWnZZVEZrU0ZOcmFHaFNiVkpXVm1wT1ExZEdXWGRYYlVaWVVsUkdWMXBGV2xOV01rVjRZMFJhV0Zac1dtaGFSRVphWlVaT2MxcEhiRTVOTUVwYVZtMHhORmxYUmtkaVJGcFVZWHBzV0ZSV1ZURk5WbFY1WlVjNWFGWnRVa2xaVlZwWFYwWlplbFZzYUdGU1JVVjRXWHBHYTFkWFNraGtSazVPVFZWd05GWnJXbUZaVjFGNFZHdGtWMWRIZUhOVk1GVXhWakZzYzFadVpGUmlSbHBaV2xWb1QxWXdNWEpqUmxwV1lsUldhRlpzV21GU2JHUjFZMFpXYVZkSGFGRlhWRWw0VkRGT1NGWnJaRlZpVjNoWVdWUktNMDFHV25SbFIzQnNVbFJXU0ZaR2FITlZNa3BJVld4V1YwMUhVblpXYkZwelkyeGFjbVJHYUZOaVJtOTNWMnhXYjJFeVJuUlRhMlJVWWtkU1dGbHJaRzlqYkd4eVYydDBhMUpzV25oVmJYaHJWakpXY2xkWWNGZGlSa3BNVldwQk1XTXhaSFZVYld4VFlsWktWVmRYZEdGa01WcFhWMnhvYWxKWVVsaFVWbHB6VGxaV2MyRklaRnBXYTNBd1dWVm9RMVl5U2tkalJFNVhUVlp3Y2xZd1pGZFNNWEJJWkVVMVYxWkdXa3BXYlRFMFlqSk5lVkpZYUZSaWEzQlFWbTB4YjFac1duTlhhM1JVVW14S1dGWXlOVTlXTWtwSlVXdHNWVTFXY0hKV2FrRjRVMVpHZEZKc2FGZGlSbkJaVmtkMFlXRXlVa2RYYmxaVVlrZG9jRlZ0ZEhkaU1WcFlaVWRHYTAxV1NraFphMUpoVlRKS1JrNVlSbFZXYkhCTVdsZDRhMk5zWkhSa1IyaFhZbFpLU1ZaWE1YZFpWbGw1VTJ4V1VtRnJOV2hWYTFaM1YwWlZkMWRzWkZoV01GcElWbGQ0YjFVd01IbGhSbXhYWWxoQ1JGbFVTa3BsUm1SMVZHMXNVMkpHY0ZaWFYzaFRZekZrUjFkdVVrNVdSa3BZV1d0YVYwNVdjRlpXVkZaWFRVUkdlVmt3Vm5OWlZscFlZVVJPVjAxSFVrZGFWVnBQWXpGV2MxcEZOVk5pYTBwT1ZqSjBWMkV4V1hoVFdHaGhVMFUxYUZWdGN6RlVNVkpYVm01a1ZtSkdjREJaTUZZd1ZERktkR1ZHYkZkU2JXaDZWbXhrUm1WWFZraFBWbHBwVjBkbmVsZFVRbUZaVjA1elYyNU9ZVkpVVms5V2JUVkRUbFpaZVdSR1RsWk5WbkJKVlRKNGExVXlSbk5UYkdoVlZqTkNXRlV3V21Ga1JURldaRVpTVTJKR2IzaFdWbVEwV1ZkR1NGSlljRkpoYTNCWVZXMHhVazFHV1hsTlZtUlRUVmhDU2xaWGVFOWhWa3B5WTBaQ1YySllRa2hWZWtaUFZqRmtkVlZyTlZOU1ZuQlpWa1phWVZsVk1VZFdXR3hyVWpOU2IxbHJWbmRXYkd4eVYyMTBXR0pWY0VsWlZXaGhWbFpaZW1GRVRsZE5SMUpZVlRCa1UxSXhjRVpPVm1ScFlUQlplbFp0ZUdwbFJUVklVbGhvVm1Kc1NsVlpWRVozWTFaV2RFNVZUbGhTYlhoV1ZUSjRTMkV3TVZoa2VrcFdZbFJHU0ZZd1drdGphelZaWWtad1YxWnVRbTlYVmxaclZqSlNTRlpyWkdsU2JXaFlWRlJLYjFaV1duUmpSV1JUWWxaYVNWWkhkR0ZXTWtwR1RsaENWMDFHY0V4YVZWcGhVakZrZEZKdGRFNVNSVnBKVjFSQ1YxbFdaRWhTYWxwcFVteHdZVmxyV21GWFJsSjBaVVprV0ZJeFNrcFdSM2hyVkcxRmVHTkVWbGhXYkVwUVdXcEdXbVZHWkhKWGJHaHBWakpvYjFaWGVHRmtNVlpIWTBWa1dHSkhVbkpWYWtaaFUwWmFTRTFZVGxkTlJFWXdXVlZrUjFZeVJuSlhiV2hhVmtWd1dGa3ljM2hXTWtaSFYyMXNhR1ZzV21GV01XUXdXVmRSZUZwR1pHbFRSVFZZV1d4V1lXTldiSEpYYlVac1VteGFXRmxWWXpWV1ZURnlZMFZzWVZaV2NISldha0Y0WTFaS1dWcEdaR2xTTVVwTlZtMHhOR0V4V2xkVWJrNWhVako0V1ZWdGRIZE9WbHAwVFZoa1UwMVhlRmxXVjNSclZqSktSMWRzVGxwaE1taEVWakJhVjJNeFpIVmFSMmhUWWxaS05WWnNaREJUTWtwSFUyNUtUMVp0YUdGVVZWcGhZMnhhZEUxVmRGaFNNRnBIVkRGYWQyRldXa1pYYWtwWFlXdHZNRll5TVZkU01YQkpWVzEwVTFaR1dsVldSbFpUVW0xV2MxZHJhR3hTYlZKdlZGWmFjMDVXVlhsT1ZYUllVakJ3U0ZZeU1VZFdNREZJWVVWU1lWWXphSGxhVlZwclpGWlNjMkZHWkU1U1JscEtWbXBLTUZsWFNYaFdXR3hVWWtkNGIxVnJXbUZYUm14WVpFaGFUbEpzY0VaVk1uUnJWVEF4V0ZWcVJsWk5ha1o2VmxSR1MyTnRUa2RoUm1SVFlsVXhORmRYY0V0V01rMTRXa2hXVTJKR1NtOVVWRVpMVjFaYWRFMVVRbHBXYlZKNldXdGFZVmRIU2xaWGJHaFZWbXhhTTFZeWVGZFhSMUpGVld4b1UwMUlRa2xXYWtsNFlqRmtjMWRyV21wU2JFcFlXVmQwWVdGR2NFZFhhemxxWVhwc1dGZHJaSE5XTURGMFlVWm9WMkpZYUhKVWExcGFaVlpXV1dGR1pHbFNNVXBhVjFjeE5GTXhVWGhXV0dSaFVtczFjVlJXV21GTlJuQldWMjEwVlUxVmNEQldWelZ6VmpKS1ZWSllaRmROUm5CTVdrVmFWMk50U2toU2JHUlhZbXRLUmxadE1YZFRNVTE0VTFob1ZXSnNXbkZWYlRGVFZERmFkRTVWVGxoV2JWSldWVzB4UjFVd01YTlRiR2hhVFVaYWNsWnNaRWRPYkZwellVWndWMUpVVmtSV1JtUTBWMjFXUjFwSVRtRlNiVkpQVm0xMFdrMUdXbkZTYlRscVRWWndTVlV5ZEd0aGJFNUdWMnhrV21FeVVsUmFSM2hyVmpGa2MxUnNaR2xUUlVwS1ZrUkdWazFXVW5OWGJsWlNZV3h3V0ZSWE5WTlhSbEpXVjIxMFUwMVhVbHBYYTFwdllVVXhkV0ZIYUZkaVdHaG9Xa1JCZDJWSFNrbFRiVVpUVm01Q2VsWlhjRUpOVms1SFlraEtXR0pVYkZoVVZsWjNWMnhXVjFWcmRGZE5WV3cyV1ZWa2IxZHNXa1pYYkVKV1lXdGFVRnBHV2s5ak1rWklZVWQ0YVZkSGFHRldiWFJoWVdzeFdGTllhRmhpUjFKWldXMTBZVlV4YkhKYVJrNVhVbTE0ZWxZeU1VZFhSa3B6WWtSV1ZXSkdjRkJaVmxwTFkyMUtSVlJzWkU1aGEwVjRWbTE0WVZsV1dYaFViazVvVW14d1QxVnROVU5pTVZwWVkwVjBVMDFWTlZoV1Z6VlBWMGRHTmxadE9WVldSVXBNVlhwR1dtVkdaSE5hUm5CWFRVZDNNRll5ZEc5Vk1WcElVMnRvYkZKdFVtRlphMlJUWkd4WmQxZHRSbXBpUm5Bd1ZXMHhOR0ZXU25WUmFscFhZV3R2TUZaRVNrWmxSazV6Vm0xc1UySlhhRmxXVjNCUFlqSk9jMkpHWkZoaVZWcHhXV3hXZDFKc1dsaGxSM1JWWWtac05GVXhhSGRXTWtWNFUydDRWbUpVUmxoVmFrWnJaRlpPZEZKc1RtbFdNbWd6Vm14amQwMVdSWGhXYkdSWVltdGFVMWxzVm1GWlZscDBaVWhPVDFKc2NEQlViRnBQWVZaS2NtTkdiRmRXTTAweFZteGFZV015VGtkaFJsWnBWMGRvZVZkVVNYaFNNVTVIVTI1T1dHSkhVbkJWYlRWRFdWWmFjbFZyVGxaTmF6RTBWVEowYTJGc1NrZGpSVGxXWVRKUk1GVnNXbXRrVjBsNldrWkNWMVpVVmpGV1ZWcFNaREZPTTJKNk1Fc0sK Looking at the characters and the name of the challenge, we can guess that it is the result of encoding a certain string multiple times in Base64.
Since there are a lot of encoding processes, we can use a loop in Bash until we find the flag in plain text:
$ f=$(cat flag.txt); while true; do if [[ $f = CTFlearn* ]]; then echo $f; break; fi; f=$(echo $f | base64 -d); done CTFlearn{pr3tty_b4s1c_r1ght?</description></item><item><title>Space pirate: Entrypoint</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/space-pirate-entrypoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/space-pirate-entrypoint/</guid><description>We are given a 64-bit binary called sp_entrypoint:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' We can run it to view two options:
$ ./sp_entrypoint Authentication System ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░▒▓▓▓░░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓▒░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▒░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒░░░▓▓░░░▓▓▒░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒░░░▒▓▓░░░▓▓▒ ░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░░░░░▓▓░░░▓▓▓ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░▓▓▓▒░░░░▓▓▒ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░▒░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓░▒▓▓▓░░░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒░▓▓▓░░░░ ▓▓ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 1.</description></item><item><title>Space pirate: Going Deeper</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/space-pirate-going-deeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/space-pirate-going-deeper/</guid><description>We are given a 64-bit binary called sp_going_deeper:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' If we run it, we will see three options:
$ ./sp_going_deeper Trying to leak information from the pc.. 🖥️ ____________________________________________________ / \ | _____________________________________________ | | | | | | | goldenfang@d12:$ history | | | | 1 ls | | | | 2 mv secret_pass.</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/space-pirates/</guid><description>We are given this Python source code:
fromsympyimport* fromhashlibimportmd5 fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad fromrandomimportrandint, randbytes, seed FLAG=b'HTB{dummyflag}' classShamir: def__init__(self, prime, k, n): self.p=prime self.secret=randint(1, self.p-1) self.k=k self.n=n self.coeffs=[self.secret] self.x_vals=[] self.y_vals=[] defnext_coeff(self, val): returnint(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) defcalc_coeffs(self): foriinrange(1, self.n+1): self.coeffs.append(self.next_coeff(self.coeffs[i-1])) defcalc_y(self, x): y=0 fori, coeffinenumerate(self.coeffs): y+=coeff*x**i returny%self.p defcreate_pol(self): self.calc_coeffs() self.coeffs=self.coeffs[:self.k] for_inrange(self.n): x=randint(1, self.p-1) self.x_vals.append(x) self.y_vals.append(self.calc_y(x)) defget_share(self): returnself.x_vals[0], self.y_vals[0] defmain(): sss=Shamir(92434467187580489687, 10, 18) sss.create_pol() share=sss.get_share() seed(sss.secret) key=randbytes(16) cipher=AES.new(key, AES.MODE_ECB) enc_FLAG=cipher.encrypt(pad(FLAG, 16)).hex() print(sss.coeffs) f=open('msg.enc', 'w') f.</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>We are given the source code of a Node.js web project using Express JS and MySQL. In the Dockerfile an entrypoint.sh script is run:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/spooky-rsa/</guid><description>We got the Python source code used to encrypt the flag:
fromCrypto.Util.numberimportbytes_to_long, getStrongPrime fromrandomimportrandint FLAG=b'HTB{????????????????????????????????????????????}' defkey_gen(bits): p, q=getStrongPrime(bits), getStrongPrime(bits) N=p*q returnN, (p, q) defencrypt(m, N, f): e1, e2=randint(2, N-2), randint(2, N-2) c1=(pow(f, e1, N) +m) %N c2=(pow(f, e2, N) +m) %N return(e1, c1), (e2, c2) defmain(): N, priv=key_gen(1024) m=bytes_to_long(FLAG) (e1, c1), (e2, c2) =encrypt(m, N, priv[0]) withopen('out.txt', 'w') asf: f.write(f'N = {N}\n(e1, c1) = ({e1}, {c1})\n(e2, c2) = ({e2}, {c2})\n') if__name__=="</description></item><item><title>St3g0</title><link>https://7rocky.github.io/en/ctf/picoctf/forensics/st3g0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/forensics/st3g0/</guid><description>We have a PNG image called pico.flag.png:
Since the challenge name is St3g0, it seems that the image has hidden data using steganography. We can use zsteg to show the flag:
$ zsteg pico.flag.png b1,r,lsb,xy .. text: "~__BwV_G@" b1,rgb,lsb,xy .. text: "picoCTF{7h3r3_15_n0_5p00n_96ae0ac1}$t3g0" b1,abgr,lsb,xy .. text: "E2A5q4E%uSA" b2,b,lsb,xy .. text: "AAPAAQTAAA" b2,b,msb,xy .. text: "HWUUUUUU" b2,a,lsb,xy .. file: Matlab v4 mat-file (little endian) &amp;gt;&amp;lt;?P, numeric, rows 0, columns 0 b2,a,msb,xy .. file: Matlab v4 mat-file (little endian) | &amp;lt;?</description></item><item><title>Stonks</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</guid><description>We are given the C source code of a binary. The source code is relatively large, so the most interesting function is this one:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>Substitution Cipher</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/substitution-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/substitution-cipher/</guid><description>We are given this encrypted text:
MIT YSAU OL OYGFSBDGRTKFEKBHMGCALSOQTMIOL. UTFTKAMTR ZB DAKQGX EIAOF GY MIT COQOHTROA HAUT GF EASXOF AFR IGZZTL. ZT CTKT SGFU, MIT YSACL GF A 2005 HKTLTFM MODTL MIAF LMADOFA GK A CTTQSB LWFRAB, RTETDZTK 21, 1989 1990, MIT RKTC TROMGKL CAL WHKGGMTR TXTKB CGKSR EAF ZT YGWFR MIT EGFMOFWTR MG CGKQ AM A YAOMIYWS KTHSOTL CITKT IGZZTL, LMBST AOD EASXOF, AMMAEQ ZGMI LORTL MG DAKQL, "</description></item><item><title>Sum-O-Primes</title><link>https://7rocky.github.io/en/ctf/picoctf/cryptography/sum-o-primes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/cryptography/sum-o-primes/</guid><description>We are given the output of an RSA encryption:
x = 17fef88f46a58da13be8083b814caf6cd8d494dd6c21ad7bf399e521e14466d51a74f51ad5499731018b6a437576e72bd397c4bb07bfbb699c1a35f1f4fa1b86dee2a1702670e9cea45aa7062f9569279d6d4b964f3df2ff8e38cf029faad57e42b831bde21132303e127cba4e80cd3c9ff6a7bad5b399a18252dc35460471ea8 n = 85393637a04ec36e699796ac16979c51ecea41cfd8353c2a241193d1d40d02701b34e9cd4deaf2b13b6717757f178ff75249f3d675448ec928aef41c39e4be1c8ba2ba79c4ada36c607763d7dc8543103acfe1027245acda2208f22fcabe0f37bdadf077e4f943c4f4178cedeb5279a4ebc86323356e23a58b6666ac6ffbf4f1c8229117ffb9071a94dfb724957f10d6664e4ee02e16bed29eb922f126e2082e2f73b5c5b7817e0543155eb9673f4de3de8c91707c1261e8ba6e7348d930293f7796679218c2b1dabe41527eccd72ec3e7284344622eff81ae0541769fb70b6146b54bd092c2dfbe7f8e9653cad80d0fb4f3ef288778927b3852f9ff3a4076d7 c = 42cafbc77ed8396a681dac328701ee02cd746488ae084f15a3e6a5b8f666c595a372a69bbca0dae934fd5ed2292d4393912ee10a22a3b57de9cee2f30b5dc7c67f574b0453f6074171cca37bd407529cb30ba17f152ef5b2484d94b38cf0a513a723255d725e5c3b3f3c985f9223095be3fa148afedf91e4ed37720c3d97dd29cf07830efa8a557a9da68d3095fc3b31f3763e030b62c70d94c3d2951e163e48683f3b9611d562ea06bf1e5d8465e8bf5a6345050a5e7b0c175faf136562cf2a196fdb61ac6503446616cffa9ed85015b86dda73f6eda4d688d3e719a07439d98f95fb5dcf675948ec58d9af83fa29afa4375213ec48f09a6c8cbc431cfe7c6a We are also given the source code to generate this output. There, we can see that $x = p + q$, $n = p q$ and $c$ is the ciphertext. The exponent $e = 65537$.
RSA background RSA works so that, given a message $m$ in decimal format, we can encrypt it as follows:</description></item><item><title>Taking LS</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/taking-ls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/taking-ls/</guid><description>We are given a ZIP file that contains these files and directories:
$ unzip -l The\ Flag.zip Archive: The Flag.zip Length Date Time Name --------- ---------- ----- ---- 0 10-30-2016 14:45 The Flag/ 6148 10-30-2016 14:45 The Flag/.DS_Store 0 10-30-2016 14:46 __MACOSX/ 0 10-30-2016 14:46 __MACOSX/The Flag/ 120 10-30-2016 14:45 __MACOSX/The Flag/._.DS_Store 0 10-30-2016 14:40 The Flag/.ThePassword/ 42 10-30-2016 14:41 The Flag/.ThePassword/ThePassword.txt 16647 10-30-2016 14:45 The Flag/The Flag.pdf 177 10-30-2016 14:45 __MACOSX/The Flag/.</description></item><item><title>Tapping</title><link>https://7rocky.github.io/en/ctf/picoctf/cryptography/tapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/cryptography/tapping/</guid><description>We are given a strange message from nc:
$ nc jupiter.challenges.picoctf.org 9422 .--. .. -.-. --- -.-. - ..-. { -- ----- .-. ... ...-- -.-. ----- -.. ...-- .---- ... ..-. ..- -. ..--- -.... ---.. ...-- ---.. ..--- ....- -.... .---- ----- } Ncat: Broken pipe. We see that the message has only . and - (and also braces, indicating that the message might be the flag). In fact, the message is Morse code.</description></item><item><title>Teleport</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/teleport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/teleport/</guid><description>We have a binary called teleport:
$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped If we run it, it asks for a password:
$ ./teleport Missing password We can try to add it as a command line argument:
$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong... Using ltrace we see that the input is copied at some memory address and then there are a lot of jumps (44 calls to _setjmp):</description></item><item><title>The Office</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</guid><description>We are given a 32-bit binary called the_office:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) The challenge says that they have implemented a secure heap using canaries.
We do not have the C source code. Hence, we need to use a reversing tool like Ghidra.
Although the file is stripped:
$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>The secret of a Queen</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/the-secret-of-a-queen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/the-secret-of-a-queen/</guid><description>We are given an image with some weird symbols:
The name of the challenge is actually a hint, because there is a cipher used by Mary, Queen of Scots. The cipher is based in a substitution of letters by symbols using this alphabet:
If we translate every symbol on the given image to a letter, we capture the flag: HTB{THEBABINGTONPLOT}.</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>We are given this Python source code:
fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad importrandom importsignal importsubprocess importsocketserver FLAG=b'HTB{--REDACTED--}' prefix=random.randbytes(12) key=random.randbytes(16) defencrypt(key, msg): msg=bytes.fromhex(msg) crypto=AES.new(key, AES.MODE_ECB) padded=pad(prefix+msg+FLAG, 16) returncrypto.encrypt(padded).hex() defchallenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n'+ b'It seems like there is a prefix appended to the real firmware\n'+ b'Can you somehow extract the firmware and fix the chip?\n') whileTrue: req.sendall(b'&amp;gt; ') try: msg=req.recv(4096).decode() ct=encrypt(key, msg) req.sendall(ct.encode() +b'\n') exceptExceptionase: print(e) req.sendall(b'An error occurred! Please try again!') classincoming(socketserver.BaseRequestHandler): defhandle(self): signal.</description></item><item><title>Time Traveller</title><link>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/time-traveller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/miscellaneous/time-traveller/</guid><description>In this challenge, we are told to find an email address that was shown in the NASA&amp;rsquo;s website (nasa.gov) on December 31, 1996.
The way to find something in a certain date is going to web.archive.org (WayBack Machine):
Here we search for nasa.gov and get a lot of snapshots of the webpage. Curiously, the oldest snapshot is from December 31, 1996:
If we check this snapshot, we see some information. And here we have the email:</description></item><item><title>Tree of Danger</title><link>https://7rocky.github.io/en/ctf/htb-challenges/misc/tree-of-danger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/misc/tree-of-danger/</guid><description>We are given the Python source code that is being run by the remote instance (util.py):
#!/usr/bin/env python3.10 importast importmath fromtypingimportUnion defis_expression_safe(node: Union[ast.Expression, ast.AST]) -&amp;gt; bool: matchtype(node): caseast.Constant: returnTrue caseast.List|ast.Tuple|ast.Set: returnis_sequence_safe(node) caseast.Dict: returnis_dict_safe(node) caseast.Name: returnnode.id =="math"andisinstance(node.ctx, ast.Load) caseast.UnaryOp: returnis_expression_safe(node.operand) caseast.BinOp: returnis_expression_safe(node.left) andis_expression_safe(node.right) caseast.Call: returnis_call_safe(node) caseast.Attribute: returnis_expression_safe(node.value) case_: returnFalse defis_sequence_safe(node: Union[ast.List, ast.Tuple, ast.Set]): returnall(map(is_expression_safe, node.elts)) defis_dict_safe(node: ast.Dict) -&amp;gt; bool: fork, vinzip(node.keys, node.values): ifnotis_expression_safe(k) andis_expression_safe(v): returnFalse returnTrue defis_call_safe(node: ast.Call) -&amp;gt; bool: ifnotis_expression_safe(node.func): returnFalse ifnotall(map(is_expression_safe, node.</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>Ursa Minor</title><link>https://7rocky.github.io/en/ctf/other/ursa-minor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ursa-minor/</guid><description>We are given the following source code and an instance to connect to:
#!/usr/local/bin/python # # Polymero # # Imports fromCrypto.Util.numberimportisPrime, getPrime, inverse importhashlib, time, os # Local import FLAG=os.environ.get('FLAG').encode() classURSA: # Upgraded RSA (faster and with cheap key cycling) def__init__(self, pbit, lbit): p, q=self.prime_gen(pbit, lbit) self.public={'n': p*q, 'e': 0x10001} self.private={'p': p, 'q': q, 'f': (p-1)*(q-1), 'd': inverse(self.public['e'], (p-1)*(q-1))} defprime_gen(self, pbit, lbit): # Smooth primes are FAST primes ~ !</description></item><item><title>Vault-breaker</title><link>https://7rocky.github.io/en/ctf/htb-challenges/pwn/vault-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/pwn/vault-breaker/</guid><description>We have a 64-bit binary called vault-breaker:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./.glibc/' If we execute it, we have two options:
$ ./vault-breaker Current status: Unlocked🔓 ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒▒▓▓▓▓▒▒▒▒▒▒░░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒░░▒▒░░████▓▓████░░▒▒▓▓▓▓▓▓▓▓▓▓░░▒▒░░ ░░░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒▓▓░░▓▓▒▒▒▒▒▒░░░░▒▒▓▓██▒▒▒▒▓▓▓▓▓▓░░░░ ░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒▓▓░░▓▓░░██▓▓▓▓▓▓▒▒▒▒██░░▓▓▓▓▒▒▒▒ ░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░▓▓▒▒░░▒▒██░░██▒▒▒▒▒▒▒▒██▒▒▒▒██▓▓▒▒▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▒▒▓▓▒▒▓▓░░▒▒▓▓▒▒▒▒░░░░░░▒▒██░░██▒▒▒▒ ▒▒▒▒▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒░░░░▓▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒░░░░░░░░▒▒▓▓▓▓▓▓▒▒ ░░▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▒▒▒▒▒▒▓▓░░▓▓░░░░░░░░▒▒▒▒██▒▒██▒▒ ▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▓▓▒▒░░▒▒▓▓░░░░░░░░░░▒▒▒▒▓▓▒▒██░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▓▓▒▒░░▒▒▓▓░░▒▒░░░░░░░░░░▓▓▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒▒▒▒▒▓▓▒▒░░░░░░░░░░░░▒▒▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▒▒▒░░▓▓▒▒░░░░▒▒░░▒▒▒▒▓▓▒▒▓▓░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▒▒▓▓░░░░░░▒▒░░▒▒▓▓▓▓██▒▒ ░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓██▒▒░░▒▒▒▒▓▓▒▒░░░░▒▒▒▒▓▓▓▓▒▒░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓██▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▒▒██▒▒░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▓▓▒▒▒▒░░▓▓▒▒▒▒▒▒▓▓▒▒██▒▒▓▓▓▓░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓██▓▓▒▒██▒▒░░▒▒▒▒▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓░░░░ ░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▓▓██▓▓████▒▒▒▒▓▓▓▓▓▓▓▓▓▓░░░░░░░░ ░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓██▒▒▓▓▒▒▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ [+] Random secure encryption key has been generated!</description></item><item><title>Vigenère Cipher</title><link>https://7rocky.github.io/en/ctf/ctflearn/cryptography/vigenere-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/cryptography/vigenere-cipher/</guid><description>We are given this ciphertext:
DETctysy{QzeffcgRgcBhsjdkf} And we also have a strange word: blorpy.
Since the challenge is called &amp;ldquo;Vigenère Cipher&amp;rdquo;, we can guess that the encryption algorithm is precisely Vigenère cipher, which is a type of Caesar substitution algorithm. To decrypt the message, we can go to CyberChef and use blorpy as key:
Flag: CTFlearn{CiphersAreAwesome}.</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/weak-rsa/</guid><description>We are given a public key in PEM format for an RSA implementation (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA works as follows: We take two large primes $p$ and $q$ and set the modulus $n = pq$. Then we choose an exponent $e$ (typically $e = 65537$) and encrypt a message $m$ in decimal format:</description></item><item><title>what's a net cat?</title><link>https://7rocky.github.io/en/ctf/picoctf/general-skills/whats-a-net-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/general-skills/whats-a-net-cat/</guid><description>We are given a remote instance to connect to. If we stablish the connection with nc, we get the flag:
$ nc jupiter.challenges.picoctf.org 25103 You're on your way to becoming the net cat master picoCTF{nEtCat_Mast3ry_d0c64587}</description></item><item><title>where are the robots</title><link>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/where-are-the-robots/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/web-exploitation/where-are-the-robots/</guid><description>We are given a website like this:
The page talks about robots. There is a special file called robots.txt that prevents web crawlers and spiders to access some routes listed on the file. Let&amp;rsquo;s take a look:
Alright, there is a Disallow: /8028f.html, which does not mean that we cannot enter (it only tells automatic scanners not to enter). This is /8028f.html:
And there&amp;rsquo;s the flag: picoCTF{ca1cu1at1ng_Mach1n3s_8028f}.</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/whole-lotta-candy/</guid><description>We got the Python source code of the server:
fromencryptimportEncryptor fromsecretimportFLAG importsocketserver importrandom importsignal importjson MODES=['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defmain(s): mode=random.choice(MODES) enc=Encryptor() whileTrue: try: sendMessage(s, f"Please interact with the server using json data!\n") sendMessage(s, f"Selected mode is {mode}.\n") payload=receiveMessage( s, "\nOptions:\n\n1.Encrypt flag\n2.Encrypt plaintext\n3.Change mode\n4.Exit\n\n&amp;gt; " ) payload=json.loads(payload) option=payload["option"] ifoption=="1": ciphertext=enc.encrypt(FLAG, mode).hex() response=json.dumps({ "response": "encrypted", "</description></item><item><title>WIDE</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/wide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/wide/</guid><description>We are given a 64-bit binary file called wide and another file called db.ex with some strings:
$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe If we run the binary we have this:</description></item><item><title>WOW... So Meta</title><link>https://7rocky.github.io/en/ctf/ctflearn/forensics/wow...-so-meta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/forensics/wow...-so-meta/</guid><description>We are told to find the flag in this image:
However, the flag is not visible inside the image and it is not hidden in its content. However, we can find the flag in the file metadata.
We can use exiftool to extract the file metadata and then filter by CTFlearn using grep:
$ exiftool 3UWLBAUCb9Z2.jpg | grep CTFlearn Camera Serial Number : CTFlearn{EEe_x_I_FFf}</description></item><item><title>Wrong Spooky Season</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/wrong-spooky-season/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/wrong-spooky-season/</guid><description>We are given a network traffic capture file called capture.pcap.
Traffic analysis We can use Wireshark to analyse it:
HTTP messages There are a lot of packages. Let&amp;rsquo;s filter by HTTP first:
Alright, we have significanly less packages to analyze.
There are some HTTP messages that stand out at the end. We guess that a malicious user is executing remote system commands on the server (cmd=whoami, cmd=id &amp;hellip;). The last message is using socat to obtain a reverse shell connection, we can select this packet and remove the HTTP filter.</description></item><item><title>XORed</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</guid><description>The program says that someone has used a XOR cipher with a single byte key. This is the output: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Since we know that flags start with ictf{, we can get the key using &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; because of XOR cipher properties:
$$ c = m \oplus k \iff k = c \oplus m $$
So we solve the challenge like this:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</guid><description>We are given this source code to encrypt the flag, and also the ciphertext as a comment in the code:
#!/usr/bin/env python3 flag=open('flag.txt', 'rb').read() key=open('/dev/urandom','rb').read(1)[0] out=[] forcinflag: out.append(c ^ key) key=c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' From the source code, we see that the key is a single byte. Moreover, the key is updated with the current plain text character.
Hence, we can use some Python scripting to solve the challenge:</description></item><item><title>You Cant C Me</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/you-cant-c-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/you-cant-c-me/</guid><description>We have a binary called auth:
$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped If we run it, it asks for a key:
$ ./auth Welcome! We can introduce something and see that it is not correct:
$ ./baby Insert key: asdf I said, you can't c me! We can make use of ltrace to see every call to external functions (functions that belong to a library like Glibc):</description></item><item><title>zero_to_hero</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/</guid><description>We are given a 64-bit binary called zero_to_hero:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' We also have the Glibc shared library and the loader (version 2.29):
$ ./ld-2.29.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.29-0ubuntu2) stable release version 2.29. Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item></channel></rss>