<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Exploitation on 7Rocky</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/</link><description>Recent content in Binary Exploitation on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/index.xml" rel="self" type="application/rss+xml"/><item><title>basic-file-exploit</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/basic-file-exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/basic-file-exploit/</guid><description>We are given the C source code of a program that runs remotely:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define WAIT 60 static const char* flag = "[REDACTED]"; static char data[10][100]; static int input_lengths[10]; static int inputs = 0; int tgetinput(char *input, unsigned int l) { fd_set input_set; struct timeval timeout; int ready_for_reading = 0; int read_bytes = 0; if(l &amp;lt;= 0) { printf("</description></item><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We do not have the source code of the binary, and it is stripped:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Reversing the binary will be more challenging because we do not have the names of the functions.</description></item><item><title>Cache Me Outside</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cache-me-outside/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cache-me-outside/</guid><description>We are given a 64-bit binary called heapedit and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit It is configured to use Glibc at the current directory:
$ ldd heapedit linux-vdso.</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is call function gets and after that compare a local variable (code) with the value of a global variable (GOAL):
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = "</description></item><item><title>CVE-XXXX-XXXX</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</guid><description>We have this challenge statement:
The CVE we&amp;rsquo;re looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.
We are told to search a CVE identifier for the first RCE vulnerability in Windows Print Spooler Service in 2021.</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is request two numbers and try to find one that breaks Fermat&amp;rsquo;s Last Theorem.
As a reminder, Fermat&amp;rsquo;s Last Theorem claims that there are no positive integers $a$, $b$, $c$, that satisfy the equation:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>We are given a 32-bit binary called fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments We do not have the C source code. This time, instead of reversing the binary using tools like Ghidra, we will analyze it with GDB.
First let&amp;rsquo;s execute the program:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>We are given a 64-bit static binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } int do_stuff() { long ans = (get_random() % 4096) + 1; int res = 0; printf("</description></item><item><title>Here's a LIBC</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</guid><description>We are given a 64-bit binary called vuln and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln It is configured to use Glibc at the current directory:
$ ldd vuln linux-vdso.</description></item><item><title>SaaS</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/saas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/saas/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Static code analysis We also have the original C source code (chall.c):
#include&amp;lt;errno.h&amp;gt; #include&amp;lt;error.h&amp;gt; #include&amp;lt;fcntl.h&amp;gt; #include&amp;lt;seccomp.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;string.h&amp;gt; #include&amp;lt;sys/mman.h&amp;gt; #include&amp;lt;sys/syscall.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; #defineSIZE0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;amp;arch=x86-64&amp;amp;as_format=inline#assembly #defineHEADER"\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #defineFLAG_SIZE64 charflag[FLAG_SIZE]; voidload_flag() { intfd; if((fd =open("flag.txt", O_RDONLY)) ==-1) error(EXIT_FAILURE, errno, "open flag"); if(read(fd, flag, FLAG_SIZE) ==-1) error(EXIT_FAILURE, errno, "read flag"</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>We are given a 32-bit binary called seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled This time we do not have the source code. However, we can use a reversing tool like Ghidra to decompile the binary into somewhat readable C source code. Here we have the main function:
void main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts("</description></item><item><title>Stonks</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</guid><description>We are given the C source code of a binary. The source code is relatively large, so the most interesting function is this one:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>The Office</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</guid><description>We are given a 32-bit binary called the_office:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) The challenge says that they have implemented a secure heap using canaries.
We do not have the C source code. Hence, we need to use a reversing tool like Ghidra.
Although the file is stripped:
$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item></channel></rss>