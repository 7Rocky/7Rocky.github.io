<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Exploitation on 7Rocky</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/</link><description>Recent content in Binary Exploitation on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/index.xml" rel="self" type="application/rss+xml"/><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We do not have the source code of the binary, and it is stripped:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Reversing the binary will be more challenging because we do not have the names of the functions.</description></item><item><title>Catch Me Outside</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/catch-me-outside/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/catch-me-outside/</guid><description>We are given a 64-bit binary called heapedit and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit It is configured to use Glibc at the current directory:
$ ldd heapedit linux-vdso.</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is call function gets and after that compare a local variable (code) with the value of a global variable (GOAL):
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = "</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is request two numbers and try to find one that breaks Fermat&amp;rsquo;s Last Theorem.
As a reminder, Fermat&amp;rsquo;s Last Theorem claims that there are no positive integers $a$, $b$, $c$, that satisfy the equation:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>We are given a 32-bit binary called fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments We do not have the C source code. This time, instead of reversing the binary using tools like Ghidra, we will analyze it with GDB.
First let&amp;rsquo;s execute the program:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>We are given a 64-bit static binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt; #define BUFSIZE 100 long increment(long in) { return in + 1; } long get_random() { return rand() % BUFSIZE; } int do_stuff() { long ans = get_random(); ans = increment(ans); int res = 0; printf(&amp;#34;What number would you like to guess?</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code. Basically, what the program does is request a number, compare it with a random one and if it is the same, then request a username to print a message:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } int do_stuff() { long ans = (get_random() % 4096) + 1; int res = 0; printf("</description></item><item><title>Here's a LIBC</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/heres-a-libc/</guid><description>We are given a 64-bit binary called vuln and a libc.so.6 file as external library:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' If we run the binary we will get a segmentation fault:
$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln It is configured to use Glibc at the current directory:
$ ldd vuln linux-vdso.</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>We are given a 32-bit binary called seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled This time we do not have the source code. However, we can use a reversing tool like Ghidra to decompile the binary into somewhat readable C source code. Here we have the main function:
void main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts("</description></item><item><title>Stonks</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/stonks/</guid><description>We are given the C source code of a binary. The source code is relatively large, so the most interesting function is this one:
#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!</description></item><item><title>The Office</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/the-office/</guid><description>We are given a 32-bit binary called the_office:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) The challenge says that they have implemented a secure heap using canaries.
We do not have the C source code. Hence, we need to use a reversing tool like Ghidra.
Although the file is stripped:
$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>We are given a 32-bit binary called vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item></channel></rss>