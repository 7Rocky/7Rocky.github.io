<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on 7Rocky</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>aes</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</guid><description>We are given this output:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" It is an output from Python REPL. It takes a random password from rockyou.txt and uses it as the key to encrypt the flag with AES ECB.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</guid><description>We are given a website to analyze. The index file shows the server source code:
#!/usr/bin/env python3 fromflaskimportFlask, render_template_string, request, Response app=Flask(__name__) @app.route('/') defindex(): returnResponse(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') defssti(): query=request.args['query'] iflen(query) &amp;gt;2: return"Too long!" returnrender_template_string(query) app.run('0.0.0.0', 3002, debug=True) It is a website built with Flask, in Python. One interesting thing is that debug mode is enabled.
The challenge talks about SSTI (Server-Side Template Injection), but we can only enter a 2-byte payload.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</guid><description>We are asked to compute -arcsin(-1) * 0.2 (in radians) and take the digits between positions 10000 and 10099 of the decimal part of the result.
First of all, let&amp;rsquo;s do the math:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$
Notice that the inverse sine function is bounded: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Therefore:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$</description></item><item><title>basic</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</guid><description>We are asked to represent 51 in base 12. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 So the flag is ictf{43}.</description></item><item><title>Box</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/box/</guid><description>We are given this Python source code that encrypts the flag:
fromCrypto.Util.numberimportbytes_to_long flag=open("flag.txt", "rb").read().strip() TABLE=[ lambdaa, b: f"({a}+{b})", lambdaa, b: f"({a}-{b})", lambdaa, b: f"({a}*{b})", ] defbuild_box(s: bytes): e="(x)" forbins: e=TABLE[b%len(TABLE)](e, b) returneval(f"lambda x: {e}") box=build_box(flag) ct=box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 """ It is a strange way to encrypt a message. Basically, box is a set of operations that contain a single x, and then calling box with a given value means to substitute that value inside x and get the final result.</description></item><item><title>cos1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 6 decimal places. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 100 decimal places. For this, we can use Wolfram Alpha:
And the flag is:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Enormous</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* m=bytes_to_long(open('flag.txt', 'rb').read()) n=1 foriinrange(5): n*=getPrime(2025) e=31 c=pow(m, e, n) print(f'{n= }') print(f'{c= }') And we have the ciphertext $c$ and the modulus $n$ of the RSA implementation. Notice that $e = 31$ is very small and $n$ is very large. Hence, we will be able to perform a 31-root to recover the plaintext $m$, because</description></item><item><title>Fasting</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</guid><description>We are given a host puzzler7.imaginaryctf.org:5005. If we send a GET request using curl, we have this response:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Using ffuf, we discover endpoints docs and redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Both of them are supposed to document API endpoints for people who want to consume the API:</description></item><item><title>Login Please</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</guid><description>We are supposed to log in here: http://puzzler7.imaginaryctf.org:5001/:
If we inspect the HTML code, we will see a comment that points to /source:
So we have the source code used by the server:
constexpress=require('express') constcrypto=require('crypto') functionmd5(text) { returncrypto.createHash('md5').update(text).digest('hex') } constapp=express() constusers={ guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } constlocalIPs=['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false})) app.use(express.json()) app.get('/', (req, res) =&amp;gt;{ res.send(` &amp;lt;form action="https://7rocky.github.io/login" method="POST"&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="username"&amp;gt;Username: &amp;lt;/label&amp;gt; &amp;lt;input name="username" type="text" id="</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</guid><description>We have a ZIP file called flag.zip that contains a JPEG image and also a .DS_Store file, which is a temporary file for macOS machines:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>mixup</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</guid><description>We are given a flag.txt file that contains some Unicode characters. This is the hexdump of the file:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</guid><description>We are given a 64-bit binary called notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
voidmain() { setbuf(stdout, (char*) 0x0); do{ notepad(); } while(true); } Basically, it runs notepad infinitely:
voidnotepad() { longin_FS_OFFSET; charoption; inti; undefined notes[136]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); for(i =0; i &amp;lt;128; i =i +1) { notes[i] =0; } puts("</description></item><item><title>Personalized</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* fromrandomimportseed, getrandbits m=bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name=open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e=2*getrandbits(32)+1 p=getPrime(512) q=getPrime(512) n=p*q c=pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) foriinname)}!") print(f'{n= }') print(f'{e= }') print(f'{c= }') It uses a RSA implementation where we can provide a name that will be used as the seed for a Pseudo-Random Number Generator (PRNG). And then the public exponent $e$ is computed as 2 * getrandbits(32) + 1.</description></item><item><title>Pickle</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</guid><description>We are given a file called out.pickle. The flag is stored inside, we can visualize its contents in hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>pqqp</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</guid><description>We are given this Python source code that encrypts the flag:
fromCrypto.Util.numberimport* p=getPrime(1024) q=getPrime(1024) n=p*q e=65537 m=bytes_to_long(open("flag.txt", "rb").read().strip()) c=pow(m, e, n) pqqp=(pow(p, q, n) +pow(q, p, n)) %n print(f"{n= }") print(f"{e= }") print(f"{c= }") print(f"{pqqp= }") And we have the output.txt file:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 First of all, we need to express $p^q + q^p \pmod{n}$ in another way.</description></item><item><title>Reflection</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</guid><description>We are given a binary file called reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped If we open Ghidra and take a look at the decompiled C source code, we will see the main function:
undefined8 main() { longj; char*__format; byte flag_input[100]; intk; int_j; int_length; inti; intlength; printf("&amp;gt;&amp;gt;&amp;gt; "); fgets((char*) flag_input, 100, stdin); _length =0; _j =0; k =0; while(true) { length =_length; i =_j; j =(long)_j; _j =_j +1; if((flag[j] ^flag_input[i]) !</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* p=getPrime(512) q=getPrime(512) n=p * q phi=(p - 1) * (q - 1) d=getPrime(32) e=pow(d, -1, phi) m=bytes_to_long(open('flag.txt', 'rb').read()) c=pow(m, e, n) print(f'{n= }') print(f'{e= }') print(f'{c= }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' The encryption type is RSA, but the implementation is wrong. The issue is that the private number $d$ is relatively small (a 32-bit prime number).</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>We are given the source code of a server that runs a Digital Signature Algorithm (DSA):
fromCrypto.Util.numberimportgetPrime, isPrime, inverse fromhashlibimportsha256 fromrandomimportrandrange q, g=0, 2 whilenotisPrime(p:=2*q+1) orpow(g, q, p) !=1: q=getPrime(256) x=randrange(2, q) y=pow(g, x, p) defH(m): returnint.from_bytes(sha256(m).digest(), 'big') defsign(m): k=randrange(2, q) r=pow(g, k, p) %q s=(H(m) +r*x) *inverse(k, q) %q returnr, s defverify(m, r, s): u=inverse(s, q) returnpow(g, u*H(m), p) *pow(y, u*r, p) %p%q==r defmain(): print("Hello admin, here are the parameters!</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>We are given a host to connect to. It shows the source code used to encrypt the flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 fromCrypto.Util.numberimport* classRotator: QUEUE_LENGTH=10 def__init__(self): self.e=65537 self.m=bytes_to_long(open('flag.txt', 'rb').read()) self.queue=[getPrime(512) foriinrange(self.QUEUE_LENGTH)] defget_new_primes(self): ret=self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt;self.QUEUE_LENGTH): self.queue=[getPrime(512)] +self.queue returntuple(ret) defenc_flag(self): p, q=self.get_new_primes() n=p*q print(f"Public key: {(n, self.e)}") print(f"Your encrypted flag: {pow(self.m, self.e, n)}") rot=Rotator() print('='*80) print(open(__file__).read()) print('='*80) whileTrue: inp=input("Would you like an encrypted flag (y/n)? ") if'y'ininp.</description></item><item><title>same</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/same/</guid><description>We are given the source code in Python to encrypt the flag:
fromCrypto.Util.numberimportgetPrime, bytes_to_long m=bytes_to_long(open("flag", "rb").read()) n=getPrime(512)*getPrime(512) e=[1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) And we have the output of the program:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 The cryptosystem is RSA, but there&amp;rsquo;s a vulnerability. The flag ($m$) is being encrypted two times as
$$ c_1 = m ^ {e_1} \pmod{n} $$
$$ c_2 = m ^ {e_2} \pmod{n} $$
The problem here is that the same message is raised to a different power but using the same modulus $n$.</description></item><item><title>Shifted</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</guid><description>We are given this Python source code:
importstring importrandom flag=open("flag.txt").read().strip() mystery_num=random.randint(100,1000) new_alphabet=list(string.ascii_lowercase+string.digits+string.punctuation) enc_flag="" defshift(char): index=new_alphabet.index(char) new_index=(index+mystery_num) %len(new_alphabet) returnnew_alphabet[new_index] forcharinflag: enc_flag+=shift(char) mystery_num+=10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t What the script does is set an alphabet and a random number (mystery_num). Then, to encrypt the flag, it finds the index of the current plaintext character in the alphabet, adds it to the random number (modulo the length of the alphabet) and returns the character at that new index.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</guid><description>We are given a 64-bit binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
undefined8 main() { longin_FS_OFFSET; charlocal_118[264]; longlocal_10; local_10 =*(long*) (in_FS_OFFSET +0x28); setvbuf(stdout, (char*) 0x0, 2, 0); setvbuf(stdin, (char*) 0x0, 2, 0); puts("Send your string to be printed:"); fgets(local_118, 256, stdin); printf(local_118); puts("</description></item><item><title>XORed</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</guid><description>The program says that someone has used a XOR cipher with a single byte key. This is the output: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Since we know that flags start with ictf{, we can get the key using &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; because of XOR cipher properties:
$$ c = m \oplus k \iff k = c \oplus m $$
So we solve the challenge like this:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</guid><description>We are given this source code to encrypt the flag, and also the ciphertext as a comment in the code:
#!/usr/bin/env python3 flag=open('flag.txt', 'rb').read() key=open('/dev/urandom','rb').read(1)[0] out=[] forcinflag: out.append(c ^ key) key=c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' From the source code, we see that the key is a single byte. Moreover, the key is updated with the current plain text character.
Hence, we can use some Python scripting to solve the challenge:</description></item></channel></rss>