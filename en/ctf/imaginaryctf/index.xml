<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on 7Rocky</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Almost SSTI</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</guid><description>We are given a website to analyze. The index file shows the server source code:
#!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;flask&amp;nbsp;import&amp;nbsp;Flask,&amp;nbsp;render_template_string,&amp;nbsp;request,&amp;nbsp;Response app&amp;nbsp;=&amp;nbsp;Flask(__name__) @app.route('/') def&amp;nbsp;index(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;Response(open(__file__).read(),&amp;nbsp;mimetype='text/plain') @app.route('/ssti') def&amp;nbsp;ssti(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;query&amp;nbsp;=&amp;nbsp;request.args['query'] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;len(query)&amp;nbsp;&amp;gt;&amp;nbsp;2: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"Too&amp;nbsp;long!" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;render_template_string(query) app.run('0.0.0.0',&amp;nbsp;3002,&amp;nbsp;debug=True) It is a website built with Flask, in Python. One interesting thing is that debug mode is enabled.
The challenge talks about SSTI (Server-Side Template Injection), but we can only enter a 2-byte payload. This length makes it impossible to exploit an SSTI.</description></item><item><title>basic</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</guid><description>We are asked to represent 51 in base 12. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 So the flag is ictf{43}.</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</guid><description>We have a ZIP file called flag.zip that contains a JPEG image and also a .DS_Store file, which is a temporary file for macOS machines:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</guid><description>We are given a 64-bit binary called notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
void&amp;nbsp;main()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;setbuf(stdout,&amp;nbsp;(char&amp;nbsp;*)&amp;nbsp;0x0); &amp;nbsp;&amp;nbsp;do&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notepad(); &amp;nbsp;&amp;nbsp;}&amp;nbsp;while&amp;nbsp;(true); } Basically, it runs notepad infinitely:
void&amp;nbsp;notepad()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;long&amp;nbsp;in_FS_OFFSET; &amp;nbsp;&amp;nbsp;char&amp;nbsp;option; &amp;nbsp;&amp;nbsp;int&amp;nbsp;i; &amp;nbsp;&amp;nbsp;undefined&amp;nbsp;notes[136]; &amp;nbsp;&amp;nbsp;long&amp;nbsp;canary; &amp;nbsp;&amp;nbsp;canary&amp;nbsp;=&amp;nbsp;*(long&amp;nbsp;*)&amp;nbsp;(in_FS_OFFSET&amp;nbsp;+&amp;nbsp;0x28); &amp;nbsp;&amp;nbsp;for&amp;nbsp;(i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&amp;lt;&amp;nbsp;128;&amp;nbsp;i&amp;nbsp;=&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notes[i]&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;puts("Welcome&amp;nbsp;to&amp;nbsp;Notepad&amp;nbsp;as&amp;nbsp;a&amp;nbsp;Service!"); &amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("Menu:"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("1)&amp;nbsp;View&amp;nbsp;note"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("2)&amp;nbsp;Edit&amp;nbsp;note"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("3)&amp;nbsp;Quit&amp;nbsp;and&amp;nbsp;make&amp;nbsp;new&amp;nbsp;note\n"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf("</description></item><item><title>Pickle</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</guid><description>We are given a file called out.pickle. The flag is stored inside, we can visualize its contents in hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>Reflection</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</guid><description>We are given a binary file called reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped If we open Ghidra and take a look at the decompiled C source code, we will see the main function:
undefined8&amp;nbsp;main()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;long&amp;nbsp;j; &amp;nbsp;&amp;nbsp;char&amp;nbsp;*__format; &amp;nbsp;&amp;nbsp;byte&amp;nbsp;flag_input[100]; &amp;nbsp;&amp;nbsp;int&amp;nbsp;k; &amp;nbsp;&amp;nbsp;int&amp;nbsp;_j; &amp;nbsp;&amp;nbsp;int&amp;nbsp;_length; &amp;nbsp;&amp;nbsp;int&amp;nbsp;i; &amp;nbsp;&amp;nbsp;int&amp;nbsp;length; &amp;nbsp;&amp;nbsp;printf("&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;"); &amp;nbsp;&amp;nbsp;fgets((char&amp;nbsp;*)&amp;nbsp;flag_input,&amp;nbsp;100,&amp;nbsp;stdin); &amp;nbsp;&amp;nbsp;_length&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;_j&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;k&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;length&amp;nbsp;=&amp;nbsp;_length; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;i&amp;nbsp;=&amp;nbsp;_j; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;j&amp;nbsp;=&amp;nbsp;(long)_j; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_j&amp;nbsp;=&amp;nbsp;_j&amp;nbsp;+&amp;nbsp;1; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;((flag[j]&amp;nbsp;^&amp;nbsp;flag_input[i])&amp;nbsp;!</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;Crypto.Util.number&amp;nbsp;import&amp;nbsp;* p&amp;nbsp;=&amp;nbsp;getPrime(512) q&amp;nbsp;=&amp;nbsp;getPrime(512) n&amp;nbsp;=&amp;nbsp;p * q phi&amp;nbsp;=&amp;nbsp;(p - 1) * (q - 1) d&amp;nbsp;=&amp;nbsp;getPrime(32) e&amp;nbsp;=&amp;nbsp;pow(d,&amp;nbsp;-1,&amp;nbsp;phi) m&amp;nbsp;=&amp;nbsp;bytes_to_long(open('flag.txt',&amp;nbsp;'rb').read()) c&amp;nbsp;=&amp;nbsp;pow(m,&amp;nbsp;e,&amp;nbsp;n) print(f'{n&amp;nbsp;=&amp;nbsp;}') print(f'{e&amp;nbsp;=&amp;nbsp;}') print(f'{c&amp;nbsp;=&amp;nbsp;}') ''' n&amp;nbsp;=&amp;nbsp;134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e&amp;nbsp;=&amp;nbsp;50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c&amp;nbsp;=&amp;nbsp;133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' The encryption type is RSA, but the implementation is wrong. The issue is that the private number $d$ is relatively small (a 32-bit prime number). Hence, we can break the encryption with Wiener&amp;rsquo;s attack.</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>We are given a host to connect to. It shows the source code used to encrypt the flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;Crypto.Util.number&amp;nbsp;import&amp;nbsp;* class&amp;nbsp;Rotator: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;QUEUE_LENGTH&amp;nbsp;=&amp;nbsp;10 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;__init__(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.e&amp;nbsp;=&amp;nbsp;65537 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.m&amp;nbsp;=&amp;nbsp;bytes_to_long(open('flag.txt',&amp;nbsp;'rb').read()) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue&amp;nbsp;=&amp;nbsp;[getPrime(512)&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;range(self.QUEUE_LENGTH)] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;get_new_primes(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ret&amp;nbsp;=&amp;nbsp;self.queue[-2:] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue.pop() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while(len(self.queue)&amp;nbsp;&amp;lt;&amp;nbsp;self.QUEUE_LENGTH): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue&amp;nbsp;=&amp;nbsp;[getPrime(512)]&amp;nbsp;+&amp;nbsp;self.queue &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;tuple(ret) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;enc_flag(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p,&amp;nbsp;q&amp;nbsp;=&amp;nbsp;self.get_new_primes() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n&amp;nbsp;=&amp;nbsp;p*q &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print(f"Public&amp;nbsp;key:&amp;nbsp;{(n,&amp;nbsp;self.e)}") &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print(f"Your&amp;nbsp;encrypted&amp;nbsp;flag:&amp;nbsp;{pow(self.m,&amp;nbsp;self.e,&amp;nbsp;n)}") rot&amp;nbsp;=&amp;nbsp;Rotator() print('='*80) print(open(__file__).read()) print('='*80) while&amp;nbsp;True: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inp&amp;nbsp;=&amp;nbsp;input("Would&amp;nbsp;you&amp;nbsp;like&amp;nbsp;an&amp;nbsp;encrypted&amp;nbsp;flag&amp;nbsp;(y/n)?&amp;nbsp;") &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;'y'&amp;nbsp;in&amp;nbsp;inp.lower(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rot.enc_flag() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break ================================================================================ Would you like an encrypted flag (y/n)? ^C The encryption type is RSA, but the implementation is wrong.</description></item><item><title>xorrot</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</guid><description>We are given this source code to encrypt the flag, and also the ciphertext as a comment in the code:
#!/usr/bin/env&amp;nbsp;python3 flag&amp;nbsp;=&amp;nbsp;open('flag.txt',&amp;nbsp;'rb').read() key&amp;nbsp;=&amp;nbsp;open('/dev/urandom','rb').read(1)[0] out&amp;nbsp;=&amp;nbsp;[] for&amp;nbsp;c&amp;nbsp;in&amp;nbsp;flag: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.append(c ^ key) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key&amp;nbsp;=&amp;nbsp;c print(f'{bytes(out).hex()&amp;nbsp;=&amp;nbsp;}') #&amp;nbsp;bytes(out).hex()&amp;nbsp;=&amp;nbsp;'970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' From the source code, we see that the key is a single byte. Moreover, the key is updated with the current plain text character.
Hence, we can use some Python scripting to solve the challenge:
#!/usr/bin/env&amp;nbsp;python3 def&amp;nbsp;main(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ct&amp;nbsp;=&amp;nbsp;bytes.fromhex('970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311') &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key&amp;nbsp;=&amp;nbsp;ord('i')&amp;nbsp;^&amp;nbsp;ct[0] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;flag&amp;nbsp;=&amp;nbsp;b'' &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;b&amp;nbsp;in&amp;nbsp;ct: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;flag&amp;nbsp;+=&amp;nbsp;bytes([b&amp;nbsp;^&amp;nbsp;key]) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key&amp;nbsp;=&amp;nbsp;flag[-1] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print(flag.</description></item></channel></rss>