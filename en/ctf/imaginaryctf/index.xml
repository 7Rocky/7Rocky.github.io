<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>A Puzzle in Seven Parts</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/a-puzzle-in-seven-parts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/a-puzzle-in-seven-parts/</guid><description>We are given this string:
AbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDEFGaBCdefgAbCDeFGABCdeFGAbCDeFGABCdefgaBCdeFGAbCDeFGABCdefgABCDEFGAbCDeFGAbCDeFGAbCDeFGABCDEFGAbCDEFGaBCdeFGaBCdeFGAbcDEFGAbCDeFGAbCDEFGAbCDeFGABCdefgAbCDeFGABcDEfGABCdefgaBCdefgAbCDeFGAbCDeFGABCDefGABCDEFgAbCDeFGABCdEFGAbCDEFGaBCdefgAbCDEFGABCDefGAbCDEFGAbcDEFgAbCDeFGAbCDeFGABCdefgABCdefgAbCDEFGaBCdefgaBCdeFGAbCDeFGaBCdeFGAbcDEFGAbCDEFGABCdEFGAbCDeFGABcDEfGAbCDEFGAbcDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDeFGAbCDeFGAbCDeFGABCdefgABCDefGAbCDeFGAbCDEFGabCDEFGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGABCDEFGAbCDeFGABCdefgaBCdeFGaBCDEfGAbCDeFGAbCDEFGaBCdeFGABCdEFGAbCDeFGABCDEFGAbCDeFGABCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCdEFGAbCDEFGaBCdeFGABCDefGABcDEfGaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGABCdefgAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDeFGABCDefGaBCdeFGaBCDEfGABCDefGABCDEFgaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGAbCDeFGaBCdeFGABCdefgaBCdeFGAbcDEFGAbCDeFGABCDEFGAbCDeFGABCDefGAbCDEFGabCDEFGAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgAbCDEFGABCDEFGAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbcDEFgAbCDeFGABcDEfGAbCDeFGABCdefgAbCDeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGaBCdeFGAbCDeFGABCDEFGAbCDEFGABCDefGaBCdeFGAbCDeFGAbCDEFGaBCdeFGAbCDEFGabCDEFGaBCdeFGaBCDEfGAbCDeFGAbCDEFGAbCDEFGAbcDEFgABCDefGABCDefGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgABCDefGAbCDeFGABCdeFGAbCDeFGAbCDEFGaBCdeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgaBCdeFGaBCDEfGABCDefGaBCdefgAbCDeFGaBCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDEFGabCDEFGAbCDeFGABCdefgAbCDeFGABCdefgaBCdeFGAbcDEFGaBCdeFGAbCDEFGAbCDeFGABCdefgAbCDEFGabCDEFGABCDefGABCdeFGAbCDeFGABCdefgaBCdeFGaBCDEfGaBCdeFGAbCDEFGABCdefgABCDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDEFGabCDEFGAbCDEFGABCDefGABCDefGaBCdefgAbCDeFGAbCDeFGABCDefGaBCdefgAbCDeFGABCdeFGABCdefgABCdeFGAbCDeFGABCDefGAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDEFGABCdEFGAbCDeFGABCDefGaBCdeFGAbCDeFGABCdefgABCDEFgAbCDeFGABCdefgAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDeFGABCdEFGAbCDEFGaBCdefgaBCdeFGaBCDEfGABCDefGaBCdefgABCdefgABCDEFgaBCdeFGAbCDeFGAbCDeFGABcDEfGAbCDEFGAbcDEFGAbCDEFGaBCdeFGAbCDeFGaBCdeFGAbCDeFGABcDEfGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDeFGABCdEFGAbCDeFGAbCDEFGaBCdeFGABCdefgABCDefGaBCdefgAbCDEFGAbcdEFGAbCDeFGAbCDeFGABCDefGABCDEFgABCDefGaBCdefgaBCdeFGABCdeFGAbCDeFGaBCdefgAbCDEFGabCDEFGABCdefgaBCdeFGAbCDeFGABCdefgAbCDeFGABcDEfGAbCDEFGAbcDEFgAbCDeFGABCdEFGAbCDeFGABCDefGAbCDeFGABCdEFGaBCdeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCDefGAbCDeFGAbCDeFGAbCDEFGAbcDEFgaBCdeFGABcDEfGAbCDeFGAbCDeFGaBCdeFGaBCDEfGaBCdeFGaBCdeFGABCDefGABCDEFgABCDefGaBCDEfG Seven-segment display As the challenge suggests, the above string must be related to a seven-segment display:
For example, the first 7 letters are AbCDeFG, which form a 5 (uppercase letters are on and lowercase letters are off). Let&amp;rsquo;s use Python to split the whole string in chunks of 7 letters and remove lowercase letters:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import re &amp;gt;&amp;gt;&amp;gt; m = 'AbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDEFGaBCdefgAbCDeFGABCdeFGAbCDeFGABCdefgaBCdeFGAbCDeFGABCdefgABCDEFGAbCDeFGAbCDeFGAbCDeFGABCDEFGAbCDEFGaBCdeFGaBCdeFGAbcDEFGAbCDeFGAbCDEFGAbCDeFGABCdefgAbCDeFGABcDEfGABCdefgaBCdefgAbCDeFGAbCDeFGABCDefGABCDEFgAbCDeFGABCdEFGAbCDEFGaBCdefgAbCDEFGABCDefGAbCDEFGAbcDEFgAbCDeFGAbCDeFGABCdefgABCdefgAbCDEFGaBCdefgaBCdeFGAbCDeFGaBCdeFGAbcDEFGAbCDEFGABCdEFGAbCDeFGABcDEfGAbCDEFGAbcDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDeFGAbCDeFGAbCDeFGABCdefgABCDefGAbCDeFGAbCDEFGabCDEFGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGABCDEFGAbCDeFGABCdefgaBCdeFGaBCDEfGAbCDeFGAbCDEFGaBCdeFGABCdEFGAbCDeFGABCDEFGAbCDeFGABCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCdEFGAbCDEFGaBCdeFGABCDefGABcDEfGaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGABCdefgAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDeFGABCDefGaBCdeFGaBCDEfGABCDefGABCDEFgaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGAbCDeFGaBCdeFGABCdefgaBCdeFGAbcDEFGAbCDeFGABCDEFGAbCDeFGABCDefGAbCDEFGabCDEFGAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgAbCDEFGABCDEFGAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbcDEFgAbCDeFGABcDEfGAbCDeFGABCdefgAbCDeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGaBCdeFGAbCDeFGABCDEFGAbCDEFGABCDefGaBCdeFGAbCDeFGAbCDEFGaBCdeFGAbCDEFGabCDEFGaBCdeFGaBCDEfGAbCDeFGAbCDEFGAbCDEFGAbcDEFgABCDefGABCDefGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgABCDefGAbCDeFGABCdeFGAbCDeFGAbCDEFGaBCdeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgaBCdeFGaBCDEfGABCDefGaBCdefgAbCDeFGaBCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDEFGabCDEFGAbCDeFGABCdefgAbCDeFGABCdefgaBCdeFGAbcDEFGaBCdeFGAbCDEFGAbCDeFGABCdefgAbCDEFGabCDEFGABCDefGABCdeFGAbCDeFGABCdefgaBCdeFGaBCDEfGaBCdeFGAbCDEFGABCdefgABCDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDEFGabCDEFGAbCDEFGABCDefGABCDefGaBCdefgAbCDeFGAbCDeFGABCDefGaBCdefgAbCDeFGABCdeFGABCdefgABCdeFGAbCDeFGABCDefGAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDEFGABCdEFGAbCDeFGABCDefGaBCdeFGAbCDeFGABCdefgABCDEFgAbCDeFGABCdefgAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDeFGABCdEFGAbCDEFGaBCdefgaBCdeFGaBCDEfGABCDefGaBCdefgABCdefgABCDEFgaBCdeFGAbCDeFGAbCDeFGABcDEfGAbCDEFGAbcDEFGAbCDEFGaBCdeFGAbCDeFGaBCdeFGAbCDeFGABcDEfGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDeFGABCdEFGAbCDeFGAbCDEFGaBCdeFGABCdefgABCDefGaBCdefgAbCDEFGAbcdEFGAbCDeFGAbCDeFGABCDefGABCDEFgABCDefGaBCdefgaBCdeFGABCdeFGAbCDeFGaBCdefgAbCDEFGabCDEFGABCdefgaBCdeFGAbCDeFGABCdefgAbCDeFGABcDEfGAbCDEFGAbcDEFgAbCDeFGABCdEFGAbCDeFGABCDefGAbCDeFGABCdEFGaBCdeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCDefGAbCDeFGAbCDeFGAbCDEFGAbcDEFgaBCdeFGABcDEfGAbCDeFGAbCDeFGaBCdeFGaBCDEfGaBCdeFGaBCdeFGABCDefGABCDEFgABCDefGaBCDEfG' &amp;gt;&amp;gt;&amp;gt; ms = [m[i : i + 7] for i in range(0, len(m), 7)] &amp;gt;&amp;gt;&amp;gt; ms = [re.</description></item><item><title>A Very Good Place to Start</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/a-very-good-place-to-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/a-very-good-place-to-start/</guid><description>We are given a 64-bit binary called start:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Reverse engineering If we use Ghidra to extract the decompiled C source code, we see the main function:
int main() { int ret; char name[64]; FILE *fp; uint i; setbuf(stdout, NULL); setbuf(stdin, NULL); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What\'s your name? "); fgets(name, 128, stdin); i = 0; do { if (63 &amp;lt; i) { LAB_00401240: ret = strcmp("</description></item><item><title>AAAA</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/aaaa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/aaaa/</guid><description>We are given this domain: number6challenge.imaginaryctf.org.
DNS enumeration Since the challenge is called &amp;ldquo;AAAA&amp;rdquo;, we can think of the AAAA record in DNS (more information here). To check it, we can use dig:
$ dig number6challenge.imaginaryctf.org AAAA ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; number6challenge.imaginaryctf.org AAAA ;; global options: +cmd ;; Got answer: ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 14021 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;number6challenge.</description></item><item><title>aes</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/aes/</guid><description>We are given this output:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" It is an output from Python REPL. It takes a random password from rockyou.txt and uses it as the key to encrypt the flag with AES ECB.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/almost-ssti/</guid><description>We are given a website to analyze. The index file shows the server source code:
#!/usr/bin/env python3 from flask import Flask, render_template_string, request, Response app = Flask(__name__) @app.route('/') def index(): return Response(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') def ssti(): query = request.args['query'] if len(query) &amp;gt; 2: return "Too long!" return render_template_string(query) app.run('0.0.0.0', 3002, debug=True) It is a website built with Flask, in Python. One interesting thing is that debug mode is enabled.
The challenge talks about SSTI (Server-Side Template Injection), but we can only enter a 2-byte payload.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/arcsin1/</guid><description>We are asked to compute -arcsin(-1) * 0.2 (in radians) and take the digits between positions 10000 and 10099 of the decimal part of the result.
First of all, let&amp;rsquo;s do the math:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$ Notice that the inverse sine function is bounded: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Therefore:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$ So we are asked for the 10000th-10099th digits of $\pi$.</description></item><item><title>base64</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/base64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/base64/</guid><description>We are given this string:
aWN0ZntfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX30= It looks like Base64-encoded data&amp;hellip; And the challenge is called &amp;ldquo;base64&amp;rdquo;, so everything is clear.
Flag This is the flag:
$ echo aWN0ZntfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX30= | base64 -d ictf{___________________________________}</description></item><item><title>basic</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/basic/</guid><description>We are asked to represent 51 in base 12. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) -> int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 So the flag is ictf{43}.</description></item><item><title>Box</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/box/</guid><description>We are given this Python source code that encrypts the flag:
from Crypto.Util.number import bytes_to_long flag = open("flag.txt", "rb").read().strip() TABLE = [ lambda a, b: f"({a}+{b})", lambda a, b: f"({a}-{b})", lambda a, b: f"({a}*{b})", ] def build_box(s: bytes): e = "(x)" for b in s: e = TABLE[b % len(TABLE)](e, b) return eval(f"lambda x: {e}") box = build_box(flag) ct = box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 """ It is a strange way to encrypt a message.</description></item><item><title>cos1</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos1/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 6 decimal places. This is simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/cos2/</guid><description>We are asked to compute the cosine of 42 radians, rounded to 100 decimal places. For this, we can use Wolfram Alpha:
And the flag is:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Easy DSA: Elated once</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-elated-once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-elated-once/</guid><description>We are given the Python source code used to encrypt the flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def H(msg): return int.from_bytes(sha256(msg).digest(), 'big') def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y def gen_nonces(): a = randrange(2, q) b = randrange(2, q) k = 0 while 1: k = (a*k + b) % q yield k def sign(m): k = next(nonces) r = pow(g, k, p) % q s = (H(m) + x*r) * pow(k, -1, q) % q return r, s def verify(m, r, s): assert 0 &amp;lt; r &amp;lt; q and 0 &amp;lt; s &amp;lt; q u = pow(s, -1, q) v = pow(g, H(m) * u, p) * pow(y, r * u, p) % p % q return v == r flag = b"</description></item><item><title>Easy DSA: Lovely Little Lane</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-lovely-little-lane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-lovely-little-lane/</guid><description>We are given the Python source code used to encrypt the flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y def H(msg): return int.</description></item><item><title>Easy DSA: The beginning</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-the-beginning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/easy-dsa-the-beginning/</guid><description>We are given the Python source code used to encrypt the flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p k = randrange(2, q) x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y, k def H(msg): return int.</description></item><item><title>Enormous</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/enourmous/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 from Crypto.Util.number import * m = bytes_to_long(open('flag.txt', 'rb').read()) n = 1 for i in range(5): n *= getPrime(2025) e = 31 c = pow(m, e, n) print(f'{n = }') print(f'{c = }') And we have the ciphertext $c$ and the modulus $n$ of the RSA implementation. Notice that $e = 31$ is very small and $n$ is very large.</description></item><item><title>Fasting</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/fasting/</guid><description>We are given a host puzzler7.imaginaryctf.org:5005. If we send a GET request using curl, we have this response:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Using ffuf, we discover endpoints docs and redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Both of them are supposed to document API endpoints for people who want to consume the API:</description></item><item><title>Fleeting</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/fleeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/fleeting/</guid><description>We are given this short Python code to encrypt the flag, and also the ciphertext as a comment:
print((f:=lambda s:s and[s[0]^s[-1],*f(s[::-1][1:])])([*open('flag','rb')][0])) #[20, 37, 47, 47, 56, 52, 38, 46, 51, 56, 23, 58, 57, 50, 86, 95, 95, 103, 0] Source code analysis If we analyze the code, we will see that it is defining a lambda function named f and calling it with the contents of the flag in bytes:</description></item><item><title>Highlighter</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/highlighter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/highlighter/</guid><description>We are given a binary called highlighter:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra, we will see the decompiled source code of the main function:
int main() { int __fd; long in_FS_OFFSET; undefined8 *where; undefined8 what; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setbuf(stdin, (char *) 0x0); setbuf(stdout, (char *) 0x0); __fd = open("flag.txt", 0); read(__fd, flag, 100); puts("</description></item><item><title>Highlights</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/highlights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/highlights/</guid><description>We are given a binary called highlights:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra, we will see the decompiled source code of the main function:
int main() { undefined8 *address; FILE *fp; setbuf(stdout, (char *) 0x0); setbuf(stdin, (char *) 0x0); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What address (in hex) would you like to read?\n&amp;gt;&amp;gt;&amp;gt; "); __isoc99_scanf("</description></item><item><title>Instructive</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/instructive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/instructive/</guid><description>We are given a 64-bit binary called instructive:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Reverse engineering If load the binary in Ghidra, we will see this main function:
int main() { int ret; undefined flag[136]; char *data; FILE *fp; int j; int i; setbuf(stdout, NULL); setbuf(stdin, NULL); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); data = (char *) malloc(128); printf("Please enter your username: "</description></item><item><title>Login Please</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/login-please/</guid><description>We are supposed to log in here: http://puzzler7.imaginaryctf.org:5001/:
If we inspect the HTML code, we will see a comment that points to /source:
So we have the source code used by the server:
const express = require('express') const crypto = require('crypto') function md5(text) { return crypto.createHash('md5').update(text).digest('hex') } const app = express() const users = { guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } const localIPs = ['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false })) app.</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/lost-flag/</guid><description>We have a ZIP file called flag.zip that contains a JPEG image and also a .DS_Store file, which is a temporary file for macOS machines:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>mixup</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/mixup/</guid><description>We are given a flag.txt file that contains some Unicode characters. This is the hexdump of the file:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/notepad-as-a-service/</guid><description>We are given a 64-bit binary called notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
void main() { setbuf(stdout, (char *) 0x0); do { notepad(); } while (true); } Basically, it runs notepad infinitely:
void notepad() { long in_FS_OFFSET; char option; int i; undefined notes[136]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); for (i = 0; i &amp;lt; 128; i = i + 1) { notes[i] = 0; } puts("</description></item><item><title>Personalized</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/personalized/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 from Crypto.Util.number import * from random import seed, getrandbits m = bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name = open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e = 2*getrandbits(32)+1 p = getPrime(512) q = getPrime(512) n = p*q c = pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) for i in name)}!") print(f'{n = }') print(f'{e = }') print(f'{c = }') It uses a RSA implementation where we can provide a name that will be used as the seed for a Pseudo-Random Number Generator (PRNG).</description></item><item><title>Pickle</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pickle/</guid><description>We are given a file called out.pickle. The flag is stored inside, we can visualize its contents in hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>pqqp</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/pqqp/</guid><description>We are given this Python source code that encrypts the flag:
from Crypto.Util.number import * p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 m = bytes_to_long(open("flag.txt", "rb").read().strip()) c = pow(m, e, n) pqqp = (pow(p, q, n) + pow(q, p, n)) % n print(f"{n = }") print(f"{e = }") print(f"{c = }") print(f"{pqqp = }") And we have the output.txt file:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 First of all, we need to express $p^q + q^p \pmod{n}$ in another way.</description></item><item><title>Rather Secure Attachment</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rather-secure-attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rather-secure-attachment/</guid><description>We are given the Python source code used to encrypt the flag:
from Crypto.Util.number import getPrime, bytes_to_long with open('flag.txt','rb') as f: m = bytes_to_long(f.read()) e = 0x10001 k = getPrime(4) l = getPrime(512) p = getPrime(512) q = getPrime(512) n = p*q c = pow(m, e, n) d = pow(2, k, n) f = pow(p, d, l) print(f"c = {c}") print(f"n = {n}") print(f"f = {f}") print(f"l = {l}") And the output of the above script:</description></item><item><title>Reflection</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/reflection/</guid><description>We are given a binary file called reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped If we open Ghidra and take a look at the decompiled C source code, we will see the main function:
undefined8 main() { long j; char *__format; byte flag_input[100]; int k; int _j; int _length; int i; int length; printf("</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/relatively-small-arguments/</guid><description>We are given the Python source code used to encrypt the flag:
#!/usr/bin/env python3 from Crypto.Util.number import * p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = getPrime(32) e = pow(d, -1, phi) m = bytes_to_long(open('flag.txt', 'rb').read()) c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' The encryption type is RSA, but the implementation is wrong.</description></item><item><title>Robotic</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/robotic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/robotic/</guid><description>We are given this website (https://eth007.me/):
Since the name of the challenge is &amp;ldquo;Robotic&amp;rdquo;, we might think about robots.txt, which is a file used by web crawlers to index pages of a website in search engines like Google. There we have the resource:
Flag If we follow that URL (which is marked as Disallow for web crawlers), we will see the flag:
$ curl https://eth007.me/10b20f3d29ba114a.txt ictf{truly_not_a_robot}</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>We are given the source code of a server that runs a Digital Signature Algorithm (DSA):
from Crypto.Util.number import getPrime, isPrime, inverse from hashlib import sha256 from random import randrange q, g = 0, 2 while not isPrime(p := 2 * q + 1) or pow(g, q, p) != 1: q = getPrime(256) x = randrange(2, q) y = pow(g, x, p) def H(m): return int.from_bytes(sha256(m).digest(), 'big') def sign(m): k = randrange(2, q) r = pow(g, k, p) % q s = (H(m) + r * x) * inverse(k, q) % q return r, s def verify(m, r, s): u = inverse(s, q) return pow(g, u * H(m), p) * pow(y, u * r, p) % p % q == r def main(): print("</description></item><item><title>Ron was wrong, Whit is right</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/ron-was-wrong-whit-is-right/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/ron-was-wrong-whit-is-right/</guid><description>We are given the source code used to encrypt the flag:
#!/usr/bin/env python from Crypto.Util import number flag = open("flag.txt", "rb").read() m = number.bytes_to_long(flag) e = 65537 for _ in range(1336): q = number.getPrime(1024) p = number.getPrime(1024) n = p * q c = pow(m, e, n) print(f"{n},{c}") We also have the output (1336 pairs of n and c).
RSA background Let&amp;rsquo;s review how RSA works: $n = p q$, where $p$ and $q$ are some large prime numbers.</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>We are given a host to connect to. It shows the source code used to encrypt the flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 from Crypto.Util.number import * class Rotator: QUEUE_LENGTH = 10 def __init__(self): self.e = 65537 self.m = bytes_to_long(open('flag.txt', 'rb').read()) self.queue = [getPrime(512) for i in range(self.QUEUE_LENGTH)] def get_new_primes(self): ret = self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt; self.QUEUE_LENGTH): self.queue = [getPrime(512)] + self.queue return tuple(ret) def enc_flag(self): p, q = self.</description></item><item><title>RSAgain</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/rsagain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/rsagain/</guid><description>We are given the source code used to encrypt the flag:
from Crypto.Util.number import getPrime from secrets import randbelow flag = b'ictf{???????????????}' m = int.from_bytes(flag, 'big') p, q = getPrime(1024), getPrime(1024) n = p*q e1 = 7*randbelow(n) e2 = 7*randbelow(n) c1 = pow(m, e1, n) c2 = pow(m, e2, n) print('n =', n) print('e =', [e1, e2]) print('c =', [c1, c2]) And the output of the above script:
n = 13761685901869725143768331354410331722080881206892978316226355274731948923788116922997132633408042821072846131527848521009073675634635614838798409359054501234184243307064644162477264359675732802892743867662331151938667918459410404673473173649215468906981810925676420598006739662864501852090661953622948938870414604397215114998121635153443376761422254645059647616441054621053792673427510353100668664861428374057353161172637671266095296358943110920490442118842860397633084527337550938542697953483620271948205306390349644786873542968679812523808277314879159441909502558166069319615649241027566862990490220961067181937669 e = [176102760168508342366248560703991436320546222245646770978202319048411166429566382514628949532380311738047680739422807353850798607282412088644610303686988373545251970947896120364153937039760741931013881201304685285276800581219089376477570281711773721947249912869605837122685995085027900352995492083277384406401003380587567849080200688516195340372450525399311095577291241729818923687928903049024986910768913495050369506538600090893434395973537955406795607398026050382337136405732255493959814072239958699297858559423614495730987219798816735202147878946461603285288373867465864345098892545645132818258947898456430424006, 3573981821831492277529738650073504616174769536804810418010981678130362702872320797121521713323943777400757776843305922735161754061510443680673867557929082126015295854646693109385804251924239205353662684744351670833911869748673257355076814511174326199099866635753979773946343291340766410907901834068770274767020404800822067211027120846913766665910218577234432145411130775944881987043775179494758158033064351482298980282644264138853891021708458121104223946012736356102642750591504966939159058542007824839461238347551623770276126868717421123099282388441377112476606520160468063905419246868567792524706613954405034280745] c = [2442003451487395252876121378320580564808335180996151717051522763081890537479875202133875395729806314814096885940653943728394923611282999540770370852775313679101585158491964936530361527619836260073209497935763771182203301056707656219921717552895243715201530990757549283670161276843945223662108755382731302991164300014685362347621843020642892430217171795396599343678165183180757721956247558358291103649246073117361482130651740512048690900488267309376415549379476398675385332885750364853460566103195169529710541031930399449866328356546569547859848315600711606485060302078139530732323306248727557394224647978798154455432, 5877775554635189664514035705193818872462952989637173497670868665060589927366277311749438728976759716021062894771294263103329901952516874052114135886783478914172913186895498679544398990747998647492211189869428581232686408690719184490347471496179923775491153260487724884204595180798615723157844735887389748026739587255981069056269993158062939424519078722321933831961667178045072850177889672933456786971303039062246151676207874781304093381264675070371899409850042467776910769703994219307749656616821280706978085046384421702389657326825914608919485710624515946600476275010829782060955742590243380095470169814313117059260] The encryption type is RSA, but the implementation is wrong because the message m is being encrypted two times with different public exponents (e[0] and e[1]) and the same public modulus n.</description></item><item><title>same</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/same/</guid><description>We are given the source code in Python to encrypt the flag:
from Crypto.Util.number import getPrime, bytes_to_long m = bytes_to_long(open("flag", "rb").read()) n = getPrime(512)*getPrime(512) e = [1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) And we have the output of the program:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 The cryptosystem is RSA, but there&amp;rsquo;s a vulnerability. The flag ($m$) is being encrypted two times as
$$ c_1 = m ^ {e_1} \pmod{n} $$ $$ c_2 = m ^ {e_2} \pmod{n} $$ The problem here is that the same message is raised to a different power but using the same modulus $n$.</description></item><item><title>Secure</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/secure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/secure/</guid><description>We are given this website (https://puzzler7.imaginaryctf.org:7002/):
Since the name of the challenge is &amp;ldquo;Secure&amp;rdquo; and the browser showed a warning telling that the certificate is self-signed, we must examine the certificate.
Flag For instance, we can use curl with verbose(-v) and insecure (-k) modes. And there&amp;rsquo;s the flag, in the certificate&amp;rsquo;s subject and issuer:
$ curl -vk https://puzzler7.imaginaryctf.org:7002/ * Trying 137.184.207.224:7002... * Connected to puzzler7.imaginaryctf.org (137.184.207.224) port 7002 (#0) * ALPN: offers h2 * ALPN: offers http/1.</description></item><item><title>Shifted</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/shifted/</guid><description>We are given this Python source code:
import string import random flag = open("flag.txt").read().strip() mystery_num = random.randint(100,1000) new_alphabet = list(string.ascii_lowercase + string.digits + string.punctuation) enc_flag = "" def shift(char): index = new_alphabet.index(char) new_index = (index + mystery_num) % len(new_alphabet) return new_alphabet[new_index] for char in flag: enc_flag += shift(char) mystery_num += 10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t What the script does is set an alphabet and a random number (mystery_num). Then, to encrypt the flag, it finds the index of the current plaintext character in the alphabet, adds it to the random number (modulo the length of the alphabet) and returns the character at that new index.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/show-me-what-you-got/</guid><description>We are given a 64-bit binary called vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) If we use Ghidra to extract the decompiled C source code, we see the main function:
undefined8 main() { long in_FS_OFFSET; char local_118[264]; long local_10; local_10 = *(long *) (in_FS_OFFSET + 0x28); setvbuf(stdout, (char *) 0x0, 2, 0); setvbuf(stdin, (char *) 0x0, 2, 0); puts("Send your string to be printed:"</description></item><item><title>Situated</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/situated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/situated/</guid><description>We are given this website (https://eth007.me/blog/about/):
Since the description of the challenge is
Can you see beyond what&amp;rsquo;s visible?
we might think inspecting the HTML source code of the website. And there we have a strange img source:
Flag And it is indeed the flag (in URL encoding, %7B is { and %7D is }):
$ curl -s https://eth007.me/blog/about/ | grep ictf &amp;lt;p&amp;gt;&amp;lt;img src="ictf%7Binsp3cting_my_site?_h0w??%7D" alt=""&amp;gt;&amp;lt;/p&amp;gt;</description></item><item><title>XORed</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xored/</guid><description>The program says that someone has used a XOR cipher with a single byte key. This is the output: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Since we know that flags start with ictf{, we can get the key using &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; because of XOR cipher properties:
$$ c = m \oplus k \iff k = c \oplus m $$ So we solve the challenge like this:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/imaginaryctf/xorrot/</guid><description>We are given this source code to encrypt the flag, and also the ciphertext as a comment in the code:
#!/usr/bin/env python3 flag = open('flag.txt', 'rb').read() key = open('/dev/urandom','rb').read(1)[0] out = [] for c in flag: out.append(c ^ key) key = c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' From the source code, we see that the key is a single byte. Moreover, the key is updated with the current plain text character.</description></item></channel></rss>