<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/</link><description>Recent content in Binary on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/ctflearn/binary/index.xml" rel="self" type="application/rss+xml"/><item><title>Blackbox</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/blackbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/blackbox/</guid><description>We are given a server to connect using SSH. There is a binary called blackbox that is SGID:
blackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission As it can be seen, we have no read permission, so we cannot transfer the file to our machine, or decompile it, or debug it.</description></item><item><title>Favorite Color</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/favorite-color/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/favorite-color/</guid><description>We are given a server to connect using SSH. There is a 32-bit binary called color that is SGID:
color@ubuntu-512mb-nyc3-01:~$ ls -l total 20 -r--r--r-- 1 root root 714 Sep 12 2017 Makefile -r-xr-sr-x 1 root color_pwn 7672 Sep 12 2017 color -r--r--r-- 1 root root 722 Sep 12 2017 color.c -r--r----- 1 root color_pwn 24 Sep 12 2017 flag.txt color@ubuntu-512mb-nyc3-01:~$ file color color: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>Lazy Game Challenge</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/lazy-game-challenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/lazy-game-challenge/</guid><description>We are given a service that consists of a betting system. We bet a certain amount of money and we need to guess a number between 1 and 10 in less than 10 attempts. For example:
$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of !</description></item><item><title>Poor Login</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/poor-login/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/poor-login/</guid><description>We are given a 64-bit binary called login:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled We also have the C source code:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int menu() { printf("*** WINBLOWS LOGIN *********\n" "1. Login into user.\n" "2. Sign out.\n" "3. Print flag.\n" "4. Lock user.\n" "5. Restore user.\n" "&amp;gt; "); int resp = 0; scanf("%d", &amp;amp;resp); while (getchar() != '\n'); return resp; } struct creds { void *padding; char name[32]; int admin; }; struct creds *curr; struct creds *save; char *fake_flag; int main() { char buff[64]; setbuf(stdout, NULL); setbuf(stdin, NULL); while (1) { switch (menu()) { case 1: // Login curr = malloc(sizeof(*curr)); printf("</description></item><item><title>RIP my bof</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/rip-my-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/rip-my-bof/</guid><description>We are given a 32-bit binary called server:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We also have the C source code. Basically, what the program does is call function gets, which is vulnerable to Buffer Overflow:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system("</description></item><item><title>Shell time!</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/shell-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/shell-time/</guid><description>This challenge is the continuation of RIP my bof. Check it our first if you have not done it yet.
Now, the flag is stored at /flag2.txt, so we must do something more than redirect the program execution to system(&amp;quot;cat /flag.txt&amp;quot;), as in RIP my bof.
The first thing I came up with was Ret2Libc. The idea is to obtain a shell by calling system inside Glibc with &amp;quot;/bin/sh&amp;quot; as argument.</description></item><item><title>Simple bof</title><link>https://7rocky.github.io/en/ctf/ctflearn/binary/simple-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/ctflearn/binary/simple-bof/</guid><description>We have the C source code of a binary and a remote instance to connect to. Basically, what the program does is call function gets, which is vulnerable to Buffer Overflow, and then compare a local variable with a certain value:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer.</description></item></channel></rss>