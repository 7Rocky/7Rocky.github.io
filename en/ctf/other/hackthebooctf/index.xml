<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HackTheBoo CTF on 7Rocky</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/</link><description>Recent content in HackTheBoo CTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/other/hackthebooctf/index.xml" rel="self" type="application/rss+xml"/><item><title>AHS512</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/ahs512/</guid><description>We got the Python source code of the server:
fromsecretimportFLAG fromhashlibimportsha512 importsocketserver importsignal fromrandomimportrandint WELCOME=""" **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** """ classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.</description></item><item><title>Cult Meeting</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/cult-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/cult-meeting/</guid><description>We are given a binary called meeting:
$ file meeting meeting: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=72d8b06e4ca750d5c24395d3349c3121b9b95283, for GNU/Linux 3.2.0, not stripped Reverse engineering Using Ghidra, we can read the decompiled source code in C. This is the main function:
intmain() { intret; char*pointer; charinput_data[64]; setvbuf(stdout, NULL, 2, 0); puts("\x1b[3mYou knock on the door and a panel slides back\x1b[0m"); puts(&amp;amp;DAT_00102040); fwrite("</description></item><item><title>EncodedPayload</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/encodedpayload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/encodedpayload/</guid><description>We are given a binary file called encodedpayload:
$ file encodedpayload encodedpayload: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, no section header Reverse engineering If we execute it, there&amp;rsquo;s nothing shown. Moreover, the binary is very short:
$ ./encodedpayload $ xxd encodedpayload 00000000: 7f45 4c46 0101 0100 0000 0000 0000 0000 .ELF............ 00000010: 0200 0300 0100 0000 5480 0408 3400 0000 ........T...4... 00000020: 0000 0000 0000 0000 3400 2000 0100 0000 .</description></item><item><title>Entity</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/entity/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we connect to the remote instance, we see this:
$ nc 134.122.106.203 30576 Something strange is coming out of the TV.. (T)ry to turn it off (R)un (C)ry &amp;gt;&amp;gt; Nothing really explanatory&amp;hellip;
Static code analysis This time, we are given the original C source code (chall.</description></item><item><title>Evaluation Deck</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/evaluation-deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/evaluation-deck/</guid><description>We are given this website:
However, the web UI is not that interesting&amp;hellip;
Static code analysis We also have the source code. The web application is built with Flask in Python. The following file is application/blueprints/routes.py:
fromflaskimportBlueprint, render_template, request fromapplication.utilimportresponse web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/get_health', methods=['POST']) defcount(): ifnotrequest.is_json: returnresponse('Invalid JSON!'), 400 data=request.get_json() current_health=data.get('current_health') attack_power=data.get('attack_power') operator=data.get('operator') ifnotcurrent_healthornotattack_powerornotoperator: returnresponse('All fields are required!'), 400 result={} try: code=compile(f'result = {int(current_health)}{operator}{int(attack_power)}', '&amp;lt;string&amp;gt;', 'exec') exec(code, result) returnresponse(result.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/fast-carmichael/</guid><description>We got the Python source code of the server:
fromsecretimportFLAG fromCrypto.Util.numberimportisPrime importsocketserver importsignal classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defgenerate_basis(n): basis=[True] *n foriinrange(3, int(n**0.5) +1, 2): ifbasis[i]: basis[i*i::2*i] =[False] *((n-i*i-1) //(2*i) +1) return[2] +[iforiinrange(3, n, 2) ifbasis[i]] defmillerRabin(n, b): basis=generate_basis(300) ifn==2orn==3: returnTrue ifn%2==0: returnFalse r, s=0, n-1 whiles%2==0: r+=1 s//=2 forbinbasis: x=pow(b, s, n) ifx==1orx==n-1: continue for_inrange(r-1): x=pow(x, 2, n) ifx==n-1: break else: returnFalse returnTrue def_isPrime(p): ifp&amp;lt;1: returnFalse if(p.</description></item><item><title>Ghost Wrangler</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/ghost-wrangler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/ghost-wrangler/</guid><description>We are given a binary file called ghost:
$ file ghost ghost: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=810d0f9271ec04d80a2eee6ff2afd9367da3c3dd, for GNU/Linux 3.2.0, not stripped Reverse engineering If we open the binary in Ghidra, we will see this decompiled main function in C:
intmain() { undefined8 flag; flag =get_flag(); printf("%s\r|\x1b[4m%*.c\x1b[24m| I\'ve managed to trap the flag ghost in this box, butit\'s turn ed invisible!</description></item><item><title>Gonna-Lift-Them-All</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/gonna-lift-them-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/gonna-lift-them-all/</guid><description>We got the Python source code used to encrypt the flag:
fromCrypto.Util.numberimportbytes_to_long, getPrime importrandom FLAG=b'HTB{??????????????????????????????????????????????????????????????????????}' defgen_params(): p=getPrime(1024) g=random.randint(2, p-2) x=random.randint(2, p-2) h=pow(g, x, p) return(p, g, h), x defencrypt(pubkey): p, g, h=pubkey m=bytes_to_long(FLAG) y=random.randint(2, p-2) s=pow(h, y, p) return(g*y%p, m*s%p) defmain(): pubkey, privkey=gen_params() c1, c2=encrypt(pubkey) withopen('data.txt', 'w') asf: f.write(f'p = {pubkey[0]}\ng = {pubkey[1]}\nh = {pubkey[2]}\n(c1, c2) = ({c1}, {c2})\n') if__name__=="__main__": main() We also have the output of the script:</description></item><item><title>Horror Feeds</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/horror-feeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/horror-feeds/</guid><description>We are given this website:
Static code analysis We are also given the Python source code of the web application, built in Flask. Since we are dealing with a login form, let&amp;rsquo;s take a look at the database interaction (application/database.py):
fromcoloramaimportCursor fromapplication.utilimportgenerate_password_hash, verify_hash, generate_token fromflask_mysqldb importMySQL mysql=MySQL() defquery_db(query, args=(), one=False): withopen('/tmp/log', 'a') asf: f.write(query+'\n') cursor=mysql.connection.cursor() cursor.execute(query, args) rv=[dict((cursor.description[idx][0], value) foridx, valueinenumerate(row)) forrowincursor.fetchall()] return(rv[0] ifrvelseNone) ifoneelserv deflogin(username, password): user=query_db('SELECT password FROM users WHERE username = %s', (username,), one=True) ifuser: password_check=verify_hash(password, user.</description></item><item><title>Juggling Facts</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/juggling-facts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/juggling-facts/</guid><description>We are given this website:
Static code analysis We also have the PHP source code of the web application. The relevant part is in controllers/IndexController.php:
&amp;lt;?php classIndexControllerextendsController { publicfunction__construct() { parent::__construct(); } publicfunctionindex($router) { $router-&amp;gt;view('index'); } publicfunctiongetfacts($router) { $jsondata =json_decode(file_get_contents('php://input'), true); if( empty($jsondata) ||!array_key_exists('type', $jsondata)) { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Insufficient parameters!']); } if($jsondata['type'] ==='secrets'&amp;amp;&amp;amp;$_SERVER['REMOTE_ADDR'] !=='127.0.0.1') { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Currently this type can be only accessed through localhost!']); } switch($jsondata['type']) { case'secrets': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('secrets') ]); case'spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('spooky') ]); case'not_spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('not_spooky') ]); default: return$router-&amp;gt;jsonify([ 'message'=&amp;gt;'Invalid type!</description></item><item><title>Pumpkin Stand</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/pumpkin-stand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/pumpkin-stand/</guid><description>We are given a 64-bit binary called pumpkin_stand:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Reverse engineering If we load the binary in Ghidra, we will see this decompiled C code for main:
voidmain() { longin_FS_OFFSET; shortoption; shortamount; FILE *fp; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); setup(); banner(); option =0; amount =0; while(true) { while(true) { while(true) { while(true) { menu(); __isoc99_scanf("</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/secured-transfer/</guid><description>We are given a binary file called securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped We also have a network capture file called trace.pcap.
Traffic analysis Starting with trace.pcap, we can use Wireshark to analyze the network capture file:
There is only one TCP segment that has data:
5f558867993dccc99879f7ca39c5e406972f84a3a9dd5d48972421ff375cb18c Reverse engineering We can use Ghidra to read the decompiled source code in C.</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/spooky-rsa/</guid><description>We got the Python source code used to encrypt the flag:
fromCrypto.Util.numberimportbytes_to_long, getStrongPrime fromrandomimportrandint FLAG=b'HTB{????????????????????????????????????????????}' defkey_gen(bits): p, q=getStrongPrime(bits), getStrongPrime(bits) N=p*q returnN, (p, q) defencrypt(m, N, f): e1, e2=randint(2, N-2), randint(2, N-2) c1=(pow(f, e1, N) +m) %N c2=(pow(f, e2, N) +m) %N return(e1, c1), (e2, c2) defmain(): N, priv=key_gen(1024) m=bytes_to_long(FLAG) (e1, c1), (e2, c2) =encrypt(m, N, priv[0]) withopen('out.txt', 'w') asf: f.write(f'N = {N}\n(e1, c1) = ({e1}, {c1})\n(e2, c2) = ({e2}, {c2})\n') if__name__=="</description></item><item><title>Trick or Breach</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/trick-or-breach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/trick-or-breach/</guid><description>We are given a network traffic capture file called capture.pcap.
Traffic analysis We can use Wireshark to analyze it:
DNS queries All packets are DNS queries (and responses). The thing that stands out is the subdomain: all queries ask for hex-data.pumpkincorp.com.
If we filter by the hexadecimal data on the capture.pcap, we will have this:
$ strings capture.pcap | grep -E '[0-9a-f]{32,}' | head 2504b0304140008080800a52c47550000000000000000000000 2504b0304140008080800a52c47550000000000000000000000 20018000000786c2f64726177696e67732f64726177696e6731 20018000000786c2f64726177696e67732f64726177696e6731 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f Notice that all lines start by 2, which is not part of the subdomain (check the previous image), so we need to get rid of it:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/whole-lotta-candy/</guid><description>We got the Python source code of the server:
fromencryptimportEncryptor fromsecretimportFLAG importsocketserver importrandom importsignal importjson MODES=['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defmain(s): mode=random.choice(MODES) enc=Encryptor() whileTrue: try: sendMessage(s, f"Please interact with the server using json data!\n") sendMessage(s, f"Selected mode is {mode}.\n") payload=receiveMessage( s, "\nOptions:\n\n1.Encrypt flag\n2.Encrypt plaintext\n3.Change mode\n4.Exit\n\n&amp;gt; " ) payload=json.loads(payload) option=payload["option"] ifoption=="1": ciphertext=enc.encrypt(FLAG, mode).hex() response=json.dumps({ "response": "encrypted", "</description></item><item><title>Wrong Spooky Season</title><link>https://7rocky.github.io/en/ctf/other/hackthebooctf/wrong-spooky-season/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hackthebooctf/wrong-spooky-season/</guid><description>We are given a network traffic capture file called capture.pcap.
Traffic analysis We can use Wireshark to analyse it:
HTTP messages There are a lot of packages. Let&amp;rsquo;s filter by HTTP first:
Alright, we have significanly less packages to analyze.
There are some HTTP messages that stand out at the end. We guess that a malicious user is executing remote system commands on the server (cmd=whoami, cmd=id &amp;hellip;). The last message is using socat to obtain a reverse shell connection, we can select this packet and remove the HTTP filter.</description></item></channel></rss>