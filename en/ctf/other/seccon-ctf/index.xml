<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SECCON CTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/seccon-ctf/</link><description>Recent content in SECCON CTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/seccon-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>plai_n_rsa</title><link>https://7rocky.github.io/en/ctf/other/seccon-ctf/plai_n_rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seccon-ctf/plai_n_rsa/</guid><description>We are given the Python source code to encrypt the flag:
import os from Crypto.Util.number import bytes_to_long, getPrime flag = os.getenvb(b"FLAG", b"SECCON{THIS_IS_FAKE}") assert flag.startswith(b"SECCON{") m = bytes_to_long(flag) e = 0x10001 p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 phi = (p-1)*(q-1) d = pow(e, -1, phi) hint = p+q c = pow(m,e,n) print(f"e={e}") print(f"d={d}") print(f"hint={hint}") print(f"c={c}") And the output of the script:
e=65537 d=15353693384417089838724462548624665131984541847837698089157240133474013117762978616666693401860905655963327632448623455383380954863892476195097282728814827543900228088193570410336161860174277615946002137912428944732371746227020712674976297289176836843640091584337495338101474604288961147324379580088173382908779460843227208627086880126290639711592345543346940221730622306467346257744243136122427524303881976859137700891744052274657401050973668524557242083584193692826433940069148960314888969312277717419260452255851900683129483765765679159138030020213831221144899328188412603141096814132194067023700444075607645059793 hint=275283221549738046345918168846641811313380618998221352140350570432714307281165805636851656302966169945585002477544100664479545771828799856955454062819317543203364336967894150765237798162853443692451109345096413650403488959887587524671632723079836454946011490118632739774018505384238035279207770245283729785148 c=8886475661097818039066941589615421186081120873494216719709365309402150643930242604194319283606485508450705024002429584410440203415990175581398430415621156767275792997271367757163480361466096219943197979148150607711332505026324163525477415452796059295609690271141521528116799770835194738989305897474856228866459232100638048610347607923061496926398910241473920007677045790186229028825033878826280815810993961703594770572708574523213733640930273501406675234173813473008872562157659306181281292203417508382016007143058555525203094236927290804729068748715105735023514403359232769760857994195163746288848235503985114734813 The server uses RSA to encrypt the flag.</description></item><item><title>readme 2023</title><link>https://7rocky.github.io/en/ctf/other/seccon-ctf/readme-2023/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seccon-ctf/readme-2023/</guid><description>We are provided with the Python source code that is running on the server:
import mmap import os import signal signal.alarm(60) try: f = open("./flag.txt", "r") mm = mmap.mmap(f.fileno(), 0, prot=mmap.PROT_READ) except FileNotFoundError: print("[-] Flag does not exist") exit(1) while True: path = input("path: ") if 'flag.txt' in path: print("[-] Path not allowed") exit(1) elif 'fd' in path: print("[-] No more fd trick ;)") exit(1) with open(os.path.realpath(path), "rb") as f: print(f.</description></item><item><title>RSA 4.0</title><link>https://7rocky.github.io/en/ctf/other/seccon-ctf/rsa-4.0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seccon-ctf/rsa-4.0/</guid><description>We are given the source code in SageMath to encrypt the flag:
import os from Crypto.Util.number import bytes_to_long, getStrongPrime m = bytes_to_long(os.getenvb(b"FLAG", b"FAKEFLAG{THIS_IS_FAKE}")) e = 0x10001 p = getStrongPrime(1024, e=e) q = getStrongPrime(1024, e=e) n = p * q assert m &amp;lt; n Q = QuaternionAlgebra(Zmod(n), -1, -1) i, j, k = Q.gens() enc = ( 1 * m + (3 * m + 1 * p + 337 * q) * i + (3 * m + 13 * p + 37 * q) * j + (7 * m + 133 * p + 7 * q) * k ) ** e print(f"</description></item><item><title>Sickle</title><link>https://7rocky.github.io/en/ctf/other/seccon-ctf/sickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seccon-ctf/sickle/</guid><description>We are provided with the Python source code that checks if the flag is right:
import pickle, io payload = b'\x8c\x08builtins\x8c\x07getattr\x93\x942\x8c\x08builtins\x8c\x05input\x93\x8c\x06FLAG&amp;gt; \x85R\x8c\x06encode\x86R)R\x940g0\n\x8c\x08builtins\x8c\x04dict\x93\x8c\x03get\x86R\x8c\x08builtins\x8c\x07globals\x93)R\x8c\x01f\x86R\x8c\x04seek\x86R\x94g0\n\x8c\x08builtins\x8c\x03int\x93\x8c\x07__add__\x86R\x940g0\n\x8c\x08builtins\x8c\x03int\x93\x8c\x07__mul__\x86R\x940g0\n\x8c\x08builtins\x8c\x03int\x93\x8c\x06__eq__\x86R\x940g3\ng5\n\x8c\x08builtins\x8c\x03len\x93g1\n\x85RM@\x00\x86RM\x05\x01\x86R\x85R.0g0\ng1\n\x8c\x0b__getitem__\x86R\x940M\x00\x00\x940g2\ng3\ng0\ng6\ng7\n\x85R\x8c\x06__le__\x86RM\x7f\x00\x85RMJ\x01\x86R\x85R.0g2\ng3\ng4\ng5\ng3\ng7\nM\x01\x00\x86Rp7\nM@\x00\x86RMU\x00\x86RM"\x01\x86R\x85R0g0\ng0\n]\x94\x8c\x06append\x86R\x940g8\n\x8c\x0b__getitem__\x86R\x940g0\n\x8c\x08builtins\x8c\x03int\x93\x8c\nfrom_bytes\x86R\x940M\x00\x00p7\n0g9\ng11\ng6\n\x8c\x08builtins\x8c\x05slice\x93g4\ng7\nM\x08\x00\x86Rg4\ng3\ng7\nM\x01\x00\x86RM\x08\x00\x86R\x86R\x85R\x8c\x06little\x86R\x85R0g2\ng3\ng4\ng5\ng3\ng7\nM\x01\x00\x86Rp7\nM\x08\x00\x86RMw\x00\x86RM\xc9\x01\x86R\x85R0g0\n]\x94\x8c\x06append\x86R\x940g0\ng12\n\x8c\x0b__getitem__\x86R\x940g0\n\x8c\x08builtins\x8c\x03int\x93\x8c\x07__xor__\x86R\x940I1244422970072434993\n\x940M\x00\x00p7\n0g13\n\x8c\x08builtins\x8c\x03pow\x93g15\ng10\ng7\n\x85Rg16\n\x86RI65537\nI18446744073709551557\n\x87R\x85R0g14\ng7\n\x85Rp16\n0g2\ng3\ng4\ng5\ng3\ng7\nM\x01\x00\x86Rp7\nM\x08\x00\x86RM\x83\x00\x86RM\xa7\x02\x86R\x85R0g0\ng12\n\x8c\x06__eq__\x86R(I8215359690687096682\nI1862662588367509514\nI8350772864914849965\nI11616510986494699232\nI3711648467207374797\nI9722127090168848805\nI16780197523811627561\nI18138828537077112905\nl\x85R.' f = io.BytesIO(payload) res = pickle.load(f) if isinstance(res, bool) and res: print("Congratulations!!") else: print("Nope") What it does is load a serialized payload into pickle and check if the result is true:
$ python3 problem.py FLAG&amp;gt; SECCON{asdf} Nope Therefore, we must analyze the pickle payload to determine how the flag is being checked.</description></item></channel></rss>