<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Other CTF on 7Rocky</title><link>https://7rocky.github.io/en/ctf/other/</link><description>Recent content in Other CTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/other/index.xml" rel="self" type="application/rss+xml"/><item><title>babyreeee</title><link>https://7rocky.github.io/en/ctf/other/babyreeee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/babyreeee/</guid><description>We are given a binary called chall:
$ file chall chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=151528987cd274999ec93665ef2d6a7678c5107b, for GNU/Linux 3.2.0, stripped When we execute, it asks for the flag:
$ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{asdf} Flag wrong. Try again. Let&amp;rsquo;s open the binary in Ghidra to analyze the decompiled C code. This is the main function.</description></item><item><title>Close Enough</title><link>https://7rocky.github.io/en/ctf/other/close-enough/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/close-enough/</guid><description>We are told that some RSA implementation uses a prime number and the next prime number. We are also given the ciphertext:
4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 We got the source code as well:
from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open("key", "w") as f: f.write(key) m = bytes_to_long(flag.</description></item><item><title>fno-stack-protector</title><link>https://7rocky.github.io/en/ctf/other/fno-stack-protector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/fno-stack-protector/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
voidbad_function() { execve("/bin/sh", NULL, NULL); } voidvuln() { chardata[10]; read(0, data, 170); } intmain() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return0; } There exists a Buffer Overflow vulnerability. Notice that data is a character array of 10 bytes, and the program reads up to 170 bytes.</description></item><item><title>Hope you know JS</title><link>https://7rocky.github.io/en/ctf/other/hope-you-know-js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/hope-you-know-js/</guid><description>We are given an obfuscated JavaScript file called good-luck.js. When running it on a simple HTML document it will show a prompt to validate the flag:
&amp;lt;!doctypehtml&amp;gt; &amp;lt;htmllang="en"&amp;gt; &amp;lt;head&amp;gt; &amp;lt;metacharset="UTF-8"&amp;gt; &amp;lt;title&amp;gt;Hope you know JS&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;scriptsrc="good-luck.js"&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Making use of Visual Studio Code Prettier formatter, I was able to find some patterns that where repeated along the code. For example, I started substituting expressions like +!![] or !</description></item><item><title>Robot Factory</title><link>https://7rocky.github.io/en/ctf/other/robot-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/robot-factory/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled We are given a Dockerfile that starts with FROM ubuntu:18.04, so we take Glibc from the container and use pwninit to patch the binary:
$ docker run --rm -v "$(pwd)":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.so.2 /lib/x86_64-linux-gnu/libc.so.6 GNU C Library (Ubuntu GLIBC 2.</description></item><item><title>scrambler</title><link>https://7rocky.github.io/en/ctf/other/scrambler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/scrambler/</guid><description>We are given a 64-bit binary called scrambler:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the remote Glibc binary (libc.so_1.6), so we can use pwninit to patch the binary and use the provided library, so that the local and the remote exploits are equal:
$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.31-0ubuntu9.7_amd64.deb unstripping libc https://launchpad.</description></item><item><title>Secret Note</title><link>https://7rocky.github.io/en/ctf/other/secret-note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/secret-note/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
voidget_name() { longin_FS_OFFSET; charname[40]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); puts("Please fill in your name:"); read(0, name, 30); printf("Thank you "); printf(name); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } intmain() { longin_FS_OFFSET; charsecret[56]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts("</description></item><item><title>Ursa Minor</title><link>https://7rocky.github.io/en/ctf/other/ursa-minor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ursa-minor/</guid><description>We are given the following source code and an instance to connect to:
#!/usr/local/bin/python # # Polymero # # Imports fromCrypto.Util.numberimportisPrime, getPrime, inverse importhashlib, time, os # Local import FLAG=os.environ.get('FLAG').encode() classURSA: # Upgraded RSA (faster and with cheap key cycling) def__init__(self, pbit, lbit): p, q=self.prime_gen(pbit, lbit) self.public={'n': p*q, 'e': 0x10001} self.private={'p': p, 'q': q, 'f': (p-1)*(q-1), 'd': inverse(self.public['e'], (p-1)*(q-1))} defprime_gen(self, pbit, lbit): # Smooth primes are FAST primes ~ !</description></item></channel></rss>