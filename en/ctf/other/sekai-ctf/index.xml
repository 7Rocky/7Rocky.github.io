<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sekai CTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/</link><description>Recent content in Sekai CTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/sekai-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>cryptoGRAPHy (1, 2, 3)</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/cryptography-1-2-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/cryptography-1-2-3/</guid><description>This series of challenges has a background on graph theory combined with cryptography. The author implemented a Python library using networkx to handle graphs and cryptographyc functions such as AES cipher, HMAC or SHA256 hash.
These challenges were a bit polemic due to the fact that players needed to read, analyze and understand the implemented library for the Graph Encryption Scheme and after that implement a solution to the corresponding challenge.</description></item><item><title>Noisy CRC</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/noisy-crc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/noisy-crc/</guid><description>We are given the Python source code of the server:
import secrets from Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 from flag import FLAG def getCRC16(msg, gen_poly): assert (1 &amp;lt;&amp;lt; 16) &amp;lt;= gen_poly &amp;lt; (1 &amp;lt;&amp;lt; 17) # check if deg = 16 msglen = msg.bit_length() msg &amp;lt;&amp;lt;= 16 for i in range(msglen - 1, -1, -1): if (msg &amp;gt;&amp;gt; (i + 16)) &amp;amp; 1: msg ^= (gen_poly &amp;lt;&amp;lt; i) return msg def oracle(secret, gen_poly): res = [secrets.</description></item><item><title>Play to Earn</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/play-to-earn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/play-to-earn/</guid><description>We are given a Smart Contract called ArcadeMachine.sol:
pragma solidity 0.8.25; import { Coin } from "./Coin.sol"; contract ArcadeMachine { Coin coin; constructor(Coin _coin) { coin = _coin; } function play(uint256 times) external { // burn the coins require(coin.transferFrom(msg.sender, address(0), 1 ether * times)); // Have fun XD } } Another Smart Contract called Coin.sol:
pragma solidity 0.8.25; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/cryptography/EIP712.sol"; contract Coin is Ownable, EIP712 { string public constant name = "</description></item></channel></rss>