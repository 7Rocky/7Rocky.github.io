<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SekaiCTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/</link><description>Recent content in SekaiCTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/sekai-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>cryptoGRAPHy (1, 2, 3)</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/cryptography-1-2-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/cryptography-1-2-3/</guid><description>This series of challenges has a background on graph theory combined with cryptography. The author implemented a Python library using networkx to handle graphs and cryptographyc functions such as AES cipher, HMAC or SHA256 hash.
These challenges were a bit polemic due to the fact that players needed to read, analyze and understand the implemented library for the Graph Encryption Scheme and after that implement a solution to the corresponding challenge.</description></item><item><title>Noisy CRC</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/noisy-crc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/noisy-crc/</guid><description>We are given the Python source code of the server:
import secrets from Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 from flag import FLAG def getCRC16(msg, gen_poly): assert (1 &amp;lt;&amp;lt; 16) &amp;lt;= gen_poly &amp;lt; (1 &amp;lt;&amp;lt; 17) # check if deg = 16 msglen = msg.bit_length() msg &amp;lt;&amp;lt;= 16 for i in range(msglen - 1, -1, -1): if (msg &amp;gt;&amp;gt; (i + 16)) &amp;amp; 1: msg ^= (gen_poly &amp;lt;&amp;lt; i) return msg def oracle(secret, gen_poly): res = [secrets.</description></item><item><title>Play to Earn</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/play-to-earn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/play-to-earn/</guid><description>We are given a Smart Contract called ArcadeMachine.sol:
pragma solidity 0.8.25; import { Coin } from "./Coin.sol"; contract ArcadeMachine { Coin coin; constructor(Coin _coin) { coin = _coin; } function play(uint256 times) external { // burn the coins require(coin.transferFrom(msg.sender, address(0), 1 ether * times)); // Have fun XD } } Another Smart Contract called Coin.sol:
pragma solidity 0.8.25; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/cryptography/EIP712.sol"; contract Coin is Ownable, EIP712 { string public constant name = "</description></item><item><title>speedpwn</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/speedpwn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/speedpwn/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No Source code analysis This time, we are given the full source code in C:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; unsigned long long number_of_games; unsigned long long game_history; unsigned long long seed; FILE* seed_generator; int cmp(unsigned long long a, unsigned long long b) { if (__builtin_popcountll(a) !</description></item><item><title>はやぶさ</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/%E3%81%AF%E3%82%84%E3%81%B6%E3%81%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/%E3%81%AF%E3%82%84%E3%81%B6%E3%81%95/</guid><description>We are given a Python script called chall.py:
from falcon import falcon from flag import flag from timeout_decorator import timeout @timeout(30) def main(): sk = falcon.SecretKey(64) pk = falcon.PublicKey(sk) print(pk) your_sig = bytes.fromhex(input("what is your sig? &amp;gt;")) if pk.verify(b"Can you break me", your_sig): print("well done!!") print(flag) exit() print("Broken your wing T_T") main() And we also have a shell script called up.sh:
git clone https://github.com/tprest/falcon.py.git mv falcon.py falcon echo "import os import sys sys.</description></item><item><title>マスタースパーク</title><link>https://7rocky.github.io/en/ctf/other/sekai-ctf/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/sekai-ctf/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF/</guid><description>We are given a SageMath script called challenge.sage:
from Crypto.Util.number import * import os from timeout_decorator import timeout, TimeoutError load("GA.sage") FLAG = os.getenv("FLAG") secret = getPrime(256) choice = set() @timeout(60) def T_T(p, primes, secret): assert isPrime(p) assert len(primes) &amp;gt; 3 Fp = GF(p) Fp2.&amp;lt;j&amp;gt; = GF(p ^ 2, modulus=x ^ 2 + 1) ls = len(factor(p + 1)) - 2 m = ceil((sqrt(p) ** (1 / ls) - 1) / 2) alice_priv = [randrange(-m, m + 1) for _ in range(len(primes))] bob_priv = [randrange(-m, m + 1) for _ in range(len(primes))] EC = montgomery(Fp2, 0) P = EC.</description></item></channel></rss>