<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB Cyber Apocalypse on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/</link><description>Recent content in HTB Cyber Apocalypse on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/alien-saboteaur/</guid><description>We are given a binary file called vm and a program called bin:
$ file * bin: data vm: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=10fb238b19d3a82b46536b51e47396525086a09c, for GNU/Linux 3.2.0, not stripped Setup environment The binary needs a recent version of Glibc in order to run:
$ ./vm ./vm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./vm) To solve this issue, we can run Ubuntu 22.</description></item><item><title>Arranged</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/arranged/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/arranged/</guid><description>We are given the SageMath source code to encrypt the flag:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 from secret import FLAG, p, b, priv_a, priv_b F = GF(p) E = EllipticCurve(F, [726, b]) G = E(926644437000604217447316655857202297402572559368538978912888106419470011487878351667380679323664062362524967242819810112524880301882054682462685841995367, 4856802955780604241403155772782614224057462426619061437325274365157616489963087648882578621484232159439344263863246191729458550632500259702851115715803253) A = G * priv_a B = G * priv_b print(A) print(B) C = priv_a * B assert C == priv_b * A # now use it as shared secret secret = C[0] hash = sha256() hash.</description></item><item><title>Artifacts of Dangerous Sightings</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/artifacts-of-dangerous-sightings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/artifacts-of-dangerous-sightings/</guid><description>We are given a Windows disk image inside a folder called HostEvidence_PANDORA:
$ file HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx: Microsoft Disk Image eXtended, by .NET DiscUtils, sequence 0x8, NO Log Signature; region, 2 entries, id Metadata, at 0x200000, Required 1, id BAT, at 0x300000, Required 1 If we switch to a Windows machine and mount the disk image, we will have the following folders:
Analyzing the disk image Basically, it is the C:\ drive of a Windows machine.</description></item><item><title>Bashic Ransomware</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/bashic-ransomware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/bashic-ransomware/</guid><description>We are given these files:
$ file * flag.txt.a59ap: GPG symmetrically encrypted data (AES256 cipher) forensics.mem: data linux-image-5.10.0-21.zip: Zip archive data, at least v2.0 to extract, compression method=deflate traffic.pcap: pcapng capture file - version 1.0 We can guess that we will need to analyze a compromised Linux machine because we are given a memory dump (forensics.mem) and a profile for volatility.
Network traffic analysis Let&amp;rsquo;s start using Wireshark to analyze the PCAP:</description></item><item><title>Biased Heritage</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/biased-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/biased-heritage/</guid><description>This challenge is kind of a continuation of Colliding Heritage. We are provided with the server source code in Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????????????????}" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.</description></item><item><title>Calibrator</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/calibrator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/calibrator/</guid><description>We are given a remote instance to connect to:
$ nc 165.227.224.40 31139 [OK] Memory check [OK] Syncing filesystem [OK] Detecting sensors [OK] Module loader [OK] Reading configurations Inititing calibration process ... ┌──────────────────────────────────────────────────────────────────────┐ │┼───────────────────┼────────────────────────┼┼──────────────────────┼│ ││ XenoCal 2000 │ . ││ ││ │┼───────────────────┤ ┌─┐ x││ . . ││ ││ Iteration: 42 │ x ► └─┘ ││ x ││ │┼─────────┬─────────┤ ││ ││ ││ X:1337 │ Y:65189 │ . x ┌───┼┼───┐ ││ │┼─────────┴─────────┘ x ┌─┘ ││ └─┐ x ││ ││ .</description></item><item><title>Colliding Heritage</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/colliding-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/colliding-heritage/</guid><description>We are provided with the server source code in Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????}" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.</description></item><item><title>Control Room</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/control-room/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/control-room/</guid><description>We are given a 64-bit binary called control_room:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Setup environment We are also provided with the remote Glibc library:
$ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Converging Visions</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/converging-visions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/converging-visions/</guid><description>We are provided with the server source code in Python:
from secret import FLAG, p, a, b from sage.all_cmdline import * class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.</description></item><item><title>Didactic Octo Paddles</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/didactic-octo-paddles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/didactic-octo-paddles/</guid><description>We are given a website like this:
We also have the source code in Node.js.
Source code analysis The web application is built with Express JS. After reading some files, one that stands out is middlewares/AdminMiddleware.js:
const jwt = require("jsonwebtoken"); const { tokenKey } = require("../utils/authorization"); const db = require("../utils/database"); const AdminMiddleware = async (req, res, next) =&amp;gt; { try { const sessionCookie = req.cookies.session; if (!sessionCookie) { return res.redirect("/login"); } const decoded = jwt.</description></item><item><title>Elliptic Labyrinth</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth/</guid><description>We are provided with the server source code in Python:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print("1. Get parameters of path"</description></item><item><title>Elliptic Labyrinth Revenge</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth-revenge/</guid><description>This challenge is Elliptic Labyrinth modified to force CTF players use the intended way to solve the challenge.
Finding differences The provided source code is a bit different:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.</description></item><item><title>Gloater</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/</guid><description>We are given a 64-bit binary called gloater:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' We are also given a Dockerfile with the container configuration:
FROM ubuntu:20.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update --fix-missing &amp;amp;&amp;amp; apt-get -y upgrade RUN apt-get install -y socat RUN useradd -m ctf COPY challenge/* /home/ctf/ RUN chown -R ctf:ctf /home/ctf/ WORKDIR /home/ctf #USER ctf EXPOSE 9001 CMD ["</description></item><item><title>Hijack</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/hijack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/hijack/</guid><description>We are given a remote instance to connect to:
$ nc 167.71.143.44 31614 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; Basic recognition We have two options. Using the first one, we can set some configuration and the output is a Base64-encoded string:
$ nc 165.232.100.46 31251 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; 1 - Creating new config - Temperature units (F/C/K): C Propulsion Components Target Temperature : 13 Solar Array Target Temperature : 37 Infrared Spectrometers Target Temperature : 0 Auto Calibration (ON/OFF) : ON Serialized config: ISFweXRob24vb2JqZWN0Ol9fbWFpbl9fLkNvbmZpZyB7SVJfc3BlY3Ryb21ldGVyX3RlbXA6ICcwJywgYXV0b19jYWxpYnJhdGlvbjogJ09OJywKICBwcm9wdWxzaW9uX3RlbXA6ICcxMycsIHNvbGFyX2FycmF5X3RlbXA6ICczNycsIHVuaXRzOiBDfQo= Uploading to ship.</description></item><item><title>HM74</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/hm74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/hm74/</guid><description>We are given this Verilog hardware description code:
module encoder( input [3:0] data_in, output [6:0] ham_out ); wire p0, p1, p2; assign p0 = data_in[3] ^ data_in[2] ^ data_in[0]; assign p1 = data_in[3] ^ data_in[1] ^ data_in[0]; assign p2 = data_in[2] ^ data_in[1] ^ data_in[0]; assign ham_out = { p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0] }; endmodule module main; wire[3:0] data_in = 5; wire[6:0] ham_out; encoder en(data_in, ham_out); initial begin #10; $display("</description></item><item><title>Iced TEA</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/iced-tea/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/iced-tea/</guid><description>We are given the Python source code that encrypts the flag:
import os from secret import FLAG from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.</description></item><item><title>Inside The Matrix</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/inside-the-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/inside-the-matrix/</guid><description>We are given the source code of the server in Python:
from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b"HTB{????????????????????}" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.</description></item><item><title>Interstellar C2</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/interstellar-c2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/interstellar-c2/</guid><description>We are given a PCAP file called capture.pcapng. Let&amp;rsquo;s open it in Wireshark:
As always, it is nice to start analyzing top-level protocols like HTTP, so let&amp;rsquo;s apply a filter:
The first request is trying to download a PowerShell script called vn84.ps1:
PowerShell deobfuscation We can take the script from Wireshark and read it here:
.("{1}{0}{2}" -f'T','Set-i','em') ('vAriA'+'ble'+':q'+'L'+'z0so') ( [tYpe]("{0}{1}{2}{3}" -F'SySTEM.i','o.Fi','lE','mode')) ; &amp;amp;("{0}{2}{1}" -f'set-Vari','E','ABL') l60Yu3 ( [tYPe]("{7}{0}{5}{4}{3}{1}{2}{6}"-F'm.','ph','Y.ae','A','TY.crypTOgR','SeCuRi','S','sYSte')); .("{0}{2}{1}{3}" -f 'Set-V','i','AR','aBle') BI34 ( [TyPE]("</description></item><item><title>Janken</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/janken/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/janken/</guid><description>We are given a binary file called janken and a remote instance to connect to:
$ file janken janken: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, BuildID[sha1]=56b54cdae265aa352fe2ebb016f86af831fd58d3, for GNU/Linux 3.2.0, not stripped It is a Rock-Paper-Scissors game:
$ nc 167.99.86.8 31902 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▌ じ ゃ ん 拳 ▐ ▙▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▟ 1. ℙ ∟ ₳ Ұ 2. ℜ ℧ ∟ Ӗ ⅀ &amp;gt;&amp;gt; 2 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▚ [*] Rock is called "</description></item><item><title>Labyrinth</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/labyrinth/</guid><description>We are given a 64-bit binary called labyrinth:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering If we open it in Ghidra, we will see this main function in decompiled C code:
int main() { int ret; char *__s; char data[32]; ulong i; setup(); banner(); data._0_8_ = 0; data._8_8_ = 0; data._16_8_ = 0; data._24_8_ = 0; fwrite("\nSelect door: \n\n"</description></item><item><title>Lucky Faucet</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/lucky-faucet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/lucky-faucet/</guid><description>We are given a Solidity file called LuckyFaucet.sol:
// SPDX-License-Identifier: MIT pragma solidity 0.7.6; contract LuckyFaucet { int64 public upperBound; int64 public lowerBound; constructor() payable { // start with 50M-100M wei Range until player changes it upperBound = 100_000_000; lowerBound = 50_000_000; } function setBounds(int64 _newLowerBound, int64 _newUpperBound) public { require(_newUpperBound &amp;lt;= 100_000_000, "100M wei is the max upperBound sry"); require(_newLowerBound &amp;lt;= 50_000_000, "50M wei is the max lowerBound sry"); require(_newLowerBound &amp;lt;= _newUpperBound); // why?</description></item><item><title>Math Door</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/math-door/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/math-door/</guid><description>We are given a 64-bit binary called math-door:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' Setup environment We are also provided with the remote Glibc library and loader:
$ ./ld.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Maze of Mist</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/</guid><description>We are given a compressed vmlinuz-linux kernel image, an initramfs.cpio.gz filesystem and a run.sh script:
$ unzip -l pwn_maze_of_mist.zip Archive: pwn_maze_of_mist.zip Length Date Time Name --------- ---------- ----- ---- 0 2024-02-06 09:30 maze_of_mist/ 1347202 2024-02-06 09:29 maze_of_mist/initramfs.cpio.gz 291 2024-02-06 09:26 maze_of_mist/run.sh 12886816 2024-02-06 09:26 maze_of_mist/vmlinuz-linux --------- ------- 14234309 4 files $ unzip pwn_maze_of_mist.zip Archive: pwn_maze_of_mist.zip creating: maze_of_mist/ inflating: maze_of_mist/initramfs.cpio.gz inflating: maze_of_mist/run.sh inflating: maze_of_mist/vmlinuz-linux If we decompress the filesystem, we find a 32-bit binary called target:</description></item><item><title>Multipage Recyclings</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/multipage-recyclings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/multipage-recyclings/</guid><description>We are provided with the server source code in Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.</description></item><item><title>nehebkaus trap</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/nehebkaus-trap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/nehebkaus-trap/</guid><description>We are given a remote instance to connect to:
$ nc 167.71.143.44 32139 __ {00} \__/ /^/ ( ( \_\_____ (_______) (_________()Ooo. [ Nehebkau's Trap ] You are trapped! Can you escape? &amp;gt; Basic recognition We are allowed to enter some information, but it shows an error:
&amp;gt; asdf [*] Input accepted! Error: name 'asdf' is not defined The error message looks familiar to a Python REPL:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; asdf Traceback (most recent call last): File "</description></item><item><title>Oracle</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/oracle/</guid><description>We are given a 64-bit binary called oracle:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled We also have a Dockerfile:
FROM ubuntu:20.04 RUN useradd -m ctf COPY challenge/* /home/ctf/ RUN chown -R ctf:ctf /home/ctf/ WORKDIR /home/ctf USER ctf EXPOSE 9001 CMD ["./run.sh"] Source code analysis This time, we are given the source code of the program in C. It is quite large, so I will only put the relevant parts.</description></item><item><title>Orbital</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/orbital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/orbital/</guid><description>We are given a website like this:
We also have the source code in Python.
Source code analysis The web application is built with Flask. A clear SQL injection (SQLi) vulnerability can be found at database.py:
from colorama import Cursor from application.util import createJWT, passwordVerify from flask_mysqldb import MySQL mysql = MySQL() def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.</description></item><item><title>Pandora's Bane</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/pandoras-bane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/pandoras-bane/</guid><description>We are given a large memory dump called mem.raw:
$ du -h mem.raw 2,1G	mem.raw $ file mem.raw mem.raw: data Memory dump analysis Let&amp;rsquo;s use volatility to analyze it (I will use a Docker image for that):
$ docker run --rm -v "${PWD}":/project --entrypoint /bin/sh --platform linux/amd64 -it sk4la/volatility3 /usr/local $ cd /project /project $ vol -f mem.raw windows.info.Info | tee info.txt Volatility 3 Framework 2.0.1 Progress: 100.00	PDB scanning finished Variable	Value Kernel Base	0xf80445604000 DTB	0x1ad000 Symbols	file:///usr/local/lib/volatility3/volatility3/symbols/windows/ntkrnlmp.</description></item><item><title>Pandora's Box</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/pandoras-box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/pandoras-box/</guid><description>We are given a 64-bit binary called pb:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering We can use Ghidra to analyze the binary and look at the decompiled source code in C:
int main() { setup(); cls(); banner(); box(); return 0; } Among others, this function calls box:
void box() { long num; char data [32]; data._0_8_ = 0; data.</description></item><item><title>Partial Tenacity</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/partial-tenacity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/partial-tenacity/</guid><description>We are given the Python source code that encrypts the flag:
from secret import FLAG from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP class RSACipher: def __init__(self, bits): self.key = RSA.generate(bits) self.cipher = PKCS1_OAEP.new(self.key) def encrypt(self, m): return self.cipher.encrypt(m) def decrypt(self, c): return self.cipher.decrypt(c) cipher = RSACipher(1024) enc_flag = cipher.encrypt(FLAG) with open('output.txt', 'w') as f: f.write(f'n = {cipher.key.n}\n') f.write(f'ct = {enc_flag.hex()}\n') f.write(f'p = {str(cipher.key.p)[::2]}\n') f.write(f'q = {str(cipher.key.q)[1::2]}') We also have the output of the script:</description></item><item><title>Passman</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/passman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/passman/</guid><description>We are given a website like this:
We also have the source code in Node.js.
Source code analysis The web application is built with Express JS. A relevant file is routes/index.js:
const express = require('express'); const router = express.Router(); const { graphqlHTTP } = require('express-graphql'); const AuthMiddleware = require('../middleware/AuthMiddleware'); const GraphqlSchema = require('../helpers/GraphqlHelper'); router.get('/', (req, res) =&amp;gt; { return res.render('login.html'); }); router.get('/register', (req, res) =&amp;gt; { return res.render('register.html'); }); router.use('/graphql', AuthMiddleware, graphqlHTTP({ schema: GraphqlSchema, graphiql: false })); router.</description></item><item><title>Path of Survival</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/path-of-survival/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/path-of-survival/</guid><description>We are given the following website:
It shows a kind of labyrinth where we are an astronaut and we need to find a weapon in the shortest time possible.
The website shows how to interact with our astronaut player, and shows some rules regarding labyrinth tiles (Cliff, Geyser, Mountain&amp;hellip;):
Moreover, we have an HTTP API to get the map as a JSON document and to run commands to move the astronaut:</description></item><item><title>Percetron</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/percetron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/percetron/</guid><description>We are given a website where we can register and log in to have this dashboard:
Moreover, we are given the whole web project for analysis.
Source code analysis The web server is running Express JS (Node.js). The index.js file is quite standard, but we can see that it uses MongoDB and neo4j:
require("dotenv").config(); const path = require("path"); const express = require("express"); const session = require("express-session"); const mongoose = require("mongoose"); const Neo4jConnection = require("</description></item><item><title>Relic Maps</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/relic-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/relic-maps/</guid><description>We have this description for the challenge:
Pandora received an email with a link claiming to have information about the location of the relic and attached ancient city maps, but something seems off about it. Could it be rivals trying to send her off on a distraction? Or worse, could they be trying to hack her systems to get what she knows? Investigate the given attachment and figure out what&amp;rsquo;s going on and get the flag.</description></item><item><title>Restricted</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/restricted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/restricted/</guid><description>We are given a remote instance to connect to:
$ nc 64.227.41.83 30543 SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1 Invalid SSH identification string. Ncat: Broken pipe. It looks like we must access via SSH.
SSH connection We are also given some files:
$ tree . ├── Dockerfile ├── build_docker.sh └── src ├── bash_profile ├── flag.txt └── sshd_config 2 directories, 5 files Loooking at the Dockerfile, we see that the user is named restricted and we will be using rbash (restricted Bash):</description></item><item><title>Roten</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/roten/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/roten/</guid><description>We are given a PCAP file (challenge.pcap) with a lot of network packets:
Finding the attack vector First of all, let&amp;rsquo;s filter by HTTP to read only high-level network packets:
The attacker is poking around with the website. For instance, they are trying to use POST parameters:
If we go to the end of the packet capture, we will see that the attackers are executing system commands:
In the above ls command, we see a file called galacticmap-php that looks suspicious.</description></item><item><title>Russian Roulette</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/russian-roulette/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/russian-roulette/</guid><description>We are given a Solidity file called RussianRoulette.sol:
pragma solidity 0.8.23; contract RussianRoulette { constructor() payable { // i need more bullets } function pullTrigger() public returns (string memory) { if (uint256(blockhash(block.number - 1)) % 10 == 7) { selfdestruct(payable(msg.sender)); // 💀 } else { return "im SAFU ... for now"; } } } Moreover, we have this Setup.sol, which is common in Solidity challenges:
pragma solidity 0.8.23; import {RussianRoulette} from "</description></item><item><title>Small StEps</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/small-steps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/small-steps/</guid><description>We are given a remote instance to connect to:
$ nc 188.166.152.84 32213 This is the second level of training. [E]ncrypt the flag. [A]bort training. &amp;gt; We are also provided with the server&amp;rsquo;s Python source code:
from Crypto.Util.number import getPrime, bytes_to_long FLAG = b"HTB{???????????????}" assert len(FLAG) == 20 class RSA: def __init__(self): self.q = getPrime(256) self.p = getPrime(256) self.n = self.q * self.p self.e = 3 def encrypt(self, plaintext): plaintext = bytes_to_long(plaintext) return pow(plaintext, self.</description></item><item><title>Sound of Silence</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/sound-of-silence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/sound-of-silence/</guid><description>We are given a 64-bit binary called sound_of_silence:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We also have the remote Glibc library and loader:
$ glibc/ld-linux-x86-64.so.2 glibc/libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.4) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>SpyBug</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/spybug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/spybug/</guid><description>We are given a website like this:
We also have the source code of the web application in Node.js and the source code of an agent in Go.
Source code analysis The web application is built with Express JS. In index.js we can see a Content Security Policy (CSP) header and a function visitPanel that runs every minute:
application.use((req, res, next) =&amp;gt; { res.setHeader("Content-Security-Policy", "script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';"</description></item><item><title>Testimonial</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/testimonial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/testimonial/</guid><description>We are given the following website:
Moreover, we have a gRPC endpoint at 94.237.49.166:58578.
We are also given the source code of the project in Go.
Source code analysis This is the main file (main.go):
package main import ( "embed" "htbchal/handler" "htbchal/pb" "log" "net" "net/http" "github.com/go-chi/chi/v5" "google.golang.org/grpc" ) //go:embed public var FS embed.FS func main() { router := chi.NewMux() router.Handle("/*", http.StripPrefix("/", http.FileServer(http.FS(FS)))) router.Get("/", handler.MakeHandler(handler.HandleHomeIndex)) go startGRPC() log.Fatal(http.ListenAndServe(":1337", router)) } type server struct { pb.</description></item><item><title>TrapTrack</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/traptrack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/traptrack/</guid><description>We are given a website like this:
We are also given the source code of the project.
Website functionality The web application allows us to enter URLs that will be stored in a SQLite3 database. Just reading the code from challenge/application/config.py, we have valid credentials (admin:admin):
from application.util import generate import os class Config(object): SECRET_KEY = generate(50) ADMIN_USERNAME = 'admin' ADMIN_PASSWORD = 'admin' SESSION_PERMANENT = False SESSION_TYPE = 'filesystem' SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/database.</description></item><item><title>Tsayaki</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/tsayaki/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/tsayaki/</guid><description>We are given the source code of the server in Python:
from tea import Cipher as TEA from secret import IV, FLAG import os ROUNDS = 10 def show_menu(): print(""" ============================================================================================ || I made this decryption oracle in which I let users choose their own decryption keys. || || I think that it's secure as the tea cipher doesn't produce collisions (?) ... Right? || || If you manage to prove me wrong 10 times, you get a special gift.</description></item><item><title>Void</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/void/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/void/</guid><description>We are given a 64-bit binary called void:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering If we use Ghidra, we will find this decompiled C code:
void vuln() { char data[64]; read(0, data, 200); } int main() { vuln(); return 0; } The code is very short and there is only a single point to enter data.</description></item></channel></rss>