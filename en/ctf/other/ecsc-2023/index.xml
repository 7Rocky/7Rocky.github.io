<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECSC 2023 on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/</link><description>Recent content in ECSC 2023 on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/ecsc-2023/index.xml" rel="self" type="application/rss+xml"/><item><title>Blind</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/blind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/blind/</guid><description>Is this what people mean by &amp;ldquo;message blinding&amp;rdquo;?
Challenge contributed by CryptoHack
Challenge files:
output.txt blind.sage Source code analysis We are given a large SageMath script that uses ECDSA to sign the key to encrypt the flag (actually, a key used to derive an AES key with bcrypt.kdf):
def encrypt_flag(): k = secrets.token_bytes(k2//8) key = bcrypt.kdf(k, b"ICC_CHALLENGE", 16, 31337) cipher = AES.new(key, AES.MODE_CTR, nonce=b"") with open("flag.txt", "rb") as f: flag = f.</description></item><item><title>Hide and seek</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/hide-and-seek/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/hide-and-seek/</guid><description>I have hidden my flag among the elliptic curve points. Go seek!
Challenge contributed by CryptoHack
Challenge files:
output.txt hide_and_seek.sage Source code analysis We are given a SageMath script that uses Elliptic Curve Cryptography to encrypt the flag:
from Crypto.Util.number import bytes_to_long FLAG = bytes_to_long(open("flag.txt", "rb").read().strip()[len("ECSC{"):-1]) proof.arithmetic(False) p = 1789850433742566803999659961102071018708588095996784752439608585988988036381340404632423562593 a = 62150203092456938230366891668382702110196631396589305390157506915312399058961554609342345998 b = 1005820216843804918712728918305396768000492821656453232969553225956348680715987662653812284211 F = GF(p) E.&amp;lt;G&amp;gt; = EllipticCurve(F, [a, b]) assert FLAG &amp;lt; G.order() k = randrange(G.</description></item><item><title>Irish Flan</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/irish-flan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/irish-flan/</guid><description>Yum, time for dessert.
Challenge contributed by CryptoHack
Challenge files:
output.txt irish_flan.py We are given a Python script that uses quaternions to hide an AES key used to encrypt the flag. The quaternion implementation is based on Python classes. We can assume that the implementation is correct (although there is a bug in the power of a quaternion, but it is not intended).
Source code analysis The relevant part of the script is:</description></item><item><title>Kernel searcher</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/kernel-searcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/kernel-searcher/</guid><description>I have a super secret isogeny. Wanna know where your point ends up? Just send me your favourite coordinates.
Challenge contributed by CryptoHack
Challenge files:
Dockerfile entry.sh kernel_searcher.sage kernel_searcher.xinetd We are given a SageMath script that hides the flag under an isogeny and allows us to evaluate the isogeny in any point we desire.
Source code analysis The relevant part of the script is this one:
import json from Crypto.</description></item><item><title>not crypto</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/not-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/not-crypto/</guid><description>This is the not crypto flag which is totaly not crypto, but crypto! Can we get a clap from the team for excessive crypto usage?
We are given the following Python script:
import base64 input_string = "REMOVED" def secret(raw_string): result = [] for char in raw_string: if 'a' &amp;lt;= char &amp;lt;= 'z': offset = ord('a') result.append(chr(((ord(char) - offset + 13) % 26) + offset)) elif 'A' &amp;lt;= char &amp;lt;= 'Z': offset = ord('A') result.</description></item><item><title>Put a ring on it</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/put-a-ring-on-it/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/put-a-ring-on-it/</guid><description>Ring Signatures are used in some cryptocurrencies to provide anonymity for who has signed a transaction or sent money. Can you break the anonymity of the ring signatures?
Challenge contributed by CryptoHack
Challenge files:
ed25519.py data.json chal.py We are given an implementation of a ring signature protocol, which is supposed to be al algorithm where a set of parties can validate signed messages but cannot determine who has signed it, providing anonymity to the signatures.</description></item><item><title>RRSSAA</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/rrssaa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/rrssaa/</guid><description>My primes are prefectly random. I wonder if you can find them.
Challenge contributed by CryptoHack
Challenge files:
output.txt RRSSAA.py Source code analysis We are given the following Python script that uses RSA to encrypt the flag:
flag = open("flag.txt", "rb").read().strip() assert len(flag) == 128 N = prod(get_prime(i) for i in range(2, len(flag))) print(hex(N), hex(pow(bytes_to_long(flag), 0x10001, N))) The RSA setup is not the usual one. This time, we have a multi-prime RSA setup, where each prime factor of the modulus $n$ is computed with get_prime:</description></item><item><title>Tough decisions</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/tough-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/tough-decisions/</guid><description>Champagne for my real friends, real pain for my sham friends.
Challenge contributed by CryptoHack
Challenge files:
output.txt tough_decisions.py Source code analysis We are fiven a Python script that takes the flag as bits and, for each bit, it prints 6 outputs of either the real function (bit 0) or the fake function (bit 1):
if __name__ == "__main__": s = sample_key() for b in get_flag(): print([[real, fake][b](s) for _ in range(6)]) Therefore, the objective is to find a way to differentiate between real and fake outputs in order to learn the bits of the flag.</description></item><item><title>Twist and shout</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/twist-and-shout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/twist-and-shout/</guid><description>I&amp;rsquo;ll shout about my curve all day, it&amp;rsquo;s totally secure. You&amp;rsquo;ll have to pull the solution from my cold dead hands!
Challenge contributed by CryptoHack
Connect at archive.cryptohack.org 11718
Challenge files:
twist_and_shout.py Dockerfile twist_and_shout.xinetd We are given a server that uses an elliptic curve to encrypt the flag.
Source code analysis We have the curve parameters:
""" Define the elliptic curve E: y^2 = x^3 + a*x + b With order n = 340282366920938463465004184633952524077 = 2^128 - 1629577202184312621 "</description></item><item><title>WOTS Up</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/wots-up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/wots-up/</guid><description>With the need to find post-quantum schemes, hash-based signatures are cool again.
Challenge contributed by CryptoHack
Challenge files:
data.json chal.py We are given a class called Winternitz that implements some sort of signing protocol based on SHA256 hashes. Actually, WOTS stands for Winternitz One-Time Signature and it is a post-quantum signature algorithm, which is perfectly explained at www.codingninjas.com.
Source code analysis First of all, the class creates a list of private keys:</description></item><item><title>WOTS Up 2</title><link>https://7rocky.github.io/en/ctf/other/ecsc-2023/wots-up-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/ecsc-2023/wots-up-2/</guid><description>I fixed the problem with my last scheme, now I can confidently sign my WOTScoin transactions.
Challenge contributed by CryptoHack
Challenge files:
data.json chal.py This is another challenge that implements WOTS (more information at www.codingninjas.com).
Source code analysis The Winternitz class is a bit different from the first part of the challenge, in the keys generation:
class Winternitz: def __init__(self): self.priv_key = [] for _ in range(KEY_LEN): priv_seed = urandom(KEY_LEN) self.</description></item></channel></rss>