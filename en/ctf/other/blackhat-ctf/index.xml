<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BlackHat CTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/</link><description>Recent content in BlackHat CTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/blackhat-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>fno-stack-protector</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
void bad_function() { execve("/bin/sh", NULL, NULL); } void vuln() { char data[10]; read(0, data, 170); } int main() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return 0; } There exists a Buffer Overflow vulnerability.</description></item><item><title>Hope you know JS</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/hope-you-know-js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/blackhat-ctf/hope-you-know-js/</guid><description>We are given an obfuscated JavaScript file called good-luck.js. When running it on a simple HTML document it will show a prompt to validate the flag:
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang="en"&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset="UTF-8"&amp;gt; &amp;lt;title&amp;gt;Hope you know JS&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script src="good-luck.js"&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Making use of Visual Studio Code Prettier formatter, I was able to find some patterns that where repeated along the code. For example, I started substituting expressions like +!</description></item><item><title>Robot Factory</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We are given a Dockerfile that starts with FROM ubuntu:18.04, so we take Glibc from the container and use pwninit to patch the binary:
$ docker run --rm -v "$(pwd)":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.so.2 /lib/x86_64-linux-gnu/libc.so.6 GNU C Library (Ubuntu GLIBC 2.</description></item><item><title>Secret Note</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/secret-note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/blackhat-ctf/secret-note/</guid><description>We are given a 64-bit binary called main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled If we open the binary in Ghidra we see these functions:
void get_name() { long in_FS_OFFSET; char name[40]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); puts("Please fill in your name:"); read(0, name, 30); printf("Thank you "); printf(name); if (canary != *(long *) (in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } int main() { long in_FS_OFFSET; char secret[56]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts("</description></item><item><title>Ursa Minor</title><link>https://7rocky.github.io/en/ctf/other/blackhat-ctf/ursa-minor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/blackhat-ctf/ursa-minor/</guid><description>We are given the following source code and an instance to connect to:
#!/usr/local/bin/python # # Polymero # # Imports from Crypto.Util.number import isPrime, getPrime, inverse import hashlib, time, os # Local import FLAG = os.environ.get('FLAG').encode() class URSA: # Upgraded RSA (faster and with cheap key cycling) def __init__(self, pbit, lbit): p, q = self.prime_gen(pbit, lbit) self.public = {'n': p * q, 'e': 0x10001} self.private = {'p': p, 'q': q, 'f': (p - 1)*(q - 1), 'd': inverse(self.</description></item></channel></rss>