<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SEETF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/seetf/</link><description>Recent content in SEETF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/seetf/index.xml" rel="self" type="application/rss+xml"/><item><title>babyreeee</title><link>https://7rocky.github.io/en/ctf/other/seetf/babyreeee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seetf/babyreeee/</guid><description>We are given a binary called chall:
$ file chall chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=151528987cd274999ec93665ef2d6a7678c5107b, for GNU/Linux 3.2.0, stripped When we execute, it asks for the flag:
$ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{asdf} Flag wrong. Try again. Let&amp;rsquo;s open the binary in Ghidra to analyze the decompiled C code. This is the main function. It is a bit overwhelming because there are a lot of assignments:</description></item><item><title>Close Enough</title><link>https://7rocky.github.io/en/ctf/other/seetf/close-enough/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/seetf/close-enough/</guid><description>We are told that some RSA implementation uses a prime number and the next prime number. We are also given the ciphertext:
4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 We got the source code as well:
from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open("key", "w") as f: f.write(key) m = bytes_to_long(flag.</description></item></channel></rss>