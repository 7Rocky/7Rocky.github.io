<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>corCTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/corctf/</link><description>Recent content in corCTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/corctf/index.xml" rel="self" type="application/rss+xml"/><item><title>eyes</title><link>https://7rocky.github.io/en/ctf/other/corctf/eyes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/eyes/</guid><description>We are given the source code in SageMath that was used to encrypt the flag:
from Crypto.Util.number import bytes_to_long, getPrime # my NEW and IMPROVED secret sharing scheme!! (now with multivariate quadratics) with open('flag.txt', 'rb') as f: flag = f.read() s = bytes_to_long(flag) p = getPrime(len(bin(s))) print(p) F = GF(p) N = 1024 conv = lambda n: matrix(F, N, 1, [int(i) for i in list(bin(n)[2:][::-1].ljust(N, '0'))]) A = random_matrix(F, N, N) for i in range(0, N): for j in range(0, i): A[i, j] = 0 B = random_matrix(F, N, 1) C = matrix(F, [F(s)]) fn = lambda x: (x.</description></item><item><title>fizzbuzz100</title><link>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz100/</guid><description>We are given the Python source code that is running on a server:
#!/usr/local/bin/python from Crypto.Util.number import * from os import urandom flag = open("flag.txt", "rb").read() flag = bytes_to_long(urandom(16) + flag + urandom(16)) p = getPrime(512) q = getPrime(512) n = p * q e = 0x10001 d = pow(e, -1, (p-1)*(q-1)) assert flag &amp;lt; n ct = pow(flag, e, n) print(f"{n = }") print(f"{e = }") print(f"{ct = }") while True: ct = int(input("</description></item><item><title>fizzbuzz101</title><link>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz101/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz101/</guid><description>We are given the Python source code that is running on a server:
#!/usr/local/bin/python from Crypto.Util.number import * from os import urandom flag = open("flag.txt", "rb").read() flag = bytes_to_long(urandom(16) + flag + urandom(16)) p = getPrime(512) q = getPrime(512) n = p * q e = 0x10001 d = pow(e, -1, (p-1)*(q-1)) assert flag &amp;lt; n ct = pow(flag, e, n) print(f"{n = }") print(f"{e = }") print(f"{ct = }") while True: ct = int(input("</description></item><item><title>fizzbuzz102</title><link>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz102/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/fizzbuzz102/</guid><description>We are given the Python source code that is running on a server:
#!/usr/local/bin/python from Crypto.Util.number import * from os import urandom from secrets import randbits flag = open("flag.txt", "rb").read() flag = bytes_to_long(urandom(16) + flag + urandom(16)) p = getPrime(512) q = getPrime(512) n = p * q e = 0x10001 d = pow(e, -1, (p-1)*(q-1)) assert flag &amp;lt; n ct = pow(flag, e, n) a = randbits(845) b = randbits(845) def lcg(x): return (a * x + b) % n print(f"</description></item><item><title>qcg-k</title><link>https://7rocky.github.io/en/ctf/other/corctf/qcg-k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/qcg-k/</guid><description>We are provided with the Python source code to encrypt the flag:
from random import randint from Crypto.Util.number import inverse, bytes_to_long from Crypto.Util.Padding import pad from Crypto.Cipher import AES from hashlib import sha256 import os class PRNG: def __init__(self, mod): self.coeffs = [randint(1,mod) for _ in range(16)] self.mod = mod self.state = randint(1, mod) def next(self): self.state = sum(coeff * self.state**i for i,coeff in enumerate(self.coeffs)) % self.mod return self.state q = 77897050769654696452572824710099972349639759246855689360228775736949644730457 p = 16158503035655503650357438344334975980222051334857742016065172713762327569433945446598600705761456731844358980460949009747059779575245460547544076193224141560315438683650498045875098875194826053398028819192033784138396109321309878080919047169238085235290822926018152521443787945770532904303776199561965192760957166694834171210342487393282284747428088017663161029038902829665513096354230157075129296432088558362971801859230928678799175576150822952201848806616643615613562842355410104862578550863465661734839271290328348967522998634183738667876030053003528149973545862146652611656961993385485831857222177076627368030677 g = 8986665761954289500303442250714013257267958541522625625218561169199279419042595142610100040988087502082590727136475698540201993746428470373168993292913039320311763660217801850784878564935450880018874371587199649965685742134884651107493812479234148805689664214460255588413695390568080942032263992785493208738282307168575867379095610792294961396770216272833435684440954774251862518243249608047971545524864083813237641522093309769070100469565960964654622352499351408269623653746705149014123772757153278180752939277436109738789404154406479625797746665884100327134640664657032784940498017583213619767216652249367376800156 x = randint(1, q - 1) y = pow(g,x,p) kPRNG = PRNG(q) def hsh(msg): return bytes_to_long(sha256(msg).</description></item><item><title>two-wrongs</title><link>https://7rocky.github.io/en/ctf/other/corctf/two-wrongs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/corctf/two-wrongs/</guid><description>We are provided with the Python source code that encrypts the flag:
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile from qiskit_aer import AerSimulator import numpy as np import random, os, binascii, sys from Crypto.Cipher import AES from flag import flag key = os.urandom(16) cipher = AES.new(key, AES.MODE_ECB) sv_sim = AerSimulator(method="statevector") bit_idxs = list(map(int, input('Select a sensor index to remove from each bit: ').split(' '))) def enc_byte(b): sensor_vals = '' bit_encs = [] for bit in format(b, '08b'): seed = int.</description></item></channel></rss>