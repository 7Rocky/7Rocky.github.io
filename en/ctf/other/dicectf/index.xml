<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DiceCTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/dicectf/</link><description>Recent content in DiceCTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/dicectf/index.xml" rel="self" type="application/rss+xml"/><item><title>baby-talk</title><link>https://7rocky.github.io/en/ctf/other/dicectf/baby-talk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/dicectf/baby-talk/</guid><description>We are given a 64-bit binary called chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled The program gives us four options:
$ ./chall 1. str 2. tok 3. del 4. exit &amp;gt; Reverse engineering If we open the binary in Ghidra, we will see the following decompiled C code. The main function manages the options and calls the corresponding function:
int main() { ulong option; setbuf(stdout, NULL); do { while (true) { while (true) { print_menu(); printf("</description></item><item><title>winter</title><link>https://7rocky.github.io/en/ctf/other/dicectf/winter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/dicectf/winter/</guid><description>We are given the Python source code of a server:
#!/usr/local/bin/python import os from hashlib import sha256 class Wots: def __init__(self, sk, vk): self.sk = sk self.vk = vk @classmethod def keygen(cls): sk = [os.urandom(32) for _ in range(32)] vk = [cls.hash(x, 256) for x in sk] return cls(sk, vk) @classmethod def hash(cls, x, n): for _ in range(n): x = sha256(x).digest() return x def sign(self, msg): m = self.hash(msg, 1) sig = b''.</description></item><item><title>yaonet</title><link>https://7rocky.github.io/en/ctf/other/dicectf/yaonet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/dicectf/yaonet/</guid><description>We are given two files id_ecdsa, id_ecdsa.pub and a remote instance to connect using SSH:
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null yaonet@mc.ax -p 31000 -i id_ecdsa The private key id_ecdsa is corrupt:
-----BEGIN OPENSSH PRIVATE KEY----- ??????????1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAA???????????????????????? ??????????c3RwMjU2AAAACG5pc3RwMjU2AAAAQQR72Bqp???????????????????????? ??????????1hSxoXrVpRtsx1F2GIgXAqI/6MxuS7Bq86XF???????????????????????? ??????????ZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy???????????????????????? ??????????lSEQfdEcgOhx7zvWFLGhetWlG2zHUXYYiBcC???????????????????????? ??????????37PMrof3dNCpeuwsSUupbaUh3/+7+eDnRH+3???????????????????????? -----END OPENSSH PRIVATE KEY----- And the public key id_ecdsa.pub is correct:
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHvYGqk903tU4dOcBPTbZ9xl5rlSEQfdEcgOhx7zvWFLGhetWlG2zHUXYYiBcCoj/ozG5LsGrzpcXE3HuEzPEQg= yaonet We will need to fix the private key in order to connect to the remote instance and get the flag.</description></item></channel></rss>