<!doctype html><html lang="en"><head><title>cryptoGRAPHy (1, 2, 3) | 7Rocky</title>
<meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="7Rocky's Blog. Cybersecurity and Maths"><meta name="description" content="SekaiCTF 2023. Graph Encryption Scheme

1: Key leakage. Decryption

2: Single-Destination Shortest Path. Node degrees

3: Query recovery. Tree isomorphisms
"><meta name="image" content="https://7rocky.github.io/images/cryptography.png"><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,minimum-scale=1"><meta itemprop="description" content="SekaiCTF 2023. Graph Encryption Scheme

1: Key leakage. Decryption

2: Single-Destination Shortest Path. Node degrees

3: Query recovery. Tree isomorphisms
"><meta itemprop="keywords" content><meta itemprop="name" content="cryptoGRAPHy (1, 2, 3)"><meta property="article:published_time" content><meta property="og:author" content="7Rocky's Blog. Cybersecurity and Maths"><meta property="og:description" content="SekaiCTF 2023. Graph Encryption Scheme

1: Key leakage. Decryption

2: Single-Destination Shortest Path. Node degrees

3: Query recovery. Tree isomorphisms
"><meta property="og:image" content="https://7rocky.github.io/images/cryptography.png"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="7Rocky's Blog. Cybersecurity and Maths"><meta property="og:title" content="cryptoGRAPHy (1, 2, 3)"><meta property="og:type" content="website"><meta property="og:url" content="https://7rocky.github.io/en/ctf/other/sekaictf/cryptography-1-2-3/"><meta name="twitter:author" content="7Rocky's Blog. Cybersecurity and Maths"><meta name="twitter:card" content="SekaiCTF 2023. Graph Encryption Scheme

1: Key leakage. Decryption

2: Single-Destination Shortest Path. Node degrees

3: Query recovery. Tree isomorphisms
"><meta name="twitter:description" content="SekaiCTF 2023. Graph Encryption Scheme

1: Key leakage. Decryption

2: Single-Destination Shortest Path. Node degrees

3: Query recovery. Tree isomorphisms
"><meta name="twitter:image" content="https://7rocky.github.io/images/cryptography.png"><meta name="twitter:title" content="cryptoGRAPHy (1, 2, 3)"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css" integrity="sha256-MgEf5i1a74lVzhT+1R6mBbWCUeUaxC8sQTaN5GY+CoI=" crossorigin="anonymous"><link href="/css/main.css" rel="stylesheet"><link href="/css/code.css" rel="stylesheet"><link href="https://7rocky.github.io/en/ctf/other/sekaictf/cryptography-1-2-3/" rel="canonical"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z1HQGH3M4D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z1HQGH3M4D")}</script><script>MathJax={loader:{load:["[tex]/noerrors"]},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process",skipHtmlTags:["noscript","pre","script","style","textarea"]},tex:{autoload:{color:[],colorv2:["color"]},displayMath:[["$$","$$"]],inlineMath:[["$","$"]],packages:{"[+]":["noerrors"]},processEnvironments:!0,processEscapes:!0}}</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><div id="math-consts" style="display:none">$
\newcommand{\e}{e}
\newcommand{\N}[1][]{\mathbb{N}^{#1}}
\newcommand{\Q}[1][]{\mathbb{Q}^{#1}}
\newcommand{\R}[1][]{\mathbb{R}^{#1}}
\newcommand{\Z}[1][]{\mathbb{Z}^{#1}}
\newcommand{\C}[1][]{\mathbb{C}^{#1}}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\dy}{\,\mathrm{d}y}
\newcommand{\dz}{\,\mathrm{d}z}
\newcommand{\dt}{\,\mathrm{d}t}
\newcommand{\divides}{\, | \,}
\newcommand{\st}{\; | \;}
\renewcommand{\geq}{\geqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\i}{\mathrm{i}}
\newcommand{\rank}{\mathop{\mathrm{rank}}}
\newcommand{\gcd}{\mathop{\mathrm{gcd}}}
\newcommand{\lcm}{\mathop{\mathrm{lcm}}}
\newcommand{\tr}{\mathop{\mathrm{tr}}}
\newcommand{\charField}{\mathop{\mathrm{char}}}
\newcommand{\Image}{\mathop{\mathrm{Im}}}
$</div><script src="/js/imc.js"></script><script>(async()=>await typeset(()=>[`#math-consts`]))()</script></head><body class="ma0 production"><header style="position:sticky;top:0;z-index:9"><div class="bg-black"><nav class="ph4-ns" id="navigation" role="navigation"><div class="flex-l justify-between items-center center"><a class="f3 fw2 hover-white no-underline white-90 dib" href="/en/" title="7Rocky">7Rocky</a><div class="flex-l items-center"><a href="/en/search" target class="link-transition link dib z-999 pt3 pt0-l mr1 search-link" title="Search" rel="noopener" aria-label="Search"><svg height="30" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 487.95 487.95" style="enable-background:new 0 0 487.95 487.95"><g><g><path d="M481.8 453l-140-140.1c27.6-33.1 44.2-75.4 44.2-121.6C386 85.9 299.5.2 193.1.2S0 86 0 191.4s86.5 191.1 192.9 191.1c45.2.0 86.8-15.5 119.8-41.4l140.5 140.5c8.2 8.2 20.4 8.2 28.6.0C490 473.4 490 461.2 481.8 453zM41 191.4c0-82.8 68.2-150.1 151.9-150.1s151.9 67.3 151.9 150.1-68.2 150.1-151.9 150.1S41 274.1 41 191.4z" style="fill-rule:evenodd;clip-rule:evenodd;fill:#a9a9b3"/></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg>
</a><a class="link-transition lang link dib z-999 pt3 pt0-l mr3" href="/ctf/other/sekaictf/cryptography-1-2-3/" title="es"><img alt="es" height="30px" src="/images/es.png" style="border:4px solid#000;border-radius:100%" width="30px">
</a><a class="link-transition lang link dib z-999 pt3 pt0-l" href="#" title="en"><img alt="en" height="30px" src="/images/en.png" width="30px"></a><ul class="pl0 ml3 mr3" style="line-height:30px"><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/en/ctf/" title="CTF">CTF</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/en/htb/" title="HTB">HTB</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/en/imc/" title="IMC">IMC</a></li></ul><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn——Opens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
<span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub——Opens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
<span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></nav></div></header><main class="pb5" role="main" style="min-height:720px"><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-80-l"><a aria-label="aside" class="instapaper_ignoref b tracked" href="../" style="font-size:1.2rem">&lt;- SEKAICTF</a><div id="sharing" class="mt3"><a aria-label="share on Facebook" class="facebook no-underline" href="https://www.facebook.com/sharer.php?u=https://7rocky.github.io/en/ctf/other/sekaictf/cryptography-1-2-3/" title="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a><a aria-label="share on Twitter" class="twitter no-underline" href="https://twitter.com/share?url=https://7rocky.github.io/en/ctf/other/sekaictf/cryptography-1-2-3/&amp;text=cryptoGRAPHy%20%281,%202,%203%29" title="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a><a aria-label="share on LinkedIn" class="linkedin no-underline" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://7rocky.github.io/en/ctf/other/sekaictf/cryptography-1-2-3/&amp;title=cryptoGRAPHy%20%281,%202,%203%29" title="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 mt3 mb1">cryptoGRAPHy (1, 2, 3)</h1><p class="mb4 f6 dib tracked">23 minutes to read</p></header><aside aria-label="aside" class="w-20-l mt6-l aside-mobile"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contents</p><nav id="TableOfContents"><ul><li><a href="#graph-encryption-scheme">Graph Encryption Scheme</a><ul><li><a href="#understanding-the-encryption">Understanding the encryption</a></li><li><a href="#understanding-queries">Understanding queries</a></li><li><a href="#summary">Summary</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#source-code-analysis">Source code analysis</a></li><li><a href="#solution">Solution</a></li><li><a href="#flag">Flag</a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-and-node-degrees">SDSP and node degrees</a></li><li><a href="#source-code-analysis-1">Source code analysis</a></li><li><a href="#solution-1">Solution</a></li><li><a href="#flag-1">Flag</a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#source-code-analysis-2">Source code analysis</a></li><li><a href="#solution-2">Solution</a></li><li><a href="#flag-2">Flag</a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">🍺 <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img pr4-l w-80-l"><p>This series of challenges has a background on graph theory combined with cryptography. The author implemented a Python library using <a target="_blank" href="https://networkx.org/"><code>networkx</code></a> to handle graphs and cryptographyc functions such as AES cipher, HMAC or SHA256 hash.</p><p>These challenges were a bit polemic due to the fact that players needed to read, analyze and understand the implemented library for the Graph Encryption Scheme and after that implement a solution to the corresponding challenge. Fortunately, the library didn&rsquo;t change between levels. Nevertheless, some teams complained because the solution didn&rsquo;t involve much cryptography, but a lot of graph theory and programming skills.</p><p>Moreover, the first two challenges were a bit introductory to getting comfortable with the library. The last one was actually inspired by a realistic attack on a Graph Encryption Scheme, so it is way more interesting.</p><p>Anyways, I really enjoyed the challenges because they made me dust off my knowledge on graph theory and discrete math, so let&rsquo;s start!</p><h2 id="graph-encryption-scheme">Graph Encryption Scheme</h2><p>In the library, we have three files (fortunately, most functions and classes have <em>docstrings</em>):</p><ul><li><code>GES.py</code>: Implementation of graph encryption scheme</li><li><code>DES.py</code>: Implementation of dictionary encryption scheme</li><li><code>utils.py</code>: Utility functions</li></ul><h3 id="understanding-the-encryption">Understanding the encryption</h3><p>Taking a look at <code>server.py</code> from <a target="_blank" href="#cryptography-1">cryptoGRAPHy 1</a>, we can see that the server will always start by defining a graph (with <a target="_blank" href="https://networkx.org/"><code>networkx</code></a>). Then it will generate a key with <code>GESClass.keyGen</code> (which calls <code>DESClass.keyGen</code> under the hood):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key key_SKE||key_DES</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">key_DES</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Once the key is set, then the graph is encrypted using <code>GESClass.encryptGraph</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>As can be seen, the function calls <code>computeSPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>This function might be a bit difficult to understand (also, there is no <em>docstring</em>), because it calls yet another function named <code>computeSDSP</code>, which is executed inside <code>pool.istarmap</code> to speed up the process. The summary is that <code>computeSDSP</code> is called with arguments <code>G</code> and a node of the graph, for every node in the graph. This is <code>computeSDSP</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSDSP</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Graph G and a root</span>
<span class="mtk4">    Output: Tuples of the form ((start, root), (ne</span><span class="mtk4">xt_vertex, root))</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">paths</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">single_source_shortest_path</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">path</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">paths</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">():   </span>
<span class="mtk1">        </span><span class="mtk1">path</span><span class="mtk1">.reverse()</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">) </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">)</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">], </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">1</span><span class="mtk1">],</span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">S</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">S</span>
</code></pre></div><p>Again, this function might be hard to understand. The gist is that the function takes <code>root</code> as destination and computes all shortest paths to <code>root</code> from any other source node of the graph (<code>paths</code>). For each path, the different nodes of the path are inserted into a set using format <code>((node, root), (next, root))</code>. I interpret <code>((node, root), (next, root))</code> like:</p><blockquote><p><em>If I am in <code>node</code> and I want to reach <code>root</code>, i will move to <code>next</code>.</em></p></blockquote><p>In the end, the set will contain the longest shortest path to <code>root</code> in the graph. Moreover, since it is stored as <code>(label, value)</code> (where <code>label = (node, root)</code> and <code>value = (next, root)</code>), we can easily find the shortest path to <code>root</code> from any node of the graph. Actually, this is called a single-destination shortest path (SDSP).</p><p>Let&rsquo;s review function <code>computeSDPX</code> again:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>Now, for each SDSP of the graph, the <code>label</code> and <code>value</code> variables are translated to bytes (a simple translation):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">str</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">).</span><span class="mtk8">encode</span><span class="mtk1">()</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">: </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">[</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk8 mtku">int</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">])</span>  
</code></pre></div><p>Then, it uses the label (<code>label_bytes</code>) as the key of a dictionary (<code>SPDX</code>). The corresponding dictionary value is encrypted.</p><p>To encrypt the dictionary value, first a <code>token</code> is generated on <code>value_bytes</code> using <code>key_DES</code> (<code>key[16:]</code> from the first generated <code>key</code>):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">label</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a label</span>
<span class="mtk4">        Output: A token on label</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">K2</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Where <code>utils.HashMAC</code> just implements HMAC with SHA256:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Key and plaintext</span>
<span class="mtk4">    Output: A token on plaintext with the key usin</span><span class="mtk4">g HMAC</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">HMAC</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">digestmod</span><span class="mtk5">=</span><span class="mtk8 mtku">SHA256</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">update</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">digest</span><span class="mtk1">()</span>
</code></pre></div><p>So, we can assume that <code>token</code> is uniquely related to <code>value_bytes</code> (which means that for every combination of <code>(next, node)</code>, there is a single associated <code>token</code>). Observe that <code>token</code> is 32-byte long.</p><p>Continuing with encryption, <code>value_bytes</code> is encrypted with AES using <code>key_SKE</code> (<code>key[:16]</code>) as key. See <code>utils.SymmetricEncrypt</code> / <code>utils.SymmetricDecrypt</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Encrypt the plaintext using AES-CBC mode with </span><span class="mtk4">provided key.</span>  
<span class="mtk4">    Input: 16-byte key and plaintext</span>
<span class="mtk4">    Output: Ciphertext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">encrypt</span><span class="mtk1">(</span><span class="mtk8">pad</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk1">iv</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">iv</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Decrypt the ciphertex using AES-CBC mode with </span><span class="mtk4">provided key.</span>
<span class="mtk4">    Input: 16-byte key and ciphertext</span>
<span class="mtk4">    Output: Plaintext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[:</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">pt</span>
</code></pre></div><p>Notice that the IV of the AES CBC cipher is appended to the ciphertext at the end after encryption, and taken from the ciphertext for decryption.</p><p>Finally, the value that is added to <code>SPDX[label_bytes]</code> is <code>token + ct</code>.</p><p>Ok, but we have not finished yet. Recall <code>GESClass.encryptGraph</code>, we have only computed <code>SPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>The next step is to take <code>key_DES</code> (<code>key[16:]</code>) and call <code>DESClass.encryptDict</code> to actually encrypt the whole dictionary <code>SPDX</code>, which is the value to return:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">], </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a plaintext dictionary</span>
<span class="mtk4">        Output: An encrypted dictionary EDX</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">encrypted_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">        </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">)</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">encryptDictHelper</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):   </span>
<span class="mtk1">                </span><span class="mtk1">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">ct_label</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">encrypted_db</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Again, a bit weird to read, but is very similar to before. It is calling <code>encryptDictHelper</code> on <code>(key, label_bytes, token + ct)</code> for each <code>label_bytes</code> - <code>token + ct</code> mapping in the dictionary.</p><p>And <code>encryptDictHelper</code> does the following operations:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDictHelper</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">ct_label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">)</span>  
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span>
</code></pre></div><p>Notice that <code>K1</code> is <code>token[:16]</code> and <code>K2</code> is <code>token[16:]</code>. Therefore, it just outputs the SHA256 hash of <code>K1</code> and encrypts <code>token + ct</code> with AES using <code>K2</code> as key. Those will be the key-value pairs of the encrypted dictionary <code>EDB</code>.</p><h3 id="understanding-queries">Understanding queries</h3><p>There are still two methods we have not talked about yet: <code>GESClass.search</code> and <code>DESClass.search</code>. The first one calls the second one under the hood, and it is used to find the shortest path between two nodes of the graph:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">):</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token</span>
<span class="mtk4">        Output: (tokens, cts)</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span>
<span class="mtk1">        </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">token</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">curr</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[</span><span class="mtk6">32</span><span class="mtk1">:]</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">curr</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">tuple</span><span class="mtk1">([</span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">])</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">search_token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token and EDX</span>
<span class="mtk4">        Output: The corresponding encrypted value.</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">        </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">hash_val</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Basically, to search the shortest path from <code>A</code> to <code>B</code>, a <code>token</code> is generated (which identifies the label <code>(A, B)</code>) and it is searched on <code>EDB</code> (also named <code>encrypted_db</code>). Remember that <code>token = K1 + K2</code>, so the hash of <code>K1</code> is the key of the dictionary item and <code>K2</code> is the AES key to decrypt the value of the dictionary item. Only the value is returned from <code>DESClass.search</code>.</p><p>Imagine that the next node from <code>A</code> of the shortest path is <code>C</code>, then the output of <code>DESClass.search</code> in this example would be <code>token + ct</code>. This <code>token</code> would correspond to <code>(C, B)</code> and <code>ct</code> is encrypted with AES and <code>key_SKE</code>, which holds precisely <code>(C, B)</code>.</p><p>For each result of <code>DESClass.search</code>, the result is splitted into <code>token</code> and <code>ct</code> and they are both appended to <code>tok</code> and <code>resp</code>, respectively. Finally, the tuple <code>(tok, resp)</code> is returned from <code>GESClass.search</code>.</p><h3 id="summary">Summary</h3><ul><li><code>GESClass.keyGen</code>: Generates <code>key</code> as <code>key_SKE</code> and <code>key_DES</code>. Then, <code>key[:16]</code> is employed for AES encryption and <code>key[16:]</code> for HMAC</li><li>Single-destination shortest path (SDSP): It represents all the shortest paths from all nodes to a single destination. Each entry is represented as <code>((node, root), (next, root))</code>, so that they can be chained together to build a shortest path from <code>node</code> to <code>root</code></li><li><code>SPDX</code>: It is a dictionary that maps <code>(node, root)</code> with <code>token + ct</code> (related to <code>(next, root)</code>)</li><li><code>DESClass.tokenGen</code> (and <code>GESClass.tokenGen</code>): Defines a unique token for a label <code>(node, root)</code>. It is a 32-byte value composed of 16-byte values <code>K1</code> and <code>K2</code></li><li><code>EDB</code> (<code>encrypted_db</code>): It is a dictionary that maps the SHA256 hash of <code>K1</code> and the AES-encrypted value of <code>token + ct</code> using <code>K2</code> as key</li><li><code>GESClass.search</code>: Searches the shortest path from a source to a destination in the SDSP and returns the concatenation of all <code>token</code> (associated to <code>(node, root)</code>) of the path and all ciphertexts (actually, <code>token + ct</code>)</li></ul><h2 id="cryptography-1">cryptoGRAPHy 1</h2><p>We are given the source code of the server, which uses some functions from the <a target="_blank" href="#graph-encryption-scheme">Graph Encryption Scheme library</a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">260</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">16</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">node_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk9 mtki">node_count</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">) </span><span class="mtk5">&lt;</span><span class="mtk1"> </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk1">nodes</span><span class="mtk1">, </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">([</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">])</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">)</span>


<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Answer 50 queries to get the flag. In each qu</span><span class="mtk4">ery, input the shortest path </span><span class="mtk6">\</span>  
<span class="mtk4">              decrypted from response. It will be </span><span class="mtk4">a string of space-separated nodes from </span><span class="mtk6">\</span>
<span class="mtk4">              source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><p>Notice that there is a function called <code>decrypt</code> that is hidden to us.</p><h3 id="source-code-analysis">Source code analysis</h3><p>First, the server generates a random graph, generates a key (which is printed out!) and encrypts the graph:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>  
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>
</code></pre></div><p>After that, we are asked to answer 50 queries correctly to get the flag. For each query, the server will take two random nodes (<code>u</code> and <code>v</code>) of the graph that are connected and will find the shortest path between them. We will be given the <code>token</code> for <code>(u, v)</code> and the <code>resp</code> part of <code>GESClass.search</code> (the ciphertexts):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solution">Solution</h3><p>Recall from the <a target="_blank" href="#graph-encryption-scheme">Graph Encryption Scheme library</a> analysis that <code>resp</code> is AES-encrypted using <code>key_SKE</code> as key, which is <code>key[:16]</code> (we know it from the beginning). So, we can find all intermediate nodes from <code>u</code> to <code>v</code> (including <code>v</code> but not <code>u</code>) by decrypting every 32-byte chunk (16 for ciphertext and 16 for IV). The value of <code>u</code> is printed by the server, so it is not a problem here.</p><p>We can implement this easily with Python. This is the relevant code:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Key: '</span><span class="mtk1">)</span>
<span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk1">DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 50'</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'/50: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">ct_iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [(</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">]) </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">ct_iv</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">pt</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1">)[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk1">shortest_path</span><span class="mtk1">))</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'50 / 50'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="flag">Flag</h3><p>Once we run the script, we will find the flag:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3001
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3001: Done  
[<span class="code-green">+</span>] Round: 50 / 50
[+] Flag: SEKAI{GES_15_34sy_2_br34k_kn@w1ng_th3_k3y}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3001
</code></pre></div><p>The full script can be found in here: <a target="_blank" href="https://github.com/7Rocky/CTF-scripts/tree/main/SekaiCTF/cryptoGRAPHy%201/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-2">cryptoGRAPHy 2</h2><p>For this second part, we are given the source code of the server, which again uses some functions from the <a target="_blank" href="#graph-encryption-scheme">Graph Encryption Scheme library</a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_PROB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">0.031</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">32</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">() -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">fast_gnp_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">n</span><span class="mtk5">=</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk9 mtki">p</span><span class="mtk5">=</span><span class="mtk1">EDGE_PROB</span><span class="mtk1">)</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="sdsp-and-node-degrees">SDSP and node degrees</h3><p>Now, the server hides a function called <code>get_SDSP_node_degrees</code>, but at least it describes what it does:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>
</code></pre></div><p>This challenge made me understand exactly the concept of an SDSP. The drawn example might be a bit short to generalize, so let&rsquo;s draw the second example. This is the graph:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><p>Now, the destination is <code>1</code>, so let&rsquo;s find shortest paths from every node:</p><ul><li><code>2</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----</span><span class="mtk7">2</span>  
|    |    |
7----6----5
</code></pre></div><ul><li><code>4</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7">4</span><span class="mtk8">----</span><span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><ul><li><code>5</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----2</span>  
|    |    <span class="mtk8">|</span>
7----6----</span><span class="mtk7">5
</code></pre></div><ul><li><code>6</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    <span class="mtk8">|</span>    |
7----<span class="mtk7">6</span>----5
</code></pre></div><ul><li><code>7</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk8">4----</span><span class="mtk5">1</span>----2  
<span class="mtk8">|</span>    |    |
<span class="mtk7">7</span>----6----5
</code></pre></div><p>So, the SDSP is the initial graph but removing the unused edges, and it is actually a tree:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----1----2  
|    |    |
7    6    5
</code></pre></div><p>And the output of <code>get_SDSP_node_degrees</code> is a list of the degrees of each node of the SDSP (the degree of a node is the number of adjacent nodes of such node), sorted in ascending order. Therefore, the result for this example is <code>1 1 1 2 2 3</code>. We can replace the node identifiers by their corresponding degree, to illustrate the concept of the degree of a node:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">2----3----2  
|    |    |
1    1    1
</code></pre></div><h3 id="source-code-analysis-1">Source code analysis</h3><p>This time, the server does not print the <code>key</code>&mldr; We will need to obtain the output of <code>get_SDSP_node_degrees</code> a total of 10 times.</p><p>The initialization is the same as before (generate random graph, generate key and encrypt graph). After that, the server takes a random destination point, which is printed out in plaintext:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>  
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><p>The server allows us to query up to 130 times (<code>NODE_COUNT</code>, the number of nodes in the graph), and we will be given the <code>token</code> for our input <code>(u, v)</code>, as well as <code>tok</code> and <code>resp</code> from <code>GESClass.search</code> (concatenated):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>  
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solution-1">Solution</h3><p>So, we will try to find the SDSP to a given destination node. Therefore, all the queries to do must be <code>(node, root)</code>, where <code>root</code> is the given destination point.</p><p>Also, notice that there is a check <code>u != v</code>. We can use this to break the <code>while</code> loop by sending <code>(root, root)</code> at the end, when we already have the other 129 query results, and then try to guess the output of <code>getSDSP_node_degrees</code>.</p><p>For each round, we will do the following:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">data</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">NODES_SIZE</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Destination: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk1">NODES_SIZE</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">dest</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">continue</span>

<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">i</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span>] <span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>  

<span class="mtk1">        </span><span class="mtk1">data</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">b</span><span class="mtk1">: </span><span class="mtk9 mtki">b</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">(), </span><span class="mtk1">keys</span><span class="mtk1">))</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>
</code></pre></div><p>We are taking the <code>token</code>, which is related to <code>(node, root)</code>, and then we take the <code>token</code> part of the response from the server (the first half are all the 32-byte tokens for each <code>(next, root)</code> label in the shortest path). We will save them into a <code>data</code> dictionary for each node.</p><p>Also, we will use the <code>token</code> to identify each node (saved in the <code>nodes</code> list), and one of the last <code>token</code> values from <code>res</code> as the identifier for the destination (<code>(root, root)</code>).</p><p>Once we have this information, we can generate the SDSP graph by saving all possible edges into a set (following shortest paths):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">d</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">data</span><span class="mtk1">.</span><span class="mtk8">values</span><span class="mtk1">():</span>
<span class="mtk1">        </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1">, </span><span class="mtk1">next_node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">enumerate</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">:] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]]):</span>
<span class="mtk1">            </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">prev_node</span><span class="mtk1">, </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">))</span>

<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> (</span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">] </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> (</span><span class="mtk1">dest</span><span class="mtk1">, </span><span class="mtk6">0</span><span class="mtk1">):</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">(</span><span class="mtk1">edge</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
</code></pre></div><p>And the last step is to take the degrees of the nodes and sort them:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">degrees</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">sorted</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">t</span><span class="mtk1">: </span><span class="mtk9 mtki">t</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">G</span><span class="mtk1">.degree))</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Answer: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">degrees</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  
</code></pre></div><h3 id="flag-1">Flag</h3><p>We can run the script to compute the above 10 times to get the flag:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3062
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3062: Done  
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{3ff1c13nt_GES_4_Shortest-Path-Queries-_-}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3062
</code></pre></div><p>The full script can be found in here: <a target="_blank" href="https://github.com/7Rocky/CTF-scripts/tree/main/SekaiCTF/cryptoGRAPHy%202/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-3">cryptoGRAPHy 3</h2><p>For the last challenge of the series, we are given the source code of the server again:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">itertools</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">, </span><span class="mtk8 mtku">chain</span>
<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">multiprocessing</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk1">Pool</span>
<span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, generate_tree, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">60</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">128</span>
<span class="mtk1">MENU</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk4">'''============ MENU ============</span>
<span class="mtk4">1. Graph Information</span>
<span class="mtk4">2. Query Responses</span>
<span class="mtk4">3. Challenge</span>
<span class="mtk4">4. Exit</span>
<span class="mtk4">=============================='''</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_tree()</span>
<span class="mtk1">        </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Recover 10 queries in 30 seconds. It is guara</span><span class="mtk4">nteed that each answer is unique."</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">MENU</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Option: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"2"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Responses: "</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">myGES</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"3"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="source-code-analysis-2">Source code analysis</h3><p>Again, the server does not print the <code>key</code>&mldr; But instead, we are given the initial graph in plaintext (option <code>1</code>):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
</code></pre></div><p>Particularly, the graph is a tree that is generated with a hidden function called <code>generate_tree</code>. At the beginning, this was a bit weird to me, since <a target="_blank" href="https://networkx.org/"><code>networkx</code></a> has a function named <a target="_blank" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.trees.random_unlabeled_tree.html"><code>random_tree</code></a>, so there is no reason to hide it. When doing some tests in local, I found out that if two nodes are at the same level, the challenge is not solvable because those nodes can&rsquo;t be distinguished when they are encrypted. Then, looking at the tree generated by the server, there was no pair of nodes at the same level, so the challenge was solvable and the hidden function <code>generate_tree</code> discarded that situation.</p><p>In option <code>2</code>, we will be given the responses (<code>(tok, resp)</code>) to all possible queries in the graph, which has a total of 60 nodes. Therefore, we will be given a total of $60^2 = 3600$ responses. The problem is that the responses list is shuffled:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>  
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>
</code></pre></div><p>Having received all the information, we can use option <code>3</code> to begin the actual challenge: for 10 rounds, the server wil take two random nodes <code>u</code> and <code>v</code> of the graph that are connected and it will request us to enter the original query (that is, the shortest path between them). We will be given the <code>token</code> for <code>(u, v)</code> and the output of <code>GESClass.search</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solution-2">Solution</h3><p>First of all, we can take all the information from options <code>1</code> and <code>2</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Edges: '</span><span class="mtk1">)</span>
<span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk8">eval</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()))</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">()</span>

<span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">line</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()[:</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk4">'MENU'</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">line</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">break</span>

<span class="mtk1">    </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">, </span><span class="mtk1">line</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">' '</span><span class="mtk1">))</span>

<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">({</span>
<span class="mtk1">        </span><span class="mtk4">'token'</span><span class="mtk1">: </span><span class="mtk1">tok</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">(),</span>
<span class="mtk1">        </span><span class="mtk4">'tok'</span><span class="mtk1">: [</span><span class="mtk1">tok</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">32</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">tok</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)],</span>  
<span class="mtk1">        </span><span class="mtk4">'res'</span><span class="mtk1">: [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    })</span>
</code></pre></div><p>Notice how I used a <code>queries</code> list (that will contain a total of 3600 elements) with a <code>token</code>, and two lists for <code>tok</code> and <code>res</code>.</p><p>Taking a look at the <code>queries</code> list, we can find out that there are exactly 60 elements with empty <code>tok</code> and <code>res</code> lists since those queries are of the form <code>(root, root)</code>. We can use these elements to identify nodes of the graph, so let&rsquo;s separate them into another list:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">toks_0</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">]</span>  
</code></pre></div><p>Actually, each token in <code>tok_0</code> will appear in other elements of <code>queries.tok</code> lists at the last position, since <code>(root, root)</code> is a destination. As a result, we can find all <code>token</code> of the form <code>(node, root)</code> that contain a given <code>token</code> from <code>tok_0</code> in their <code>tok</code> list.</p><p>And what&rsquo;s more interesting, we can join all <code>token</code> together in a graph. Actually, this graph will be a tree. This is very important, because trees do not contain any cycle, so the path between two nodes is actually the shortest path between them. And what&rsquo;s even more mindblowing, we can find a mapping between the <code>token</code> tree and the plaintext tree we have from the beginning.</p><p>In mathematical terms, this is called a tree isomorphism, which defines a one-to-one relation between the nodes of two trees. Fortunately, <a target="_blank" href="https://networkx.org/"><code>networkx</code></a> provides a function to find a tree isomorphism (<a target="_blank" href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism.html#networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism"><code>tree_isomorphism</code></a>), so we can match each <code>token</code> to a plaintext node:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">mappings</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">define_tree</span><span class="mtk1">(</span><span class="mtk9 mtki">queries</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">][</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1">:</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">node</span><span class="mtk1">, </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]))</span>

<span class="mtk1">    </span><span class="mtk1">GG</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">isomorphism</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">tree_isomorphism</span><span class="mtk1">(</span><span class="mtk1">GG</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">enc</span><span class="mtk1">, </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">isomorphism</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">enc</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">node</span>
</code></pre></div><p>And this process must be done 60 times, since there are a total of 60 different destinations:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">toks_0</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk8">define_tree</span><span class="mtk1">([</span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">] </span><span class="mtk5">or</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]])</span>  
</code></pre></div><p>Once we have the mapping between encrypted <code>token</code> and plaintext node, we can easily find the shortest path of the query we are given by searching in the <code>mapping</code> dictionary. And that is precisely what we are doing here:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'3'</span><span class="mtk1">)</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 10'</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>

<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">key</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">shortest_path</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'10 / 10'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="flag-2">Flag</h3><p>Once we run the script we will see the flag (which points to a paper that describes this query recovery attack in much more detail):</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3023
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3023: Done
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{Full_QR_Attack_is_not_easy_https://eprint.iacr.org/2022/838.pdf}  
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3023
</code></pre></div><p>The full script can be found in here: <a target="_blank" href="https://github.com/7Rocky/CTF-scripts/tree/main/SekaiCTF/cryptoGRAPHy%203/solve.py"><code>solve.py</code></a>.</p><div class="mt6 instapaper_ignoref"></div></div><aside aria-label="aside" class="w-20-l aside-desktop"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contents</p><nav id="TableOfContents"><ul><li><a href="#graph-encryption-scheme">Graph Encryption Scheme</a><ul><li><a href="#understanding-the-encryption">Understanding the encryption</a></li><li><a href="#understanding-queries">Understanding queries</a></li><li><a href="#summary">Summary</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#source-code-analysis">Source code analysis</a></li><li><a href="#solution">Solution</a></li><li><a href="#flag">Flag</a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-and-node-degrees">SDSP and node degrees</a></li><li><a href="#source-code-analysis-1">Source code analysis</a></li><li><a href="#solution-1">Solution</a></li><li><a href="#flag-1">Flag</a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#source-code-analysis-2">Source code analysis</a></li><li><a href="#solution-2">Solution</a></li><li><a href="#flag-2">Flag</a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">🍺 <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside></article></main><footer class="bottom-0 w-100" role="contentinfo"><div class="tc mw8 ph3" style="margin:auto"><form style="background-color:var(--background-card)" class="tc mw8 pv3 mb3" action="https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter" target="popupwindow" onsubmit='return window.open("https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter"),!0'><h3 class="tc">7Rocky's Blog Weekly Newsletter</h3><p class="tc"><input class="f5 pv3 ph3 bn" style="background-color:var(--background);color:inherit;font-weight:700;line-height:normal" type="submit" value="Receive a weekly blog digest"></p><input type="hidden" value="1" name="embed">
<input style="display:none;color:var(--header)" type="submit" value="Subscribe"><p class="tc"><a href="/en/newsletters/" target="_blank" title="View letter archive">View letter archive</a></p><p class="tc">powered by <a href="http://www.mailchimp.com" target="_blank" title="Mailchimp">Mailchimp</a></p></form></div><div class="bg-black w-100 pa3" role="contentinfo"><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://7rocky.github.io/" title="https://7rocky.github.io/">&copy; 7Rocky's Blog. Cybersecurity and Maths 2024</a><div style="margin-top:8px"><div><div><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn——Opens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
<span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub——Opens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
<span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></div></div></div></footer></body></html>