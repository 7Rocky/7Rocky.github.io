<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB UniCTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/</link><description>Recent content in HTB UniCTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/htb-unictf/index.xml" rel="self" type="application/rss+xml"/><item><title>AESWCM</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/aeswcm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/aeswcm/</guid><description>We got the Python source code of the server:
from Crypto.Util.Padding import pad from Crypto.Cipher import AES import os import random from secret import FLAG KEY = os.urandom(16) IV = os.urandom(16) class AESWCM: def __init__(self, key): self.key = key self.cipher = AES.new(self.key, AES.MODE_ECB) self.BLOCK_SIZE = 16 def pad(self, pt): if len(pt) % self.BLOCK_SIZE != 0: pt = pad(pt, self.BLOCK_SIZE) return pt def blockify(self, message): return [ message[i:i + self.BLOCK_SIZE] for i in range(0, len(message), self.</description></item><item><title>Bank-er-smith</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/bank-er-smith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/bank-er-smith/</guid><description>We got the Python source code of the server:
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = """ ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ """ class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.</description></item><item><title>BatchCraft Potions</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/batchcraft-potions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/batchcraft-potions/</guid><description>We are given this website:
Static code analysis We are provided with the JavaScript source code of the web application, built with Node.js and Express JS. This is index.js:
const express = require('express'); const app = express(); const path = require('path'); const cookieParser = require('cookie-parser'); const nunjucks = require('nunjucks'); const routes = require('./routes'); const Database = require('./database'); global.db = new Database(); app.use(express.json()); app.use(cookieParser()); nunjucks.configure('views', { autoescape: true, express: app }); app.</description></item><item><title>Curse Breaker</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/curse-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/curse-breaker/</guid><description>We are given a binary called breaker:
$ file breaker breaker: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=276c71525dd765da538440a4615fa5b717e331ad, for GNU/Linux 3.2.0, not stripped Reverse engineering Using Ghidra, we can read the decompiled source code in C. This is the main function:
int main() { size_t newline_index; long i5; char magic_word[50]; uint i; magic_word._0_8_ = 0; magic_word._8_8_ = 0; magic_word._16_8_ = 0; magic_word._24_8_ = 0; magic_word.</description></item><item><title>Fake News</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/fake-news/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/fake-news/</guid><description>We are given a folder named html with a lot files from a WordPress server:
$ ls index.php wp-activate.php wp-blogs wp-config-sample.php wp-cron.php wp-load.php wp-settings.php xmlrpc.php license.txt wp-admin wp-comments-post.php wp-config.php wp-includes wp-login.php wp-signup.php readme.html wp-blog-header.php wp-config-docker.php wp-content wp-links-opml.php wp-mail.php wp-trackback.php Basic inspection Obviously, wp-blogs stands out, so let&amp;rsquo;s examine files that are inside:
$ ls wp-blogs 2022 $ ls wp-blogs/2022/ 11 $ ls wp-blogs/2022/11/ index.php style.css $ du -h wp-blogs/2022/11/* 304K wp-blogs/2022/11/index.</description></item><item><title>Great Old Talisman</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/great-old-talisman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/great-old-talisman/</guid><description>We are given a 64-bit binary called great_old_talisman:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Reverse engineering If we open the binary in Ghidra, we will see this decompiled C source code for the main function:
void main() { long in_FS_OFFSET; int n; undefined8 canary; canary = *(undefined8 *) (in_FS_OFFSET + 0x28); setup(); banner(); printf("\nThis Great Old Talisman will protect you from the evil powers of zombies!</description></item><item><title>Mayday Mayday</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/mayday-mayday/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/mayday-mayday/</guid><description>We are given the Python source code to encrypt the flag:
from Crypto.Util.number import getPrime, GCD, bytes_to_long from secret import FLAG from random import randint class Crypto: def __init__(self, bits): self.bits = bits self.alpha = 1/9 self.delta = 1/4 self.known = int(self.bits*self.delta) def keygen(self): while True: p, q = [getPrime(self.bits//2) for _ in '__'] self.e = getPrime(int(self.bits*self.alpha)) φ = (p-1)*(q-1) try: dp = pow(self.e, -1, p-1) dq = pow(self.e, -1, q-1) self.</description></item><item><title>MSS</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/mss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/mss/</guid><description>We are given the Python source code of the server:
import os, random, json from hashlib import sha256 from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secret import FLAG class MSS: def __init__(self, BITS, d, n): self.d = d self.n = n self.BITS = BITS self.key = bytes_to_long(os.urandom(BITS//8)) self.coeffs = [self.key] + [bytes_to_long(os.urandom(self.BITS//8)) for _ in range(self.d)] def poly(self, x): return sum([self.coeffs[i] * x**i for i in range(self.</description></item><item><title>MSS Revenge</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/mss-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/mss-revenge/</guid><description>This challenge is the same as MSS, with a patched unintended solution.
Review of the challenge The server creates a polynomial with random 256-bit coefficients:
$$ P(x) = \mathrm{key} + a_1 x + a_2 x^2 + \dots + a_{30} x^{30} $$ The objective is to find $\mathrm{key}$, which is used to derive an AES key to encrypt the flag. The server allows us to evaluate the polynomial 19 times with values of $0 &amp;lt; x \leqslant 2^{15}$.</description></item><item><title>Potion Master</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/potion-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/potion-master/</guid><description>We are given a Haskell script called potion.hs:
import Data.Char (ord) import Data.Bits (xor) -- Complete the incantation... flag = "HTB{XXX}" extractFlag :: String -&amp;gt; String extractFlag (s:rest) | s == 'H' || s == 'T' || s == 'B' = extractFlag rest | s == '{' &amp;&amp; last rest == '}' = init rest | otherwise = error ("Invalid format") chunks :: Int -&amp;gt; [a] -&amp;gt; [[a]] chunks n l | n == 0 = [] | n == 1 = [[x] | x &amp;lt;- l] | length l &amp;lt;= n = [l] | otherwise = [take n l] ++ (chunks n (drop n l)) takeLast :: Int -&amp;gt; [a] -&amp;gt; [a] takeLast n = reverse .</description></item><item><title>RiseFromTheDead</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/risefromthedead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/risefromthedead/</guid><description>We are given a 64-bit binary called rise and also a core file:
$ file * core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './rise flag', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './rise', platform: 'x86_64' rise: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8341bf2064b7903b6e87d69c63a1849338d3f1e6, for GNU/Linux 3.2.0, not stripped The core file corresponds to an execution of rise (actually, the command was .</description></item><item><title>Sacred Scrolls</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/sacred-scrolls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/sacred-scrolls/</guid><description>We are given a 64-bit binary called sacred_scrolls:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering If we open the binary in Ghidra, we will see this decompiled C source code for the main function:
void main() { undefined8 *puVar1; long i; byte bVar2; undefined wizard_tag[1528]; undefined8 uStack_110; undefined8 target; undefined8 local_100; undefined8 local_f8; undefined8 local_f0; undefined8 local_e8; undefined8 local_e0; undefined8 local_d8; undefined8 local_d0; undefined8 local_c8; undefined8 local_c0; undefined8 local_b8; undefined8 local_b0; undefined8 local_a8; undefined8 local_a0; undefined8 local_98; undefined8 local_90; undefined8 local_88; undefined8 local_80; undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined8 local_60; undefined8 local_58; undefined8 local_50; undefined8 local_48; undefined *wizard_tag_copy; undefined8 local_38; undefined4 local_2c; bVar2 = 0; uStack_110 = 0x400ecc; setup(); uStack_110 = 0x400ed1; banner(); uStack_110 = 0x400edb; clean(); uStack_110 = 0x400eec; printf("</description></item><item><title>Sacred Scrolls' Revenge</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/sacred-scrolls-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/sacred-scrolls-revenge/</guid><description>This challenge is a fixed version of Sacred Scrolls. Almost all the program behavior is the same as in the previous version, so read that write-up before this one.
They fixed the challenge due to an unintended solution (command injection):
$ ./sacred_scrolls ▄▞▀▀▀▜▄▖ ▗ ▖ ▗ ▖ ▗ ▖▟▞▖▘▗▖▚▘ ▝▀▄ ▖▝ ▘ ▝ ▝ ▝ ▘ ▝ ▝ ▝ ▘ ▝ ▖▌▀ ▖▖▚▘▝▗▝▝ ▗▝▄▖▘ ▘ ▗▗▞▘▚▝▝▝▗▝ ▘ ▖ ▗▚▖ ▗ ▖ ▗ ▗ ▖▗▄▜▝▚▝▝▖▘▘▝ ▖ ▖ ▘ ▗ ▖▛▞ ▖ ▖▘ ▖ ▗ ▘ ▖ ▗▝ ▗▄▞▚▗▗▘ ▝ ▖ ▖ ▖▘▀▀▖ ▖ ▗▖▛▚▗▝ ▖ ▗ ▝ ▝ ▘ ▖ ▘▗▗▗▝▌ ▗ ▗▄▞▀▚▝ ▖ ▖▝ ▖▝ ▖▗ ▖▘▝▗▗▄▞▘ ▖ ▝ ▗ ▖ ▄▞▀▚▗▝▝ ▖ ▘ ▘ ▗▝ ▖ ▘▗▗▝▖▞▞▌▜▐▐▖ ▗ ▘▄▖▀▀▗▝▝▗ ▝ ▗ ▘ ▖▖▘▖▝▗ ▚▝▖▖▌▌▌▙▞▌▀ ▘ ▄▞▞▀▗▝▞▝▖▝ ▘▝ ▖▘▖▖▘▞▝▖▚▚▐▐▟▟▞▘▘ ▖▝ ▄▖▛▀▖▞▖▌▘▘▝▖ ▖▝ ▗ ▝ ▖▗ ▘▖▖▖▞▐▗▚▚▙▙▛▀▝ ▄▄▜▚▙▄▄▀▝▗ ▄▝▝▘ ▘ ▘ ▘ ▗ ▖▗ ▝▖▄▐▐▐▟▟▜▜▝ ▘ ▐▟▛█▜▚▚▚▞▄▖▘ ▖ ▗ ▗ ▘▝ ▖▗▗▐▝▄▟▞▙█▐▝ ▐▚▛▞▜▚▟ ▝▚▚ ▘▝ ▝ ▝▗ ▖▘ ▗▝▝▖▞▖▌▙▜▙▙▀▘ ▗ ▝ ▗ ▘ ▜▐▚▐▐▜▟█▖ ▀▙▖▗ ▖▗▝ ▖▗ ▖▘▖▞▞▟▞▛▛▟▀ ▗ ▘ ▖ ▝▛▗ ▖▌▙▙█▘ ▗▚ ▖▗ ▗▗▗▗▚▐▐▐▞▛▟▞▛▝ ▗▝ █ ▖▗▀▝▝▛█▗ ▜▘▖▗▝▗▗▚▚▚▙▜▞▙▜▝ ▝ ▘ ▗ ▖ ▐▖▖ ▚ ▚▜▜▖▞▐▚▗▗▐▗▜▞▛▙▚▙▀ ▝ ▗ ▘ ▗ ▚▝▖▚▚▖▀▛▞▐▟▚▘▌▌▛▙▜▟▝▘ ▗ ▗ ▗ ▝▌▝▖▌▜▚▛▟█▛▙▜▞▛▛▞▘ ▖ ▝ ▖ ▗▝ ▘ ▝▙▗▐▐▐▜▜▙█▞▟▞▛▝ ▗ ▖ ▗ ▗ ▝ ▝▘▌▖▖▙▀▙▜▚▜▝ ▗ ▘ ▝▀▗▀▞▞▘▘ ▝ ▘ ▗▝ ▗ ▝ ▝ ▝ ▗▝ ▘ ▝ ▝ ▖▝ ▘ ▝ [+] All ⅀ ℙ ∉ ⎳ ⎳ ⅀ have been whiped out.</description></item><item><title>Spellbook</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/spellbook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/spellbook/</guid><description>We are given a 64-bit binary called spellbook:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Reverse engineering If we open the binary in Ghidra, we will see this decompiled C source code for the main function:
void main() { size_t option; setup(); banner(); while (true) { while (true) { while (option = menu(), option == 2) { show(); } if (option &amp;lt; 3) break; if (option == 3) { edit(); } else { if (option !</description></item><item><title>The Magic Informer</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/the-magic-informer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/the-magic-informer/</guid><description>We are given this website:
This time we don&amp;rsquo;t have source code available, so we must poke around with the website.
Registering a new account At the bottom of the page we can find a link to a registration form:
So we can register and then log in:
And we get access to our dashboard:
Directory Traversal and Local File Read We can try common injections in the above form. The key is in the file upload input.</description></item><item><title>Zombie Rolled</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/zombie-rolled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/zombie-rolled/</guid><description>We are given the Python source code to encrypt the flag:
from Crypto.Util.number import getPrime, bytes_to_long from fractions import Fraction from math import prod from hashlib import sha256 from secrets import randbelow # I hope no one cares about Kerckhoff's principle :) from secret import derive_public_key, FLAG def fraction_mod(f, n): return f.numerator * pow(f.denominator, -1, n) % n class PublicKey: def __init__(self, pub): self.pub = pub self.f = self.magic(pub) self.nb = (self.</description></item><item><title>Zombiedote</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/zombiedote/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/zombiedote/</guid><description>We are given a 64-bit binary called zombiedote:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Reverse engineering We have a typical menu for a heap exploitation challenge:
$ ./zombiedote [ BioShield Solutions Research Institute ] Virus Concentration Levels Logging - Manual Mode: ON [ MANUAL MODE LOGGING ] [1] Create log [2] Insert into log [3] Delete log [4] Edit log [5] Inspect log &amp;gt;&amp;gt; If we open the binary in Ghidra, we will see the decompiled C scource code for program.</description></item><item><title>Zombienator</title><link>https://7rocky.github.io/en/ctf/other/htb-unictf/zombienator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-unictf/zombienator/</guid><description>We are given a 64-bit binary called zombienator:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Reverse engineering If we open the binary in Ghidra, we will see this decompiled C source code for the main function:
void main() { ulong option; banner(); while (true) { while (true) { while (true) { printf("\n##########################\n# #\n# 1. Create Zombienator #\ n# 2. Remove Zombienator #\n# 3.</description></item></channel></rss>