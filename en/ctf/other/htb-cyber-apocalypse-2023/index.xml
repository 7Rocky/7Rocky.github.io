<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB Cyber Apocalypse 2023 on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/</link><description>Recent content in HTB Cyber Apocalypse 2023 on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/alien-saboteaur/</guid><description>Coming soon</description></item><item><title>Artifacts of Dangerous Sightings</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/artifacts-of-dangerous-sightings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/artifacts-of-dangerous-sightings/</guid><description>We are given a Windows disk image inside a folder called HostEvidence_PANDORA:
$ file HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx: Microsoft Disk Image eXtended, by .NET DiscUtils, sequence 0x8, NO Log Signature; region, 2 entries, id Metadata, at 0x200000, Required 1, id BAT, at 0x300000, Required 1 If we switch to a Windows machine and mount the disk image, we will have the following folders:
Analyzing the disk image Basically, it is the C:\ drive of a Windows machine.</description></item><item><title>Bashic Ransomware</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/bashic-ransomware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/bashic-ransomware/</guid><description>We are given these files:
$ file * flag.txt.a59ap: GPG symmetrically encrypted data (AES256 cipher) forensics.mem: data linux-image-5.10.0-21.zip: Zip archive data, at least v2.0 to extract, compression method=deflate traffic.pcap: pcapng capture file - version 1.0 We can guess that we will need to analyze a compromised Linux machine because we are given a memory dump (forensics.mem) and a profile for volatility.
Network traffic analysis Let&amp;rsquo;s start using Wireshark to analyze the PCAP:</description></item><item><title>Biased Heritage</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/biased-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/biased-heritage/</guid><description>This challenge is kind of a continuation of Colliding Heritage. We are provided with the server source code in Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????????????????}" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.</description></item><item><title>Calibrator</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/calibrator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/calibrator/</guid><description>We are given a remote instance to connect to:
$ nc 165.227.224.40 31139 [OK] Memory check [OK] Syncing filesystem [OK] Detecting sensors [OK] Module loader [OK] Reading configurations Inititing calibration process ... ┌──────────────────────────────────────────────────────────────────────┐ │┼───────────────────┼────────────────────────┼┼──────────────────────┼│ ││ XenoCal 2000 │ . ││ ││ │┼───────────────────┤ ┌─┐ x││ . . ││ ││ Iteration: 42 │ x ► └─┘ ││ x ││ │┼─────────┬─────────┤ ││ ││ ││ X:1337 │ Y:65189 │ . x ┌───┼┼───┐ ││ │┼─────────┴─────────┘ x ┌─┘ ││ └─┐ x ││ ││ .</description></item><item><title>Colliding Heritage</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/colliding-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/colliding-heritage/</guid><description>We are provided with the server source code in Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????}" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.</description></item><item><title>Control Room</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/control-room/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/control-room/</guid><description>We are given a 64-bit binary called control_room:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Setup environment We are also provided with the remote Glibc library:
$ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Converging Visions</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/converging-visions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/converging-visions/</guid><description>We are provided with the server source code in Python:
from secret import FLAG, p, a, b from sage.all_cmdline import * class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.</description></item><item><title>Didactic Octo Paddles</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/didactic-octo-paddles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/didactic-octo-paddles/</guid><description>We are given a website like this:
We also have the source code in Node.js.
Source code analysis The web application is built with Express JS. After reading some files, one that stands out is middlewares/AdminMiddleware.js:
const jwt = require("jsonwebtoken"); const { tokenKey } = require("../utils/authorization"); const db = require("../utils/database"); const AdminMiddleware = async (req, res, next) =&amp;gt; { try { const sessionCookie = req.cookies.session; if (!sessionCookie) { return res.redirect("/login"); } const decoded = jwt.</description></item><item><title>Elliptic Labyrinth</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth/</guid><description>We are provided with the server source code in Python:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print("1. Get parameters of path"</description></item><item><title>Elliptic Labyrinth Revenge</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth-revenge/</guid><description>This challenge is Elliptic Labyrinth modified to force CTF players use the intended way to solve the challenge.
Finding differences The provided source code is a bit different:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.</description></item><item><title>Hijack</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/hijack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/hijack/</guid><description>We are given a remote instance to connect to:
$ nc 167.71.143.44 31614 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; Basic recognition We have two options. Using the first one, we can set some configuration and the output is a Base64-encoded string:
$ nc 165.232.100.46 31251 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; 1 - Creating new config - Temperature units (F/C/K): C Propulsion Components Target Temperature : 13 Solar Array Target Temperature : 37 Infrared Spectrometers Target Temperature : 0 Auto Calibration (ON/OFF) : ON Serialized config: ISFweXRob24vb2JqZWN0Ol9fbWFpbl9fLkNvbmZpZyB7SVJfc3BlY3Ryb21ldGVyX3RlbXA6ICcwJywgYXV0b19jYWxpYnJhdGlvbjogJ09OJywKICBwcm9wdWxzaW9uX3RlbXA6ICcxMycsIHNvbGFyX2FycmF5X3RlbXA6ICczNycsIHVuaXRzOiBDfQo= Uploading to ship.</description></item><item><title>HM74</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/hm74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/hm74/</guid><description>We are given this Verilog hardware description code:
module encoder( input [3:0] data_in, output [6:0] ham_out ); wire p0, p1, p2; assign p0 = data_in[3] ^ data_in[2] ^ data_in[0]; assign p1 = data_in[3] ^ data_in[1] ^ data_in[0]; assign p2 = data_in[2] ^ data_in[1] ^ data_in[0]; assign ham_out = { p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0] }; endmodule module main; wire[3:0] data_in = 5; wire[6:0] ham_out; encoder en(data_in, ham_out); initial begin #10; $display("</description></item><item><title>Inside The Matrix</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/inside-the-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/inside-the-matrix/</guid><description>We are given the source code of the server in Python:
from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b"HTB{????????????????????}" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.</description></item><item><title>Interstellar C2</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/interstellar-c2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/interstellar-c2/</guid><description>We are given a PCAP file called capture.pcapng. Let&amp;rsquo;s open it in Wireshark:
As always, it is nice to start analyzing top-level protocols like HTTP, so let&amp;rsquo;s apply a filter:
The first request is trying to download a PowerShell script called vn84.ps1:
PowerShell deobfuscation We can take the script from Wireshark and read it here:
.("{1}{0}{2}" -f'T','Set-i','em') ('vAriA'+'ble'+':q'+'L'+'z0so') ( [tYpe]("{0}{1}{2}{3}" -F'SySTEM.i','o.Fi','lE','mode')) ; &amp;amp;("{0}{2}{1}" -f'set-Vari','E','ABL') l60Yu3 ( [tYPe]("{7}{0}{5}{4}{3}{1}{2}{6}"-F'm.','ph','Y.ae','A','TY.crypTOgR','SeCuRi','S','sYSte')); .("{0}{2}{1}{3}" -f 'Set-V','i','AR','aBle') BI34 ( [TyPE]("</description></item><item><title>Janken</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/janken/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/janken/</guid><description>We are given a binary file called janken and a remote instance to connect to:
$ file janken janken: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, BuildID[sha1]=56b54cdae265aa352fe2ebb016f86af831fd58d3, for GNU/Linux 3.2.0, not stripped If is a Rock-Paper-Scissors game:
$ nc 167.99.86.8 31902 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▌ じ ゃ ん 拳 ▐ ▙▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▟ 1. ℙ ∟ ₳ Ұ 2. ℜ ℧ ∟ Ӗ ⅀ &amp;gt;&amp;gt; 2 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▚ [*] Rock is called "</description></item><item><title>Labyrinth</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/labyrinth/</guid><description>We are given a 64-bit binary called labyrinth:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering If we open it im Ghidra, we will see this main function in decompiled C code:
int main() { int ret; char *__s; char data[32]; ulong i; setup(); banner(); data._0_8_ = 0; data._8_8_ = 0; data._16_8_ = 0; data._24_8_ = 0; fwrite("\nSelect door: \n\n"</description></item><item><title>Math Door</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/math-door/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/math-door/</guid><description>We are given a 64-bit binary called math-door:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' Setup environment We are also provided with the remote Glibc library and loader:
$ ./ld.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Multipage Recyclings</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/multipage-recyclings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/multipage-recyclings/</guid><description>We are provided with the server source code in Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.</description></item><item><title>nehebkaus trap</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/nehebkaus-trap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/nehebkaus-trap/</guid><description>We are given a remote instance to connect to:
$ nc 167.71.143.44 32139 __ {00} \__/ /^/ ( ( \_\_____ (_______) (_________()Ooo. [ Nehebkau's Trap ] You are trapped! Can you escape? &amp;gt; Basic recognition We are allowed to enter some information, but it shows an error:
&amp;gt; asdf [*] Input accepted! Error: name 'asdf' is not defined The error message looks familiar to a Python REPL:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; asdf Traceback (most recent call last): File "</description></item><item><title>Orbital</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/orbital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/orbital/</guid><description>We are given a website like this:
We also have the source code in Python.
Source code analysis The web application is built with Flask. A clear SQL injection (SQLi) vulnerability can be found at database.py:
from colorama import Cursor from application.util import createJWT, passwordVerify from flask_mysqldb import MySQL mysql = MySQL() def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.</description></item><item><title>Pandora's Bane</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/pandoras-bane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/pandoras-bane/</guid><description>Coming soon</description></item><item><title>Pandora's Box</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/pandoras-box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/pandoras-box/</guid><description>We are given a 64-bit binary called pb:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering We can use Ghidra to analyze the binary and look at the decompiled source code in C:
int main() { setup(); cls(); banner(); box(); return 0; } Among others, this function calls box:
void box() { long num; char data [32]; data._0_8_ = 0; data.</description></item><item><title>Passman</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/passman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/passman/</guid><description>We are given a website like this:
We also have the source code in Node.js.
Source code analysis The web application is built with Express JS. A relevant file is routes/index.js:
const express = require('express'); const router = express.Router(); const { graphqlHTTP } = require('express-graphql'); const AuthMiddleware = require('../middleware/AuthMiddleware'); const GraphqlSchema = require('../helpers/GraphqlHelper'); router.get('/', (req, res) =&amp;gt; { return res.render('login.html'); }); router.get('/register', (req, res) =&amp;gt; { return res.render('register.html'); }); router.use('/graphql', AuthMiddleware, graphqlHTTP({ schema: GraphqlSchema, graphiql: false })); router.</description></item><item><title>Relic Maps</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/relic-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/relic-maps/</guid><description>We have this description for the challenge:
Pandora received an email with a link claiming to have information about the location of the relic and attached ancient city maps, but something seems off about it. Could it be rivals trying to send her off on a distraction? Or worse, could they be trying to hack her systems to get what she knows?Investigate the given attachment and figure out what&amp;rsquo;s going on and get the flag.</description></item><item><title>Restricted</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/restricted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/restricted/</guid><description>We are given a remote instance to connect to:
$ nc 64.227.41.83 30543 SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1 Invalid SSH identification string. Ncat: Broken pipe. It looks like we must access via SSH.
SSH connection We are also given some files:
$ tree . ├── Dockerfile ├── build_docker.sh └── src ├── bash_profile ├── flag.txt └── sshd_config 2 directories, 5 files Loooking at the Dockerfile, we see that the user is named restricted and we will be using rbash (restricted Bash):</description></item><item><title>Roten</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/roten/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/roten/</guid><description>We are given a PCAP file (challenge.pcap) with a lot of network packets:
Finding the attack vector First of all, let&amp;rsquo;s filter by HTTP to read only high-level network packets:
The attacker is poking around with the website. For instance, they are trying to use POST parameters:
If we go to the end of the packet capture, we will see that the attackers are executing system commands:
In the above ls command, we see a file called galacticmap-php that looks suspicious.</description></item><item><title>Small StEps</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/small-steps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/small-steps/</guid><description>We are given a remote instance to connect to:
$ nc 188.166.152.84 32213 This is the second level of training. [E]ncrypt the flag. [A]bort training. &amp;gt; We are also provided with the server&amp;rsquo;s Python source code:
from Crypto.Util.number import getPrime, bytes_to_long FLAG = b"HTB{???????????????}" assert len(FLAG) == 20 class RSA: def __init__(self): self.q = getPrime(256) self.p = getPrime(256) self.n = self.q * self.p self.e = 3 def encrypt(self, plaintext): plaintext = bytes_to_long(plaintext) return pow(plaintext, self.</description></item><item><title>SpyBug</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/spybug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/spybug/</guid><description>We are given a website like this:
We also have the source code of the web application in Node.js and the source code of an agent in Go.
Source code analysis The web application is built with Express JS. In index.js we can see a Content Security Policy (CSP) header and a function visitPanel that runs every minute:
application.use((req, res, next) =&amp;gt; { res.setHeader("Content-Security-Policy", "script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';"</description></item><item><title>TrapTrack</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/traptrack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/traptrack/</guid><description>We are given a website like this:
We are also given the source code of the project.
Website functionality The web application allows us to enter URLs that will be stored in a SQLite database. Just reading the code from challenge/application/config.py, we have valid credentials (admin:admin):
from application.util import generate import os class Config(object): SECRET_KEY = generate(50) ADMIN_USERNAME = 'admin' ADMIN_PASSWORD = 'admin' SESSION_PERMANENT = False SESSION_TYPE = 'filesystem' SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/database.</description></item><item><title>Void</title><link>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/void/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/void/</guid><description>We are given a 64-bit binary called void:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Reverse engineering If we use Ghidra, we will find this decompiled C code:
void vuln() { char data[64]; read(0, data, 200); } int main() { vuln(); return 0; } The code is very short and there is only a single point to enter data.</description></item></channel></rss>