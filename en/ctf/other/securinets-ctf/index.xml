<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Securinets CTF on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/other/securinets-ctf/</link><description>Recent content in Securinets CTF on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/other/securinets-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>scrambler</title><link>https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/</guid><description>We are given a 64-bit binary called scrambler:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) We also have the remote Glibc binary (libc.so_1.6), so we can use pwninit to patch the binary and use the provided library, so that the local and the remote exploits are equal:
$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.31-0ubuntu9.7_amd64.deb unstripping libc https://launchpad.</description></item></channel></rss>