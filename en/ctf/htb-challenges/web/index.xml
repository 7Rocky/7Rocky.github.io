<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on 7Rocky</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/</link><description>Recent content in Web on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>Amidst Us</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</guid><description>We have the following website, that mimics the game Among Us:
There is a button to select a color with a color picker:
If we analyze the given source code, we have a Flask application (in Python). This is application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) The function make_alpha is defined in application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</guid><description>We have a Flask web application that allows us to render other websites inside it as an image:
Behind the hoods, the server is launching a Headless Chrome with selenium, accessing the site we provided and taking a screenshot to show it. Here is an example:
The objective is to reach the endpoint /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') However, it is protected by checking that the request is done from 127.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>We are provided with this web page:
There is an HTML comment on the index.html that points to a debugging URL (/debug):
In this /debug endpoint, the source code is found:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</guid><description>We have a website where we can write Markdown and transform the document to PDF:
By default, we have this Markdown content:
As we have a Node.js project, if we read package.json we can see the versions of the third-party dependencies:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>Gunship</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</guid><description>We have a website with a nice style:
There is only one user input:
This is a Node.js application that uses pug as a template renderer (as shown in the available files from the challenge).
It also uses flat to parse JSON data, as shown in the following file called routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</guid><description>We are given a PHP web application with a single functionality, that is to post an email address.
We can start by analyzing the source code. The file index.php shows that there are only two endpoints (GET and POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); We can see that Database.</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</guid><description>We are provided with this web page:
It shows a directory listing. If we go to /mailer.php we will have this website to send emails:
The mailer.zip file contains the mailer.php source code. It is quite large to insert it here.
The key thing is that it uses PHPMailer, which is vulnerable to CVE-2016-10033 and CVE-2016-10045. In fact, there are public exploits like the one in www.exploit-db.com.
Basically, the exploit says to enter this payload as the email:</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</guid><description>We are given a website like this:
We must register a new account and login to view a nice dashboard:
The only functionality we have is to export the SVG images we see as PNG files. We can capture the request with Burp Suite:
After some research, we can see that there is a vulnerability regarding SVG conversion that leads to Local File Read (more information at security.snyk.io).
We will need to use the following payload to read /etc/passwd as a PNG image:</description></item><item><title>Red Island</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</guid><description>We are given a website like this:
We can register a new account and then login to see this functionality:
This time we don&amp;rsquo;t have the source code for the web application, so we must find a clear vulnerability or get the source code somehow.
We can start thinking of Server-Side Request Forgery (SSRF). As in other challenges, we know that the web server listens on port 1337, so let&amp;rsquo;s try and get http://127.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</guid><description>We have a simple web back-end that allows us to upload a .tar.gz file. As we have a Dockerfile, let&amp;rsquo;s use a Docker container locally:
On the source code we have a simple Python Flask application:
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 The file is being extracted and written to /tmp:
import tarfile, tempfile, os from application import main generate = lambda x: os.</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>We are given the source code of a Node.js web project using Express JS and MySQL. In the Dockerfile an entrypoint.sh script is run:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item></channel></rss>