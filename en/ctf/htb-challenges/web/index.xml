<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on 7Rocky</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/</link><description>Recent content in Web on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>Amidst Us</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/amidst-us/</guid><description>We have the following website, that mimics the game Among Us:
There is a button to select a color with a color picker:
If we analyze the given source code, we have a Flask application (in Python). This is application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) The function make_alpha is defined in application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.</description></item><item><title>baby auth</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-auth/</guid><description>We are provided with this webpage:
First, we can register a new account (asdf as username):
And we are told that we are not admin. In fact, the authentication is handled with session cookies:
The session cookie looks encoded in Base64, so let&amp;rsquo;s try to decode it (beware of URL encoding):
$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {"username":"asdf"} It shows our username, so maybe we can modify the cookie and get access as admin:</description></item><item><title>baby BoneChewerCon</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-bonechewercon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-bonechewercon/</guid><description>We are provided with this webpage:
At the bottom of the page we have a text input. Let&amp;rsquo;s enter something and submit.
It shows an error in the Laravel debugger (a PHP framework):
This is a bad practice and a security issue, since debuggers might contain sensitive information and most of them provide ways to execute code.
Flag Indeed, we can find the flag in an environment variable named APP_KEY (HTB{wh3n_th3_d3bugg3r_turns_4g41nst_th3_d3bugg33}):</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-cachedview/</guid><description>We have a Flask web application that allows us to render other websites inside it as an image:
Behind the hoods, the server is launching a Headless Chrome with selenium, accessing the site we provided and taking a screenshot to show it. Here is an example:
The objective is to reach the endpoint /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') However, it is protected by checking that the request is done from 127.</description></item><item><title>baby interdimensional internet</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-interdimensional-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-interdimensional-internet/</guid><description>We are provided with this webpage:
If we look into the HTML source code, we see /debug:
And there we can find the source code of the web application:
fromflaskimportFlask, Response, request, render_template, request fromrandomimportchoice, randint fromstringimportlowercase fromfunctoolsimportwraps app=Flask(__name__) defcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass defGCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) deffederation(*args, **kwargs): ingredient=''.join(choice(lowercase) for_inrange(10)) recipe='%s= %s'%(ingredient, ''.join(map(str, [randint(1, 69), choice(['+', '-', '*']), randint(1,69)]))) ifrequest.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>We are provided with this web page:
There is an HTML comment on the index.html that points to a debugging URL (/debug):
In this /debug endpoint, the source code is found:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/blinkerfluids/</guid><description>We have a website where we can write Markdown and transform the document to PDF:
By default, we have this Markdown content:
As we have a Node.js project, if we read package.json we can see the versions of the third-party dependencies:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>Cursed Secret Party</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/cursed-secret-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/cursed-secret-party/</guid><description>We are given this website:
Static code analysis We are provided with the JavaScript source code of the web application, built in Node.js with Express JS. This is routes/index.js:
constexpress=require('express'); constrouter=express.Router({ caseSensitive: true}); constAuthMiddleware =require('../middleware/AuthMiddleware'); constbot =require('../bot'); letdb; constresponse=data=&amp;gt;({ message: data}); router.get('/', (req, res) =&amp;gt;{ returnres.render('index.html'); }); router.post('/api/submit', (req, res) =&amp;gt;{ const{ halloween_name, email, costume_type, trick_or_treat} =req.body; if(halloween_name&amp;amp;&amp;amp;email&amp;amp;&amp;amp;costume_type&amp;amp;&amp;amp;trick_or_treat) { returndb.party_request_add(halloween_name, email, costume_type, trick_or_treat) .then(() =&amp;gt;{ res.send(response('Your request will be reviewed by our team!</description></item><item><title>Full Stack Conf</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/full-stack-conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/full-stack-conf/</guid><description>We are provided with this webpage:
At the bottom of the page we have a text input:
If we provide some data, we see a message:
However, the website tells us to pop an alert(). This is usually a proof of concept for Cross-Site Scripting (XSS) payloads. One of the simplest payloads for XSS is:
&amp;lt;imgsrc=xonerror=alert(1)&amp;gt; If we use it, we will see the flag in the alert (HTB{p0p..p0p..p0p...alert(1337)}):</description></item><item><title>Gunship</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/gunship/</guid><description>We have a website with a nice style:
There is only one user input:
This is a Node.js application that uses pug as a template renderer (as shown in the available files from the challenge).
It also uses flat to parse JSON data, as shown in the following file called routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Horror Feeds</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/horror-feeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/horror-feeds/</guid><description>We are given this website:
Static code analysis We are also given the Python source code of the web application, built in Flask. Since we are dealing with a login form, let&amp;rsquo;s take a look at the database interaction (application/database.py):
fromcoloramaimportCursor fromapplication.utilimportgenerate_password_hash, verify_hash, generate_token fromflask_mysqldb importMySQL mysql=MySQL() defquery_db(query, args=(), one=False): withopen('/tmp/log', 'a') asf: f.write(query+'\n') cursor=mysql.connection.cursor() cursor.execute(query, args) rv=[dict((cursor.description[idx][0], value) foridx, valueinenumerate(row)) forrowincursor.fetchall()] return(rv[0] ifrvelseNone) ifoneelserv deflogin(username, password): user=query_db('SELECT password FROM users WHERE username = %s', (username,), one=True) ifuser: password_check=verify_hash(password, user.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/intergalactic-post/</guid><description>We are given a PHP web application with a single functionality, that is to post an email address.
We can start by analyzing the source code. The file index.php shows that there are only two endpoints (GET and POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); We can see that Database.</description></item><item><title>Juggling Facts</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/juggling-facts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/juggling-facts/</guid><description>We are given this website:
Static code analysis We also have the PHP source code of the web application. The relevant part is in controllers/IndexController.php:
&amp;lt;?php classIndexControllerextendsController { publicfunction__construct() { parent::__construct(); } publicfunctionindex($router) { $router-&amp;gt;view('index'); } publicfunctiongetfacts($router) { $jsondata =json_decode(file_get_contents('php://input'), true); if( empty($jsondata) ||!array_key_exists('type', $jsondata)) { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Insufficient parameters!']); } if($jsondata['type'] ==='secrets'&amp;amp;&amp;amp;$_SERVER['REMOTE_ADDR'] !=='127.0.0.1') { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Currently this type can be only accessed through localhost!']); } switch($jsondata['type']) { case'secrets': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('secrets') ]); case'spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('spooky') ]); case'not_spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('not_spooky') ]); default: return$router-&amp;gt;jsonify([ 'message'=&amp;gt;'Invalid type!</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/letter-dispair/</guid><description>We are provided with this webpage:
It shows a directory listing. If we go to /mailer.php we will have this website to send emails:
The mailer.zip file contains the mailer.php source code. It is quite large to insert it here.
The key thing is that it uses PHPMailer, which is vulnerable to CVE-2016-10033 and CVE-2016-10045. In fact, there are public exploits like the one in www.exploit-db.com.
Basically, the exploit says to enter this payload as the email:</description></item><item><title>looking glass</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/looking-glass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/looking-glass/</guid><description>We are provided with this webpage:
There is a feature to use ping command:
The problem might be related to command injection, because probably the server does something like this:
&amp;lt;?php $cmd ='ping -c 4 '.$_POST['ip_address']; system($cmd); Maybe not in PHP, but the concept is the same. Hence, we can try and add a semicolon to inject another system command (; id):
There it is, the server is vulnerable to command injection, which derives in Remote Code Execution (RCE).</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/mutation-lab/</guid><description>We are given a website like this:
We must register a new account and login to view a nice dashboard:
The only functionality we have is to export the SVG images we see as PNG files. We can capture the request with Burp Suite:
After some research, we can see that there is a vulnerability regarding SVG conversion that leads to Local File Read (more information at security.snyk.io).
We will need to use the following payload to read /etc/passwd as a PNG image:</description></item><item><title>Red Island</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/red-island/</guid><description>We are given a website like this:
We can register a new account and then login to see this functionality:
This time we don&amp;rsquo;t have the source code for the web application, so we must find a clear vulnerability or get the source code somehow.
We can start thinking of Server-Side Request Forgery (SSRF). As in other challenges, we know that the web server listens on port 1337, so let&amp;rsquo;s try and get http://127.</description></item><item><title>sanitize</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/sanitize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/sanitize/</guid><description>We are provided with this webpage:
If we look into the HTML source code, we see /debug:
And there we can find the source code of the web application:
fromflaskimportFlask, request, render_template, Response, url_for, g fromsqlite3importdbapi2assqlite3 fromfunctoolsimportwraps app=Flask(__name__) defget_db(): db=getattr(g, '_database', None) ifdbisNone: db=g._database =sqlite3.connect(':memory:', isolation_level=None) db.row_factory=sqlite3.Row withapp.app_context(): db.cursor().execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT);') withapp.open_resource('schema.sql', mode='r') asf: db.cursor().executescript(f.read()) returndb @app.teardown_appcontext defclose_connection(exception): db=getattr(g, '_database', None) ifdbisnotNone: db.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/slippy/</guid><description>We have a simple web back-end that allows us to upload a .tar.gz file. As we have a Dockerfile, let&amp;rsquo;s use a Docker container locally:
On the source code we have a simple Python Flask application:
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 The file is being extracted and written to /tmp:
import tarfile, tempfile, os from application import main generate = lambda x: os.</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>We are given the source code of a Node.js web project using Express JS and MySQL. In the Dockerfile an entrypoint.sh script is run:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item><item><title>Spookifier</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/spookifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/spookifier/</guid><description>We are given this website:
We can enter some string and it will be shown in different fonts:
Static code analysis We are provided with the Python source code of the web application, built with Flask. This is application/blueprints/routes.py:
fromflaskimportBlueprint, request from flask_mako importrender_template fromapplication.utilimportspookify web=Blueprint('web', __name__) @web.route('/') defindex(): text=request.args.get('text') if text: converted=spookify(text) return render_template('index.html', output=converted) return render_template('index.html', output='') The first thing we see here is that it is using templates, but using mako instead of the usual Jinja2 template engine.</description></item><item><title>Userland City</title><link>https://7rocky.github.io/en/ctf/htb-challenges/web/userland-city/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/web/userland-city/</guid><description>We are provided with this webpage:
Enumeration It shows a login form. Fortunately, we are given credentials in the challenge description: lxkid02:8rsNN9ohfLp69cVRFEgk4Qzs. Hence, we can use them to access:
It is a simple web page for some fake online store for cybercriminals.
The description of the challenge is quite long. The important things are the already used credentials and that it uses Laravel with debug mode activated.
Finding a CVE There is a known exploit for Laravel when debug is on: CVE-2021-3129.</description></item></channel></rss>