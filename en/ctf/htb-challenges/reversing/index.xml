<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reversing on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/</link><description>Recent content in Reversing on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/htb-challenges/reversing/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/alien-saboteaur/</guid><description>We are given a binary file called vm and a program called bin:
$ file * bin: data vm: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=10fb238b19d3a82b46536b51e47396525086a09c, for GNU/Linux 3.2.0, not stripped Setup environment The binary needs a recent version of Glibc in order to run:
$ ./vm ./vm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./vm) To solve this issue, we can run Ubuntu 22.</description></item><item><title>Anti Flag</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/anti-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/anti-flag/</guid><description>We have a binary called anti_flag:
$ file anti_flag anti_flag: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b8de97bc12c627606510140e43fc13e2efffcee5, for GNU/Linux 3.2.0, stripped Decompilation If we open it in Ghidra, we will see this main function:
/* WARNING: Removing unreachable block (ram,0x00101525) */ undefined8 main(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5, undefined8 param_6) { size_t sVar1; long lVar2; sVar1 = strlen(&amp;amp;DAT_00102011); malloc(sVar1 &amp;lt;&amp;lt; 2); lVar2 = ptrace(PTRACE_TRACEME, 0, 1, 0, param_5, param_6, param_2); if (lVar2 == -1) { puts("</description></item><item><title>Baby Crypt</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-crypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-crypt/</guid><description>We have a binary called baby_crypt:
$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped If we open it in Ghidra, we will see this main function:
int main() { char *key; long in_FS_OFFSET; int i; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); printf("Give me the key and I\'ll give you the flag: "</description></item><item><title>Baby RE</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/baby-re/</guid><description>We have a binary called baby:
$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped If we run it, it asks for a key:
$ ./baby Insert key: We can introduce something and see that it is not correct:
$ ./baby Insert key: 1234 Try again later. We can make use of ltrace to see every call to external functions (functions that belong to a library like Glibc):</description></item><item><title>ChromeMiner</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/chromeminer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/chromeminer/</guid><description>We have a Discord scam website that looks like this:
C# .NET decompilation If we click in &amp;ldquo;Login&amp;rdquo; we will download a Windows executable called DiscurdNitru.exe:
$ file DiscurdNitru.exe DiscurdNitru.exe: PE32+ executable (console) x86-64 Mono/.Net assembly, for MS Windows If we analyze printable strings, we will see that the executable is compiled from C# .NET:
$ strings DiscurdNitru.exe | grep .NET .NETFramework,Version=v4.6 .NET Framework 4.6 Therefore, we can use JetBrains dotPeek to decompile the file:</description></item><item><title>Curse Breaker</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/curse-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/curse-breaker/</guid><description>We are given a binary called breaker:
$ file breaker breaker: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=203d702c3e6cc789e148886f986713f7cf21e2c2, for GNU/Linux 3.2.0, not stripped Reverse engineering Using Ghidra, we can read the decompiled source code in C. This is the main function:
int main() { size_t newline_index; long i5; char magic_word[50]; uint i; magic_word._0_8_ = 0; magic_word._8_8_ = 0; magic_word._16_8_ = 0; magic_word._24_8_ = 0; magic_word.</description></item><item><title>Eat the Cake!</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/eat-the-cake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/eat-the-cake/</guid><description>We have a Windows PE called cake.exe:
$ file cake.exe cake.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed Decompression As can be seen, it is compressed with UPX, so let&amp;rsquo;s decompress it:
$ upx -d cake.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2023 UPX 4.0.2 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Jan 30th 2023 File size Ratio Format Name -------------------- ------ ----------- ----------- 15872 &amp;lt;- 9216 58.</description></item><item><title>Find The Easy Pass</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/find-the-easy-pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/find-the-easy-pass/</guid><description>We have a 32-bit binary called EasyPass.exe which is a Windows PE file:
$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows If we execute the binary in a Windows machine, it will a password:
Since the password is wrong, we will see a message &amp;ldquo;Wrong Password!&amp;rdquo;:
A static code analysis with Ghidra won&amp;rsquo;t be useful. Hence, let&amp;rsquo;s use a debugger like x32dbg to debug the binary. Once it is open, we can search for the previous error string:</description></item><item><title>Headache</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/headache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/headache/</guid><description>We have a binary called headache:
$ file headache headache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped Basic recognition When we run it, it starts writing Initialising and after some seconds, we are asked to enter a key:
$ ./headache Initialising..... Enter the key: asdf Login Failed! Let&amp;rsquo;s debug a bit using GDB. Once we are prompted to enter the key, we can hit ^C and set a breakpoint after the read instruction:</description></item><item><title>Hissss</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/hissss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/hissss/</guid><description>We have a binary called auth:
$ file auth auth: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=3507aa01d32c34dc8e8c6462b764adb90a82768d, stripped Decompilation If we look at the strings of the binary, we will find a lot of references to Python:
$ strings auth | grep python b_asyncio.cpython-38-x86_64-linux-gnu.so b_bisect.cpython-38-x86_64-linux-gnu.so b_blake2.cpython-38-x86_64-linux-gnu.so b_bz2.cpython-38-x86_64-linux-gnu.so b_codecs_cn.cpython-38-x86_64-linux-gnu.so b_codecs_hk.cpython-38-x86_64-linux-gnu.so b_codecs_iso2022.cpython-38-x86_64-linux-gnu.so b_codecs_jp.cpython-38-x86_64-linux-gnu.so b_codecs_kr.cpython-38-x86_64-linux-gnu.so b_codecs_tw.cpython-38-x86_64-linux-gnu.so b_contextvars.cpython-38-x86_64-linux-gnu.so b_csv.cpython-38-x86_64-linux-gnu.so b_ctypes.cpython-38-x86_64-linux-gnu.so b_datetime.cpython-38-x86_64-linux-gnu.so b_decimal.cpython-38-x86_64-linux-gnu.so b_hashlib.cpython-38-x86_64-linux-gnu.so b_heapq.cpython-38-x86_64-linux-gnu.so b_lzma.</description></item><item><title>Hunting License</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/hunting-license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/hunting-license/</guid><description>We have a binary called license:
$ file license license: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5be88c3ed329c1570ab807b55c1875d429a581a7, for GNU/Linux 3.2.0, not stripped $ ldd license linux-vdso.so.1 (0x00007ffe18bb1000) libreadline.so.8 => /lib/x86_64-linux-gnu/libreadline.so.8 (0x00007f430a30a000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f430a118000) libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f430a0e8000) /lib64/ld-linux-x86-64.so.2 (0x00007f430a366000) Decompilation If we open it in Ghidra, we will see this main function:
int main() { char cVar1; int iVar2; puts("So, you want to be a relic hunter?</description></item><item><title>Impossible Password</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/impossible-password/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/impossible-password/</guid><description>We have a binary called impossible_password.bin:
$ file impossible_password.bin impossible_password.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=ba116ba1912a8c3779ddeb579404e2fdf34b1568, stripped Dynamic analysis If we run it, it waits for user input:
$ ./impossible_password.bin * asdf [asdf] Strings Using strings to how printable characters of the binary we can see SuperSeKretKey:
$ strings impossible_password.bin /lib64/ld-linux-x86-64.so.2 libc.so.6 exit srand __isoc99_scanf time putchar printf malloc strcmp __libc_start_main __gmon_start__ GLIBC_2.</description></item><item><title>IRCware</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ircware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ircware/</guid><description>We have a binary called ircware:
$ file ircware ircware: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped Basic analysis If we open it in Ghidra straight away, the decompiled C code will be very difficult to understand because the binary is stripped (there are not symbols). Instead, we can try to execute it:
$ ./ircware EXCEPTION! ABORT Well, nothing useful. With ltrace we can log all external function calls:</description></item><item><title>Ouija</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ouija/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ouija/</guid><description>We are given a binary file called ouija:
$ file ouija ouija: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=53a9e0435f7c7041c557e9d4a8418cb6a916f339, for GNU/Linux 3.2.0, not stripped Reverse engineering If we open the binary in Ghidra, we will see this decompiled main function in C:
int main() { undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined4 local_60; undefined2 local_5c; undefined local_5a; int key_copy; int r; int m; int o; int n; int q; int p; int l; char *enc_flag; int k; int j; int i; local_78 = 0x6877644b7b544c5a; local_70 = 0x665f6b615f796661; local_68 = 0x6b6d7874675f6c67; local_60 = 0x616c7375; local_5c = 0x6667; local_5a = 0x7d; setvbuf(stdout, NULL, 2, 0); enc_flag = strdup((char *) &amp;amp;local_78); puts("</description></item><item><title>Potion Master</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/potion-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/potion-master/</guid><description>We are given a Haskell script called potion.hs:
import Data.Char (ord) import Data.Bits (xor) -- Complete the incantation... flag = "HTB{XXX}" extractFlag :: String -&amp;gt; String extractFlag (s:rest) | s == 'H' || s == 'T' || s == 'B' = extractFlag rest | s == '{' &amp;&amp; last rest == '}' = init rest | otherwise = error ("Invalid format") chunks :: Int -&amp;gt; [a] -&amp;gt; [[a]] chunks n l | n == 0 = [] | n == 1 = [[x] | x &amp;lt;- l] | length l &amp;lt;= n = [l] | otherwise = [take n l] ++ (chunks n (drop n l)) takeLast :: Int -&amp;gt; [a] -&amp;gt; [a] takeLast n = reverse .</description></item><item><title>Ransom</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ransom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/ransom/</guid><description>We have a Windows PE called windows_update.exe:
$ file windows_update.exe windows_update.exe: PE32+ executable (console) x86-64, for MS Windows Moreover, there is another file that looks encrypted from login.xlsx:
$ file login.xlsx.enc login.xlsx.enc: data Decompilation If we open the Windows PE in Ghidra, we will see this main function:
int __cdecl main(int _Argc, char **_Argv, char **_Env) { char *filename; __main(); if (_Argc == 1) { filename = "C:\\Users"; } else if (_Argc == 2) { filename = _Argv[1]; } else { printf("</description></item><item><title>Rebuilding</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/rebuilding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/rebuilding/</guid><description>We have a binary called rebuilding:
$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped If we run it, it requires to use a command line argument:
$ ./rebuilding Preparing secret keys Missing required argument Let&amp;rsquo;s open it in Ghidra and decompile it. This is the main function:
undefined8 main(int argc, long argv) { int __c; size_t length; undefined8 ret; int checks; int i; int j; if (argc !</description></item><item><title>RiseFromTheDead</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/risefromthedead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/risefromthedead/</guid><description>We are given a 64-bit binary called rise and also a core file:
$ file * core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './rise flag', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './rise', platform: 'x86_64' rise: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8341bf2064b7903b6e87d69c63a1849338d3f1e6, for GNU/Linux 3.2.0, not stripped The core file corresponds to an execution of rise (actually, the command was .</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/secured-transfer/</guid><description>We are given a binary file called securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped We also have a network capture file called trace.pcap.
Traffic analysis Starting with trace.pcap, we can use Wireshark to analyze the network capture file:
There is only one TCP segment that has data:
17275a3d9163b2798392813bf5e6826657bd11426076c910a38b68c2bcbbd3a5 Reverse engineering We can use Ghidra to read the decompiled source code in C.</description></item><item><title>Sekure Decrypt</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/sekure-decrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/sekure-decrypt/</guid><description>We are given a binary called dec, the C source code (src.c) and a core file (core):
$ file dec dec: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=daf03fccbc32333244dc0f36e874e27457110af1, for GNU/Linux 3.2.0, with debug_info, not stripped $ file core core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './dec', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: '.</description></item><item><title>Shattered Tablet</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/shattered-tablet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/shattered-tablet/</guid><description>We have a binary called tablet:
$ file tablet tablet: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=71ad3ff9f7e5fbf0edc75446337a0a68deb7ecd6, for GNU/Linux 3.2.0, not stripped Decompilation If we open it in Ghidra, we will see this main function:
/* WARNING: Could not reconcile some variable overlaps */ undefined8 main(void) { undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; local_48 = 0; local_40 = 0; local_38 = 0; local_30 = 0; local_28 = 0; local_20 = 0; local_18 = 0; local_10 = 0; printf("</description></item><item><title>Snakecode</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/snakecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/snakecode/</guid><description>We are given a binary file called chall.pyc, so we know it is a binary compiled using Python:
$ file chall.pyc chall.pyc: python 2.7 byte-compiled First of all, we can extract the Python source code using uncompyle6. Since it is compiled with python2.7, we can use a Docker container for that purpose:
$ docker run -v "$PWD":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020.</description></item><item><title>Teleport</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/teleport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/teleport/</guid><description>We have a binary called teleport:
$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped If we run it, it asks for a password:
$ ./teleport Missing password We can try to add it as a command line argument:
$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong... Using ltrace we see that the input is copied at some memory address and then there are a lot of jumps (44 calls to _setjmp):</description></item><item><title>The Vault</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/the-vault/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/the-vault/</guid><description>We are given a binary called vault:
$ file vault vault: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped Decompilation Let&amp;rsquo;s open it in Ghidra and decompile it. This is the entry function:
void processEntry entry(undefined8 param_1, undefined8 param_2) { undefined auStack_8[8]; __libc_start_main(FUN_0010c450, param_2, &amp;amp;stack0x00000008, FUN_0010d460, FUN_0010d4d0, param_1, auStack_8); do { // WARNING: Do nothing block with infinite loop } while (true); } So, the &amp;ldquo;main&amp;rdquo; function is FUN_0010c450 (the function name is its address because the binary is stripped), which just calls another one:</description></item><item><title>Up a Stream</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/up-a-stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/up-a-stream/</guid><description>We have a JAR file called stream.jar and an output.txt:
$ cat output.txt b71bO12cO156O6e43Od8O69c3O5cd3O144Oe4O6e43O37cbOf6O69c3O1e7bO156O3183O69c3O6cO8b3bOc0O1e7bO156OfcO50bbO69c3Oc0O102O6e43OdeOb14bOc6OfcOd8Ob71bO12cO156O6e43Od8O69c3O5cd3O144Oe4O6e43O37cbOf6O69c3O1e7bO156O3183O69c3O6cO8b3bOc0O1e7bO156OfcO50bbO69c3Oc0O102O6e43OdeOb14bOc6OfcOd8Ob71bO12cO156O6e43Od8O69c3O5cd3O144Oe4O6e43O37cbOf6O69c3O1e7bO156O3183O69c3O6cO8b3bOc0O1e7bO156OfcO50bbO69c3Oc0O102O6e43OdeOb14bOc6OfcOd8Ob71bO12cO156O6e43Od8O69c3O5cd3O144Oe4O6e43O37cbOf6O69c3O1e7bO156O3183O69c3O6cO8b3bOc0O1e7bO156OfcO50bbO69c3Oc0O102O6e43OdeOb14bOc6OfcOd8Ob71bO12cO156O6e43Od8O69c3O5cd3O144Oe4O6e43O37cbOf6O69c3O1e7bO156O3183O69c3O6cO8b3bOc0O1e7bO156OfcO50bbO69c3Oc0O102O6e43OdeOb14bOc6OfcOd8O If we run the JAR file, we have a different output:
$ java -jar stream.jar 3b13O3183Oe4Od2O3b13O3183Oe4Od2O3b13O3183Oe4Od2O3b13O3183Oe4Od2O3b13O3183Oe4Od2O Java decompilation We will need to decompile the JAR file and obtain a readable Java source file. We can go to www.javadecompilers.com and select CFR as decompiler. Then, we will have this source code:
/* * Decompiled with CFR 0.150. */ import java.</description></item><item><title>WIDE</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/wide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/wide/</guid><description>We are given a 64-bit binary file called wide and another file called db.ex with some strings:
$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe If we run the binary we have this:</description></item><item><title>You Cant C Me</title><link>https://7rocky.github.io/en/ctf/htb-challenges/reversing/you-cant-c-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/reversing/you-cant-c-me/</guid><description>We have a binary called auth:
$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped If we run it, it asks for a key:
$ ./auth Welcome! We can introduce something and see that it is not correct:
$ ./baby Insert key: asdf I said, you can't c me! We can make use of ltrace to see every call to external functions (functions that belong to a library like Glibc):</description></item></channel></rss>