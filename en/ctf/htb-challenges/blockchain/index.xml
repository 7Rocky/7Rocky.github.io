<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/htb-challenges/blockchain/</link><description>Recent content in Blockchain on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://7rocky.github.io/en/ctf/htb-challenges/blockchain/index.xml" rel="self" type="application/rss+xml"/><item><title>Confidentiality</title><link>https://7rocky.github.io/en/ctf/htb-challenges/blockchain/confidentiality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/blockchain/confidentiality/</guid><description>We are given a Solidity file called AccessToken.sol:
// SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.19; import {ERC721} from "./lib/ERC721.sol"; import {Owned} from "./lib/Owned.sol"; contract AccessToken is ERC721, Owned { uint256 public currentSupply; bytes[] public usedSignatures; bytes32 public constant approvalHash = 0x4ed1c9f7e3813196653ad7c62857a519087860f86aff4bc7766c8af8756a72ba; constructor(address _owner) Owned(_owner) ERC721("AccessToken", "ACT") {} function safeMint(address to) public onlyOwner returns (uint256) { return _safeMintInternal(to); } function safeMintWithSignature(bytes memory signature, address to) external returns (uint256) { require(_verifySignature(signature), "Not approved"); require(!</description></item><item><title>Funds Secured</title><link>https://7rocky.github.io/en/ctf/htb-challenges/blockchain/funds-secured/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/blockchain/funds-secured/</guid><description>We are given a Solidity file called Campaign.sol:
// SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.18; import {ECDSA} from "./lib/ECDSA.sol"; /// @notice MultiSignature wallet used to end the Crowdfunding and transfer the funds to a desired address contract CouncilWallet { using ECDSA for bytes32; address[] public councilMembers; /// @notice Register the 11 council members in the wallet constructor(address[] memory members) { require(members.length == 11); councilMembers = members; } /// @notice Function to close crowdfunding campaign.</description></item></channel></rss>