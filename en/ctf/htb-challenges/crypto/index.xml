<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto on 7Rocky's Blog. Cybersecurity and Maths</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/</link><description>Recent content in Crypto on 7Rocky's Blog. Cybersecurity and Maths</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/en/ctf/htb-challenges/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>AHS512</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/ahs512/</guid><description>We got the Python source code of the server:
from secret import FLAG from hashlib import sha512 import socketserver import signal from random import randint WELCOME = """ **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** "</description></item><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>We have the Python source code to launch a local instance for the challenge:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Taking a look at the source code, we see that the program expects a number $M$ from us to generate a shared secret.</description></item><item><title>BBGun06</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/bbgun06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/bbgun06/</guid><description>We are given a Python source code that asks for a signature. This is the main function:
def main(s): rsa = RSA(2048) user, data = parseEmail() signature = rsa.sign(user) rsa.verify(user, signature) headers = generateHeaders(rsa, signature) valid_email = headers + data sendMessage(s, valid_email + "\n\n") try: forged_signature = recieveMessage(s, "Enter the signature as hex: ") forged_signature = bytes.fromhex(forged_signature) if not rsa.verify(user, forged_signature): sendMessage(s, "Invalid signature") if different(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, "</description></item><item><title>Brainy's Cipher</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/brainys-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/brainys-cipher/</guid><description>We are given this text file (brainy.txt):
++++++++++[>+>+++>+++++++>++++++++++&lt;&lt;&lt;&lt;-]>>>>+++++++++++++++++++++++.-----------.&lt;------------.---.++.---------.+.++.-.++.+.-----.++..++++.--.++++.+..-------.+.+++.---.+.+++++.-------.+.---.+++++++.+.-------..+++.-.+++++.-------.++.+++++.-----.+++++..-----.--.++++++++.-------.--.++++.+++.---.++..+++.------.+++.--.-..++++++.-.----..+++++.------.++++++.---.---.--.+++.++++.-------.+++++..-.++..-------.++++++.---.++..+++.----.++++.-------.++++++++..----.+++.+.------.--.-.++.-.+++++.--..--.++++.-.++++.---.------.+++++.++.+.---.+++.---.----.++++.--.+++.-----.+++++.+.---.--.+++++++.---.---...---.+.++++++++.----.++++.-----.++.--.-.--.++.-.-.+++++.--..+++++.-------.-.++++.++.-----.++++++.--------.+++.+++.-.+++.----.----.++++++.----.++++++.-------.-----.>+.&lt;++++++++++++++.---------.+.++++++.--------.++.+++++++.--------.+++++++.----.+.----.+++...----.++++..++.----..+++.+++.-----.++++.--.++..-------.+++.++++.--.---.--.++++++..-----..+++++++.-------.+++++++.--------..++++++.++.--..++.----.+++.++.------.++++.+.-..+.+.-------.++++++.-.---.---.-.++++++++..-----.---.++.+.++..-.--.+++.++++.--..------.++++++++.-------.+++++++..---.+.++..---.----.+.++++++..-.-.-----.--.++++.--.+++++++.----.++++.-----.-.+.++.+..+..--.-.---.+++++.--.--.++++++.--------.++.---.+++++++..----.---.+++++++++.-...-------.++++++++.-------.++.-.+++++.----.-.+++++.---.----.+++++.++.-----.---.+++++++.++.---------...++.+++++++.------.+++++.-------.++++.-----.+++++.----.-----.>-------------.++++++++++++.&lt;++++++++++++++.-----..-.----.++++++.-..-----.++.++++++.--.----..--.++.-.++++++++.------.+..--.+++++++.------.---.++++++.----.++++++.-.++.------.++++...--.---.+++++++.--------.++++++++.----..+.----.+..---.++++++++.+.---.-.---.--.++++++++.-----.+++++.----.+.+++.------.--..+++++++++.-.---.++.----.++++.-.------.+++++.--.++.+++.-----.++.++.--..----.-.+++++++.+.----.---.+++++.+++.---.-----.+++++.------.++++++.-.----..++.+++.--.---.++.++++++.--------..+++++.+++.---.-----.++.++++++.---.+++.-.-------.++.+++.-.---.+++.---.+.++.-----.+++++++.---.--.-..++++.++.-------.++++.+.--.++++..+.+.-.---.-.--.+.+++++.--.+++.------..--.++++++++.-.------.++++.+++.-----.+.----.-----.>------------.+++++++++++++.&lt;++++++++++++++.-.---------.++++++..++.+.--.----.-.--.+++.---.++++++++..-----.+.--.--.++++++.+++.----.---.+.++.++++.------.++++++..--.----.++++..---.+++.----.--..++++++++.-.-----..---.+++++++++.---------.++++++.----.+++++.-.--.---.++++++.+.+.---------.++++++.----.++++.+++.-----.+++.--.+++.----.+++.------.++++++.----.++++++.---..------.+++++++.----.++.+.+.++.-..-------.++++++.-------.++++.---.++++.+++.-----.++++++..----.-.+++++..---.---.-..+.--.+++.---.++++.++.---.-.+++++.-..-------.++..+++.++++.----.---.++.+++++.--------.++++.+.------..+++++.---.++++++.-.------.+++.++.--.---.++.+++.-----.+++++.---.+.--.-.+++++++.+.-------.--.+++++.-----..+++++.++.---.+++++.-.--.-.----.-----.>--------------.&lt;++++++++++++++.----.----.--.+++++++.+.--------.++++++++.--..+..---.---.+++++..++.--.++.--.+.------.+++++++.-----.+++++.---.++.++.----.++.----.++.-----.+++..+++++.-----.--.+++...++.----.++++++.--------.+++++++++.--------.+.++++.+.----..++++++.-------.++..++++.--------.++++++.-.-----.++.++++.++.---.-----.++.-.+.++++.++.---.--.-.++++.-..----..+++++++.-----.++++++.---.----.--.+++++.+.--.+++++.----.++++.---.--.+.++.++.--.+.------.+.-.+++.--.---.++.--.++++++++.------.--.+++++.-.-.++++++.------.++++++.------..+++.++.------..++++.-.++..-----.++++++.--------.++.+++++.--.-----.++++++++..-.-----.+++++++.------.+++.------.++.++.-.-.+++.----.+.+++++++.---.+.++..-----.++++.--------.+++++..-.+++++..---.-.-----.++.--.+++++++++.--------.+++++.+++.----.--.+++.--..++.---.++.++++.---.-.++++.--------.+++++..------.+++++++.++.-------.+++.--..++.+.---.++++++.---------.++.+++++.--.++.++.--------.+++++++.-.---.-.++.----.+++++++.--------.++++++.------.+++++++.---.+++.--.++++.---.---..-..++.++.-.-.---.++++++..--.+++.+.----.++++.---------..++.+.+++++.---.-.+.----.+++++++.--.---.--.+..-.-.++++++.--.++++.-.+.-----.+.+++.+.----.++.++..--------.++.+++++++.--------.+++++.+..-----.--.+.++++++.--.----.+.++++++.--------.++++++++.------.--.++++++...+.-------.+++++++++.-----.+.+.----.+++.-----.++++++.+.+.--------.+++.+++++.-------.+.+++++++.--.-------.++++++++.-.------.>++++++++++++++++++++++++++. It corresponds to Brainfuck esoteric languages. If we use a tool like www.tutorialspoint.com, we can get the output:
In summary, we have:
p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 $p$ and $q$ seem to be parameters for an RSA cryptosystem, and $c$ must be the ciphertext. However, we need to find out what are $dp$ and $dq$.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>We are given a ciphertext:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>We are given a Python code to encrypt the flag, and the corresponding out.txt file:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/fast-carmichael/</guid><description>We got the Python source code of the server:
from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p &amp;lt; 1: return False if (p.</description></item><item><title>Find Marher's Secret</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/find-marhers-secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/find-marhers-secret/</guid><description>We are given a some Python source code and a server to connect to:
$ nc 161.35.172.25 32275 Connected to the cyborg's debugging interface Options: 1. Encrypt your text. 2. Claim the key. &amp;gt; Static code analysis This is the relevant part of the code:
def challenge(req): key = bytes.fromhex(KEY) assert(len(key) == 27) req.sendall(b'Connected to the cyborg\'s debugging interface\n') while True: req.sendall( b'\nOptions:\n1. Encrypt your text.\n2. Claim the key.\n&amp;gt; ') try: response = json.</description></item><item><title>Gonna-Lift-Em-All</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/gonna-lift-em-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/gonna-lift-em-all/</guid><description>We got the Python source code used to encrypt the flag:
from Crypto.Util.number import bytes_to_long, getPrime import random FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}' def gen_params(): p = getPrime(1024) g = random.randint(2, p-2) x = random.randint(2, p-2) h = pow(g, x, p) return (p, g, h), x def encrypt(pubkey): p, g, h = pubkey m = bytes_to_long(FLAG) y = random.randint(2, p-2) s = pow(h, y, p) return (g * y % p, m * s % p) def main(): pubkey, privkey = gen_params() c1, c2 = encrypt(pubkey) with open('data.</description></item><item><title>Hash the Filesystem</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/hash-the-filesystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/hash-the-filesystem/</guid><description>We are given a Python source code that asks to sign in and offers some functionalities. This is the main function:
def challenge(req): fnames = initializeDatabase() file_record['admin'] = [fname for fname in fnames] req.sendall(b'Super secret file server for malicious operations.\n' + b'Who are you:\n' + b'&amp;gt; ') user = req.recv(4096).decode().strip() if user == 'admin': req.sendall( b'Administrator can access the server only via ssh.\nGoodbye!\n') return token = json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] = [] key = os.</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>We are given a Python code to encrypt the flag (source.py), and we are also given dialog.txt and encrypted_messages.txt:
import os with open('super_secret_messages.txt', 'r') as f: SUPER_SECRET_MESSAGES = [msg.strip() for msg in f.readlines()] def deriveKey(key): derived_key = [] for i, char in enumerate(key): previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): if previous_char &amp;gt; char: derived_key[j] += 1 else: new_number += 1 derived_key.append(new_number) return derived_key def transpose(array): return [row for row in map(list, zip(*array))] def flatten(array): return "</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/infinite-descent/</guid><description>We are given a Python with a weird RSA implementation (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Do neighbouring primes present a security risk?</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>We are given this Python source code:
from hashlib import sha256 from Crypto.Util.Padding import pad, unpad import signal import subprocess import socketserver import os allowed_commands = [b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE = 32 def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]+secret[i]) % 256 enc_block += bytes([val]) return enc_block def encrypt(msg, password): h = sha256(password).digest() if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' for block in blocks: enc_block = encrypt_block(block, h) h = sha256(enc_block + block).</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/one-step-closer/</guid><description>We are given a Python code to encrypt the flag, and a Flask application that calls the encryption function:
from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime, inverse import random FLAG = b'HTB{--REDACTED--}' p = getPrime(1024) q = getPrime(1024) n = p * q e = 257 def encrypt_flag(): a = random.getrandbits(1024) b = random.getrandbits(1024) flag = bytes_to_long(FLAG) msg = a*flag + b ct = pow(msg, e, n) return {'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} from flask import * from chall import encrypt_flag app = Flask(__name__) @app.</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/space-pirates/</guid><description>We are given this Python source code:
from sympy import * from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randint, randbytes, seed FLAG = b'HTB{dummyflag}' class Shamir: def __init__(self, prime, k, n): self.p = prime self.secret = randint(1, self.p - 1) self.k = k self.n = n self.coeffs = [self.secret] self.x_vals = [] self.y_vals = [] def next_coeff(self, val): return int(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) def calc_coeffs(self): for i in range(1, self.</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/spooky-rsa/</guid><description>We got the Python source code used to encrypt the flag:
from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b'HTB{????????????????????????????????????????????}' def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open('out.</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>We are given this Python source code:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random import signal import subprocess import socketserver FLAG = b'HTB{--REDACTED--}' prefix = random.randbytes(12) key = random.randbytes(16) def encrypt(key, msg): msg = bytes.fromhex(msg) crypto = AES.new(key, AES.MODE_ECB) padded = pad(prefix + msg + FLAG, 16) return crypto.encrypt(padded).hex() def challenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n' + b'It seems like there is a prefix appended to the real firmware\n' + b'Can you somehow extract the firmware and fix the chip?</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/weak-rsa/</guid><description>We are given a public key in PEM format for an RSA implementation (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA works as follows: We take two large primes $p$ and $q$ and set the modulus $n = pq$. Then we choose an exponent $e$ (typically $e = 65537$) and encrypt a message $m$ in decimal format:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/en/ctf/htb-challenges/crypto/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/en/ctf/htb-challenges/crypto/whole-lotta-candy/</guid><description>We got the Python source code of the server:
from encrypt import Encryptor from secret import FLAG import socketserver import random import signal import json MODES = ['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def main(s): mode = random.choice(MODES) enc = Encryptor() while True: try: sendMessage(s, f"Please interact with the server using json data!</description></item></channel></rss>