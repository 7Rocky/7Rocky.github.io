<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECSC 2023 on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/</link><description>Recent content in ECSC 2023 on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/ecsc-2023/index.xml" rel="self" type="application/rss+xml"/><item><title>Blind</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/blind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/blind/</guid><description>Is this what people mean by &amp;ldquo;message blinding&amp;rdquo;?
Challenge contributed by CryptoHack
Challenge files:
output.txt blind.sage Análisis del código fuente Se nos proporciona un script largo de SageMath que usa ECDSA para firmar la clave que cifra la flag (en realidad, una clave utilizada para derivar una clave AES con bcrypt.kdf):
def encrypt_flag(): k = secrets.token_bytes(k2//8) key = bcrypt.kdf(k, b"ICC_CHALLENGE", 16, 31337) cipher = AES.new(key, AES.MODE_CTR, nonce=b"") with open("flag.txt", "</description></item><item><title>Hide and seek</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/hide-and-seek/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/hide-and-seek/</guid><description>I have hidden my flag among the elliptic curve points. Go seek!
Challenge contributed by CryptoHack
Challenge files:
output.txt hide_and_seek.sage Análisis del código fuente Se nos proporciona un script de SageMath que usa criptografía de curva elíptica para cifrar la flag:
from Crypto.Util.number import bytes_to_long FLAG = bytes_to_long(open("flag.txt", "rb").read().strip()[len("ECSC{"):-1]) proof.arithmetic(False) p = 1789850433742566803999659961102071018708588095996784752439608585988988036381340404632423562593 a = 62150203092456938230366891668382702110196631396589305390157506915312399058961554609342345998 b = 1005820216843804918712728918305396768000492821656453232969553225956348680715987662653812284211 F = GF(p) E.&amp;lt;G&amp;gt; = EllipticCurve(F, [a, b]) assert FLAG &amp;lt; G.</description></item><item><title>not crypto</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/not-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/not-crypto/</guid><description>This is the not crypto flag which is totaly not crypto, but crypto! Can we get a clap from the team for excessive crypto usage?
Se nos proporciona el siguiente script de Python:
import base64 input_string = "REMOVED" def secret(raw_string): result = [] for char in raw_string: if 'a' &amp;lt;= char &amp;lt;= 'z': offset = ord('a') result.append(chr(((ord(char) - offset + 13) % 26) + offset)) elif 'A' &amp;lt;= char &amp;lt;= 'Z': offset = ord('A') result.</description></item><item><title>RRSSAA</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/rrssaa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/rrssaa/</guid><description>My primes are prefectly random. I wonder if you can find them.
Challenge contributed by CryptoHack
Challenge files:
output.txt RRSSAA.py Análisis del código fuente Se nos proporciona el siguiente script de Python que usa RSA para cifrar la flag:
flag = open("flag.txt", "rb").read().strip() assert len(flag) == 128 N = prod(get_prime(i) for i in range(2, len(flag))) print(hex(N), hex(pow(bytes_to_long(flag), 0x10001, N))) La configuración de RSA no es la habitual. Esta vez, tenemos una configuración de RSA multiprimo, donde cada factor primo del módulo $n$ se calcula con get_prime:</description></item></channel></rss>