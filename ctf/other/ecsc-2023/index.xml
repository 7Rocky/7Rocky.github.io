<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECSC 2023 on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/</link><description>Recent content in ECSC 2023 on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/ecsc-2023/index.xml" rel="self" type="application/rss+xml"/><item><title>Blind</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/blind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/blind/</guid><description>Is this what people mean by &amp;ldquo;message blinding&amp;rdquo;?
Challenge contributed by CryptoHack
Challenge files:
output.txt blind.sage Análisis del código fuente Se nos proporciona un script largo de SageMath que usa ECDSA para firmar la clave que cifra la flag (en realidad, una clave utilizada para derivar una clave AES con bcrypt.kdf):
def encrypt_flag(): k = secrets.token_bytes(k2//8) key = bcrypt.kdf(k, b"ICC_CHALLENGE", 16, 31337) cipher = AES.new(key, AES.MODE_CTR, nonce=b"") with open("flag.txt", "</description></item><item><title>Hide and seek</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/hide-and-seek/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/hide-and-seek/</guid><description>I have hidden my flag among the elliptic curve points. Go seek!
Challenge contributed by CryptoHack
Challenge files:
output.txt hide_and_seek.sage Análisis del código fuente Se nos proporciona un script de SageMath que usa criptografía de curva elíptica para cifrar la flag:
from Crypto.Util.number import bytes_to_long FLAG = bytes_to_long(open("flag.txt", "rb").read().strip()[len("ECSC{"):-1]) proof.arithmetic(False) p = 1789850433742566803999659961102071018708588095996784752439608585988988036381340404632423562593 a = 62150203092456938230366891668382702110196631396589305390157506915312399058961554609342345998 b = 1005820216843804918712728918305396768000492821656453232969553225956348680715987662653812284211 F = GF(p) E.&amp;lt;G&amp;gt; = EllipticCurve(F, [a, b]) assert FLAG &amp;lt; G.</description></item><item><title>Irish Flan</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/irish-flan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/irish-flan/</guid><description>Yum, time for dessert.
Challenge contributed by CryptoHack
Challenge files:
output.txt irish_flan.py Se nos proporciona un script en Python que usa cuaterniones para ocultar una clave AES utilizada para cifrar la flag. La implementación de los cuaterniones se basa en clases de Python. Podemos suponer que la implementación es correcta (aunque hay un error en la potencia de un cuaternión, pero no es intencionado).
Análisis del código fuente La parte relevante del script es:</description></item><item><title>Kernel searcher</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/kernel-searcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/kernel-searcher/</guid><description>I have a super secret isogeny. Wanna know where your point ends up? Just send me your favourite coordinates.
Challenge contributed by CryptoHack
Challenge files:
Dockerfile entry.sh kernel_searcher.sage kernel_searcher.xinetd Se nos proporciona un script en SageMath que oculta la flag bajo una isogenia y nos permite evaluar la isogenia en cualquier punto que deseemos.
Análisis del código fuente La parte relevante del script es esta:
import json from Crypto.Util.number import bytes_to_long proof.</description></item><item><title>not crypto</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/not-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/not-crypto/</guid><description>This is the not crypto flag which is totaly not crypto, but crypto! Can we get a clap from the team for excessive crypto usage?
Se nos proporciona el siguiente script de Python:
import base64 input_string = "REMOVED" def secret(raw_string): result = [] for char in raw_string: if 'a' &amp;lt;= char &amp;lt;= 'z': offset = ord('a') result.append(chr(((ord(char) - offset + 13) % 26) + offset)) elif 'A' &amp;lt;= char &amp;lt;= 'Z': offset = ord('A') result.</description></item><item><title>Put a ring on it</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/put-a-ring-on-it/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/put-a-ring-on-it/</guid><description>Ring Signatures are used in some cryptocurrencies to provide anonymity for who has signed a transaction or sent money. Can you break the anonymity of the ring signatures?
Challenge contributed by CryptoHack
Challenge files:
ed25519.py data.json chal.py Se nos proporciona una implementación de un protocolo de firma de anillo, que se supone que es un algoritmo en el que unas partes pueden validar los mensajes firmados pero no pueden determinar quién lo ha firmado, proporcionando anonimato a las firmas.</description></item><item><title>RRSSAA</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/rrssaa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/rrssaa/</guid><description>My primes are prefectly random. I wonder if you can find them.
Challenge contributed by CryptoHack
Challenge files:
output.txt RRSSAA.py Análisis del código fuente Se nos proporciona el siguiente script de Python que usa RSA para cifrar la flag:
flag = open("flag.txt", "rb").read().strip() assert len(flag) == 128 N = prod(get_prime(i) for i in range(2, len(flag))) print(hex(N), hex(pow(bytes_to_long(flag), 0x10001, N))) La configuración de RSA no es la habitual. Esta vez, tenemos una configuración de RSA multiprimo, donde cada factor primo del módulo $n$ se calcula con get_prime:</description></item><item><title>Tough decisions</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/tough-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/tough-decisions/</guid><description>Champagne for my real friends, real pain for my sham friends.
Challenge contributed by CryptoHack
Challenge files:
output.txt tough_decisions.py Análisis del código fuente Se nos proporciona un script en Python que toma la flag como bits y, por cada bit, imprime 6 salidas de una de las funciones real (bit 0) o fake (bit 1):
if __name__ == "__main__": s = sample_key() for b in get_flag(): print([[real, fake][b](s) for _ in range(6)]) Por lo tanto, el objetivo es encontrar una manera de diferenciar entre resultados de real y fake para obtener los bits de la flag.</description></item><item><title>Twist and shout</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/twist-and-shout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/twist-and-shout/</guid><description>I&amp;rsquo;ll shout about my curve all day, it&amp;rsquo;s totally secure. You&amp;rsquo;ll have to pull the solution from my cold dead hands!
Challenge contributed by CryptoHack
Connect at archive.cryptohack.org 11718
Challenge files:
twist_and_shout.py Dockerfile twist_and_shout.xinetd Se nos proporciona un servidor que usa una curva elíptica para cifrar la flag.
Análisis del código fuente Tenemos los parámetros de la curva:
""" Define the elliptic curve E: y^2 = x^3 + a*x + b With order n = 340282366920938463465004184633952524077 = 2^128 - 1629577202184312621 "</description></item><item><title>WOTS Up</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/wots-up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/wots-up/</guid><description>With the need to find post-quantum schemes, hash-based signatures are cool again.
Challenge contributed by CryptoHack
Challenge files:
data.json chal.py Se nos da una clase llamada Winternitz que implementa un protocolo de firma basado en el hash SHA256. En realidad, WOTS significa Winternitz One-Time Signature y es un algoritmo post-cuántico de firma, que se explica perfectamente en www.codingninjas.com.
Análisis del código fuente En primer lugar, la clase crea una lista de claves privadas:</description></item><item><title>WOTS Up 2</title><link>https://7rocky.github.io/ctf/other/ecsc-2023/wots-up-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ecsc-2023/wots-up-2/</guid><description>I fixed the problem with my last scheme, now I can confidently sign my WOTScoin transactions.
Challenge contributed by CryptoHack
Challenge files:
data.json chal.py Este es otro reto que implementa WOTS (más información en www.codingninjas.com).
Análisis del código fuente La clase Winternitz es un poco diferente de la primera parte del reto, en la generación de teclas:
class Winternitz: def __init__(self): self.priv_key = [] for _ in range(KEY_LEN): priv_seed = urandom(KEY_LEN) self.</description></item></channel></rss>