<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB UniCTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/htb-unictf/</link><description>Recent content in HTB UniCTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/htb-unictf/index.xml" rel="self" type="application/rss+xml"/><item><title>AESWCM</title><link>https://7rocky.github.io/ctf/other/htb-unictf/aeswcm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/aeswcm/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.Padding import pad from Crypto.Cipher import AES import os import random from secret import FLAG KEY = os.urandom(16) IV = os.urandom(16) class AESWCM: def __init__(self, key): self.key = key self.cipher = AES.new(self.key, AES.MODE_ECB) self.BLOCK_SIZE = 16 def pad(self, pt): if len(pt) % self.BLOCK_SIZE != 0: pt = pad(pt, self.BLOCK_SIZE) return pt def blockify(self, message): return [ message[i:i + self.BLOCK_SIZE] for i in range(0, len(message), self.</description></item><item><title>Bank-er-smith</title><link>https://7rocky.github.io/ctf/other/htb-unictf/bank-er-smith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/bank-er-smith/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = """ ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ """ class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.</description></item><item><title>BatchCraft Potions</title><link>https://7rocky.github.io/ctf/other/htb-unictf/batchcraft-potions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/batchcraft-potions/</guid><description>Tenemos este sitio web:
Análisis de código estático Se nos proporciona el código fuente de JavaScript de la aplicación web, creada con Node.js y Express JS. Esto es index.js:
const express = require('express'); const app = express(); const path = require('path'); const cookieParser = require('cookie-parser'); const nunjucks = require('nunjucks'); const routes = require('./routes'); const Database = require('./database'); global.db = new Database(); app.use(express.json()); app.use(cookieParser()); nunjucks.configure('views', { autoescape: true, express: app }); app.</description></item><item><title>Curse Breaker</title><link>https://7rocky.github.io/ctf/other/htb-unictf/curse-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/curse-breaker/</guid><description>Se nos proporciona un binario llamado breaker:
$ file breaker breaker: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=276c71525dd765da538440a4615fa5b717e331ad, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
int main() { size_t newline_index; long i5; char magic_word[50]; uint i; magic_word._0_8_ = 0; magic_word._8_8_ = 0; magic_word._16_8_ = 0; magic_word._24_8_ = 0; magic_word.</description></item><item><title>Fake News</title><link>https://7rocky.github.io/ctf/other/htb-unictf/fake-news/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/fake-news/</guid><description>Se nos proporciona una carpeta llamada html con muchos archivos de un servidor de WordPress:
$ ls index.php wp-activate.php wp-blogs wp-config-sample.php wp-cron.php wp-load.php wp-settings.php xmlrpc.php license.txt wp-admin wp-comments-post.php wp-config.php wp-includes wp-login.php wp-signup.php readme.html wp-blog-header.php wp-config-docker.php wp-content wp-links-opml.php wp-mail.php wp-trackback.php Inspección básica Obviamente, wp-blogs llama la atención, así que examinemos los archivos que están dentro:
$ ls wp-blogs 2022 $ ls wp-blogs/2022/ 11 $ ls wp-blogs/2022/11/ index.php style.css $ du -h wp-blogs/2022/11/* 304K wp-blogs/2022/11/index.</description></item><item><title>Great Old Talisman</title><link>https://7rocky.github.io/ctf/other/htb-unictf/great-old-talisman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/great-old-talisman/</guid><description>Se nos proporciona un binario de 64 bits llamado great_old_talisman:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Si abrimos el binario en Ghidra, veremos este código fuente en C descompilado para la función main:
void main() { long in_FS_OFFSET; int n; undefined8 canary; canary = *(undefined8 *) (in_FS_OFFSET + 0x28); setup(); banner(); printf("\nThis Great Old Talisman will protect you from the evil powers of zombies!</description></item><item><title>Mayday Mayday</title><link>https://7rocky.github.io/ctf/other/htb-unictf/mayday-mayday/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/mayday-mayday/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, GCD, bytes_to_long from secret import FLAG from random import randint class Crypto: def __init__(self, bits): self.bits = bits self.alpha = 1/9 self.delta = 1/4 self.known = int(self.bits*self.delta) def keygen(self): while True: p, q = [getPrime(self.bits//2) for _ in '__'] self.e = getPrime(int(self.bits*self.alpha)) φ = (p-1)*(q-1) try: dp = pow(self.e, -1, p-1) dq = pow(self.e, -1, q-1) self.</description></item><item><title>MSS</title><link>https://7rocky.github.io/ctf/other/htb-unictf/mss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/mss/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import os, random, json from hashlib import sha256 from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secret import FLAG class MSS: def __init__(self, BITS, d, n): self.d = d self.n = n self.BITS = BITS self.key = bytes_to_long(os.urandom(BITS//8)) self.coeffs = [self.key] + [bytes_to_long(os.urandom(self.BITS//8)) for _ in range(self.d)] def poly(self, x): return sum([self.coeffs[i] * x**i for i in range(self.</description></item><item><title>MSS Revenge</title><link>https://7rocky.github.io/ctf/other/htb-unictf/mss-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/mss-revenge/</guid><description>Este reto es el mismo que MSS, pero con una correción para evitar una solución.
Revisión del reto El servidor crea un polinomio con coeficientes aleatorios de 256 bits:
$$ P(x) = \mathrm{key} + a_1 x + a_2 x^2 + \dots + a_{30} x^{30} $$ El objetivo es encontrar $\mathrm{key}$, que se utiliza para derivar una clave de AES para cifrar la flag. El servidor nos permite evaluar el polinomio 19 veces con valores de $0 &amp;lt; x \leqslant 2^{15}$.</description></item><item><title>Potion Master</title><link>https://7rocky.github.io/ctf/other/htb-unictf/potion-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/potion-master/</guid><description>Se nos proporciona un script en Haskell llamado potion.hs:
import Data.Char (ord) import Data.Bits (xor) -- Complete the incantation... flag = "HTB{XXX}" extractFlag :: String -&amp;gt; String extractFlag (s:rest) | s == 'H' || s == 'T' || s == 'B' = extractFlag rest | s == '{' &amp;&amp; last rest == '}' = init rest | otherwise = error ("Invalid format") chunks :: Int -&amp;gt; [a] -&amp;gt; [[a]] chunks n l | n == 0 = [] | n == 1 = [[x] | x &amp;lt;- l] | length l &amp;lt;= n = [l] | otherwise = [take n l] ++ (chunks n (drop n l)) takeLast :: Int -&amp;gt; [a] -&amp;gt; [a] takeLast n = reverse .</description></item><item><title>Sacred Scrolls</title><link>https://7rocky.github.io/ctf/other/htb-unictf/sacred-scrolls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/sacred-scrolls/</guid><description>Se nos proporciona un binario de 64 bits llamado sacred_scrolls:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
void main() { undefined8 *puVar1; long i; byte bVar2; undefined wizard_tag[1528]; undefined8 uStack_110; undefined8 target; undefined8 local_100; undefined8 local_f8; undefined8 local_f0; undefined8 local_e8; undefined8 local_e0; undefined8 local_d8; undefined8 local_d0; undefined8 local_c8; undefined8 local_c0; undefined8 local_b8; undefined8 local_b0; undefined8 local_a8; undefined8 local_a0; undefined8 local_98; undefined8 local_90; undefined8 local_88; undefined8 local_80; undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined8 local_60; undefined8 local_58; undefined8 local_50; undefined8 local_48; undefined *wizard_tag_copy; undefined8 local_38; undefined4 local_2c; bVar2 = 0; uStack_110 = 0x400ecc; setup(); uStack_110 = 0x400ed1; banner(); uStack_110 = 0x400edb; clean(); uStack_110 = 0x400eec; printf("</description></item><item><title>Sacred Scrolls' Revenge</title><link>https://7rocky.github.io/ctf/other/htb-unictf/sacred-scrolls-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/sacred-scrolls-revenge/</guid><description>Este reto es una versión corregida de Sacred Scrolls. Casi todo el comportamiento del programa es el mismo que en la versión anterior, así que lea ese artículo antes que este.
Arreglaron el reto debido a una solución no intencionada (inyección de comandos):
$ ./sacred_scrolls ▄▞▀▀▀▜▄▖ ▗ ▖ ▗ ▖ ▗ ▖▟▞▖▘▗▖▚▘ ▝▀▄ ▖▝ ▘ ▝ ▝ ▝ ▘ ▝ ▝ ▝ ▘ ▝ ▖▌▀ ▖▖▚▘▝▗▝▝ ▗▝▄▖▘ ▘ ▗▗▞▘▚▝▝▝▗▝ ▘ ▖ ▗▚▖ ▗ ▖ ▗ ▗ ▖▗▄▜▝▚▝▝▖▘▘▝ ▖ ▖ ▘ ▗ ▖▛▞ ▖ ▖▘ ▖ ▗ ▘ ▖ ▗▝ ▗▄▞▚▗▗▘ ▝ ▖ ▖ ▖▘▀▀▖ ▖ ▗▖▛▚▗▝ ▖ ▗ ▝ ▝ ▘ ▖ ▘▗▗▗▝▌ ▗ ▗▄▞▀▚▝ ▖ ▖▝ ▖▝ ▖▗ ▖▘▝▗▗▄▞▘ ▖ ▝ ▗ ▖ ▄▞▀▚▗▝▝ ▖ ▘ ▘ ▗▝ ▖ ▘▗▗▝▖▞▞▌▜▐▐▖ ▗ ▘▄▖▀▀▗▝▝▗ ▝ ▗ ▘ ▖▖▘▖▝▗ ▚▝▖▖▌▌▌▙▞▌▀ ▘ ▄▞▞▀▗▝▞▝▖▝ ▘▝ ▖▘▖▖▘▞▝▖▚▚▐▐▟▟▞▘▘ ▖▝ ▄▖▛▀▖▞▖▌▘▘▝▖ ▖▝ ▗ ▝ ▖▗ ▘▖▖▖▞▐▗▚▚▙▙▛▀▝ ▄▄▜▚▙▄▄▀▝▗ ▄▝▝▘ ▘ ▘ ▘ ▗ ▖▗ ▝▖▄▐▐▐▟▟▜▜▝ ▘ ▐▟▛█▜▚▚▚▞▄▖▘ ▖ ▗ ▗ ▘▝ ▖▗▗▐▝▄▟▞▙█▐▝ ▐▚▛▞▜▚▟ ▝▚▚ ▘▝ ▝ ▝▗ ▖▘ ▗▝▝▖▞▖▌▙▜▙▙▀▘ ▗ ▝ ▗ ▘ ▜▐▚▐▐▜▟█▖ ▀▙▖▗ ▖▗▝ ▖▗ ▖▘▖▞▞▟▞▛▛▟▀ ▗ ▘ ▖ ▝▛▗ ▖▌▙▙█▘ ▗▚ ▖▗ ▗▗▗▗▚▐▐▐▞▛▟▞▛▝ ▗▝ █ ▖▗▀▝▝▛█▗ ▜▘▖▗▝▗▗▚▚▚▙▜▞▙▜▝ ▝ ▘ ▗ ▖ ▐▖▖ ▚ ▚▜▜▖▞▐▚▗▗▐▗▜▞▛▙▚▙▀ ▝ ▗ ▘ ▗ ▚▝▖▚▚▖▀▛▞▐▟▚▘▌▌▛▙▜▟▝▘ ▗ ▗ ▗ ▝▌▝▖▌▜▚▛▟█▛▙▜▞▛▛▞▘ ▖ ▝ ▖ ▗▝ ▘ ▝▙▗▐▐▐▜▜▙█▞▟▞▛▝ ▗ ▖ ▗ ▗ ▝ ▝▘▌▖▖▙▀▙▜▚▜▝ ▗ ▘ ▝▀▗▀▞▞▘▘ ▝ ▘ ▗▝ ▗ ▝ ▝ ▝ ▗▝ ▘ ▝ ▝ ▖▝ ▘ ▝ [+] All ⅀ ℙ ∉ ⎳ ⎳ ⅀ have been whiped out.</description></item><item><title>Spellbook</title><link>https://7rocky.github.io/ctf/other/htb-unictf/spellbook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/spellbook/</guid><description>Se nos proporciona un binario de 64 bits llamado spellbook:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
void main() { size_t option; setup(); banner(); while (true) { while (true) { while (option = menu(), option == 2) { show(); } if (option &amp;lt; 3) break; if (option == 3) { edit(); } else { if (option !</description></item><item><title>The Magic Informer</title><link>https://7rocky.github.io/ctf/other/htb-unictf/the-magic-informer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/the-magic-informer/</guid><description>Tenemos este sitio web:
Esta vez no tenemos el código fuente, por lo que debemos dar vueltas con el sitio web.
Registrando una nueva cuenta En la parte inferior de la página podemos encontrar un enlace a un formulario de registro:
Entonces nos registramos y luego iniciamos sesión:
Y tenemos acceso a nuestro dashboard:
Navegación de directorios y lectura de archivos locales Podemos probar inyecciones comunes en la en el formulario anterior.</description></item><item><title>Zombie Rolled</title><link>https://7rocky.github.io/ctf/other/htb-unictf/zombie-rolled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/zombie-rolled/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, bytes_to_long from fractions import Fraction from math import prod from hashlib import sha256 from secrets import randbelow # I hope no one cares about Kerckhoff's principle :) from secret import derive_public_key, FLAG def fraction_mod(f, n): return f.numerator * pow(f.denominator, -1, n) % n class PublicKey: def __init__(self, pub): self.pub = pub self.f = self.magic(pub) self.</description></item><item><title>Zombiedote</title><link>https://7rocky.github.io/ctf/other/htb-unictf/zombiedote/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/zombiedote/</guid><description>Se nos proporciona un binario de 64 bits llamado zombiedote:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Tenemos un menú típico de un reto de explotación del heap:
$ ./zombiedote [ BioShield Solutions Research Institute ] Virus Concentration Levels Logging - Manual Mode: ON [ MANUAL MODE LOGGING ] [1] Create log [2] Insert into log [3] Delete log [4] Edit log [5] Inspect log &amp;gt;&amp;gt; Si abrimos el binario en Ghidra, veremos el código fuente en C descompilado para el programa.</description></item><item><title>Zombienator</title><link>https://7rocky.github.io/ctf/other/htb-unictf/zombienator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/zombienator/</guid><description>Se nos proporciona un binario de 64 bits llamado zombienator:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si abrimos el binario en Ghidra, veremos este código fuente en C descompilado para la función main:
void main() { ulong option; banner(); while (true) { while (true) { while (true) { printf("\n##########################\n# #\n# 1. Create Zombienator #\ n# 2. Remove Zombienator #\n# 3.</description></item></channel></rss>