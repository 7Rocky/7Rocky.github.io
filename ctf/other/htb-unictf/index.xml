<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB UniCTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/htb-unictf/</link><description>Recent content in HTB UniCTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/htb-unictf/index.xml" rel="self" type="application/rss+xml"/><item><title>AESWCM</title><link>https://7rocky.github.io/ctf/other/htb-unictf/aeswcm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-unictf/aeswcm/</guid><description>Se nos proporciona el c√≥digo fuente del servidor en Python:
from Crypto.Util.Padding import pad from Crypto.Cipher import AES import os import random from secret import FLAG KEY = os.urandom(16) IV = os.urandom(16) class AESWCM: def __init__(self, key): self.key = key self.cipher = AES.new(self.key, AES.MODE_ECB) self.BLOCK_SIZE = 16 def pad(self, pt): if len(pt) % self.BLOCK_SIZE != 0: pt = pad(pt, self.BLOCK_SIZE) return pt def blockify(self, message): return [ message[i:i + self.BLOCK_SIZE] for i in range(0, len(message), self.</description></item></channel></rss>