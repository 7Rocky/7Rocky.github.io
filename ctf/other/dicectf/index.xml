<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DiceCTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/dicectf/</link><description>Recent content in DiceCTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/dicectf/index.xml" rel="self" type="application/rss+xml"/><item><title>baby-talk</title><link>https://7rocky.github.io/ctf/other/dicectf/baby-talk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/dicectf/baby-talk/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled El programa nos ofrece cuatro opciones:
$ ./chall 1. str 2. tok 3. del 4. exit &amp;gt; Ingeniería inversa Si abrimos el binario en Ghidra, veremos el siguiente código en C descompilado. La función main gestiona las opciones y llama a la función correspondiente:
int main() { ulong option; setbuf(stdout, NULL); do { while (true) { while (true) { print_menu(); printf("</description></item><item><title>funnylogin</title><link>https://7rocky.github.io/ctf/other/dicectf/funnylogin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/dicectf/funnylogin/</guid><description>Se nos proporciona un proyecto de Node.js con un solo archivo app.js:
const express = require('express'); const crypto = require('crypto'); const app = express(); const db = require('better-sqlite3')('db.sqlite3'); db.exec(`DROP TABLE IF EXISTS users;`); db.exec(`CREATE TABLE users( id INTEGER PRIMARY KEY, username TEXT, password TEXT );`); const FLAG = process.env.FLAG || "dice{test_flag}"; const PORT = process.env.PORT || 3000; const users = [...Array(100_000)].map(() =&amp;gt; ({ user: `user-${crypto.randomUUID()}`, pass: crypto.randomBytes(8).toString("hex") })); db.exec(`INSERT INTO users (id, username, password) VALUES ${users.</description></item><item><title>rps-casino</title><link>https://7rocky.github.io/ctf/other/dicectf/rps-casino/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/dicectf/rps-casino/</guid><description>Se nos proporciona el código fuente en Python del servidor:
#!/usr/local/bin/python import os from Crypto.Util.number import bytes_to_long def LFSR(): state = bytes_to_long(os.urandom(8)) while 1: yield state &amp;amp; 0xf for i in range(4): bit = (state ^ (state &amp;gt;&amp;gt; 1) ^ (state &amp;gt;&amp;gt; 3) ^ (state &amp;gt;&amp;gt; 4)) &amp;amp; 1 state = (state &amp;gt;&amp;gt; 1) | (bit &amp;lt;&amp;lt; 63) rng = LFSR() n = 56 print(f"Let's play rock-paper-scissors! We'll give you {n} free games"</description></item><item><title>winter</title><link>https://7rocky.github.io/ctf/other/dicectf/winter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/dicectf/winter/</guid><description>Se nos proporciona el código fuente en Python de un servidor:
#!/usr/local/bin/python import os from hashlib import sha256 class Wots: def __init__(self, sk, vk): self.sk = sk self.vk = vk @classmethod def keygen(cls): sk = [os.urandom(32) for _ in range(32)] vk = [cls.hash(x, 256) for x in sk] return cls(sk, vk) @classmethod def hash(cls, x, n): for _ in range(n): x = sha256(x).digest() return x def sign(self, msg): m = self.</description></item><item><title>yaonet</title><link>https://7rocky.github.io/ctf/other/dicectf/yaonet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/dicectf/yaonet/</guid><description>Se nos proporcionan dos archivos id_ecdsa, id_ecdsa.pub y una instancia remota para conectarnos usando SSH:
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null yaonet@mc.ax -p 31000 -i id_ecdsa La clave privada id_ecdsa está corrupta:
-----BEGIN OPENSSH PRIVATE KEY----- ??????????1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAA???????????????????????? ??????????c3RwMjU2AAAACG5pc3RwMjU2AAAAQQR72Bqp???????????????????????? ??????????1hSxoXrVpRtsx1F2GIgXAqI/6MxuS7Bq86XF???????????????????????? ??????????ZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy???????????????????????? ??????????lSEQfdEcgOhx7zvWFLGhetWlG2zHUXYYiBcC???????????????????????? ??????????37PMrof3dNCpeuwsSUupbaUh3/+7+eDnRH+3???????????????????????? -----END OPENSSH PRIVATE KEY----- Y la clave pública id_ecdsa.pub es correcta:
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHvYGqk903tU4dOcBPTbZ9xl5rlSEQfdEcgOhx7zvWFLGhetWlG2zHUXYYiBcCoj/ozG5LsGrzpcXE3HuEzPEQg= yaonet Tendremos que arreglar la clave privada para conectarnos a la instancia remota y obtener la flag.</description></item></channel></rss>