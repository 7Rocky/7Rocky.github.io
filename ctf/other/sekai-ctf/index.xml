<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sekai CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/sekai-ctf/</link><description>Recent content in Sekai CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/sekai-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>cryptoGRAPHy (1, 2, 3)</title><link>https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/</guid><description>Esta serie de retos está contextualizada en la teoría de grafos combinada con la criptografía. El autor implementó una librería de Python usando networkx para manejar grafos y funciones criptográficas como el cifrado AES, HMAC o el hash SHA256.
Estos retos fueron algo polémicos debido a que los jugadores necesitaban leer, analizar y comprender la librería implementada para el esquema de cifrado de grafos (Graph Encryption Scheme) y luego buscar una solución para el reto correspondiente.</description></item><item><title>Noisy CRC</title><link>https://7rocky.github.io/ctf/other/sekai-ctf/noisy-crc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekai-ctf/noisy-crc/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import secrets from Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 from flag import FLAG def getCRC16(msg, gen_poly): assert (1 &amp;lt;&amp;lt; 16) &amp;lt;= gen_poly &amp;lt; (1 &amp;lt;&amp;lt; 17) # check if deg = 16 msglen = msg.bit_length() msg &amp;lt;&amp;lt;= 16 for i in range(msglen - 1, -1, -1): if (msg &amp;gt;&amp;gt; (i + 16)) &amp;amp; 1: msg ^= (gen_poly &amp;lt;&amp;lt; i) return msg def oracle(secret, gen_poly): res = [secrets.</description></item><item><title>Play to Earn</title><link>https://7rocky.github.io/ctf/other/sekai-ctf/play-to-earn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekai-ctf/play-to-earn/</guid><description>Se nos proporciona un Smart Contract llamado ArcadeMachine.sol:
pragma solidity 0.8.25; import { Coin } from "./Coin.sol"; contract ArcadeMachine { Coin coin; constructor(Coin _coin) { coin = _coin; } function play(uint256 times) external { // burn the coins require(coin.transferFrom(msg.sender, address(0), 1 ether * times)); // Have fun XD } } Y otro Smart Contract llamado Coin.sol:
pragma solidity 0.8.25; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/cryptography/EIP712.sol"; contract Coin is Ownable, EIP712 { string public constant name = "</description></item></channel></rss>