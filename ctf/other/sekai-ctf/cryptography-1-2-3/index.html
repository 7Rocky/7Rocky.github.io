<!doctype html><html lang="es"><head><title>cryptoGRAPHy (1, 2, 3) | 7Rocky</title>
<meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta name="description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtraci√≥n de clave. Descifrado

2: Ruta m√°s corta de destino √∫nico. Grados de un nodo

3: Recuperaci√≥n de consulta. Isomorfismos entre √°rboles
"><meta name="image" content="https://7rocky.github.io/images/cryptography.png"><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,minimum-scale=1"><meta itemprop="description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtraci√≥n de clave. Descifrado

2: Ruta m√°s corta de destino √∫nico. Grados de un nodo

3: Recuperaci√≥n de consulta. Isomorfismos entre √°rboles
"><meta itemprop="keywords" content><meta itemprop="name" content="cryptoGRAPHy (1, 2, 3)"><meta property="article:published_time" content><meta property="og:author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta property="og:description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtraci√≥n de clave. Descifrado

2: Ruta m√°s corta de destino √∫nico. Grados de un nodo

3: Recuperaci√≥n de consulta. Isomorfismos entre √°rboles
"><meta property="og:image" content="https://7rocky.github.io/images/cryptography.png"><meta property="og:locale" content="es_ES"><meta property="og:site_name" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta property="og:title" content="cryptoGRAPHy (1, 2, 3)"><meta property="og:type" content="website"><meta property="og:url" content="https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/"><meta name="twitter:author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta name="twitter:card" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtraci√≥n de clave. Descifrado

2: Ruta m√°s corta de destino √∫nico. Grados de un nodo

3: Recuperaci√≥n de consulta. Isomorfismos entre √°rboles
"><meta name="twitter:description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtraci√≥n de clave. Descifrado

2: Ruta m√°s corta de destino √∫nico. Grados de un nodo

3: Recuperaci√≥n de consulta. Isomorfismos entre √°rboles
"><meta name="twitter:image" content="https://7rocky.github.io/images/cryptography.png"><meta name="twitter:title" content="cryptoGRAPHy (1, 2, 3)"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="/css/style.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><link href="/css/code.css" rel="stylesheet"><link href="https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/" rel="canonical"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z1HQGH3M4D"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z1HQGH3M4D",{anonymize_ip:!1})}</script><script>MathJax={loader:{load:["[tex]/noerrors"]},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process",skipHtmlTags:["noscript","pre","script","style","textarea"]},tex:{autoload:{color:[],colorv2:["color"]},displayMath:[["$$","$$"]],inlineMath:[["$","$"]],packages:{"[+]":["noerrors"]},processEnvironments:!0,processEscapes:!0}}</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><div id="math-consts" style="display:none">$
\newcommand{\e}{e}
\newcommand{\N}[1][]{\mathbb{N}^{#1}}
\newcommand{\Q}[1][]{\mathbb{Q}^{#1}}
\newcommand{\R}[1][]{\mathbb{R}^{#1}}
\newcommand{\Z}[1][]{\mathbb{Z}^{#1}}
\newcommand{\C}[1][]{\mathbb{C}^{#1}}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\dy}{\,\mathrm{d}y}
\newcommand{\dz}{\,\mathrm{d}z}
\newcommand{\dt}{\,\mathrm{d}t}
\newcommand{\divides}{\, | \,}
\newcommand{\st}{\; | \;}
\renewcommand{\geq}{\geqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\i}{\mathrm{i}}
\newcommand{\rank}{\mathop{\mathrm{rank}}}
\newcommand{\gcd}{\mathop{\mathrm{gcd}}}
\newcommand{\tr}{\mathop{\mathrm{tr}}}
\newcommand{\charField}{\mathop{\mathrm{char}}}
\newcommand{\Image}{\mathop{\mathrm{Im}}}
$</div><script src="/js/imc.js"></script><script>(async()=>await typeset(()=>[`#math-consts`]))()</script></head><body class="ma0 production"><header style="position:sticky;top:0;z-index:9"><div class="bg-black"><nav class="ph4-ns" id="navigation" role="navigation"><div class="flex-l justify-between items-center center"><a class="f3 fw2 hover-white no-underline white-90 dib" href="/" title="7Rocky">7Rocky</a><div class="flex-l items-center"><a href="/search" target class="link-transition link dib z-999 pt3 pt0-l mr1 search-link" title="Buscar" rel="noopener" aria-label="Buscar"><svg height="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 487.95 487.95" style="enable-background:new 0 0 487.95 487.95"><g><g><path d="M481.8 453l-140-140.1c27.6-33.1 44.2-75.4 44.2-121.6C386 85.9 299.5.2 193.1.2S0 86 0 191.4s86.5 191.1 192.9 191.1c45.2.0 86.8-15.5 119.8-41.4l140.5 140.5c8.2 8.2 20.4 8.2 28.6.0C490 473.4 490 461.2 481.8 453zM41 191.4c0-82.8 68.2-150.1 151.9-150.1s151.9 67.3 151.9 150.1-68.2 150.1-151.9 150.1S41 274.1 41 191.4z" style="fill-rule:evenodd;clip-rule:evenodd;fill:#a9a9b3"/></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a><a class="link-transition lang link dib z-999 pt3 pt0-l mr3" href="#" title="es"><img alt="es" height="30px" src="/images/es.png" width="30px">
</a><a class="link-transition lang link dib z-999 pt3 pt0-l" href="/en/ctf/other/sekai-ctf/cryptography-1-2-3/" title="en"><img alt="en" height="30px" src="/images/en.png" style="border:4px solid#000;border-radius:100%" width="30px"></a><ul class="pl0 ml3 mr3" style="line-height:30px"><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/ctf/" title="CTF">CTF</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/htb/" title="HTB">HTB</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/imc/" title="IMC">IMC</a></li></ul><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn‚Äî‚ÄîOpens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub‚Äî‚ÄîOpens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></nav></div></header><main class="pb5" role="main" style="min-height:720px"><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-80-l"><a aria-label="aside" class="instapaper_ignoref b tracked" href="../" style="font-size:1.2rem">&lt;- SEKAI CTF</a><div id="sharing" class="mt3"><a aria-label="share on Facebook" class="facebook no-underline" href="https://www.facebook.com/sharer.php?u=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/" title="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a aria-label="share on Twitter" class="twitter no-underline" href="https://twitter.com/share?url=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/&amp;text=cryptoGRAPHy%20%281,%202,%203%29" title="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a aria-label="share on LinkedIn" class="linkedin no-underline" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/&amp;title=cryptoGRAPHy%20%281,%202,%203%29" title="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 mt3 mb1">cryptoGRAPHy (1, 2, 3)</h1><p class="mb4 f6 dib tracked">23 minutos de lectura</p></header><aside aria-label="aside" class="w-20-l mt6-l aside-mobile"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contenidos</p><nav id="TableOfContents"><ul><li><a href="#_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></a><ul><li><a href="#entendiendo-el-cifrado">Entendiendo el cifrado</a></li><li><a href="#comprendiendo-las-consultas">Comprendiendo las consultas</a></li><li><a href="#resumen">Resumen</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#an√°lisis-del-c√≥digo-fuente">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n">Soluci√≥n</a></li><li><a href="#_flag_"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</a></li><li><a href="#an√°lisis-del-c√≥digo-fuente-1">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n-1">Soluci√≥n</a></li><li><a href="#_flag_-1"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#an√°lisis-del-c√≥digo-fuente-2">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n-2">Soluci√≥n</a></li><li><a href="#_flag_-2"><em>Flag</em></a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">üç∫ <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img pr4-l w-80-l"><p>Esta serie de retos est√° contextualizada en la teor√≠a de grafos combinada con la criptograf√≠a. El autor implement√≥ una librer√≠a de Python usando <a href="https://networkx.org/"><code>networkx</code></a> para manejar grafos y funciones criptogr√°ficas como el cifrado AES, HMAC o el <em>hash</em> SHA256.</p><p>Estos retos fueron algo pol√©micos debido a que los jugadores necesitaban leer, analizar y comprender la librer√≠a implementada para el esquema de cifrado de grafos (<em>Graph Encryption Scheme</em>) y luego buscar una soluci√≥n para el desaf√≠o correspondiente. Afortunadamente, la librer√≠a no cambiaba entre niveles. Sin embargo, algunos equipos se quejaron porque la soluci√≥n no implicaba mucha criptograf√≠a, sino mucha teor√≠a de grafos y habilidades de programaci√≥n.</p><p>Adem√°s, los dos primeros retos fueron un poco introductorios para manejarse con la librer√≠a. El √∫ltimo en realidad se inspir√≥ en un ataque realista a un esquema de cifrado de grafos, por lo que es mucho m√°s interesante.</p><p>De todos modos, disfrut√© mucho de los retos porque me hicieron desempolvar mis conocimientos sobre teor√≠a de grafos y matem√°tica discreta, ¬°as√≠ que comencemos!</p><h2 id="_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></h2><p>En la librer√≠a tenemos tres archivos (afortunadamente, la mayor√≠a de funciones y clases tienen <em>docstrings</em>):</p><ul><li><code>GES.py</code>: Implementaci√≥n del esquema de cifrado de grafos</li><li><code>DES.py</code>: Implementaci√≥n del esquema de cifrado de diccionarios.</li><li><code>utils.py</code>: Funciones de utilidad</li></ul><h3 id="entendiendo-el-cifrado">Entendiendo el cifrado</h3><p>Echando un vistazo a <code>server.py</code> de <a href="#cryptography-1">cryptoGRAPHy 1</a>, podemos ver que el servidor siempre comenzar√° definiendo un grafo (con <a href="https://networkx.org/"><code>networkx</code></a>). Luego generar√° una clave con <code>GESClass.keyGen</code> (que llama a <code>DESClass.keyGen</code> por detr√°s):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key key_SKE||key_DES</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">key_DES</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Una vez que se establece la clave, el grafo se cifra usando <code>GESClass.encryptGraph</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Como puede verse, la funci√≥n llama a <code>computeSPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>Esta funci√≥n puede ser un poco dif√≠cil de entender (adem√°s, no hay <em>docstring</em>), porque llama a otra funci√≥n llamada <code>computeSDSP</code>, que se ejecuta dentro de <code>pool.istarmap</code> para acelerar el proceso. El resumen es que <code>computeSDSP</code> se llama con argumentos <code>G</code> y un nodo del grafo, para cada nodo del grafo. Esta es la funci√≥n <code>computeSDSP</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSDSP</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Graph G and a root</span>
<span class="mtk4">    Output: Tuples of the form ((start, root), (ne</span><span class="mtk4">xt_vertex, root))</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">paths</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">single_source_shortest_path</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">path</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">paths</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">():   </span>
<span class="mtk1">        </span><span class="mtk1">path</span><span class="mtk1">.reverse()</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">) </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">)</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">], </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">1</span><span class="mtk1">],</span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">S</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">S</span>
</code></pre></div><p>Nuevamente, esta funci√≥n puede resultar dif√≠cil de entender. La esencia es que la funci√≥n toma <code>root</code> como destino y calcula todas las rutas m√°s cortas a <code>root</code> desde cualquier otro nodo fuente del grafo. (<code>paths</code>). Para cada ruta, los diferentes nodos de la ruta se insertan en un conjunto usando el formato <code>((node, root), (next, root))</code>. Yo interpreto <code>((node, root), (next, root))</code> como:</p><blockquote><p><em>Si estoy en &ldquo;node&rdquo; y quiero llegar al nodo &ldquo;root&rdquo;, el siguiente nodo es &ldquo;next&rdquo;.</em></p></blockquote><p>Al final, el conjunto contendr√° el camino corto m√°s largo hacia <code>root</code> del grafo. Adem√°s, dado que se almacena como <code>(label, value)</code> (donde <code>label = (node, root)</code> y <code>value = (next, root)</code>), podemos encontrar f√°cilmente el camino m√°s corto para <code>root</code> desde cualquier nodo del grafo. De hecho, esto se conoce como camino m√°s corto de un solo destino. (<em>single-destination shortest path</em>, SDSP).</p><p>Repasemos la funci√≥n <code>computeSDPX</code> de nuevo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>Ahora, para cada SDSP del grafo, las variables <code>label</code> y <code>value</code> se traducen a bytes (una traducci√≥n simple):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">str</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">).</span><span class="mtk8">encode</span><span class="mtk1">()</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">: </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">[</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk8 mtku">int</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">])</span>  
</code></pre></div><p>Luego, utiliza la etiqueta (<code>label_bytes</code>) como clave de un diccionario (<code>SPDX</code>). El valor del diccionario correspondiente est√° cifrado.</p><p>Para cifrar el valor del diccionario, primero se genera un <code>token</code> sobre <code>value_bytes</code> usando <code>key_DES</code> (<code>key[16:]</code> de la primera <code>key</code> generada):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">label</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a label</span>
<span class="mtk4">        Output: A token on label</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">K2</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Donde <code>utils.HashMAC</code> implementa HMAC con SHA256:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Key and plaintext</span>
<span class="mtk4">    Output: A token on plaintext with the key usin</span><span class="mtk4">g HMAC</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">HMAC</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">digestmod</span><span class="mtk5">=</span><span class="mtk8 mtku">SHA256</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">update</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">digest</span><span class="mtk1">()</span>
</code></pre></div><p>Entonces, podemos suponer que <code>token</code> est√° exclusivamente relacionado con <code>value_bytes</code> (lo que significa que para cada combinaci√≥n de <code>(next, node)</code>, hay un solo <code>token</code> asociado). Obs√©rvese que <code>token</code> tiene 32 bytes.</p><p>Continuando con el cifrado, <code>value_bytes</code> se cifra con AES usando <code>key_SKE</code> (<code>key[:16]</code>) como clave. V√©anse <code>utils.SymmetricEncrypt</code> / <code>utils.SymmetricDecrypt</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Encrypt the plaintext using AES-CBC mode with </span><span class="mtk4">provided key.</span>
<span class="mtk4">    Input: 16-byte key and plaintext</span>
<span class="mtk4">    Output: Ciphertext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">encrypt</span><span class="mtk1">(</span><span class="mtk8">pad</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk1">iv</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">iv</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Decrypt the ciphertex using AES-CBC mode with </span><span class="mtk4">provided key.</span>
<span class="mtk4">    Input: 16-byte key and ciphertext</span>
<span class="mtk4">    Output: Plaintext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[:</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">pt</span>
</code></pre></div><p>Obs√©rvese que el IV del cifrado AES CBC se agrega al texto cifrado al final despu√©s de la operaci√≥n y se toma del texto cifrado para su descifrado.</p><p>Finalmente, el valor <code>token + ct</code> se agrega a <code>SPDX[label_bytes]</code>.</p><p>Ok, pero a√∫n no hemos terminado. Recordemos <code>GESClass.encryptGraph</code>, solo hemos calculado <code>SPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>El siguiente paso es coger <code>key_DES</code> (<code>key[16:]</code>) y llamar a <code>DESClass.encryptDict</code> para cifrar el diccionario <code>SPDX</code> completo, que es el valor a devolver:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">], </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a plaintext dictionary</span>
<span class="mtk4">        Output: An encrypted dictionary EDX</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">encrypted_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">        </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">)</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">encryptDictHelper</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):   </span>
<span class="mtk1">                </span><span class="mtk1">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">ct_label</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">encrypted_db</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Nuevamente, es un poco extra√±o de leer, pero es muy similar a lo anterior. Esta llamando a <code>encryptDictHelper</code> con <code>(key, label_bytes, token + ct)</code> como argumentos para cada par <code>label_bytes</code> - <code>token + ct</code> en el diccionario.</p><p>Y <code>encryptDictHelper</code> realiza las siguientes operaciones:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDictHelper</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">ct_label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">)</span>  
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span>
</code></pre></div><p>N√≥tese que <code>K1</code> es <code>token[:16]</code> y <code>K2</code> es <code>token[16:]</code>. Por lo tanto, simplemente genera el <em>hash</em> SHA256 de <code>K1</code> y cifra <code>token + ct</code> con AES usando <code>K2</code> como clave. Esos ser√°n los pares clave-valor del diccionario cifrado <code>EDB</code>.</p><h3 id="comprendiendo-las-consultas">Comprendiendo las consultas</h3><p>Todav√≠a hay dos m√©todos de los que a√∫n no hemos hablado: <code>GESClass.search</code> y <code>DESClass.search</code>. El primero llama al segundo por detr√°s y se usa para encontrar el camino m√°s corto entre dos nodos del grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">):</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token</span>
<span class="mtk4">        Output: (tokens, cts)</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span>
<span class="mtk1">        </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">token</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">curr</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[</span><span class="mtk6">32</span><span class="mtk1">:]</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">curr</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">tuple</span><span class="mtk1">([</span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">])</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">search_token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token and EDX</span>
<span class="mtk4">        Output: The corresponding encrypted value.</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">        </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">hash_val</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>B√°sicamente, para buscar el camino m√°s corto desde <code>A</code> hasta <code>B</code>, se genera un <code>token</code> (que identifica la etiqueta <code>(A, B)</code>) y se busca en <code>EDB</code> (tambi√©n llamado <code>encrypted_db</code>). Recordemos que <code>token = K1 + K2</code>, por lo que <code>K1</code> es la clave del diccionario y <code>K2</code> es la clave AES para descifrar el valor del diccionario. S√≥lo se devuelve el valor de <code>DESClass.search</code>.</p><p>Imaginemos que el siguiente nodo desde <code>A</code> en el cambino m√°s corto es <code>C</code>, entonces la salida de <code>DESClass.search</code> en este ejemplo ser√° <code>token + ct</code>. Este <code>token</code> se corresponder√≠a con <code>(C, B)</code> y <code>ct</code> estar√≠a cifrado con AES y <code>key_SKE</code>, que se portar√≠a precisamente la etiqueta <code>(C, B)</code>.</p><p>Para cada resultado de <code>DESClass.search</code>, el resultado se divide en <code>token</code> y <code>ct</code> y ambas se agregan a <code>tok</code> y <code>resp</code>, respectivamente. Finalmente, la tupla <code>(tok, resp)</code> se devuelve desde <code>GESClass.search</code>.</p><h3 id="resumen">Resumen</h3><ul><li><code>GESClass.keyGen</code>: Genera <code>key</code> como <code>key_SKE</code> y <code>key_DES</code>. Luego, <code>key[:16]</code> se emplea para el cifrado AES y <code>key[16:]</code> para HMAC</li><li><em>Single-destination shortest path</em> (SDSP): Representa todos los caminos m√°s cortos desde todos los nodos hasta un √∫nico destino. Cada entrada se representa como <code>((node, root), (next, root))</code>, para que puedan encadenarse para construir un camino m√°s corto desde un <code>node</code> hasta <code>root</code></li><li><code>SPDX</code>: Es un diccionario que mapea <code>(node, root)</code> con <code>token + ct</code> (relacionado con <code>(next, root)</code>)</li><li><code>DESClass.tokenGen</code> (y <code>GESClass.tokenGen</code>): Define un <em>token</em> √∫nico para una etiqueta <code>(node, root)</code>. Es un valor de 32 bytes compuesto por valores de 16 bytes <code>K1</code> y <code>K2</code></li><li><code>EDB</code> (<code>encrypted_db</code>): Es un diccionario que asigna el <em>hash</em> SHA256 de <code>K1</code> y el valor cifrado con AES de <code>token + ct</code> usando <code>K2</code> como clave</li><li><code>GESClass.search</code>: Busca la ruta m√°s corta desde un origen a un destino en el SDSP y devuelve la concatenaci√≥n de todos los <code>token</code> (asociados a <code>(node, root)</code>) de la ruta y todos los textos cifrados (en realidad, <code>token + ct</code>)</li></ul><h2 id="cryptography-1">cryptoGRAPHy 1</h2><p>Se nos proporciona el c√≥digo fuente del servidor, que utiliza algunas funciones de la <a href="#graph-encryption-scheme">librer√≠a de <em>Graph Encryption Scheme</em></a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">260</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">16</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">node_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk9 mtki">node_count</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">) </span><span class="mtk5">&lt;</span><span class="mtk1"> </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk1">nodes</span><span class="mtk1">, </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">([</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">])</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">)</span>


<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Answer 50 queries to get the flag. In each qu</span><span class="mtk4">ery, input the shortest path </span><span class="mtk6">\</span>  
<span class="mtk4">              decrypted from response. It will be </span><span class="mtk4">a string of space-separated nodes from </span><span class="mtk6">\</span>
<span class="mtk4">              source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><p>Obs√©rvese que hay una funci√≥n llamada <code>decrypt</code> que est√° oculta para nosotros.</p><h3 id="an√°lisis-del-c√≥digo-fuente">An√°lisis del c√≥digo fuente</h3><p>Primero, el servidor genera un grafo aleatorio, genera una clave (¬°que se muestra!) y cifra el grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>  
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>
</code></pre></div><p>Despu√©s de eso, se nos pide que respondamos correctamente a 50 consultas para obtener la <em>flag</em>. Para cada consulta, el servidor tomar√° dos nodos aleatorios (<code>u</code> y <code>v</code>) del grafo que est√©n conectados y encontrar√° el camino m√°s corto entre ellos. Se nos dar√° el <code>token</code> para <code>(u, v)</code> y la parte <code>resp</code> de <code>GESClass.search</code> (los textos cifrados):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="soluci√≥n">Soluci√≥n</h3><p>Recordemos del an√°lisis la <a href="#graph-encryption-scheme">librer√≠a de <em>Graph Encryption Scheme</em></a> que <code>resp</code> est√° cifrado con AES y la clave <code>key_SKE</code>, que es <code>key[:16]</code> (la sabemos desde el principio). Entonces, podemos encontrar todos los nodos intermedios desde <code>u</code> hasta <code>v</code> (incluido <code>v</code> pero no <code>u</code>) descifrando cada fragmento de 32 bytes (16 para texto cifrado y 16 para IV). El valor de <code>u</code> lo imprime el servidor, por lo que no es un problema aqu√≠.</p><p>Podemos implementar esto f√°cilmente con Python. Este es el c√≥digo relevante:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Key: '</span><span class="mtk1">)</span>
<span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk1">DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 50'</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'/50: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">ct_iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [(</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">]) </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">ct_iv</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">pt</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1">)[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk1">shortest_path</span><span class="mtk1">))</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'50 / 50'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="_flag_"><em>Flag</em></h3><p>Una vez que ejecutemos el <em>script</em>, encontraremos la <em>flag</em>:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3001
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3001: Done  
[<span class="code-green">+</span>] Round: 50 / 50
[+] Flag: SEKAI{GES_15_34sy_2_br34k_kn@w1ng_th3_k3y}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3001
</code></pre></div><p>El <em>script</em> completo se puede encontrar aqu√≠: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%201/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-2">cryptoGRAPHy 2</h2><p>Para esta segunda parte, se nos proporciona el c√≥digo fuente del servidor, que nuevamente utiliza algunas funciones de la <a href="#graph-encryption-scheme">librer√≠a de <em>Graph Encryption Scheme</em></a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_PROB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">0.031</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">32</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">() -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">fast_gnp_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">n</span><span class="mtk5">=</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk9 mtki">p</span><span class="mtk5">=</span><span class="mtk1">EDGE_PROB</span><span class="mtk1">)</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</h3><p>Ahora, el servidor oculta una funci√≥n llamada <code>get_SDSP_node_degrees</code>, pero al menos nos explica lo que hace:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>
</code></pre></div><p>Este reto me hizo comprender exactamente el concepto de SDSP. El ejemplo dibujado puede ser un poco breve para generalizar, as√≠ que dibujemos el segundo ejemplo. Este es el grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><p>Ahora, el destino es <code>1</code>, as√≠ que busquemos las rutas m√°s cortas desde cada nodo:</p><ul><li><code>2</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----</span><span class="mtk7">2</span>  
|    |    |
7----6----5
</code></pre></div><ul><li><code>4</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7">4</span><span class="mtk8">----</span><span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><ul><li><code>5</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----2</span>  
|    |    <span class="mtk8">|</span>
7----6----</span><span class="mtk7">5</span>
</code></pre></div><ul><li><code>6</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    <span class="mtk8">|</span>    |
7----<span class="mtk7">6</span>----5
</code></pre></div><ul><li><code>7</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk8">4----</span><span class="mtk5">1</span>----2  
<span class="mtk8">|</span>    |    |
<span class="mtk7">7</span>----6----5
</code></pre></div><p>Entonces, el SDSP es el grafo inicial pero eliminando los bordes no utilizados, y en realidad es un √°rbol:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----1----2  
|    |    |
7    6    5
</code></pre></div><p>Y la salida de <code>get_SDSP_node_degrees</code> es una lista de los grados de cada nodo del SDSP (el grado de un nodo es el n√∫mero de nodos adyacentes de dicho nodo), ordenados en orden ascendente. Por lo tanto, el resultado para este ejemplo es <code>1 1 1 2 2 3</code>. Podemos reemplazar los identificadores de los nodos por su grado correspondiente, para ilustrar el concepto de grado de un nodo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">2----3----2  
|    |    |
1    1    1
</code></pre></div><h3 id="an√°lisis-del-c√≥digo-fuente-1">An√°lisis del c√≥digo fuente</h3><p>Esta vez, el servidor no imprime la <code>key</code>&mldr; Necesitaremos obtener la salida de <code>get_SDSP_node_degrees</code> un total de 10 veces.</p><p>La inicializaci√≥n es la misma que antes (se genera un grafo aleatorio, se generaa la clave y se cifra el grafo). Despu√©s de eso, el servidor toma un punto de destino aleatorio, que se imprime en texto claro:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>  
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><p>El servidor nos permite realizar hasta 130 consultas (<code>NODE_COUNT</code>, el n√∫mero de nodos en el grafo), y se nos dar√° el <code>token</code> para nuestra entrada <code>(u, v)</code>, as√≠ como <code>tok</code> y <code>resp</code> de <code>GESClass.search</code> (concatenados):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>  
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="soluci√≥n-1">Soluci√≥n</h3><p>Entonces, intentaremos encontrar el SDSP para un nodo de destino determinado. Por lo tanto, todas las consultas a realizar deben ser <code>(node, root)</code>, donde <code>root</code> es el punto de destino dado.</p><p>Adem√°s, obs√©rvese que hay una comprobaci√≥n de que <code>u != v</code>. Podemos usar esto para romper el bucle <code>while</code> enviando <code>(root, root)</code> al final, cuando ya tengamos los otros 129 resultados de la consulta, y luego intentar adivinar el resultado de <code>getSDSP_node_degrees</code>.</p><p>Para cada ronda, haremos lo siguiente:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">data</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">NODES_SIZE</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Destination: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk1">NODES_SIZE</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">dest</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">continue</span>

<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">i</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span>] <span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>  

<span class="mtk1">        </span><span class="mtk1">data</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">b</span><span class="mtk1">: </span><span class="mtk9 mtki">b</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">(), </span><span class="mtk1">keys</span><span class="mtk1">))</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>
</code></pre></div><p>Estamos tomando el <code>token</code>, que est√° relacionado con <code>(node, root)</code>, y luego tomamos la parte <code>token</code> de la respuesta del servidor (la primera mitad son todos los <em>tokens</em> de 32 bytes para cada etiqueta <code>(next, root)</code> en la ruta m√°s corta). Los guardaremos en un diccionario <code>data</code> para cada nodo.</p><p>Adem√°s, usaremos el <code>token</code> para identificar cada nodo (guardado en la lista <code>nodes</code>), y uno de los ultimos valores de <code>token</code> de <code>res</code> como identificador del destino (<code>(root, root)</code>).</p><p>Una vez que tengamos esta informaci√≥n, podemos generar el grafo SDSP guardando todas las aristar posibles en un conjunto (siguiendo los caminos m√°s cortos):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">d</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">data</span><span class="mtk1">.</span><span class="mtk8">values</span><span class="mtk1">():</span>
<span class="mtk1">        </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1">, </span><span class="mtk1">next_node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">enumerate</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">:] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]]):</span>
<span class="mtk1">            </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">prev_node</span><span class="mtk1">, </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">))</span>

<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> (</span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">] </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> (</span><span class="mtk1">dest</span><span class="mtk1">, </span><span class="mtk6">0</span><span class="mtk1">):</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">(</span><span class="mtk1">edge</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
</code></pre></div><p>Y el √∫ltimo paso es tomar los grados de los nodos y ordenarlos:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">degrees</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">sorted</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">t</span><span class="mtk1">: </span><span class="mtk9 mtki">t</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">G</span><span class="mtk1">.degree))</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Answer: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">degrees</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  
</code></pre></div><h3 id="_flag_-1"><em>Flag</em></h3><p>Podemos ejecutar el <em>script</em> para calcular lo anterior 10 veces y obtener la <em>flag</em>:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3062
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3062: Done  
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{3ff1c13nt_GES_4_Shortest-Path-Queries-_-}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3062
</code></pre></div><p>El <em>script</em> completo se puede encontrar aqu√≠: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%202/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-3">cryptoGRAPHy 3</h2><p>Para el √∫ltimo reto de la serie, se nos proporciona nuevamente el c√≥digo fuente del servidor:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">itertools</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">, </span><span class="mtk8 mtku">chain</span>
<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">multiprocessing</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk1">Pool</span>
<span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, generate_tree, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">60</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">128</span>
<span class="mtk1">MENU</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk4">'''============ MENU ============</span>
<span class="mtk4">1. Graph Information</span>
<span class="mtk4">2. Query Responses</span>
<span class="mtk4">3. Challenge</span>
<span class="mtk4">4. Exit</span>
<span class="mtk4">=============================='''</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_tree()</span>
<span class="mtk1">        </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Recover 10 queries in 30 seconds. It is guara</span><span class="mtk4">nteed that each answer is unique."</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">MENU</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Option: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"2"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Responses: "</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">myGES</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"3"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="an√°lisis-del-c√≥digo-fuente-2">An√°lisis del c√≥digo fuente</h3><p>Nuevamente, el servidor no imprime la <code>key</code>&mldr; Pero en su lugar, se nos da el grafo inicial en texto claro (opci√≥n <code>1</code>):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
</code></pre></div><p>Particularmente, el grafo es un √°rbol que se genera con una funci√≥n oculta llamada <code>generate_tree</code>. Al principio, esto fue un poco extra√±o para m√≠, ya que <a href="https://networkx.org/"><code>networkx</code></a> tiene una funci√≥n llamada <a href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.trees.random_tree.html#random-tree"><code>random_tree</code></a>, por lo que no hay raz√≥n para ocultarla. Al realizar algunas pruebas en local, descubr√≠ que si dos nodos est√°n al mismo nivel, el reto no se pod√≠a resolver porque esos nodos no se pueden distinguir cuando est√°n cifrados. Luego, mirando el √°rbol generado por el servidor, no hab√≠a ning√∫n par de nodos al mismo nivel, por lo que el reto s√≠ ten√≠a soluci√≥n y la funci√≥n <code>generate_tree</code> (oculta) se encargar√≠a de evitar esa situaci√≥n.</p><p>En la opci√≥n <code>2</code>, se nos dar√°n las respuestas (<code>(tok, resp)</code>) a todas las consultas posibles en el grafo, que tiene un total de 60 nodos. Por lo tanto, recibiremos un total de $60^2 = 3600$ respuestas. El problema es que la lista de respuestas est√° desordenada:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>  
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>
</code></pre></div><p>Una vez recibida toda la informaci√≥n, podemos usar la opci√≥n <code>3</code> para comenzar el reto real: durante 10 rondas, el servidor tomar√° dos nodos aleatorios <code>u</code> y <code>v</code> del grafo que est√©n conectados y nos solicitar√° que pongamos la consulta original (es decir, el camino m√°s corto entre ellos). Se nos dar√° el <code>token</code> para <code>(u, v)</code> y el resultado de <code>GESClass.search</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="soluci√≥n-2">Soluci√≥n</h3><p>En primer lugar, podemos tomar toda la informaci√≥n de las opciones <code>1</code> y <code>2</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Edges: '</span><span class="mtk1">)</span>
<span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk8">eval</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()))</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">()</span>

<span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">line</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()[:</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk4">'MENU'</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">line</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">break</span>

<span class="mtk1">    </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">, </span><span class="mtk1">line</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">' '</span><span class="mtk1">))</span>

<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">({</span>
<span class="mtk1">        </span><span class="mtk4">'token'</span><span class="mtk1">: </span><span class="mtk1">tok</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">(),</span>
<span class="mtk1">        </span><span class="mtk4">'tok'</span><span class="mtk1">: [</span><span class="mtk1">tok</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">32</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">tok</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)],</span>  
<span class="mtk1">        </span><span class="mtk4">'res'</span><span class="mtk1">: [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    })</span>
</code></pre></div><p>Observe c√≥mo utilic√© una lista <code>queries</code> (que contendr√° un total de 3600 elementos) con un <code>token</code> y dos listas para <code>tok</code> y <code>res</code>.</p><p>Echando un vistazo a la lista <code>queries</code>, podemos descubrir que hay exactamente 60 elementos con <code>tok</code> y <code>res</code> vac√≠os dado que son consultas de la forma <code>(root, root)</code>. Podemos usar estos elementos para identificar nodos del grafo, as√≠ que vamos a separarlos en otra lista:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">toks_0</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">]</span>  
</code></pre></div><p>En realidad, cada <em>token</em> en <code>tok_0</code> aparecer√° en otros elementos de las listas <code>queries.tok</code> en la √∫ltima posici√≥n, ya que <code>(root, root)</code> es un destino. As√≠, podemos encontrar todos los <code>token</code> de la forma <code>(node, root)</code> que contienen un <code>token</code> dado de <code>tok_0</code> en su lista <code>tok</code>.</p><p>Y lo que es m√°s interesante, podemos unir todos los <code>token</code> en un grafo. En realidad, este grafo ser√° un √°rbol. Esto es muy importante, porque los √°rboles no contienen ning√∫n ciclo, por lo que el camino entre dos nodos es en realidad el camino m√°s corto entre ellos. Y lo que es a√∫n m√°s alucinante, podemos encontrar un mapeo entre el √°rbol <code>token</code> y el √°rbol de texto claro que tenemos desde el principio.</p><p>En t√©rminos matem√°ticos, esto se llama isomorfismo entre √°rboles, que define una relaci√≥n uno a uno entre los nodos de dos √°rboles. Afortunadamente, <a href="https://networkx.org/"><code>networkx</code></a> proporciona una funci√≥n para encontrar un isomorfismo entre √°rboles. (<a href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism.html#networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism"><code>tree_isomorphism</code></a>), para que podamos hacer coincidir cada <code>token</code> con un nodo de texto claro:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">mappings</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">define_tree</span><span class="mtk1">(</span><span class="mtk9 mtki">queries</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">][</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1">:</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">node</span><span class="mtk1">, </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]))</span>

<span class="mtk1">    </span><span class="mtk1">GG</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">isomorphism</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">tree_isomorphism</span><span class="mtk1">(</span><span class="mtk1">GG</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">enc</span><span class="mtk1">, </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">isomorphism</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">enc</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">node</span>
</code></pre></div><p>Y este proceso hay que hacerlo 60 veces, ya que hay un total de 60 destinos diferentes:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">toks_0</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk8">define_tree</span><span class="mtk1">([</span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">] </span><span class="mtk5">or</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]])</span>  
</code></pre></div><p>Una vez que tengamos el mapeo entre el<code>token</code> cifrado y el nodo de texto claro, podemos encontrar f√°cilmente la ruta m√°s corta de la consulta que se nos proporciona buscando en el diccionario <code>mapping</code>. Y eso es precisamente lo que estamos haciendo aqu√≠:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'3'</span><span class="mtk1">)</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 10'</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>

<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">key</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">shortest_path</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'10 / 10'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="_flag_-2"><em>Flag</em></h3><p>Una vez que ejecutemos el <em>script</em> veremos la <em>flag</em> (que nos da un <em>paper</em> que describe este ataque de recuperaci√≥n de consulta con mucho m√°s detalle):</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3023
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3023: Done
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{Full_QR_Attack_is_not_easy_https://eprint.iacr.org/2022/838.pdf}  
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3023
</code></pre></div><p>El <em>script</em> completo se puede encontrar aqu√≠: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%203/solve.py"><code>solve.py</code></a>.</p><div class="mt6 instapaper_ignoref"></div></div><aside aria-label="aside" class="w-20-l aside-desktop"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contenidos</p><nav id="TableOfContents"><ul><li><a href="#_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></a><ul><li><a href="#entendiendo-el-cifrado">Entendiendo el cifrado</a></li><li><a href="#comprendiendo-las-consultas">Comprendiendo las consultas</a></li><li><a href="#resumen">Resumen</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#an√°lisis-del-c√≥digo-fuente">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n">Soluci√≥n</a></li><li><a href="#_flag_"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</a></li><li><a href="#an√°lisis-del-c√≥digo-fuente-1">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n-1">Soluci√≥n</a></li><li><a href="#_flag_-1"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#an√°lisis-del-c√≥digo-fuente-2">An√°lisis del c√≥digo fuente</a></li><li><a href="#soluci√≥n-2">Soluci√≥n</a></li><li><a href="#_flag_-2"><em>Flag</em></a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">üç∫ <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside></article></main><footer class="bottom-0 w-100" role="contentinfo"><div class="tc mw8 ph3" style="margin:auto"><form style="background-color:var(--background-card)" class="tc mw8 pv3 mb3" action="https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter" target="popupwindow" onsubmit='return window.open("https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter"),!0'><h3 class="tc">7Rocky's Blog Weekly Newsletter</h3><p class="tc"><input class="f5 pv3 ph3 bn" style="background-color:var(--background);color:inherit;font-weight:700;line-height:normal" type="submit" value="Recibe un resumen semanal del blog"></p><input type="hidden" value="1" name="embed">
<input style="display:none;color:var(--header)" type="submit" value="Suscribirse"><p class="tc"><a href="/en/newsletters/" target="_blank" title="View letter archive">Ver historial de res√∫menes</a></p><p class="tc">impulsado por <a href="http://www.mailchimp.com" target="_blank" title="Mailchimp">Mailchimp</a></p></form></div><div class="bg-black w-100 pa3" role="contentinfo"><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://7rocky.github.io/" title="https://7rocky.github.io/">&copy; Blog de 7Rocky. Ciberseguridad y Mates 2023</a><div style="margin-top:8px"><div><div><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn‚Äî‚ÄîOpens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub‚Äî‚ÄîOpens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></div></div></div></footer></body></html>