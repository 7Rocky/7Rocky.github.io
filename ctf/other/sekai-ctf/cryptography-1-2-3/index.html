<!doctype html><html lang="es"><head><title>cryptoGRAPHy (1, 2, 3) | 7Rocky</title>
<meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta name="description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtración de clave. Descifrado

2: Ruta más corta de destino único. Grados de un nodo

3: Recuperación de consulta. Isomorfismos entre árboles
"><meta name="image" content="https://7rocky.github.io/images/cryptography.png"><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,minimum-scale=1"><meta itemprop="description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtración de clave. Descifrado

2: Ruta más corta de destino único. Grados de un nodo

3: Recuperación de consulta. Isomorfismos entre árboles
"><meta itemprop="keywords" content><meta itemprop="name" content="cryptoGRAPHy (1, 2, 3)"><meta property="article:published_time" content><meta property="og:author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta property="og:description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtración de clave. Descifrado

2: Ruta más corta de destino único. Grados de un nodo

3: Recuperación de consulta. Isomorfismos entre árboles
"><meta property="og:image" content="https://7rocky.github.io/images/cryptography.png"><meta property="og:locale" content="es_ES"><meta property="og:site_name" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta property="og:title" content="cryptoGRAPHy (1, 2, 3)"><meta property="og:type" content="website"><meta property="og:url" content="https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/"><meta name="twitter:author" content="Blog de 7Rocky. Ciberseguridad y Mates"><meta name="twitter:card" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtración de clave. Descifrado

2: Ruta más corta de destino único. Grados de un nodo

3: Recuperación de consulta. Isomorfismos entre árboles
"><meta name="twitter:description" content="Sekai CTF 2023. _Graph Encryption Scheme_

1: Filtración de clave. Descifrado

2: Ruta más corta de destino único. Grados de un nodo

3: Recuperación de consulta. Isomorfismos entre árboles
"><meta name="twitter:image" content="https://7rocky.github.io/images/cryptography.png"><meta name="twitter:title" content="cryptoGRAPHy (1, 2, 3)"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="/css/style.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><link href="/css/code.css" rel="stylesheet"><link href="https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/" rel="canonical"><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z1HQGH3M4D"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z1HQGH3M4D",{anonymize_ip:!1})}</script><script>MathJax={loader:{load:["[tex]/noerrors"]},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process",skipHtmlTags:["noscript","pre","script","style","textarea"]},tex:{autoload:{color:[],colorv2:["color"]},displayMath:[["$$","$$"]],inlineMath:[["$","$"]],packages:{"[+]":["noerrors"]},processEnvironments:!0,processEscapes:!0}}</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><div id="math-consts" style="display:none">$
\newcommand{\e}{e}
\newcommand{\N}[1][]{\mathbb{N}^{#1}}
\newcommand{\Q}[1][]{\mathbb{Q}^{#1}}
\newcommand{\R}[1][]{\mathbb{R}^{#1}}
\newcommand{\Z}[1][]{\mathbb{Z}^{#1}}
\newcommand{\C}[1][]{\mathbb{C}^{#1}}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\dy}{\,\mathrm{d}y}
\newcommand{\dz}{\,\mathrm{d}z}
\newcommand{\dt}{\,\mathrm{d}t}
\newcommand{\divides}{\, | \,}
\newcommand{\st}{\; | \;}
\renewcommand{\geq}{\geqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\i}{\mathrm{i}}
\newcommand{\rank}{\mathop{\mathrm{rank}}}
\newcommand{\gcd}{\mathop{\mathrm{gcd}}}
\newcommand{\tr}{\mathop{\mathrm{tr}}}
\newcommand{\charField}{\mathop{\mathrm{char}}}
\newcommand{\Image}{\mathop{\mathrm{Im}}}
$</div><script src="/js/imc.js"></script><script>(async()=>await typeset(()=>[`#math-consts`]))()</script></head><body class="ma0 production"><header style="position:sticky;top:0;z-index:9"><div class="bg-black"><nav class="ph4-ns" id="navigation" role="navigation"><div class="flex-l justify-between items-center center"><a class="f3 fw2 hover-white no-underline white-90 dib" href="/" title="7Rocky">7Rocky</a><div class="flex-l items-center"><a href="/search" target class="link-transition link dib z-999 pt3 pt0-l mr1 search-link" title="Buscar" rel="noopener" aria-label="Buscar"><svg height="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 487.95 487.95" style="enable-background:new 0 0 487.95 487.95"><g><g><path d="M481.8 453l-140-140.1c27.6-33.1 44.2-75.4 44.2-121.6C386 85.9 299.5.2 193.1.2S0 86 0 191.4s86.5 191.1 192.9 191.1c45.2.0 86.8-15.5 119.8-41.4l140.5 140.5c8.2 8.2 20.4 8.2 28.6.0C490 473.4 490 461.2 481.8 453zM41 191.4c0-82.8 68.2-150.1 151.9-150.1s151.9 67.3 151.9 150.1-68.2 150.1-151.9 150.1S41 274.1 41 191.4z" style="fill-rule:evenodd;clip-rule:evenodd;fill:#a9a9b3"/></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></a><a class="link-transition lang link dib z-999 pt3 pt0-l mr3" href="#" title="es"><img alt="es" height="30px" src="/images/es.png" width="30px">
</a><a class="link-transition lang link dib z-999 pt3 pt0-l" href="/en/ctf/other/sekai-ctf/cryptography-1-2-3/" title="en"><img alt="en" height="30px" src="/images/en.png" style="border:4px solid#000;border-radius:100%" width="30px"></a><ul class="pl0 ml3 mr3" style="line-height:30px"><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/ctf/" title="CTF">CTF</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/htb/" title="HTB">HTB</a></li><li class="list f5 f4-ns fw4 dib pr2 pl2"><a class="hover-white no-underline white-90" href="/imc/" title="IMC">IMC</a></li></ul><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn——Opens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub——Opens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></nav></div></header><main class="pb5" role="main" style="min-height:720px"><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-80-l"><a aria-label="aside" class="instapaper_ignoref b tracked" href="../" style="font-size:1.2rem">&lt;- SEKAI CTF</a><div id="sharing" class="mt3"><a aria-label="share on Facebook" class="facebook no-underline" href="https://www.facebook.com/sharer.php?u=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/" title="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a aria-label="share on Twitter" class="twitter no-underline" href="https://twitter.com/share?url=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/&amp;text=cryptoGRAPHy%20%281,%202,%203%29" title="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a aria-label="share on LinkedIn" class="linkedin no-underline" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://7rocky.github.io/ctf/other/sekai-ctf/cryptography-1-2-3/&amp;title=cryptoGRAPHy%20%281,%202,%203%29" title="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 mt3 mb1">cryptoGRAPHy (1, 2, 3)</h1><p class="mb4 f6 dib tracked">23 minutos de lectura</p></header><aside aria-label="aside" class="w-20-l mt6-l aside-mobile"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contenidos</p><nav id="TableOfContents"><ul><li><a href="#_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></a><ul><li><a href="#entendiendo-el-cifrado">Entendiendo el cifrado</a></li><li><a href="#comprendiendo-las-consultas">Comprendiendo las consultas</a></li><li><a href="#resumen">Resumen</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#análisis-del-código-fuente">Análisis del código fuente</a></li><li><a href="#solución">Solución</a></li><li><a href="#_flag_"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</a></li><li><a href="#análisis-del-código-fuente-1">Análisis del código fuente</a></li><li><a href="#solución-1">Solución</a></li><li><a href="#_flag_-1"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#análisis-del-código-fuente-2">Análisis del código fuente</a></li><li><a href="#solución-2">Solución</a></li><li><a href="#_flag_-2"><em>Flag</em></a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">🍺 <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img pr4-l w-80-l"><p>Esta serie de retos está contextualizada en la teoría de grafos combinada con la criptografía. El autor implementó una librería de Python usando <a href="https://networkx.org/"><code>networkx</code></a> para manejar grafos y funciones criptográficas como el cifrado AES, HMAC o el <em>hash</em> SHA256.</p><p>Estos retos fueron algo polémicos debido a que los jugadores necesitaban leer, analizar y comprender la librería implementada para el esquema de cifrado de grafos (<em>Graph Encryption Scheme</em>) y luego buscar una solución para el desafío correspondiente. Afortunadamente, la librería no cambiaba entre niveles. Sin embargo, algunos equipos se quejaron porque la solución no implicaba mucha criptografía, sino mucha teoría de grafos y habilidades de programación.</p><p>Además, los dos primeros retos fueron un poco introductorios para manejarse con la librería. El último en realidad se inspiró en un ataque realista a un esquema de cifrado de grafos, por lo que es mucho más interesante.</p><p>De todos modos, disfruté mucho de los retos porque me hicieron desempolvar mis conocimientos sobre teoría de grafos y matemática discreta, ¡así que comencemos!</p><h2 id="_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></h2><p>En la librería tenemos tres archivos (afortunadamente, la mayoría de funciones y clases tienen <em>docstrings</em>):</p><ul><li><code>GES.py</code>: Implementación del esquema de cifrado de grafos</li><li><code>DES.py</code>: Implementación del esquema de cifrado de diccionarios.</li><li><code>utils.py</code>: Funciones de utilidad</li></ul><h3 id="entendiendo-el-cifrado">Entendiendo el cifrado</h3><p>Echando un vistazo a <code>server.py</code> de <a href="#cryptography-1">cryptoGRAPHy 1</a>, podemos ver que el servidor siempre comenzará definiendo un grafo (con <a href="https://networkx.org/"><code>networkx</code></a>). Luego generará una clave con <code>GESClass.keyGen</code> (que llama a <code>DESClass.keyGen</code> por detrás):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key key_SKE||key_DES</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">key_DES</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Security parameter</span>
<span class="mtk4">        Output: Secret key</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">get_random_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">security_parameter</span><span class="mtk1">)</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Una vez que se establece la clave, el grafo se cifra usando <code>GESClass.encryptGraph</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Como puede verse, la función llama a <code>computeSPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>Esta función puede ser un poco difícil de entender (además, no hay <em>docstring</em>), porque llama a otra función llamada <code>computeSDSP</code>, que se ejecuta dentro de <code>pool.istarmap</code> para acelerar el proceso. El resumen es que <code>computeSDSP</code> se llama con argumentos <code>G</code> y un nodo del grafo, para cada nodo del grafo. Esta es la función <code>computeSDSP</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSDSP</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Graph G and a root</span>
<span class="mtk4">    Output: Tuples of the form ((start, root), (ne</span><span class="mtk4">xt_vertex, root))</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">paths</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">single_source_shortest_path</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">path</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">paths</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">():   </span>
<span class="mtk1">        </span><span class="mtk1">path</span><span class="mtk1">.reverse()</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">) </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">path</span><span class="mtk1">)</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">], </span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">path</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">1</span><span class="mtk1">],</span><span class="mtk9 mtki">root</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">S</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">S</span>
</code></pre></div><p>Nuevamente, esta función puede resultar difícil de entender. La esencia es que la función toma <code>root</code> como destino y calcula todas las rutas más cortas a <code>root</code> desde cualquier otro nodo fuente del grafo. (<code>paths</code>). Para cada ruta, los diferentes nodos de la ruta se insertan en un conjunto usando el formato <code>((node, root), (next, root))</code>. Yo interpreto <code>((node, root), (next, root))</code> como:</p><blockquote><p><em>Si estoy en &ldquo;node&rdquo; y quiero llegar al nodo &ldquo;root&rdquo;, el siguiente nodo es &ldquo;next&rdquo;.</em></p></blockquote><p>Al final, el conjunto contendrá el camino corto más largo hacia <code>root</code> del grafo. Además, dado que se almacena como <code>(label, value)</code> (donde <code>label = (node, root)</code> y <code>value = (next, root)</code>), podemos encontrar fácilmente el camino más corto para <code>root</code> desde cualquier nodo del grafo. De hecho, esto se conoce como camino más corto de un solo destino. (<em>single-destination shortest path</em>, SDSP).</p><p>Repasemos la función <code>computeSDPX</code> de nuevo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">    </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">round</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk1">key_SKE</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">G</span><span class="mtk1">], </span><span class="mtk9 mtki">G</span><span class="mtk1">)</span>
<span class="mtk1">        </span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">computeSDSP</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">S</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">label</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">], </span><span class="mtk1">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">                </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">label</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">value_bytes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk1">value</span><span class="mtk1">)</span>

<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">label_bytes</span><span class="mtk1"> </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">SPDX</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">key_SKE</span><span class="mtk1">,</span><span class="mtk1">value_bytes</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">ct</span>
<span class="mtk1">                    </span><span class="mtk1">SPDX</span><span class="mtk1">[</span><span class="mtk1">label_bytes</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">SPDX</span>
</code></pre></div><p>Ahora, para cada SDSP del grafo, las variables <code>label</code> y <code>value</code> se traducen a bytes (una traducción simple):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">str</span><span class="mtk1">(</span><span class="mtk9 mtki">x</span><span class="mtk1">).</span><span class="mtk8">encode</span><span class="mtk1">()</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">pair_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">: </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">[</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk8 mtku">int</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk8">int_to_bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">pair</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">])</span>  
</code></pre></div><p>Luego, utiliza la etiqueta (<code>label_bytes</code>) como clave de un diccionario (<code>SPDX</code>). El valor del diccionario correspondiente está cifrado.</p><p>Para cifrar el valor del diccionario, primero se genera un <code>token</code> sobre <code>value_bytes</code> usando <code>key_DES</code> (<code>key[16:]</code> de la primera <code>key</code> generada):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">label</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a label</span>
<span class="mtk4">        Output: A token on label</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk9 mtki">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">K2</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Donde <code>utils.HashMAC</code> implementa HMAC con SHA256:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Input: Key and plaintext</span>
<span class="mtk4">    Output: A token on plaintext with the key usin</span><span class="mtk4">g HMAC</span>  
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">HMAC</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">digestmod</span><span class="mtk5">=</span><span class="mtk8 mtku">SHA256</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">update</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">digest</span><span class="mtk1">()</span>
</code></pre></div><p>Entonces, podemos suponer que <code>token</code> está exclusivamente relacionado con <code>value_bytes</code> (lo que significa que para cada combinación de <code>(next, node)</code>, hay un solo <code>token</code> asociado). Obsérvese que <code>token</code> tiene 32 bytes.</p><p>Continuando con el cifrado, <code>value_bytes</code> se cifra con AES usando <code>key_SKE</code> (<code>key[:16]</code>) como clave. Véanse <code>utils.SymmetricEncrypt</code> / <code>utils.SymmetricDecrypt</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Encrypt the plaintext using AES-CBC mode with </span><span class="mtk4">provided key.</span>
<span class="mtk4">    Input: 16-byte key and plaintext</span>
<span class="mtk4">    Output: Ciphertext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">encrypt</span><span class="mtk1">(</span><span class="mtk8">pad</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk1">iv</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">iv</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">    </span><span class="mtk4">'''</span>
<span class="mtk4">    Decrypt the ciphertex using AES-CBC mode with </span><span class="mtk4">provided key.</span>
<span class="mtk4">    Input: 16-byte key and ciphertext</span>
<span class="mtk4">    Output: Plaintext</span>
<span class="mtk4">    '''</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">) </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk6">16</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">raise</span><span class="mtk1"> </span><span class="mtk8 mtku">ValueError</span>

<span class="mtk1">    </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[:</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk9 mtki">ciphertext</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">    </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">pt</span>
</code></pre></div><p>Obsérvese que el IV del cifrado AES CBC se agrega al texto cifrado al final después de la operación y se toma del texto cifrado para su descifrado.</p><p>Finalmente, el valor <code>token + ct</code> se agrega a <code>SPDX[label_bytes]</code>.</p><p>Ok, pero aún no hemos terminado. Recordemos <code>GESClass.encryptGraph</code>, solo hemos calculado <code>SPDX</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Secret key and a graph G</span>
<span class="mtk4">        Output: Encrypted graph encrypted_db</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">SPDX</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">computeSPDX</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">key_DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]    </span>
<span class="mtk1">        </span><span class="mtk1">EDB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk1">key_DES</span><span class="mtk1">, </span><span class="mtk1">SPDX</span><span class="mtk1">, </span><span class="mtk9 mtki">self</span><span class="mtk1">.</span><span class="mtk1">cores</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">del</span><span class="mtk1">(</span><span class="mtk1">SPDX</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8 mtku">gc</span><span class="mtk1">.</span><span class="mtk8">collect</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">EDB</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>El siguiente paso es coger <code>key_DES</code> (<code>key[16:]</code>) y llamar a <code>DESClass.encryptDict</code> para cifrar el diccionario <code>SPDX</code> completo, que es el valor a devolver:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDict</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">], </span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: A key and a plaintext dictionary</span>
<span class="mtk4">        Output: An encrypted dictionary EDX</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">encrypted_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">        </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">)</span><span class="mtk5">/</span><span class="mtk9 mtki">cores</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk9 mtki">plaintext_dx</span><span class="mtk1">.</span><span class="mtk8">items</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk8">encryptDictHelper</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):   </span>
<span class="mtk1">                </span><span class="mtk1">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">ct_label</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">ct_value</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">encrypted_db</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Nuevamente, es un poco extraño de leer, pero es muy similar a lo anterior. Esta llamando a <code>encryptDictHelper</code> con <code>(key, label_bytes, token + ct)</code> como argumentos para cada par <code>label_bytes</code> - <code>token + ct</code> en el diccionario.</p><p>Y <code>encryptDictHelper</code> realiza las siguientes operaciones:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">encryptDictHelper</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">dict_item</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">HashMAC</span><span class="mtk1">(</span><span class="mtk9 mtki">key</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk5">+</span><span class="mtk1">label</span><span class="mtk1">)[:</span><span class="mtk6">16</span><span class="mtk1">]</span>

<span class="mtk1">    </span><span class="mtk1">ct_label</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricEncrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">value</span><span class="mtk1">)</span>  
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">ct_label</span><span class="mtk1">, </span><span class="mtk1">ct_value</span>
</code></pre></div><p>Nótese que <code>K1</code> es <code>token[:16]</code> y <code>K2</code> es <code>token[16:]</code>. Por lo tanto, simplemente genera el <em>hash</em> SHA256 de <code>K1</code> y cifra <code>token + ct</code> con AES usando <code>K2</code> como clave. Esos serán los pares clave-valor del diccionario cifrado <code>EDB</code>.</p><h3 id="comprendiendo-las-consultas">Comprendiendo las consultas</h3><p>Todavía hay dos métodos de los que aún no hemos hablado: <code>GESClass.search</code> y <code>DESClass.search</code>. El primero llama al segundo por detrás y se usa para encontrar el camino más corto entre dos nodos del grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">GESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">Tuple</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">):</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token</span>
<span class="mtk4">        Output: (tokens, cts)</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">""</span>
<span class="mtk1">        </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">token</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">DES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">curr</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">curr</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">value</span><span class="mtk1">[</span><span class="mtk6">32</span><span class="mtk1">:]</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">+=</span><span class="mtk1"> </span><span class="mtk1">curr</span>
<span class="mtk1">        </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">tuple</span><span class="mtk1">([</span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">])</span>

    <span class="mtk3"># ...</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">class</span><span class="mtk1"> </span><span class="mtk8 mtku">DESClass</span><span class="mtk1">:</span>
    <span class="mtk3"># ...</span>

<span class="mtk1">    </span><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk9 mtki">self</span><span class="mtk1">, </span><span class="mtk9 mtki">search_token</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">: </span><span class="mtk8 mtku">dict</span><span class="mtk1">[</span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk8 mtku">bytes</span><span class="mtk1">]) -&gt; </span><span class="mtk8 mtku">bytes</span><span class="mtk1">:</span>  
<span class="mtk1">        </span><span class="mtk4">'''</span>
<span class="mtk4">        Input: Search token and EDX</span>
<span class="mtk4">        Output: The corresponding encrypted value.</span>
<span class="mtk4">        '''</span>
<span class="mtk1">        </span><span class="mtk1">K1</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">]</span>
<span class="mtk1">        </span><span class="mtk1">K2</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">search_token</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>
<span class="mtk1">        </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">Hash</span><span class="mtk1">(</span><span class="mtk1">K1</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">hash_val</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">ct_value</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk1">[</span><span class="mtk1">hash_val</span><span class="mtk1">]</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">SymmetricDecrypt</span><span class="mtk1">(</span><span class="mtk1">K2</span><span class="mtk1">, </span><span class="mtk1">ct_value</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">''</span>

    <span class="mtk3"># ...</span>
</code></pre></div><p>Básicamente, para buscar el camino más corto desde <code>A</code> hasta <code>B</code>, se genera un <code>token</code> (que identifica la etiqueta <code>(A, B)</code>) y se busca en <code>EDB</code> (también llamado <code>encrypted_db</code>). Recordemos que <code>token = K1 + K2</code>, por lo que <code>K1</code> es la clave del diccionario y <code>K2</code> es la clave AES para descifrar el valor del diccionario. Sólo se devuelve el valor de <code>DESClass.search</code>.</p><p>Imaginemos que el siguiente nodo desde <code>A</code> en el cambino más corto es <code>C</code>, entonces la salida de <code>DESClass.search</code> en este ejemplo será <code>token + ct</code>. Este <code>token</code> se correspondería con <code>(C, B)</code> y <code>ct</code> estaría cifrado con AES y <code>key_SKE</code>, que se portaría precisamente la etiqueta <code>(C, B)</code>.</p><p>Para cada resultado de <code>DESClass.search</code>, el resultado se divide en <code>token</code> y <code>ct</code> y ambas se agregan a <code>tok</code> y <code>resp</code>, respectivamente. Finalmente, la tupla <code>(tok, resp)</code> se devuelve desde <code>GESClass.search</code>.</p><h3 id="resumen">Resumen</h3><ul><li><code>GESClass.keyGen</code>: Genera <code>key</code> como <code>key_SKE</code> y <code>key_DES</code>. Luego, <code>key[:16]</code> se emplea para el cifrado AES y <code>key[16:]</code> para HMAC</li><li><em>Single-destination shortest path</em> (SDSP): Representa todos los caminos más cortos desde todos los nodos hasta un único destino. Cada entrada se representa como <code>((node, root), (next, root))</code>, para que puedan encadenarse para construir un camino más corto desde un <code>node</code> hasta <code>root</code></li><li><code>SPDX</code>: Es un diccionario que mapea <code>(node, root)</code> con <code>token + ct</code> (relacionado con <code>(next, root)</code>)</li><li><code>DESClass.tokenGen</code> (y <code>GESClass.tokenGen</code>): Define un <em>token</em> único para una etiqueta <code>(node, root)</code>. Es un valor de 32 bytes compuesto por valores de 16 bytes <code>K1</code> y <code>K2</code></li><li><code>EDB</code> (<code>encrypted_db</code>): Es un diccionario que asigna el <em>hash</em> SHA256 de <code>K1</code> y el valor cifrado con AES de <code>token + ct</code> usando <code>K2</code> como clave</li><li><code>GESClass.search</code>: Busca la ruta más corta desde un origen a un destino en el SDSP y devuelve la concatenación de todos los <code>token</code> (asociados a <code>(node, root)</code>) de la ruta y todos los textos cifrados (en realidad, <code>token + ct</code>)</li></ul><h2 id="cryptography-1">cryptoGRAPHy 1</h2><p>Se nos proporciona el código fuente del servidor, que utiliza algunas funciones de la <a href="#graph-encryption-scheme">librería de <em>Graph Encryption Scheme</em></a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">260</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">16</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">node_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">) -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk9 mtki">node_count</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">) </span><span class="mtk5">&lt;</span><span class="mtk1"> </span><span class="mtk9 mtki">edge_count</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk1">nodes</span><span class="mtk1">, </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> (</span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">([</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">])</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">(</span><span class="mtk1">edges</span><span class="mtk1">)</span>


<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Answer 50 queries to get the flag. In each qu</span><span class="mtk4">ery, input the shortest path </span><span class="mtk6">\</span>  
<span class="mtk4">              decrypted from response. It will be </span><span class="mtk4">a string of space-separated nodes from </span><span class="mtk6">\</span>
<span class="mtk4">              source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><p>Obsérvese que hay una función llamada <code>decrypt</code> que está oculta para nosotros.</p><h3 id="análisis-del-código-fuente">Análisis del código fuente</h3><p>Primero, el servidor genera un grafo aleatorio, genera una clave (¡que se muestra!) y cifra el grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">(</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk1">EDGE_COUNT</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>  
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Key: </span><span class="mtk6">{</span><span class="mtk1">key</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>
</code></pre></div><p>Después de eso, se nos pide que respondamos correctamente a 50 consultas para obtener la <em>flag</em>. Para cada consulta, el servidor tomará dos nodos aleatorios (<code>u</code> y <code>v</code>) del grafo que estén conectados y encontrará el camino más corto entre ellos. Se nos dará el <code>token</code> para <code>(u, v)</code> y la parte <code>resp</code> de <code>GESClass.search</code> (los textos cifrados):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Query </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/50: </span><span class="mtk6">{</span><span class="mtk1">u</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">v</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk1">_</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Response: </span><span class="mtk6">{</span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solución">Solución</h3><p>Recordemos del análisis la <a href="#graph-encryption-scheme">librería de <em>Graph Encryption Scheme</em></a> que <code>resp</code> está cifrado con AES y la clave <code>key_SKE</code>, que es <code>key[:16]</code> (la sabemos desde el principio). Entonces, podemos encontrar todos los nodos intermedios desde <code>u</code> hasta <code>v</code> (incluido <code>v</code> pero no <code>u</code>) descifrando cada fragmento de 32 bytes (16 para texto cifrado y 16 para IV). El valor de <code>u</code> lo imprime el servidor, por lo que no es un problema aquí.</p><p>Podemos implementar esto fácilmente con Python. Este es el código relevante:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Key: '</span><span class="mtk1">)</span>
<span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk1">DES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1">[:</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">key</span><span class="mtk1">[</span><span class="mtk6">16</span><span class="mtk1">:]</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">50</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 50'</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'/50: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">ct_iv</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [(</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">], </span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">16</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">]) </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">ct</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">ct_iv</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">cipher</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk8">new</span><span class="mtk1">(</span><span class="mtk1">SKE</span><span class="mtk1">, </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">MODE_CBC</span><span class="mtk1">, </span><span class="mtk1">iv</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">pt</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">unpad</span><span class="mtk1">(</span><span class="mtk1">cipher</span><span class="mtk1">.</span><span class="mtk8">decrypt</span><span class="mtk1">(</span><span class="mtk1">ct</span><span class="mtk1">), </span><span class="mtk8 mtku">AES</span><span class="mtk1">.</span><span class="mtk1">block_size</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">pt</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">','</span><span class="mtk1">)[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk1">start</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk7 mtki">b</span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk1">shortest_path</span><span class="mtk1">))</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'50 / 50'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="_flag_"><em>Flag</em></h3><p>Una vez que ejecutemos el <em>script</em>, encontraremos la <em>flag</em>:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3001
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3001: Done  
[<span class="code-green">+</span>] Round: 50 / 50
[+] Flag: SEKAI{GES_15_34sy_2_br34k_kn@w1ng_th3_k3y}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3001
</code></pre></div><p>El <em>script</em> completo se puede encontrar aquí: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%201/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-2">cryptoGRAPHy 2</h2><p>Para esta segunda parte, se nos proporciona el código fuente del servidor, que nuevamente utiliza algunas funciones de la <a href="#graph-encryption-scheme">librería de <em>Graph Encryption Scheme</em></a>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">, </span><span class="mtk8 mtku">utils</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">130</span>
<span class="mtk1">EDGE_PROB</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">0.031</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">32</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">() -&gt; </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">fast_gnp_random_graph</span><span class="mtk1">(</span><span class="mtk9 mtki">n</span><span class="mtk5">=</span><span class="mtk1">NODE_COUNT</span><span class="mtk1">, </span><span class="mtk9 mtki">p</span><span class="mtk5">=</span><span class="mtk1">EDGE_PROB</span><span class="mtk1">)</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</h3><p>Ahora, el servidor oculta una función llamada <code>get_SDSP_node_degrees</code>, pero al menos nos explica lo que hace:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, get_SDSP_node_degrees</span>

<span class="mtk4">'''</span>
<span class="mtk4">get_SDSP_node_degrees(G, dest) returns the node de</span><span class="mtk4">grees in the single-destination shortest path (SDS</span><span class="mtk4">P) tree, sorted in ascending order.</span>  
<span class="mtk4">For example, if G has 5 nodes with edges (1,2),(1,</span><span class="mtk4">3),(2,3),(2,5),(4,5) and dest=1, returns "1 1 2 2 </span><span class="mtk4">2".</span>
<span class="mtk4">[+] Original:       [+] SDSP:</span>
<span class="mtk4">1--2--5--4          1--2--5--4</span>
<span class="mtk4">| /                 |</span>
<span class="mtk4">3                   3</span>
<span class="mtk4">'''</span>
<span class="mtk3"># Another example for sanity check</span>
<span class="mtk1">TestGraph</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">utils</span><span class="mtk1">.</span><span class="mtk8">generate_graph</span><span class="mtk1">([[</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">2</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">4</span><span class="mtk1">], [</span><span class="mtk6">1</span><span class="mtk1">, </span><span class="mtk6">6</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">], [</span><span class="mtk6">6</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk6">7</span><span class="mtk1">], [</span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">5</span><span class="mtk1">]])</span>
<span class="mtk5">assert</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">TestGraph</span><span class="mtk1">, </span><span class="mtk6">1</span><span class="mtk1">) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'1 1 1 2 2 3'</span>
</code></pre></div><p>Este reto me hizo comprender exactamente el concepto de SDSP. El ejemplo dibujado puede ser un poco breve para generalizar, así que dibujemos el segundo ejemplo. Este es el grafo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><p>Ahora, el destino es <code>1</code>, así que busquemos las rutas más cortas desde cada nodo:</p><ul><li><code>2</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----</span><span class="mtk7">2</span>  
|    |    |
7----6----5
</code></pre></div><ul><li><code>4</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7">4</span><span class="mtk8">----</span><span class="mtk5">1</span>----2  
|    |    |
7----6----5
</code></pre></div><ul><li><code>5</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span><span class="mtk8">----2</span>  
|    |    <span class="mtk8">|</span>
7----6----</span><span class="mtk7">5</span>
</code></pre></div><ul><li><code>6</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----<span class="mtk5">1</span>----2  
|    <span class="mtk8">|</span>    |
7----<span class="mtk7">6</span>----5
</code></pre></div><ul><li><code>7</code> -> <code>1</code>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk8">4----</span><span class="mtk5">1</span>----2  
<span class="mtk8">|</span>    |    |
<span class="mtk7">7</span>----6----5
</code></pre></div><p>Entonces, el SDSP es el grafo inicial pero eliminando los bordes no utilizados, y en realidad es un árbol:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">4----1----2  
|    |    |
7    6    5
</code></pre></div><p>Y la salida de <code>get_SDSP_node_degrees</code> es una lista de los grados de cada nodo del SDSP (el grado de un nodo es el número de nodos adyacentes de dicho nodo), ordenados en orden ascendente. Por lo tanto, el resultado para este ejemplo es <code>1 1 1 2 2 3</code>. Podemos reemplazar los identificadores de los nodos por su grado correspondiente, para ilustrar el concepto de grado de un nodo:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight">2----3----2  
|    |    |
1    1    1
</code></pre></div><h3 id="análisis-del-código-fuente-1">Análisis del código fuente</h3><p>Esta vez, el servidor no imprime la <code>key</code>&mldr; Necesitaremos obtener la salida de <code>get_SDSP_node_degrees</code> un total de 10 veces.</p><p>La inicialización es la misma que antes (se genera un grafo aleatorio, se generaa la clave y se cifra el grafo). Después de eso, el servidor toma un punto de destino aleatorio, que se imprime en texto claro:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Pass 10 challenges to get the flag:"</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10. Generating random graph..."</span><span class="mtk1">)</span>  
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">gen_random_graph</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">is_connected</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">            </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[+] Encrypting graph..."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choice</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">()))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Destination: </span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><p>El servidor nos permite realizar hasta 130 consultas (<code>NODE_COUNT</code>, el número de nodos en el grafo), y se nos dará el <code>token</code> para nuestra entrada <code>(u, v)</code>, así como <code>tok</code> y <code>resp</code> de <code>GESClass.search</code> (concatenados):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">attempts</span><span class="mtk1"> </span><span class="mtk5">-=</span><span class="mtk1"> </span><span class="mtk6">1</span>
<span class="mtk1">                </span><span class="mtk1">query</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Query u,v: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">                </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk1">query</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">','</span><span class="mtk1">))</span>
<span class="mtk1">                    </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">() </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span>  
<span class="mtk1">                </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Invalid query!"</span><span class="mtk1">)</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">                </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Answer: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> get_SDSP_node_degrees(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">dest</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solución-1">Solución</h3><p>Entonces, intentaremos encontrar el SDSP para un nodo de destino determinado. Por lo tanto, todas las consultas a realizar deben ser <code>(node, root)</code>, donde <code>root</code> es el punto de destino dado.</p><p>Además, obsérvese que hay una comprobación de que <code>u != v</code>. Podemos usar esto para romper el bucle <code>while</code> enviando <code>(root, root)</code> al final, cuando ya tengamos los otros 129 resultados de la consulta, y luego intentar adivinar el resultado de <code>getSDSP_node_degrees</code>.</p><p>Para cada ronda, haremos lo siguiente:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">data</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">NODES_SIZE</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Destination: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">dest</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">int</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk1">NODES_SIZE</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">dest</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">continue</span>

<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">i</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">        </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">        </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span>] <span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>  

<span class="mtk1">        </span><span class="mtk1">data</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">b</span><span class="mtk1">: </span><span class="mtk9 mtki">b</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">(), </span><span class="mtk1">keys</span><span class="mtk1">))</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">dest</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">()</span>
</code></pre></div><p>Estamos tomando el <code>token</code>, que está relacionado con <code>(node, root)</code>, y luego tomamos la parte <code>token</code> de la respuesta del servidor (la primera mitad son todos los <em>tokens</em> de 32 bytes para cada etiqueta <code>(next, root)</code> en la ruta más corta). Los guardaremos en un diccionario <code>data</code> para cada nodo.</p><p>Además, usaremos el <code>token</code> para identificar cada nodo (guardado en la lista <code>nodes</code>), y uno de los ultimos valores de <code>token</code> de <code>res</code> como identificador del destino (<code>(root, root)</code>).</p><p>Una vez que tengamos esta información, podemos generar el grafo SDSP guardando todas las aristar posibles en un conjunto (siguiendo los caminos más cortos):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">d</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">data</span><span class="mtk1">.</span><span class="mtk8">values</span><span class="mtk1">():</span>
<span class="mtk1">        </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">])</span>

<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1">, </span><span class="mtk1">next_node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">enumerate</span><span class="mtk1">(</span><span class="mtk1">d</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">:] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">nodes</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]]):</span>
<span class="mtk1">            </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> (</span><span class="mtk1">prev_node</span><span class="mtk1">, </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">))</span>

<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> (</span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]) </span><span class="mtk5">not</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">] </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">edge</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> (</span><span class="mtk1">dest</span><span class="mtk1">, </span><span class="mtk6">0</span><span class="mtk1">):</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">(</span><span class="mtk1">edge</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">prev_node</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">.</span><span class="mtk8">index</span><span class="mtk1">(</span><span class="mtk1">next_node</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
</code></pre></div><p>Y el último paso es tomar los grados de los nodos y ordenarlos:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">    </span><span class="mtk1">degrees</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">sorted</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk7 mtki">lambda</span><span class="mtk1"> </span><span class="mtk9 mtki">t</span><span class="mtk1">: </span><span class="mtk9 mtki">t</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">], </span><span class="mtk1">G</span><span class="mtk1">.degree))</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Query u,v: '</span><span class="mtk1">, </span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">,</span><span class="mtk6">{</span><span class="mtk1">dest</span><span class="mtk6">}</span><span class="mtk4">'</span><span class="mtk1">.</span><span class="mtk8">encode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Answer: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">degrees</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  
</code></pre></div><h3 id="_flag_-1"><em>Flag</em></h3><p>Podemos ejecutar el <em>script</em> para calcular lo anterior 10 veces y obtener la <em>flag</em>:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3062
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3062: Done  
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{3ff1c13nt_GES_4_Shortest-Path-Queries-_-}
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3062
</code></pre></div><p>El <em>script</em> completo se puede encontrar aquí: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%202/solve.py"><code>solve.py</code></a>.</p><h2 id="cryptography-3">cryptoGRAPHy 3</h2><p>Para el último reto de la serie, se nos proporciona nuevamente el código fuente del servidor:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">itertools</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">, </span><span class="mtk8 mtku">chain</span>
<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk8 mtku">multiprocessing</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk1">Pool</span>
<span class="mtk5">from</span><span class="mtk1"> lib </span><span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">networkx</span><span class="mtk1"> </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span>
<span class="mtk5">import</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span>

<span class="mtk5">from</span><span class="mtk1"> </span><span class="mtk6">SECRET</span><span class="mtk1"> </span><span class="mtk5">import</span><span class="mtk1"> flag, generate_tree, decrypt</span>

<span class="mtk1">NODE_COUNT</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">60</span>
<span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk6">128</span>
<span class="mtk1">MENU</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk4">'''============ MENU ============</span>
<span class="mtk4">1. Graph Information</span>
<span class="mtk4">2. Query Responses</span>
<span class="mtk4">3. Challenge</span>
<span class="mtk4">4. Exit</span>
<span class="mtk4">=============================='''</span>

<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>

<span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">__name__</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">'__main__'</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk5">try</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_tree()</span>
<span class="mtk1">        </span><span class="mtk5">assert</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">NODE_COUNT</span>
<span class="mtk1">        </span><span class="mtk1">myGES</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk5">=</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk9 mtki">encrypted_db</span><span class="mtk5">=</span><span class="mtk1">{})</span>
<span class="mtk1">        </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">keyGen</span><span class="mtk1">(</span><span class="mtk1">SECURITY_PARAMETER</span><span class="mtk1">)</span>
<span class="mtk1">        </span><span class="mtk1">enc_db</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">encryptGraph</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Recover 10 queries in 30 seconds. It is guara</span><span class="mtk4">nteed that each answer is unique."</span><span class="mtk1">)</span>

<span class="mtk1">        </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">MENU</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Option: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"2"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Responses: "</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk6">4</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">myGES</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">:</span>
<span class="mtk1">                    </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">0</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4"> </span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1">[</span><span class="mtk6">1</span><span class="mtk1">]</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">elif</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"3"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk5">else</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>

<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">except</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk8">exit</span><span class="mtk1">()</span>
</code></pre></div><h3 id="análisis-del-código-fuente-2">Análisis del código fuente</h3><p>Nuevamente, el servidor no imprime la <code>key</code>&mldr; Pero en su lugar, se nos da el grafo inicial en texto claro (opción <code>1</code>):</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">option</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk4">"1"</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Graph information:"</span><span class="mtk1">)</span>  
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[*] Edges:"</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">.edges())</span>
</code></pre></div><p>Particularmente, el grafo es un árbol que se genera con una función oculta llamada <code>generate_tree</code>. Al principio, esto fue un poco extraño para mí, ya que <a href="https://networkx.org/"><code>networkx</code></a> tiene una función llamada <a href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.trees.random_tree.html#random-tree"><code>random_tree</code></a>, por lo que no hay razón para ocultarla. Al realizar algunas pruebas en local, descubrí que si dos nodos están al mismo nivel, el reto no se podía resolver porque esos nodos no se pueden distinguir cuando están cifrados. Luego, mirando el árbol generado por el servidor, no había ningún par de nodos al mismo nivel, por lo que el reto sí tenía solución y la función <code>generate_tree</code> (oculta) se encargaría de evitar esa situación.</p><p>En la opción <code>2</code>, se nos darán las respuestas (<code>(tok, resp)</code>) a todas las consultas posibles en el grafo, que tiene un total de 60 nodos. Por lo tanto, recibiremos un total de $60^2 = 3600$ respuestas. El problema es que la lista de respuestas está desordenada:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">query_resps</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">: </span><span class="mtk8 mtku">int</span><span class="mtk1">, </span><span class="mtk9 mtki">key</span><span class="mtk1">: </span><span class="mtk8 mtku">bytes</span><span class="mtk1">, </span><span class="mtk9 mtki">G</span><span class="mtk1">: </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8 mtku">Graph</span><span class="mtk1">, </span><span class="mtk9 mtki">myGES</span><span class="mtk1">: </span><span class="mtk8 mtku">GES</span><span class="mtk1">.</span><span class="mtk8 mtku">GESClass</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">):</span>  
<span class="mtk1">    </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">.</span><span class="mtk1">nodes</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">query_list</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>
<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk8 mtku">set</span><span class="mtk1">(), </span><span class="mtk8 mtku">set</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">component</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">connected_components</span><span class="mtk1">(</span><span class="mtk9 mtki">G</span><span class="mtk1">):</span>
<span class="mtk1">        </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">chain</span><span class="mtk1">(</span><span class="mtk1">queries</span><span class="mtk1">, </span><span class="mtk8 mtku">product</span><span class="mtk1">(</span><span class="mtk1">component</span><span class="mtk1">, </span><span class="mtk1">component</span><span class="mtk1">))</span>
<span class="mtk1">    </span><span class="mtk1">iterable</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">product</span><span class="mtk1">([</span><span class="mtk9 mtki">key</span><span class="mtk1">], </span><span class="mtk1">queries</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">chunk</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">*</span><span class="mtk1"> </span><span class="mtk1">n</span><span class="mtk1"> </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk9 mtki">cores</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk5">with</span><span class="mtk1"> </span><span class="mtk1">Pool</span><span class="mtk1">(</span><span class="mtk9 mtki">cores</span><span class="mtk1">) </span><span class="mtk5">as</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">pool</span><span class="mtk1">.istarmap(</span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">, </span><span class="mtk1">iterable</span><span class="mtk1">, </span><span class="mtk9 mtki">chunksize</span><span class="mtk5">=</span><span class="mtk1">chunk</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk9 mtki">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk9 mtki">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">query_list</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">((</span><span class="mtk1">token</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1">.hex(), </span><span class="mtk1">resp</span><span class="mtk1">.hex()))</span>
<span class="mtk1">    </span>
<span class="mtk1">    </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">shuffle</span><span class="mtk1">(</span><span class="mtk1">query_list</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk5">return</span><span class="mtk1"> </span><span class="mtk1">query_list</span>
</code></pre></div><p>Una vez recibida toda la información, podemos usar la opción <code>3</code> para comenzar el reto real: durante 10 rondas, el servidor tomará dos nodos aleatorios <code>u</code> y <code>v</code> del grafo que estén conectados y nos solicitará que pongamos la consulta original (es decir, el camino más corto entre ellos). Se nos dará el <code>token</code> para <code>(u, v)</code> y el resultado de <code>GESClass.search</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] In each query, input the shortest path decryp</span><span class="mtk4">ted from response. </span><span class="mtk6">\</span>
<span class="mtk4">              It will be a string of space-separat</span><span class="mtk4">ed nodes from source to destination, e.g. '1 2 3 4</span><span class="mtk4">'."</span><span class="mtk1">)</span>  
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Challenge </span><span class="mtk6">{</span><span class="mtk1">q</span><span class="mtk5">+</span><span class="mtk6">1}</span><span class="mtk4">/10."</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">random</span><span class="mtk1">.</span><span class="mtk1">choices</span><span class="mtk1">(</span><span class="mtk8 mtku">list</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">.nodes()), </span><span class="mtk9 mtki">k</span><span class="mtk5">=</span><span class="mtk6">2</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">u</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> </span><span class="mtk1">v</span><span class="mtk1"> </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk8 mtku">nx</span><span class="mtk1">.</span><span class="mtk8">has_path</span><span class="mtk1">(</span><span class="mtk1">G</span><span class="mtk1">, </span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">):</span>
<span class="mtk1">                    </span><span class="mtk5">break</span>
<span class="mtk1">            </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">tokenGen</span><span class="mtk1">(</span><span class="mtk1">key</span><span class="mtk1">, (</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">))</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Token: </span><span class="mtk6">{</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">myGES</span><span class="mtk1">.</span><span class="mtk8">search</span><span class="mtk1">(</span><span class="mtk1">token</span><span class="mtk1">, </span><span class="mtk1">enc_db</span><span class="mtk1">)</span>
<span class="mtk1">            </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[*] Query Response: </span><span class="mtk6">{</span><span class="mtk1">tok</span><span class="mtk1">.hex() </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk1">resp</span><span class="mtk1">.hex()</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>

<span class="mtk1">            </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">input</span><span class="mtk1">(</span><span class="mtk4">"&gt; Original query: "</span><span class="mtk1">).</span><span class="mtk8">strip</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">ans</span><span class="mtk1"> </span><span class="mtk5">!=</span><span class="mtk1"> decrypt(</span><span class="mtk1">u</span><span class="mtk1">, </span><span class="mtk1">v</span><span class="mtk1">, </span><span class="mtk1">resp</span><span class="mtk1">, </span><span class="mtk1">key</span><span class="mtk1">):</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Wrong answer!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8 mtku">time</span><span class="mtk1">.</span><span class="mtk8">time</span><span class="mtk1">() </span><span class="mtk5">-</span><span class="mtk1"> </span><span class="mtk1">t</span><span class="mtk1"> </span><span class="mtk5">&gt;</span><span class="mtk1"> </span><span class="mtk6">30</span><span class="mtk1">:</span>
<span class="mtk1">                </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk4">"[!] Time's up!"</span><span class="mtk1">)</span>
<span class="mtk1">                </span><span class="mtk8">exit</span><span class="mtk1">()</span>
<span class="mtk1">        </span><span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">"[+] Flag: </span><span class="mtk6">{</span><span class="mtk1">flag</span><span class="mtk6">}</span><span class="mtk4">"</span><span class="mtk1">)</span>
</code></pre></div><h3 id="solución-2">Solución</h3><p>En primer lugar, podemos tomar toda la información de las opciones <code>1</code> y <code>2</code>:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">get_process</span><span class="mtk1">()</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'1'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Edges: '</span><span class="mtk1">)</span>
<span class="mtk1">G</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk8">eval</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()))</span>

<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'2'</span><span class="mtk1">)</span>
<span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">()</span>

<span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk5">while</span><span class="mtk1"> </span><span class="mtk6">True</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk1">line</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">()[:</span><span class="mtk5">-</span><span class="mtk6">1</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk4">'MENU'</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">line</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">break</span>

<span class="mtk1">    </span><span class="mtk1">tok</span><span class="mtk1">, </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">, </span><span class="mtk1">line</span><span class="mtk1">.</span><span class="mtk8">split</span><span class="mtk1">(</span><span class="mtk4">' '</span><span class="mtk1">))</span>

<span class="mtk1">    </span><span class="mtk1">queries</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">({</span>
<span class="mtk1">        </span><span class="mtk4">'token'</span><span class="mtk1">: </span><span class="mtk1">tok</span><span class="mtk1">[:</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">(),</span>
<span class="mtk1">        </span><span class="mtk4">'tok'</span><span class="mtk1">: [</span><span class="mtk1">tok</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">32</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">tok</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)],</span>  
<span class="mtk1">        </span><span class="mtk4">'res'</span><span class="mtk1">: [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">), </span><span class="mtk6">32</span><span class="mtk1">)]</span>
<span class="mtk1">    })</span>
</code></pre></div><p>Observe cómo utilicé una lista <code>queries</code> (que contendrá un total de 3600 elementos) con un <code>token</code> y dos listas para <code>tok</code> y <code>res</code>.</p><p>Echando un vistazo a la lista <code>queries</code>, podemos descubrir que hay exactamente 60 elementos con <code>tok</code> y <code>res</code> vacíos dado que son consultas de la forma <code>(root, root)</code>. Podemos usar estos elementos para identificar nodos del grafo, así que vamos a separarlos en otra lista:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">toks_0</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk6">0</span><span class="mtk1">]</span>  
</code></pre></div><p>En realidad, cada <em>token</em> en <code>tok_0</code> aparecerá en otros elementos de las listas <code>queries.tok</code> en la última posición, ya que <code>(root, root)</code> es un destino. Así, podemos encontrar todos los <code>token</code> de la forma <code>(node, root)</code> que contienen un <code>token</code> dado de <code>tok_0</code> en su lista <code>tok</code>.</p><p>Y lo que es más interesante, podemos unir todos los <code>token</code> en un grafo. En realidad, este grafo será un árbol. Esto es muy importante, porque los árboles no contienen ningún ciclo, por lo que el camino entre dos nodos es en realidad el camino más corto entre ellos. Y lo que es aún más alucinante, podemos encontrar un mapeo entre el árbol <code>token</code> y el árbol de texto claro que tenemos desde el principio.</p><p>En términos matemáticos, esto se llama isomorfismo entre árboles, que define una relación uno a uno entre los nodos de dos árboles. Afortunadamente, <a href="https://networkx.org/"><code>networkx</code></a> proporciona una función para encontrar un isomorfismo entre árboles. (<a href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism.html#networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism"><code>tree_isomorphism</code></a>), para que podamos hacer coincidir cada <code>token</code> con un nodo de texto claro:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">mappings</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> {}</span>


<span class="mtk7 mtki">def</span><span class="mtk1"> </span><span class="mtk8">define_tree</span><span class="mtk1">(</span><span class="mtk9 mtki">queries</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">nodes</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">] </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">]</span>
<span class="mtk1">    </span><span class="mtk1">edges</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">set</span><span class="mtk1">()</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">nodes</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk9 mtki">queries</span><span class="mtk1">:</span>
<span class="mtk1">            </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">]) </span><span class="mtk5">and</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">][</span><span class="mtk6">0</span><span class="mtk1">] </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">node</span><span class="mtk1">:</span>  
<span class="mtk1">                </span><span class="mtk1">edges</span><span class="mtk1">.</span><span class="mtk8">add</span><span class="mtk1">((</span><span class="mtk1">node</span><span class="mtk1">, </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]))</span>

<span class="mtk1">    </span><span class="mtk1">GG</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> generate_graph(</span><span class="mtk1">edges</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">isomorphism</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8">tree_isomorphism</span><span class="mtk1">(</span><span class="mtk1">GG</span><span class="mtk1">, </span><span class="mtk1">G</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">enc</span><span class="mtk1">, </span><span class="mtk1">node</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">isomorphism</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">enc</span><span class="mtk1">] </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">node</span>
</code></pre></div><p>Y este proceso hay que hacerlo 60 veces, ya que hay un total de 60 destinos diferentes:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">toks_0</span><span class="mtk1">:</span>
<span class="mtk1">    </span><span class="mtk8">define_tree</span><span class="mtk1">([</span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">queries</span><span class="mtk1"> </span><span class="mtk5">if</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'tok'</span><span class="mtk1">] </span><span class="mtk5">or</span><span class="mtk1"> </span><span class="mtk1">tok</span><span class="mtk1"> </span><span class="mtk5">==</span><span class="mtk1"> </span><span class="mtk1">q</span><span class="mtk1">[</span><span class="mtk4">'token'</span><span class="mtk1">]])</span>  
</code></pre></div><p>Una vez que tengamos el mapeo entre el<code>token</code> cifrado y el nodo de texto claro, podemos encontrar fácilmente la ruta más corta de la consulta que se nos proporciona buscando en el diccionario <code>mapping</code>. Y eso es precisamente lo que estamos haciendo aquí:</p><div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1d1e19;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Option: '</span><span class="mtk1">, </span><span class="mtk7 mtki">b</span><span class="mtk4">'3'</span><span class="mtk1">)</span>

<span class="mtk1">round_prog</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">progress</span><span class="mtk1">(</span><span class="mtk4">'Round'</span><span class="mtk1">)</span>

<span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">10</span><span class="mtk1">):</span>
<span class="mtk1">    </span><span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">status</span><span class="mtk1">(</span><span class="mtk7 mtki">f</span><span class="mtk4">'</span><span class="mtk6">{</span><span class="mtk1">r</span><span class="mtk1"> </span><span class="mtk5">+</span><span class="mtk1"> </span><span class="mtk6">1}</span><span class="mtk4"> / 10'</span><span class="mtk1">)</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Token: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">token</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>
<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvuntil</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'[*] Query Response: '</span><span class="mtk1">)</span>
<span class="mtk1">    </span><span class="mtk1">res</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> </span><span class="mtk8 mtku">bytes</span><span class="mtk1">.</span><span class="mtk8">fromhex</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recvline</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">())</span>

<span class="mtk1">    </span><span class="mtk1">keys</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> [</span><span class="mtk1">token</span><span class="mtk1">.</span><span class="mtk8">hex</span><span class="mtk1">()] </span><span class="mtk5">+</span><span class="mtk1"> [</span><span class="mtk1">res</span><span class="mtk1">[</span><span class="mtk1">i</span><span class="mtk1">:</span><span class="mtk1">i</span><span class="mtk5">+</span><span class="mtk6">32</span><span class="mtk1">].</span><span class="mtk8">hex</span><span class="mtk1">() </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">i</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk8 mtku">range</span><span class="mtk1">(</span><span class="mtk6">0</span><span class="mtk1">, </span><span class="mtk8">len</span><span class="mtk1">(</span><span class="mtk1">res</span><span class="mtk1">) </span><span class="mtk5">//</span><span class="mtk1"> </span><span class="mtk6">2</span><span class="mtk1">, </span><span class="mtk6">32</span><span class="mtk1">)]</span>

<span class="mtk1">    </span><span class="mtk1">shortest_path</span><span class="mtk1"> </span><span class="mtk5">=</span><span class="mtk1"> []</span>

<span class="mtk1">    </span><span class="mtk5">for</span><span class="mtk1"> </span><span class="mtk1">key</span><span class="mtk1"> </span><span class="mtk5">in</span><span class="mtk1"> </span><span class="mtk1">keys</span><span class="mtk1">:</span>
<span class="mtk1">        </span><span class="mtk1">shortest_path</span><span class="mtk1">.</span><span class="mtk8">append</span><span class="mtk1">(</span><span class="mtk1">mappings</span><span class="mtk1">[</span><span class="mtk1">key</span><span class="mtk1">])</span>

<span class="mtk1">    </span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">sendlineafter</span><span class="mtk1">(</span><span class="mtk7 mtki">b</span><span class="mtk4">'&gt; Original query: '</span><span class="mtk1">, </span><span class="mtk4">' '</span><span class="mtk1">.</span><span class="mtk8">join</span><span class="mtk1">(</span><span class="mtk8 mtku">map</span><span class="mtk1">(</span><span class="mtk8 mtku">str</span><span class="mtk1">, </span><span class="mtk1">shortest_path</span><span class="mtk1">)).</span><span class="mtk8">encode</span><span class="mtk1">())</span>  

<span class="mtk1">round_prog</span><span class="mtk1">.</span><span class="mtk8">success</span><span class="mtk1">(</span><span class="mtk4">'10 / 10'</span><span class="mtk1">)</span>
<span class="mtk8">print</span><span class="mtk1">(</span><span class="mtk1">io</span><span class="mtk1">.</span><span class="mtk8">recv</span><span class="mtk1">().</span><span class="mtk8">decode</span><span class="mtk1">().</span><span class="mtk8">strip</span><span class="mtk1">())</span>
</code></pre></div><h3 id="_flag_-2"><em>Flag</em></h3><p>Una vez que ejecutemos el <em>script</em> veremos la <em>flag</em> (que nos da un <em>paper</em> que describe este ataque de recuperación de consulta con mucho más detalle):</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000!important;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="no-highlight"><span class="code-cyan">$</span> <span class="code-dark-green">python3</span> <span class="mtku">solve.py</span> chals.sekai.team 3023
[<span class="code-green">+</span>] Opening connection to chals.sekai.team on port 3023: Done
[<span class="code-green">+</span>] Round: 10 / 10
[+] Flag: SEKAI{Full_QR_Attack_is_not_easy_https://eprint.iacr.org/2022/838.pdf}  
[<span class="code-blue">*</span>] Closed connection to chals.sekai.team port 3023
</code></pre></div><p>El <em>script</em> completo se puede encontrar aquí: <a href="https://github.com/7Rocky/CTF-scripts/tree/main/Sekai%20CTF/cryptoGRAPHy%203/solve.py"><code>solve.py</code></a>.</p><div class="mt6 instapaper_ignoref"></div></div><aside aria-label="aside" class="w-20-l aside-desktop"><div class="bg-card pa3 nested-list-reset nested-copy-line-height nested-links" style="position:sticky;top:5rem;padding-bottom:0"><p class="f5 b pb2" style="border-bottom:5px solid var(--background);margin:0">Contenidos</p><nav id="TableOfContents"><ul><li><a href="#_graph-encryption-scheme_"><em>Graph Encryption Scheme</em></a><ul><li><a href="#entendiendo-el-cifrado">Entendiendo el cifrado</a></li><li><a href="#comprendiendo-las-consultas">Comprendiendo las consultas</a></li><li><a href="#resumen">Resumen</a></li></ul></li><li><a href="#cryptography-1">cryptoGRAPHy 1</a><ul><li><a href="#análisis-del-código-fuente">Análisis del código fuente</a></li><li><a href="#solución">Solución</a></li><li><a href="#_flag_"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-2">cryptoGRAPHy 2</a><ul><li><a href="#sdsp-y-grados-de-los-nodos">SDSP y grados de los nodos</a></li><li><a href="#análisis-del-código-fuente-1">Análisis del código fuente</a></li><li><a href="#solución-1">Solución</a></li><li><a href="#_flag_-1"><em>Flag</em></a></li></ul></li><li><a href="#cryptography-3">cryptoGRAPHy 3</a><ul><li><a href="#análisis-del-código-fuente-2">Análisis del código fuente</a></li><li><a href="#solución-2">Solución</a></li><li><a href="#_flag_-2"><em>Flag</em></a></li></ul></li></ul></nav><div class="bg-card" style="border-top:5px solid var(--background)"><a class="bmc-btn w-100" target="_blank" href="http://buymeacoffee.com/7Rocky" style="padding:0" title="Buy me a beer">🍺 <span class="bmc-btn-text" style="font-family:Cookie!important;color:#fff">Buy me a beer</span></a></div></div></aside></article></main><footer class="bottom-0 w-100" role="contentinfo"><div class="tc mw8 ph3" style="margin:auto"><form style="background-color:var(--background-card)" class="tc mw8 pv3 mb3" action="https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter" target="popupwindow" onsubmit='return window.open("https://mailchi.mp/59ffae939360/7rockys-blog-weekly-newsletter"),!0'><h3 class="tc">7Rocky's Blog Weekly Newsletter</h3><p class="tc"><input class="f5 pv3 ph3 bn" style="background-color:var(--background);color:inherit;font-weight:700;line-height:normal" type="submit" value="Recibe un resumen semanal del blog"></p><input type="hidden" value="1" name="embed">
<input style="display:none;color:var(--header)" type="submit" value="Suscribirse"><p class="tc"><a href="/en/newsletters/" target="_blank" title="View letter archive">Ver historial de resúmenes</a></p><p class="tc">impulsado por <a href="http://www.mailchimp.com" target="_blank" title="Mailchimp">Mailchimp</a></p></form></div><div class="bg-black w-100 pa3" role="contentinfo"><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://7rocky.github.io/" title="https://7rocky.github.io/">&copy; Blog de 7Rocky. Ciberseguridad y Mates 2023</a><div style="margin-top:8px"><div><div><a href="https://www.linkedin.com/in/roberto-gesteira-minarro/" target="_blank" class="link-transition linkedin link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel="noopener" aria-label="follow on LinkedIn——Opens in a new window"><svg height="30" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a><a href="https://github.com/7Rocky" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel="noopener" aria-label="follow on GitHub——Opens in a new window"><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class="new-window"><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></div></div></div></footer></body></html>