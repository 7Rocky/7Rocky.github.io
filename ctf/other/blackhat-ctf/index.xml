<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BlackHat CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/</link><description>Recent content in BlackHat CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/blackhat-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>fno-stack-protector</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/fno-stack-protector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/blackhat-ctf/fno-stack-protector/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si lo abrimos en Ghidra, veremos las siguientes funciones:
void bad_function() { execve("/bin/sh", NULL, NULL); } void vuln() { char data[10]; read(0, data, 170); } int main() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return 0; } Existe una vulnerabilidad de Buffer Overflow.</description></item><item><title>Hope you know JS</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/hope-you-know-js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/blackhat-ctf/hope-you-know-js/</guid><description>Se nos proporciona un código JavaScript ofuscado llamado good-luck.js. Al ejecutarlo en un documento HTML sencillo, muestra una ventana para validar la flag:
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang="en"&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset="UTF-8"&amp;gt; &amp;lt;title&amp;gt;Hope you know JS&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script src="good-luck.js"&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Haciendo uso del formateador Prettier en Visual Studio Code, pude encontrar patrones que se repetían a lo largo del código. Por ejemplo, empezé a sustituir expresiones como +!![] o ![] por sus valores finales.</description></item><item><title>Robot Factory</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/robot-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/blackhat-ctf/robot-factory/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Nos dan un Dockerfile que comienza por FROM ubuntu:18.04, así que podemos coger Glibc desde el contenedor y usar pwninit para parchear el binario:
$ docker run --rm -v "$(pwd)":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.</description></item><item><title>Secret Note</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/secret-note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/blackhat-ctf/secret-note/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Si abrimos el binario en Ghidra, veremos las siguientes funciones:
void get_name() { long in_FS_OFFSET; char name[40]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); puts("Please fill in your name:"); read(0, name, 30); printf("Thank you "); printf(name); if (canary != *(long *) (in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } int main() { long in_FS_OFFSET; char secret[56]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts("</description></item><item><title>Ursa Minor</title><link>https://7rocky.github.io/ctf/other/blackhat-ctf/ursa-minor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/blackhat-ctf/ursa-minor/</guid><description>Se nos proporciona el siguiente código y una instancia a la que conectarnos:
#!/usr/local/bin/python # # Polymero # # Imports from Crypto.Util.number import isPrime, getPrime, inverse import hashlib, time, os # Local import FLAG = os.environ.get('FLAG').encode() class URSA: # Upgraded RSA (faster and with cheap key cycling) def __init__(self, pbit, lbit): p, q = self.prime_gen(pbit, lbit) self.public = {'n': p * q, 'e': 0x10001} self.private = {'p': p, 'q': q, 'f': (p - 1)*(q - 1), 'd': inverse(self.</description></item></channel></rss>