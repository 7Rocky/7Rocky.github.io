<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SECCON CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/seccon-ctf/</link><description>Recent content in SECCON CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/seccon-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>plai_n_rsa</title><link>https://7rocky.github.io/ctf/other/seccon-ctf/plai_n_rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/seccon-ctf/plai_n_rsa/</guid><description>Se nos proporciona el código fuente de Python para cifrar la flag:
import os from Crypto.Util.number import bytes_to_long, getPrime flag = os.getenvb(b"FLAG", b"SECCON{THIS_IS_FAKE}") assert flag.startswith(b"SECCON{") m = bytes_to_long(flag) e = 0x10001 p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 phi = (p-1)*(q-1) d = pow(e, -1, phi) hint = p+q c = pow(m,e,n) print(f"e={e}") print(f"d={d}") print(f"hint={hint}") print(f"c={c}") Y la salida del script:
e=65537 d=15353693384417089838724462548624665131984541847837698089157240133474013117762978616666693401860905655963327632448623455383380954863892476195097282728814827543900228088193570410336161860174277615946002137912428944732371746227020712674976297289176836843640091584337495338101474604288961147324379580088173382908779460843227208627086880126290639711592345543346940221730622306467346257744243136122427524303881976859137700891744052274657401050973668524557242083584193692826433940069148960314888969312277717419260452255851900683129483765765679159138030020213831221144899328188412603141096814132194067023700444075607645059793 hint=275283221549738046345918168846641811313380618998221352140350570432714307281165805636851656302966169945585002477544100664479545771828799856955454062819317543203364336967894150765237798162853443692451109345096413650403488959887587524671632723079836454946011490118632739774018505384238035279207770245283729785148 c=8886475661097818039066941589615421186081120873494216719709365309402150643930242604194319283606485508450705024002429584410440203415990175581398430415621156767275792997271367757163480361466096219943197979148150607711332505026324163525477415452796059295609690271141521528116799770835194738989305897474856228866459232100638048610347607923061496926398910241473920007677045790186229028825033878826280815810993961703594770572708574523213733640930273501406675234173813473008872562157659306181281292203417508382016007143058555525203094236927290804729068748715105735023514403359232769760857994195163746288848235503985114734813 El servidor usa RSA para cifrar la flag.</description></item><item><title>readme 2023</title><link>https://7rocky.github.io/ctf/other/seccon-ctf/readme-2023/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/seccon-ctf/readme-2023/</guid><description>Se nos proporciona el código fuente en Python que se ejecuta en el servidor:
import mmap import os import signal signal.alarm(60) try: f = open("./flag.txt", "r") mm = mmap.mmap(f.fileno(), 0, prot=mmap.PROT_READ) except FileNotFoundError: print("[-] Flag does not exist") exit(1) while True: path = input("path: ") if 'flag.txt' in path: print("[-] Path not allowed") exit(1) elif 'fd' in path: print("[-] No more fd trick ;)") exit(1) with open(os.path.realpath(path), "rb") as f: print(f.</description></item></channel></rss>