<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HackOn CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/</link><description>Recent content in HackOn CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/hackon-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>El cifrao del cuñao</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/el-cifrao-del-cu%C3%B1ao/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/el-cifrao-del-cu%C3%B1ao/</guid><description>Se nos proporciona un script en Python que cifra la flag con RSA:
from Crypto.Util.number import getPrime, bytes_to_long import random flag='HackOn{testing_flag}' p = getPrime(1024) q = getPrime(1024) r = getPrime(24) N1 = p * q * r N = p * q e1 = 34456075732829756714431696264844933736161425428678777444326530245267175496676105 e2 = 66213320562378389542956020292848603326457400359492442893037745994906793456536650 c1 = pow(7 * p + random.randint(N,N1) * q, e1, N) c2 = pow(5 * p + random.randint(2,N) * q, e2, N) print (f'N1: {N1}\ne1: {e1}\ne2: {e2}\nc1: {c1}\nc2: {c2}') flag_enc= pow(bytes_to_long(flag.</description></item><item><title>Favela Ransomware</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/favela-ransomware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/favela-ransomware/</guid><description>En este reto nos dan un Windows PE llamado favela_ransom.exe junto con otros archivos que forman parte de un ataque de ransomware, junto con los archivos cifrados que tenemos que recuperar:
$ file * diary.txt: data favela_ransom.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows flag.enc: data lia sikora desnuda.jpg: data note.txt: Unicode text, UTF-8 text ransomed.png: PNG image data, 2643 x 1580, 8-bit/color RGBA, non-interlaced Ingeniería inversa Al abrir el ejecutable en Ghidra, y mirar las strings, vemos una curiosa que apunta a un Gist de GitHub: https://gist.</description></item><item><title>Guglu v2</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/guglu-v2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/guglu-v2/</guid><description>Se nos proporciona esta página web para crear notas. También existe un bot que accede a su perfil y accede después a una URL provista por nosotros. Disponemos también de los proyectos en Node.js.
Análisis del código fuente Las funciones de registro (/register) e inicio de sesión (/login) están correctamente implementadas.
La funcionalidad principal de la aplicación es la posibilidad de crear y buscar notas (web/src/routes/post.router.js):
router.get('/posts', (req, res) =&amp;gt; { const { page } = req.</description></item><item><title>Jorge Wants a Token</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/jorge-wants-a-token/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/jorge-wants-a-token/</guid><description>Se nos el código fuente en Python del servidor. Por un lado tenemos administation.py (el archivo principal), y por otro tenemos library.py (funciones auxiliares). El servidor nos da estas opciones:
$ nc 0.cloud.chals.io 15980 __ __ __ ____ / / / /___ ______/ /__/ __ \____ / /_/ / __ `/ ___/ //_/ / / / __ \ / __ / /_/ / /__/ ,&amp;lt; / /_/ / / / / /_/ /_/\__,_/\___/_/|_|\____/_/ /_/ Welcome to the HackOn administration.</description></item><item><title>La casa de papel</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/la-casa-de-papel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/la-casa-de-papel/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Además, disponemos del código fuente en C. El programa es un gestor de notas con un menú bastante típico:
$ ./chall ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡒⠦⠤⠤⠄⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⢼⠀⠀⠒⠒⠤⠤⠤⠤⠤⣀⣀⣀⣀⠀⠀⠘⡇⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢀⣀⠤⠔⠒⠉⠁⢀⣼⡀⠀⢠⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡧⠚⠉⢹⡀⠀⠀⠀⠀⠀⠀ ⠰⣖⠊⠉⠀⠀⠀⣠⠔⠚⠉⠁⢀⡇⠀⡀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⢀⡇⠀⣤⠀⢷⡀⠀⠀⠀⠀⠀ ⠀⠈⠳⡄⠀⠀⠋⣠⠖⠂⡠⠖⢙⡇⠀⠈⠉⠉⠉⠉⠓⠒⠒⠒⠒⠒⠆⠀⠀⣷⡀⠉⢦⠀⢳⡀⠀⠀⠀⠀ ⠀⠀⠀⠈⢦⠀⠀⠁⠀⠀⠀⢀⠼⡇⠀⠀⠦⠤⠤⠄⡀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠱⡀⠀⠳⡀⠙⣆⠀⠀⠀ ⠀⠀⠀⠀⠀⠳⡄⠀⢀⡤⠊⠁⢠⡇⠀⠠⠤⢤⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⡧⡀⠙⢄⠀⠱⠄⠈⠳⡄⠀ ⠀⠀⠀⠀⠀⠀⠙⡄⠀⠀⡠⠔⢻⠀⠀⠀⠀⠀⠀⠠⣄⣀⣀⣁⣀⠀⠀⠀⠀⡇⠱⡀⠀⠀⠀⠀⠀⣀⣘⣦ ⠀⠀⠀⠀⠀⠀⠀⠘⣆⠀⠀⠀⡸⠀⠀⠰⣄⣀⡀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⡇⠀⠃⢀⣠⠴⠛⠉⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠙⠒⠀⠀⠀⠠⡇⣠⠔⠋⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⢸⠁⠀⠀⠀⠒⠲⠤⣀⡀⠀⠀⠀⠀⠀⠀⠀⢰⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠀⠀⠀⠀⠀⠉⠑⠢⣄⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣎⣀⠀⠀⠀⠀⠀⠀⠀⠢⠤⣀⠀⠀⠁⠀⠀⠀⠸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢡⠉⠙⠒⠤⢤⡀⠀⠀⠀⠀⠉⠒⠀⠀⠀⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠶⠒⠊⠉⠉⠉⠓⠦⣀⠀⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠲⢄⡀⠀⠀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠲⣼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ What would you like to do?</description></item><item><title>Noleak</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/noleak/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/noleak/</guid><description>Se nos proporciona un binario de 64 bits llamado noleak:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Su código descompilado en C es muy sencillo:
undefined8 _() { undefined8 unaff_RBP; return unaff_RBP; } void FUN_00401060(FILE *param_1, char *param_2, int param_3, size_t param_4) { setvbuf(param_1, param_2, param_3, param_4); } undefined8 vuln() { undefined8 param_10; undefined8 local_12; undefined2 local_a; local_12 = 0; local_a = 0; gets((char *) &amp;amp;local_12); return param_10; } undefined8 main(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5, undefined8 param_6) { FUN_00401060(stdin, 0, 2, 0, param_5, param_6, param_2); FUN_00401060(stdout, 0, 2, 0); FUN_00401060(stderr, 0, 2, 0); vuln(); return 0; } Básicamente, tenemos un programa que usa gets sobre un buffer de 10 bytes (&amp;quot;undefined8 + undefined2&amp;quot;).</description></item><item><title>PICtureThis</title><link>https://7rocky.github.io/ctf/other/hackon-ctf/picturethis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackon-ctf/picturethis/</guid><description>En este reto nos dan un Windows PE llamado main.exe y una DLL cifrada (ciphered.dll):
$ file * ciphered.dll: data main.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows Análisis de main.exe De momento, podemos comenzar por abrir main.exe en Ghidra y mirar las strings. Rápidamente vemos una que indica cómo se tiene que ejecutar el archivo main.exe:
Funcionamiento: ./reto.exe &amp;lt;input_string&amp;gt; Si buscamos por referencias a esta string, llegaremos a la función principal:</description></item></channel></rss>