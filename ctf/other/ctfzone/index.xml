<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CTFZone on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/ctfzone/</link><description>Recent content in CTFZone on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/ctfzone/index.xml" rel="self" type="application/rss+xml"/><item><title>Come on feel the nonce</title><link>https://7rocky.github.io/ctf/other/ctfzone/come-on-feel-the-nonce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ctfzone/come-on-feel-the-nonce/</guid><description>Se nos proporciona el código fuente en Go:
package main import ( "crypto/elliptic" cryptorand "crypto/rand" "crypto/sha256" "encoding/base64" "fmt" "log" "math" "math/big" "math/rand" "os" ) func randInt64() int64 { n, err := cryptorand.Int(cryptorand.Reader, big.NewInt(math.MaxInt64)) if err != nil { panic(err) } return n.Int64() } func encrypt(data, priv []byte) string { res := make([]byte, 0) st := sha256.Sum256(priv) for i, b := range data { res = append(res, b^st[i]) } return base64.StdEncoding.EncodeToString(res) } func decrypt(enc string, priv []byte) string { res := make([]byte, 0) data, _ := base64.</description></item><item><title>Right Decision</title><link>https://7rocky.github.io/ctf/other/ctfzone/right-decision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ctfzone/right-decision/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import random import string import Crypto.Util.number as number import numpy as np import json import socketserver import galois from hashlib import md5 PORT = 31339 with open('params.txt') as f: params = json.load(f) p = params['galois_p'] k = params['k'] n = params['RSA_n'] gf = galois.GF(p,verify=False,primitive_element=2) with open('votes.txt') as f: votes = json.load(f) with open('flag.txt') as f: flag = f.read() def check_secret(s): #check if secret is real phi for public key n return pow(2,s,n)==1 def parse_new_vote(data): all_votes = votes.</description></item></channel></rss>