<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB Cyber Apocalypse 2023 on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/</link><description>Recent content in HTB Cyber Apocalypse 2023 on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/alien-saboteaur/</guid><description>Próximamente</description></item><item><title>Artifacts of Dangerous Sightings</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/artifacts-of-dangerous-sightings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/artifacts-of-dangerous-sightings/</guid><description>Se nos proporciona una imagen de disco de Windows dentro de una carpeta llamada HostEvidence_PANDORA:
$ file HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx: Microsoft Disk Image eXtended, by .NET DiscUtils, sequence 0x8, NO Log Signature; region, 2 entries, id Metadata, at 0x200000, Required 1, id BAT, at 0x300000, Required 1 Si cambiamos a una máquina de Windows y montamos la imagen del disco, tendremos las siguientes carpetas:
Analizando la imagen del disco Básicamente, tenemos la unidad C:\ de una máquina de Windows.</description></item><item><title>Bashic Ransomware</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/bashic-ransomware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/bashic-ransomware/</guid><description>Se nos proporcionan estos archivos:
$ file * flag.txt.a59ap: GPG symmetrically encrypted data (AES256 cipher) forensics.mem: data linux-image-5.10.0-21.zip: Zip archive data, at least v2.0 to extract, compression method=deflate traffic.pcap: pcapng capture file - version 1.0 Podemos deducir que necesitamos analizar una máquina de Linux comprometida porque se nos da un volcado de memoria(forensics.mem) y un perfil para volatility.
Análisis de tráfico de red Comencemos a usar Wireshark para analizar el PCAP:</description></item><item><title>Biased Heritage</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/biased-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/biased-heritage/</guid><description>Este desafío es una especie de continuación de Colliding Heritage. Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????????????????}" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.</description></item><item><title>Calibrator</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/calibrator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/calibrator/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 165.227.224.40 31139 [OK] Memory check [OK] Syncing filesystem [OK] Detecting sensors [OK] Module loader [OK] Reading configurations Inititing calibration process ... ┌──────────────────────────────────────────────────────────────────────┐ │┼───────────────────┼────────────────────────┼┼──────────────────────┼│ ││ XenoCal 2000 │ . ││ ││ │┼───────────────────┤ ┌─┐ x││ . . ││ ││ Iteration: 42 │ x ► └─┘ ││ x ││ │┼─────────┬─────────┤ ││ ││ ││ X:1337 │ Y:65189 │ . x ┌───┼┼───┐ ││ │┼─────────┴─────────┘ x ┌─┘ ││ └─┐ x ││ ││ .</description></item><item><title>Colliding Heritage</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/colliding-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/colliding-heritage/</guid><description>Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????}" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.</description></item><item><title>Control Room</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/control-room/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/control-room/</guid><description>Se nos proporciona un binario de 64 bits llamado control_room:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Configuración del entorno También se nos proporciona la librería remota Glibc:
$ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Converging Visions</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/converging-visions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/converging-visions/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from secret import FLAG, p, a, b from sage.all_cmdline import * class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.</description></item><item><title>Didactic Octo Paddles</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/didactic-octo-paddles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/didactic-octo-paddles/</guid><description>Se nos da un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis del código fuente La aplicación web está construida con Express JS. Después de leer algunos archivos, uno que destaca es middlewares/AdminMiddleware.js:
const jwt = require("jsonwebtoken"); const { tokenKey } = require("../utils/authorization"); const db = require("../utils/database"); const AdminMiddleware = async (req, res, next) =&amp;gt; { try { const sessionCookie = req.cookies.session; if (!sessionCookie) { return res.</description></item><item><title>Elliptic Labyrinth</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print("1. Get parameters of path"</description></item><item><title>Elliptic Labyrinth Revenge</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/elliptic-labyrinth-revenge/</guid><description>Este desafío es una modificación de Elliptic Labyrinth para obligar a los jugadores de CTF a usar la vía intencionada de resolver el reto.
Encontrando diferencias El código fuente proporcionado es un poco diferente:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.</description></item><item><title>Hijack</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/hijack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/hijack/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 167.71.143.44 31614 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; Reconocimiento básico Tenemos dos opciones. Usando la primera, podemos establecer una configuración y la salida es una cadena codificada en Base64:
$ nc 165.232.100.46 31251 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; 1 - Creating new config - Temperature units (F/C/K): C Propulsion Components Target Temperature : 13 Solar Array Target Temperature : 37 Infrared Spectrometers Target Temperature : 0 Auto Calibration (ON/OFF) : ON Serialized config: ISFweXRob24vb2JqZWN0Ol9fbWFpbl9fLkNvbmZpZyB7SVJfc3BlY3Ryb21ldGVyX3RlbXA6ICcwJywgYXV0b19jYWxpYnJhdGlvbjogJ09OJywKICBwcm9wdWxzaW9uX3RlbXA6ICcxMycsIHNvbGFyX2FycmF5X3RlbXA6ICczNycsIHVuaXRzOiBDfQo= Uploading to ship.</description></item><item><title>HM74</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/hm74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/hm74/</guid><description>Se nos proporciona este código de descripción de hardware en Verilog:
module encoder( input [3:0] data_in, output [6:0] ham_out ); wire p0, p1, p2; assign p0 = data_in[3] ^ data_in[2] ^ data_in[0]; assign p1 = data_in[3] ^ data_in[1] ^ data_in[0]; assign p2 = data_in[2] ^ data_in[1] ^ data_in[0]; assign ham_out = { p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0] }; endmodule module main; wire[3:0] data_in = 5; wire[6:0] ham_out; encoder en(data_in, ham_out); initial begin #10; $display("</description></item><item><title>Inside The Matrix</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/inside-the-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/inside-the-matrix/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b"HTB{????????????????????}" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.</description></item><item><title>Interstellar C2</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/interstellar-c2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/interstellar-c2/</guid><description>Se nos proporciona un archivo PCAP llamado capture.pcapng. Vamos a verlo en Wireshark:
Como siempre, es bueno comenzar a analizar protocolos de alto nivel como HTTP, así que apliquemos un filtro:
La primera petición se intenta descargar un script de PowerShell llamado vn84.ps1:
Desofuscación de PowerShell Podemos tomar el script de Wireshark y leerlo aquí:
.("{1}{0}{2}" -f'T','Set-i','em') ('vAriA'+'ble'+':q'+'L'+'z0so') ( [tYpe]("{0}{1}{2}{3}" -F'SySTEM.i','o.Fi','lE','mode')) ; &amp;amp;("{0}{2}{1}" -f'set-Vari','E','ABL') l60Yu3 ( [tYPe]("{7}{0}{5}{4}{3}{1}{2}{6}"-F'm.','ph','Y.ae','A','TY.crypTOgR','SeCuRi','S','sYSte')); .("{0}{2}{1}{3}" -f 'Set-V','i','AR','aBle') BI34 ( [TyPE]("</description></item><item><title>Janken</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/janken/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/janken/</guid><description>Se nos proporciona un archivo binario llamado janken y una instancia remota a la que conectarnos:
$ file janken janken: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, BuildID[sha1]=56b54cdae265aa352fe2ebb016f86af831fd58d3, for GNU/Linux 3.2.0, not stripped Se trata de un juego de Piedra-Papel-Tijera:
$ nc 167.99.86.8 31902 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▌ じ ゃ ん 拳 ▐ ▙▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▟ 1. ℙ ∟ ₳ Ұ 2. ℜ ℧ ∟ Ӗ ⅀ &amp;gt;&amp;gt; 2 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▚ [*] Rock is called "</description></item><item><title>Labyrinth</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/labyrinth/</guid><description>Próximamente</description></item><item><title>Math Door</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/math-door/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/math-door/</guid><description>Se nos proporciona un binario de 64 bits llamado math-door:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' Configuración del entorno También se nos proporciona la librería y el cargador de Glibc remotos:
$ ./ld.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions.</description></item><item><title>Multipage Recyclings</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/multipage-recyclings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/multipage-recyclings/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.</description></item><item><title>nehebkaus trap</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/nehebkaus-trap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/nehebkaus-trap/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 167.71.143.44 32139 __ {00} \__/ /^/ ( ( \_\_____ (_______) (_________()Ooo. [ Nehebkau's Trap ] You are trapped! Can you escape? &amp;gt; Reconocimiento básico Se nos permite ingresar alguna información, pero muestra un error:
&amp;gt; asdf [*] Input accepted! Error: name 'asdf' is not defined El mensaje de error parece familiar para un REPL de Python:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; asdf Traceback (most recent call last): File "</description></item><item><title>Orbital</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/orbital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/orbital/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Python.
Análisis del código fuente La aplicación web está construida con Flask. Se puede encontrar una vulnerabilidad clara de inyección SQL (SQLi) en database.py:
from colorama import Cursor from application.util import createJWT, passwordVerify from flask_mysqldb import MySQL mysql = MySQL() def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.</description></item><item><title>Pandora's Bane</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/pandoras-bane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/pandoras-bane/</guid><description>Próximamente</description></item><item><title>Pandora's Box</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/pandoras-box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/pandoras-box/</guid><description>Próximamente</description></item><item><title>Passman</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/passman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/passman/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis de código fuente La aplicación web está construida con Express JS. Un archivo relevante es routes/index.js:
const express = require('express'); const router = express.Router(); const { graphqlHTTP } = require('express-graphql'); const AuthMiddleware = require('../middleware/AuthMiddleware'); const GraphqlSchema = require('../helpers/GraphqlHelper'); router.get('/', (req, res) =&amp;gt; { return res.render('login.html'); }); router.get('/register', (req, res) =&amp;gt; { return res.render('register.html'); }); router.</description></item><item><title>Relic Maps</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/relic-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/relic-maps/</guid><description>Próximamente</description></item><item><title>Restricted</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/restricted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/restricted/</guid><description>Se nos da una instancia remota para conectarnos:
$ nc 64.227.41.83 30543 SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1 Invalid SSH identification string. Ncat: Broken pipe. Parece que debemos acceder a través de SSH.
Conexión por SSH También se nos proporcionan algunos archivos:
$ tree . ├── Dockerfile ├── build_docker.sh └── src ├── bash_profile ├── flag.txt └── sshd_config 2 directories, 5 files Mirando el DockerFile, vemos que hay un usuario llamado restricted y tiene configurado rbash (Bash restringida):</description></item><item><title>Roten</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/roten/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/roten/</guid><description>Se nos proporciona un archivo PCAP (challenge.pcap) con muchos paquetes de red:
Encontrando el vector de ataque En primer lugar, filtremos por HTTP para leer solo paquetes de red de alto nivel:
El atacante está hurgando con el sitio web. Por ejemplo, está tratando de usar parámetros POST:
Si vamos al final de la captura de paquetes, veremos que los atacantes consiguen ejecutar comandos de sistema:
En el comando ls anterior, vemos un archivo llamado galacticmap.</description></item><item><title>Small StEps</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/small-steps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/small-steps/</guid><description>Se nos da una instancia remota para conectarnos:
$ nc 188.166.152.84 32213 This is the second level of training. [E]ncrypt the flag. [A]bort training. &amp;gt; También se nos proporciona el código fuente de Python del servidor:
from Crypto.Util.number import getPrime, bytes_to_long FLAG = b"HTB{???????????????}" assert len(FLAG) == 20 class RSA: def __init__(self): self.q = getPrime(256) self.p = getPrime(256) self.n = self.q * self.p self.e = 3 def encrypt(self, plaintext): plaintext = bytes_to_long(plaintext) return pow(plaintext, self.</description></item><item><title>SpyBug</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/spybug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/spybug/</guid><description>Próximamente</description></item><item><title>TrapTrack</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/traptrack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/traptrack/</guid><description>Se nos proporciona una página web como esta:
También tenemos el código fuente del proyecto.
Funcionalidad del sitio web La aplicación web nos permite ingresar una URL que se almacenará en una base de datos SQLite. Al leer el código de challenge/application/config.py encontramos credenciales válidas (admin:admin):
from application.util import generate import os class Config(object): SECRET_KEY = generate(50) ADMIN_USERNAME = 'admin' ADMIN_PASSWORD = 'admin' SESSION_PERMANENT = False SESSION_TYPE = 'filesystem' SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/database.</description></item><item><title>Void</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/void/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse-2023/void/</guid><description>Se nos proporciona un binario de 64 bits llamado void:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Si usamos Ghidra, encontraremos este código descompilado en C:
void vuln() { char data[64]; read(0, data, 200); } int main() { vuln(); return 0; } El código es muy corto y solo hay un solo punto para ingresar datos.
Vulnerabilidad de Buffer Overflow Hay una clara vulnerabilidad de Buffer Overflow ya que data es un vector de char de 64 bytes, y read está leyendo hasta 200 bytes y almacena la información en data.</description></item></channel></rss>