<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Plaid CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/plaid-ctf/</link><description>Recent content in Plaid CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/plaid-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>DHCPPP</title><link>https://7rocky.github.io/ctf/other/plaid-ctf/dhcppp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/plaid-ctf/dhcppp/</guid><description>Se nos proporciona el c√≥digo fuente en Python del servidor que tiene la flag:
import time, zlib import secrets import hashlib import requests from Crypto.Cipher import ChaCha20_Poly1305 import dns.resolver CHACHA_KEY = secrets.token_bytes(32) TIMEOUT = 1e-1 def encrypt_msg(msg, nonce): # In case our RNG nonce is repeated, we also hash # the message in. This means the worst-case scenario # is that our nonce reflects a hash of the message # but saves the chance of a nonce being reused across # different messages nonce = sha256(msg[:32] + nonce[:32])[:12] cipher = ChaCha20_Poly1305.</description></item></channel></rss>