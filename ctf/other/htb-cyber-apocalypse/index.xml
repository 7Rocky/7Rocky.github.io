<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTB Cyber Apocalypse on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/</link><description>Recent content in HTB Cyber Apocalypse on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/alien-saboteaur/</guid><description>Se nos proporciona un archivo binario llamado vm y un programa llamado bin:
$ file * bin: data vm: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=10fb238b19d3a82b46536b51e47396525086a09c, for GNU/Linux 3.2.0, not stripped Configuración del entorno El binario necesita una versión reciente de Glibc para funcionar:
$ ./vm ./vm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./vm) Para resolver este problema, podemos ejecutar Ubuntu 22.04 en un contenedor de Docker y tomar la librería y el cargador para parchear el binario:</description></item><item><title>Arranged</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/arranged/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/arranged/</guid><description>Se nos proporciona el código fuente en SageMath para cifrar la flag:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 from secret import FLAG, p, b, priv_a, priv_b F = GF(p) E = EllipticCurve(F, [726, b]) G = E(926644437000604217447316655857202297402572559368538978912888106419470011487878351667380679323664062362524967242819810112524880301882054682462685841995367, 4856802955780604241403155772782614224057462426619061437325274365157616489963087648882578621484232159439344263863246191729458550632500259702851115715803253) A = G * priv_a B = G * priv_b print(A) print(B) C = priv_a * B assert C == priv_b * A # now use it as shared secret secret = C[0] hash = sha256() hash.</description></item><item><title>Artifacts of Dangerous Sightings</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/artifacts-of-dangerous-sightings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/artifacts-of-dangerous-sightings/</guid><description>Se nos proporciona una imagen de disco de Windows dentro de una carpeta llamada HostEvidence_PANDORA:
$ file HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx HostEvidence_PANDORA/2023-03-09T132449_PANDORA.vhdx: Microsoft Disk Image eXtended, by .NET DiscUtils, sequence 0x8, NO Log Signature; region, 2 entries, id Metadata, at 0x200000, Required 1, id BAT, at 0x300000, Required 1 Si cambiamos a una máquina de Windows y montamos la imagen del disco, tendremos las siguientes carpetas:
Analizando la imagen del disco Básicamente, tenemos la unidad C:\ de una máquina de Windows.</description></item><item><title>Bashic Ransomware</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/bashic-ransomware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/bashic-ransomware/</guid><description>Se nos proporcionan estos archivos:
$ file * flag.txt.a59ap: GPG symmetrically encrypted data (AES256 cipher) forensics.mem: data linux-image-5.10.0-21.zip: Zip archive data, at least v2.0 to extract, compression method=deflate traffic.pcap: pcapng capture file - version 1.0 Podemos deducir que necesitamos analizar una máquina de Linux comprometida porque se nos da un volcado de memoria(forensics.mem) y un perfil para volatility.
Análisis de tráfico de red Comencemos a usar Wireshark para analizar el PCAP:</description></item><item><title>Biased Heritage</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/biased-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/biased-heritage/</guid><description>Este reto es una especie de continuación de Colliding Heritage. Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????????????????}" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.</description></item><item><title>Calibrator</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/calibrator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/calibrator/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 165.227.224.40 31139 [OK] Memory check [OK] Syncing filesystem [OK] Detecting sensors [OK] Module loader [OK] Reading configurations Inititing calibration process ... ┌──────────────────────────────────────────────────────────────────────┐ │┼───────────────────┼────────────────────────┼┼──────────────────────┼│ ││ XenoCal 2000 │ . ││ ││ │┼───────────────────┤ ┌─┐ x││ . . ││ ││ Iteration: 42 │ x ► └─┘ ││ x ││ │┼─────────┬─────────┤ ││ ││ ││ X:1337 │ Y:65189 │ . x ┌───┼┼───┐ ││ │┼─────────┴─────────┘ x ┌─┘ ││ └─┐ x ││ ││ .</description></item><item><title>Colliding Heritage</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/colliding-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/colliding-heritage/</guid><description>Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????}" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.</description></item><item><title>Control Room</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/control-room/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/control-room/</guid><description>Se nos proporciona un binario de 64 bits llamado control_room:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Configuración del entorno También se nos proporciona la librería remota Glibc:
$ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>Converging Visions</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/converging-visions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/converging-visions/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from secret import FLAG, p, a, b from sage.all_cmdline import * class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.</description></item><item><title>Didactic Octo Paddles</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/didactic-octo-paddles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/didactic-octo-paddles/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis del código fuente La aplicación web está construida con Express JS. Después de leer algunos archivos, uno que destaca es middlewares/AdminMiddleware.js:
const jwt = require("jsonwebtoken"); const { tokenKey } = require("../utils/authorization"); const db = require("../utils/database"); const AdminMiddleware = async (req, res, next) =&amp;gt; { try { const sessionCookie = req.cookies.session; if (!sessionCookie) { return res.</description></item><item><title>Elliptic Labyrinth</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print("1. Get parameters of path"</description></item><item><title>Elliptic Labyrinth Revenge</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/elliptic-labyrinth-revenge/</guid><description>Este reto es una modificación de Elliptic Labyrinth para obligar a los jugadores de CTF a usar la vía intencionada de resolver el reto.
Encontrando diferencias El código fuente proporcionado es un poco diferente:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * from secret import FLAG class ECC: def __init__(self, bits): self.</description></item><item><title>Gloater</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/gloater/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/gloater/</guid><description>Se nos proporciona un binario de 64 bits llamado gloater:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' También se nos proporciona un Dockerfile con la configuración del contenedor:
FROM ubuntu:20.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update --fix-missing &amp;amp;&amp;amp; apt-get -y upgrade RUN apt-get install -y socat RUN useradd -m ctf COPY challenge/* /home/ctf/ RUN chown -R ctf:ctf /home/ctf/ WORKDIR /home/ctf #USER ctf EXPOSE 9001 CMD ["</description></item><item><title>Hijack</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/hijack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/hijack/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 167.71.143.44 31614 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; Reconocimiento básico Tenemos dos opciones. Usando la primera, podemos establecer una configuración y la salida es una cadena codificada en Base64:
$ nc 165.232.100.46 31251 &amp;lt;------[TCS]------&amp;gt; [1] Create config [2] Load config [3] Exit &amp;gt; 1 - Creating new config - Temperature units (F/C/K): C Propulsion Components Target Temperature : 13 Solar Array Target Temperature : 37 Infrared Spectrometers Target Temperature : 0 Auto Calibration (ON/OFF) : ON Serialized config: ISFweXRob24vb2JqZWN0Ol9fbWFpbl9fLkNvbmZpZyB7SVJfc3BlY3Ryb21ldGVyX3RlbXA6ICcwJywgYXV0b19jYWxpYnJhdGlvbjogJ09OJywKICBwcm9wdWxzaW9uX3RlbXA6ICcxMycsIHNvbGFyX2FycmF5X3RlbXA6ICczNycsIHVuaXRzOiBDfQo= Uploading to ship.</description></item><item><title>HM74</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/hm74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/hm74/</guid><description>Se nos proporciona este código de descripción de hardware en Verilog:
module encoder( input [3:0] data_in, output [6:0] ham_out ); wire p0, p1, p2; assign p0 = data_in[3] ^ data_in[2] ^ data_in[0]; assign p1 = data_in[3] ^ data_in[1] ^ data_in[0]; assign p2 = data_in[2] ^ data_in[1] ^ data_in[0]; assign ham_out = { p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0] }; endmodule module main; wire[3:0] data_in = 5; wire[6:0] ham_out; encoder en(data_in, ham_out); initial begin #10; $display("</description></item><item><title>Iced TEA</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/iced-tea/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/iced-tea/</guid><description>Se nos proporciona el código fuente en Python que cifra la flag:
import os from secret import FLAG from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.</description></item><item><title>Inside The Matrix</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/inside-the-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/inside-the-matrix/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b"HTB{????????????????????}" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.</description></item><item><title>Interstellar C2</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/interstellar-c2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/interstellar-c2/</guid><description>Se nos proporciona un archivo PCAP llamado capture.pcapng. Vamos a verlo en Wireshark:
Como siempre, es bueno comenzar a analizar protocolos de alto nivel como HTTP, así que apliquemos un filtro:
La primera petición se intenta descargar un script de PowerShell llamado vn84.ps1:
Desofuscación de PowerShell Podemos tomar el script de Wireshark y leerlo aquí:
.("{1}{0}{2}" -f'T','Set-i','em') ('vAriA'+'ble'+':q'+'L'+'z0so') ( [tYpe]("{0}{1}{2}{3}" -F'SySTEM.i','o.Fi','lE','mode')) ; &amp;amp;("{0}{2}{1}" -f'set-Vari','E','ABL') l60Yu3 ( [tYPe]("{7}{0}{5}{4}{3}{1}{2}{6}"-F'm.','ph','Y.ae','A','TY.crypTOgR','SeCuRi','S','sYSte')); .("{0}{2}{1}{3}" -f 'Set-V','i','AR','aBle') BI34 ( [TyPE]("</description></item><item><title>Janken</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/janken/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/janken/</guid><description>Se nos proporciona un archivo binario llamado janken y una instancia remota a la que conectarnos:
$ file janken janken: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./.glibc/ld-linux-x86-64.so.2, BuildID[sha1]=56b54cdae265aa352fe2ebb016f86af831fd58d3, for GNU/Linux 3.2.0, not stripped Se trata de un juego de Piedra-Papel-Tijera:
$ nc 167.99.86.8 31902 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▌ じ ゃ ん 拳 ▐ ▙▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▟ 1. ℙ ∟ ₳ Ұ 2. ℜ ℧ ∟ Ӗ ⅀ &amp;gt;&amp;gt; 2 ▛▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▜ ▚ [*] Rock is called "</description></item><item><title>Labyrinth</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/labyrinth/</guid><description>Se nos proporciona un binario de 64 bits llamado labyrinth:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Si lo abrimos en Ghidra, veremos esta función main en código C descompilado:
int main() { int ret; char *__s; char data[32]; ulong i; setup(); banner(); data._0_8_ = 0; data._8_8_ = 0; data._16_8_ = 0; data._24_8_ = 0; fwrite("\nSelect door: \n\n"</description></item><item><title>Math Door</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/math-door/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/math-door/</guid><description>Se nos proporciona un binario de 64 bits llamado math-door:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' Configuración del entorno También se nos proporciona la librería y el cargador de Glibc remotos:
$ ./ld.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions.</description></item><item><title>Maze of Mist</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/maze-of-mist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/maze-of-mist/</guid><description>Se nos proporciona una imagen de kernel vmlinuz-linux comprimida, un sistema de archivos initramfs.cpio.gz y un script run.sh:
$ unzip -l pwn_maze_of_mist.zip Archive: pwn_maze_of_mist.zip Length Date Time Name --------- ---------- ----- ---- 0 2024-02-06 09:30 maze_of_mist/ 1347202 2024-02-06 09:29 maze_of_mist/initramfs.cpio.gz 291 2024-02-06 09:26 maze_of_mist/run.sh 12886816 2024-02-06 09:26 maze_of_mist/vmlinuz-linux --------- ------- 14234309 4 files $ unzip pwn_maze_of_mist.zip Archive: pwn_maze_of_mist.zip creating: maze_of_mist/ inflating: maze_of_mist/initramfs.cpio.gz inflating: maze_of_mist/run.sh inflating: maze_of_mist/vmlinuz-linux Si descomprimimos el sistema de archivos, encontramos un binario de 32 bits llamado target:</description></item><item><title>Multipage Recyclings</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/multipage-recyclings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/multipage-recyclings/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.</description></item><item><title>nehebkaus trap</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/nehebkaus-trap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/nehebkaus-trap/</guid><description>Se nos proporciona una instancia remota a la que conectarnos:
$ nc 167.71.143.44 32139 __ {00} \__/ /^/ ( ( \_\_____ (_______) (_________()Ooo. [ Nehebkau's Trap ] You are trapped! Can you escape? &amp;gt; Reconocimiento básico Se nos permite ingresar alguna información, pero muestra un error:
&amp;gt; asdf [*] Input accepted! Error: name 'asdf' is not defined El mensaje de error parece familiar para un REPL de Python:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; asdf Traceback (most recent call last): File "</description></item><item><title>Oracle</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/oracle/</guid><description>Se nos proporciona un binario de 64 bits llamado oracle:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled También tenemos un Dockerfile:
FROM ubuntu:20.04 RUN useradd -m ctf COPY challenge/* /home/ctf/ RUN chown -R ctf:ctf /home/ctf/ WORKDIR /home/ctf USER ctf EXPOSE 9001 CMD ["./run.sh"] Análisis del código fuente Esta vez, se nos proporciona tambiñen el código fuente del programa en C. Es bastante grande, por lo que solo pondré las partes relevantes.</description></item><item><title>Orbital</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/orbital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/orbital/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Python.
Análisis del código fuente La aplicación web está construida con Flask. Se puede encontrar una vulnerabilidad clara de inyección SQL (SQLi) en database.py:
from colorama import Cursor from application.util import createJWT, passwordVerify from flask_mysqldb import MySQL mysql = MySQL() def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.</description></item><item><title>Pandora's Bane</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/pandoras-bane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/pandoras-bane/</guid><description>Se nos proporciona un volcado de memoria llamado mem.raw:
$ du -h mem.raw 2,1G	mem.raw $ file mem.raw mem.raw: data Análisis de volcado de memoria Usaremos volatility para analizarlo (específicamente, esta imagen de Docker):
$ docker run --rm -v "${PWD}":/project --entrypoint /bin/sh --platform linux/amd64 -it sk4la/volatility3 /usr/local $ cd /project /project $ vol -f mem.raw windows.info.Info | tee info.txt Volatility 3 Framework 2.0.1 Progress: 100.00	PDB scanning finished Variable	Value Kernel Base	0xf80445604000 DTB	0x1ad000 Symbols	file:///usr/local/lib/volatility3/volatility3/symbols/windows/ntkrnlmp.</description></item><item><title>Pandora's Box</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/pandoras-box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/pandoras-box/</guid><description>Se nos proporciona un binario de 64 bits llamado pb:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Podemos usar Ghidra para analizar el binario y mirar el código fuente descompilado en C:
int main() { setup(); cls(); banner(); box(); return 0; } Entre otras, esta función llama a box:
void box() { long num; char data [32]; data.</description></item><item><title>Partial Tenacity</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/partial-tenacity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/partial-tenacity/</guid><description>Se nos proporciona el código fuente en Python que cifra la flag:
from secret import FLAG from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP class RSACipher: def __init__(self, bits): self.key = RSA.generate(bits) self.cipher = PKCS1_OAEP.new(self.key) def encrypt(self, m): return self.cipher.encrypt(m) def decrypt(self, c): return self.cipher.decrypt(c) cipher = RSACipher(1024) enc_flag = cipher.encrypt(FLAG) with open('output.txt', 'w') as f: f.write(f'n = {cipher.key.n}\n') f.write(f'ct = {enc_flag.hex()}\n') f.write(f'p = {str(cipher.key.p)[::2]}\n') f.write(f'q = {str(cipher.key.q)[1::2]}') También tenemos la salida del script:</description></item><item><title>Passman</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/passman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/passman/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis de código fuente La aplicación web está construida con Express JS. Un archivo relevante es routes/index.js:
const express = require('express'); const router = express.Router(); const { graphqlHTTP } = require('express-graphql'); const AuthMiddleware = require('../middleware/AuthMiddleware'); const GraphqlSchema = require('../helpers/GraphqlHelper'); router.get('/', (req, res) =&amp;gt; { return res.render('login.html'); }); router.get('/register', (req, res) =&amp;gt; { return res.render('register.html'); }); router.</description></item><item><title>Path of Survival</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/path-of-survival/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/path-of-survival/</guid><description>Se nos proporciona el siguiente sitio web:
Muestra una especie de laberinto en el que somos un astronauta y necesitamos encontrar un arma en el menor tiempo posible.
El sitio web muestra cómo interactuar con nuestro jugador astronauta y muestra algunas reglas con respecto a las casillas del laberinto. (Cliff, Geyser, Mountain&amp;hellip;):
Además, tenemos una API HTTP para obtener el mapa como documento JSON y ejecutar comandos para mover el astronauta:</description></item><item><title>Percetron</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/percetron/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/percetron/</guid><description>Se nos proporciona un sitio web donde podemos registrarnos e iniciar sesión para tener este dashboard:
Además, tenemos todo el proyecto web para realizar el análisis.
Análisis del código fuente El servidor web ejecuta Express JS (Node.js). El archivo index.js es bastante estándar, pero podemos ver que usa MongoDB y neo4j:
require("dotenv").config(); const path = require("path"); const express = require("express"); const session = require("express-session"); const mongoose = require("mongoose"); const Neo4jConnection = require("</description></item><item><title>Relic Maps</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/relic-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/relic-maps/</guid><description>Tenemos esta descripción para el reto:
Pandora received an email with a link claiming to have information about the location of the relic and attached ancient city maps, but something seems off about it. Could it be rivals trying to send her off on a distraction? Or worse, could they be trying to hack her systems to get what she knows? Investigate the given attachment and figure out what&amp;rsquo;s going on and get the flag.</description></item><item><title>Restricted</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/restricted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/restricted/</guid><description>Se nos proporciona una instancia remota para conectarnos:
$ nc 64.227.41.83 30543 SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1 Invalid SSH identification string. Ncat: Broken pipe. Parece que debemos acceder a través de SSH.
Conexión por SSH También se nos proporcionan algunos archivos:
$ tree . ├── Dockerfile ├── build_docker.sh └── src ├── bash_profile ├── flag.txt └── sshd_config 2 directories, 5 files Mirando el DockerFile, vemos que hay un usuario llamado restricted y tiene configurado rbash (Bash restringida):</description></item><item><title>Roten</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/roten/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/roten/</guid><description>Se nos proporciona un archivo PCAP (challenge.pcap) con muchos paquetes de red:
Encontrando el vector de ataque En primer lugar, filtremos por HTTP para leer solo paquetes de red de alto nivel:
El atacante está hurgando con el sitio web. Por ejemplo, está tratando de usar parámetros POST:
Si vamos al final de la captura de paquetes, veremos que los atacantes consiguen ejecutar comandos de sistema:
En el comando ls anterior, vemos un archivo llamado galacticmap.</description></item><item><title>Small StEps</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/small-steps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/small-steps/</guid><description>Se nos proporciona una instancia remota para conectarnos:
$ nc 188.166.152.84 32213 This is the second level of training. [E]ncrypt the flag. [A]bort training. &amp;gt; También se nos proporciona el código fuente de Python del servidor:
from Crypto.Util.number import getPrime, bytes_to_long FLAG = b"HTB{???????????????}" assert len(FLAG) == 20 class RSA: def __init__(self): self.q = getPrime(256) self.p = getPrime(256) self.n = self.q * self.p self.e = 3 def encrypt(self, plaintext): plaintext = bytes_to_long(plaintext) return pow(plaintext, self.</description></item><item><title>Sound of Silence</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/sound-of-silence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/sound-of-silence/</guid><description>Se nos proporciona un binario de 64 bits llamado sound_of_silence:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) También tenemos la librería y cargador de Glibc remoto:
$ glibc/ld-linux-x86-64.so.2 glibc/libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.4) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>SpyBug</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/spybug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/spybug/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente de la aplicación web en Node.js y el código fuente de un agente en Go.
Análisis de código fuente La aplicación web está construida con Express JS. En index.js Podemos ver una cabecera de Content Security Policy (CSP) y una función visitPanel que se ejecuta cada minuto:
application.use((req, res, next) =&amp;gt; { res.setHeader("Content-Security-Policy", "script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';"</description></item><item><title>Testimonial</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/testimonial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/testimonial/</guid><description>Se nos proporciona el siguiente sitio web:
Además, tenemos un endpoint de gRPC en 94.237.49.166:58578.
También se nos proporciona el código fuente del proyecto en Go.
Análisis del código fuente Este es el archivo principal (main.go):
package main import ( "embed" "htbchal/handler" "htbchal/pb" "log" "net" "net/http" "github.com/go-chi/chi/v5" "google.golang.org/grpc" ) //go:embed public var FS embed.FS func main() { router := chi.NewMux() router.Handle("/*", http.StripPrefix("/", http.FileServer(http.FS(FS)))) router.Get("/", handler.MakeHandler(handler.HandleHomeIndex)) go startGRPC() log.Fatal(http.ListenAndServe(":1337", router)) } type server struct { pb.</description></item><item><title>TrapTrack</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/traptrack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/traptrack/</guid><description>Se nos proporciona una página web como esta:
También tenemos el código fuente del proyecto.
Funcionalidad del sitio web La aplicación web nos permite ingresar una URL que se almacenará en una base de datos SQLite. Al leer el código de challenge/application/config.py encontramos credenciales válidas (admin:admin):
from application.util import generate import os class Config(object): SECRET_KEY = generate(50) ADMIN_USERNAME = 'admin' ADMIN_PASSWORD = 'admin' SESSION_PERMANENT = False SESSION_TYPE = 'filesystem' SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/database.</description></item><item><title>Tsayaki</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/tsayaki/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/tsayaki/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from tea import Cipher as TEA from secret import IV, FLAG import os ROUNDS = 10 def show_menu(): print(""" ============================================================================================ || I made this decryption oracle in which I let users choose their own decryption keys. || || I think that it's secure as the tea cipher doesn't produce collisions (?) ... Right? || || If you manage to prove me wrong 10 times, you get a special gift.</description></item><item><title>Void</title><link>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/void/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/htb-cyber-apocalypse/void/</guid><description>Se nos proporciona un binario de 64 bits llamado void:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Si usamos Ghidra, encontraremos este código descompilado en C:
void vuln() { char data[64]; read(0, data, 200); } int main() { vuln(); return 0; } El código es muy corto y solo hay un solo punto para ingresar datos.
Vulnerabilidad de Buffer Overflow Hay una clara vulnerabilidad de Buffer Overflow ya que data es un vector de char de 64 bytes, y read está leyendo hasta 200 bytes y almacena la información en data.</description></item></channel></rss>