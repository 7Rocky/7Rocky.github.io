<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SekaiCTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/sekaictf/</link><description>Recent content in SekaiCTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/sekaictf/index.xml" rel="self" type="application/rss+xml"/><item><title>cryptoGRAPHy (1, 2, 3)</title><link>https://7rocky.github.io/ctf/other/sekaictf/cryptography-1-2-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/cryptography-1-2-3/</guid><description>Esta serie de retos está contextualizada en la teoría de grafos combinada con la criptografía. El autor implementó una librería de Python usando networkx para manejar grafos y funciones criptográficas como el cifrado AES, HMAC o el hash SHA256.
Estos retos fueron algo polémicos debido a que los jugadores necesitaban leer, analizar y comprender la librería implementada para el esquema de cifrado de grafos (Graph Encryption Scheme) y luego buscar una solución para el reto correspondiente.</description></item><item><title>Noisy CRC</title><link>https://7rocky.github.io/ctf/other/sekaictf/noisy-crc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/noisy-crc/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import secrets from Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 from flag import FLAG def getCRC16(msg, gen_poly): assert (1 &amp;lt;&amp;lt; 16) &amp;lt;= gen_poly &amp;lt; (1 &amp;lt;&amp;lt; 17) # check if deg = 16 msglen = msg.bit_length() msg &amp;lt;&amp;lt;= 16 for i in range(msglen - 1, -1, -1): if (msg &amp;gt;&amp;gt; (i + 16)) &amp;amp; 1: msg ^= (gen_poly &amp;lt;&amp;lt; i) return msg def oracle(secret, gen_poly): res = [secrets.</description></item><item><title>Play to Earn</title><link>https://7rocky.github.io/ctf/other/sekaictf/play-to-earn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/play-to-earn/</guid><description>Se nos proporciona un Smart Contract llamado ArcadeMachine.sol:
pragma solidity 0.8.25; import { Coin } from "./Coin.sol"; contract ArcadeMachine { Coin coin; constructor(Coin _coin) { coin = _coin; } function play(uint256 times) external { // burn the coins require(coin.transferFrom(msg.sender, address(0), 1 ether * times)); // Have fun XD } } Y otro Smart Contract llamado Coin.sol:
pragma solidity 0.8.25; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/utils/cryptography/EIP712.sol"; contract Coin is Ownable, EIP712 { string public constant name = "</description></item><item><title>speedpwn</title><link>https://7rocky.github.io/ctf/other/sekaictf/speedpwn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/speedpwn/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No Análisis del código fuente Esta vez, tenemos el código fuente completo en C:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; unsigned long long number_of_games; unsigned long long game_history; unsigned long long seed; FILE* seed_generator; int cmp(unsigned long long a, unsigned long long b) { if (__builtin_popcountll(a) !</description></item><item><title>はやぶさ</title><link>https://7rocky.github.io/ctf/other/sekaictf/%E3%81%AF%E3%82%84%E3%81%B6%E3%81%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/%E3%81%AF%E3%82%84%E3%81%B6%E3%81%95/</guid><description>Se nos proporciona un script en Python llamado chall.py:
from falcon import falcon from flag import flag from timeout_decorator import timeout @timeout(30) def main(): sk = falcon.SecretKey(64) pk = falcon.PublicKey(sk) print(pk) your_sig = bytes.fromhex(input("what is your sig? &amp;gt;")) if pk.verify(b"Can you break me", your_sig): print("well done!!") print(flag) exit() print("Broken your wing T_T") main() Y también tenemos un script de shell llamado up.sh:
git clone https://github.com/tprest/falcon.py.git mv falcon.py falcon echo "import os import sys sys.</description></item><item><title>マスタースパーク</title><link>https://7rocky.github.io/ctf/other/sekaictf/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/sekaictf/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF/</guid><description>Se nos proporciona un script en SageMath llamado challenge.sage:
from Crypto.Util.number import * import os from timeout_decorator import timeout, TimeoutError load("GA.sage") FLAG = os.getenv("FLAG") secret = getPrime(256) choice = set() @timeout(60) def T_T(p, primes, secret): assert isPrime(p) assert len(primes) &amp;gt; 3 Fp = GF(p) Fp2.&amp;lt;j&amp;gt; = GF(p ^ 2, modulus=x ^ 2 + 1) ls = len(factor(p + 1)) - 2 m = ceil((sqrt(p) ** (1 / ls) - 1) / 2) alice_priv = [randrange(-m, m + 1) for _ in range(len(primes))] bob_priv = [randrange(-m, m + 1) for _ in range(len(primes))] EC = montgomery(Fp2, 0) P = EC.</description></item></channel></rss>