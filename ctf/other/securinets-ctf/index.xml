<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Securinets CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/securinets-ctf/</link><description>Recent content in Securinets CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/securinets-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Farfour Post Quantom</title><link>https://7rocky.github.io/ctf/other/securinets-ctf/farfour-post-quantom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/securinets-ctf/farfour-post-quantom/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import hashlib from os import urandom from random import SystemRandom from sympy import GF from sympy.polys.matrices import DomainMatrix import json from hashlib import md5 random=SystemRandom() shuffle=random.shuffle randint=random.randint randrange=random.randrange uniform = lambda: randrange(257//2) - 257//2 P=GF(257) secret=open("Secret.txt",'rb').read() assert len(secret)==16 flag=open("flag.txt","rb").read() def encrypt_flag(secret): key = hashlib.sha256(secret).digest()[-16:] iv = urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) enc_flag=cipher.</description></item><item><title>PolyLCG</title><link>https://7rocky.github.io/ctf/other/securinets-ctf/polylcg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/securinets-ctf/polylcg/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from random import randint xcoeff=[2220881165502059873403292638352563283672047788097000474246472547036149880673794935190953317495413822516051735501183996484673938426874803787946897055911986,3780868071235160215367199770952656972709510983146503211692869296836254519620768737356081836837102329626660962468333562050121427935761471039362287802941597,4902413424318450578332022710023815992030030940432088134156375736636296016273860394626141407089100644225364129305706233708267009976783719598126300552264686] ycoeff=[10133630993576627916260025550504106878405253409844193620608338129978685236278362029266353690006955194818074387390350472504283291952199370441443295790407675,3364000239596805500788439152587586988694473612770420810400457954622820421525205173981972752548906690775960238564395459369815397933405749174182967563999094, 5184466564604150683447715719961919989718796968566745874607480183961791804239357212974694797397047787503590843234526492414458478882622032364603797888695699] p=10369539704979520345376943788090457296701518777268113122376443474930073612795297691185597789473973789467303121639140064504782927997022419913721978857764263 class LCG: def __init__(self,p,xcoeffs,ycoeffs): self.p=p self.xcoeffs=xcoeffs self.ycoeffs=ycoeffs self.xstate =randint(1,p-1) self.ystate =randint(1,p-1) for i in range(randint(1,1337)): self.next() def next(self): self.xstate=pow(self.xcoeffs[0]+self.xcoeffs[1]*self.xstate+self.xcoeffs[2]*self.xstate**2,1,self.p) self.ystate=pow(self.ycoeffs[0]+self.ycoeffs[1]*self.ystate+self.ycoeffs[2]*self.ystate**2,1,self.p) def encrypt(self,msg): bin_msg=list(map(int, list(f"{msg:0512b}"))) encrypted=[] for i in bin_msg: self.next() if i==1: encrypted.append(self.xstate) else: encrypted.append(self.ystate) return encrypted flag=b"Securinets{???????????????????????????????????????}" flag=int.from_bytes(flag,"big") lcgCipher=LCG(p,xcoeff,ycoeff) encrypted_flag=lcgCipher.encrypt(flag) print("encrypted_flag=",encrypted_flag) Además, tenemos la salida del programa como output.txt:</description></item><item><title>scrambler</title><link>https://7rocky.github.io/ctf/other/securinets-ctf/scrambler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/securinets-ctf/scrambler/</guid><description>Se nos proporciona un binario de 64 bits llamado scrambler:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) También tenemos el binario de Glibc (libc.so_1.6) de la instancia remota, por lo que podemos usar pwninit para parchear el binario y usar esta librería, de manera que el exploit sea igual en local y en remoto:
$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.</description></item></channel></rss>