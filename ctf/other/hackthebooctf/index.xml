<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HackTheBoo CTF on 7Rocky</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/</link><description>Recent content in HackTheBoo CTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/hackthebooctf/index.xml" rel="self" type="application/rss+xml"/><item><title>AHS512</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/ahs512/</guid><description>Se nos proporciona el código fuente en Python del servidor:
fromsecretimportFLAG fromhashlibimportsha512 importsocketserver importsignal fromrandomimportrandint WELCOME=""" **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** """ classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.</description></item><item><title>Cult Meeting</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</guid><description>Se nos proporciona un archivo binario llamado meeting:
$ file meeting meeting: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=72d8b06e4ca750d5c24395d3349c3121b9b95283, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Usando Ghidra, podemos leer el código descompilado en C. Esta es la función main:
intmain() { intret; char*pointer; charinput_data[64]; setvbuf(stdout, NULL, 2, 0); puts("\x1b[3mYou knock on the door and a panel slides back\x1b[0m"); puts(&amp;amp;DAT_00102040); fwrite("\"What is the password for this week\'s meeting?</description></item><item><title>EncodedPayload</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/encodedpayload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/encodedpayload/</guid><description>Se nos proporciona un archivo binario llamado encodedpayload:
$ file encodedpayload encodedpayload: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, no section header Ingeniería inversa Si lo ejecutamos, no aparece nada. Por otro lado, el binario es muy corto:
$ ./encodedpayload $ xxd encodedpayload 00000000: 7f45 4c46 0101 0100 0000 0000 0000 0000 .ELF............ 00000010: 0200 0300 0100 0000 5480 0408 3400 0000 ........T...4... 00000020: 0000 0000 0000 0000 3400 2000 0100 0000 .</description></item><item><title>Entity</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/entity/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si nos conectamos a la instancia remota, vemos lo siguiente:
$ nc 134.122.106.203 30576 Something strange is coming out of the TV.. (T)ry to turn it off (R)un (C)ry &amp;gt;&amp;gt; Nada explicativo&amp;hellip;
Análisis de código estático Esta vez, se nos proporciona también el código fuente original (chall.</description></item><item><title>Evaluation Deck</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</guid><description>Se nos proporciona la siguiente página web:
No obstante, la interfaz no es interesante&amp;hellip;
Análisis de código estático También disponemos del código fuente. La aplicación web está construida en Flask (Python). El siguiente archivo es application/blueprints/routes.py:
fromflaskimportBlueprint, render_template, request fromapplication.utilimportresponse web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/get_health', methods=['POST']) defcount(): ifnotrequest.is_json: returnresponse('Invalid JSON!'), 400 data=request.get_json() current_health=data.get('current_health') attack_power=data.get('attack_power') operator=data.get('operator') ifnotcurrent_healthornotattack_powerornotoperator: returnresponse('All fields are required!'), 400 result={} try: code=compile(f'result = {int(current_health)}{operator}{int(attack_power)}', '&amp;lt;string&amp;gt;', 'exec') exec(code, result) returnresponse(result.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</guid><description>Se nos proporciona el código fuente en Python del servidor:
fromsecretimportFLAG fromCrypto.Util.numberimportisPrime importsocketserver importsignal classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defgenerate_basis(n): basis=[True] *n foriinrange(3, int(n**0.5) +1, 2): ifbasis[i]: basis[i*i::2*i] =[False] *((n-i*i-1) //(2*i) +1) return[2] +[iforiinrange(3, n, 2) ifbasis[i]] defmillerRabin(n, b): basis=generate_basis(300) ifn==2orn==3: returnTrue ifn%2==0: returnFalse r, s=0, n-1 whiles%2==0: r+=1 s//=2 forbinbasis: x=pow(b, s, n) ifx==1orx==n-1: continue for_inrange(r-1): x=pow(x, 2, n) ifx==n-1: break else: returnFalse returnTrue def_isPrime(p): ifp&amp;lt;1: returnFalse if(p.</description></item><item><title>Ghost Wrangler</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/ghost-wrangler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/ghost-wrangler/</guid><description>Se nos proporciona un binario llamado ghost:
$ file ghost ghost: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=810d0f9271ec04d80a2eee6ff2afd9367da3c3dd, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Si lo abrimos en Ghidra, veremos el código en C descompilado de la función main:
intmain() { undefined8 flag; flag =get_flag(); printf("%s\r|\x1b[4m%*.c\x1b[24m| I\'ve managed to trap the flag ghost in this box, butit\'s turn ed invisible!\nCan you figure out how to reveal them?</description></item><item><title>Gonna-Lift-Them-All</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
fromCrypto.Util.numberimportbytes_to_long, getPrime importrandom FLAG=b'HTB{??????????????????????????????????????????????????????????????????????}' defgen_params(): p=getPrime(1024) g=random.randint(2, p-2) x=random.randint(2, p-2) h=pow(g, x, p) return(p, g, h), x defencrypt(pubkey): p, g, h=pubkey m=bytes_to_long(FLAG) y=random.randint(2, p-2) s=pow(h, y, p) return(g*y%p, m*s%p) defmain(): pubkey, privkey=gen_params() c1, c2=encrypt(pubkey) withopen('data.txt', 'w') asf: f.write(f'p = {pubkey[0]}\ng = {pubkey[1]}\nh = {pubkey[2]}\n(c1, c2) = ({c1}, {c2})\n') if__name__=="__main__": main() También tenemos la salida del script:
p = 163096280281091423983210248406915712517889481034858950909290409636473708049935881617682030048346215988640991054059665720267702269812372029514413149200077540372286640767440712609200928109053348791072129620291461211782445376287196340880230151621619967077864403170491990385250500736122995129377670743204192511487 g = 90013867415033815546788865683138787340981114779795027049849106735163065530238112558925433950669257882773719245540328122774485318132233380232659378189294454934415433502907419484904868579770055146403383222584313613545633012035801235443658074554570316320175379613006002500159040573384221472749392328180810282909 h = 36126929766421201592898598390796462047092189488294899467611358820068759559145016809953567417997852926385712060056759236355651329519671229503584054092862591820977252929713375230785797177168714290835111838057125364932429350418633983021165325131930984126892231131770259051468531005183584452954169653119524751729 (c1, c2) = (159888401067473505158228981260048538206997685715926404215585294103028971525122709370069002987651820789915955483297339998284909198539884370216675928669717336010990834572641551913464452325312178797916891874885912285079465823124506696494765212303264868663818171793272450116611177713890102083844049242593904824396, 119922107693874734193003422004373653093552019951764644568950336416836757753914623024010126542723403161511430245803749782677240741425557896253881748212849840746908130439957915793292025688133503007044034712413879714604088691748282035315237472061427142978538459398404960344186573668737856258157623070654311038584) Analizando operaciones matemáticas Vamos a expresar los pasos del cifrado en términos matemáticos:</description></item><item><title>Horror Feeds</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/horror-feeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/horror-feeds/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También se nos proporciona el código fuente en Python de la aplicación web, hecha en Flask. Como estamos tratando con un formulario de inicio de sesión, vamos a echar un vistazo a cómo se interactúa con la base de datos (application/database.py):
fromcoloramaimportCursor fromapplication.utilimportgenerate_password_hash, verify_hash, generate_token fromflask_mysqldb importMySQL mysql=MySQL() defquery_db(query, args=(), one=False): withopen('/tmp/log', 'a') asf: f.write(query+'\n') cursor=mysql.connection.cursor() cursor.execute(query, args) rv=[dict((cursor.description[idx][0], value) foridx, valueinenumerate(row)) forrowincursor.</description></item><item><title>Juggling Facts</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/juggling-facts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/juggling-facts/</guid><description>Se nos proporciona la siguiente página web:
Análisis de código estático También nos dan el código PHP de la aplicación web. La parte importante está en controllers/IndexController.php:
&amp;lt;?php classIndexControllerextendsController { publicfunction__construct() { parent::__construct(); } publicfunctionindex($router) { $router-&amp;gt;view('index'); } publicfunctiongetfacts($router) { $jsondata =json_decode(file_get_contents('php://input'), true); if( empty($jsondata) ||!array_key_exists('type', $jsondata)) { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Insufficient parameters!']); } if($jsondata['type'] ==='secrets'&amp;amp;&amp;amp;$_SERVER['REMOTE_ADDR'] !=='127.0.0.1') { return$router-&amp;gt;jsonify(['message'=&amp;gt;'Currently this type can be only accessed through localhost!']); } switch($jsondata['type']) { case'secrets': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('secrets') ]); case'spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('spooky') ]); case'not_spooky': return$router-&amp;gt;jsonify([ 'facts'=&amp;gt;$this-&amp;gt;facts-&amp;gt;get_facts('not_spooky') ]); default: return$router-&amp;gt;jsonify([ 'message'=&amp;gt;'Invalid type!</description></item><item><title>Pumpkin Stand</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/pumpkin-stand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/pumpkin-stand/</guid><description>Se nos proporciona un binario de 64 bits llamado pumpkin_stand:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si abrimos el binario en Ghidra, veremos el código descompilado en C de la función main:
voidmain() { longin_FS_OFFSET; shortoption; shortamount; FILE *fp; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); setup(); banner(); option =0; amount =0; while(true) { while(true) { while(true) { while(true) { menu(); __isoc99_scanf("</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/secured-transfer/</guid><description>Se nos proporciona un archivo binario llamado securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped También tenemos un archivo de captura de red llamado trace.pcap.
Análisis de tráfico Comenzando por trace.pcap, podemos usar Wireshark para analizar la captura de red:
Solamente hay un segmento TCP que contiene datos:
5f558867993dccc99879f7ca39c5e406972f84a3a9dd5d48972421ff375cb18c Ingeniería inversa Podemos usar Ghidra para leer el código descompilado en C.</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
fromCrypto.Util.numberimportbytes_to_long, getStrongPrime fromrandomimportrandint FLAG=b'HTB{????????????????????????????????????????????}' defkey_gen(bits): p, q=getStrongPrime(bits), getStrongPrime(bits) N=p*q returnN, (p, q) defencrypt(m, N, f): e1, e2=randint(2, N-2), randint(2, N-2) c1=(pow(f, e1, N) +m) %N c2=(pow(f, e2, N) +m) %N return(e1, c1), (e2, c2) defmain(): N, priv=key_gen(1024) m=bytes_to_long(FLAG) (e1, c1), (e2, c2) =encrypt(m, N, priv[0]) withopen('out.txt', 'w') asf: f.write(f'N = {N}\n(e1, c1) = ({e1}, {c1})\n(e2, c2) = ({e2}, {c2})\n') if__name__=="</description></item><item><title>Trick or Breach</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/trick-or-breach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/trick-or-breach/</guid><description>Se nos proporciona un archivo con una captura de tráfico de red llamado capture.pcap:
Análisis de tráfico Podemos usar Wireshark para analizarlo:
Consultas DNS Todos los paquetes corresponden a consultas DNS (y respuestas). Lo que destaca es el subdominio: todas las consultas preguntan por hex-data.pumpkincorp.com.
Si filtramos por los datos hexadecimales en el archivo capture.pcap, tenemos lo siguiente:
$ strings capture.pcap | grep -E '[0-9a-f]{32,}' | head 2504b0304140008080800a52c47550000000000000000000000 2504b0304140008080800a52c47550000000000000000000000 20018000000786c2f64726177696e67732f64726177696e6731 20018000000786c2f64726177696e67732f64726177696e6731 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f Nótese que todas las líneas empiezan por 2, que no es parte del subdominio (se comprueba en la imagen anterior), por lo que tenemos que quitarlo:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/whole-lotta-candy/</guid><description>Se nos proporciona el código fuente en Python del servidor:
fromencryptimportEncryptor fromsecretimportFLAG importsocketserver importrandom importsignal importjson MODES=['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defmain(s): mode=random.choice(MODES) enc=Encryptor() whileTrue: try: sendMessage(s, f"Please interact with the server using json data!\n") sendMessage(s, f"Selected mode is {mode}.\n") payload=receiveMessage( s, "\nOptions:\n\n1.Encrypt flag\n2.Encrypt plaintext\n3.Change mode\n4.Exit\n\n&amp;gt; " ) payload=json.loads(payload) option=payload["option"] ifoption=="1": ciphertext=enc.encrypt(FLAG, mode).hex() response=json.dumps({ "response": "</description></item><item><title>Wrong Spooky Season</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/wrong-spooky-season/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/wrong-spooky-season/</guid><description>Se nos proporciona un archivo con una captura de tráfico de red llamado capture.pcap:
Análisis de tráfico Podemos usar Wireshark para analizarlo:
Mensajes HTTP Hay un montón de paquetes. Vamos a filtrar primero por HTTP:
Vale, ahora hay muchos menos paquetes para analizar.
Existen algunos mensajes HTTP que destacan al final. Podemos pensar que un usuario malintencionado está ejecutando comandos de sistema en el servidor de forma remota (cmd=whoami, cmd=id &amp;hellip;).</description></item></channel></rss>