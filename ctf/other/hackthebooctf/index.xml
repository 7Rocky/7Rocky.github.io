<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HackTheBoo CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/</link><description>Recent content in HackTheBoo CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/hackthebooctf/index.xml" rel="self" type="application/rss+xml"/><item><title>AHS512</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/ahs512/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from hashlib import sha512 import socketserver import signal from random import randint WELCOME = """ **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** "</description></item><item><title>Cult Meeting</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</guid><description>Se nos proporciona un archivo binario llamado meeting:
$ file meeting meeting: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=72d8b06e4ca750d5c24395d3349c3121b9b95283, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Usando Ghidra, podemos leer el código descompilado en C. Esta es la función main:
int main() { int ret; char *pointer; char input_data[64]; setvbuf(stdout, NULL, 2, 0); puts("\x1b[3mYou knock on the door and a panel slides back\x1b[0m"); puts(&amp;amp;DAT_00102040); fwrite("</description></item><item><title>Cursed Secret Party</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/cursed-secret-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/cursed-secret-party/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También tenemos el código fuente en JavaScript de la aplicación web, hecha en Node.js con Express JS. Este archivo es routes/index.js:
const express = require('express'); const router = express.Router({ caseSensitive: true }); const AuthMiddleware = require('../middleware/AuthMiddleware'); const bot = require('../bot'); let db; const response = data =&amp;gt; ({ message: data }); router.get('/', (req, res) =&amp;gt; { return res.render('index.html'); }); router.post('/api/submit', (req, res) =&amp;gt; { const { halloween_name, email, costume_type, trick_or_treat } = req.</description></item><item><title>Downgrade</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/downgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/downgrade/</guid><description>Se nos proporcionan un montón de logs de Eventos de Windows (archivos .evtx):
$ tree Logs Logs ├── Application.evtx ├── HardwareEvents.evtx ├── Internet Explorer.evtx ├── Key Management Service.evtx ├── Microsoft-Windows-AppModel-Runtime%4Admin.evtx ├── Microsoft-Windows-AppReadiness%4Admin.evtx ├── Microsoft-Windows-AppReadiness%4Operational.evtx ├── Microsoft-Windows-AppXDeployment%4Operational.evtx ├── Microsoft-Windows-AppXDeploymentServer%4Operational.evtx ├── Microsoft-Windows-AppXDeploymentServer%4Restricted.evtx ├── Microsoft-Windows-ApplicationResourceManagementSystem%4Operational.evtx ├── Microsoft-Windows-Bits-Client%4Operational.evtx ├── Microsoft-Windows-CodeIntegrity%4Operational.evtx ├── Microsoft-Windows-Compat-Appraiser%4Operational.evtx ├── Microsoft-Windows-CoreApplication%4Operational.evtx ├── Microsoft-Windows-Crypto-DPAPI%4BackUpKeySvc.evtx ├── Microsoft-Windows-Crypto-DPAPI%4Operational.evtx ├── Microsoft-Windows-DSC%4Admin.evtx ├── Microsoft-Windows-DSC%4Operational.evtx ├── Microsoft-Windows-DataIntegrityScan%4Admin.evtx ├── Microsoft-Windows-DataIntegrityScan%4CrashRecovery.evtx ├── Microsoft-Windows-DeviceSetupManager%4Admin.evtx ├── Microsoft-Windows-DeviceSetupManager%4Operational.evtx ├── Microsoft-Windows-Dhcp-Client%4Admin.evtx ├── Microsoft-Windows-Dhcpv6-Client%4Admin.evtx ├── Microsoft-Windows-Diagnosis-DPS%4Operational.</description></item><item><title>EncodedPayload</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/encodedpayload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/encodedpayload/</guid><description>Se nos proporciona un archivo binario llamado encodedpayload:
$ file encodedpayload encodedpayload: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, no section header Ingeniería inversa Si lo ejecutamos, no aparece nada. Por otro lado, el binario es muy corto:
$ ./encodedpayload $ xxd encodedpayload 00000000: 7f45 4c46 0101 0100 0000 0000 0000 0000 .ELF............ 00000010: 0200 0300 0100 0000 5480 0408 3400 0000 ........T...4... 00000020: 0000 0000 0000 0000 3400 2000 0100 0000 .</description></item><item><title>Entity</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/entity/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si nos conectamos a la instancia remota, vemos lo siguiente:
$ nc 134.122.106.203 30576 Something strange is coming out of the TV.. (T)ry to turn it off (R)un (C)ry &amp;gt;&amp;gt; Nada explicativo&amp;hellip;
Análisis de código estático Esta vez, se nos proporciona también el código fuente original (chall.</description></item><item><title>Evaluation Deck</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</guid><description>Se nos proporciona la siguiente página web:
No obstante, la interfaz no es interesante&amp;hellip;
Análisis de código estático También disponemos del código fuente. La aplicación web está construida en Flask (Python). El siguiente archivo es application/blueprints/routes.py:
from flask import Blueprint, render_template, request from application.util import response web = Blueprint('web', __name__) api = Blueprint('api', __name__) @web.route('/') def index(): return render_template('index.html') @api.route('/get_health', methods=['POST']) def count(): if not request.is_json: return response('Invalid JSON!'), 400 data = request.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p &amp;lt; 1: return False if (p.</description></item><item><title>Finale</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/finale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/finale/</guid><description>Se nos proporciona un binario de 64 bits llamado finale:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Configuración del entorno Puede ocurrir que no tengamos la versión de Glibc que acepta el programa:
$ ./finale ./finale: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./finale) Por suerte, en Spooky Time nos dan una librería y un loader, versión 2.35:
$ ../pwn_spooky_time/glibc/ld-linux-x86-64.so.2 ../pwn_spooky_time/glibc/libc.so.6 GNU C Library (Ubuntu GLIBC 2.</description></item><item><title>Ghost Wrangler</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/ghost-wrangler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/ghost-wrangler/</guid><description>Se nos proporciona un binario llamado ghost:
$ file ghost ghost: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=810d0f9271ec04d80a2eee6ff2afd9367da3c3dd, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Si lo abrimos en Ghidra, veremos el código en C descompilado de la función main:
int main() { undefined8 flag; flag = get_flag(); printf("%s\r|\x1b[4m%*.c\x1b[24m| I\'ve managed to trap the flag ghost in this box, but it\'s turn ed invisible!</description></item><item><title>Gonna-Lift-Them-All</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getPrime import random FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}' def gen_params(): p = getPrime(1024) g = random.randint(2, p-2) x = random.randint(2, p-2) h = pow(g, x, p) return (p, g, h), x def encrypt(pubkey): p, g, h = pubkey m = bytes_to_long(FLAG) y = random.randint(2, p-2) s = pow(h, y, p) return (g * y % p, m * s % p) def main(): pubkey, privkey = gen_params() c1, c2 = encrypt(pubkey) with open('data.</description></item><item><title>Halloween Invitation</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/halloween-invitation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/halloween-invitation/</guid><description>Se nos proporciona un archivo ZIP que contiene un fichero llamado invitation.docm:
$ unzip -l forensics_halloween_invitation.zip Archive: forensics_halloween_invitation.zip Length Date Time Name --------- ---------- ----- ---- 5252634 10-12-2022 08:04 invitation.docm --------- ------- 5252634 1 file $ unzip forensics_halloween_invitation.zip Archive: forensics_halloween_invitation.zip inflating: invitation.docm $ file invitation.docm invitation.docm: Microsoft Word 2007+ Extracción de macros VBA Esto significa que tenemos un documento de Microsoft Word con macros VBA. En lugar de abrir Microsoft Word, podemos usar olevba de oletools para extraer el código VBA:</description></item><item><title>Horror Feeds</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/horror-feeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/horror-feeds/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También se nos proporciona el código fuente en Python de la aplicación web, hecha en Flask. Como estamos tratando con un formulario de inicio de sesión, vamos a echar un vistazo a cómo se interactúa con la base de datos (application/database.py):
from colorama import Cursor from application.util import generate_password_hash, verify_hash, generate_token from flask_mysqldb import MySQL mysql = MySQL() def query_db(query, args=(), one=False): with open('/tmp/log', 'a') as f: f.</description></item><item><title>Juggling Facts</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/juggling-facts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/juggling-facts/</guid><description>Se nos proporciona la siguiente página web:
Análisis de código estático También nos dan el código PHP de la aplicación web. La parte importante está en controllers/IndexController.php:
&amp;lt;?php class IndexController extends Controller { public function __construct() { parent::__construct(); } public function index($router) { $router-&amp;gt;view('index'); } public function getfacts($router) { $jsondata = json_decode(file_get_contents('php://input'), true); if ( empty($jsondata) || !array_key_exists('type', $jsondata)) { return $router-&amp;gt;jsonify(['message' =&amp;gt; 'Insufficient parameters!']); } if ($jsondata['type'] === 'secrets' &amp;amp;&amp;amp; $_SERVER['REMOTE_ADDR'] !</description></item><item><title>Ouija</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/ouija/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/ouija/</guid><description>Se nos proporciona un binario llamado ouija:
$ file ouija ouija: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2cace162c306a34dcfc4837d648d047e2ea339fe, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Si lo abrimos en Ghidra, veremos el código en C descompilado de la función main:
int main() { int key_copy; int r; int m; int o; int n; int q; int p; int l; char *enc_flag; int k; int j; int i; setvbuf(stdout, NULL, 2, 0); enc_flag = strdup("</description></item><item><title>POOF</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/poof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/poof/</guid><description>Se nos proporcionan algunos archivos:
$ unzip -l forensics_poof.zip Archive: forensics_poof.zip Length Date Time Name ---------- ---------- ----- ---- 2567089 10-20-2022 11:12 candy_dungeon.pdf.boo 1096901984 10-20-2022 18:11 mem.dmp 7839830 10-20-2022 11:25 poof_capture.pcap 1126698 10-20-2022 12:04 Ubuntu_4.15.0-184-generic_profile.zip ---------- ------- 1108435601 4 files Y tenemos una instancia remota a la que conectarnos para responder a algunas preguntas:
$ nc 159.65.48.79 31240 +-------+-----------------------------------------------------+ | Title | Description | +-------+-----------------------------------------------------+ | POOF | In my company, we are developing a | | | new python game for Halloween.</description></item><item><title>Pumpkin Stand</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/pumpkin-stand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/pumpkin-stand/</guid><description>Se nos proporciona un binario de 64 bits llamado pumpkin_stand:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si abrimos el binario en Ghidra, veremos el código descompilado en C de la función main:
void main() { long in_FS_OFFSET; short option; short amount; FILE *fp; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 canary; canary = *(undefined8 *) (in_FS_OFFSET + 0x28); setup(); banner(); option = 0; amount = 0; while (true) { while (true) { while (true) { while (true) { menu(); __isoc99_scanf("</description></item><item><title>Pumpking</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/pumpking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/pumpking/</guid><description>Se nos proporciona un binario de 64 bits llamado pumpking:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Configuración del entorno Puede ocurrir que no tengamos la versión de Glibc que acepta el programa:
$ ./pumpking zsh: no such file or directory: ./pumpking $ ldd pumpking ./pumpking: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./pumpking) linux-vdso.so.1 (0x00007ffc78fd6000) libseccomp.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f16439e4000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/secured-transfer/</guid><description>Se nos proporciona un archivo binario llamado securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped También tenemos un archivo de captura de red llamado trace.pcap.
Análisis de tráfico Comenzando por trace.pcap, podemos usar Wireshark para analizar la captura de red:
Solamente hay un segmento TCP que contiene datos:
5f558867993dccc99879f7ca39c5e406972f84a3a9dd5d48972421ff375cb18c Ingeniería inversa Podemos usar Ghidra para leer el código descompilado en C.</description></item><item><title>Spookifier</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/spookifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/spookifier/</guid><description>Se nos proporciona esta página web:
Podemos introducir un texto cualquiera y será mostrado en diferentes fuentes:
Análisis de código estático Tenemos el código fuente en Python de la aplicación web, hecha con Flask. Este archivo es application/blueprints/routes.py:
from flask import Blueprint, request from flask_mako import render_template from application.util import spookify web = Blueprint('web', __name__) @web.route('/') def index(): text = request.args.get('text') if text: converted = spookify(text) return render_template('index.html', output=converted) return render_template('index.</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b'HTB{????????????????????????????????????????????}' def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open('out.</description></item><item><title>Spooky Time</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-time/</guid><description>Se nos proporciona un binario de 64 bits llamado spooky_time:
Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si lo abrimos en Ghidra, veremos esta función main:
void main() { long in_FS_OFFSET; char first_input[12]; char second_input[312]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setup(); banner(); puts("It\'s your chance to scare those little kids, say something scary!\n"); __isoc99_scanf("%11s", first_input); puts("</description></item><item><title>Trick or Breach</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/trick-or-breach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/trick-or-breach/</guid><description>Se nos proporciona un archivo con una captura de tráfico de red llamado capture.pcap:
Análisis de tráfico Podemos usar Wireshark para analizarlo:
Consultas DNS Todos los paquetes corresponden a consultas DNS (y respuestas). Lo que destaca es el subdominio: todas las consultas preguntan por hex-data.pumpkincorp.com.
Si filtramos por los datos hexadecimales en el archivo capture.pcap, tenemos lo siguiente:
$ strings capture.pcap | grep -E '[0-9a-f]{32,}' | head 2504b0304140008080800a52c47550000000000000000000000 2504b0304140008080800a52c47550000000000000000000000 20018000000786c2f64726177696e67732f64726177696e6731 20018000000786c2f64726177696e67732f64726177696e6731 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 22e786d6c9dd05d6ec2300c07f013ec0e55de695a181343145e 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2d04e300ee0256e1b918fca0ea3dc7ed14a36697b011e6dcb3f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f 2f9efcd6e74b6f84462137c23eab212057a15b4f15d230eef6f Nótese que todas las líneas empiezan por 2, que no es parte del subdominio (se comprueba en la imagen anterior), por lo que tenemos que quitarlo:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/whole-lotta-candy/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from encrypt import Encryptor from secret import FLAG import socketserver import random import signal import json MODES = ['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def main(s): mode = random.choice(MODES) enc = Encryptor() while True: try: sendMessage(s, f"Please interact with the server using json data!</description></item><item><title>Wrong Spooky Season</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/wrong-spooky-season/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/wrong-spooky-season/</guid><description>Se nos proporciona un archivo con una captura de tráfico de red llamado capture.pcap:
Análisis de tráfico Podemos usar Wireshark para analizarlo:
Mensajes HTTP Hay un montón de paquetes. Vamos a filtrar primero por HTTP:
Vale, ahora hay muchos menos paquetes para analizar.
Existen algunos mensajes HTTP que destacan al final. Podemos pensar que un usuario malintencionado está ejecutando comandos de sistema en el servidor de forma remota (cmd=whoami, cmd=id &amp;hellip;).</description></item></channel></rss>