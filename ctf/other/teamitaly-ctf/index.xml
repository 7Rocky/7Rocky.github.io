<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TeamItaly CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/teamitaly-ctf/</link><description>Recent content in TeamItaly CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/teamitaly-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Big RSA</title><link>https://7rocky.github.io/ctf/other/teamitaly-ctf/big-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/teamitaly-ctf/big-rsa/</guid><description>Se nos proporciona el c√≥digo fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, getStrongPrime, bytes_to_long from sympy import factorial from random import randint from secret import flag p, q = getStrongPrime(1024), getStrongPrime(1024) def RSAgen(e = None): d = 0 if not e: while(d.bit_length() &amp;lt; 2047): e = getPrime(2047) d = pow(e, -1, (p-1)*(q-1)) else: d = pow(e, -1, (p-1)*(q-1)) return (p*q, p, q, e, d) n = p*q print(f'{n = }') key = RSAgen() k = randint(600, 1200) f = factorial(k) leak = (pow(key[3], 2) + (key[3]*key[4] - 1)*f)*getPrime(256) + k # 2048 bit e is very expensive, i should use standard e for my encryption key = RSAgen(65537) e = key[3] flag = bytes_to_long(flag) c = pow(flag, e, n) print(f"</description></item></channel></rss>