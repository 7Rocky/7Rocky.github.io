<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TeamItaly CTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/other/teamitaly-ctf/</link><description>Recent content in TeamItaly CTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/other/teamitaly-ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Big RSA</title><link>https://7rocky.github.io/ctf/other/teamitaly-ctf/big-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/teamitaly-ctf/big-rsa/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, getStrongPrime, bytes_to_long from sympy import factorial from random import randint from secret import flag p, q = getStrongPrime(1024), getStrongPrime(1024) def RSAgen(e = None): d = 0 if not e: while(d.bit_length() &amp;lt; 2047): e = getPrime(2047) d = pow(e, -1, (p-1)*(q-1)) else: d = pow(e, -1, (p-1)*(q-1)) return (p*q, p, q, e, d) n = p*q print(f'{n = }') key = RSAgen() k = randint(600, 1200) f = factorial(k) leak = (pow(key[3], 2) + (key[3]*key[4] - 1)*f)*getPrime(256) + k # 2048 bit e is very expensive, i should use standard e for my encryption key = RSAgen(65537) e = key[3] flag = bytes_to_long(flag) c = pow(flag, e, n) print(f"</description></item><item><title>Scrambled Pizzeria</title><link>https://7rocky.github.io/ctf/other/teamitaly-ctf/scrambled-pizzeria/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/teamitaly-ctf/scrambled-pizzeria/</guid><description>Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/python3 import numpy as np import numpy.typing as npt from PIL import Image import os def permutation( img: npt.NDArray[np.uint8], c: npt.NDArray[np.uint64] ) -&amp;gt; npt.NDArray[np.uint8]: height, width = img.shape cm = c[np.arange(max(height, width)) % len(c)] rows = np.argsort(cm[:height]) cols = np.argsort(cm[:width]) return img[rows, :][:, cols] def substitution( con: npt.NDArray[np.uint8], c: npt.NDArray[np.uint64] ) -&amp;gt; npt.NDArray[np.uint8]: ids = np.arange(np.prod(con.shape)) % len(c) return con ^ (c % 256).</description></item></channel></rss>