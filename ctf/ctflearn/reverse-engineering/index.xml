<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ingeniería Inversa on 7Rocky</title><link>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/</link><description>Recent content in Ingeniería Inversa on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/ctflearn/reverse-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>PIN</title><link>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/pin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/pin/</guid><description>Se nos proporciona un binario llamado rev1:
$ file rev1 rev1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5f9af621b132c2028d8e689cbb5b707f3f3cd28, not stripped Si lo ejecutamos, el programa espera un PIN:
$ ./rev1 Masukan PIN = 1234 PIN salah ! Vamos a depurarlo con GDB y a mostrar el código ensamblador del main:
$ gdb -q rev1 Reading symbols from rev1... (No debugging symbols found in rev1) gef➤ disassemble main Dump of assembler code for function main: 0x00000000004005d6 &amp;lt;+0&amp;gt;: push rbp 0x00000000004005d7 &amp;lt;+1&amp;gt;: mov rbp,rsp 0x00000000004005da &amp;lt;+4&amp;gt;: sub rsp,0x10 0x00000000004005de &amp;lt;+8&amp;gt;: lea rdi,[rip+0xdf] # 0x4006c4 0x00000000004005e5 &amp;lt;+15&amp;gt;: mov eax,0x0 0x00000000004005ea &amp;lt;+20&amp;gt;: call 0x4004a0 &amp;lt;printf@plt&amp;gt; 0x00000000004005ef &amp;lt;+25&amp;gt;: lea rax,[rbp-0x4] 0x00000000004005f3 &amp;lt;+29&amp;gt;: mov rsi,rax 0x00000000004005f6 &amp;lt;+32&amp;gt;: lea rdi,[rip+0xd6] # 0x4006d3 0x00000000004005fd &amp;lt;+39&amp;gt;: mov eax,0x0 0x0000000000400602 &amp;lt;+44&amp;gt;: call 0x4004b0 &amp;lt;__isoc99_scanf@plt&amp;gt; 0x0000000000400607 &amp;lt;+49&amp;gt;: mov eax,DWORD PTR [rbp-0x4] 0x000000000040060a &amp;lt;+52&amp;gt;: mov edi,eax 0x000000000040060c &amp;lt;+54&amp;gt;: call 0x4005b6 &amp;lt;cek&amp;gt; 0x0000000000400611 &amp;lt;+59&amp;gt;: test eax,eax 0x0000000000400613 &amp;lt;+61&amp;gt;: je 0x400623 &amp;lt;main+77&amp;gt; 0x0000000000400615 &amp;lt;+63&amp;gt;: lea rdi,[rip+0xba] # 0x4006d6 0x000000000040061c &amp;lt;+70&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x0000000000400621 &amp;lt;+75&amp;gt;: jmp 0x40062f &amp;lt;main+89&amp;gt; 0x0000000000400623 &amp;lt;+77&amp;gt;: lea rdi,[rip+0xba] # 0x4006e4 0x000000000040062a &amp;lt;+84&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x000000000040062f &amp;lt;+89&amp;gt;: mov eax,0x0 0x0000000000400634 &amp;lt;+94&amp;gt;: leave 0x0000000000400635 &amp;lt;+95&amp;gt;: ret End of assembler dump.</description></item><item><title>Reykjavik</title><link>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/reykjavik/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/reykjavik/</guid><description>Se nos proporciona un binario de 64 bits llamado Reykjavik:
$ file Reykjavik Reykjavik: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9bc04368dbcefb4491573ac8feea3a32e31ed59f, for GNU/Linux 3.2.0, not stripped Si lo ejecutamos, vemos que necesita un argumento de línea de comandos:
$ ./Reykjavik Usage: Reykjavik CTFlearn{flag} $ ./Reykjavik 'CTFlearn{flag}' Welcome to the CTFlearn Reversing Challenge Reykjavik v2: CTFlearn{flag} Compile Options: ${CMAKE_CXX_FLAGS} -O0 -fno-stack-protector -mno-sse Sorry Dude, 'CTFlearn{flag}' is not the flag :-( Vamos a usar GDB para depurar el programa.</description></item></channel></rss>