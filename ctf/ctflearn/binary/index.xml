<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binarios on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/ctflearn/binary/</link><description>Recent content in Binarios on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/ctflearn/binary/index.xml" rel="self" type="application/rss+xml"/><item><title>Blackbox</title><link>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</guid><description>Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario llamado blackbox que es SGID:
blackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission Como se puede ver, no tenemos permisos de lectura, por lo que no podemos transferir el archivo a nuestra máquina, ni descompilarlo, ni depurarlo.</description></item><item><title>Favorite Color</title><link>https://7rocky.github.io/ctf/ctflearn/binary/favorite-color/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/favorite-color/</guid><description>Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario de 32 bits llamado color que es SGID:
color@ubuntu-512mb-nyc3-01:~$ ls -l total 20 -r--r--r-- 1 root root 714 Sep 12 2017 Makefile -r-xr-sr-x 1 root color_pwn 7672 Sep 12 2017 color -r--r--r-- 1 root root 722 Sep 12 2017 color.c -r--r----- 1 root color_pwn 24 Sep 12 2017 flag.txt color@ubuntu-512mb-nyc3-01:~$ file color color: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>Lazy Game Challenge</title><link>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</guid><description>Se nos proporciona un servicio que consiste en un sistema de apuestas. Tenemos que apostar una cierta cantidad de dinero y luego adivinar un número entre 1 y 10 en menos de 10 intentos. Por ejemplo:
$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of !</description></item><item><title>Poor Login</title><link>https://7rocky.github.io/ctf/ctflearn/binary/poor-login/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/poor-login/</guid><description>Se nos proporciona un binario de 64 bits llamado login:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled También tenemos el código fuente en C:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int menu() { printf("*** WINBLOWS LOGIN *********\n" "1. Login into user.\n" "2. Sign out.\n" "3. Print flag.\n" "4. Lock user.\n" "5. Restore user.\n" "&amp;gt; "); int resp = 0; scanf("%d", &amp;amp;resp); while (getchar() !</description></item><item><title>RIP my bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</guid><description>Se nos proporciona un binario de 32 bits llamado server:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) También tenemos el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets, que es vulnerable a Buffer Overflow:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system("</description></item><item><title>Shell time!</title><link>https://7rocky.github.io/ctf/ctflearn/binary/shell-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/shell-time/</guid><description>Este reto es la continuación de RIP my bof. Échale un vistazo si no lo has visto ya.
Ahora, la flag está en /flag2.txt, por lo que tenemos que conseguir algo más que redirigir la ejecución del programa a system(&amp;quot;cat /flag.txt&amp;quot;), como en RIP my bof.
Lo primero que pensé es ret2libc. La idea es obtener una consola de comandos llamando a system dentro de Glibc con argumento &amp;quot;/bin/sh&amp;quot;.
Para ese propósito, necesitamos burlar ASLR, porque Glibc es una librería de sistema y está afectada por la aleatorización de direcciones si ASLR está habilitado (probablemente sí).</description></item><item><title>Simple bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</guid><description>Se nos proporciona el código fuente en C de un binario y una instancia remota a la que conectarnos. Básicamente, lo que el programa hace es llamar a gets, que es vulnerable a Buffer Overflow, y luego comparar una variable local con un cierto valor:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer.</description></item></channel></rss>