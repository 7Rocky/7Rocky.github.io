<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pwn on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/</link><description>Recent content in Pwn on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>Bat Computer</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/bat-computer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/bat-computer/</guid><description>Se nos proporciona un binario de 64 bits llamado batcomputer:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Ingeniería inversa Si usamod Ghidra, veremos el código descompilado en C para la función main:
int main() { int res; int option; char password[16]; char command[76]; setup(); while(true) { while(true) { memset(password, 0, 16); printf("Welcome to your BatComputer, Batman. What would you like to do?</description></item><item><title>Blacksmith</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/blacksmith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/blacksmith/</guid><description>Se nos proporciona un binario de 64 bits llamado blacksmith:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Si lo abrimos en Ghidra, veremos esta función main:
void main() { size_t length; long in_FS_OFFSET; int answer; int option; char *message_1; char *message_2; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setup(); message_1 = "You are worthy to carry this Divine Weapon and bring peace to our homeland!</description></item><item><title>Control Room</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/control-room/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/control-room/</guid><description>Se nos proporciona un binario de 64 bits llamado control_room:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Configuración del entorno También se nos proporciona la librería remota Glibc:
$ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item><item><title>CRSid</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/crsid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/crsid/</guid><description>Se nos proporciona un binario de 64 bits llamado crsid:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Si lo ejecutamos, tenemos que introducir un CRSid y luego tenemos este menú:
$ ./crsid ██████╗██████╗ ███████╗██╗██████╗ ██╔════╝██╔══██╗██╔════╝██║██╔══██╗ ██║ ██████╔╝███████╗██║██║ ██║ ██║ ██╔══██╗╚════██║██║██║ ██║ ╚██████╗██║ ██║███████║██║██████╔╝ ╚═════╝╚═╝ ╚═╝╚══════╝╚═╝╚═════╝ [i] Enter your CRSid: asdf ========================= [1] Create username [2] Delete username [3] Edit username [4] Show username [5] Change your CRSid [6] Exit ========================= [#] Ingeniería inversa Se trata de un reto típico de explotación del heap.</description></item><item><title>Entity</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/entity/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si nos conectamos a la instancia remota, vemos lo siguiente:
$ nc 134.122.106.203 30576 Something strange is coming out of the TV.. (T)ry to turn it off (R)un (C)ry &amp;gt;&amp;gt; Nada explicativo&amp;hellip;
Análisis de código estático Esta vez, se nos proporciona también el código fuente original (chall.</description></item><item><title>FileStorage</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/filestorage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/filestorage/</guid><description>Este es reto que diseñé para Hack the Box. Se nos proporciona un binario de 64 bits llamado file_storage:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Vemos que tiene NX habilitado, por lo que no podemos ejecutar shellcode personalizado en la pila directamente. Además, tiene Partial RELRO, lo que significa que la Tabla de Offsets Globales (GOT) puede modificarse de algunas maneras.</description></item><item><title>Finale</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/finale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/finale/</guid><description>Se nos proporciona un binario de 64 bits llamado finale:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Configuración del entorno Puede ocurrir que no tengamos la versión de Glibc que acepta el programa:
$ ./finale ./finale: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./finale) Por suerte, en Spooky Time nos dan una librería y un loader, versión 2.35:
$ ../pwn_spooky_time/glibc/ld-linux-x86-64.so.2 ../pwn_spooky_time/glibc/libc.so.6 GNU C Library (Ubuntu GLIBC 2.</description></item><item><title>Fleet Management</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/fleet-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/fleet-management/</guid><description>Se nos proporciona un binario de 64 bits llamado fleet_management:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si lo abrimos en Ghidra, veremos esta función main:
int main() { setup(); fprintf(stdout, "%s %s Fleet Management System %s\n", &amp;amp;DAT_001023e5, &amp;amp;DAT_001020e9, &amp;amp;DAT_001023e0); fprintf(stdout, "\n%s[*] Loading . . .\n%s", &amp;amp;DAT_001020f1, &amp;amp;DAT_001020e9); sleep(2); menu(); return 0; } Está llamando a menu:
void menu() { long in_FS_OFFSET; undefined8 uVar1; char local_13 [3]; undefined8 canary; canary = *(undefined8 *) (in_FS_OFFSET + 0x28); memset(local_13, 0, 3); do { fwrite("</description></item><item><title>Format</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/format/</guid><description>Se nos proporciona un binario de 64 bits llamado format:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Después de ejecutarlo, vemos que el programa solamente repite lo que introducimos:
$ ./format asdf asdf fdsa fdsa Usando Ghidra, podemos hacer ingeniería inversa para ver el código fuente y observar lo que hace el programa:
int main(EVP_PKEY_CTX *param_1) { long canary; long in_FS_OFFSET; canary = *(long *) (in_FS_OFFSET + 0x28); init(param_1); echo(); if (canary !</description></item><item><title>Getting Started</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/getting-started/</guid><description>En este reto se nos pide explotar una vulnerabilidad de Buffer Overflow básica, a parte de darnos instrucciones y ejemplos:
$ nc 178.62.11.21 31609 Stack frame layout | . | &amp;lt;- Higher addresses | . | |_____________| | | &amp;lt;- 64 bytes | Return addr | |_____________| | | &amp;lt;- 56 bytes | RBP | |_____________| | | &amp;lt;- 48 bytes | target | |_____________| | | &amp;lt;- 40 bytes | alignment | |_____________| | | &amp;lt;- 32 bytes | Buffer[31] | |_____________| | .</description></item><item><title>Hellhound</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/hellhound/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/hellhound/</guid><description>Tenemos un binario de 64 bits llamado hellound:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./.glibc/' Si lo ejecutamos, tenemos la posibilidad de realizar algunas acciones extrañas:
$ ./hellhound This is what it used to look before the modifications.. _ / \ _-' _/| \-''- _ / __-' { | \ / \ / 'o. |o } | \ ; ', \_ __\ ''-_ \.</description></item><item><title>HTB Console</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/htb-console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/htb-console/</guid><description>Se nos proporciona un binario de 64 bits llamado htb-console:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Si usamos Ghidra, veremos la siguiente función main:
void main() { char command[16]; setup(); puts("Welcome HTB Console Version 0.1 Beta."); do { printf("&amp;gt;&amp;gt; "); fgets(command, 16, stdin); console(command); memset(command, 0, 16); } while(true); } El código anterior solamente pide datos al usuario y los pasa a console:</description></item><item><title>Jeeves</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/jeeves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/jeeves/</guid><description>Se nos proporciona un binario de 64 bits llamado jeeves:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Podemos usar Ghidra para analizar el binario y echar un vistazo al código en C descompilado. Este es el main:
int main() { char name[44]; int fd; void *data; uint code; code = 0xdeadc0d3; printf("Hello, good sir!\nMay I have your name? "); gets(name); printf("Hello %s, hope you have a good day!</description></item><item><title>Leet Test</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/leet-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/leet-test/</guid><description>Se nos proporciona un binario de 64 bits llamado leet_test:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si lo abrimos en Ghidra, veremos el siguiente código descompilado en C:
uint winner = 0xcafebabe; void main() { long in_FS_OFFSET; uint random; int urandom_fd; int flag_fd; void *flag; char name[280]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); initialize(); urandom_fd = open("/dev/urandom", 0); read(urandom_fd, &amp;amp;random, 4); close(urandom_fd); random = random &amp;amp; 0xffff; while (true) { printf("</description></item><item><title>Math Door</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/math-door/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/math-door/</guid><description>Se nos proporciona un binario de 64 bits llamado math-door:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' Configuración del entorno También se nos proporciona la librería y el cargador de Glibc remotos:
$ ./ld.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions.</description></item><item><title>Nightmare</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/nightmare/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/nightmare/</guid><description>Se nos proporciona un binario de 64 bits llamado nightmare:
Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
void main() { char option; int option_char; setup(); do { while (true) { while (true) { menu(); option_char = getchar(); option = (char)option_char; getchar(); if (option != '3') break; puts("</description></item><item><title>No Return</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/no-return/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/no-return/</guid><description>Se nos proporciona un binario de 64 bits llamado no-return:
Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa El binario está compilado estáticamente y es tan pequeño que podemos mostrar el código ensamblador complato aquí:
$ objdump -M intel -d no-return no-return: file format elf64-x86-64 Disassembly of section .text: 0000000000401000 &amp;lt;.text&amp;gt;: 401000: 5c pop rsp 401001: 5f pop rdi 401002: 5e pop rsi 401003: 5d pop rbp 401004: 5a pop rdx 401005: 59 pop rcx 401006: 5b pop rbx 401007: 48 31 c0 xor rax,rax 40100a: ff 67 01 jmp QWORD PTR [rdi+0x1] 40100d: 48 ff c0 inc rax 401010: de f1 fdivrp st(1),st 401012: ff 22 jmp QWORD PTR [rdx] 401014: 48 2b 74 24 10 sub rsi,QWORD PTR [rsp+0x10] 401019: f5 cmc 40101a: ff 22 jmp QWORD PTR [rdx] 40101c: 48 89 e1 mov rcx,rsp 40101f: fd std 401020: ff 22 jmp QWORD PTR [rdx] 401022: 48 8d 0c d9 lea rcx,[rcx+rbx*8] 401026: fd std 401027: ff 21 jmp QWORD PTR [rcx] 401029: 48 31 d5 xor rbp,rdx 40102c: 0f 95 c4 setne ah 40102f: ff a5 00 00 44 e8 jmp QWORD PTR [rbp-0x17bc0000] 401035: 48 01 f4 add rsp,rsi 401038: de f9 fdivp st(1),st 40103a: ff 22 jmp QWORD PTR [rdx] 40103c: 48 01 dd add rbp,rbx 40103f: 9b fwait 401040: ff 65 c7 jmp QWORD PTR [rbp-0x39] 401043: 88 a7 00 00 44 e8 mov BYTE PTR [rdi-0x17bc0000],ah 401049: f9 stc 40104a: ff 22 jmp QWORD PTR [rdx] 40104c: 59 pop rcx 40104d: 48 89 d1 mov rcx,rdx 401050: 5a pop rdx 401051: ff 21 jmp QWORD PTR [rcx] 401053: 48 ff c1 inc rcx 401056: de f1 fdivrp st(1),st 401058: ff 22 jmp QWORD PTR [rdx] 40105a: 48 92 xchg rdx,rax 40105c: de f9 fdivp st(1),st 40105e: ff 21 jmp QWORD PTR [rcx] 401060: 48 ff c3 inc rbx 401063: de f1 fdivrp st(1),st 401065: ff 22 jmp QWORD PTR [rdx] 401067: 48 87 cf xchg rdi,rcx 40106a: fd std 40106b: ff 22 jmp QWORD PTR [rdx] 40106d: 54 push rsp 40106e: 48 31 c0 xor rax,rax 401071: 48 ff c0 inc rax 401074: 48 31 ff xor rdi,rdi 401077: 48 ff c7 inc rdi 40107a: 48 89 e6 mov rsi,rsp 40107d: ba 08 00 00 00 mov edx,0x8 401082: 0f 05 syscall 401084: 48 81 ee b0 00 00 00 sub rsi,0xb0 40108b: 48 31 c0 xor rax,rax 40108e: 48 31 ff xor rdi,rdi 401091: 48 8d 36 lea rsi,[rsi] 401094: ba c0 00 00 00 mov edx,0xc0 401099: 0f 05 syscall 40109b: 48 83 c4 08 add rsp,0x8 40109f: ff 64 24 f8 jmp QWORD PTR [rsp-0x8] Esta vez, el binario está desarrollado solo para ser explotado, no hay ningúna funcionalidad realista.</description></item><item><title>Old Bridge</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/old-bridge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/old-bridge/</guid><description>Se nos proporciona un binario de 64 bits llamado oldbridge:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Tenemos casi todas las protecciones habilitadas, por lo que debemos realizar varios bypasses para explotar el binario.
Ingeniería inversa Como en la mayoría de los retos de explotación de binarios, debemos hacer un paso de ingeniería inversa para obtener las instrucciones de ensamblador o el código fuente en C del binario para determinar qué está haciendo y cómo podemos explotarlo.</description></item><item><title>Optimistic</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/optimistic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/optimistic/</guid><description>Se nos proporciona un binario de 64 bits llamado optimistic:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Ingeniería inversa Si usamos Ghidra, veremos el código fuente descompilado en C para la función main:
void main() { int number; ssize_t read_length; uint length; undefined4 local_80; undefined2 local_7c; char option; undefined local_79; undefined email[8]; undefined age[8]; char name[96]; initialize(); puts("Welcome to the positive community!</description></item><item><title>PwnShop</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/pwnshop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/pwnshop/</guid><description>Se nos proporciona un binario de 64 bits llamado pwnshop:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Podemos usar Ghidra para analizar el binario y mirar el código fuente descompilado en C:
undefined[16] main() { int option_char; ulong in_RCX; char option; setup(); puts("========= HTB PwnShop ==========="); while (true) { while (true) { puts("What do you wanna do?"); printf("1&amp;gt; Buy\n2&amp;gt; Sell\n3&amp;gt; Exit\n&amp;gt; "</description></item><item><title>Questionnaire</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/questionnaire/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/questionnaire/</guid><description>Se nos pide contestar a las siguientes preguntas sobre explotación de binarios:
$ nc 161.35.34.21 30758 This is a simple questionnaire to get started with the basics. ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉ ◉ ◉ When compiling C/C++ source code in Linux, an ELF (Executable and Linkable Format) file is created. ◉ ◉ The flags added when compiling can affect the binary in various ways, like the protections. ◉ ◉ Another thing affected can be the architecture and the way it's linked.</description></item><item><title>Reg</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/reg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/reg/</guid><description>Se nos proporciona un binario de 64 bits llamado reg:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Podemos utilizar Ghidra para analizar el binario y mirar el código fuente en C descompilado. Esta es la función main:
int main() { run(); return 0; } Vamos a ver run:
void run() { char local_38[48]; initialize(); printf("Enter your name : "); gets(local_38); puts("Registered!"); return; } El binario es vulnerable a Buffer Overflow porque la variable llamada local_38 tiene 48 bytes asignados como buffer, pero el programa está usando gets, que es una función insegura ya que no limita la longitud de los datos de entrada, desbordando el buffer reservado si el tamaño de los datos de entrada es mayor que 48 bytes.</description></item><item><title>Sacred Scrolls: Revenge</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/sacred-scrolls-revenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/sacred-scrolls-revenge/</guid><description>Se nos proporciona un binario de 64 bits llamado sacred_scrolls:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
void main() { undefined8 *puVar1; long i; byte bVar2; undefined wizard_tag[1528]; undefined8 uStack_110; undefined8 target; undefined8 local_100; undefined8 local_f8; undefined8 local_f0; undefined8 local_e8; undefined8 local_e0; undefined8 local_d8; undefined8 local_d0; undefined8 local_c8; undefined8 local_c0; undefined8 local_b8; undefined8 local_b0; undefined8 local_a8; undefined8 local_a0; undefined8 local_98; undefined8 local_90; undefined8 local_88; undefined8 local_80; undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined8 local_60; undefined8 local_58; undefined8 local_50; undefined8 local_48; undefined *wizard_tag_copy; undefined8 local_38; undefined4 local_2c; bVar2 = 0; uStack_110 = 0x400efa; setup(); uStack_110 = 0x400eff; banner(); uStack_110 = 0x400f09; clean(); uStack_110 = 0x400f1a; printf("</description></item><item><title>Shooting star</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/shooting-star/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/shooting-star/</guid><description>Se nos proporciona un binario de 64 bits llamado shooting_star:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Podemos usar Ghidra para analizar el binario y mirar el código fuente descompilado en C:
void main() { setup(); write(1, &amp;amp;message, 0x5b); star(); return; } Esta función llama a star:
void star() { char option[2]; undefined input_data[64]; read(0, option, 2); if (option[0] == '1') { write(1,"</description></item><item><title>Space</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space/</guid><description>Se nos proporciona un binario de 32 bits llamado space:
Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments No tiene ninguna protección, por lo que podremos ejecutar código arbitrario en la pila (stack) potencialmente para explotar una vulnerabilidad de Buffer Overflow.
Vulnerabilidad de Buffer Overflow Si ejecutamos el binario, solamente nos da una interfaz para introducir datos, y después termina:</description></item><item><title>Space pirate: Entrypoint</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-entrypoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-entrypoint/</guid><description>Se nos proporciona un binario de 64 bits llamado sp_entrypoint:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Podemos ejecutarlo para ver lo que hay, dos opciones:
$ ./sp_entrypoint Authentication System ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░▒▓▓▓░░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓▒░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▒░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒░░░▓▓░░░▓▓▒░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒░░░▒▓▓░░░▓▓▒ ░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░░░░░▓▓░░░▓▓▓ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░▓▓▓▒░░░░▓▓▒ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░▒░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓░▒▓▓▓░░░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒░▓▓▓░░░░ ▓▓ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 1.</description></item><item><title>Space pirate: Going Deeper</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-going-deeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-going-deeper/</guid><description>Se nos proporciona un binario de 64 bits llamado sp_going_deeper:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Si lo ejecutamos, tenemos tres opciones:
$ ./sp_going_deeper Trying to leak information from the pc.. 🖥️ ____________________________________________________ / \ | _____________________________________________ | | | | | | | goldenfang@d12:$ history | | | | 1 ls | | | | 2 mv secret_pass.</description></item><item><title>Space pirate: Retribution</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-retribution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-retribution/</guid><description>Se nos proporciona un binario de 64 bits llamado sp_retribution:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si abrimos el binario en Ghidra veremos esta función main:
void main() { char local_b[3]; setup(); banner(); while (true) { while (true) { printf(&amp;amp;DAT_00101f68, &amp;amp;DAT_00100d78); read(0, local_b, 2); if (local_b[0] != '1') break; show_missiles(); } if (local_b[0] != '2') break; missile_launcher(); } printf("</description></item><item><title>Spellbook</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/spellbook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/spellbook/</guid><description>Se nos proporciona un binario de 64 bits llamado spellbook:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
void main() { size_t option; setup(); banner(); while (true) { while (true) { while (option = menu(), option == 2) { show(); } if (option &amp;lt; 3) break; if (option == 3) { edit(); } else { if (option !</description></item><item><title>Spooky Time</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/spooky-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/spooky-time/</guid><description>Se nos proporciona un binario de 64 bits llamado spooky_time:
Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si lo abrimos en Ghidra, veremos esta función main:
void main() { long in_FS_OFFSET; char first_input[12]; char second_input[312]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setup(); banner(); puts("It\'s your chance to scare those little kids, say something scary!\n"); __isoc99_scanf("%11s", first_input); puts("</description></item><item><title>Trick or Deal</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/trick-or-deal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/trick-or-deal/</guid><description>Se nos proporciona un binario de 64 bits llamado trick_or_deal:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Ingeniería inversa Si usamos Ghidra, podremos ver el siguiente código en C descompilado de la función main:
undefined8 main(undefined8 param_1, undefined8 param_2) { undefined8 in_R9; setup(); fprintf(stdout, "%s %s Welcome to the Intergalactic Weapon Black Market %s\n", &amp;amp;DAT_0010123c, &amp;amp;DAT_00101241, &amp;amp;DAT_0010123c, in_R9, param_2); fprintf(stdout, "\n%sLoading the latest weaponry .</description></item><item><title>Vault-breaker</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/vault-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/vault-breaker/</guid><description>Se nos proporciona un binario de 64 bits llamado vault-breaker:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./.glibc/' Si lo ejecutamos, tenemos dos opciones:
$ ./vault-breaker Current status: Unlocked 🔓 ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒▒▓▓▓▓▒▒▒▒▒▒░░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒░░▒▒░░████▓▓████░░▒▒▓▓▓▓▓▓▓▓▓▓░░▒▒░░ ░░░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒▓▓░░▓▓▒▒▒▒▒▒░░░░▒▒▓▓██▒▒▒▒▓▓▓▓▓▓░░░░ ░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒▓▓░░▓▓░░██▓▓▓▓▓▓▒▒▒▒██░░▓▓▓▓▒▒▒▒ ░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░▓▓▒▒░░▒▒██░░██▒▒▒▒▒▒▒▒██▒▒▒▒██▓▓▒▒▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▒▒▓▓▒▒▓▓░░▒▒▓▓▒▒▒▒░░░░░░▒▒██░░██▒▒▒▒ ▒▒▒▒▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒░░░░▓▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒░░░░░░░░▒▒▓▓▓▓▓▓▒▒ ░░▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▒▒▒▒▒▒▓▓░░▓▓░░░░░░░░▒▒▒▒██▒▒██▒▒ ▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▓▓▒▒░░▒▒▓▓░░░░░░░░░░▒▒▒▒▓▓▒▒██░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▓▓▒▒░░▒▒▓▓░░▒▒░░░░░░░░░░▓▓▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒▒▒▒▒▓▓▒▒░░░░░░░░░░░░▒▒▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▒▒▒░░▓▓▒▒░░░░▒▒░░▒▒▒▒▓▓▒▒▓▓░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▒▒▓▓░░░░░░▒▒░░▒▒▓▓▓▓██▒▒ ░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓██▒▒░░▒▒▒▒▓▓▒▒░░░░▒▒▒▒▓▓▓▓▒▒░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓██▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▒▒██▒▒░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▓▓▒▒▒▒░░▓▓▒▒▒▒▒▒▓▓▒▒██▒▒▓▓▓▓░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓██▓▓▒▒██▒▒░░▒▒▒▒▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓░░░░ ░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▓▓██▓▓████▒▒▒▒▓▓▓▓▓▓▓▓▓▓░░░░░░░░ ░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓██▒▒▓▓▒▒▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ [+] Random secure encryption key has been generated!</description></item><item><title>Void</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/void/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/void/</guid><description>Se nos proporciona un binario de 64 bits llamado void:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Ingeniería inversa Si usamos Ghidra, encontraremos este código descompilado en C:
void vuln() { char data[64]; read(0, data, 200); } int main() { vuln(); return 0; } El código es muy corto y solo hay un solo punto para ingresar datos.
Vulnerabilidad de Buffer Overflow Hay una clara vulnerabilidad de Buffer Overflow ya que data es un vector de char de 64 bytes, y read está leyendo hasta 200 bytes y almacena la información en data.</description></item></channel></rss>