<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pwn on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/</link><description>Recent content in Pwn on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>Little Tommy</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/little-tommy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/little-tommy/</guid><description>Se nos proporciona un binario de 32 bits llamado little_tommy:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) No disponemos del código fuente en C, pero podemos descompilar el binario mediante una herramienta de ingeniería inversa como Ghidra. Esta es la función main:
void main() { int iVar1; int iVar2; size_t sVar3; int in_GS_OFFSET; char local_114[256]; undefined4 local_14; undefined *puStack16; puStack16 = &amp;amp;stack0x00000004; local_14 = *(undefined4 *) (in_GS_OFFSET + 0x14); puts("</description></item><item><title>ropme</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/ropme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/ropme/</guid><description>Se nos proporciona un binario de 64 bits llamado ropme:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Podemos utilizar Ghidra para analizar el binario y mirar el código fuente en C descompilado:
int main() { char local_48[64]; puts("ROP me outside, how \'about dah?"); fflush(stdout); fgets(local_48, 500, stdin); return 0; } El binario es vulnerable a Buffer Overflow porque la variable llamada local_48 tiene 64 bytes asignados como buffer, pero el programa está leyendo hasta 500 bytes de stdin y guardando los datos en local_48, desbordando el buffer reservado si el tamaño de los datos de entrada es mayor que 64 bytes.</description></item></channel></rss>