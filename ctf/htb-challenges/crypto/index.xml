<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/</link><description>Recent content in Crypto on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>AESWCM</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/aeswcm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/aeswcm/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.Padding import pad from Crypto.Cipher import AES import os import random from secret import FLAG KEY = os.urandom(16) IV = os.urandom(16) class AESWCM: def __init__(self, key): self.key = key self.cipher = AES.new(self.key, AES.MODE_ECB) self.BLOCK_SIZE = 16 def pad(self, pt): if len(pt) % self.BLOCK_SIZE != 0: pt = pad(pt, self.BLOCK_SIZE) return pt def blockify(self, message): return [ message[i:i + self.BLOCK_SIZE] for i in range(0, len(message), self.</description></item><item><title>AHS512</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/ahs512/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from hashlib import sha512 import socketserver import signal from random import randint WELCOME = """ **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** "</description></item><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.</description></item><item><title>Bank-er-smith</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bank-er-smith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bank-er-smith/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = """ ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ """ class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.</description></item><item><title>BBGun06</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</guid><description>Se nos proporciona un código fuente en Python que nos pregunta por una firma. Esta es la función main:
def main(s): rsa = RSA(2048) user, data = parseEmail() signature = rsa.sign(user) rsa.verify(user, signature) headers = generateHeaders(rsa, signature) valid_email = headers + data sendMessage(s, valid_email + "\n\n") try: forged_signature = recieveMessage(s, "Enter the signature as hex: ") forged_signature = bytes.fromhex(forged_signature) if not rsa.verify(user, forged_signature): sendMessage(s, "Invalid signature") if different(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, "</description></item><item><title>Brainy's Cipher</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</guid><description>Se nos proporciona el siguiente archivo de texto (brainy.txt):
++++++++++[>+>+++>+++++++>++++++++++&lt;&lt;&lt;&lt;-]>>>>+++++++++++++++++++++++.-----------.&lt;------------.---.++.---------.+.++.-.++.+.-----.++..++++.--.++++.+..-------.+.+++.---.+.+++++.-------.+.---.+++++++.+.-------..+++.-.+++++.-------.++.+++++.-----.+++++..-----.--.++++++++.-------.--.++++.+++.---.++..+++.------.+++.--.-..++++++.-.----..+++++.------.++++++.---.---.--.+++.++++.-------.+++++..-.++..-------.++++++.---.++..+++.----.++++.-------.++++++++..----.+++.+.------.--.-.++.-.+++++.--..--.++++.-.++++.---.------.+++++.++.+.---.+++.---.----.++++.--.+++.-----.+++++.+.---.--.+++++++.---.---...---.+.++++++++.----.++++.-----.++.--.-.--.++.-.-.+++++.--..+++++.-------.-.++++.++.-----.++++++.--------.+++.+++.-.+++.----.----.++++++.----.++++++.-------.-----.>+.&lt;++++++++++++++.---------.+.++++++.--------.++.+++++++.--------.+++++++.----.+.----.+++...----.++++..++.----..+++.+++.-----.++++.--.++..-------.+++.++++.--.---.--.++++++..-----..+++++++.-------.+++++++.--------..++++++.++.--..++.----.+++.++.------.++++.+.-..+.+.-------.++++++.-.---.---.-.++++++++..-----.---.++.+.++..-.--.+++.++++.--..------.++++++++.-------.+++++++..---.+.++..---.----.+.++++++..-.-.-----.--.++++.--.+++++++.----.++++.-----.-.+.++.+..+..--.-.---.+++++.--.--.++++++.--------.++.---.+++++++..----.---.+++++++++.-...-------.++++++++.-------.++.-.+++++.----.-.+++++.---.----.+++++.++.-----.---.+++++++.++.---------...++.+++++++.------.+++++.-------.++++.-----.+++++.----.-----.>-------------.++++++++++++.&lt;++++++++++++++.-----..-.----.++++++.-..-----.++.++++++.--.----..--.++.-.++++++++.------.+..--.+++++++.------.---.++++++.----.++++++.-.++.------.++++...--.---.+++++++.--------.++++++++.----..+.----.+..---.++++++++.+.---.-.---.--.++++++++.-----.+++++.----.+.+++.------.--..+++++++++.-.---.++.----.++++.-.------.+++++.--.++.+++.-----.++.++.--..----.-.+++++++.+.----.---.+++++.+++.---.-----.+++++.------.++++++.-.----..++.+++.--.---.++.++++++.--------..+++++.+++.---.-----.++.++++++.---.+++.-.-------.++.+++.-.---.+++.---.+.++.-----.+++++++.---.--.-..++++.++.-------.++++.+.--.++++..+.+.-.---.-.--.+.+++++.--.+++.------..--.++++++++.-.------.++++.+++.-----.+.----.-----.>------------.+++++++++++++.&lt;++++++++++++++.-.---------.++++++..++.+.--.----.-.--.+++.---.++++++++..-----.+.--.--.++++++.+++.----.---.+.++.++++.------.++++++..--.----.++++..---.+++.----.--..++++++++.-.-----..---.+++++++++.---------.++++++.----.+++++.-.--.---.++++++.+.+.---------.++++++.----.++++.+++.-----.+++.--.+++.----.+++.------.++++++.----.++++++.---..------.+++++++.----.++.+.+.++.-..-------.++++++.-------.++++.---.++++.+++.-----.++++++..----.-.+++++..---.---.-..+.--.+++.---.++++.++.---.-.+++++.-..-------.++..+++.++++.----.---.++.+++++.--------.++++.+.------..+++++.---.++++++.-.------.+++.++.--.---.++.+++.-----.+++++.---.+.--.-.+++++++.+.-------.--.+++++.-----..+++++.++.---.+++++.-.--.-.----.-----.>--------------.&lt;++++++++++++++.----.----.--.+++++++.+.--------.++++++++.--..+..---.---.+++++..++.--.++.--.+.------.+++++++.-----.+++++.---.++.++.----.++.----.++.-----.+++..+++++.-----.--.+++...++.----.++++++.--------.+++++++++.--------.+.++++.+.----..++++++.-------.++..++++.--------.++++++.-.-----.++.++++.++.---.-----.++.-.+.++++.++.---.--.-.++++.-..----..+++++++.-----.++++++.---.----.--.+++++.+.--.+++++.----.++++.---.--.+.++.++.--.+.------.+.-.+++.--.---.++.--.++++++++.------.--.+++++.-.-.++++++.------.++++++.------..+++.++.------..++++.-.++..-----.++++++.--------.++.+++++.--.-----.++++++++..-.-----.+++++++.------.+++.------.++.++.-.-.+++.----.+.+++++++.---.+.++..-----.++++.--------.+++++..-.+++++..---.-.-----.++.--.+++++++++.--------.+++++.+++.----.--.+++.--..++.---.++.++++.---.-.++++.--------.+++++..------.+++++++.++.-------.+++.--..++.+.---.++++++.---------.++.+++++.--.++.++.--------.+++++++.-.---.-.++.----.+++++++.--------.++++++.------.+++++++.---.+++.--.++++.---.---..-..++.++.-.-.---.++++++..--.+++.+.----.++++.---------..++.+.+++++.---.-.+.----.+++++++.--.---.--.+..-.-.++++++.--.++++.-.+.-----.+.+++.+.----.++.++..--------.++.+++++++.--------.+++++.+..-----.--.+.++++++.--.----.+.++++++.--------.++++++++.------.--.++++++...+.-------.+++++++++.-----.+.+.----.+++.-----.++++++.+.+.--------.+++.+++++.-------.+.+++++++.--.-------.++++++++.-.------.>++++++++++++++++++++++++++. Se trata de un lenguaje esotérico llamado Brainfuck. Si usamos una herramienta como www.tutorialspoint.com, podemos obtener el resultado:
En resumen, tenemos:
p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 $p$ y $q$ parecen parámetros para un criptosistema RSA, y $c$ debe ser el texto cifrado. Sin embargo, necesitamos saber qué son $dp$ y $dq$.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>Se nos proporciona un texto cifrado:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>ElElGamal</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/elelgamal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/elelgamal/</guid><description>Tenemos esta descripción del reto:
After some minor warnings from IDS, you decide to check the logs to see if anything suspicious is happening. Surprised by what you see, you realize that one of your honeypots has been compromised with a cryptominer. As you look at the processes, you discover a backdoor attached to one of them. The backdoor retrieves the private key from the /key route of a C2. It establishes a session by sending an encrypted initialization sequence.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/fast-carmichael/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p &amp;lt; 1: return False if (p.</description></item><item><title>Find Marher's Secret</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</guid><description>Se nos proporciona un sódigo en Python y un servidor al que conectarnos:
$ nc 161.35.172.25 32275 Connected to the cyborg's debugging interface Options: 1. Encrypt your text. 2. Claim the key. &amp;gt; Análisis de código estático Esta es la parte importante del código:
def challenge(req): key = bytes.fromhex(KEY) assert(len(key) == 27) req.sendall(b'Connected to the cyborg\'s debugging interface\n') while True: req.sendall( b'\nOptions:\n1. Encrypt your text.\n2. Claim the key.\n&amp;gt; ') try: response = json.</description></item><item><title>Gonna-Lift-Em-All</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/gonna-lift-em-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/gonna-lift-em-all/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getPrime import random FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}' def gen_params(): p = getPrime(1024) g = random.randint(2, p-2) x = random.randint(2, p-2) h = pow(g, x, p) return (p, g, h), x def encrypt(pubkey): p, g, h = pubkey m = bytes_to_long(FLAG) y = random.randint(2, p-2) s = pow(h, y, p) return (g * y % p, m * s % p) def main(): pubkey, privkey = gen_params() c1, c2 = encrypt(pubkey) with open('data.</description></item><item><title>Hash the Filesystem</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</guid><description>Se nos proporciona un código fuente que nos pide iniciar sesión y nos ofrece algunas funcionalidades. Esta es la función principal:
def challenge(req): fnames = initializeDatabase() file_record['admin'] = [fname for fname in fnames] req.sendall(b'Super secret file server for malicious operations.\n' + b'Who are you:\n' + b'&amp;gt; ') user = req.recv(4096).decode().strip() if user == 'admin': req.sendall( b'Administrator can access the server only via ssh.\nGoodbye!\n') return token = json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] = [] key = os.</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:
import os with open('super_secret_messages.txt', 'r') as f: SUPER_SECRET_MESSAGES = [msg.strip() for msg in f.readlines()] def deriveKey(key): derived_key = [] for i, char in enumerate(key): previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): if previous_char &amp;gt; char: derived_key[j] += 1 else: new_number += 1 derived_key.append(new_number) return derived_key def transpose(array): return [row for row in map(list, zip(*array))] def flatten(array): return "</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</guid><description>Se nos proporciona un código en Python que implementa RSA de forma extraña (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Do neighbouring primes present a security risk?</description></item><item><title>Infinite Knapsack</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-knapsack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-knapsack/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from random import randint, seed, sample, getstate import math from secret import SEED, FLAG, INIT class MH: def __init__(self, size): keys = self.generateKeys(size) self.public_key = keys[0] self.private_key = keys[1] def generateKeys(self, n): private_key = [INIT] + [0 for _ in range(n - 1)] for i in range(1, n): total = sum(private_key) private_key[i] = randint(total * 2, total * 3) total = sum(private_key) modulo = randint(total * 2, total * 3) while True: multiplier = randint(modulo // 4, modulo - 1) if math.</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>Se nos proporciona este código fuente en Python:
from hashlib import sha256 from Crypto.Util.Padding import pad, unpad import signal import subprocess import socketserver import os allowed_commands = [b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE = 32 def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]+secret[i]) % 256 enc_block += bytes([val]) return enc_block def encrypt(msg, password): h = sha256(password).digest() if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' for block in blocks: enc_block = encrypt_block(block, h) h = sha256(enc_block + block).</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag, y una aplicación Flask que llama a la función de cifrado:
from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime, inverse import random FLAG = b'HTB{--REDACTED--}' p = getPrime(1024) q = getPrime(1024) n = p * q e = 257 def encrypt_flag(): a = random.getrandbits(1024) b = random.getrandbits(1024) flag = bytes_to_long(FLAG) msg = a*flag + b ct = pow(msg, e, n) return {'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} from flask import * from chall import encrypt_flag app = Flask(__name__) @app.</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</guid><description>Se nos proporciona el siguiente código en Python:
from sympy import * from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randint, randbytes, seed FLAG = b'HTB{dummyflag}' class Shamir: def __init__(self, prime, k, n): self.p = prime self.secret = randint(1, self.p - 1) self.k = k self.n = n self.coeffs = [self.secret] self.x_vals = [] self.y_vals = [] def next_coeff(self, val): return int(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) def calc_coeffs(self): for i in range(1, self.</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/spooky-rsa/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b'HTB{????????????????????????????????????????????}' def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open('out.</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>Se nos proporciona el siguiente código en Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random import signal import subprocess import socketserver FLAG = b'HTB{--REDACTED--}' prefix = random.randbytes(12) key = random.randbytes(16) def encrypt(key, msg): msg = bytes.fromhex(msg) crypto = AES.new(key, AES.MODE_ECB) padded = pad(prefix + msg + FLAG, 16) return crypto.encrypt(padded).hex() def challenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n' + b'It seems like there is a prefix appended to the real firmware\n' + b'Can you somehow extract the firmware and fix the chip?</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</guid><description>Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo. Luego, se coge un exponente $e$ (típicamente $e = 65537$) y se cifra el mensage $m$ en formato decimal:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/whole-lotta-candy/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from encrypt import Encryptor from secret import FLAG import socketserver import random import signal import json MODES = ['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def main(s): mode = random.choice(MODES) enc = Encryptor() while True: try: sendMessage(s, f"Please interact with the server using json data!</description></item></channel></rss>