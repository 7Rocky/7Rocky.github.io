<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/</link><description>Recent content in Crypto on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:
import&amp;nbsp;os with&amp;nbsp;open('super_secret_messages.txt',&amp;nbsp;'r')&amp;nbsp;as&amp;nbsp;f: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SUPER_SECRET_MESSAGES&amp;nbsp;=&amp;nbsp;[msg.strip()&amp;nbsp;for&amp;nbsp;msg&amp;nbsp;in&amp;nbsp;f.readlines()] def&amp;nbsp;deriveKey(key): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;derived_key&amp;nbsp;=&amp;nbsp;[] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;i,&amp;nbsp;char&amp;nbsp;in&amp;nbsp;enumerate(key): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;previous_letters&amp;nbsp;=&amp;nbsp;key[:i] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new_number&amp;nbsp;=&amp;nbsp;1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;j,&amp;nbsp;previous_char&amp;nbsp;in&amp;nbsp;enumerate(previous_letters): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;previous_char&amp;nbsp;&amp;gt;&amp;nbsp;char: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;derived_key[j]&amp;nbsp;+=&amp;nbsp;1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new_number&amp;nbsp;+=&amp;nbsp;1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;derived_key.append(new_number) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;derived_key def&amp;nbsp;transpose(array): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;[row&amp;nbsp;for&amp;nbsp;row&amp;nbsp;in&amp;nbsp;map(list,&amp;nbsp;zip(*array))] def&amp;nbsp;flatten(array): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"".join([i&amp;nbsp;for&amp;nbsp;sub&amp;nbsp;in&amp;nbsp;array&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;sub]) def&amp;nbsp;twistedColumnarEncrypt(pt,&amp;nbsp;key): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;derived_key&amp;nbsp;=&amp;nbsp;deriveKey(key) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;width&amp;nbsp;=&amp;nbsp;len(key) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;blocks&amp;nbsp;=&amp;nbsp;[pt[i:i&amp;nbsp;+&amp;nbsp;width]&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;range(0,&amp;nbsp;len(pt),&amp;nbsp;width)] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;blocks&amp;nbsp;=&amp;nbsp;transpose(blocks) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ct&amp;nbsp;=&amp;nbsp;[blocks[derived_key.index(i&amp;nbsp;+&amp;nbsp;1)][::-1]&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;range(width)] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ct&amp;nbsp;=&amp;nbsp;flatten(ct) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;ct class&amp;nbsp;PRNG: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;__init__(self,&amp;nbsp;seed): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.p&amp;nbsp;=&amp;nbsp;0x2ea250216d705 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.a&amp;nbsp;=&amp;nbsp;self.p &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.b&amp;nbsp;=&amp;nbsp;int.from_bytes(os.urandom(16),&amp;nbsp;'big') &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.rn&amp;nbsp;=&amp;nbsp;seed &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;next(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.rn&amp;nbsp;=&amp;nbsp;((self.a&amp;nbsp;*&amp;nbsp;self.rn)&amp;nbsp;+&amp;nbsp;self.b)&amp;nbsp;%&amp;nbsp;self.p &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;self.rn def&amp;nbsp;main(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;seed&amp;nbsp;=&amp;nbsp;int.from_bytes(os.urandom(16),&amp;nbsp;'big') &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rng&amp;nbsp;=&amp;nbsp;PRNG(seed) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cts&amp;nbsp;=&amp;nbsp;"" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;message&amp;nbsp;in&amp;nbsp;SUPER_SECRET_MESSAGES: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key&amp;nbsp;=&amp;nbsp;str(rng.next()) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ct&amp;nbsp;=&amp;nbsp;twistedColumnarEncrypt(message,&amp;nbsp;key) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cts&amp;nbsp;+=&amp;nbsp;ct&amp;nbsp;+&amp;nbsp;"\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;with&amp;nbsp;open('encrypted_messages.txt',&amp;nbsp;'w')&amp;nbsp;as&amp;nbsp;f: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;f.write(cts) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dialog&amp;nbsp;=&amp;nbsp;"Miyuki&amp;nbsp;says:\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dialog&amp;nbsp;+=&amp;nbsp;"Klaus&amp;nbsp;it's&amp;nbsp;your&amp;nbsp;time&amp;nbsp;to&amp;nbsp;sign!\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dialog&amp;nbsp;+=&amp;nbsp;"All&amp;nbsp;we&amp;nbsp;have&amp;nbsp;is&amp;nbsp;the&amp;nbsp;last&amp;nbsp;key&amp;nbsp;of&amp;nbsp;this&amp;nbsp;wierd&amp;nbsp;encryption&amp;nbsp;scheme.\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dialog&amp;nbsp;+=&amp;nbsp;"Please&amp;nbsp;do&amp;nbsp;your&amp;nbsp;magic,&amp;nbsp;we&amp;nbsp;need&amp;nbsp;to&amp;nbsp;gather&amp;nbsp;more&amp;nbsp;information&amp;nbsp;if&amp;nbsp;we&amp;nbsp;want&amp;nbsp;to&amp;nbsp;defeat&amp;nbsp;Draeger.\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dialog&amp;nbsp;+=&amp;nbsp;f"The&amp;nbsp;key&amp;nbsp;is:&amp;nbsp;{str(key)}\n" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;with&amp;nbsp;open('dialog.txt',&amp;nbsp;'w')&amp;nbsp;as&amp;nbsp;f: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;f.</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</guid><description>Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo. Luego, se coge un exponente $e$ (típicamente $e = 65537$) y se cifra el mensage $m$ en formato decimal:</description></item></channel></rss>