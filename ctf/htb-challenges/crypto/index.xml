<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/</link><description>Recent content in Crypto on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>Se nos proporciona un texto cifrado:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:
importos withopen('super_secret_messages.txt', 'r') asf: SUPER_SECRET_MESSAGES=[msg.strip() formsginf.readlines()] defderiveKey(key): derived_key=[] fori, charinenumerate(key): previous_letters=key[:i] new_number=1 forj, previous_charinenumerate(previous_letters): ifprevious_char&amp;gt;char: derived_key[j] +=1 else: new_number+=1 derived_key.append(new_number) returnderived_key deftranspose(array): return[rowforrowinmap(list, zip(*array))] defflatten(array): return"".join([iforsubinarrayforiinsub]) deftwistedColumnarEncrypt(pt, key): derived_key=deriveKey(key) width=len(key) blocks=[pt[i:i+width] foriinrange(0, len(pt), width)] blocks=transpose(blocks) ct=[blocks[derived_key.index(i+1)][::-1] foriinrange(width)] ct=flatten(ct) returnct classPRNG: def__init__(self, seed): self.p=0x2ea250216d705 self.a=self.p self.b=int.from_bytes(os.urandom(16), 'big') self.rn=seed defnext(self): self.rn=((self.a*self.rn) +self.b) %self.p returnself.rn defmain(): seed=int.</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</guid><description>Se nos proporciona un código en Python que implementa RSA de forma extraña (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Doneighbouring primes present a security risk?</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>Se nos proporciona este código fuente en Python:
fromhashlibimportsha256 fromCrypto.Util.Paddingimportpad, unpad importsignal importsubprocess importsocketserver importos allowed_commands=[b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE=32 defencrypt_block(block, secret): enc_block=b'' foriinrange(BLOCK_SIZE): val=(block[i]+secret[i]) %256 enc_block+=bytes([val]) returnenc_block defencrypt(msg, password): h=sha256(password).digest() iflen(msg) %BLOCK_SIZE!=0: msg=pad(msg, BLOCK_SIZE) blocks=[msg[i:i+BLOCK_SIZE] foriinrange(0, len(msg), BLOCK_SIZE)] ct=b'' forblockinblocks: enc_block=encrypt_block(block, h) h=sha256(enc_block+block).digest() ct+=enc_block returnct.hex() defrun_command(cmd): ifcmdinallowed_commands: try: resp=subprocess.run( cmd.decode().split(' '), capture_output=True) output=resp.stdout returnoutput except: returnb'Something went wrong!\n' else: returnb'Invalid command!\n' defchallenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag, y una aplicación Flask que llama a la función de cifrado:
fromCrypto.Util.numberimportlong_to_bytes, bytes_to_long, getPrime, inverse importrandom FLAG=b'HTB{--REDACTED--}' p=getPrime(1024) q=getPrime(1024) n=p*q e=257 defencrypt_flag(): a=random.getrandbits(1024) b=random.getrandbits(1024) flag=bytes_to_long(FLAG) msg=a*flag+b ct=pow(msg, e, n) return{'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} fromflaskimport* fromchallimportencrypt_flag app=Flask(__name__) @app.route('/', methods=['GET']) defindex(): returnrender_template('index.html') @app.route('/api/get_flag', methods=['GET']) defget_flag(): payload=encrypt_flag() returnjsonify(payload) if__name__=='__main__': app.</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</guid><description>Se nos proporciona el siguiente código en Python:
fromsympyimport* fromhashlibimportmd5 fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad fromrandomimportrandint, randbytes, seed FLAG=b'HTB{dummyflag}' classShamir: def__init__(self, prime, k, n): self.p=prime self.secret=randint(1, self.p-1) self.k=k self.n=n self.coeffs=[self.secret] self.x_vals=[] self.y_vals=[] defnext_coeff(self, val): returnint(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) defcalc_coeffs(self): foriinrange(1, self.n+1): self.coeffs.append(self.next_coeff(self.coeffs[i-1])) defcalc_y(self, x): y=0 fori, coeffinenumerate(self.coeffs): y+=coeff*x**i returny%self.p defcreate_pol(self): self.calc_coeffs() self.coeffs=self.coeffs[:self.k] for_inrange(self.n): x=randint(1, self.p-1) self.x_vals.append(x) self.y_vals.append(self.calc_y(x)) defget_share(self): returnself.x_vals[0], self.y_vals[0] defmain(): sss=Shamir(92434467187580489687, 10, 18) sss.create_pol() share=sss.get_share() seed(sss.secret) key=randbytes(16) cipher=AES.new(key, AES.MODE_ECB) enc_FLAG=cipher.encrypt(pad(FLAG, 16)).hex() print(sss.coeffs) f=open('msg.enc', 'w') f.</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>Se nos proporciona el siguiente código en Python:
fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad importrandom importsignal importsubprocess importsocketserver FLAG=b'HTB{--REDACTED--}' prefix=random.randbytes(12) key=random.randbytes(16) defencrypt(key, msg): msg=bytes.fromhex(msg) crypto=AES.new(key, AES.MODE_ECB) padded=pad(prefix+msg+FLAG, 16) returncrypto.encrypt(padded).hex() defchallenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n'+ b'It seems like there is a prefix appended to the real firmware\n'+ b'Can you somehow extract the firmware and fix the chip?\n') whileTrue: req.sendall(b'&amp;gt; ') try: msg=req.recv(4096).decode() ct=encrypt(key, msg) req.sendall(ct.encode() +b'\n') exceptExceptionase: print(e) req.sendall(b'An error occurred! Please try again!') classincoming(socketserver.</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</guid><description>Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo.</description></item></channel></rss>