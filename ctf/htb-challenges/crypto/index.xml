<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/</link><description>Recent content in Crypto on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>400curves</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/400curves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/400curves/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.number import inverse, bytes_to_long import socketserver import signal from secret import FLAG a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff E = {'a': a, 'b': b, 'p': p} class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def recieveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def add(P, Q, E): if (P == (0, 0)): return Q elif (Q == (0, 0)): return P else: Ea, Ep = E['a'], E['p'] x1, y1 = P x2, y2 = Q if ((x1 == x2) &amp;amp; (y1 == -y2)): return ((0, 0)) else: if (P !</description></item><item><title>AbraCryptabra</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/abracryptabra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/abracryptabra/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.number import long_to_bytes, GCD from Crypto.Util.Padding import pad from Crypto.Cipher import AES import hashlib import random import socketserver import signal from secret import FLAG LOGO = (""" ╭━━━┳╮╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╭╮╱╱╱╭╮ ┃╭━╮┃┃╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╭╯╰╮╱╱┃┃ ┃┃╱┃┃╰━┳━┳━━┳━━┳━┳╮╱╭┳━┻╮╭╋━━┫╰━┳━┳━━╮ ┃╰━╯┃╭╮┃╭┫╭╮┃╭━┫╭┫┃╱┃┃╭╮┃┃┃╭╮┃╭╮┃╭┫╭╮┃ ┃╭━╮┃╰╯┃┃┃╭╮┃╰━┫┃┃╰━╯┃╰╯┃╰┫╭╮┃╰╯┃┃┃╭╮┃ ╰╯╱╰┻━━┻╯╰╯╰┻━━┻╯╰━╮╭┫╭━┻━┻╯╰┻━━┻╯╰╯╰╯ ╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╭━╯┃┃┃ ╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╰━━╯╰╯\n""") class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def bytes_to_bits(input): return ''.</description></item><item><title>AESWCM</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/aeswcm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/aeswcm/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.Padding import pad from Crypto.Cipher import AES import os import random from secret import FLAG KEY = os.urandom(16) IV = os.urandom(16) class AESWCM: def __init__(self, key): self.key = key self.cipher = AES.new(self.key, AES.MODE_ECB) self.BLOCK_SIZE = 16 def pad(self, pt): if len(pt) % self.BLOCK_SIZE != 0: pt = pad(pt, self.BLOCK_SIZE) return pt def blockify(self, message): return [ message[i:i + self.BLOCK_SIZE] for i in range(0, len(message), self.</description></item><item><title>AHS512</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/ahs512/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/ahs512/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from hashlib import sha512 import socketserver import signal from random import randint WELCOME = """ **************** Welcome to the Hash Game. **************** * * * Hash functions are really spooky. * * In this game you will have to face your fears. * * Can you find a colision in the updated sha512? * * * *********************************************************** "</description></item><item><title>Ancient Encodings</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/ancient-encodings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/ancient-encodings/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long from base64 import b64encode from secret import FLAG def encode(message): return hex(bytes_to_long(b64encode(message))) def main(): encoded_flag = encode(FLAG) with open("output.txt", "w") as f: f.write(encoded_flag) if __name__ == "__main__": main() Y también tenemos la salida del script:
0x53465243657a51784d56383361444e664d32356a4d475178626a6c664e44497a5832677a4d6a4e664e7a42664e5463306558303d Análisis de código fuente El programa coge la flag y usa encode:
def encode(message): return hex(bytes_to_long(b64encode(message))) Como se puede ver, la flag se convierte a codificación Base64, luego a un número decimal y finalmente a formato hexadecimal.</description></item><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.</description></item><item><title>baby quick maffs</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/baby-quick-maffs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/baby-quick-maffs/</guid><description>Se nos proporciona este código en Python para cifrar la flag, y nos dan el archivo output.txt:
#!/usr/bin/env python3 from secret import flag, p, q from Crypto.Util.number import bytes_to_long from random import randint def partition_message(m, N): m1 = randint(1, N) parts = [] remainder = 0 while sum(parts) &amp;lt; m: if sum(parts) + m1 &amp;lt; m: parts.append(m1) else: remainder = m - sum(parts) parts.append(m1 + remainder) return (parts, remainder) def encode(message, N): m = bytes_to_long(message) parts, remainder = partition_message(m, N) ciphers = [pow(c, 2, N) for c in parts] return (ciphers, remainder) N = p * q ciphers, remainder = encode(flag, N) with open("</description></item><item><title>Bank-er-smith</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bank-er-smith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bank-er-smith/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = """ ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ """ class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.</description></item><item><title>BBGun06</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</guid><description>Se nos proporciona un código fuente en Python que nos pregunta por una firma. Esta es la función main:
def main(s): rsa = RSA(2048) user, data = parseEmail() signature = rsa.sign(user) rsa.verify(user, signature) headers = generateHeaders(rsa, signature) valid_email = headers + data sendMessage(s, valid_email + "\n\n") try: forged_signature = recieveMessage(s, "Enter the signature as hex: ") forged_signature = bytes.fromhex(forged_signature) if not rsa.verify(user, forged_signature): sendMessage(s, "Invalid signature") if different(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, "</description></item><item><title>BFD56</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bfd56/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bfd56/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from secret import pt,key,block_length import random alph = "ABCDEFGHIKLMNOPQRSTUVWXYZ" def strmask(msg,mask): mask = (mask * ((len(msg)//len(mask)) + 1)) return "".join([alph[(alph.index(i) + alph.index(j)) % 25] for i,j in zip(msg, mask)]) def strunmask(msg,mask): mask = (mask * ((len(msg)//len(mask)) + 1)) return "".join([alph[(alph.index(i) - alph.index(j)) % 25] for i,j in zip(msg, mask)]) def encrypt_block(pt, indices, characters): res = [-1] * len(pt) * 2 for i,c in enumerate(pt): res[i],res[i+len(pt)] = indices[c][0],indices[c][1] ret = "</description></item><item><title>Biased Heritage</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/biased-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/biased-heritage/</guid><description>Este reto es una especie de continuación de Colliding Heritage. Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????????????????}" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.</description></item><item><title>Brainy's Cipher</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</guid><description>Se nos proporciona el siguiente archivo de texto (brainy.txt):
++++++++++[>+>+++>+++++++>++++++++++&lt;&lt;&lt;&lt;-]>>>>+++++++++++++++++++++++.-----------.&lt;------------.---.++.---------.+.++.-.++.+.-----.++..++++.--.++++.+..-------.+.+++.---.+.+++++.-------.+.---.+++++++.+.-------..+++.-.+++++.-------.++.+++++.-----.+++++..-----.--.++++++++.-------.--.++++.+++.---.++..+++.------.+++.--.-..++++++.-.----..+++++.------.++++++.---.---.--.+++.++++.-------.+++++..-.++..-------.++++++.---.++..+++.----.++++.-------.++++++++..----.+++.+.------.--.-.++.-.+++++.--..--.++++.-.++++.---.------.+++++.++.+.---.+++.---.----.++++.--.+++.-----.+++++.+.---.--.+++++++.---.---...---.+.++++++++.----.++++.-----.++.--.-.--.++.-.-.+++++.--..+++++.-------.-.++++.++.-----.++++++.--------.+++.+++.-.+++.----.----.++++++.----.++++++.-------.-----.>+.&lt;++++++++++++++.---------.+.++++++.--------.++.+++++++.--------.+++++++.----.+.----.+++...----.++++..++.----..+++.+++.-----.++++.--.++..-------.+++.++++.--.---.--.++++++..-----..+++++++.-------.+++++++.--------..++++++.++.--..++.----.+++.++.------.++++.+.-..+.+.-------.++++++.-.---.---.-.++++++++..-----.---.++.+.++..-.--.+++.++++.--..------.++++++++.-------.+++++++..---.+.++..---.----.+.++++++..-.-.-----.--.++++.--.+++++++.----.++++.-----.-.+.++.+..+..--.-.---.+++++.--.--.++++++.--------.++.---.+++++++..----.---.+++++++++.-...-------.++++++++.-------.++.-.+++++.----.-.+++++.---.----.+++++.++.-----.---.+++++++.++.---------...++.+++++++.------.+++++.-------.++++.-----.+++++.----.-----.>-------------.++++++++++++.&lt;++++++++++++++.-----..-.----.++++++.-..-----.++.++++++.--.----..--.++.-.++++++++.------.+..--.+++++++.------.---.++++++.----.++++++.-.++.------.++++...--.---.+++++++.--------.++++++++.----..+.----.+..---.++++++++.+.---.-.---.--.++++++++.-----.+++++.----.+.+++.------.--..+++++++++.-.---.++.----.++++.-.------.+++++.--.++.+++.-----.++.++.--..----.-.+++++++.+.----.---.+++++.+++.---.-----.+++++.------.++++++.-.----..++.+++.--.---.++.++++++.--------..+++++.+++.---.-----.++.++++++.---.+++.-.-------.++.+++.-.---.+++.---.+.++.-----.+++++++.---.--.-..++++.++.-------.++++.+.--.++++..+.+.-.---.-.--.+.+++++.--.+++.------..--.++++++++.-.------.++++.+++.-----.+.----.-----.>------------.+++++++++++++.&lt;++++++++++++++.-.---------.++++++..++.+.--.----.-.--.+++.---.++++++++..-----.+.--.--.++++++.+++.----.---.+.++.++++.------.++++++..--.----.++++..---.+++.----.--..++++++++.-.-----..---.+++++++++.---------.++++++.----.+++++.-.--.---.++++++.+.+.---------.++++++.----.++++.+++.-----.+++.--.+++.----.+++.------.++++++.----.++++++.---..------.+++++++.----.++.+.+.++.-..-------.++++++.-------.++++.---.++++.+++.-----.++++++..----.-.+++++..---.---.-..+.--.+++.---.++++.++.---.-.+++++.-..-------.++..+++.++++.----.---.++.+++++.--------.++++.+.------..+++++.---.++++++.-.------.+++.++.--.---.++.+++.-----.+++++.---.+.--.-.+++++++.+.-------.--.+++++.-----..+++++.++.---.+++++.-.--.-.----.-----.>--------------.&lt;++++++++++++++.----.----.--.+++++++.+.--------.++++++++.--..+..---.---.+++++..++.--.++.--.+.------.+++++++.-----.+++++.---.++.++.----.++.----.++.-----.+++..+++++.-----.--.+++...++.----.++++++.--------.+++++++++.--------.+.++++.+.----..++++++.-------.++..++++.--------.++++++.-.-----.++.++++.++.---.-----.++.-.+.++++.++.---.--.-.++++.-..----..+++++++.-----.++++++.---.----.--.+++++.+.--.+++++.----.++++.---.--.+.++.++.--.+.------.+.-.+++.--.---.++.--.++++++++.------.--.+++++.-.-.++++++.------.++++++.------..+++.++.------..++++.-.++..-----.++++++.--------.++.+++++.--.-----.++++++++..-.-----.+++++++.------.+++.------.++.++.-.-.+++.----.+.+++++++.---.+.++..-----.++++.--------.+++++..-.+++++..---.-.-----.++.--.+++++++++.--------.+++++.+++.----.--.+++.--..++.---.++.++++.---.-.++++.--------.+++++..------.+++++++.++.-------.+++.--..++.+.---.++++++.---------.++.+++++.--.++.++.--------.+++++++.-.---.-.++.----.+++++++.--------.++++++.------.+++++++.---.+++.--.++++.---.---..-..++.++.-.-.---.++++++..--.+++.+.----.++++.---------..++.+.+++++.---.-.+.----.+++++++.--.---.--.+..-.-.++++++.--.++++.-.+.-----.+.+++.+.----.++.++..--------.++.+++++++.--------.+++++.+..-----.--.+.++++++.--.----.+.++++++.--------.++++++++.------.--.++++++...+.-------.+++++++++.-----.+.+.----.+++.-----.++++++.+.+.--------.+++.+++++.-------.+.+++++++.--.-------.++++++++.-.------.>++++++++++++++++++++++++++. Se trata de un lenguaje esotérico llamado Brainfuck. Si usamos una herramienta como www.tutorialspoint.com, podemos obtener el resultado:
En resumen, tenemos:
p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 $p$ y $q$ parecen parámetros para un criptosistema RSA, y $c$ debe ser el texto cifrado. Sin embargo, necesitamos saber qué son $dp$ y $dq$.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>Se nos proporciona un texto cifrado:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Colliding Heritage</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/colliding-heritage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/colliding-heritage/</guid><description>Se nos proporciona el código fuente del servidor en Python:
#!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = "HTB{???????????????????????????}" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.</description></item><item><title>Converging Visions</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/converging-visions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/converging-visions/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from secret import FLAG, p, a, b from random import randint from utils import EllipticCurve class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.</description></item><item><title>CryptoConundrum</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/cryptoconundrum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/cryptoconundrum/</guid><description>Se nos proporciona el código fuente en Python para cifrar un mensaje:
from os import urandom from Crypto.Cipher import AES from secret import MESSAGE assert all([x.isupper() for x in MESSAGE]) assert MESSAGE.startswith('A') class Cipher: def __init__(self): self.salt = urandom(14) key = urandom(16) self.cipher = AES.new(key, AES.MODE_ECB) def encrypt(self, message): return [ self.cipher.encrypt(message[i:i + 2].encode() + self.salt) for i in range(len(message) - 1) ] def main(): cipher = Cipher() encrypted = cipher.</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>Ebola Virus</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/ebola-virus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/ebola-virus/</guid><description>Se nos proporcionan estos dos archivos:
$ cat key.txt CTGAAATGTTCCGCGAGCCGAACCGATTCACCGCCTAGAAACGTATTGTGCTGGTGTGCGGCGGTTAGAGATATTAGGTAGCGCCGTTACTCTAACATTTCGAATCAACCTTTCAGGGGAGTCACTGCCATCGTAAGTAGAGTACTTAGCATCGATGGCCATGCCTACTAATTACAGGCTGAATGACACTAAACCTTAGTTCACTGACCCGTTTTGTCATGTACTCTTGTGGTATGGGTCTTCAAATTGATCTGATTGGGAAGATAGAAAAACGGCTCTATCCTGGGTCGAGCCTCCCATGAAGCAGTCAAGGGGCCGCGAGGACTTCGATACTTGCCCTGCTCGAGCACATTTTAAAGCTTATTCCACATACTAGACTTACCCCCCGGCGTGTCGTACTGGAAGGTTAAACCTCTTGAGTTGATCTGACAACCTAGACGCGTGCCACGTTGTGTGGGATAGGTCACTCTCATTTCCACGAGGGACCAGAACCTTTGGCAATCCAGTTATTCTGCACTCGTGGCCGCCTCTCCTGGCAGGGGACCGGTAAGTTTGCGTATTCGCCGGGGAGTGGAGACGGATCGTCGTACACTGTTTCGAAAATTTTTGAGGATGGAGAGCAGAGCTATTGGATAAACGCTTGTACAGGTTCAATACTATTAGCAACGTGCCACCGGCACAGCTATCTCTGTTTCGCATGAAAGAGCCGTTAATCACGACGTTTAATCGAAACACATACCGATGGTCTACGAATATTATATCCGATACTAAGTCGGCCGCCGCAGTCCAGACGCCATATCGCTTTGAAGACCCCAAGGCGAACATTAACCGGTACGAGCAACTGCGGAGTGCCCTGCAATAGTCCGTCTGTAAAGGGCCCAGGCTAGGGCAAATAGTCCCTAAAACTAGAGATGGTCAACCGCTATGTGGGGCATTCTCCGTGAGACTCAGCCGTATTACAGTGAGCGTATTCCCAAACTCCCCTTCTGTGTATGACCAGTGTCGCTGCAAATGGACCGAGCAG $ xxd encrypted.bin 00000000: f3d3 8309 0748 15ee b309 8144 5dea a409 .....H.....D]... 00000010: 26b3 eaa4 83a4 09b3 6e09 b326 ea75 8323 &amp;.......n..&amp;.u.# 00000020: 09a4 835d 4415 eaa4 0944 eeee 6e83 a4a4 ...]D....D..n... 00000030: 0967 d344 26d3 0944 a409 154f 7583 6e09 .g.D&amp;..D...Ou.n. 00000040: 4fb3 75b3 ee09 444f 09ea 6e75 5d83 b375 O.u...DO..nu]..u 00000050: 83c3 f009 0748 15ee b309 8144 5dea a409 .</description></item><item><title>ElElGamal</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/elelgamal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/elelgamal/</guid><description>Tenemos esta descripción del reto:
After some minor warnings from IDS, you decide to check the logs to see if anything suspicious is happening. Surprised by what you see, you realize that one of your honeypots has been compromised with a cryptominer. As you look at the processes, you discover a backdoor attached to one of them. The backdoor retrieves the private key from the /key route of a C2. It establishes a session by sending an encrypted initialization sequence.</description></item><item><title>Elliptic Labyrinth</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/elliptic-labyrinth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/elliptic-labyrinth/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secret import FLAG class ECC: def __init__(self, bits): while True: self.p = getPrime(bits) if self.p % 4 == 3: break self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): x = randint(2, self.p-2) return (x, pow(x**3 + self.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/fast-carmichael/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from secret import FLAG from Crypto.Util.number import isPrime import socketserver import signal class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5) + 1, 2): if basis[i]: basis[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1) return [2] + [i for i in range(3, n, 2) if basis[i]] def millerRabin(n, b): basis = generate_basis(300) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def _isPrime(p): if p &amp;lt; 1: return False if (p.</description></item><item><title>Fibopadcci</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/fibopadcci/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/fibopadcci/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import socketserver from Crypto.Cipher import AES import os from secret import flag, key fib = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219, 61] wlc_msg = """ ------------------------------------------------------------------------- | Welcome to my Super Secure Encryption service! | | We use AES along with custom padding for authentication | | for extra security, so only admins should be able to | | decrypt the flag with the key I have provided them!</description></item><item><title>Find Marher's Secret</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</guid><description>Se nos proporciona un sódigo en Python y un servidor al que conectarnos:
$ nc 161.35.172.25 32275 Connected to the cyborg's debugging interface Options: 1. Encrypt your text. 2. Claim the key. &amp;gt; Análisis de código estático Esta es la parte importante del código:
def challenge(req): key = bytes.fromhex(KEY) assert(len(key) == 27) req.sendall(b'Connected to the cyborg\'s debugging interface\n') while True: req.sendall( b'\nOptions:\n1. Encrypt your text.\n2. Claim the key.\n&amp;gt; ') try: response = json.</description></item><item><title>Flippin Bank</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/flippin-bank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/flippin-bank/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import socketserver import socket, os from Crypto.Cipher import AES from Crypto.Util.Padding import pad,unpad from Crypto.Random import get_random_bytes from binascii import unhexlify from secret import FLAG wlcm_msg ='########################################################################\n'+\ '# Welcome to the Bank of the World #\n'+\ '# All connections are monitored and recorded #\n'+\ '# Disconnect IMMEDIATELY if you are not an authorized user! #\n'+\ '########################################################################\n' key = get_random_bytes(16) iv = get_random_bytes(16) def encrypt_data(data): padded = pad(data.</description></item><item><title>Gonna-Lift-Em-All</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/gonna-lift-em-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/gonna-lift-em-all/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getPrime import random FLAG = b'HTB{??????????????????????????????????????????????????????????????????????}' def gen_params(): p = getPrime(1024) g = random.randint(2, p-2) x = random.randint(2, p-2) h = pow(g, x, p) return (p, g, h), x def encrypt(pubkey): p, g, h = pubkey m = bytes_to_long(FLAG) y = random.randint(2, p-2) s = pow(h, y, p) return (g * y % p, m * s % p) def main(): pubkey, privkey = gen_params() c1, c2 = encrypt(pubkey) with open('data.</description></item><item><title>Hash the Filesystem</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</guid><description>Se nos proporciona un código fuente que nos pide iniciar sesión y nos ofrece algunas funcionalidades. Esta es la función principal:
def challenge(req): fnames = initializeDatabase() file_record['admin'] = [fname for fname in fnames] req.sendall(b'Super secret file server for malicious operations.\n' + b'Who are you:\n' + b'&amp;gt; ') user = req.recv(4096).decode().strip() if user == 'admin': req.sendall( b'Administrator can access the server only via ssh.\nGoodbye!\n') return token = json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] = [] key = os.</description></item><item><title>Homomurphy's Law</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/homomurphys-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/homomurphys-law/</guid><description>Se nos da el código fuente de un proyecto de ransomware.
Análisis de código fuente Este es ransomware.py:
from Crypto import Random from encryption import * import os MBEGIN = "---BEGIN MORPHEUS KEY---" MEND = "---END MORPHEUS KEY---" GBEGIN = "----BEGIN GPUBLIC KEY---" GEND = "---END GPUBLIC KEY---" with open("note.txt", "r") as f: note = f.read() aes = AESP() gm = GM() obf = OBF() def encrypt(key): obf_key = obf.obfuscate(key) enc_key = gm.</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:
import os with open('super_secret_messages.txt', 'r') as f: SUPER_SECRET_MESSAGES = [msg.strip() for msg in f.readlines()] def deriveKey(key): derived_key = [] for i, char in enumerate(key): previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): if previous_char &amp;gt; char: derived_key[j] += 1 else: new_number += 1 derived_key.append(new_number) return derived_key def transpose(array): return [row for row in map(list, zip(*array))] def flatten(array): return "</description></item><item><title>I know Mag1k</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/i-know-mag1k/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/i-know-mag1k/</guid><description>Se nos proporciona el siguiente sitio web:
En primer lugar, debemos registrar una nueva cuenta:
Ahora podemos iniciar sesión:
Y tenemos acceso a nuestro dashboard:
Podemos ver que el servidor establece dos cookies para manejar la autenticación:
Análisis del cifrado La que parece interesante es iknowmag1k, que está codificada en base64 (y codificación URL: %2B es +, %2F es / y %3D es =). Si lo decodificamos, tenemos 40 bytes que parecen aleatorios:</description></item><item><title>I'm gRoot</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/im-groot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/im-groot/</guid><description>Se nos proporciona el código fuente en Python de un servidor:
server.py: from pymerkle import InmemoryTree as MerkleTree from hashlib import sha256 from os import urandom from secret import FLAG from utils import * class Transaction: def __init__(self, _from, _to): self._from = _from self._to = _to self._signature = self.getSignature(self._from, self._to) def signature(self): return self._signature def getSignature(self, _from, _to): return sha256(_from + _to).digest() class Block: def __init__(self): self._transactions = [] def transactions(self): return self.</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</guid><description>Se nos proporciona un código en Python que implementa RSA de forma extraña (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Do neighbouring primes present a security risk?</description></item><item><title>Infinite Knapsack</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-knapsack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-knapsack/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from random import randint, seed, sample, getstate import math from secret import SEED, FLAG, INIT class MH: def __init__(self, size): keys = self.generateKeys(size) self.public_key = keys[0] self.private_key = keys[1] def generateKeys(self, n): private_key = [INIT] + [0 for _ in range(n - 1)] for i in range(1, n): total = sum(private_key) private_key[i] = randint(total * 2, total * 3) total = sum(private_key) modulo = randint(total * 2, total * 3) while True: multiplier = randint(modulo // 4, modulo - 1) if math.</description></item><item><title>Initialization</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/initialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/initialization/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
#!/usr/bin/env python3 import os from Crypto.Util import Counter from Crypto.Util.Padding import pad from Crypto.Cipher import AES class AdvancedEncryption: def __init__(self, block_size): self.KEYS = self.generate_encryption_keys() self.CTRs = [Counter.new(block_size) for i in range(len(MSG))] # nonce reuse : avoided! def generate_encryption_keys(self): keys = [[b'\x00']*16] * len(MSG) for i in range(len(keys)): for j in range(len(keys[i])): keys[i][j] = os.urandom(1) return keys def encrypt(self, i, msg): key = b''.</description></item><item><title>Inside The Matrix</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/inside-the-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/inside-the-matrix/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from utils import ascii_print import os from secret import FLAG from Crypto.Util.number import getPrime from matrix import Matrix from sympy import randprime assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return Matrix(self.prime, self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.</description></item><item><title>Interception</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/interception/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/interception/</guid><description>Se nos proporciona el código fuente en Python del servidor. Esto es server.py:
#!/usr/bin/env python3 import signal import random, os from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long from Crypto.Util.Padding import pad, unpad from Crypto.Cipher import AES from pool import GREET, ANS from secret import RESTRICTED class GRAS: def __init__(self, m, p, q): self.m = m self.a = 0xdeadbeef self.p = p self.q = q def generate_key(self): ct = 0x1337 # this loop runs in milliseconds in our super computer for _ in range(self.</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>Se nos proporciona este código fuente en Python:
from hashlib import sha256 from Crypto.Util.Padding import pad, unpad import signal import subprocess import socketserver import os allowed_commands = [b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE = 32 def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]+secret[i]) % 256 enc_block += bytes([val]) return enc_block def encrypt(msg, password): h = sha256(password).digest() if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' for block in blocks: enc_block = encrypt_block(block, h) h = sha256(enc_block + block).</description></item><item><title>LunaCrypt</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/lunacrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/lunacrypt/</guid><description>Se nos proporciona el resultado de un cifrado personalizado y su código fuente. Sin embargo, el código fuente es difícil de leer porque hay muchas funciones:
import math from random import randint, seed from time import time, process_time strchr = lambda x: chr(x) strbyt = lambda x, y=0: ord(x[y]) bitlst = lambda x, y: x &amp;lt;&amp;lt; y bitrst = lambda x, y: x &amp;gt;&amp;gt; y bitext = lambda x, y, z=1: bitrst(x, y) &amp;amp; int(math.</description></item><item><title>Mayday Mayday</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/mayday-mayday/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/mayday-mayday/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, GCD, bytes_to_long from secret import FLAG from random import randint class Crypto: def __init__(self, bits): self.bits = bits self.alpha = 1/9 self.delta = 1/4 self.known = int(self.bits*self.delta) def keygen(self): while True: p, q = [getPrime(self.bits//2) for _ in '__'] self.e = getPrime(int(self.bits*self.alpha)) φ = (p-1)*(q-1) try: dp = pow(self.e, -1, p-1) dq = pow(self.e, -1, q-1) self.</description></item><item><title>MSS</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/mss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/mss/</guid><description>Se nos proporciona el código fuente en Python del servidor:
import os, random, json from hashlib import sha256 from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secret import FLAG class MSS: def __init__(self, BITS, d, n): self.d = d self.n = n self.BITS = BITS self.key = bytes_to_long(os.urandom(BITS//8)) self.coeffs = [self.key] + [bytes_to_long(os.urandom(self.BITS//8)) for _ in range(self.d)] def poly(self, x): return sum([self.coeffs[i] * x**i for i in range(self.</description></item><item><title>Multipage Recyclings</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/multipage-recyclings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/multipage-recyclings/</guid><description>Se nos proporciona el código fuente del servidor en Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.</description></item><item><title>Nuclear Sale</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/nuclear-sale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/nuclear-sale/</guid><description>Se nos proporciona un archivo PCAP (challenge.pcap). Si lo analizamos con Wireshark, veremos unos emails en SMTP:
El reto está basado en una serie de correos enviados en una empresa. Hay información cifrada en ellos. Estos son los emails:
Hello everyone, A potential Buyer approached us asking for a HUGE amount of plutonium. Are we even allowed to sell this much? Best Regards, Sales Dept We are very XORry but the management does not approve such a sale.</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag, y una aplicación Flask que llama a la función de cifrado:
from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime, inverse import random FLAG = b'HTB{--REDACTED--}' p = getPrime(1024) q = getPrime(1024) n = p * q e = 257 def encrypt_flag(): a = random.getrandbits(1024) b = random.getrandbits(1024) flag = bytes_to_long(FLAG) msg = a*flag + b ct = pow(msg, e, n) return {'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} from flask import * from chall import encrypt_flag app = Flask(__name__) @app.</description></item><item><title>Optimus Prime</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/optimus-prime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/optimus-prime/</guid><description>Se nos proporciona una instancia remota a la que conectarnos. Tenemos algunas opciones:
$ nc 167.99.202.193 31899 Your people must learn to be masters of their own fate. 1. View status of the Transformer. 2. View Serial ID's of the Transformer. 3. Register new Transformer. 4. Enter to the access panel. Enter the option: 1 Battery: 60% Mechanical damages: 14% Heat: 64.76 ºC Ncat: Broken pipe. $ nc 167.99.202.193 31899 Your volume, like any capability, is also a responsibility.</description></item><item><title>Oracle Leaks</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/oracle-leaks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/oracle-leaks/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import os import math from Crypto.Util.number import * from cryptography.hazmat.primitives.asymmetric import rsa def get_length(pt): res = 0 if (len(bin(pt)) - 2) % 8 != 0: res += 1 res += (len(bin(pt)) - 2) // 8 return res def ceil(a, b): return -(-a // b) class RSA: def __init__(self, size): self.e = 0x10001 self.size = size priv = rsa.generate_private_key( public_exponent=self.e, key_size=size ) pub = priv.</description></item><item><title>Perfect Synchronization</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/perfect-synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/perfect-synchronization/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from os import urandom from Crypto.Cipher import AES from secret import MESSAGE assert all([x.isupper() or x in '{_} ' for x in MESSAGE]) class Cipher: def __init__(self): self.salt = urandom(15) key = urandom(16) self.cipher = AES.new(key, AES.MODE_ECB) def encrypt(self, message): return [self.cipher.encrypt(c.encode() + self.salt) for c in message] def main(): cipher = Cipher() encrypted = cipher.encrypt(MESSAGE) encrypted = "</description></item><item><title>RLotto</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/rlotto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/rlotto/</guid><description>Se nos proporciona el código fuente de un servidor que nos da cinco números y el objetivo es adivinar los cinco números siguientes para ganar la lotería:
$ nc 46.101.63.21 31102 __/\____/\____/\____/\____/\____/\____/\____/\__ \ /\ /\ /\ /\ /\ /\ /\ / /_ _\/_ _\/_ _\/_ _\/_ _\/_ _\/_ _\/_ _\ \/ \/ \/ \/ \/ \/ \/ \/ __ _ _ ____ ___ ____ ___ / / ___ | |_| |_ ___|___ \ / _ \___ \ / _ \ / / / _ \| __| __/ _ \ __) | | | |__) | | | | / /__| (_) | |_| || (_) / __/| |_| / __/| |_| | \____/\___/ \__|\__\___/_____|\___/_____|\___/ __/\____/\____/\____/\____/\____/\____/\____/\__ \ /\ /\ /\ /\ /\ /\ /\ / /_ _\/_ _\/_ _\/_ _\/_ _\/_ _\/_ _\/_ _\ \/ \/ \/ \/ \/ \/ \/ \/ ------------------------------------------------ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ------------------------------------------------ [+] EXTRACTION: 11 32 87 35 89 [?</description></item><item><title>Rookie Mistake</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/rookie-mistake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/rookie-mistake/</guid><description>Se nos proporciona el código fuente en Python donde se cifra la flag:
import os from Crypto.Util.number import bytes_to_long, getPrime from sympy import * from secret import flag flag1 = bytes_to_long(flag[:len(flag)//2] + os.urandom(69)) flag2 = bytes_to_long(flag[len(flag)//2:] + os.urandom(200)) def genprime(): p = 2 while p.bit_length() &amp;lt; 1020: p *= getPrime(30) while True: x = getPrime(16) if isprime((p * x) + 1): return (p * x) + 1 break p,q = [genprime() for _ in range(2)] print("</description></item><item><title>Roulette</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/roulette/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/roulette/</guid><description>Se nos proporciona el código fuente del servidor en Python:
import socketserver import signal from twister import Twister def handle(self): signal.alarm(500) self.write("Welcome to the Casino") self.write("We are playing roulette today") money = 50 random = Twister() self.write("The wheel stops on a number between 0 and 31.") self.write("\n") while money &amp;gt; 0: self.write("You have {} coins".format(money)) self.write("What would you like to bet on:") self.write("1) Even") self.write("2) Odd") self.write("3) Number") option = int(self.</description></item><item><title>RsaCtfTool</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/rsactftool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/rsactftool/</guid><description>Se nos proporciona una clave pública de RSA en formato PEM (pubkey.pem):
-----BEGIN PUBLIC KEY----- MIHeMA0GCSqGSIb3DQEBAQUAA4HMADCByAKBwHfR4yv+QfsHYSvLlS6LGW2cMDlB 3RlH1PteD7gN6nU4KhyMlRznOUQI7cgB082btMWs1usPYfUSrqkDs+1EDrzzw42M G683YvLlJRfcO2syc+YNJTDqtVHW5V3SNJ2J+WKCw0A5+ab2qA+sfhRFhvPJ7gsL vUj+blt5qweyGVheMOQvy+WXI+Vi/jwtlW3it25kBLZUoESDBg+HZKnxz3MgcJ6X roMdjPPwTH2f8sOrCTI1jJzNUYxJ9JQ0QPTrxwIDAQAB -----END PUBLIC KEY----- Podemos abrirla con Python para ver qué valores tenemos:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; with open('pubkey.pem') as f: ... key = RSA.import_key(f.read()) ... &amp;gt;&amp;gt;&amp;gt; key.e 65537 &amp;gt;&amp;gt;&amp;gt; key.n 1128137999850045612492145429133282716267233566834715456536184965477269592934207986950131365518741418540788596074115883774105736493742449131477464976858161587355643311888741515506653603321337485523828144179637379528510277430032789458804637543905426347328041281785616616421292879871785633181756858096548411753919440011378411476275900648915887370219369154688926914542233244450724820670256654513052812215949495598592852131398736567134556141744727764716053145639513031 Podemos tratar de factorizar el módulo $n$ para obtener los números primos privados $p$ y $q$ de un criptosistema RSA común.</description></item><item><title>signup</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/signup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/signup/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag (app.py):
from Crypto.Util.number import getPrime, getRandomRange, isPrime, inverse, long_to_bytes, bytes_to_long from hashlib import sha512 from random import SystemRandom from FLAG import flag L = 2048 N = 256 def repeating_xor_key(message, key): repeation = 1 + (len(message) // len(key)) key = key * repeation key = key[:len(message)] msg = bytes([c ^ k for c, k in zip(message, key)]) return msg def domain_params_generation(): q = getPrime(N) print(f"</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</guid><description>Se nos proporciona el siguiente código en Python:
from sympy import * from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randint, randbytes, seed FLAG = b'HTB{dummyflag}' class Shamir: def __init__(self, prime, k, n): self.p = prime self.secret = randint(1, self.p - 1) self.k = k self.n = n self.coeffs = [self.secret] self.x_vals = [] self.y_vals = [] def next_coeff(self, val): return int(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) def calc_coeffs(self): for i in range(1, self.</description></item><item><title>SPG</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/spg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/spg/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from hashlib import sha256 import string, random from secret import MASTER_KEY, FLAG from Crypto.Cipher import AES from Crypto.Util.Padding import pad from base64 import b64encode ALPHABET = string.ascii_letters + string.digits + '~!@#$%^&amp;amp;*' def generate_password(): master_key = int.from_bytes(MASTER_KEY, 'little') password = '' while master_key: bit = master_key &amp;amp; 1 if bit: password += random.choice(ALPHABET[:len(ALPHABET)//2]) else: password += random.choice(ALPHABET[len(ALPHABET)//2:]) master_key &amp;gt;&amp;gt;= 1 return password def main(): password = generate_password() encryption_key = sha256(MASTER_KEY).</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/spooky-rsa/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
from Crypto.Util.number import bytes_to_long, getStrongPrime from random import randint FLAG = b'HTB{????????????????????????????????????????????}' def key_gen(bits): p, q = getStrongPrime(bits), getStrongPrime(bits) N = p * q return N, (p, q) def encrypt(m, N, f): e1, e2 = randint(2, N - 2), randint(2, N - 2) c1 = (pow(f, e1, N) + m) % N c2 = (pow(f, e2, N) + m) % N return (e1, c1), (e2, c2) def main(): N, priv = key_gen(1024) m = bytes_to_long(FLAG) (e1, c1), (e2, c2) = encrypt(m, N, priv[0]) with open('out.</description></item><item><title>Symbols</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/symbols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/symbols/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from secret import FLAG from random import randint p = 307163712384204009961137975465657319439 g = 1337 def encrypt(m): bits = bin(m)[2:] encrypted = [] for b in bits: r = (randint(2, p) &amp;lt;&amp;lt; 1) + int(b) encrypted.append(pow(g, r, p)) return encrypted def main(): flag = int.from_bytes(FLAG, 'big') encrypted_flag = encrypt(flag) with open('output.txt', 'w') as f: f.write(str(encrypted_flag)) if __name__ == '__main__': main() Y también tenemos la salida del script:</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>Se nos proporciona el siguiente código en Python:
from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random import signal import subprocess import socketserver FLAG = b'HTB{--REDACTED--}' prefix = random.randbytes(12) key = random.randbytes(16) def encrypt(key, msg): msg = bytes.fromhex(msg) crypto = AES.new(key, AES.MODE_ECB) padded = pad(prefix + msg + FLAG, 16) return crypto.encrypt(padded).hex() def challenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n' + b'It seems like there is a prefix appended to the real firmware\n' + b'Can you somehow extract the firmware and fix the chip?</description></item><item><title>TurboCipher</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/turbocipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/turbocipher/</guid><description>Este es un reto que diseñé para Hack the Box. Se nos proporciona el código fuente en Python del servidor:
#!/usr/bin/env python3 from Crypto.Util.number import bytes_to_long, getPrime, getRandomRange from secret import FLAG, fast_turbonacci, fast_turbocrypt from typing import Callable def turbonacci(n: int, p: int, b: int, c: int) -&amp;gt; int: if n &amp;lt; 2: return n return (b * turbonacci(n - 1, p, b, c) + c * turbonacci(n - 2, p, b, c)) % p def lcg(x: int, m: int, n: int, p: int) -&amp;gt; int: return (m * x + n) % p def turbocrypt(pt: int, k: int, f: Callable[[int], int]) -&amp;gt; int: return sum((f(i + 1) - f(i)) for i in range(k, pt)) def menu() -&amp;gt; int: print('Choose one option') print('1.</description></item><item><title>TwoForOne</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/twoforone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/twoforone/</guid><description>Se nos proporcionan dos claves públicas en formato PEM:
-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxqy430huZnHUpVZIA+HD IUqOJ03grABD7CjIWJ83fH6NMIvD4wKFA4Q0S6eYiIViCkGOatlVV4KE/ATyifEm s4oBgWJRzvmhT9TCSdlraQh/qRsuGtvcgMuW/wzLYSnY9nN9qFDEUfLtP2y2HDaJ Hckk0Kso8mrfDtNXzoSNAv/gCRJxTM9jcsH0EIDoZ0egMD61zfbOkS8RRP1PVXQ8 eWh1oU/f+Pi2YhUMVr5YsJI5dx3ETZaQecStj9mTvGMLeFXS4C6L4Wgk3NWrOBMj HBcxEQqL0CjXod+riS51KUVXuvxxrq9eSNsCZ6bbY9NQ+ZUGjuHK1tMt8RpJvSS6 lwIDAQAB -----END PUBLIC KEY----- -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxqy430huZnHUpVZIA+HD IUqOJ03grABD7CjIWJ83fH6NMIvD4wKFA4Q0S6eYiIViCkGOatlVV4KE/ATyifEm s4oBgWJRzvmhT9TCSdlraQh/qRsuGtvcgMuW/wzLYSnY9nN9qFDEUfLtP2y2HDaJ Hckk0Kso8mrfDtNXzoSNAv/gCRJxTM9jcsH0EIDoZ0egMD61zfbOkS8RRP1PVXQ8 eWh1oU/f+Pi2YhUMVr5YsJI5dx3ETZaQecStj9mTvGMLeFXS4C6L4Wgk3NWrOBMj HBcxEQqL0CjXod+riS51KUVXuvxxrq9eSNsCZ6bbY9NQ+ZUGjuHK1tMt8RpJvSS6 lwIDBTy3 -----END PUBLIC KEY----- Y tenemos también dos textos cifrados que están asociados a las claves públicas anteriores. Es importante mencionar que el mensaje es el mismo:
RBVdQw7Pllwb42GDYyRa6ByVOfzRrZHmxBkUPD393zxOcrNRZgfub1mqcrAgX4PAsvAOWptJSHbrHctFm6rJLzhBi/rAsKGboWqPAWYIu49Rt7Sc/5+LE2dvy5zriAKclchv9d+uUJ4/kU/vcpg2qlfTnyor6naBsZQvRze0VCMkPvqWPuE6iL6YEAjZmLWmb+bqO+unTLF4YtM1MkKTtiOEy+Bbd4LxlXIO1KSFVOoGjyLW2pVIgKzotB1/9BwJMKJV14/+MUEiP40ehH0U2zr8BeueeXp6NIZwS/9svmvmVi06Np74EbL+aeB4meaXH22fJU0eyL2FppeyvbVaYQ== TSHSOfFBkK/sSE4vWxy00EAnZXrIsBI/Y6mGv466baOsST+qyYXHdPsI33Kr6ovucDjgDw/VvQtsAuGhthLbLVdldt9OWDhK5lbM6e0CuhKSoJntnvCz7GtZvjgPM7JDHQkAU7Pcyall9UEqL+W6ZCkiSQnK+j6QB7ynwCsW1wAmnCM68fY2HaBvd8RP2+rPgWv9grcEBkXf7ewA+sxSw7hahMaW0LYhsMYUggrcKqhofGgl+4UR5pdSiFg4YKUSgdSw1Ic/tug9vfHuLSiiuhrtP38yVzazqOZPXGxG4tQ6btc1helH0cLfw1SCdua1ejyan9l1GLXsAyGOKSFdKw== Las claves públicas parecen muy similares. Vamos a importarlas con Python y ver los valores de $n$ y de $e$:</description></item><item><title>Vitrium Stash</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/vitrium-stash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/vitrium-stash/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from Crypto.Util.number import * from secrets import * import json """ from Crypto.PublicKey import DSA k = DSA.generate(2048) print(f"{k.p = }") print(f"{k.q = }") print(f"{k.g = }") """ p = 30514860220781649196505378618677588344627509796136052197766721133333403517227804826248671926331671978511695325934422209350872533631963158343821543243314354301612941382823755283391175569282500778759917825290265500008435125458284371701669393617263164707568562478942069967845682300866897274415749964510071038555145487346022921591488265881313448995313340365972250251431925090356830155846705412769705029295847471355919584592321591959772488755986181054597974081870037624260173234561447688627353479361867003340196122160639547860024025674714107946196423198018724048310862485718766310003158603549746994074302705926658218700843 q = 26189572440233739420990528170531051459310363621928135990243626537967 g = 6111748161621056558453263711027460170929636824002846224800107291166700007147256826554286465237732729099376511591848799483754962591483370638607627034808201246023891469880792589537431156477847873086973414247654773443349132863425799271140168302068820170758172107172379842519843597077356839020025609506792115532019927453283319270046204956352057936972814681479252626295814756888943630138110534869191473166355939365725603055249365076889191708484425425599800051451167006426087674425090967640170968963795028092131692666710522291627118158125917935888441403300632869010691598781782043810771106247022549721544793735832383283054 x = randbelow(p) y = pow(g, x, p) def sign(message): m = bytes_to_long(message) k = randbelow(p) r = pow(g, k, p) % q s = (inverse(k, q) * (m + x*r)) % q return r, s def verify(message, r, s): assert 0 &amp;lt; r &amp;lt; q assert 0 &amp;lt; s &amp;lt; q m = bytes_to_long(message) w = pow(s, -1, q) u1 = (m * w) % q u2 = (r * w) % q v = ((pow(g, u1, p) * pow(y, u2, p)) % p) % q return r == v menu = "</description></item><item><title>Waiting List</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/waiting-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/waiting-list/</guid><description>Se nos proporciona el código fuente del servidor en Python (challenge.py):
import json import signal import subprocess import socketserver from hashlib import sha1 from random import randint from Crypto.Util.number import bytes_to_long, long_to_bytes FLAG = 'HTB{dummyflag}' class ECDSA: def __init__(self): self.n = 115792089210356248762697446949407573529996955224135760342422259061068512044369 self.k = 0 self.g = 5 self.key = ... #choose your own key def sign(self, pt): h = sha1(pt).digest() h = bytes_to_long(h) h = bin(h)[2:] h = int(h[:len(bin(self.n)[2:])], 2) self.</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</guid><description>Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo. Luego, se coge un exponente $e$ (típicamente $e = 65537$) y se cifra el mensage $m$ en formato decimal:</description></item><item><title>Whole Lotta Candy</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/whole-lotta-candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/whole-lotta-candy/</guid><description>Se nos proporciona el código fuente en Python del servidor:
from encrypt import Encryptor from secret import FLAG import socketserver import random import signal import json MODES = ['ECB', 'CBC', 'CFB', 'OFB', 'CTR'] class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def receiveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def main(s): mode = random.choice(MODES) enc = Encryptor() while True: try: sendMessage(s, f"Please interact with the server using json data!</description></item><item><title>Zombie Rolled</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/zombie-rolled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/zombie-rolled/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, bytes_to_long from fractions import Fraction from math import prod from hashlib import sha256 from secrets import randbelow # I hope no one cares about Kerckhoff's principle :) from secret import derive_public_key, FLAG def fraction_mod(f, n): return f.numerator * pow(f.denominator, -1, n) % n class PublicKey: def __init__(self, pub, n): self.pub = pub self.f = self.</description></item></channel></rss>