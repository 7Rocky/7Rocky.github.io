<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reversing on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/</link><description>Recent content in Reversing on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/reversing/index.xml" rel="self" type="application/rss+xml"/><item><title>Alien Saboteaur</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/alien-saboteaur/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/alien-saboteaur/</guid><description>Se nos proporciona un archivo binario llamado vm y un programa llamado bin:
$ file * bin: data vm: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=10fb238b19d3a82b46536b51e47396525086a09c, for GNU/Linux 3.2.0, not stripped Configuración del entorno El binario necesita una versión reciente de Glibc para funcionar:
$ ./vm ./vm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./vm) Para resolver este problema, podemos ejecutar Ubuntu 22.04 en un contenedor de Docker y tomar la librería y el cargador para parchear el binario:</description></item><item><title>Anti Flag</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/anti-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/anti-flag/</guid><description>Se nos proporciona un binario llamado anti_flag:
$ file anti_flag anti_flag: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b8de97bc12c627606510140e43fc13e2efffcee5, for GNU/Linux 3.2.0, stripped Descompilación Si lo abrimos en Ghidra, veremos esta función main:
/* WARNING: Removing unreachable block (ram,0x00101525) */ undefined8 main(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5, undefined8 param_6) { size_t sVar1; long lVar2; sVar1 = strlen(&amp;amp;DAT_00102011); malloc(sVar1 &amp;lt;&amp;lt; 2); lVar2 = ptrace(PTRACE_TRACEME, 0, 1, 0, param_5, param_6, param_2); if (lVar2 == -1) { puts("</description></item><item><title>Baby Crypt</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</guid><description>Se nos proporciona un binario llamado baby_crypt:
$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped Si lo abrimos en Ghidra, veremos esta función main:
int main() { char *key; long in_FS_OFFSET; int i; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); printf("Give me the key and I\'ll give you the flag: "</description></item><item><title>Baby RE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</guid><description>Se nos proporciona un binario llamado baby:
$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped Si lo ejecutamos, pregunta por una clave:
$ ./baby Insert key: Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: 1234 Try again later. Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item><item><title>ChromeMiner</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/chromeminer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/chromeminer/</guid><description>Tenemos un sitio web fraudulento de Discord que se ve así:
Descompilación de C# .NET Si pinchamos en &amp;ldquo;Login&amp;rdquo;, descargaremos un ejecutable de Windows llamado DiscurdNitru.exe:
$ file DiscurdNitru.exe DiscurdNitru.exe: PE32+ executable (console) x86-64 Mono/.Net assembly, for MS Windows Si analizamos las strings, veremos que el ejecutable está compilado desde C# .NET:
$ strings DiscurdNitru.exe | grep .NET .NETFramework,Version=v4.6 .NET Framework 4.6 Por lo tanto, podemos usar JetBrains dotPeek para descompilar el archivo:</description></item><item><title>Curse Breaker</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/curse-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/curse-breaker/</guid><description>Se nos proporciona un binario llamado breaker:
$ file breaker breaker: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=203d702c3e6cc789e148886f986713f7cf21e2c2, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Usando Ghidra, podemos leer el código fuente descompilado en C. Esta es la función main:
int main() { size_t newline_index; long i5; char magic_word[50]; uint i; magic_word._0_8_ = 0; magic_word._8_8_ = 0; magic_word._16_8_ = 0; magic_word._24_8_ = 0; magic_word.</description></item><item><title>Eat the Cake!</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/eat-the-cake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/eat-the-cake/</guid><description>Tenemos un Windows PE llamado cake.exe:
$ file cake.exe cake.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed Descompresión Como se puede ver, está comprimido con UPX, así que vamos a descomprimirlo:
$ upx -d cake.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2023 UPX 4.0.2 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Jan 30th 2023 File size Ratio Format Name -------------------- ------ ----------- ----------- 15872 &amp;lt;- 9216 58.</description></item><item><title>Find The Easy Pass</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</guid><description>Se nos proporciona un binario de 32 bits llamado EasyPass.exe que es un archivo Windows PE:
$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows Si lo ejecutamos en una máquina Windows, nos preguntará por una contraseña:
Como la contraseña será incorrecta, veremos un mensaje &amp;ldquo;Wrong Password!&amp;rdquo;:
Un análisis de código estático con Ghidra no es útil. Por tanto, vamos a utilizar un depurador como x32dbg para depurar el binario.</description></item><item><title>Headache</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/headache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/headache/</guid><description>Tenemos un binario llamado headache:
$ file headache headache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped Reconocimiento básico Al ejecutarlo, escribe Initialising y tras unos segundos, nos pregunta por una clave:
$ ./headache Initialising..... Enter the key: asdf Login Failed! Vamos a depurarlo un poco con GDB. Una vez que nos pide la clave, podemos presionar ^C y poner un breakpoint después de la instrucción read:</description></item><item><title>Hissss</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/hissss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/hissss/</guid><description>Se nos proporciona un binario llamado auth:
$ file auth auth: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=3507aa01d32c34dc8e8c6462b764adb90a82768d, stripped Descompilaciónn Si miramos las strings del binario, encontraremos muchas referencias a Python:
$ strings auth | grep python b_asyncio.cpython-38-x86_64-linux-gnu.so b_bisect.cpython-38-x86_64-linux-gnu.so b_blake2.cpython-38-x86_64-linux-gnu.so b_bz2.cpython-38-x86_64-linux-gnu.so b_codecs_cn.cpython-38-x86_64-linux-gnu.so b_codecs_hk.cpython-38-x86_64-linux-gnu.so b_codecs_iso2022.cpython-38-x86_64-linux-gnu.so b_codecs_jp.cpython-38-x86_64-linux-gnu.so b_codecs_kr.cpython-38-x86_64-linux-gnu.so b_codecs_tw.cpython-38-x86_64-linux-gnu.so b_contextvars.cpython-38-x86_64-linux-gnu.so b_csv.cpython-38-x86_64-linux-gnu.so b_ctypes.cpython-38-x86_64-linux-gnu.so b_datetime.cpython-38-x86_64-linux-gnu.so b_decimal.cpython-38-x86_64-linux-gnu.so b_hashlib.cpython-38-x86_64-linux-gnu.so b_heapq.cpython-38-x86_64-linux-gnu.so b_lzma.cpython-38-x86_64-linux-gnu.so b_md5.cpython-38-x86_64-linux-gnu.so b_multibytecodec.cpython-38-x86_64-linux-gnu.so b_multiprocessing.cpython-38-x86_64-linux-gnu.so b_opcode.cpython-38-x86_64-linux-gnu.so b_pickle.cpython-38-x86_64-linux-gnu.so b_posixshmem.</description></item><item><title>Hunting License</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/hunting-license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/hunting-license/</guid><description>Se nos proporciona un binario llamado license:
$ file license license: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5be88c3ed329c1570ab807b55c1875d429a581a7, for GNU/Linux 3.2.0, not stripped $ ldd license linux-vdso.so.1 (0x00007ffe18bb1000) libreadline.so.8 => /lib/x86_64-linux-gnu/libreadline.so.8 (0x00007f430a30a000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f430a118000) libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f430a0e8000) /lib64/ld-linux-x86-64.so.2 (0x00007f430a366000) Descompilación Si lo abrimos en Ghidra, veremos esta función main:
int main() { char cVar1; int iVar2; puts("So, you want to be a relic hunter?</description></item><item><title>IRCware</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/ircware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/ircware/</guid><description>Tenemos un binario llamado ircware:
$ file ircware ircware: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped Análisis básico Si lo abrimos en Ghidra de inmediato, el código en C descompilado será muy difícil de entender porque el binario está despojado de sus símbolos. En su lugar, podemos intentar ejecutarlo:
$ ./ircware EXCEPTION! ABORT Bueno, nada útil. Con ltrace podemos registrar todas las llamadas a funciones externas:</description></item><item><title>Ouija</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/ouija/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/ouija/</guid><description>Se nos proporciona un binario llamado ouija:
$ file ouija ouija: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=53a9e0435f7c7041c557e9d4a8418cb6a916f339, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Si lo abrimos en Ghidra, veremos el código en C descompilado de la función main:
int main() { undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined4 local_60; undefined2 local_5c; undefined local_5a; int key_copy; int r; int m; int o; int n; int q; int p; int l; char *enc_flag; int k; int j; int i; local_78 = 0x6877644b7b544c5a; local_70 = 0x665f6b615f796661; local_68 = 0x6b6d7874675f6c67; local_60 = 0x616c7375; local_5c = 0x6667; local_5a = 0x7d; setvbuf(stdout, NULL, 2, 0); enc_flag = strdup((char *) &amp;amp;local_78); puts("</description></item><item><title>Potion Master</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/potion-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/potion-master/</guid><description>Se nos proporciona un script en Haskell llamado potion.hs:
import Data.Char (ord) import Data.Bits (xor) -- Complete the incantation... flag = "HTB{XXX}" extractFlag :: String -&amp;gt; String extractFlag (s:rest) | s == 'H' || s == 'T' || s == 'B' = extractFlag rest | s == '{' &amp;&amp; last rest == '}' = init rest | otherwise = error ("Invalid format") chunks :: Int -&amp;gt; [a] -&amp;gt; [[a]] chunks n l | n == 0 = [] | n == 1 = [[x] | x &amp;lt;- l] | length l &amp;lt;= n = [l] | otherwise = [take n l] ++ (chunks n (drop n l)) takeLast :: Int -&amp;gt; [a] -&amp;gt; [a] takeLast n = reverse .</description></item><item><title>Ransom</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/ransom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/ransom/</guid><description>Tenemos un Windows PE llamado windows_update.exe:
$ file windows_update.exe windows_update.exe: PE32+ executable (console) x86-64, for MS Windows Además, hay otro archivo que parece cifrado desde login.xlsx:
$ file login.xlsx.enc login.xlsx.enc: data Descompilación Si abrimos el Windows PE en Ghidra, veremos esta función main:
int __cdecl main(int _Argc, char **_Argv, char **_Env) { char *filename; __main(); if (_Argc == 1) { filename = "C:\\Users"; } else if (_Argc == 2) { filename = _Argv[1]; } else { printf("</description></item><item><title>Rebuilding</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</guid><description>Se nos proporciona un binario llamado rebuilding:
$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped Si lo ejecutamos, nos pide poner un argumento de línea de comandos:
$ ./rebuilding Preparing secret keys Missing required argument Vamos a abrirlo en Ghidra para descompilarlo. Esta es la función main:
undefined8 main(int argc, long argv) { int __c; size_t length; undefined8 ret; int checks; int i; int j; if (argc !</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/secured-transfer/</guid><description>Se nos proporciona un archivo binario llamado securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped También tenemos un archivo de captura de red llamado trace.pcap.
Análisis de tráfico Comenzando por trace.pcap, podemos usar Wireshark para analizar la captura de red:
Solamente hay un segmento TCP que contiene datos:
17275a3d9163b2798392813bf5e6826657bd11426076c910a38b68c2bcbbd3a5 Ingeniería inversa Podemos usar Ghidra para leer el código descompilado en C.</description></item><item><title>Sekure Decrypt</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/sekure-decrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/sekure-decrypt/</guid><description>Se nos proporciona un binario llamado dec, el código fuente en C (src.c) y un archivo core (core):
$ file dec dec: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=daf03fccbc32333244dc0f36e874e27457110af1, for GNU/Linux 3.2.0, with debug_info, not stripped $ file core core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './dec', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: '.</description></item><item><title>Shattered Tablet</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/shattered-tablet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/shattered-tablet/</guid><description>Se nos proporciona un binario llamado tablet:
$ file tablet tablet: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=71ad3ff9f7e5fbf0edc75446337a0a68deb7ecd6, for GNU/Linux 3.2.0, not stripped Descompilación Si lo abrimos en Ghidra, veremos esta función main:
/* WARNING: Could not reconcile some variable overlaps */ undefined8 main(void) { undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; local_48 = 0; local_40 = 0; local_38 = 0; local_30 = 0; local_28 = 0; local_20 = 0; local_18 = 0; local_10 = 0; printf("</description></item><item><title>Snakecode</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</guid><description>Se nos proporciona un binario llamado chall.pyc, por lo que sabemos que es un binario compilado mediante Python:
$ file chall.pyc chall.pyc: python 2.7 byte-compiled En primer lugar, podemos extraer el código fuente en Python usando uncompyle6. Como está compilado con python2.7, podemos emplear un contenedor de Docker para ello:
$ docker run -v "$PWD":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020.</description></item><item><title>Teleport</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</guid><description>Se nos proporciona un binario llamado teleport:
$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped Si lo ejecutamos, nos pregunta por una contraseña:
$ ./teleport Missing password Podemos probar a añadirla como argumento de línea de comandos:
$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong... Con ltrace podemos ver que nuestra entrada se copia en una dirección de memoria y luego hay un montón de saltos (44 llamadas a _setjmp):</description></item><item><title>The Vault</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/the-vault/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/the-vault/</guid><description>Se nos da un binario llamado vault:
$ file vault vault: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped Descompilación Abrimos Ghidra para descompilarlo. Esta es la función entry:
void processEntry entry(undefined8 param_1, undefined8 param_2) { undefined auStack_8[8]; __libc_start_main(FUN_0010c450, param_2, &amp;amp;stack0x00000008, FUN_0010d460, FUN_0010d4d0, param_1, auStack_8); do { // WARNING: Do nothing block with infinite loop } while (true); } Entonces, la función &amp;ldquo;main&amp;rdquo; es FUN_0010c450 (el nombre de la función es su dirección porque el binario está despojado de sus símbolos), que solo llama a otra:</description></item><item><title>WIDE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</guid><description>Se nos proporciona un binario de 64 bits llamado wide y otro archivo llamado db.ex con algunas cadenas de texto:
$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe Si ejeutamos el binario tenemos lo siguiente:</description></item><item><title>You Cant C Me</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</guid><description>Se nos proporciona un binario llamado auth:
$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped Si lo ejecutamos, pregunta por una clave:
$ ./auth Welcome! Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: asdf I said, you can't c me! Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item></channel></rss>