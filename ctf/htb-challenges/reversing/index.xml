<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reversing on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/</link><description>Recent content in Reversing on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/reversing/index.xml" rel="self" type="application/rss+xml"/><item><title>Anti Flag</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/anti-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/anti-flag/</guid><description>Se nos proporciona un binario llamado anti_flag:
$ file anti_flag anti_flag: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b8de97bc12c627606510140e43fc13e2efffcee5, for GNU/Linux 3.2.0, stripped Descompilación Si lo abrimos en Ghidra, veremos esta función main:
/* WARNING: Removing unreachable block (ram,0x00101525) */ undefined8 main(undefined8 param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4, undefined8 param_5, undefined8 param_6) { size_t sVar1; long lVar2; sVar1 = strlen(&amp;amp;DAT_00102011); malloc(sVar1 &amp;lt;&amp;lt; 2); lVar2 = ptrace(PTRACE_TRACEME, 0, 1, 0, param_5, param_6, param_2); if (lVar2 == -1) { puts("</description></item><item><title>Baby Crypt</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</guid><description>Se nos proporciona un binario llamado baby_crypt:
$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped Si lo abrimos en Ghidra, veremos esta función main:
int main() { char *key; long in_FS_OFFSET; int i; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); printf("Give me the key and I\'ll give you the flag: "</description></item><item><title>Baby RE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</guid><description>Se nos proporciona un binario llamado baby:
$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped Si lo ejecutamos, pregunta por una clave:
$ ./baby Insert key: Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: 1234 Try again later. Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item><item><title>Find The Easy Pass</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</guid><description>Se nos proporciona un binario de 32 bits llamado EasyPass.exe que es un archivo Windows PE:
$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows Si lo ejecutamos en una máquina Windows, nos preguntará por una contraseña:
Como la contraseña será incorrecta, veremos un mensaje &amp;ldquo;Wrong Password!&amp;rdquo;:
Un análisis de código estático con Ghidra no es útil. Por tanto, vamos a utilizar un depurador como x32dbg para depurar el binario.</description></item><item><title>Ouija</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/ouija/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/ouija/</guid><description>Se nos proporciona un binario llamado ouija:
$ file ouija ouija: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=53a9e0435f7c7041c557e9d4a8418cb6a916f339, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Si lo abrimos en Ghidra, veremos el código en C descompilado de la función main:
int main() { undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined4 local_60; undefined2 local_5c; undefined local_5a; int key_copy; int r; int m; int o; int n; int q; int p; int l; char *enc_flag; int k; int j; int i; local_78 = 0x6877644b7b544c5a; local_70 = 0x665f6b615f796661; local_68 = 0x6b6d7874675f6c67; local_60 = 0x616c7375; local_5c = 0x6667; local_5a = 0x7d; setvbuf(stdout, NULL, 2, 0); enc_flag = strdup((char *) &amp;amp;local_78); puts("</description></item><item><title>Potion Master</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/potion-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/potion-master/</guid><description>Se nos proporciona un script en Haskell llamado potion.hs:
import Data.Char (ord) import Data.Bits (xor) -- Complete the incantation... flag = "HTB{XXX}" extractFlag :: String -&amp;gt; String extractFlag (s:rest) | s == 'H' || s == 'T' || s == 'B' = extractFlag rest | s == '{' &amp;&amp; last rest == '}' = init rest | otherwise = error ("Invalid format") chunks :: Int -&amp;gt; [a] -&amp;gt; [[a]] chunks n l | n == 0 = [] | n == 1 = [[x] | x &amp;lt;- l] | length l &amp;lt;= n = [l] | otherwise = [take n l] ++ (chunks n (drop n l)) takeLast :: Int -&amp;gt; [a] -&amp;gt; [a] takeLast n = reverse .</description></item><item><title>Rebuilding</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</guid><description>Se nos proporciona un binario llamado rebuilding:
$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped Si lo ejecutamos, nos pide poner un argumento de línea de comandos:
$ ./rebuilding Preparing secret keys Missing required argument Vamos a abrirlo en Ghidra para descompilarlo. Esta es la función main:
undefined8 main(int argc, long argv) { int __c; size_t length; undefined8 ret; int checks; int i; int j; if (argc !</description></item><item><title>Secured Transfer</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/secured-transfer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/secured-transfer/</guid><description>Se nos proporciona un archivo binario llamado securetransfer:
$ file securetransfer securetransfer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0457997eda987eb100de85a2954fc8b8fc660a53, for GNU/Linux 3.2.0, stripped También tenemos un archivo de captura de red llamado trace.pcap.
Análisis de tráfico Comenzando por trace.pcap, podemos usar Wireshark para analizar la captura de red:
Solamente hay un segmento TCP que contiene datos:
17275a3d9163b2798392813bf5e6826657bd11426076c910a38b68c2bcbbd3a5 Ingeniería inversa Podemos usar Ghidra para leer el código descompilado en C.</description></item><item><title>Snakecode</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</guid><description>Se nos proporciona un binario llamado chall.pyc, por lo que sabemos que es un binario compilado mediante Python:
$ file chall.pyc chall.pyc: python 2.7 byte-compiled En primer lugar, podemos extraer el código fuente en Python usando uncompyle6. Como está compilado con python2.7, podemos emplear un contenedor de Docker para ello:
$ docker run -v "$PWD":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020.</description></item><item><title>Teleport</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</guid><description>Se nos proporciona un binario llamado teleport:
$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped Si lo ejecutamos, nos pregunta por una contraseña:
$ ./teleport Missing password Podemos probar a añadirla como argumento de línea de comandos:
$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong... Con ltrace podemos ver que nuestra entrada se copia en una dirección de memoria y luego hay un montón de saltos (44 llamadas a _setjmp):</description></item><item><title>WIDE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</guid><description>Se nos proporciona un binario de 64 bits llamado wide y otro archivo llamado db.ex con algunas cadenas de texto:
$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe Si ejeutamos el binario tenemos lo siguiente:</description></item><item><title>You Cant C Me</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</guid><description>Se nos proporciona un binario llamado auth:
$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped Si lo ejecutamos, pregunta por una clave:
$ ./auth Welcome! Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: asdf I said, you can't c me! Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item></channel></rss>