<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/web/</link><description>Recent content in Web on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>Amidst Us</title><link>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</guid><description>Tenemos la siguiente página web, que simula el juego Among Us:
Existe un botón para seleccionar un color con un color picker:
Si analizamos el código fuente, tenemos una aplicación en Flask (en Python). Este es application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) La función make_alpha está definida en application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.urandom(x).hex() defmake_alpha(data): color=data.</description></item><item><title>baby auth</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</guid><description>Se nos proporciona esta página web:
Primero, nos podemos registrar (nombre asdf, por ejemplo):
Luego, nos dicen que no somos admin. De hecho, la autenticación se gestiona con cookies de sesión:
La cookie se sesión parece codificada en Base64, por lo que vamos a decodificarla (cuidado con la codificación de URL):
$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {"username":"asdf"} Muestra nuestro nombre de usuario, a lo mejor podemos modificar la cookie y ganar acceso como admin:</description></item><item><title>baby BoneChewerCon</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto. Vamos a poner algo y a enviarlo.
Se nos muestra un error en el depurador de Laravel (un framework de PHP):
Esto es una mala práctica y un problema de seguridad, ya que los depuradores pueden contener información sensible y muchos de ellos proporcionan maneras de ejecutar código.
Flag De hecho, podemos encontrar la flag en una variable de entorno llamada APP_KEY (HTB{wh3n_th3_d3bugg3r_turns_4g41nst_th3_d3bugg33}):</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</guid><description>Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:
Por detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:
El objetivo es llegar a la ruta /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') Sin embargo, está protegida verificando que la petición se realiza desde 127.</description></item><item><title>baby interdimensional internet</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
fromflaskimportFlask, Response, request, render_template, request fromrandomimportchoice, randint fromstringimportlowercase fromfunctoolsimportwraps app=Flask(__name__) defcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass defGCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) deffederation(*args, **kwargs): ingredient=''.join(choice(lowercase) for_inrange(10)) recipe='%s= %s'%(ingredient, ''.join(map(str, [randint(1, 69), choice(['+', '-', '*']), randint(1,69)]))) ifrequest.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>Se nos proporciona esta página web:
Existe un comentario en el código HTML de la página que indica una URL de depuración (/debug):
En esta ruta /debug, podemos encontrar el código fuente:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</guid><description>Tenemos una página web donde podemos escribir en Markdown y transformar el documento a PDF:
Por defecto, tenemos este contenido en Markdown:
Como tenemos un proyecto en Node.js, si leemos el archivo package.json veremos las versiones de las dependencias de terceros:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>Full Stack Conf</title><link>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto:
Si ponemos algunos datos, vemos un mensaje:
No obstante, la página pide que mostremos un alert(). Esto se suele usar como prueba de concepto para un ataque de Cross-Site Scripting (XSS). Uno de los payloads de XSS más sencillos es:
&amp;lt;imgsrc=xonerror=alert(1)&amp;gt; Si lo usamos, veremos la flag en el alert (HTB{p0p..p0p..p0p...alert(1337)}):</description></item><item><title>Gunship</title><link>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</guid><description>Tenemos una página web con una interfaz bastante chula:
Solamente existe una entrada de usuario:
Se trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).
También utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</guid><description>Se nos proporciona una aplicación web en PHP con una única funcionalidad, que es poner un email en un formulario.
Empezamos analizando el código fuente. El archivo index.php muestra que solo hay dos rutas (GET y POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); Vemos que Database.</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</guid><description>Se nos proporciona la siguiente página web:
Muestra un listado de directorio. Si vamos a /mailer.php veremos esta página para enviar correos:
El archivo mailer.zip contiene el código fuente de mailer.php. Es bastante largo como para ponerlo aquí.
La clave está en que utiliza PHPMailer, que es vulnerable a CVE-2016-10033 y CVE-2016-10045. De hecho, existen exploits públicos como el que aparece en www.exploit-db.com.
Básicamente, el exploit dice que pongamos este payload como nuestro correo:</description></item><item><title>looking glass</title><link>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</guid><description>Se nos proporciona esta página web:
La funcionalidad que tiene es usar el comando ping:
El problema puede estar relacionado con inyección de comandos, porque probablemente el servidor hace algo como:
&amp;lt;?php $cmd ='ping -c 4 '.$_POST['ip_address']; system($cmd); A lo mejor no en PHP, pero el concepto es el mismo. Por tanto, podemos probar a poner un punto y coma e inyectar otro comando de sistema (; id):
Ahí está, el servidor es vulnerable a inyección de comandos, que deriva en ejecución remota de comandos (RCE).</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</guid><description>Se nos proporciona una página web como esta:
Nos tenemos que registrar e iniciar sesión para ver un dashboard chulo:
La única funcionalidad que tenemos es la de exportar las imágenes SVG que vemos como archivos PNG. Podemos capturar la petición con Burp Suite:
Después de un poco de investigación, podemos ver que hay una vulnerabilidad en la conversión de SVG que deriva en lectura de archivos locales (más información en security.</description></item><item><title>Red Island</title><link>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</guid><description>Tenemos una página web como esta:
Podemos registrar una nueva cuenta e iniciar sesión para ver la siguiente funcionalidad:
Esta vez no tenemos el código fuente de la aplicación web, por lo que tendremos que encontrar una vulnerabilidad clara o encontrar el código fuente de alguna manera.
Podemos comenzar a pensar en Server-Side Request Forgery (SSRF). Como en otros retos, sabemos que el servidor web escucha en el puerto 1337, por lo que vamos a probar http://127.</description></item><item><title>sanitize</title><link>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
fromflaskimportFlask, request, render_template, Response, url_for, g fromsqlite3importdbapi2assqlite3 fromfunctoolsimportwraps app=Flask(__name__) defget_db(): db=getattr(g, '_database', None) ifdbisNone: db=g._database =sqlite3.connect(':memory:', isolation_level=None) db.row_factory=sqlite3.Row withapp.app_context(): db.cursor().execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT);') withapp.open_resource('schema.sql', mode='r') asf: db.cursor().executescript(f.read()) returndb @app.teardown_appcontext defclose_connection(exception): db=getattr(g, '_database', None) ifdbisnotNone: db.close() defquery_db(query, args=(), one=False): try: withapp.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 El archivo se descomprime y se escribe el /tmp:</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>Se nos proporciona el código fuente de un proyecto web en Node.js con Express JS y MySQL. En el Dockerfile se utiliza el siguiente script entrypoint.sh:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item></channel></rss>