<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/web/</link><description>Recent content in Web on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>AbuseHumanDB</title><link>https://7rocky.github.io/ctf/htb-challenges/web/abusehumandb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/abusehumandb/</guid><description>Tenemos una página web que nos permite introducir una URL. Posteriormente, un bot accederá:
Análisis de código fuente En el código fuente tenemos una aplicación en Express JS. Este es el archivo route/index.js:
const bot = require('../bot') const path = require('path') const express = require('express') const router = express.Router() const response = data =&amp;gt; ({ message: data }) const isLocalhost = req =&amp;gt; (req.ip == '127.0.0.1' &amp;amp;&amp;amp; req.headers.host == '127.0.0.1:1337' ?</description></item><item><title>Amidst Us</title><link>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</guid><description>Tenemos la siguiente página web, que simula el juego Among Us:
Existe un botón para seleccionar un color con un color picker:
Si analizamos el código fuente, tenemos una aplicación en Flask (en Python). Este es application/blueprints/routes.py:
from flask import Blueprint, request, render_template, abort from application.util import make_alpha web = Blueprint('web', __name__) api = Blueprint('api', __name__) @web.route('/') def index(): return render_template('index.html') @api.route('/alphafy', methods=['POST']) def alphafy(): if not request.is_json or 'image' not in request.</description></item><item><title>baby auth</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</guid><description>Se nos proporciona esta página web:
Primero, nos podemos registrar (nombre asdf, por ejemplo):
Luego, nos dicen que no somos admin. De hecho, la autenticación se gestiona con cookies de sesión:
La cookie se sesión parece codificada en Base64, por lo que vamos a decodificarla (cuidado con la codificación de URL):
$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {"username":"asdf"} Muestra nuestro nombre de usuario, a lo mejor podemos modificar la cookie y ganar acceso como admin:</description></item><item><title>baby BoneChewerCon</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto. Vamos a poner algo y a enviarlo.
Se nos muestra un error en el depurador de Laravel (un framework de PHP):
Esto es una mala práctica y un problema de seguridad, ya que los depuradores pueden contener información sensible y muchos de ellos proporcionan maneras de ejecutar código.
Flag De hecho, podemos encontrar la flag en una variable de entorno llamada APP_KEY:</description></item><item><title>baby breaking grad</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-breaking-grad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-breaking-grad/</guid><description>Tenemos esta página web:
Vamos a pinchar en el botón:
Análisis de código fuente Muy bien, ya que se nos proporciona el código fuente, echémosle un vistazo. Es un proyecto en Node.js usando Express JS. Este es index.js:
const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const routes = require('./routes'); const path = require('path'); app.use(bodyParser.json()); app.set('views','./views'); app.use('/static', express.static(path.resolve('static'))); app.use(routes); app.all('*', (req, res) =&amp;gt; { return res.status(404).send('404 page not found'); }); app.</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</guid><description>Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:
Por detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:
El objetivo es llegar a la ruta /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') Sin embargo, está protegida verificando que la petición se realiza desde 127.</description></item><item><title>baby interdimensional internet</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
from flask import Flask, Response, request, render_template, request from random import choice, randint from string import lowercase from functools import wraps app = Flask(__name__) def calc(recipe): global garage garage = {} try: exec(recipe, garage) except: pass def GCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) def federation(*args, **kwargs): ingredient = ''.</description></item><item><title>baby nginxatsu</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-nginxatsu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-nginxatsu/</guid><description>Se nos proporciona esta página web:
Después de registrar una cuenta e iniciar sesión, veremos esta funcionalidad:
Básicamente, nos permiten crear archivos de configuración de nginx.
Explotación de nginx Nótese que el campo location es /storage. Vamos a crear la configuración que viene por defecto a ver qué sale:
Tenemos esta configuración:
user www; pid /run/nginx.pid; error_log /dev/stderr info; events { worker_connections 1024; } http { server_tokens off; charset utf-8; keepalive_timeout 20s; sendfile on; tcp_nopush on; client_max_body_size 2M; include /etc/nginx/mime.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>Se nos proporciona esta página web:
Existe un comentario en el código HTML de la página que indica una URL de depuración (/debug):
En esta ruta /debug, podemos encontrar el código fuente:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>baby todo or not todo</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-todo-or-not-todo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-todo-or-not-todo/</guid><description>Se nos proporciona esta página web:
Análisis de código fuente También se nos proporciona el código fuente, que es una aplicación en Flask (Python). Esto es application/app.py:
from flask import Flask, session, g from flask.json import JSONEncoder from application.blueprints.routes import main, api from application.util import generate from application.database import get_db from application.models import todo import time class toJSON(JSONEncoder): def default(self, obj): if isinstance(obj, todo): return { 'id' : obj.id, 'name' : obj.</description></item><item><title>baby WAFfles order</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-waffles-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-waffles-order/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También tenemos el código fuente en PHP. Esto es index.php:
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } include_once "${name}.php"; }); $router = new Router(); $router-&amp;gt;new('GET', '/', fn($router) =&amp;gt; $router-&amp;gt;view('menu')); $router-&amp;gt;new('POST', '/api/order', 'OrderController@order'); die($router-&amp;gt;match()); Aquí solamente hay dos rutas. La que parece más interesante es la que está gestionada por OrderController.php:
&amp;lt;?php class OrderController { public function order($router) { $body = file_get_contents('php://input'); if ($_SERVER['HTTP_CONTENT_TYPE'] === 'application/json') { $order = json_decode($body); if (!</description></item><item><title>baby website rick</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-website-rick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-website-rick/</guid><description>Se nos proporciona esta página web:
Analizando el sitio web Esta vez, no tenemos código fuente para analizar. Sin embargo, la imagen de arriba muestra algo sospechoso:
&lt;__main__.anti_pickle_serum object at 0x7f0ed62d1810> Esto parece una clase de Python:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; class Test(): ... pass ... &amp;gt;&amp;gt;&amp;gt; Test() &amp;lt;__main__.Test object at 0x1007fbd30&amp;gt; También, tenemos una cookie llamada plan_b:
Esto parece una cadena codificada en Base64:
&amp;gt;&amp;gt;&amp;gt; from base64 import b64encode as b64e, b64decode as b64d &amp;gt;&amp;gt;&amp;gt; b64d('KGRwMApTJ3NlcnVtJwpwMQpjY29weV9yZWcKX3JlY29uc3RydWN0b3IKcDIKKGNfX21haW5fXwphbnRpX3BpY2tsZV9zZXJ1bQpwMwpjX19idWlsdGluX18Kb2JqZWN0CnA0Ck50cDUKUnA2CnMu') b"</description></item><item><title>BatchCraft Potions</title><link>https://7rocky.github.io/ctf/htb-challenges/web/batchcraft-potions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/batchcraft-potions/</guid><description>Tenemos este sitio web:
Análisis de código estático Se nos proporciona el código fuente de JavaScript de la aplicación web, creada con Node.js y Express JS. Esto es index.js:
const express = require('express'); const app = express(); const path = require('path'); const cookieParser = require('cookie-parser'); const nunjucks = require('nunjucks'); const routes = require('./routes'); const Database = require('./database'); global.db = new Database(); app.use(express.json()); app.use(cookieParser()); nunjucks.configure('views', { autoescape: true, express: app }); app.</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</guid><description>Tenemos una página web donde podemos escribir en Markdown y transformar el documento a PDF:
Por defecto, tenemos este contenido en Markdown:
Como tenemos un proyecto en Node.js, si leemos el archivo package.json veremos las versiones de las dependencias de terceros:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>CurlAsAService</title><link>https://7rocky.github.io/ctf/htb-challenges/web/curlasaservice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/curlasaservice/</guid><description>Se nos proporciona esta página web, que nos permite ejecutar curl:
Análisis de código fuente También tenemos el código fuente en PHP. Esto es index.php:
&amp;lt;?php date_default_timezone_set('UTC'); spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $router = new Router(); $router-&amp;gt;new('GET', '/', 'CurlController@index'); $router-&amp;gt;new('POST', '/api/curl', 'CurlController@execute' ); $response = $router-&amp;gt;match(); die($response); Aquí solo vemos dos rutas. La que es más interesante se gestiona con CurlController.</description></item><item><title>Cursed Secret Party</title><link>https://7rocky.github.io/ctf/htb-challenges/web/cursed-secret-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/cursed-secret-party/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También tenemos el código fuente en JavaScript de la aplicación web, hecha en Node.js con Express JS. Este archivo es routes/index.js:
const express = require('express'); const router = express.Router({ caseSensitive: true }); const AuthMiddleware = require('../middleware/AuthMiddleware'); const bot = require('../bot'); let db; const response = data =&amp;gt; ({ message: data }); router.get('/', (req, res) =&amp;gt; { return res.render('index.html'); }); router.post('/api/submit', (req, res) =&amp;gt; { const { halloween_name, email, costume_type, trick_or_treat } = req.</description></item><item><title>Didactic Octo Paddles</title><link>https://7rocky.github.io/ctf/htb-challenges/web/didactic-octo-paddles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/didactic-octo-paddles/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis del código fuente La aplicación web está construida con Express JS. Después de leer algunos archivos, uno que destaca es middlewares/AdminMiddleware.js:
const jwt = require("jsonwebtoken"); const { tokenKey } = require("../utils/authorization"); const db = require("../utils/database"); const AdminMiddleware = async (req, res, next) =&amp;gt; { try { const sessionCookie = req.cookies.session; if (!sessionCookie) { return res.</description></item><item><title>E.Tree</title><link>https://7rocky.github.io/ctf/htb-challenges/web/e.tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/e.tree/</guid><description>Se nos proporciona este sitio web:
También tenemos el código fuente del proyecto en Python (Flask).
Análisis del código fuente La aplicación tiene tres endpoints en blueprints/routes.py:
from flask import Blueprint, render_template, request from application.util import leaderboard, search_staff web = Blueprint('web', __name__) api = Blueprint('api', __name__) @web.route('/') def index(): return render_template('index.html') @web.route('/leaderboard') def web_leaderboard(): return render_template('leaderboard.html', leaderboard=leaderboard('DSC-N-1547')) @api.route('/search', methods=['POST']) def api_search(): name = request.json.get('search', '') return search_staff(name) El relevante es /search, que llama a una función search_staff que se define en util.</description></item><item><title>emoji voting</title><link>https://7rocky.github.io/ctf/htb-challenges/web/emoji-voting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/emoji-voting/</guid><description>Se nos proporciona este sitio web:
También tenemos el código fuente del proyecto en Node.js (Express).
Análisis del código fuente Los endpoints disponibles están en routes/index.js:
const path = require('path'); const express = require('express'); const router = express.Router(); let db; const response = data =&amp;gt; ({ message: data }); router.get('/', (req, res) =&amp;gt; { return res.sendFile(path.resolve('views/index.html')); }); router.post('/api/vote', (req, res) =&amp;gt; { let { id } = req.body; if (id) { return db.</description></item><item><title>ExpressionalRebel</title><link>https://7rocky.github.io/ctf/htb-challenges/web/expressionalrebel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/expressionalrebel/</guid><description>Tenemos una aplicación web que evalúa las restricciones de Content Security Policy (CSP) que le pongamos:
Análisis de código fuente También tenemos el proyecto, que es una aplicación hecha en Node.js con Express. Podemos ver algunas rutas en routes/api.js:
const express = require('express') const router = express.Router() const { evaluateCsp } = require('../utils') router.post('/evaluate', async (req, res) =&amp;gt; { const { csp } = req.body try { const cspIssues = await evaluateCsp(csp) res.</description></item><item><title>Full Stack Conf</title><link>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto:
Si ponemos algunos datos, vemos un mensaje:
No obstante, la página pide que mostremos un alert(). Esto se suele usar como prueba de concepto para un ataque de Cross-Site Scripting (XSS). Uno de los payloads de XSS más sencillos es:
&amp;lt;img src=x onerror=alert(1)&amp;gt; Si lo usamos, veremos la flag en el alert (HTB{p0p..p0p..p0p...alert(1337)}):</description></item><item><title>Gunship</title><link>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</guid><description>Tenemos una página web con una interfaz bastante chula:
Solamente existe una entrada de usuario:
Se trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).
También utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Horror Feeds</title><link>https://7rocky.github.io/ctf/htb-challenges/web/horror-feeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/horror-feeds/</guid><description>Se nos proporciona esta página web:
Análisis de código estático También se nos proporciona el código fuente en Python de la aplicación web, hecha en Flask. Como estamos tratando con un formulario de inicio de sesión, vamos a echar un vistazo a cómo se interactúa con la base de datos (application/database.py):
from colorama import Cursor from application.util import generate_password_hash, verify_hash, generate_token from flask_mysqldb import MySQL mysql = MySQL() def query_db(query, args=(), one=False): with open('/tmp/log', 'a') as f: f.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</guid><description>Se nos proporciona una aplicación web en PHP con una única funcionalidad, que es poner un email en un formulario.
Empezamos analizando el código fuente. El archivo index.php muestra que solo hay dos rutas (GET y POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); Vemos que Database.</description></item><item><title>Juggling facts</title><link>https://7rocky.github.io/ctf/htb-challenges/web/juggling-facts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/juggling-facts/</guid><description>Se nos proporciona la siguiente página web:
Análisis de código estático También nos dan el código PHP de la aplicación web. La parte importante está en controllers/IndexController.php:
&amp;lt;?php class IndexController extends Controller { public function __construct() { parent::__construct(); } public function index($router) { $router-&amp;gt;view('index'); } public function getfacts($router) { $jsondata = json_decode(file_get_contents('php://input'), true); if ( empty($jsondata) || !array_key_exists('type', $jsondata)) { return $router-&amp;gt;jsonify(['message' =&amp;gt; 'Insufficient parameters!']); } if ($jsondata['type'] === 'secrets' &amp;amp;&amp;amp; $_SERVER['REMOTE_ADDR'] !</description></item><item><title>Kryptos Support</title><link>https://7rocky.github.io/ctf/htb-challenges/web/kryptos-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/kryptos-support/</guid><description>Se nos proporciona esta página web:
Nos permite enviar mensajes que serán revisados por un administrador:
Enumeración Como no tenemos el código fuente, vamos a usar ffuf para descubrir algunas rutas:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://188.166.146.25:32282/FUZZ [Status: 200, Size: 2352, Words: 1056, Lines: 53, Duration: 46ms] * FUZZ: login [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 37ms] * FUZZ: admin [Status: 301, Size: 179, Words: 7, Lines: 11, Duration: 39ms] * FUZZ: static [Status: 200, Size: 2352, Words: 1056, Lines: 53, Duration: 41ms] * FUZZ: Login [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 37ms] * FUZZ: logout [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 36ms] * FUZZ: settings [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 39ms] * FUZZ: tickets [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 68ms] * FUZZ: Admin [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 39ms] * FUZZ: Logout [Status: 301, Size: 179, Words: 7, Lines: 11, Duration: 39ms] * FUZZ: Static [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 62ms] * FUZZ: Tickets [Status: 302, Size: 23, Words: 4, Lines: 1, Duration: 36ms] * FUZZ: SETTINGS [Status: 200, Size: 2067, Words: 934, Lines: 54, Duration: 39ms] * FUZZ: [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 41ms] * FUZZ: %C0 [Status: 200, Size: 2352, Words: 1056, Lines: 53, Duration: 41ms] * FUZZ: LogIn [Status: 200, Size: 2352, Words: 1056, Lines: 53, Duration: 42ms] * FUZZ: LOGIN [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 39ms] * FUZZ: %CF [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %CD [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %CE [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 41ms] * FUZZ: %D8 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 41ms] * FUZZ: %CC [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 42ms] * FUZZ: %CB [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 42ms] * FUZZ: %CA [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 42ms] * FUZZ: %D0 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 38ms] * FUZZ: %D1 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 36ms] * FUZZ: %D7 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 41ms] * FUZZ: %D6 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 44ms] * FUZZ: %D5 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 44ms] * FUZZ: %D4 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 37ms] * FUZZ: %C2 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 42ms] * FUZZ: %C8 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 44ms] * FUZZ: %C9 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 44ms] * FUZZ: %C1 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 48ms] * FUZZ: %D2 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 48ms] * FUZZ: %D3 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 39ms] * FUZZ: %C6 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %C7 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 38ms] * FUZZ: %C4 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 41ms] * FUZZ: %C5 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %C3 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %D9 [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 39ms] * FUZZ: %DD [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %DE [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 42ms] * FUZZ: %DF [Status: 500, Size: 35, Words: 3, Lines: 1, Duration: 40ms] * FUZZ: %DB Vemos que tenemos una página de inicio de sesión:</description></item><item><title>Lazy Ballot</title><link>https://7rocky.github.io/ctf/htb-challenges/web/lazy-ballot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/lazy-ballot/</guid><description>Se nos proporciona un sitio web como este:
También se nos proporciona el código fuente del servidor en Node.js.
Análisis del código fuente Esto es routes/index.js:
const express = require("express"); const router = express.Router({ caseSensitive: true }); const AuthMiddleware = require("../middleware/auth"); let db; const response = (data) =&amp;gt; ({ resp: data }); router.get("/", (req, res) =&amp;gt; { return res.render("index.pug"); }); router.get("/login", async (req, res) =&amp;gt; { if (req.session.authenticated) { return res.</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</guid><description>Se nos proporciona la siguiente página web:
Muestra un listado de directorio. Si vamos a /mailer.php veremos esta página para enviar correos:
El archivo mailer.zip contiene el código fuente de mailer.php. Es bastante largo como para ponerlo aquí.
La clave está en que utiliza PHPMailer, que es vulnerable a CVE-2016-10033 y CVE-2016-10045. De hecho, existen exploits públicos como el que aparece en www.exploit-db.com.
Básicamente, el exploit dice que pongamos este payload como nuestro correo:</description></item><item><title>looking glass</title><link>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</guid><description>Se nos proporciona esta página web:
La funcionalidad que tiene es usar el comando ping:
El problema puede estar relacionado con inyección de comandos, porque probablemente el servidor hace algo como:
&amp;lt;?php $cmd = 'ping -c 4 ' . $_POST['ip_address']; system($cmd); A lo mejor no en PHP, pero el concepto es el mismo. Por tanto, podemos probar a poner un punto y coma e inyectar otro comando de sistema (; id):</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</guid><description>Se nos proporciona una página web como esta:
Nos tenemos que registrar e iniciar sesión para ver un dashboard chulo:
La única funcionalidad que tenemos es la de exportar las imágenes SVG que vemos como archivos PNG. Podemos capturar la petición con Burp Suite:
Después de un poco de investigación, podemos ver que hay una vulnerabilidad en la conversión de SVG que deriva en lectura de archivos locales (más información en security.</description></item><item><title>Orbital</title><link>https://7rocky.github.io/ctf/htb-challenges/web/orbital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/orbital/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Python.
Análisis del código fuente La aplicación web está construida con Flask. Se puede encontrar una vulnerabilidad clara de inyección SQL (SQLi) en database.py:
from colorama import Cursor from application.util import createJWT, passwordVerify from flask_mysqldb import MySQL mysql = MySQL() def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.</description></item><item><title>Passman</title><link>https://7rocky.github.io/ctf/htb-challenges/web/passman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/passman/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente en Node.js.
Análisis de código fuente La aplicación web está construida con Express JS. Un archivo relevante es routes/index.js:
const express = require('express'); const router = express.Router(); const { graphqlHTTP } = require('express-graphql'); const AuthMiddleware = require('../middleware/AuthMiddleware'); const GraphqlSchema = require('../helpers/GraphqlHelper'); router.get('/', (req, res) =&amp;gt; { return res.render('login.html'); }); router.get('/register', (req, res) =&amp;gt; { return res.render('register.html'); }); router.</description></item><item><title>Red Island</title><link>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</guid><description>Tenemos una página web como esta:
Podemos registrar una nueva cuenta e iniciar sesión para ver la siguiente funcionalidad:
Esta vez no tenemos el código fuente de la aplicación web, por lo que tendremos que encontrar una vulnerabilidad clara o encontrar el código fuente de alguna manera.
Podemos comenzar a pensar en Server-Side Request Forgery (SSRF). Como en otros retos, sabemos que el servidor web escucha en el puerto 1337, por lo que vamos a probar http://127.</description></item><item><title>sanitize</title><link>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
from flask import Flask, request, render_template, Response, url_for, g from sqlite3 import dbapi2 as sqlite3 from functools import wraps app = Flask(__name__) def get_db(): db = getattr(g, '_database', None) if db is None: db = g._database = sqlite3.connect(':memory:', isolation_level=None) db.row_factory = sqlite3.Row with app.app_context(): db.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
Análisis del código fuente En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 El archivo se descomprime y se escribe el /tmp:</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>Se nos proporciona el código fuente de un proyecto web en Node.js con Express JS y MySQL.
Análisis del código fuente En el Dockerfile se utiliza el siguiente script entrypoint.sh:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "</description></item><item><title>Spookifier</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spookifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spookifier/</guid><description>Se nos proporciona esta página web:
Podemos introducir un texto cualquiera y será mostrado en diferentes fuentes:
Análisis de código estático Tenemos el código fuente en Python de la aplicación web, hecha con Flask. Este archivo es application/blueprints/routes.py:
from flask import Blueprint, request from flask_mako import render_template from application.util import spookify web = Blueprint('web', __name__) @web.route('/') def index(): text = request.args.get('text') if text: converted = spookify(text) return render_template('index.html', output=converted) return render_template('index.</description></item><item><title>Spybug</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spybug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spybug/</guid><description>Se nos proporciona un sitio web como este:
También tenemos el código fuente de la aplicación web en Node.js y el código fuente de un agente en Go.
Análisis de código fuente La aplicación web está construida con Express JS. En index.js Podemos ver una cabecera de Content Security Policy (CSP) y una función visitPanel que se ejecuta cada minuto:
application.use((req, res, next) =&amp;gt; { res.setHeader("Content-Security-Policy", "script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';"</description></item><item><title>Templated</title><link>https://7rocky.github.io/ctf/htb-challenges/web/templated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/templated/</guid><description>Se nos proporciona una página web hecha en Flask:
Si probamos una ruta cualquiera, se refleja en el documento HTML:
Por tanto, puede ser vulnerable a Server-Side Template Injection (SSTI). Vamos a probar con {{7*7}}:
Y de hecho es vulnerable, ya que aparece 49. Ahora, podemos ir a PayloadsAllTheThings y coger otro payload de SSTI para obtener ejecución remota de comandos (Remote Code Execution, RCE) en el servidor:
Finalmente, tenemos la flag (HTB{t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!</description></item><item><title>The Magic Informer</title><link>https://7rocky.github.io/ctf/htb-challenges/web/the-magic-informer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/the-magic-informer/</guid><description>Tenemos este sitio web:
Esta vez no tenemos el código fuente, por lo que debemos dar vueltas con el sitio web.
Registrando una nueva cuenta En la parte inferior de la página podemos encontrar un enlace a un formulario de registro:
Entonces nos registramos y luego iniciamos sesión:
Y tenemos acceso a nuestro dashboard:
Navegación de directorios y lectura de archivos locales Podemos probar inyecciones comunes en la en el formulario anterior.</description></item><item><title>Toxic</title><link>https://7rocky.github.io/ctf/htb-challenges/web/toxic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/toxic/</guid><description>Se nos proporciona un sitio web como este:
También se tenemos el código fuente del servidor en PHP.
Análisis del código fuente Este es index.php:
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); if (empty($_COOKIE['PHPSESSID'])) { $page = new PageModel; $page-&amp;gt;file = '/www/index.html'; setcookie( 'PHPSESSID', base64_encode(serialize($page)), time()+60*60*24, '/' ); } $cookie = base64_decode($_COOKIE['PHPSESSID']); unserialize($cookie); Como podemos ver, el servidor codifica una página (/www/index.html por defecto) en la cookie PHPSESSID, y también la serializa:</description></item><item><title>Trapped Source</title><link>https://7rocky.github.io/ctf/htb-challenges/web/trapped-source/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/trapped-source/</guid><description>Se nos proporciona este sitio web:
Parece un panel donde debemos ingresar un PIN.
Inspeccionando el código HTML Si presionamos Ctrl-U en el teclado, veremos el código HTML del sitio web:
¡Sorpresa! El PIN esperado está ahí en texto claro: 1425. Vamos a ponerlo:
Flag Y aquí está la flag:
HTB{vi3w_cli13nt_s0urc3_S3cr3ts!}</description></item><item><title>TrapTrack</title><link>https://7rocky.github.io/ctf/htb-challenges/web/traptrack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/traptrack/</guid><description>Se nos proporciona una página web como esta:
También tenemos el código fuente del proyecto.
Funcionalidad del sitio web La aplicación web nos permite ingresar una URL que se almacenará en una base de datos SQLite. Al leer el código de challenge/application/config.py encontramos credenciales válidas (admin:admin):
from application.util import generate import os class Config(object): SECRET_KEY = generate(50) ADMIN_USERNAME = 'admin' ADMIN_PASSWORD = 'admin' SESSION_PERMANENT = False SESSION_TYPE = 'filesystem' SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/database.</description></item><item><title>Userland City</title><link>https://7rocky.github.io/ctf/htb-challenges/web/userland-city/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/userland-city/</guid><description>Se nos proporciona esta página web:
Enumeración Muestra un formulario de inicio de sesión. Afortunadamente, se nos proporcionan unas credenciales en la descripción del reto: lxkid02:8rsNN9ohfLp69cVRFEgk4Qzs. Por tanto, podemos usarlas para acceder:
Se trata de una simple página web de alguna tienda online de mentira para cibercriminales.
La descripción del reto es bastante larga. Lo importante son las credenciales anteriores y que la página utiliza Laravel con el modo de debug activado.</description></item><item><title>Watersnake</title><link>https://7rocky.github.io/ctf/htb-challenges/web/watersnake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/watersnake/</guid><description>Se nos da un sitio web como este:
También tenemos el código fuente en Java (SpringBoot).
Análisis del código fuente Este es el archivo principal de la aplicación (Application.java):
package com.lean.watersnake; import java.util.Arrays; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Podemos encontrar los endpoints disponibles en Controller.java:
package com.lean.watersnake; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.</description></item><item><title>Wild Goose Hunt</title><link>https://7rocky.github.io/ctf/htb-challenges/web/wild-goose-hunt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/wild-goose-hunt/</guid><description>Se nos proporciona este sitio web:
También tenemos el código fuente del proyecto en Node.js (Express).
Análisis del código fuente Este es index.js:
const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const routes = require('./routes'); const mongoose = require('mongoose'); mongoose.connect('mongodb://localhost:27017/heros', { useNewUrlParser: true , useUnifiedTopology: true }); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); app.use(express.static('static')); app.set('view engine', 'pug'); app.use(routes); app.all('*', (req, res) =&amp;gt; { return res.status(404).send({ message: '404 page not found' }); }); app.</description></item></channel></rss>