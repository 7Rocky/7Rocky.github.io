<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/web/</link><description>Recent content in Web on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>Amidst Us</title><link>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</guid><description>Tenemos la siguiente página web, que simula el juego Among Us:
Existe un botón para seleccionar un color con un color picker:
Si analizamos el código fuente, tenemos una aplicación en Flask (en Python). Este es application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) La función make_alpha está definida en application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.urandom(x).hex() defmake_alpha(data): color=data.</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</guid><description>Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:
Por detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:
El objetivo es llegar a la ruta /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') Sin embargo, está protegida verificando que la petición se realiza desde 127.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>Se nos proporciona esta página web:
Existe un comentario en el código HTML de la página que indica una URL de depuración (/debug):
En esta ruta /debug, podemos encontrar el código fuente:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</guid><description>Tenemos una página web donde podemos escribir en Markdown y transformar el documento a PDF:
Por defecto, tenemos este contenido en Markdown:
Como tenemos un proyecto en Node.js, si leemos el archivo package.json veremos las versiones de las dependencias de terceros:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>Gunship</title><link>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</guid><description>Tenemos una página web con una interfaz bastante chula:
Solamente existe una entrada de usuario:
Se trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).
También utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</guid><description>Se nos proporciona una aplicación web en PHP con una única funcionalidad, que es poner un email en un formulario.
Empezamos analizando el código fuente. El archivo index.php muestra que solo hay dos rutas (GET y POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); Vemos que Database.</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</guid><description>Se nos proporciona una página web como esta:
Nos tenemos que registrar e iniciar sesión para ver un dashboard chulo:
La única funcionalidad que tenemos es la de exportar las imágenes SVG que vemos como archivos PNG. Podemos capturar la petición con Burp Suite:
Después de un poco de investigación, podemos ver que hay una vulnerabilidad en la conversión de SVG que deriva en lectura de archivos locales (más información en security.</description></item><item><title>Red Island</title><link>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</guid><description>Tenemos una página web como esta:
Podemos registrar una nueva cuenta e iniciar sesión para ver la siguiente funcionalidad:
Esta vez no tenemos el código fuente de la aplicación web, por lo que tendremos que encontrar una vulnerabilidad clara o encontrar el código fuente de alguna manera.
Podemos comenzar a pensar en Server-Side Request Forgery (SSRF). Como en otros retos, sabemos que el servidor web escucha en el puerto 1337, por lo que vamos a probar http://127.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 El archivo se descomprime y se escribe el /tmp:</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>Se nos proporciona el código fuente de un proyecto web en Node.js con Express JS y MySQL. En el Dockerfile se utiliza el siguiente script entrypoint.sh:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item></channel></rss>