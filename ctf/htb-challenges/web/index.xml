<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on 7Rocky</title><link>https://7rocky.github.io/ctf/htb-challenges/web/</link><description>Recent content in Web on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/web/index.xml" rel="self" type="application/rss+xml"/><item><title>baby CachedView</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</guid><description>Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:
Por detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:
El objetivo es llegar a la ruta /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') Sin embargo, está protegida verificando que la petición se realiza desde 127.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>Se nos proporciona esta página web:
Existe un comentario en el código HTML de la página que indica una URL de depuración (/debug):
En esta ruta /debug, podemos encontrar el código fuente:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>Gunship</title><link>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</guid><description>Tenemos una página web con una interfaz bastante chula:
Solamente existe una entrada de usuario:
Se trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).
También utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 El archivo se descomprime y se escribe el /tmp:</description></item></channel></rss>