<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/htb-challenges/blockchain/</link><description>Recent content in Blockchain on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/htb-challenges/blockchain/index.xml" rel="self" type="application/rss+xml"/><item><title>Confidentiality</title><link>https://7rocky.github.io/ctf/htb-challenges/blockchain/confidentiality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/blockchain/confidentiality/</guid><description>Se nos proporciona un archivo de Solidity llamado AccessToken.sol:
// SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.19; import {ERC721} from "./lib/ERC721.sol"; import {Owned} from "./lib/Owned.sol"; contract AccessToken is ERC721, Owned { uint256 public currentSupply; bytes[] public usedSignatures; bytes32 public constant approvalHash = 0x4ed1c9f7e3813196653ad7c62857a519087860f86aff4bc7766c8af8756a72ba; constructor(address _owner) Owned(_owner) ERC721("AccessToken", "ACT") {} function safeMint(address to) public onlyOwner returns (uint256) { return _safeMintInternal(to); } function safeMintWithSignature(bytes memory signature, address to) external returns (uint256) { require(_verifySignature(signature), "Not approved"</description></item><item><title>Funds Secured</title><link>https://7rocky.github.io/ctf/htb-challenges/blockchain/funds-secured/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/blockchain/funds-secured/</guid><description>Se nos proporciona un archivo de Solidity llamado Campaign.sol:
// SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.18; import {ECDSA} from "./lib/ECDSA.sol"; /// @notice MultiSignature wallet used to end the Crowdfunding and transfer the funds to a desired address contract CouncilWallet { using ECDSA for bytes32; address[] public councilMembers; /// @notice Register the 11 council members in the wallet constructor(address[] memory members) { require(members.length == 11); councilMembers = members; } /// @notice Function to close crowdfunding campaign.</description></item><item><title>Lucky Faucet</title><link>https://7rocky.github.io/ctf/htb-challenges/blockchain/lucky-faucet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/blockchain/lucky-faucet/</guid><description>Se nos proporciona un archivo de Solidity llamado LuckyFaucet.sol:
// SPDX-License-Identifier: MIT pragma solidity 0.7.6; contract LuckyFaucet { int64 public upperBound; int64 public lowerBound; constructor() payable { // start with 50M-100M wei Range until player changes it upperBound = 100_000_000; lowerBound = 50_000_000; } function setBounds(int64 _newLowerBound, int64 _newUpperBound) public { require(_newUpperBound &amp;lt;= 100_000_000, "100M wei is the max upperBound sry"); require(_newLowerBound &amp;lt;= 50_000_000, "50M wei is the max lowerBound sry"</description></item></channel></rss>