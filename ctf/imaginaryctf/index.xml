<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on 7Rocky</title><link>https://7rocky.github.io/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>aes</title><link>https://7rocky.github.io/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/aes/</guid><description>Se nos proporciona esta salida:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" Se trata del resultado de una consola de Python REPL. Lo que hace es coger una contraseña aleatoria de rockyou.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</guid><description>Se nos proporciona una página web para analizar. La página principal muestra el código fuente del servidor:
#!/usr/bin/env python3 fromflaskimportFlask, render_template_string, request, Response app=Flask(__name__) @app.route('/') defindex(): returnResponse(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') defssti(): query=request.args['query'] iflen(query) &amp;gt;2: return"Too long!" returnrender_template_string(query) app.run('0.0.0.0', 3002, debug=True) Se trata de una página web hecha en Flask (Python). Algo interesante es que el modo debug está activado.
El reto habla de SSTI (Server-Side Template Injection), pero solamente podemos introducir 2 bytes.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</guid><description>Se nos pide calcular -arcsin(-1) * 0.2 (en radianes) y coger los dígitos entre las posiciones 10000 y 10099 de la parte decimal del resultado.
Antes que nada, vamos a aplicar matemáticas:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$
Nótese que la función arco coseno está acotada: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Por tanto:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$</description></item><item><title>basic</title><link>https://7rocky.github.io/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/basic/</guid><description>Se nos pide representar 51 en base 12. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 Y la flag es ictf{43}.</description></item><item><title>Box</title><link>https://7rocky.github.io/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/box/</guid><description>Se nos proporciona el siguiente código en Python que cifra la flag:
fromCrypto.Util.numberimportbytes_to_long flag=open("flag.txt", "rb").read().strip() TABLE=[ lambdaa, b: f"({a}+{b})", lambdaa, b: f"({a}-{b})", lambdaa, b: f"({a}*{b})", ] defbuild_box(s: bytes): e="(x)" forbins: e=TABLE[b%len(TABLE)](e, b) returneval(f"lambda x: {e}") box=build_box(flag) ct=box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 """ Se trata de una forma extraña de cifrar un mensaje. Básicamente, box es un conjunto de operaciones que contiene una sola x, y al llamar a box con un valor dado, se sustituye dicho valor en la x para obtener el resultado final.</description></item><item><title>cos1</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos1/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 6 decimales. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos2/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 10 decimales. Para esto, podemos usar Wolfram Alpha:
Y la flag es:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Enormous</title><link>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* m=bytes_to_long(open('flag.txt', 'rb').read()) n=1 foriinrange(5): n*=getPrime(2025) e=31 c=pow(m, e, n) print(f'{n= }') print(f'{c= }') Y tenemos el texto cifrado $c$ y el módulo $n$ de una implementación RSA. Nótese que $e = 31$ es muy pequeño y que $n$ es muy grande. Por tanto, seremos capaces de hacer la raíz de orden 31 para recuperar el mensaje $m$, ya que</description></item><item><title>Fasting</title><link>https://7rocky.github.io/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/fasting/</guid><description>Se nos proporciona un servidor puzzler7.imaginaryctf.org:5005. Si enviamos una petición GET usando curl, obtenemos la siguiente respuesta:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Empleando ffuf, descubrimos dos rutas docs y redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Ambas sirven para mostrar una documentación de API para gente que quiera consumir dicha API:</description></item><item><title>Highlighter</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</guid><description>Se nos proporciona un binario llamado highlighter:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
intmain() { int__fd; longin_FS_OFFSET; undefined8 *where; undefined8 what; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setbuf(stdin, (char*) 0x0); setbuf(stdout, (char*) 0x0); __fd =open("flag.txt", 0); read(__fd, flag, 100); puts("Write what?"); __isoc99_scanf("%ld%*c", &amp;amp;what); puts("Where?"); __isoc99_scanf("%ld%*c", &amp;amp;where); *where =what; memset(flag, 0, 100); puts("</description></item><item><title>Highlights</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlights/</guid><description>Se nos proporciona un binario llamado highlights:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
intmain() { undefined8 *address; FILE *fp; setbuf(stdout, (char*) 0x0); setbuf(stdin, (char*) 0x0); fp =fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What address (in hex) would you like to read?\n&amp;gt;&amp;gt;&amp;gt; "); __isoc99_scanf("%lx%c", &amp;amp;address, &amp;amp;dead); printf("Value at 0x%x: %016lx\n"</description></item><item><title>Login Please</title><link>https://7rocky.github.io/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/login-please/</guid><description>Tenemos que iniciar sesión aquí: http://puzzler7.imaginaryctf.org:5001/:
Si inspeccionamos el código HTML de la página, veremos un comentario que apunta a /source:
Ahora tenemos el código fuente del servidor:
constexpress=require('express') constcrypto=require('crypto') functionmd5(text) { returncrypto.createHash('md5').update(text).digest('hex') } constapp=express() constusers={ guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } constlocalIPs=['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false})) app.use(express.json()) app.get('/', (req, res) =&amp;gt;{ res.send(` &amp;lt;form action="https://7rocky.github.io/login" method="POST"&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="username"&amp;gt;Username: &amp;lt;/label&amp;gt; &amp;lt;input name="username" type="text" id="username"&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="password"&amp;gt;Password: &amp;lt;/label&amp;gt; &amp;lt;input name="</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</guid><description>Se nos proporciona un archivo ZIP llamado flag.zip que contiene una imagen JPEG y también un archivo llamado .DS_Store, que es un archivo temporal que aparece en máquinas macOS:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>mixup</title><link>https://7rocky.github.io/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/mixup/</guid><description>Se nos proporciona un archivo flag.txt que contiene algunos caracteres Unicode. Este es el volcado hexadecimal del archivo:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</guid><description>Se nos proporciona un binario de 64 bits llamado notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, veremos la función main:
voidmain() { setbuf(stdout, (char*) 0x0); do{ notepad(); } while(true); } Básicamente, ejecuta notepad de forma infinita:
voidnotepad() { longin_FS_OFFSET; charoption; inti; undefined notes[136]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); for(i =0; i &amp;lt;128; i =i +1) { notes[i] =0; } puts("</description></item><item><title>Personalized</title><link>https://7rocky.github.io/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/personalized/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* fromrandomimportseed, getrandbits m=bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name=open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e=2*getrandbits(32)+1 p=getPrime(512) q=getPrime(512) n=p*q c=pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) foriinname)}!") print(f'{n= }') print(f'{e= }') print(f'{c= }') Utiliza una implementación de RSA en la que podemos proporcionar un nombre que será usado como semilla de un Generador de Números Pseudo-Aleatorios (PRNG, Pseudo-Random Number Generator).</description></item><item><title>Pickle</title><link>https://7rocky.github.io/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pickle/</guid><description>Se nos proporciona un archivo llamado out.pickle. La flag está almacenada dentro, podemos visualizar su contenido en hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>pqqp</title><link>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</guid><description>Se nos proporciona este código en Python que cifra la flag:
fromCrypto.Util.numberimport* p=getPrime(1024) q=getPrime(1024) n=p*q e=65537 m=bytes_to_long(open("flag.txt", "rb").read().strip()) c=pow(m, e, n) pqqp=(pow(p, q, n) +pow(q, p, n)) %n print(f"{n= }") print(f"{e= }") print(f"{c= }") print(f"{pqqp= }") Y tenemos el archivo output.txt:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 En primer lugar, tenemos que expresar $p^q + q^p \pmod{n}$ de otra manera.
Por el Pequeño Teorema de Fermat, tenemos que:</description></item><item><title>Reflection</title><link>https://7rocky.github.io/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/reflection/</guid><description>Se nos proporciona un archivo binario llamado reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped Si abrimos Ghidra y echamos un vistazo al código fuente en C descompilado, veremos la función main:
undefined8 main() { longj; char*__format; byte flag_input[100]; intk; int_j; int_length; inti; intlength; printf("&amp;gt;&amp;gt;&amp;gt; "); fgets((char*) flag_input, 100, stdin); _length =0; _j =0; k =0; while(true) { length =_length; i =_j; j =(long)_j; _j =_j +1; if((flag[j] ^flag_input[i]) !</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* p=getPrime(512) q=getPrime(512) n=p * q phi=(p - 1) * (q - 1) d=getPrime(32) e=pow(d, -1, phi) m=bytes_to_long(open('flag.txt', 'rb').read()) c=pow(m, e, n) print(f'{n= }') print(f'{e= }') print(f'{c= }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' El criptosistema utilizado es RSA, pero la implementación es errónea. El problema es que el número privado $d$ es relativamente pequeño (un número primo de 32 bits).</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>Se nos proporciona el código fuente de un servidor que ejecuta un Algoritmo de Firma Digital (DSA, Digital Signature Algorithm):
fromCrypto.Util.numberimportgetPrime, isPrime, inverse fromhashlibimportsha256 fromrandomimportrandrange q, g=0, 2 whilenotisPrime(p:=2*q+1) orpow(g, q, p) !=1: q=getPrime(256) x=randrange(2, q) y=pow(g, x, p) defH(m): returnint.from_bytes(sha256(m).digest(), 'big') defsign(m): k=randrange(2, q) r=pow(g, k, p) %q s=(H(m) +r*x) *inverse(k, q) %q returnr, s defverify(m, r, s): u=inverse(s, q) returnpow(g, u*H(m), p) *pow(y, u*r, p) %p%q==r defmain(): print("Hello admin, here are the parameters!</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>Se nos da un socket al que conectarnos. Al realizar la conexión se muestra el código fuente usado para cifrar la flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 fromCrypto.Util.numberimport* classRotator: QUEUE_LENGTH=10 def__init__(self): self.e=65537 self.m=bytes_to_long(open('flag.txt', 'rb').read()) self.queue=[getPrime(512) foriinrange(self.QUEUE_LENGTH)] defget_new_primes(self): ret=self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt;self.QUEUE_LENGTH): self.queue=[getPrime(512)] +self.queue returntuple(ret) defenc_flag(self): p, q=self.get_new_primes() n=p*q print(f"Public key: {(n, self.e)}") print(f"Your encrypted flag: {pow(self.m, self.e, n)}") rot=Rotator() print('='*80) print(open(__file__).read()) print('='*80) whileTrue: inp=input("Would you like an encrypted flag (y/n)?</description></item><item><title>same</title><link>https://7rocky.github.io/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/same/</guid><description>Se nos proporciona un código fuente en Python para cifrar la flag:
fromCrypto.Util.numberimportgetPrime, bytes_to_long m=bytes_to_long(open("flag", "rb").read()) n=getPrime(512)*getPrime(512) e=[1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) Y tenemos la salida del programa:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 El criptosistema utilizado es RSA, pero tiene una vulnerabilidad. La flag ($m$) se cifra dos veces como
$$ c_1 = m ^ {e_1} \pmod{n} $$
$$ c_2 = m ^ {e_2} \pmod{n} $$
El problema aquí es que el mismo mensaje se eleva a dos exponentes diferentes pero usando el mismo módulo $n$.</description></item><item><title>Shifted</title><link>https://7rocky.github.io/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/shifted/</guid><description>Se nos proporciona este código fuente en Python:
importstring importrandom flag=open("flag.txt").read().strip() mystery_num=random.randint(100,1000) new_alphabet=list(string.ascii_lowercase+string.digits+string.punctuation) enc_flag="" defshift(char): index=new_alphabet.index(char) new_index=(index+mystery_num) %len(new_alphabet) returnnew_alphabet[new_index] forcharinflag: enc_flag+=shift(char) mystery_num+=10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t Lo que hace el script es crear un alfabeto y un número aleatorio (mystery_num). Luego, para cifrar la flag, encuentra el índice del carácter en texto claro correspondiente, le suma el número aleatorio (módulo la longitud del alfabeto) y devuelve el carácter en ese nuevo índice.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</guid><description>Se nos proporciona un binario de 64 bits llamado vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, vemos la función main:
undefined8 main() { longin_FS_OFFSET; charlocal_118[264]; longlocal_10; local_10 =*(long*) (in_FS_OFFSET +0x28); setvbuf(stdout, (char*) 0x0, 2, 0); setvbuf(stdin, (char*) 0x0, 2, 0); puts("Send your string to be printed:"); fgets(local_118, 256, stdin); printf(local_118); puts("</description></item><item><title>XORed</title><link>https://7rocky.github.io/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xored/</guid><description>El programa dice que alguien ha usado un cifrado XOR con una clave de un solo byte. Este es el resultado: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Como sabemos que las flags empiezan por ictf{, podemos obtener la clave mediante &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; debido a las propiedades del cifrado XOR:
$$ c = m \oplus k \iff k = c \oplus m $$
Entonces podemos resolver el reto así:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</guid><description>Se nos proporciona el código fuente para cifrar la flag, y también el texto cifrado como un comentario en el código:
#!/usr/bin/env python3 flag=open('flag.txt', 'rb').read() key=open('/dev/urandom','rb').read(1)[0] out=[] forcinflag: out.append(c ^ key) key=c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' A partir del código fuente, podemos ver que la clave es un solo byte. Además, la clave se actualiza con el caracter en claro actual.
Por tanto, podemos utilizar un script en Python para solucionar el reto:</description></item></channel></rss>