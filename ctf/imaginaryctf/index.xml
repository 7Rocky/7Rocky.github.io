<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on 7Rocky</title><link>https://7rocky.github.io/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>Almost SSTI</title><link>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</guid><description>Se nos proporciona una página web para analizar. La página principal muestra el código fuente del servidor:
#!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;flask&amp;nbsp;import&amp;nbsp;Flask,&amp;nbsp;render_template_string,&amp;nbsp;request,&amp;nbsp;Response app&amp;nbsp;=&amp;nbsp;Flask(__name__) @app.route('/') def&amp;nbsp;index(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;Response(open(__file__).read(),&amp;nbsp;mimetype='text/plain') @app.route('/ssti') def&amp;nbsp;ssti(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;query&amp;nbsp;=&amp;nbsp;request.args['query'] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;len(query)&amp;nbsp;&amp;gt;&amp;nbsp;2: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"Too&amp;nbsp;long!" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;render_template_string(query) app.run('0.0.0.0',&amp;nbsp;3002,&amp;nbsp;debug=True) Se trata de una página web hecha en Flask (Python). Algo interesante es que el modo debug está activado.
El reto habla de SSTI (Server-Side Template Injection), pero solamente podemos introducir 2 bytes. Esta longitud hace imposible explotar un SSTI.</description></item><item><title>basic</title><link>https://7rocky.github.io/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/basic/</guid><description>Se nos pide representar 51 en base 12. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 Y la flag es ictf{43}.</description></item><item><title>cos1</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos1/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 6 decimales. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</guid><description>Se nos proporciona un archivo ZIP llamado flag.zip que contiene una imagen JPEG y también un archivo llamado .DS_Store, que es un archivo temporal que aparece en máquinas macOS:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</guid><description>Se nos proporciona un binario de 64 bits llamado notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, veremos la función main:
void&amp;nbsp;main()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;setbuf(stdout,&amp;nbsp;(char&amp;nbsp;*)&amp;nbsp;0x0); &amp;nbsp;&amp;nbsp;do&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notepad(); &amp;nbsp;&amp;nbsp;}&amp;nbsp;while&amp;nbsp;(true); } Básicamente, ejecuta notepad de forma infinita:
void&amp;nbsp;notepad()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;long&amp;nbsp;in_FS_OFFSET; &amp;nbsp;&amp;nbsp;char&amp;nbsp;option; &amp;nbsp;&amp;nbsp;int&amp;nbsp;i; &amp;nbsp;&amp;nbsp;undefined&amp;nbsp;notes[136]; &amp;nbsp;&amp;nbsp;long&amp;nbsp;canary; &amp;nbsp;&amp;nbsp;canary&amp;nbsp;=&amp;nbsp;*(long&amp;nbsp;*)&amp;nbsp;(in_FS_OFFSET&amp;nbsp;+&amp;nbsp;0x28); &amp;nbsp;&amp;nbsp;for&amp;nbsp;(i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&amp;lt;&amp;nbsp;128;&amp;nbsp;i&amp;nbsp;=&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notes[i]&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;puts("Welcome&amp;nbsp;to&amp;nbsp;Notepad&amp;nbsp;as&amp;nbsp;a&amp;nbsp;Service!"); &amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("Menu:"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("1)&amp;nbsp;View&amp;nbsp;note"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("2)&amp;nbsp;Edit&amp;nbsp;note"); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;puts("</description></item><item><title>Pickle</title><link>https://7rocky.github.io/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pickle/</guid><description>Se nos proporciona un archivo llamado out.pickle. La flag está almacenada dentro, podemos visualizar su contenido en hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>Reflection</title><link>https://7rocky.github.io/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/reflection/</guid><description>Se nos proporciona un archivo binario llamado reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped Si abrimos Ghidra y echamos un vistazo al código fuente en C descompilado, veremos la función main:
undefined8&amp;nbsp;main()&amp;nbsp;{ &amp;nbsp;&amp;nbsp;long&amp;nbsp;j; &amp;nbsp;&amp;nbsp;char&amp;nbsp;*__format; &amp;nbsp;&amp;nbsp;byte&amp;nbsp;flag_input[100]; &amp;nbsp;&amp;nbsp;int&amp;nbsp;k; &amp;nbsp;&amp;nbsp;int&amp;nbsp;_j; &amp;nbsp;&amp;nbsp;int&amp;nbsp;_length; &amp;nbsp;&amp;nbsp;int&amp;nbsp;i; &amp;nbsp;&amp;nbsp;int&amp;nbsp;length; &amp;nbsp;&amp;nbsp;printf("&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;"); &amp;nbsp;&amp;nbsp;fgets((char&amp;nbsp;*)&amp;nbsp;flag_input,&amp;nbsp;100,&amp;nbsp;stdin); &amp;nbsp;&amp;nbsp;_length&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;_j&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;k&amp;nbsp;=&amp;nbsp;0; &amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;length&amp;nbsp;=&amp;nbsp;_length; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;i&amp;nbsp;=&amp;nbsp;_j; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;j&amp;nbsp;=&amp;nbsp;(long)_j; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_j&amp;nbsp;=&amp;nbsp;_j&amp;nbsp;+&amp;nbsp;1; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;((flag[j]&amp;nbsp;^&amp;nbsp;flag_input[i])&amp;nbsp;!=&amp;nbsp;*(byte&amp;nbsp;*)&amp;nbsp;((long)&amp;nbsp;k&amp;nbsp;+&amp;nbsp;0x100000))&amp;nbsp;break; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_length&amp;nbsp;=&amp;nbsp;_length&amp;nbsp;+&amp;nbsp;1; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(64&amp;nbsp;&amp;lt;&amp;nbsp;length)&amp;nbsp;break; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;do&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;k&amp;nbsp;=&amp;nbsp;k&amp;nbsp;+&amp;nbsp;1; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;while&amp;nbsp;(*(char&amp;nbsp;*)&amp;nbsp;((long)&amp;nbsp;k&amp;nbsp;+&amp;nbsp;0x100000)&amp;nbsp;==&amp;nbsp;'\0'); &amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;if&amp;nbsp;(_length&amp;nbsp;==&amp;nbsp;65)&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;__format&amp;nbsp;=&amp;nbsp;"</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;Crypto.Util.number&amp;nbsp;import&amp;nbsp;* p&amp;nbsp;=&amp;nbsp;getPrime(512) q&amp;nbsp;=&amp;nbsp;getPrime(512) n&amp;nbsp;=&amp;nbsp;p * q phi&amp;nbsp;=&amp;nbsp;(p - 1) * (q - 1) d&amp;nbsp;=&amp;nbsp;getPrime(32) e&amp;nbsp;=&amp;nbsp;pow(d,&amp;nbsp;-1,&amp;nbsp;phi) m&amp;nbsp;=&amp;nbsp;bytes_to_long(open('flag.txt',&amp;nbsp;'rb').read()) c&amp;nbsp;=&amp;nbsp;pow(m,&amp;nbsp;e,&amp;nbsp;n) print(f'{n&amp;nbsp;=&amp;nbsp;}') print(f'{e&amp;nbsp;=&amp;nbsp;}') print(f'{c&amp;nbsp;=&amp;nbsp;}') ''' n&amp;nbsp;=&amp;nbsp;134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e&amp;nbsp;=&amp;nbsp;50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c&amp;nbsp;=&amp;nbsp;133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' El criptosistema utilizado es RSA, pero la implementación es errónea. El problema es que el número privado $d$ es relativamente pequeño (un número primo de 32 bits). Por tanto, podemos romper el cifrado con el ataque de Wiener.</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>Se nos da un socket al que conectarnos. Al realizar la conexión se muestra el código fuente usado para cifrar la flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env&amp;nbsp;python3 from&amp;nbsp;Crypto.Util.number&amp;nbsp;import&amp;nbsp;* class&amp;nbsp;Rotator: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;QUEUE_LENGTH&amp;nbsp;=&amp;nbsp;10 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;__init__(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.e&amp;nbsp;=&amp;nbsp;65537 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.m&amp;nbsp;=&amp;nbsp;bytes_to_long(open('flag.txt',&amp;nbsp;'rb').read()) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue&amp;nbsp;=&amp;nbsp;[getPrime(512)&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;range(self.QUEUE_LENGTH)] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;get_new_primes(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ret&amp;nbsp;=&amp;nbsp;self.queue[-2:] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue.pop() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while(len(self.queue)&amp;nbsp;&amp;lt;&amp;nbsp;self.QUEUE_LENGTH): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;self.queue&amp;nbsp;=&amp;nbsp;[getPrime(512)]&amp;nbsp;+&amp;nbsp;self.queue &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;tuple(ret) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def&amp;nbsp;enc_flag(self): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p,&amp;nbsp;q&amp;nbsp;=&amp;nbsp;self.get_new_primes() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n&amp;nbsp;=&amp;nbsp;p*q &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print(f"Public&amp;nbsp;key:&amp;nbsp;{(n,&amp;nbsp;self.e)}") &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print(f"Your&amp;nbsp;encrypted&amp;nbsp;flag:&amp;nbsp;{pow(self.m,&amp;nbsp;self.e,&amp;nbsp;n)}") rot&amp;nbsp;=&amp;nbsp;Rotator() print('='*80) print(open(__file__).read()) print('='*80) while&amp;nbsp;True: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inp&amp;nbsp;=&amp;nbsp;input("Would&amp;nbsp;you&amp;nbsp;like&amp;nbsp;an&amp;nbsp;encrypted&amp;nbsp;flag&amp;nbsp;(y/n)?&amp;nbsp;") &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;'y'&amp;nbsp;in&amp;nbsp;inp.lower(): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rot.enc_flag() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break ================================================================================ Would you like an encrypted flag (y/n)? ^C El criptosistema utilizado es RSA, pero la implementación es errónea.</description></item><item><title>xorrot</title><link>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</guid><description>Se nos proporciona el código fuente para cifrar la flag, y también el texto cifrado como un comentario en el código:
#!/usr/bin/env&amp;nbsp;python3 flag&amp;nbsp;=&amp;nbsp;open('flag.txt',&amp;nbsp;'rb').read() key&amp;nbsp;=&amp;nbsp;open('/dev/urandom','rb').read(1)[0] out&amp;nbsp;=&amp;nbsp;[] for&amp;nbsp;c&amp;nbsp;in&amp;nbsp;flag: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;out.append(c ^ key) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;key&amp;nbsp;=&amp;nbsp;c print(f'{bytes(out).hex()&amp;nbsp;=&amp;nbsp;}') #&amp;nbsp;bytes(out).hex()&amp;nbsp;=&amp;nbsp;'970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' A partir del código fuente, podemos ver que la clave es un solo byte. Además, la clave se actualiza con el caracter en claro actual.
Por tanto, podemos utilizar un script en Python para solucionar el reto:</description></item></channel></rss>