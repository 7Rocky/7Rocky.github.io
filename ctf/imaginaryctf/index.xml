<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ImaginaryCTF on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/imaginaryctf/</link><description>Recent content in ImaginaryCTF on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/imaginaryctf/index.xml" rel="self" type="application/rss+xml"/><item><title>A Puzzle in Seven Parts</title><link>https://7rocky.github.io/ctf/imaginaryctf/a-puzzle-in-seven-parts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/a-puzzle-in-seven-parts/</guid><description>Se nos proporciona esta cadena de texto:
AbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDEFGaBCdefgAbCDeFGABCdeFGAbCDeFGABCdefgaBCdeFGAbCDeFGABCdefgABCDEFGAbCDeFGAbCDeFGAbCDeFGABCDEFGAbCDEFGaBCdeFGaBCdeFGAbcDEFGAbCDeFGAbCDEFGAbCDeFGABCdefgAbCDeFGABcDEfGABCdefgaBCdefgAbCDeFGAbCDeFGABCDefGABCDEFgAbCDeFGABCdEFGAbCDEFGaBCdefgAbCDEFGABCDefGAbCDEFGAbcDEFgAbCDeFGAbCDeFGABCdefgABCdefgAbCDEFGaBCdefgaBCdeFGAbCDeFGaBCdeFGAbcDEFGAbCDEFGABCdEFGAbCDeFGABcDEfGAbCDEFGAbcDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDeFGAbCDeFGAbCDeFGABCdefgABCDefGAbCDeFGAbCDEFGabCDEFGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGABCDEFGAbCDeFGABCdefgaBCdeFGaBCDEfGAbCDeFGAbCDEFGaBCdeFGABCdEFGAbCDeFGABCDEFGAbCDeFGABCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCdEFGAbCDEFGaBCdeFGABCDefGABcDEfGaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGABCdefgAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDeFGABCDefGaBCdeFGaBCDEfGABCDefGABCDEFgaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGAbCDeFGaBCdeFGABCdefgaBCdeFGAbcDEFGAbCDeFGABCDEFGAbCDeFGABCDefGAbCDEFGabCDEFGAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgAbCDEFGABCDEFGAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbcDEFgAbCDeFGABcDEfGAbCDeFGABCdefgAbCDeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGaBCdeFGAbCDeFGABCDEFGAbCDEFGABCDefGaBCdeFGAbCDeFGAbCDEFGaBCdeFGAbCDEFGabCDEFGaBCdeFGaBCDEfGAbCDeFGAbCDEFGAbCDEFGAbcDEFgABCDefGABCDefGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgABCDefGAbCDeFGABCdeFGAbCDeFGAbCDEFGaBCdeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgaBCdeFGaBCDEfGABCDefGaBCdefgAbCDeFGaBCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDEFGabCDEFGAbCDeFGABCdefgAbCDeFGABCdefgaBCdeFGAbcDEFGaBCdeFGAbCDEFGAbCDeFGABCdefgAbCDEFGabCDEFGABCDefGABCdeFGAbCDeFGABCdefgaBCdeFGaBCDEfGaBCdeFGAbCDEFGABCdefgABCDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDEFGabCDEFGAbCDEFGABCDefGABCDefGaBCdefgAbCDeFGAbCDeFGABCDefGaBCdefgAbCDeFGABCdeFGABCdefgABCdeFGAbCDeFGABCDefGAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDEFGABCdEFGAbCDeFGABCDefGaBCdeFGAbCDeFGABCdefgABCDEFgAbCDeFGABCdefgAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDeFGABCdEFGAbCDEFGaBCdefgaBCdeFGaBCDEfGABCDefGaBCdefgABCdefgABCDEFgaBCdeFGAbCDeFGAbCDeFGABcDEfGAbCDEFGAbcDEFGAbCDEFGaBCdeFGAbCDeFGaBCdeFGAbCDeFGABcDEfGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDeFGABCdEFGAbCDeFGAbCDEFGaBCdeFGABCdefgABCDefGaBCdefgAbCDEFGAbcdEFGAbCDeFGAbCDeFGABCDefGABCDEFgABCDefGaBCdefgaBCdeFGABCdeFGAbCDeFGaBCdefgAbCDEFGabCDEFGABCdefgaBCdeFGAbCDeFGABCdefgAbCDeFGABcDEfGAbCDEFGAbcDEFgAbCDeFGABCdEFGAbCDeFGABCDefGAbCDeFGABCdEFGaBCdeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCDefGAbCDeFGAbCDeFGAbCDEFGAbcDEFgaBCdeFGABcDEfGAbCDeFGAbCDeFGaBCdeFGaBCDEfGaBCdeFGaBCdeFGABCDefGABCDEFgABCDefGaBCDEfG Display de siete segmentos Como sugiere el reto, el texto anterior debe estar relacionado con un display de siete segmentos:
Por ejemplo, las primeras 7 letras son AbCDeFG, que forman un 5 (las letras mayúsculas están encendidas y las letras minúsculas están apagadas). Usemos Python para dividir toda la cadena en trozos de 7 letras y eliminar las letras minúsculas:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import re &amp;gt;&amp;gt;&amp;gt; m = 'AbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDEFGaBCdefgAbCDeFGABCdeFGAbCDeFGABCdefgaBCdeFGAbCDeFGABCdefgABCDEFGAbCDeFGAbCDeFGAbCDeFGABCDEFGAbCDEFGaBCdeFGaBCdeFGAbcDEFGAbCDeFGAbCDEFGAbCDeFGABCdefgAbCDeFGABcDEfGABCdefgaBCdefgAbCDeFGAbCDeFGABCDefGABCDEFgAbCDeFGABCdEFGAbCDEFGaBCdefgAbCDEFGABCDefGAbCDEFGAbcDEFgAbCDeFGAbCDeFGABCdefgABCdefgAbCDEFGaBCdefgaBCdeFGAbCDeFGaBCdeFGAbcDEFGAbCDEFGABCdEFGAbCDeFGABcDEfGAbCDEFGAbcDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDeFGAbCDeFGAbCDeFGABCdefgABCDefGAbCDeFGAbCDEFGabCDEFGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGABCDEFGAbCDeFGABCdefgaBCdeFGaBCDEfGAbCDeFGAbCDEFGaBCdeFGABCdEFGAbCDeFGABCDEFGAbCDeFGABCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCdEFGAbCDEFGaBCdeFGABCDefGABcDEfGaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGABCdefgAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDeFGABCDefGaBCdeFGaBCDEfGABCDefGABCDEFgaBCdeFGABCdEFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbCDEFGABCdEFGaBCdeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGAbCDeFGaBCdeFGABCdefgaBCdeFGAbcDEFGAbCDeFGABCDEFGAbCDeFGABCDefGAbCDEFGabCDEFGAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgAbCDEFGABCDEFGAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDEFGAbcDEFgAbCDeFGABcDEfGAbCDeFGABCdefgAbCDeFGAbCDEFGAbCDeFGAbCDEFGAbCDEFGaBCdeFGAbCDeFGABCDEFGAbCDEFGABCDefGaBCdeFGAbCDeFGAbCDEFGaBCdeFGAbCDEFGabCDEFGaBCdeFGaBCDEfGAbCDeFGAbCDEFGAbCDEFGAbcDEFgABCDefGABCDefGAbCDeFGaBCdeFGABCDefGaBCdefgAbCDeFGABCdEFGABCdefgABCDefGAbCDeFGABCdeFGAbCDeFGAbCDEFGaBCdeFGABCdEFGABCdefgAbCDeFGAbCDeFGaBCdefgAbCDEFGAbcDEFgAbCDEFGAbcDEFgAbCDeFGAbCDEFGAbCDEFGABcDEfGaBCdeFGABCdefgaBCdeFGaBCDEfGABCDefGaBCdefgAbCDeFGaBCdeFGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDEFGabCDEFGAbCDeFGABCdefgAbCDeFGABCdefgaBCdeFGAbcDEFGaBCdeFGAbCDEFGAbCDeFGABCdefgAbCDEFGabCDEFGABCDefGABCdeFGAbCDeFGABCdefgaBCdeFGaBCDEfGaBCdeFGAbCDEFGABCdefgABCDEFgaBCdeFGABCdEFGAbCDeFGAbCDEFGAbCDEFGabCDEFGAbCDEFGABCDefGABCDefGaBCdefgAbCDeFGAbCDeFGABCDefGaBCdefgAbCDeFGABCdeFGABCdefgABCdeFGAbCDeFGABCDefGAbCDEFGAbcDEFgAbCDEFGaBCdeFGAbCDEFGABCdEFGAbCDeFGABCDefGaBCdeFGAbCDeFGABCdefgABCDEFgAbCDeFGABCdefgAbCDeFGaBCdeFGAbCDeFGAbCDeFGAbCDeFGABCdEFGAbCDEFGaBCdefgaBCdeFGaBCDEfGABCDefGaBCdefgABCdefgABCDEFgaBCdeFGAbCDeFGAbCDeFGABcDEfGAbCDEFGAbcDEFGAbCDEFGaBCdeFGAbCDeFGaBCdeFGAbCDeFGABcDEfGAbCDeFGaBCdeFGaBCdeFGAbCDEFGAbCDeFGABCdEFGAbCDeFGAbCDEFGaBCdeFGABCdefgABCDefGaBCdefgAbCDEFGAbcdEFGAbCDeFGAbCDeFGABCDefGABCDEFgABCDefGaBCdefgaBCdeFGABCdeFGAbCDeFGaBCdefgAbCDEFGabCDEFGABCdefgaBCdeFGAbCDeFGABCdefgAbCDeFGABcDEfGAbCDEFGAbcDEFgAbCDeFGABCdEFGAbCDeFGABCDefGAbCDeFGABCdEFGaBCdeFGaBCdeFGaBCdeFGAbCDEFGaBCdeFGABCDefGAbCDeFGAbCDeFGAbCDEFGAbcDEFgaBCdeFGABcDEfGAbCDeFGAbCDeFGaBCdeFGaBCDEfGaBCdeFGaBCdeFGABCDefGABCDEFgABCDefGaBCDEfG' &amp;gt;&amp;gt;&amp;gt; ms = [m[i : i + 7] for i in range(0, len(m), 7)] &amp;gt;&amp;gt;&amp;gt; ms = [re.</description></item><item><title>A Very Good Place to Start</title><link>https://7rocky.github.io/ctf/imaginaryctf/a-very-good-place-to-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/a-very-good-place-to-start/</guid><description>Se nos proporciona un binario de 64 bits llamado start:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Si usamos Ghidra para extraer el código fuente en C descompilado, veremos la siguiente función main:
int main() { int ret; char name[64]; FILE *fp; uint i; setbuf(stdout, NULL); setbuf(stdin, NULL); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What\'s your name? "); fgets(name, 128, stdin); i = 0; do { if (63 &amp;lt; i) { LAB_00401240: ret = strcmp("</description></item><item><title>AAAA</title><link>https://7rocky.github.io/ctf/imaginaryctf/aaaa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/aaaa/</guid><description>Se nos proporciona el dominio number6challenge.imaginaryctf.org.
Enumeración por DNS Como el reto se llama &amp;ldquo;AAAA&amp;rdquo;, podemos pensar en el registro de tipo AAAA de DNS (más información aquí). Para comprobarlo, podemos usar dig:
$ dig number6challenge.imaginaryctf.org AAAA ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; number6challenge.imaginaryctf.org AAAA ;; global options: +cmd ;; Got answer: ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 14021 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;number6challenge.</description></item><item><title>aes</title><link>https://7rocky.github.io/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/aes/</guid><description>Se nos proporciona esta salida:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" Se trata del resultado de una consola de Python REPL. Lo que hace es coger una contraseña aleatoria de rockyou.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</guid><description>Se nos proporciona una página web para analizar. La página principal muestra el código fuente del servidor:
#!/usr/bin/env python3 from flask import Flask, render_template_string, request, Response app = Flask(__name__) @app.route('/') def index(): return Response(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') def ssti(): query = request.args['query'] if len(query) &amp;gt; 2: return "Too long!" return render_template_string(query) app.run('0.0.0.0', 3002, debug=True) Se trata de una página web hecha en Flask (Python). Algo interesante es que el modo debug está activado.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</guid><description>Se nos pide calcular -arcsin(-1) * 0.2 (en radianes) y coger los dígitos entre las posiciones 10000 y 10099 de la parte decimal del resultado.
Antes que nada, vamos a aplicar matemáticas:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$ Nótese que la función arco coseno está acotada: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Por tanto:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$ Entonces, nos preguntan por las dígitos de $\pi$ entre las posiciones 10000 y 10099.</description></item><item><title>base64</title><link>https://7rocky.github.io/ctf/imaginaryctf/base64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/base64/</guid><description>Se nos da este texto:
aWN0ZntfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX30= Parece que los datos están codificados en Base64&amp;hellip; Y el reto se llama &amp;ldquo;base64&amp;rdquo;, por lo que todo está claro.
Flag Esta es la flag:
$ echo aWN0ZntfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX30= | base64 -d ictf{___________________________________}</description></item><item><title>basic</title><link>https://7rocky.github.io/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/basic/</guid><description>Se nos pide representar 51 en base 12. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) -> int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 Y la flag es ictf{43}.</description></item><item><title>Box</title><link>https://7rocky.github.io/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/box/</guid><description>Se nos proporciona el siguiente código en Python que cifra la flag:
from Crypto.Util.number import bytes_to_long flag = open("flag.txt", "rb").read().strip() TABLE = [ lambda a, b: f"({a}+{b})", lambda a, b: f"({a}-{b})", lambda a, b: f"({a}*{b})", ] def build_box(s: bytes): e = "(x)" for b in s: e = TABLE[b % len(TABLE)](e, b) return eval(f"lambda x: {e}") box = build_box(flag) ct = box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 "</description></item><item><title>cos1</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos1/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 6 decimales. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos2/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 10 decimales. Para esto, podemos usar Wolfram Alpha:
Y la flag es:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Easy DSA: Elated once</title><link>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-elated-once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-elated-once/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def H(msg): return int.from_bytes(sha256(msg).digest(), 'big') def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y def gen_nonces(): a = randrange(2, q) b = randrange(2, q) k = 0 while 1: k = (a*k + b) % q yield k def sign(m): k = next(nonces) r = pow(g, k, p) % q s = (H(m) + x*r) * pow(k, -1, q) % q return r, s def verify(m, r, s): assert 0 &amp;lt; r &amp;lt; q and 0 &amp;lt; s &amp;lt; q u = pow(s, -1, q) v = pow(g, H(m) * u, p) * pow(y, r * u, p) % p % q return v == r flag = b"</description></item><item><title>Easy DSA: Lovely Little Lane</title><link>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-lovely-little-lane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-lovely-little-lane/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y def H(msg): return int.</description></item><item><title>Easy DSA: The beginning</title><link>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-the-beginning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/easy-dsa-the-beginning/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from Crypto.Util.Padding import pad from Crypto.Util.number import isPrime, getPrime, long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 from random import randrange def gen_key(): p = 0 while not isPrime(p): q = getPrime(300) p = 2*q + 1 g = randrange(2, p)**2 % p k = randrange(2, q) x = randrange(2, q) y = pow(g, x, p) return p, q, g, x, y, k def H(msg): return int.</description></item><item><title>Enormous</title><link>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 from Crypto.Util.number import * m = bytes_to_long(open('flag.txt', 'rb').read()) n = 1 for i in range(5): n *= getPrime(2025) e = 31 c = pow(m, e, n) print(f'{n = }') print(f'{c = }') Y tenemos el texto cifrado $c$ y el módulo $n$ de una implementación RSA. Nótese que $e = 31$ es muy pequeño y que $n$ es muy grande.</description></item><item><title>Fasting</title><link>https://7rocky.github.io/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/fasting/</guid><description>Se nos proporciona un servidor puzzler7.imaginaryctf.org:5005. Si enviamos una petición GET usando curl, obtenemos la siguiente respuesta:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Empleando ffuf, descubrimos dos rutas docs y redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Ambas sirven para mostrar una documentación de API para gente que quiera consumir dicha API:</description></item><item><title>Fleeting</title><link>https://7rocky.github.io/ctf/imaginaryctf/fleeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/fleeting/</guid><description>Se nos proporciona este código en Python para cifrar la flag, y también el texto cifrado como un comentario:
print((f:=lambda s:s and[s[0]^s[-1],*f(s[::-1][1:])])([*open('flag','rb')][0])) #[20, 37, 47, 47, 56, 52, 38, 46, 51, 56, 23, 58, 57, 50, 86, 95, 95, 103, 0] Análisis de código fuente Si analizamos el código, veremos que se define una función lambda nombrada f y la llama con el contenido de la flag en bytes:
$ echo -n 'ictf{test_flag}' &amp;gt; flag $ python3 -q &amp;gt;&amp;gt;&amp;gt; [*open('flag','rb')][0] b'ictf{test_flag}' Entonces, f es una función que devuelve s and [.</description></item><item><title>Highlighter</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</guid><description>Se nos proporciona un binario llamado highlighter:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
int main() { int __fd; long in_FS_OFFSET; undefined8 *where; undefined8 what; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); setbuf(stdin, (char *) 0x0); setbuf(stdout, (char *) 0x0); __fd = open("flag.txt", 0); read(__fd, flag, 100); puts("</description></item><item><title>Highlights</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlights/</guid><description>Se nos proporciona un binario llamado highlights:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
int main() { undefined8 *address; FILE *fp; setbuf(stdout, (char *) 0x0); setbuf(stdin, (char *) 0x0); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What address (in hex) would you like to read?\n&amp;gt;&amp;gt;&amp;gt; "); __isoc99_scanf("%lx%c", &amp;amp;address, &amp;amp;dead); printf("</description></item><item><title>Instructive</title><link>https://7rocky.github.io/ctf/imaginaryctf/instructive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/instructive/</guid><description>Se nos proporciona un binario de 64 bits llamado instructive:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Si cargamos el binario en Ghidra, veremos esta función main:
int main() { int ret; undefined flag[136]; char *data; FILE *fp; int j; int i; setbuf(stdout, NULL); setbuf(stdin, NULL); fp = fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); data = (char *) malloc(128); printf("Please enter your username: "</description></item><item><title>Login Please</title><link>https://7rocky.github.io/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/login-please/</guid><description>Tenemos que iniciar sesión aquí: http://puzzler7.imaginaryctf.org:5001/:
Si inspeccionamos el código HTML de la página, veremos un comentario que apunta a /source:
Ahora tenemos el código fuente del servidor:
const express = require('express') const crypto = require('crypto') function md5(text) { return crypto.createHash('md5').update(text).digest('hex') } const app = express() const users = { guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } const localIPs = ['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false })) app.use(express.json()) app.get('/', (req, res) =&amp;gt; { res.</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</guid><description>Se nos proporciona un archivo ZIP llamado flag.zip que contiene una imagen JPEG y también un archivo llamado .DS_Store, que es un archivo temporal que aparece en máquinas macOS:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>mixup</title><link>https://7rocky.github.io/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/mixup/</guid><description>Se nos proporciona un archivo flag.txt que contiene algunos caracteres Unicode. Este es el volcado hexadecimal del archivo:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</guid><description>Se nos proporciona un binario de 64 bits llamado notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, veremos la función main:
void main() { setbuf(stdout, (char *) 0x0); do { notepad(); } while (true); } Básicamente, ejecuta notepad de forma infinita:
void notepad() { long in_FS_OFFSET; char option; int i; undefined notes[136]; long canary; canary = *(long *) (in_FS_OFFSET + 0x28); for (i = 0; i &amp;lt; 128; i = i + 1) { notes[i] = 0; } puts("</description></item><item><title>Personalized</title><link>https://7rocky.github.io/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/personalized/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 from Crypto.Util.number import * from random import seed, getrandbits m = bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name = open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e = 2*getrandbits(32)+1 p = getPrime(512) q = getPrime(512) n = p*q c = pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) for i in name)}!") print(f'{n = }') print(f'{e = }') print(f'{c = }') Utiliza una implementación de RSA en la que podemos proporcionar un nombre que será usado como semilla de un Generador de Números Pseudo-Aleatorios (PRNG, Pseudo-Random Number Generator).</description></item><item><title>Pickle</title><link>https://7rocky.github.io/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pickle/</guid><description>Se nos proporciona un archivo llamado out.pickle. La flag está almacenada dentro, podemos visualizar su contenido en hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>pqqp</title><link>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</guid><description>Se nos proporciona este código en Python que cifra la flag:
from Crypto.Util.number import * p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 m = bytes_to_long(open("flag.txt", "rb").read().strip()) c = pow(m, e, n) pqqp = (pow(p, q, n) + pow(q, p, n)) % n print(f"{n = }") print(f"{e = }") print(f"{c = }") print(f"{pqqp = }") Y tenemos el archivo output.txt:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 En primer lugar, tenemos que expresar $p^q + q^p \mod{n}$ de otra manera.</description></item><item><title>Rather Secure Attachment</title><link>https://7rocky.github.io/ctf/imaginaryctf/rather-secure-attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rather-secure-attachment/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
from Crypto.Util.number import getPrime, bytes_to_long with open('flag.txt','rb') as f: m = bytes_to_long(f.read()) e = 0x10001 k = getPrime(4) l = getPrime(512) p = getPrime(512) q = getPrime(512) n = p*q c = pow(m, e, n) d = pow(2, k, n) f = pow(p, d, l) print(f"c = {c}") print(f"n = {n}") print(f"f = {f}") print(f"l = {l}") Y la salida del script anterior:</description></item><item><title>Reflection</title><link>https://7rocky.github.io/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/reflection/</guid><description>Se nos proporciona un archivo binario llamado reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped Si abrimos Ghidra y echamos un vistazo al código fuente en C descompilado, veremos la función main:
undefined8 main() { long j; char *__format; byte flag_input[100]; int k; int _j; int _length; int i; int length; printf("&amp;gt;&amp;gt;&amp;gt; "); fgets((char *) flag_input, 100, stdin); _length = 0; _j = 0; k = 0; while (true) { length = _length; i = _j; j = (long)_j; _j = _j + 1; if ((flag[j] ^ flag_input[i]) !</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 from Crypto.Util.number import * p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = getPrime(32) e = pow(d, -1, phi) m = bytes_to_long(open('flag.txt', 'rb').read()) c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' El criptosistema utilizado es RSA, pero la implementación es errónea.</description></item><item><title>Robotic</title><link>https://7rocky.github.io/ctf/imaginaryctf/robotic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/robotic/</guid><description>Se proporciona da este sitio web (https://eth007.me/):
Dado que el nombre del reto es &amp;ldquo;Robotic&amp;rdquo;, podríamos pensar en robots.txt, que es un archivo utilizado por los rastreadores web para indexar las páginas de un sitio web en motores de búsqueda como Google. Ahí tenemos el recurso:
Flag Si seguimos esa URL (que está marcada como Disallow para los rastreadores web), veremos la flag:
$ curl https://eth007.me/10b20f3d29ba114a.txt ictf{truly_not_a_robot}</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>Se nos proporciona el código fuente de un servidor que ejecuta un Algoritmo de Firma Digital (DSA, Digital Signature Algorithm):
from Crypto.Util.number import getPrime, isPrime, inverse from hashlib import sha256 from random import randrange q, g = 0, 2 while not isPrime(p := 2 * q + 1) or pow(g, q, p) != 1: q = getPrime(256) x = randrange(2, q) y = pow(g, x, p) def H(m): return int.from_bytes(sha256(m).digest(), 'big') def sign(m): k = randrange(2, q) r = pow(g, k, p) % q s = (H(m) + r * x) * inverse(k, q) % q return r, s def verify(m, r, s): u = inverse(s, q) return pow(g, u * H(m), p) * pow(y, u * r, p) % p % q == r def main(): print("</description></item><item><title>Ron was wrong, Whit is right</title><link>https://7rocky.github.io/ctf/imaginaryctf/ron-was-wrong-whit-is-right/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/ron-was-wrong-whit-is-right/</guid><description>Se nos proporciona el código fuente utilizado para cifrar la flag:
#!/usr/bin/env python from Crypto.Util import number flag = open("flag.txt", "rb").read() m = number.bytes_to_long(flag) e = 65537 for _ in range(1336): q = number.getPrime(1024) p = number.getPrime(1024) n = p * q c = pow(m, e, n) print(f"{n},{c}") También tenemos el resultado (1336 pares de n y c).
Contexto de RSA Vamos a recordar cómo funciona RSA: $n = p q$, donde $p$ y $q$ son números primos grandes.</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>Se nos da un socket al que conectarnos. Al realizar la conexión se muestra el código fuente usado para cifrar la flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 from Crypto.Util.number import * class Rotator: QUEUE_LENGTH = 10 def __init__(self): self.e = 65537 self.m = bytes_to_long(open('flag.txt', 'rb').read()) self.queue = [getPrime(512) for i in range(self.QUEUE_LENGTH)] def get_new_primes(self): ret = self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt; self.QUEUE_LENGTH): self.queue = [getPrime(512)] + self.queue return tuple(ret) def enc_flag(self): p, q = self.</description></item><item><title>RSAgain</title><link>https://7rocky.github.io/ctf/imaginaryctf/rsagain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rsagain/</guid><description>Se nos proporciona el código fuente utilizado para cifrar la flag:
from Crypto.Util.number import getPrime from secrets import randbelow flag = b'ictf{???????????????}' m = int.from_bytes(flag, 'big') p, q = getPrime(1024), getPrime(1024) n = p*q e1 = 7*randbelow(n) e2 = 7*randbelow(n) c1 = pow(m, e1, n) c2 = pow(m, e2, n) print('n =', n) print('e =', [e1, e2]) print('c =', [c1, c2]) Y la salida del script anterior:
n = 13761685901869725143768331354410331722080881206892978316226355274731948923788116922997132633408042821072846131527848521009073675634635614838798409359054501234184243307064644162477264359675732802892743867662331151938667918459410404673473173649215468906981810925676420598006739662864501852090661953622948938870414604397215114998121635153443376761422254645059647616441054621053792673427510353100668664861428374057353161172637671266095296358943110920490442118842860397633084527337550938542697953483620271948205306390349644786873542968679812523808277314879159441909502558166069319615649241027566862990490220961067181937669 e = [176102760168508342366248560703991436320546222245646770978202319048411166429566382514628949532380311738047680739422807353850798607282412088644610303686988373545251970947896120364153937039760741931013881201304685285276800581219089376477570281711773721947249912869605837122685995085027900352995492083277384406401003380587567849080200688516195340372450525399311095577291241729818923687928903049024986910768913495050369506538600090893434395973537955406795607398026050382337136405732255493959814072239958699297858559423614495730987219798816735202147878946461603285288373867465864345098892545645132818258947898456430424006, 3573981821831492277529738650073504616174769536804810418010981678130362702872320797121521713323943777400757776843305922735161754061510443680673867557929082126015295854646693109385804251924239205353662684744351670833911869748673257355076814511174326199099866635753979773946343291340766410907901834068770274767020404800822067211027120846913766665910218577234432145411130775944881987043775179494758158033064351482298980282644264138853891021708458121104223946012736356102642750591504966939159058542007824839461238347551623770276126868717421123099282388441377112476606520160468063905419246868567792524706613954405034280745] c = [2442003451487395252876121378320580564808335180996151717051522763081890537479875202133875395729806314814096885940653943728394923611282999540770370852775313679101585158491964936530361527619836260073209497935763771182203301056707656219921717552895243715201530990757549283670161276843945223662108755382731302991164300014685362347621843020642892430217171795396599343678165183180757721956247558358291103649246073117361482130651740512048690900488267309376415549379476398675385332885750364853460566103195169529710541031930399449866328356546569547859848315600711606485060302078139530732323306248727557394224647978798154455432, 5877775554635189664514035705193818872462952989637173497670868665060589927366277311749438728976759716021062894771294263103329901952516874052114135886783478914172913186895498679544398990747998647492211189869428581232686408690719184490347471496179923775491153260487724884204595180798615723157844735887389748026739587255981069056269993158062939424519078722321933831961667178045072850177889672933456786971303039062246151676207874781304093381264675070371899409850042467776910769703994219307749656616821280706978085046384421702389657326825914608919485710624515946600476275010829782060955742590243380095470169814313117059260] El tipo de cifrado es RSA, pero la implementación es incorrecta porque el mensaje m se está cifrando dos veces con diferentes exponentes públicos (e[0] y e[1]) y el mismo módulo público n.</description></item><item><title>same</title><link>https://7rocky.github.io/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/same/</guid><description>Se nos proporciona un código fuente en Python para cifrar la flag:
from Crypto.Util.number import getPrime, bytes_to_long m = bytes_to_long(open("flag", "rb").read()) n = getPrime(512)*getPrime(512) e = [1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) Y tenemos la salida del programa:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 El criptosistema utilizado es RSA, pero tiene una vulnerabilidad. La flag ($m$) se cifra dos veces como
$$ c_1 = m ^ {e_1} \mod{n} $$ $$ c_2 = m ^ {e_2} \mod{n} $$ El problema aquí es que el mismo mensaje se eleva a dos exponentes diferentes pero usando el mismo módulo $n$.</description></item><item><title>Secure</title><link>https://7rocky.github.io/ctf/imaginaryctf/secure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/secure/</guid><description>Se nos proporciona este sitio web (https://puzzler7.imaginaryctf.org:7002/):
Dado que el nombre del reto es &amp;ldquo;Secure&amp;rdquo; y el navegador mostró una advertencia que decía que el certificado es autofirmado, deberíamos examinar el certificado.
Flag Por ejemplo, podemos usar curl con modo informativo (-v) e inseguro (-k). Y ahí está la flag, en los campos asunto y emisor del certificado:
$ curl -vk https://puzzler7.imaginaryctf.org:7002/ * Trying 137.184.207.224:7002... * Connected to puzzler7.imaginaryctf.org (137.184.207.224) port 7002 (#0) * ALPN: offers h2 * ALPN: offers http/1.</description></item><item><title>Shifted</title><link>https://7rocky.github.io/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/shifted/</guid><description>Se nos proporciona este código fuente en Python:
import string import random flag = open("flag.txt").read().strip() mystery_num = random.randint(100,1000) new_alphabet = list(string.ascii_lowercase + string.digits + string.punctuation) enc_flag = "" def shift(char): index = new_alphabet.index(char) new_index = (index + mystery_num) % len(new_alphabet) return new_alphabet[new_index] for char in flag: enc_flag += shift(char) mystery_num += 10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t Lo que hace el script es crear un alfabeto y un número aleatorio (mystery_num). Luego, para cifrar la flag, encuentra el índice del carácter en texto claro correspondiente, le suma el número aleatorio (módulo la longitud del alfabeto) y devuelve el carácter en ese nuevo índice.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</guid><description>Se nos proporciona un binario de 64 bits llamado vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, vemos la función main:
undefined8 main() { long in_FS_OFFSET; char local_118[264]; long local_10; local_10 = *(long *) (in_FS_OFFSET + 0x28); setvbuf(stdout, (char *) 0x0, 2, 0); setvbuf(stdin, (char *) 0x0, 2, 0); puts("Send your string to be printed:"</description></item><item><title>Situated</title><link>https://7rocky.github.io/ctf/imaginaryctf/situated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/situated/</guid><description>Se nos proporciona este sitio web (https://eth007.me/blog/about/):
Dado que la descripción del reto es
Can you see beyond what&amp;rsquo;s visible?
Podríamos pensar en inspeccionar el código fuente HTML del sitio web. Y allí tenemos una etiqueta img curiosa:
Flag Y de hecho, es la flag (en codificación URL, %7B es { y %7D es }):
$ curl -s https://eth007.me/blog/about/ | grep ictf &amp;lt;p&amp;gt;&amp;lt;img src="ictf%7Binsp3cting_my_site?_h0w??%7D" alt=""&amp;gt;&amp;lt;/p&amp;gt;</description></item><item><title>XORed</title><link>https://7rocky.github.io/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xored/</guid><description>El programa dice que alguien ha usado un cifrado XOR con una clave de un solo byte. Este es el resultado: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Como sabemos que las flags empiezan por ictf{, podemos obtener la clave mediante &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; debido a las propiedades del cifrado XOR:
$$ c = m \oplus k \iff k = c \oplus m $$ Entonces podemos resolver el reto así:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</guid><description>Se nos proporciona el código fuente para cifrar la flag, y también el texto cifrado como un comentario en el código:
#!/usr/bin/env python3 flag = open('flag.txt', 'rb').read() key = open('/dev/urandom','rb').read(1)[0] out = [] for c in flag: out.append(c ^ key) key = c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' A partir del código fuente, podemos ver que la clave es un solo byte. Además, la clave se actualiza con el caracter en claro actual.</description></item></channel></rss>