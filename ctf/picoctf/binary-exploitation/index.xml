<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Explotación de binarios on Blog de 7Rocky. Ciberseguridad y Mates</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/</link><description>Recent content in Explotación de binarios on Blog de 7Rocky. Ciberseguridad y Mates</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/picoctf/binary-exploitation/index.xml" rel="self" type="application/rss+xml"/><item><title>basic-file-exploit</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/basic-file-exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/basic-file-exploit/</guid><description>Se nos proporciona el código fuente en C de un programa que está en ejecución en remoto:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define WAIT 60 static const char* flag = "[REDACTED]"; static char data[10][100]; static int input_lengths[10]; static int inputs = 0; int tgetinput(char *input, unsigned int l) { fd_set input_set; struct timeval timeout; int ready_for_reading = 0; int read_bytes = 0; if(l &amp;lt;= 0) { printf("</description></item><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) No tenemos el código fuente del binario, y además está despojado:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Ingeniería inversa Realizar ingeniería inversa sobre el binario será más complicado ya que no tenemos los nombres de las funciones.</description></item><item><title>Cache Me Outside</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cache-me-outside/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cache-me-outside/</guid><description>Se nos proporciona un binario de 64 bits llamado heapedit y un archivo libc.so.6 como librería externa:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):
$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit Está configurado para utilizar Glibc desde el directorio actual:
$ ldd heapedit linux-vdso.so.1 (0x00007ffe8397e000) libc.</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets y después comparar una variable local (code) con el valor de una variable global (GOAL):
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = "</description></item><item><title>CVE-XXXX-XXXX</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</guid><description>Tenemos el siguiente enunciado:
The CVE we&amp;rsquo;re looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.
Se nos pide buscar el identificador de CVE de la primera vulnerabilidad de RCE en Windows Print Spooler Service de 2021. Esta vulnerabilidad se conoce como PrintNightmare, y contiene varios CVE.</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir dos números y tratar de buscar uno que rompa el Último Teorema de Fermat.
Como recordatorio, el Último Teorema de Fermat dice que no existen números positivos $a$, $b$, $c$ que cumplan la ecuación:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>Se nos proporciona un binario de 32 bits llamado fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments No tenemos el código fuente en C. Esta vez, en lugar de hacer ingeniería inversa con Ghidra, analizaremos el binario con GDB.
Primero, vamos a ejecutar el programa:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>Se nos proporciona un binario estático de 64 bits llamado vuln
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.</description></item><item><title>Here's a LIBC</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/heres-a-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/heres-a-libc/</guid><description>Se nos proporciona un binario de 64 bits llamado vuln y un archivo libc.so.6 como librería externa:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):
$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln Está configurado para utilizar Glibc desde el directorio actual:
$ ldd vuln linux-vdso.</description></item><item><title>SaaS</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/saas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/saas/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Análisis de código estático También tenemos el código fuente original en C (chall.c):
#include &amp;lt;errno.h&amp;gt; #include &amp;lt;error.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;seccomp.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; #include &amp;lt;sys/syscall.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define SIZE 0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;amp;arch=x86-64&amp;amp;as_format=inline#assembly #define HEADER "\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #define FLAG_SIZE 64 char flag[FLAG_SIZE]; void load_flag() { int fd; if ((fd = open("</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>Se nos proporciona un binario de 32 bits llamado seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Esta vez no tenemos el código fuente. Sin embargo, podemos utilizar una herramienta de ingeniería inversa (reversing) como Ghidra para descompilar el binario y obtener código en C más o menos legible. Esta es la función main:
void main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts("</description></item><item><title>Stonks</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</guid><description>Se nos da el código fuente en C de un binario. El código es relativamente largo, por lo que se muestra la función más interesante:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>The Office</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/the-office/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/the-office/</guid><description>Se nos proporciona un binario de 32 bits llamado the_office:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) El reto dice que han implementado un heap seguro utilizando canarios (heap canaries).
No disponemos del código en C. Por tanto, necesitamos utilizar una herramienta de ingeniería inversa como Ghidra.
Aunque el archivo ha sido despojado de los símbolos:
$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Tenemos también el código fuente en C:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>zero_to_hero</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/zero_to_hero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/zero_to_hero/</guid><description>Se nos proporciona un binario de 64 bits llamado zero_to_hero:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' También tenemos la librería compartida Glibc y el loader (versión 2.29):
$ ./ld-2.29.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.29-0ubuntu2) stable release version 2.29. Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item></channel></rss>