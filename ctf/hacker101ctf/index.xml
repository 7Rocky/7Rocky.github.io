<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hacker101CTF on 7Rocky</title><link>https://7rocky.github.io/ctf/hacker101ctf/</link><description>Recent content in Hacker101CTF on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><atom:link href="https://7rocky.github.io/ctf/hacker101ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>A little something to get you started</title><link>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</guid><description>Tenemos una simple página web como esta:
Podemos leer el código HTML de la página, que es el siguiente:
Hay una imagen llamada background.png, Pero no observamos nada en la página web. Podemos acceder a ella utilizando curl:
$ curl http://35.190.155.168/9a968e7787/background.png ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ Y obtenemos la flag.</description></item><item><title>H1 Thermostat</title><link>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</guid><description>Tenemos un archivo APK de Android llamado thermostat.apk:
$ file thermostat.apk thermostat.apk: Zip archive data, at least v0.0 to extract, compression method=deflate Como se muestram un archivo APK es solo un archivo ZIP. Por tanto, podemos extraer su contenido:
$ 7z x thermostat.apk Scanning the drive for archives: 1 file, 2595443 bytes (2535 KiB) Extracting archive: thermostat.apk -- Path = thermostat.apk Type = zip Physical Size = 2595443 Everything is Ok Files: 569 Size: 4968479 Compressed: 2595443 $ ls AndroidManifest.</description></item><item><title>Hello World!</title><link>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</guid><description>Se nos proporciona un binario de 64 bits llamado vulnerable:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Si ejecutamos el binario, parece que no hace nada:
$ ./vulnerable asdf fdsa 1 2 Si insertamos datos desde la entrada estándar (stdin), vemos que el programa funciona:
$ echo asdf | ./vulnerable Hello asdf ! Vamos a enviar 100 caracteres utilizando Python para ver si falla:</description></item><item><title>Micro-CMS v1</title><link>https://7rocky.github.io/ctf/hacker101ctf/micro-cms-v1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/micro-cms-v1/</guid><description>Tenemos una página web sencilla que nos permite editar y crear artículos en Markdown:
Vamos a pinchar en &amp;ldquo;Testing&amp;rdquo;:
Ahora, podemos intentar editar el artículo actual. Se nos muestra una caja de texto para escribir el código Markdown ahí:
Markdown es un lenguaje de marcado similar a HTML pero más sencillo. Además, Markdown soporta el uso de etiquetas HTML. Por tanto, podemos intentar a poner un payload de Cross-Site Scripting (XSS) como este:</description></item><item><title>Model E1337 - Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</guid><description>Tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y, después de unos segundos, veremos que es incorrecto:
No hay nada en el código fuente de la página. En este punto, podemos aplicar fuzzing para enumerar más rutas existentes:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://35.190.155.168/c33a5d03b6/FUZZ admin [Status: 200, Size: 287, Words: 25, Lines: 11] unlock [Status: 405, Size: 178, Words: 20, Lines: 5] [Status: 200, Size: 302, Words: 16, Lines: 13] Existe una ruta /admin:</description></item><item><title>Model E1337 v2 - Hardened Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</guid><description>Este reto está muy relacionado a Model E1337 - Rolling Code Lock, especialmente en la parte de criptoanálisis. Se recomienda leerlo si no se ha hecho antes.
Como en el reto anterior, tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y veremos que es incorrecto:
La diferencia con el primer reto es la longitud del número, esta vez es de 64 bits.
Deberíamos de tener el código fuente en Python para realizar el proceso de criptoanálisis.</description></item></channel></rss>