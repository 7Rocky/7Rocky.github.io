<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>7Rocky</title><link>https://7rocky.github.io/</link><description>Recent content on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Mon, 10 Jan 2022 00:00:00 +0100</lastBuildDate><atom:link href="https://7rocky.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>NodeBlog</title><link>https://7rocky.github.io/htb/nodeblog/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/nodeblog/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene un blog que es vulnerable a inyección NoSQL, luego a inyección de Entidades Externas XML (XXE) y finalmente a deserialización insegura para obtener ejecución remota de comandos. Para comprometer esta máquina se necesitan técnicas avanzadas de explotación web y habilidades de programación. En este write-up se utilizan scripts en Bash, Python y Node.js para explotar todas las vulnerabilidades</description></item><item><title>Previse</title><link>https://7rocky.github.io/htb/previse/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/previse/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyección de comandos después de burlar redirecciones y conseguir registrar una nueva cuenta. Después, hay que romper un hash para acceder como usuario de bajos privilegios y realizar PATH hijacking mediante sudo. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web y Burp Suite, así como técnicas de escalada de privilegios comunes. En este write-up se utiliza un programa en Go personalizado para automatizar la intrusión</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route(&amp;#39;/unslippy&amp;#39;, methods=[&amp;#39;POST&amp;#39;]) def cache(): if &amp;#39;file&amp;#39; not in request.files: return abort(400) extraction = extract_from_archive(request.files[&amp;#39;file&amp;#39;]) if extraction: return {&amp;#34;list&amp;#34;: extraction}, 200 return &amp;#39;&amp;#39;, 204 El archivo se descomprime y se escribe el /tmp:</description></item><item><title>Static</title><link>https://7rocky.github.io/htb/static/</link><pubDate>Sat, 18 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/static/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web que expone un archivo Gzip corrupto que necesita ser corregido para obtener una clave de TOTP y descargar un archivo VPN. Luego, hay algunos servicios PHP vulnerables que pueden ser comprometidos para llegar a un servidor interno que contiene un archivo binario ejecutable que tiene una vulnerabilidad de Format String. Para comprometer esta máquina se necesitan conocimientos avanzados de pivoting y reenvío de puertos, además de enumeración web, explotación de PHP y explotación de Format String. En este write-up se utiliza un script personalizado de Ruby para automatizar el proceso de descarga del archivos VPN, un script de Python para ganar RCE sobre un servidor web PHP y otro script de Python para la explotación del binario mediante Format String</description></item><item><title>Writer</title><link>https://7rocky.github.io/htb/writer/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/writer/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene una página web vulnerable a inyección de código SQL. Esto permite leer el código fuente del servidor y encontrar una vulnerabilidad. Después, se utilizan varias técnicas de inyección de comandos para escalar privilegios. Para comprometer la máquina, se necesita programar una explotación automática de SQLi y conocimientos de SMB, SMTP y tareas Cron. En este write-up se utilizan scripts en Python personalizados para SQLi y para la intrusión</description></item><item><title>Pikaboo</title><link>https://7rocky.github.io/htb/pikaboo/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/pikaboo/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina utiliza nginx y Apache como servidores web con una mala configuración que deriva en navegación de directorios y posteriormente en inclusión de archivos locales. Existen credenciales de FTP en LDAP y una tarea Cron que es vulnerable a inyección de comandos. Para comprometer esta máquina se necesita enumeración web, conocimiento sobre nginx y LDAP, técnicas de explotación de inclusión de archivos y trucos de inyección de comandos. En este write-up se utiliza un script en Python personalizado para comprometer la máquina desde cero</description></item><item><title>LogForge</title><link>https://7rocky.github.io/htb/logforge/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/logforge/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina utiliza Log4j en un servidor Tomcat que es vulnerable a búsqueda JNDI. Luego hay un servidor FTP hecho en Java que también utiliza Log4j, pero esta vez solamente es vulnerable a exposición de información. Para comprometer esta máquina se necesitan conocimientos sobre Log4j, Tomcat, FTP y Wireshark</description></item><item><title>Intelligence</title><link>https://7rocky.github.io/htb/intelligence/</link><pubDate>Sat, 27 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/intelligence/</guid><description>Hack The Box. Windows. Máquina media. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de usuarios, envenenamiento de red un un ataque de Silver Ticket. Para comprometer la máquina se necesitan fundamentos de scripting, de DNS, de ataques en AD y de BloodHound. En este write-up se utiliza un script en Go personalizado para descargar documentos de un servidor web</description></item><item><title>Union</title><link>https://7rocky.github.io/htb/union/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/union/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene vulnerabilidades de inyección de código SQL (SQLi) e inyección de comandos. Para comprometer la máquina se necesitan algunas técnicas de evasión de SQLi y análisis de código fuente. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi</description></item><item><title>BountyHunter</title><link>https://7rocky.github.io/htb/bountyhunter/</link><pubDate>Sat, 20 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/bountyhunter/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyeccción de entidades externas XML (XXE) además de permisios de sudo configurados. Para comprometer la máquina se necesitan conocimientos sobre XXE, PHP y Python. En este write-up se utiliza un script en Bash para leer archivos del servidor explotando el XXE</description></item><item><title>Seal</title><link>https://7rocky.github.io/htb/seal/</link><pubDate>Sat, 13 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/seal/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene una página web de Tomcat montada sobre nginx, lo cual es una configuración vulnerable que desemboca en ejecución remota de comandos (RCE), y también tiene malas configuraciones de permisos en archivos y comandos con sudo. Para comprometer esta máquina se necesitan conocimientos sobre explotación de Tomcat y el sistema de archivos de Linux</description></item><item><title>Nunchucks</title><link>https://7rocky.github.io/htb/nunchucks/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/nunchucks/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a Server-Side Template Injection (SSTI) y tiene algunas capabilities habilitadas pero protegidas. Para comprometer la máquina se necesitan conocimientos de plantillas en Node.js y ejecución de comandos en Perl</description></item><item><title>Explore</title><link>https://7rocky.github.io/htb/explore/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/explore/</guid><description>Hack The Box. Android. Máquina fácil. Se trata de dispositivo móvil Android que contiene una aplicación vulnerable a lectura de archivos del dispositivo, a través de la cual se obtienen credenciales de acceso por SSH para poder escalar privilegios. Para comprometer el dispositivo, se necesitan conceptos de escaneo de puertos, reenvío de puertos y Android</description></item><item><title>Spider</title><link>https://7rocky.github.io/htb/spider/</link><pubDate>Sat, 23 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/spider/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web vulnerable a Server-Site Template Injection (SSTI) en dos puntos e inyección de código SQL (SQLi), y otra página interna vulnerable a inyección de entidades externas XML (XXE). Para comprometer esta máquina se necesitan conocimientos avanzados de SSTI y evasión de filtros, SQLi, XXE y reenvío de puertos. En este write-up se utiliza un script en Python para explotar un SSTI y un script en Bash para leer archivos mediante XXE</description></item><item><title>dynstr</title><link>https://7rocky.github.io/htb/dynstr/</link><pubDate>Sat, 16 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/dynstr/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina utiliza un servicio de DNS dinámico vulnerable a inyección de comandos y existen permisos de sudo en la máquina sobre un comando con un wildcard. Para comprometer la máquina se necesitan conocimientos de DNS, técnicas de inyección de comandos y abuso de wildcard</description></item><item><title>Monitors</title><link>https://7rocky.github.io/htb/monitors/</link><pubDate>Sat, 09 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/monitors/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web de Wordpress con un plugin vulnerable a navegación de directorios, otra página web vulnerable a inyección de código SQL y otra más vulnerable a deserialización insegura dentro de un contenedor de Docker con capabilities habilitadas. Para comprometer la máquina se necesitan conocimientos avanzados de enumeración web, vulnerabilidades y técnicas de explotación, además de técnicas de reenvío de puertos y para escapar de Docker. En este write-up se utiliza un script en Bash personalizado para explotar la deserialización insegura</description></item><item><title>Cap</title><link>https://7rocky.github.io/htb/cap/</link><pubDate>Sat, 02 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/cap/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene vulnerabilidades de referencias directas inseguras a archivos (IDOR) y capabilities a nivel de sistema. Para comprometer la máquina se necesita utilizar Wireshark para leer una captura de red y saber enumerar y explotar capabilities</description></item><item><title>Antique</title><link>https://7rocky.github.io/htb/antique/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/antique/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina es una impresora HP JetDirect que expone la contraseña por SNMP y tiene una vulnerabilidad de lectura privilegiada de archivos. Para comprometer la máquina se necesitan técnicas de enumeración por SNMP y reenvío de puertos. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi</description></item><item><title>Knife</title><link>https://7rocky.github.io/htb/knife/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/knife/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web en una versión de PHP con una puerta trasera y permisos de sudo configurados. Para comprometer la máquina se necesita conocer la versión de PHP y técnicas básicas de escalada de privilegios</description></item><item><title>Forest</title><link>https://7rocky.github.io/htb/forest/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/forest/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de MS RPC, AS-REProasting, descrifrado de contraseñas, DCSync y Pass the Hash. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD, además de usar BloodHound</description></item><item><title>Active</title><link>https://7rocky.github.io/htb/active/</link><pubDate>Sat, 08 Dec 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/active/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de SMB, descrifrado de contraseñas y Kerberoasting. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD</description></item><item><title>A little something to get you started</title><link>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</guid><description>Tenemos una simple página web como esta:
Podemos leer el código HTML de la página, que es el siguiente:
Hay una imagen llamada background.png, Pero no observamos nada en la página web. Podemos acceder a ella utilizando curl:
$ curl http://35.190.155.168/9a968e7787/background.png ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ Y obtenemos la flag.</description></item><item><title>Base 2 2 the 6</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/base-2-2-the-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/base-2-2-the-6/</guid><description>Nos dan este texto:
Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K
Como está compuesto por números y letras en mayúsculas y minúsculas, parece que está codificado en Base64.
De hechom el nombre del reto es &amp;ldquo;2 2 the 6&amp;rdquo; (&amp;quot;2 to the 6&amp;quot;), por lo que $2^6 = 64$.
Podemos decodificarlo en una consola de comandos:
$ echo Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K | base64 -d CTFlearn{FlaggyWaggyRaggy}</description></item><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) No tenemos el código fuente del binario, y además está despojado:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Realizar ingeniería inversa sobre el binario será más complicado ya que no tenemos los nombres de las funciones.</description></item><item><title>Blackbox</title><link>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</guid><description>Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario llamado blackbox que es SGID:
blackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission Como se puede ver, no tenemos permisos de lectura, por lo que no podemos transferir el archivo a nuestra máquina, ni descompilarlo, ni depurarlo.</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets y después comparar una variable local (code) con el valor de una variable global (GOAL):
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = &amp;#34;.</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir dos números y tratar de buscar uno que rompa el Último Teorema de Fermat.
Como recordatorio, el Último Teorema de Fermat dice que no existen números positivos $a$, $b$, $c$ que cumplan la ecuación:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>Se nos proporciona un binario de 32 bits llamado fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments No tenemos el código fuente en C. Esta vez, en lugar de hacer ingeniería inversa con Ghidra, analizaremos el binario con GDB.
Primero, vamos a ejecutar el programa:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Glory of the Garden</title><link>https://7rocky.github.io/ctf/picoctf/cryptography/mod-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/cryptography/mod-26/</guid><description>Se nos proporciona un mensaje cifrado:
cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_GYpXOHqX} Vemos que el mensaje tiene más o menos el formato de una flag de picoCTF (picoCTF{...}), ya que hay 4 letras minúsculas y 3 mayúsculas antes de {, y termina con }. Además, también hay varios _.
Parece claro que el algoritmo de cifrado utilizado es de sustitución (cifrado César). El algoritmo más común es ROT13. Utilizando CyberChef, podemos descifrar el mensaje utilizando ROT13 y ver la flag:</description></item><item><title>Glory of the Garden</title><link>https://7rocky.github.io/ctf/picoctf/forensics/glory-of-the-garden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/glory-of-the-garden/</guid><description>Se nos proporciona una imagen JPEG llamada garden.jpg:
El archivo se reconoce correctamente como imagen JPEG:
$ file garden.jpg garden.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 2999x2249, components 3 Sin embargo, si mostramos las cadenas de caracteres imprimibles en el contenido del archivo, obtendremos la flag (se puede indicar la longitud de la cadena a mostrar):
$ strings -50 garden.</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>Se nos proporciona un binario estático de 64 bits llamado vuln
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt; #define BUFSIZE 100 long increment(long in) { return in + 1; } long get_random() { return rand() % BUFSIZE; } int do_stuff() { long ans = get_random(); ans = increment(ans); int res = 0; printf(&amp;#34;What number would you like to guess?</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt; #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } int do_stuff() { long ans = (get_random() % 4096) + 1; int res = 0; printf(&amp;#34;What number would you like to guess?</description></item><item><title>H1 Thermostat</title><link>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</guid><description>Tenemos un archivo APK de Android llamado thermostat.apk:
$ file thermostat.apk thermostat.apk: Zip archive data, at least v0.0 to extract, compression method=deflate Como se muestram un archivo APK es solo un archivo ZIP. Por tanto, podemos extraer su contenido:
$ 7z x thermostat.apk Scanning the drive for archives: 1 file, 2595443 bytes (2535 KiB) Extracting archive: thermostat.apk -- Path = thermostat.apk Type = zip Physical Size = 2595443 Everything is Ok Files: 569 Size: 4968479 Compressed: 2595443 $ ls AndroidManifest.</description></item><item><title>Hello World!</title><link>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</guid><description>Se nos proporciona un binario de 64 bits llamado vulnerable:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Si ejecutamos el binario, parece que no hace nada:
$ ./vulnerable asdf fdsa 1 2 Si insertamos datos desde la entrada estándar (stdin), vemos que el programa funciona:
$ echo asdf | ./vulnerable Hello asdf ! Vamos a enviar 100 caracteres utilizando Python para ver si falla:</description></item><item><title>IMC 1999, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-1999/</guid><description> getProblemPdf('es', '1999', '1')</description></item><item><title>IMC 1999, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-1999/</guid><description> getProblemPdf('es', '1999', '7')</description></item><item><title>IMC 2000, Problema 3</title><link>https://7rocky.github.io/imc/problem-3-2000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-3-2000/</guid><description> getProblemPdf('es', '2000', '3')</description></item><item><title>IMC 2004, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-2004/</guid><description> getProblemPdf('es', '2004', '7')</description></item><item><title>IMC 2004, Problema 8</title><link>https://7rocky.github.io/imc/problem-8-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-8-2004/</guid><description> getProblemPdf('es', '2004', '8')</description></item><item><title>IMC 2005, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2005/</guid><description> getProblemPdf('es', '2005', '1')</description></item><item><title>IMC 2005, Problema 8</title><link>https://7rocky.github.io/imc/problem-8-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-8-2005/</guid><description> getProblemPdf('es', '2005', '8')</description></item><item><title>IMC 2006, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2006/</guid><description> getProblemPdf('es', '2006', '1')</description></item><item><title>IMC 2007, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-2007/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-2007/</guid><description> getProblemPdf('es', '2007', '7')</description></item><item><title>IMC 2010, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2010/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2010/</guid><description> getProblemPdf('es', '2010', '1')</description></item><item><title>IMC 2012, Problema 2</title><link>https://7rocky.github.io/imc/problem-2-2012/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-2-2012/</guid><description> getProblemPdf('es', '2012', '2')</description></item><item><title>IMC 2013, Problema 6</title><link>https://7rocky.github.io/imc/problem-6-2013/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-6-2013/</guid><description> getProblemPdf('es', '2013', '6')</description></item><item><title>IMC 2017, Problema 6</title><link>https://7rocky.github.io/imc/problem-6-2017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-6-2017/</guid><description> getProblemPdf('es', '2017', '6')</description></item><item><title>IMC 2018, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2018/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2018/</guid><description> getProblemPdf('es', '2018', '1')</description></item><item><title>IMC 2019, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2019/</guid><description> getProblemPdf('es', '2019', '1')</description></item><item><title>IMC 2019, Problema 5</title><link>https://7rocky.github.io/imc/problem-5-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-5-2019/</guid><description> getProblemPdf('es', '2019', '5')</description></item><item><title>IMC 2020, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2020/</guid><description> getProblemPdf('es', '2020', '1')</description></item><item><title>IMC 2020, Problema 2</title><link>https://7rocky.github.io/imc/problem-2-2020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-2-2020/</guid><description> getProblemPdf('es', '2020', '2')</description></item><item><title>IMC 2021, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2021/</guid><description> getProblemPdf('es', '2021', '1')</description></item><item><title>Lazy Game Challenge</title><link>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</guid><description>Se nos proporciona un servicio que consiste en un sistema de apuestas. Tenemos que apostar una cierta cantidad de dinero y luego adivinar un número entre 1 y 10 en menos de 10 intentos. Por ejemplo:
$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of !</description></item><item><title>Model E1337 - Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</guid><description>Tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y, después de unos segundos, veremos que es incorrecto:
No hay nada en el código fuente de la página. En este punto, podemos aplicar fuzzing para enumerar más rutas existentes:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://35.190.155.168/c33a5d03b6/FUZZ admin [Status: 200, Size: 287, Words: 25, Lines: 11] unlock [Status: 405, Size: 178, Words: 20, Lines: 5] [Status: 200, Size: 302, Words: 16, Lines: 13] Existe una ruta /admin:</description></item><item><title>Model E1337 v2 - Hardened Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</guid><description>Este reto está muy relacionado a Model E1337 - Rolling Code Lock, especialmente en la parte de criptoanálisis. Se recomienda leerlo si no se ha hecho antes.
Como en el reto anterior, tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y veremos que es incorrecto:
La diferencia con el primer reto es la longitud del número, esta vez es de 64 bits.
Deberíamos de tener el código fuente en Python para realizar el proceso de criptoanálisis.</description></item><item><title>Nice netcat...</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/nice-netcat.../</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/nice-netcat.../</guid><description>Se nos proporciona un nombre de dominio y un puerto para una instancia remota. Si nos conectamos utilizando nc, nos envía una lista de números:
$ nc mercury.picoctf.net 22902 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 ^C Estos números parece que son la representación en ASCII decimal de algunos caracteres.</description></item><item><title>Obedient Cat</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/obedient-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/obedient-cat/</guid><description>En este reto se nos da un archivo. El contenido de este archivo es la flag:
$ cat flag picoCTF{s4n1ty_v3r1f13d_28e8376d}</description></item><item><title>Practice Flag</title><link>https://7rocky.github.io/ctf/ctflearn/miscellaneous/practice-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/miscellaneous/practice-flag/</guid><description>Este reto es solamente una introducción. La flag se muestra directamente: CTFlearn{4m_1_4_r3al_h4ck3r_y3t}.</description></item><item><title>RIP my bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</guid><description>Se nos proporciona un binario de 32 bits llamado server:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) También tenemos el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets, que es vulnerable a Buffer Overflow:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system("</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>Se nos proporciona un binario de 32 bits llamado seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Esta vez no tenemos el código fuente. Sin embargo, podemos utilizar una herramienta de ingeniería inversa (reversing) como Ghidra para descompilar el binario y obtener código en C más o menos legible. Esta es la función main:
void main(void) { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts(&amp;#34;&amp;#34;); puts(&amp;#34;.</description></item><item><title>Simple bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</guid><description>Se nos proporciona el código fuente en C de un binario y una instancia remota a la que conectarnos. Básicamente, lo que el programa hace es llamar a gets, que es vulnerable a Buffer Overflow, y luego comparar una variable local con un cierto valor:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer.</description></item><item><title>Stonks</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</guid><description>Se nos da el código fuente en C de un binario. El código es relativamente largo, por lo que se muestra la función más interesante:
#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen(&amp;#34;api&amp;#34;, &amp;#34;r&amp;#34;); if (!</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Tenemos también el código fuente en C:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>what's a net cat?</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/whats-a-net-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/whats-a-net-cat/</guid><description>Se nos proporciona una instancia remota a la que conectarnos. Si establecemos la conexión con nc, obtenemos la flag:
$ nc jupiter.challenges.picoctf.org 25103 You're on your way to becoming the net cat master picoCTF{nEtCat_Mast3ry_d0c64587}</description></item></channel></rss>