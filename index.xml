<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>7Rocky</title><link>https://7rocky.github.io/</link><description>Recent content on 7Rocky</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 22 Oct 2022 00:00:00 +0100</lastBuildDate><atom:link href="https://7rocky.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Faculty</title><link>https://7rocky.github.io/htb/faculty/</link><pubDate>Sat, 22 Oct 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/faculty/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una página web vulnerable a SQLi y salto de autenticación que lleva a otra página en la que podemos exportar contenido HTML a PDF. Existe una vulnerabilidad en la que podemos adjuntar archivos locales al fichero PDF y leer una contraseña reutilizada para SSH. Mediante sudo podemos ejecutar un script en Node.js como otro usuario y explotar una inyección de comandos. Este segundo usuario puede ejecutar GDB y además GDB tiene la capability cap_sys_ptrace activada, por lo que podemos depurar un proceso en ejecución por root y ejecutar código arbitrario</description></item><item><title>OpenSource</title><link>https://7rocky.github.io/htb/opensource/</link><pubDate>Sat, 08 Oct 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/opensource/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que expone su código fuente, siendo vulnerable a Directory Path Traversal. Con esta vulnerabilidad podemos leer los archivos necesarios para calcular el PIN de la consola de depuración de Flask y obtener ejecución remota de comandos en un contenedor Docker. Después, se necesita usar un reenvío de puertos para ver una instancia de Gitea y acceder con credenciales que se encuentran en un repositorio de Git. Aquí podemos ver la clave privada de SSH de un usuario de sistema. Existe una tarea Cron que confirma nuevos cambios de un repositorio Git que lleva a escalada de privilegios</description></item><item><title>Scanned</title><link>https://7rocky.github.io/htb/scanned/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/scanned/</guid><description>Hack The Box. Linux. Máquina insana. Esta máquina tiene una página web que es capaz de analizar malware. Al analizar el código en C del sandbox, se ve que se puede utilizar un archivo de log para exfiltrar información por medio del servidor web, y también abusar de una mala configuración para escapar de chroot. Luego, podemos leer una base de datos SQLite y extraer el hash de una contraseña, que se reutiliza para SSH. Una vez en la máquina, se puede ejecutar un binario SUID desde la sandbox y copiar una librería compartida maliciosa para que el binario SUID ejecute Bash como root. Para comprometer esta máquina se necesitan conocimientos avanzados de Linux, programación en C y Bash, experiencia en auditoría de código y técnicas de evasión. En este write-up se utiliza un script en Bash con un programa en C embebido para listar directorios y leer archivos del servidor y también un programa en Go para romper el hash de una contraseña</description></item><item><title>Noter</title><link>https://7rocky.github.io/htb/noter/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/noter/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una aplicación web hecha en Flask para gestionar notas en Markdown y PDF. Podemos extraer la clave secreta usada para firmar las cookies de sesión y falsificar cookies para enumerar usuarios. Una vez que tenemos un usuario privilegiado, podemos acceder al servidor FTP y analizar el código fuente de la aplicación web para descubrir una vulnerabilidad de inyección de comandos. Luego, podemos acceder a la máquina y ver que MySQL se ejecuta como root, lo cual permite la escalada de privilegios</description></item><item><title>Timelapse</title><link>https://7rocky.github.io/htb/timelapse/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/timelapse/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) donde se puede encontrar un archivo cifrado ZIP mediante SMB. Podemos obtener la contraseña y obtener un archivo PFX con claves públicas y privadas para WinRM. De nuevo, se puede obtener la contraseña y conseguir las claves para conectarse a la máquina. Existe un historial de comandos en PowerShell donde se encuentra una contraseña para un miembro del grupo LAPS, el cual puede mostrar la contraseña de Administrator. Para comprometer esta máquina se necesitan conocimientos de enumeración y explotación en Windows</description></item><item><title>Retired</title><link>https://7rocky.github.io/htb/retired/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/retired/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una página web en PHP que es vulnerable a navegación de directorios. Aquí encontramos un archivo PHP que espera que se suba un archivo para pasarlo a un servidor de sockets en local. Somos capaces de enumerar procesos y descargar el binario que ejecuta el servidor y ver que es vulnerable a Buffer Overflow. Una vez explotado, podemos pivotar a un usuario usando enlaces simbólicos. Y luego, se nos permite añadir formatos ejecutables personalizados, que puede ser explotado para convertirnos en root. Para comprometer esta máquina se necesitan técnicas sólidas de explotación de binarios y conceptos de Linux. En este write-up se utilizan exploits personalizados en Python para la intrusión</description></item><item><title>OverGraph</title><link>https://7rocky.github.io/htb/overgraph/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/overgraph/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina tiene una página web que es vulnerable a Open Redirect, una aplicación web hecha en AngularJS vulnerable a Client-Side Template Injection y XSS, y una implementación de GraphQL. Somos capaces de registrar una nueva cuenta al saltarnos un código OTP mediante una inyección NoSQL. Luego, podemos realizar un ataque de CSRF abusando del Open Redirect para inyectar un payload de XSS en el perfil de la víctima para obtener su adminToken, que está guardado en localStorage. Después, podemos subir archivos de video que serán procesados por ffmpeg y explotar un Server-Side Request Forgery que nos permite leer archivos del servidor. Finalmente, ganaremos acceso a la máquina como un usuario y podemos encontrar un binario está en ejecución como root. Después de analizarlo, podemos obtener un token válido para usar el programa y exploitar una vulnerabilidad para escribir datos arbitrarios en una dirección arbitraria, derivando en RCE o permisos de lectura como root</description></item><item><title>Late</title><link>https://7rocky.github.io/htb/late/</link><pubDate>Sat, 30 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/late/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una aplicación web en Flask que extrae texto de imágenes y lo renderiza, siendo vulnerable a SSTI. Luego, existe un PAM configurado para SSH con rutas relativas, que puede ser abusado debido a ciertos privilegios para sobrescribir ejecutables. Para comprometer esta máquina se necesitan conocimientos básicos de explotación web y de enumeración en Linux</description></item><item><title>Catch</title><link>https://7rocky.github.io/htb/catch/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/catch/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina ofrece un archivo APK que contiene tokens de autenticación hard-coded de otros servicios expuestos. Uno de los tokens puede ser usado para enumerar una aplicación de Let&amp;rsquo;s Chat por medio de su API y obtener credenciales para Cachet. Este servicio es vulnerable a Server-Side Template Injection en PHP y podemos obtener más credenciales para acceder por SSH. La máquina ejecuta una tarea Cron para analizar archivos APK con un script en Bash que es vulnerable a inyección de comandos, por lo que tenemos que subir un archivo APK malicioso para explotarlo y convertirnos en root</description></item><item><title>Acute</title><link>https://7rocky.github.io/htb/acute/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/acute/</guid><description>Hack The Box. Windows. Máquina difícil. Esta máquina expone una página web donde se puede encontrar un documento de Word con información sensible y nombres de usuarios. Existe un acceso web a PowerShell en el cual podemos acceder utilizando una credencial débil y extraer otra contraseña a partir de una captura de pantalla. Existe un controlador de dominio de un entorno de Active Directory donde podemos ejecutar comandos como otros usuarios. Podremos conectarnos a la primera máquina y extraer hashes NTLM y finalmente convertirnos en administrador del dominio. Para comprometer esta máquina se necesitan conocimientos de PowerShell y técnicas básicas de explotación de Windows y Active Directory</description></item><item><title>RouterSpace</title><link>https://7rocky.github.io/htb/routerspace/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/routerspace/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene un archivo APK con una app sencilla. Esta app realiza una petición web a una API que tiene que ser capturada con un proxy, y esta API es vulnerable a inyección de comandos. Después, el acceso a la máquina se puede realizar por SSH y una enumeración básica muestra que la versión de sudo es vulnerable</description></item><item><title>Undetected</title><link>https://7rocky.github.io/htb/undetected/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/undetected/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una página web en PHP con una dependencia de terceros vulnerable a RCE. La máquina ha sido previamente comprometida y tiene algunas puertas traseras y exploits que tienen que ser detectadas y analizadas mediante técnicas de ingeniería inversa</description></item><item><title>Paper</title><link>https://7rocky.github.io/htb/paper/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/paper/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web en Wordpress con información secreta en borradores, y también un chat con un bot que muestra información sensible. Después, el servidor es vulnerable a PolKit. Para comprometer esta máquina se necesitan conocimientos de enumeración en Wordpress</description></item><item><title>Meta</title><link>https://7rocky.github.io/htb/meta/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/meta/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una página web que analiza imágenes subidas con una versión vulnerable de exiftool que deriva en RCE. Luego, existe una tarea Cron que transforma imágenes con el comando mogrify de ImageMagick, que es vulnerable a inyección de comandos. Finalmente, tenemos permisos de sudo para ejecutar neofetch, lo cual posibilita la escalada de privilegios</description></item><item><title>Timing</title><link>https://7rocky.github.io/htb/timing/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/timing/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una aplicación web en PHP que es vulnerable a enumeración de usuarios, LFI, Type Juggling y SQLi, aparte de otros errores y malas configuraciones. Después de leer el código PHP, se encuentra una manera de subir un archivo PHP para conseguir RCE. Luego encontramos una contraseña en un repositorio de Git y accedemos por SSH. Entonces, podemos ejecutar un archivo JAR con sudo que descarga archivos como root, y se puede usar un enlace simbólico para escribir una clave SSH como autorizada para root</description></item><item><title>Pandora</title><link>https://7rocky.github.io/htb/pandora/</link><pubDate>Sat, 21 May 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/pandora/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina expone información sensible por SNMP que permite acceder a la máquina. Luego, encontramos una instancia local de Pandora FMS que tiene varias vulnerabilidades y pueden ser explotadas para conseguir RCE como otro usuario. Este usuario puede ejecutar un binario SUID que es vulnerable a PATH hijacking, pero el ataque tiene que ser realizado desde una sesión de SSH. Para comprometer esta máquina se necesitan habilidades de enumeración y pentesting básicas</description></item><item><title>Unicode</title><link>https://7rocky.github.io/htb/unicode/</link><pubDate>Sat, 07 May 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/unicode/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina utiliza tokens JWT con JWKS y JKU que pueden ser falsificados para llegar a una vulnerabilidad de navegación de directorios que puede ser explotada mediante caracteres Unicode. Después, existe un binario compilado con Python que puede ejecutarse con sudo y usa curl por detrás. Para comprometer esta máquina se necesitan conocimientos sobre JWT y técnicas de bypassing para navegación de directorios e inyección de comandos. En este write-up se utiliza un script en Python para explotar la navegación de directorios usando JWT y JWKS</description></item><item><title>Backdoor</title><link>https://7rocky.github.io/htb/backdoor/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/backdoor/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web de Wordpress que tiene un plugin vulnerable a navegación de directorios, que se puede utilizar para enumerar procesos en ejecución, y después un binario SUID. Para comprometer esta máquina es necesario tener conocimientos sobre Wordpress y experiencia con vulnerabilidades de inclusión de archivos. En este write-up se utiliza un script de Python personalizado para leer archivos del servidor y un exploit público propio para ganar acceso a la máquina</description></item><item><title>Backend</title><link>https://7rocky.github.io/htb/backend/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/backend/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene una API en la que podemos crear una cuenta después de un proceso de exploración. Luego encontramos documentación en formato Swagger donde podemos ver una ruta para ejecutar comandos y para leer archivos del servidor. Necesitamos encontrar la clave secreta usada para los tokens JWT y crear un token válido para ejecutar comandos. Para comprometer esta máquina se necesitan conocimientos sobre tokens JWT y enumeración de API</description></item><item><title>Overflow</title><link>https://7rocky.github.io/htb/overflow/</link><pubDate>Sat, 09 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/overflow/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web vulnerable a Padding Oracle Attack y Bit Flipper Attack para iniciar sesión como admin y también vulnerable a SQLi por un CMS. Existe otro subdominio que usa una versión de exiftool que tiene una vulnerabilidad de RCE. Una vez en la máquina, los movimientos laterales son relativamente fáciles y la escalada de privilegios consiste en ingeniería inversa y explotación de una vulnerabilidad de Buffer Overflow en un binario SUID. Para comprometer esta máquina se necesitan conocimientos avanzados de explotación web, criptografía y explotación de binarios. En este write-up se utiliza un script en Python para efectuar un Bit Flipper Attack y un script en Ruby para SQLi</description></item><item><title>Shibboleth</title><link>https://7rocky.github.io/htb/shibboleth/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/shibboleth/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene un servicio IPMI vulnerable donde podemos encontrar una contraseña que se reutiliza para un panel de control Zabbix. Aquí podemos entrar y ganar acceso a la máquina. Luego, encontramos una versión de MariaDB vulnerable a RCE como root. Para comprometer esta máquina se necesita una buena enumeración y metodología de pentesting</description></item><item><title>Altered</title><link>https://7rocky.github.io/htb/altered/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/altered/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina tiene una página web vulnerable a enumeración de usuarios. Luego podemos hacer fuerza bruta para sacar un PIN y cambiar la contraseña, evitando la limitación de peticiones, y explotar SQLi y Type Juggling. Despúes, se ve que el kernel de Linux es vulnerable a DirtyPipe. Para comprometer esta máquina se necesitan conocimientos avanzados de explotación web. En este write-up se utiliza un script en Ruby para encontrar el PIN válido</description></item><item><title>Secret</title><link>https://7rocky.github.io/htb/secret/</link><pubDate>Sat, 26 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/secret/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una API que utiliza tokens JWT para la autenticación. Podemos descargar el proyecto y ver que es un repositorio de Git, y de las confirmaciones antiguas podemos extraer una clave secreta. Existe un binario SUID que lee archivos como root aunque solo muestra estadísticas del archivo, pero podemos matar el proceso y leer el coredump. Para comprometer esta máquina se necesitan conocimientos de pentesting web, enumeración de Git y procesos en Linux</description></item><item><title>Stacked</title><link>https://7rocky.github.io/htb/stacked/</link><pubDate>Sat, 19 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/stacked/</guid><description>Hack The Box. Linux. Máquina insana. Esta máquina contiene un entorno de LocalStack que es vulnerable a CSRF e inyección de comandos. Al descubrir una vulnerabilidad de XSS en un subdominio, podemos utilizar CSRF para explotar la vulnerabilidad de inyección de comandos y conseguir RCE en un contenedor. Después de escalar privilegios en el contenedor mediante el reinicio de un servicio e introduciendo un comando malicioso, podemos interactuar con Docker en la máquina anfitrión y crear un contenedor malicioso a partir de scratch que monta el sistema de archivos de la máquina en el contenedor para conseguir lectura y escritura arbitraria de archivos. Para comprometer esta máquina se necesitan técnicas de explotación web y conocimientos avanzados de Docker</description></item><item><title>Ransom</title><link>https://7rocky.github.io/htb/ransom/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/ransom/</guid><description>Hack The Box. Linux. Máquina media. Esta máquinaa tiene una página web en Laravel con un formulario de inicio de sesión que es vulnerable a Type Juggling. Después, encontramos un archivo ZIP encriptado y podemos realizar un ataque de texto claro conocido para extraer los archivos. La contraseña esperada en el formuulario de inicio de sesión se reutiliza para el usuario root. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web en PHP y conocimientos sobre archivos ZIP</description></item><item><title>Devzat</title><link>https://7rocky.github.io/htb/devzat/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/devzat/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene un servicio de chat sobre SSH y un subdominio web oculto vulnerable a inyección de comandos. Luego, podemos acceder a la máquina y explotar una versión vulnerable de InfluxDB para extraer la contraseña de otro usuario. Este usuario tiene permisos para ver un proyecto en desarrollo del chat de SSH que permite leer archivos arbitrarios del servidor. Para comprometer esta máquina se necesitan conocimientos básicos de explotación web y enumeración en Linux</description></item><item><title>Hancliffe</title><link>https://7rocky.github.io/htb/hancliffe/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/hancliffe/</guid><description>Hack The Box. Windows. Máquina difícil. Esta máquina tiene una página web que esconde una aplicación Nuxeo en Java vulnerable a SSTI después de romper la lógica de nginx. Luego accedemos a la máquina y encontramos una aplicación con un exploit público para acceder como otro usuario. Después, extraemos credenciales de Firefox y usamos un generador de contraseñas para acceder como otro usuario y encontrar un ejecutable de Windows. Después de hacer ingeniería inversa para obtener las credenciales esperadas, encontramos una vulnerabilidad de Buffer Overflow que necesita ser explotada mediante Socket Reuse para acceder como Administrator</description></item><item><title>Driver</title><link>https://7rocky.github.io/htb/driver/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/driver/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina tiene una página web configurada con credenciales por defecto y una subida de archivos. Aquí podemos subir un archivo SCF para capturar el hash NTLMv2 del usuario y romperlo. Luego podemos explotar PrintNightmare. Para comprometer esta máquina se necesitan conocimientos básicos de explotación en Windows</description></item><item><title>GoodGames</title><link>https://7rocky.github.io/htb/goodgames/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/goodgames/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyección de código SQL desde donde podemos obtener una contraseña para acceder a una verb interna que es vulnerable a SSTI. Luego, ganamos acceso a un contenedor de Docker que monta un directorio de la máquina, de manera que podemos aprovecharlo para escalar privilegios. Para comprometer esta máquina se necesitan habilidades básicas de pentesting web y de Docker. En este write-up se utiliza un script en Python personalizado para comprometer la máquina desde cero</description></item><item><title>Bolt</title><link>https://7rocky.github.io/htb/bolt/</link><pubDate>Sat, 19 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/bolt/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina tiene varios subdominios y una imagen de Docker con mucha información necesaria para explotar los servicios web. Existe una vulnerabilidad de SSTI en la comunicación entre dos servicios. Luego, podemos extraer una clave privada PGP de la caché de Google Chrome y descrifrar un mensaje. Para comprometer esta máquina, se necesitan conocimientos avanzados de Docker y habilidades básicas de explotación web</description></item><item><title>SteamCloud</title><link>https://7rocky.github.io/htb/steamcloud/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/steamcloud/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene un cluster de Kubernetes que expone el kubelet y es vulnerable a RCE sin autenticación. Somos capaces de extraer credenciales de un Pod en ejecución y utilizarlas para crear un Pod malicioso que monta el sistema de archivos de la máquina anfitriona. Para comprometer esta máquina se necesitan conocimientos de pentesting en Kubernetes</description></item><item><title>Epsilon</title><link>https://7rocky.github.io/htb/epsilon/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/epsilon/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene una página web que expone un repositorio de Git con secretos en confirmaciones antiguas. Hay otra página web que necesita de un token JWT válido para explotar una vulnerabilidad de SSTI. El secreto de los tokens JWT está escrito en una función AWS Lambda. Luego, existe una tarea Cron que puede ser explotada mediante enlaces simbólicos para poder leer archivos arbitrarios. Para comprometer esta máquina, se necesitan conocimientos de Git, JWT, SSTI y AWS Lambda, ademñas de explotación de tareas Cron</description></item><item><title>Horizontall</title><link>https://7rocky.github.io/htb/horizontall/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/horizontall/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que esconde un subdominio válido con una aplicación web de Strapi vulnerable a RCE. Existe también una aplicación web interna hecha con Laravel vulnerable a RCE. Para comprometer esta máquina es necesario conocimiento sobre JavaScript, PHP y Python, además de conocer técnicas de reenvío de puertos. En esta máquina se utiliza un script en Python personalizado que encadena dos exploits para Strapi necesarios para ganar RCE</description></item><item><title>Forge</title><link>https://7rocky.github.io/htb/forge/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/forge/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina es vulnerable a Server-Side Request Forgery (SSRF) desde un subdominio hacia un servidor FTP. Despuñes, existen permisos de sudo para ejecutar un script de Python con un depurador. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web. En este write-up se utiliza un script en Python personalizado para explotar el SSRF</description></item><item><title>NodeBlog</title><link>https://7rocky.github.io/htb/nodeblog/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/nodeblog/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene un blog que es vulnerable a inyección NoSQL, luego a inyección de Entidades Externas XML (XXE) y finalmente a deserialización insegura para obtener ejecución remota de comandos. Para comprometer esta máquina se necesitan técnicas avanzadas de explotación web y habilidades de programación. En este write-up se utilizan scripts en Bash, Python y Node.js para explotar todas las vulnerabilidades</description></item><item><title>Previse</title><link>https://7rocky.github.io/htb/previse/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/previse/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyección de comandos después de burlar redirecciones y conseguir registrar una nueva cuenta. Después, hay que romper un hash para acceder como usuario de bajos privilegios y realizar PATH hijacking mediante sudo. Para comprometer esta máquina se necesitan conocimientos básicos de pentesting web y Burp Suite, así como técnicas de escalada de privilegios comunes. En este write-up se utiliza un programa en Go personalizado para automatizar la intrusión</description></item><item><title>Static</title><link>https://7rocky.github.io/htb/static/</link><pubDate>Sat, 18 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/static/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web que expone un archivo Gzip corrupto que necesita ser corregido para obtener una clave de TOTP y descargar un archivo VPN. Luego, hay algunos servicios PHP vulnerables que pueden ser comprometidos para llegar a un servidor interno que contiene un archivo binario ejecutable que tiene una vulnerabilidad de Format String. Para comprometer esta máquina se necesitan conocimientos avanzados de pivoting y reenvío de puertos, además de enumeración web, explotación de PHP y explotación de Format String. En este write-up se utiliza un script personalizado de Ruby para automatizar el proceso de descarga del archivos VPN, un script de Python para ganar RCE sobre un servidor web PHP y otro script de Python para la explotación del binario mediante Format String</description></item><item><title>Writer</title><link>https://7rocky.github.io/htb/writer/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/writer/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene una página web vulnerable a inyección de código SQL. Esto permite leer el código fuente del servidor y encontrar una vulnerabilidad. Después, se utilizan varias técnicas de inyección de comandos para escalar privilegios. Para comprometer la máquina, se necesita programar una explotación automática de SQLi y conocimientos de SMB, SMTP y tareas Cron. En este write-up se utilizan scripts en Python personalizados para SQLi y para la intrusión</description></item><item><title>Pikaboo</title><link>https://7rocky.github.io/htb/pikaboo/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/pikaboo/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina utiliza nginx y Apache como servidores web con una mala configuración que deriva en navegación de directorios y posteriormente en inclusión de archivos locales. Existen credenciales de FTP en LDAP y una tarea Cron que es vulnerable a inyección de comandos. Para comprometer esta máquina se necesita enumeración web, conocimiento sobre nginx y LDAP, técnicas de explotación de inclusión de archivos y trucos de inyección de comandos. En este write-up se utiliza un script en Python personalizado para comprometer la máquina desde cero</description></item><item><title>LogForge</title><link>https://7rocky.github.io/htb/logforge/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/logforge/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina utiliza Log4j en un servidor Tomcat que es vulnerable a búsqueda JNDI. Luego hay un servidor FTP hecho en Java que también utiliza Log4j, pero esta vez solamente es vulnerable a exposición de información. Para comprometer esta máquina se necesitan conocimientos sobre Log4j, Tomcat, FTP y Wireshark</description></item><item><title>Intelligence</title><link>https://7rocky.github.io/htb/intelligence/</link><pubDate>Sat, 27 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/intelligence/</guid><description>Hack The Box. Windows. Máquina media. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de usuarios, envenenamiento de red un un ataque de Silver Ticket. Para comprometer la máquina se necesitan fundamentos de scripting, de DNS, de ataques en AD y de BloodHound. En este write-up se utiliza un script en Go personalizado para descargar documentos de un servidor web</description></item><item><title>Union</title><link>https://7rocky.github.io/htb/union/</link><pubDate>Mon, 22 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/union/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene vulnerabilidades de inyección de código SQL (SQLi) e inyección de comandos. Para comprometer la máquina se necesitan algunas técnicas de evasión de SQLi y análisis de código fuente. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi</description></item><item><title>BountyHunter</title><link>https://7rocky.github.io/htb/bountyhunter/</link><pubDate>Sat, 20 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/bountyhunter/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a inyeccción de entidades externas XML (XXE) además de permisios de sudo configurados. Para comprometer la máquina se necesitan conocimientos sobre XXE, PHP y Python. En este write-up se utiliza un script en Bash para leer archivos del servidor explotando el XXE</description></item><item><title>Seal</title><link>https://7rocky.github.io/htb/seal/</link><pubDate>Sat, 13 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/seal/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina contiene una página web de Tomcat montada sobre nginx, lo cual es una configuración vulnerable que desemboca en ejecución remota de comandos (RCE), y también tiene malas configuraciones de permisos en archivos y comandos con sudo. Para comprometer esta máquina se necesitan conocimientos sobre explotación de Tomcat y el sistema de archivos de Linux</description></item><item><title>Nunchucks</title><link>https://7rocky.github.io/htb/nunchucks/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/nunchucks/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web vulnerable a Server-Side Template Injection (SSTI) y tiene algunas capabilities habilitadas pero protegidas. Para comprometer la máquina se necesitan conocimientos de plantillas en Node.js y ejecución de comandos en Perl</description></item><item><title>Explore</title><link>https://7rocky.github.io/htb/explore/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/explore/</guid><description>Hack The Box. Android. Máquina fácil. Se trata de dispositivo móvil Android que contiene una aplicación vulnerable a lectura de archivos del dispositivo, a través de la cual se obtienen credenciales de acceso por SSH para poder escalar privilegios. Para comprometer el dispositivo, se necesitan conceptos de escaneo de puertos, reenvío de puertos y Android</description></item><item><title>Spider</title><link>https://7rocky.github.io/htb/spider/</link><pubDate>Sat, 23 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/spider/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web vulnerable a Server-Site Template Injection (SSTI) en dos puntos e inyección de código SQL (SQLi), y otra página interna vulnerable a inyección de entidades externas XML (XXE). Para comprometer esta máquina se necesitan conocimientos avanzados de SSTI y evasión de filtros, SQLi, XXE y reenvío de puertos. En este write-up se utiliza un script en Python para explotar un SSTI y un script en Bash para leer archivos mediante XXE</description></item><item><title>dynstr</title><link>https://7rocky.github.io/htb/dynstr/</link><pubDate>Sat, 16 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/dynstr/</guid><description>Hack The Box. Linux. Máquina media. Esta máquina utiliza un servicio de DNS dinámico vulnerable a inyección de comandos y existen permisos de sudo en la máquina sobre un comando con un wildcard. Para comprometer la máquina se necesitan conocimientos de DNS, técnicas de inyección de comandos y abuso de wildcard</description></item><item><title>Monitors</title><link>https://7rocky.github.io/htb/monitors/</link><pubDate>Sat, 09 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/monitors/</guid><description>Hack The Box. Linux. Máquina difícil. Esta máquina contiene una página web de Wordpress con un plugin vulnerable a navegación de directorios, otra página web vulnerable a inyección de código SQL y otra más vulnerable a deserialización insegura dentro de un contenedor de Docker con capabilities habilitadas. Para comprometer la máquina se necesitan conocimientos avanzados de enumeración web, vulnerabilidades y técnicas de explotación, además de técnicas de reenvío de puertos y para escapar de Docker. En este write-up se utiliza un script en Bash personalizado para explotar la deserialización insegura</description></item><item><title>Cap</title><link>https://7rocky.github.io/htb/cap/</link><pubDate>Sat, 02 Oct 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/cap/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene vulnerabilidades de referencias directas inseguras a archivos (IDOR) y capabilities a nivel de sistema. Para comprometer la máquina se necesita utilizar Wireshark para leer una captura de red y saber enumerar y explotar capabilities</description></item><item><title>Antique</title><link>https://7rocky.github.io/htb/antique/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/antique/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina es una impresora HP JetDirect que expone la contraseña por SNMP y tiene una vulnerabilidad de lectura privilegiada de archivos. Para comprometer la máquina se necesitan técnicas de enumeración por SNMP y reenvío de puertos. En este write-up se utiliza un programa en Java personalizado para automatizar un ataque de SQLi</description></item><item><title>Knife</title><link>https://7rocky.github.io/htb/knife/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/knife/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina contiene una página web en una versión de PHP con una puerta trasera y permisos de sudo configurados. Para comprometer la máquina se necesita conocer la versión de PHP y técnicas básicas de escalada de privilegios</description></item><item><title>Rope</title><link>https://7rocky.github.io/htb/rope/</link><pubDate>Sat, 23 May 2020 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/rope/</guid><description>Hack The Box. Linux. Máquina insana. Esta máquina expone un servidor web que es vulnerable a navegación de directorios, por lo que podemos leer archivos y descubrir que se trata de un archivo binario. Después de analizar el binario, descubrimos que tiene una vulnerabilidad de Format String que puede ser explotada para conseguir RCE como john. Este usuario puede ejecutar otro binario como el usuario r4j. Este binario utiliza una librería externa que podemos modificar debido a los permisos que tiene y ganar acceso como r4j. Finalmente, existe otro binario que ejecuta un servidor de sockets en local, podemos acceder al binario y analizarlo para encontrar una vulnerabilidad de Buffer Overflow. El binario tiene todas las protecciones activas, pero sigue siendo explotable para conseguir RCE como root</description></item><item><title>Forest</title><link>https://7rocky.github.io/htb/forest/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/forest/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de MS RPC, AS-REProasting, descrifrado de contraseñas, DCSync y Pass the Hash. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD, además de usar BloodHound</description></item><item><title>Netmon</title><link>https://7rocky.github.io/htb/netmon/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/netmon/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta una instancia de PRTG Network Monitor que es vulnerable a RCE como system. Nos podemos conectar a FTP con credentiales anonymous y leer una copia de seguridad de un archivo de configuración de PRTG Network Monitor y obtener una contraseña antigua, que proporciona el formato para adivinar la contraseña actual. Luego, podemos ejecutar el exploit público para conseguir RCE y convertirnos en Administrator</description></item><item><title>Frolic</title><link>https://7rocky.github.io/htb/frolic/</link><pubDate>Sat, 23 Mar 2019 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/frolic/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina tiene una página web que almacena algunos archivos con varias codificaciones y lenguajes esotéricos. Finalmente, podemos llegar a una instancia de PlaySMS que es vulnerable a RCE mediante PHP. La máquina contiene un binario SUID que es vulnerable a Buffer Overflow y permite la escalada de privilegios</description></item><item><title>Active</title><link>https://7rocky.github.io/htb/active/</link><pubDate>Sat, 08 Dec 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/active/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina presenta un entorno de Active Directory (AD) para realizar enumeración de SMB, descrifrado de contraseñas y Kerberoasting. Para comprometer la máquina se necesitan conocer técnicas básicas de enumeración y explotación de AD</description></item><item><title>Jerry</title><link>https://7rocky.github.io/htb/jerry/</link><pubDate>Sat, 17 Nov 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/jerry/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina expone una instalación por defecto de Tomcat. Podemos entrar al gestor de aplicaciones con las credentiales por defecto y conseguir ejecución remota de comandos en la máquina como Administrator</description></item><item><title>Mirai</title><link>https://7rocky.github.io/htb/mirai/</link><pubDate>Sat, 10 Feb 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/mirai/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina es un dispositivo Raspberry Pi que tiene configuradas las credenciales por defecto, por lo que podemos acceder por SSH y convertirnos en root porque pertenecemos al grupo sudo. Para obtener la flag root.txt, tenemos que hacer una copia completa de un dispositivo de almacenamiento USB</description></item><item><title>Blue</title><link>https://7rocky.github.io/htb/blue/</link><pubDate>Sat, 13 Jan 2018 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/blue/</guid><description>Hack The Box. Windows. Máquina fácil. Esta máquina expone SMB versión 1, siendo vulnerable a EternalBlue. Una vez que el exploit está completado, tenemos acceso como Administrator</description></item><item><title>Lame</title><link>https://7rocky.github.io/htb/lame/</link><pubDate>Sun, 18 Jun 2017 00:00:00 +0100</pubDate><guid>https://7rocky.github.io/htb/lame/</guid><description>Hack The Box. Linux. Máquina fácil. Esta máquina expone versiones vulnerables de servicios FTP y SMB. El servicio SMB es explotable y deriva en RCE como root</description></item><item><title>0ld is g0ld</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/0ld-is-g0ld/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/0ld-is-g0ld/</guid><description>Se nos proporciona un archivo PDF llamado 0ld is g0ld.pdf, pero está protegido con contraseña
Para obtener la contraseña, podemos usar pdf2john para extraer nu hash y pasárselo a john para romperlo con un ataque de diccionario usando rockyou.txt:
$ pdf2john 0ld\ is\ g0ld.pdf | tee hash 0ld is g0ld.pdf:$pdf$4*4*128*-1060*1*16*5c8f37d2a45eb64e9dbbf71ca3e86861*32*9cba5cfb1c536f1384bba7458aae3f8100000000000000000000000000000000*32*702cc7ced92b595274b7918dcb6dc74bedef6ef851b4b4b5b8c88732ba4dac0c $ john --wordlist=$WORDLISTS/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (PDF [MD5 SHA2 RC4/AES 32/64]) Cost 1 (revision) is 4 for all loaded hashes Press 'q' or Ctrl-C to abort, almost any other key for status jumanji69 (0ld is g0ld.</description></item><item><title>5x5 Crypto</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/5x5-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/5x5-crypto/</guid><description>Se nos proporciona este conjunto de números y caracteres:
1-3,4-4,2-1,3-1,1-5,1-1,4-2,3-3,{,4-4,2-3,4-5,3-2,1-2,4-3,_,4-5,3-5,} Y se nos dice que el método de cifrado usa una tabla 5x5 con todas las letras del alfabeto en orden. Si hacemos una búsqueda rápida, llegamos al Cuadrado de Polibio, que es este:
A B C D E F G H I/J K L M N O P Q R S T U V W X Y Z Podemos tomar cada par i-j y tomar la letra correspondiente al hacer coincidir fila y columna.</description></item><item><title>A little something to get you started</title><link>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/a-little-something-to-get-you-started/</guid><description>Tenemos una simple página web como esta:
Podemos leer el código HTML de la página, que es el siguiente:
Hay una imagen llamada background.png, Pero no observamos nada en la página web. Podemos acceder a ella utilizando curl:
$ curl http://35.190.155.168/9a968e7787/background.png ^FLAG^xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx$FLAG$ Y obtenemos la flag.</description></item><item><title>aes</title><link>https://7rocky.github.io/ctf/imaginaryctf/aes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/aes/</guid><description>Se nos proporciona esta salida:
Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &amp;gt;&amp;gt;&amp;gt; import random &amp;gt;&amp;gt;&amp;gt; from Crypto.Cipher import AES &amp;gt;&amp;gt;&amp;gt; key = random.choice(open("rockyou.txt", "rb").readlines()[:10000]).strip() &amp;gt;&amp;gt;&amp;gt; key = key.zfill(16) &amp;gt;&amp;gt;&amp;gt; cipher = AES.new(key, AES.MODE_ECB) &amp;gt;&amp;gt;&amp;gt; cipher.encrypt(open("flag.txt", "rb").read().zfill(48)) b"\xd6\x19O\xbeA\xb0\x15\x87\x0e\xc7\xc4\xc1\xe9h\xd8\xe6\xc6\x95\x82\xaa#\x91\xdb2l\xfa\xf7\xe1C\xb8\x11\x04\x82p\xe5\x9e\xb1\x0c*\xcc[('\x0f\xcc\xa7W\xff" Se trata del resultado de una consola de Python REPL. Lo que hace es coger una contraseña aleatoria de rockyou.</description></item><item><title>Almost SSTI</title><link>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/almost-ssti/</guid><description>Se nos proporciona una página web para analizar. La página principal muestra el código fuente del servidor:
#!/usr/bin/env python3 fromflaskimportFlask, render_template_string, request, Response app=Flask(__name__) @app.route('/') defindex(): returnResponse(open(__file__).read(), mimetype='text/plain') @app.route('/ssti') defssti(): query=request.args['query'] iflen(query) &amp;gt;2: return"Too long!" returnrender_template_string(query) app.run('0.0.0.0', 3002, debug=True) Se trata de una página web hecha en Flask (Python). Algo interesante es que el modo debug está activado.
El reto habla de SSTI (Server-Side Template Injection), pero solamente podemos introducir 2 bytes.</description></item><item><title>Amidst Us</title><link>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/amidst-us/</guid><description>Tenemos la siguiente página web, que simula el juego Among Us:
Existe un botón para seleccionar un color con un color picker:
Si analizamos el código fuente, tenemos una aplicación en Flask (en Python). Este es application/blueprints/routes.py:
fromflaskimportBlueprint, request, render_template, abort fromapplication.utilimportmake_alpha web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/alphafy', methods=['POST']) defalphafy(): ifnotrequest.is_jsonor'image'notinrequest.json: returnabort(400) returnmake_alpha(request.json) La función make_alpha está definida en application/util.py:
importos, base64 fromPILimportImage, ImageMath fromioimportBytesIO generate=lambdax: os.urandom(x).hex() defmake_alpha(data): color=data.</description></item><item><title>Android-in-the-middle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/android-in-the-middle/</guid><description>Se nos proporciona el código fuente en Python para lanzar una instancia en local del reto:
$ python3 source.py $ nc 127.0.0.1 1337 DEBUG MSG - Generating The Global DH Parameters DEBUG MSG - g = 2, p = 10177459997049772558637057109490700048394574760284564283959324525695097805837401714582821820424475480057537817583807249627119267268524840254542683041588432363128111683358536204391767254517057859973149680238170237977230020947732558089671785239121778309357814575486749623687357688511361367822815452806637006568922401890961240475060822815400430220536180181951862931844638638933951683988349468373510128406899660648258602475728913837826845743111489145006566908004165703542907243208106044538037004824530893555918497937074663828069774495573109072469750423175863678445547058247156187317168731446722852098571735569138516533993 DEBUG MSG - Calculation Complete DEBUG MSG - Generating The Public Key of CPU... DEBUG MSG - Calculation Complete DEBUG MSG - Public Key is: ??? Enter The Public Key of The Memory: Mirando el código fuente, vemos que el programa espera un número $M$ para generar un secreto compartido.</description></item><item><title>APKrypt</title><link>https://7rocky.github.io/ctf/htb-challenges/mobile/apkrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/mobile/apkrypt/</guid><description>Se nos proporciona un archivo APK (APKrypt.apk). Tenemos que encontrar un código VIP en el archivo APK. Por tanto, utilizaremos d2j-dex2jar para conseguir un archivo JAR:
$ d2j-dex2jar APKrypt.apk dex2jar APKrypt.apk - ./APKrypt-dex2jar.jar Ahora podemos subir el archivo JAR a www.javadecompilers.com y seleccionar Jadx como descompilador.
El archivo principal es sources/com/example/apkrypt/MainActivity.java:
packagecom.example.apkrypt; importandroid.app.Activity; importandroid.os.Bundle; importandroid.util.Base64; importandroid.view.View; importandroid.widget.Button; importandroid.widget.EditText; importandroid.widget.Toast; importjava.security.Key; importjava.security.MessageDigest; importjava.security.NoSuchAlgorithmException; importjavax.crypto.Cipher; importjavax.crypto.spec.SecretKeySpec; publicclassMainActivityextendsActivity{ /* renamed from: b1 */ Buttonf77b1; EditTexted1; publicstaticStringdecrypt(Stringstr) throwsException{ KeygenerateKey =generateKey(); Cipherinstance =Cipher.</description></item><item><title>arcsin1</title><link>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/arcsin1/</guid><description>Se nos pide calcular -arcsin(-1) * 0.2 (en radianes) y coger los dígitos entre las posiciones 10000 y 10099 de la parte decimal del resultado.
Antes que nada, vamos a aplicar matemáticas:
$$ \sin{\left(\frac{-\pi}{2}\right)} = -1 \iff \arcsin{(-1)} = \frac{-\pi}{2} $$
Nótese que la función arco coseno está acotada: $\frac{-\pi}{2} \leq \arcsin{x} \leq \frac{\pi}{2}$ for $x \in \mathbb{R}$. Por tanto:
$$ -\arcsin{(-1)} \cdot 0.2 = - \left(\frac{-\pi}{2}\right) \cdot 0.2 = \frac{\pi}{10} $$</description></item><item><title>Art</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/art/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/art/</guid><description>Se nos proporciona una imagen PNG llamada art.png:
$ file art.png art.png: PNG image data, 300 x 300, 8-bit/color RGBA, non-interlaced Podríamos pensar que la flag se esconde en los colores que aparecen en la imagen. No obstante, después de un poco de investigación, encontramos que exista un lenguaje esotérico llamado npiet que codifica texto en imágenes mediante colores:
Los ejemplos se asemejan bastante a lo que tenemos, por lo que vamos a probar:</description></item><item><title>baby auth</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-auth/</guid><description>Se nos proporciona esta página web:
Primero, nos podemos registrar (nombre asdf, por ejemplo):
Luego, nos dicen que no somos admin. De hecho, la autenticación se gestiona con cookies de sesión:
La cookie se sesión parece codificada en Base64, por lo que vamos a decodificarla (cuidado con la codificación de URL):
$ echo eyJ1c2VybmFtZSI6ImFzZGYifQ== | base64 -d {"username":"asdf"} Muestra nuestro nombre de usuario, a lo mejor podemos modificar la cookie y ganar acceso como admin:</description></item><item><title>baby BoneChewerCon</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-bonechewercon/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto. Vamos a poner algo y a enviarlo.
Se nos muestra un error en el depurador de Laravel (un framework de PHP):
Esto es una mala práctica y un problema de seguridad, ya que los depuradores pueden contener información sensible y muchos de ellos proporcionan maneras de ejecutar código.
Flag De hecho, podemos encontrar la flag en una variable de entorno llamada APP_KEY (HTB{wh3n_th3_d3bugg3r_turns_4g41nst_th3_d3bugg33}):</description></item><item><title>baby CachedView</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-cachedview/</guid><description>Tenemos una aplicación web en Flask que nos permite renderizar otras páginas web como una imagen:
Por detrás, el servidor lanza un Headless Chrome con selenium, accede a la página que le indicamos y toma una captura de pantalla para mostrarla. Aquí hay un ejemplo:
El objetivo es llegar a la ruta /flag:
@web.route('/flag') @is_from_localhost def flag(): return send_file('flag.png') Sin embargo, está protegida verificando que la petición se realiza desde 127.</description></item><item><title>Baby Crypt</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-crypt/</guid><description>Se nos proporciona un binario llamado baby_crypt:
$ file baby_crypt baby_crypt: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=24af7e68eab982022ea63c1828813c3bfa671b51, for GNU/Linux 3.2.0, not stripped Si lo abrimos en Ghidra, veremos esta función main:
intmain() { char*key; longin_FS_OFFSET; inti; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined2 local_20; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); printf("Give me the key and I\'ll give you the flag: "); key =(char*) malloc(4); fgets(key, 4, stdin); local_38 =0x6f0547480c35643f; local_30 =0x28130304026f0446; local_28 =0x5000f4358280e52; local_20 =0x4d56; for(i =0; i &amp;lt;0x1a; i =i +1) { *(byte *) ((long) &amp;amp;local_38 +(long) i) =*(byte *) ((long) &amp;amp;local_38 +(long) i) ^key[i %3]; } printf("</description></item><item><title>baby interdimensional internet</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-interdimensional-internet/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
fromflaskimportFlask, Response, request, render_template, request fromrandomimportchoice, randint fromstringimportlowercase fromfunctoolsimportwraps app=Flask(__name__) defcalc(recipe): globalgarage garage={} try: exec(recipe, garage) except: pass defGCR(func): # Great Calculator of the observable universe and it's infinite timelines @wraps(func) deffederation(*args, **kwargs): ingredient=''.join(choice(lowercase) for_inrange(10)) recipe='%s= %s'%(ingredient, ''.join(map(str, [randint(1, 69), choice(['+', '-', '*']), randint(1,69)]))) ifrequest.</description></item><item><title>baby ninja jinja</title><link>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/baby-ninja-jinja/</guid><description>Se nos proporciona esta página web:
Existe un comentario en el código HTML de la página que indica una URL de depuración (/debug):
En esta ruta /debug, podemos encontrar el código fuente:
$ curl 157.245.33.77:31650/debug from flask import Flask, session, render_template, request, Response, render_template_string, g import functools, sqlite3, os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(120) acc_tmpl = '''{% extends 'index.html' %} {% block content %} &amp;lt;h3&amp;gt;baby_ninja joined, total number of rebels: reb_num&amp;lt;br&amp;gt; {% endblock %} ''' def get_db(): db = getattr(g, '_database', None) if db is None: db = g.</description></item><item><title>Baby RE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/baby-re/</guid><description>Se nos proporciona un binario llamado baby:
$ file baby baby: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25adc53b89f781335a27bf1b81f5c4cb74581022, for GNU/Linux 3.2.0, not stripped Si lo ejecutamos, pregunta por una clave:
$ ./baby Insert key: Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: 1234 Try again later. Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item><item><title>babyreeee</title><link>https://7rocky.github.io/ctf/other/babyreeee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/babyreeee/</guid><description>Se nos proporciona un binario llamado chall:
$ file chall chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=151528987cd274999ec93665ef2d6a7678c5107b, for GNU/Linux 3.2.0, stripped Si lo ejecutamos, nos pregunta por la flag:
$ ./chall Hello! Welcome to SEETF. Please enter the flag. SEE{asdf} Flag wrong. Try again. Vamos a abrir el binario en Ghidra para analizar el código en C descompilado. Esta es la función main.</description></item><item><title>Base 2 2 the 6</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/base-2-2-the-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/base-2-2-the-6/</guid><description>Nos dan este texto:
Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K
Como está compuesto por números y letras en mayúsculas y minúsculas, parece que está codificado en Base64.
De hechom el nombre del reto es &amp;ldquo;2 2 the 6&amp;rdquo; (&amp;quot;2 to the 6&amp;quot;), por lo que $2^6 = 64$.
Podemos decodificarlo en una consola de comandos:
$ echo Q1RGbGVhcm57RmxhZ2d5V2FnZ3lSYWdneX0K | base64 -d CTFlearn{FlaggyWaggyRaggy}</description></item><item><title>basic</title><link>https://7rocky.github.io/ctf/imaginaryctf/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/basic/</guid><description>Se nos pide representar 51 en base 12. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; def dec_to_base(n: int, b: int) - int: ... digits = [] ... while n: ... digits.append(n % b) ... n //= b ... return int(''.join(map(str, digits[::-1]))) ... &amp;gt;&amp;gt;&amp;gt; dec_to_base(51, 12) 43 &amp;gt;&amp;gt;&amp;gt; 4 * 12 + 3 51 Y la flag es ictf{43}.</description></item><item><title>basic-file-exploit</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/basic-file-exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/basic-file-exploit/</guid><description>Se nos proporciona el código fuente en C de un programa que está en ejecución en remoto:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define WAIT 60 static const char* flag = "[REDACTED]"; static char data[10][100]; static int input_lengths[10]; static int inputs = 0; int tgetinput(char *input, unsigned int l) { fd_set input_set; struct timeval timeout; int ready_for_reading = 0; int read_bytes = 0; if(l &amp;lt;= 0) { printf("</description></item><item><title>Bat Computer</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/bat-computer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/bat-computer/</guid><description>Se nos proporciona un binario de 64 bits llamado batcomputer:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Ingeniería inversa Si usamod Ghidra, veremos el código descompilado en C para la función main:
intmain() { intres; intoption; charpassword[16]; charcommand[76]; setup(); while(true) { while(true) { memset(password, 0, 16); printf("Welcome to your BatComputer, Batman. What would you like to do?\n1. Track Joker\n2.</description></item><item><title>BBGun06</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/bbgun06/</guid><description>Se nos proporciona un código fuente en Python que nos pregunta por una firma. Esta es la función main:
defmain(s): rsa=RSA(2048) user, data=parseEmail() signature=rsa.sign(user) rsa.verify(user, signature) headers=generateHeaders(rsa, signature) valid_email=headers+data sendMessage(s, valid_email+"\n\n") try: forged_signature=recieveMessage(s, "Enter the signature as hex: ") forged_signature=bytes.fromhex(forged_signature) ifnotrsa.verify(user, forged_signature): sendMessage(s, "Invalid signature") ifdifferent(rsa, signature, forged_signature): sendMessage(s, FLAG) except: sendMessage(s, "An error occured") La función rsa.verify hace esto:
defverify(self, message, signature): keylength=len(long_to_bytes(self.n)) decrypted=self.encrypt(signature) clearsig=decrypted.to_bytes(keylength, "big") r=re.compile(b'\x00\x01\xff+?\x00(.{15})(.{20})', re.DOTALL) m=r.</description></item><item><title>BitsNBytes</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/bitsnbytes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/bitsnbytes/</guid><description>Se nos proporcionan dos imágenes PNG intercepted.png y original.png:
$ file intercepted.png intercepted.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced $ file original.png original.png: PNG image data, 775 x 550, 8-bit/color RGB, non-interlaced Ambas imágenes parecen iguales visualmente:
Pero realmente son diferentes porque sus hashes MD5 no coinciden:
$ md5sum intercepted.png 88e9b5b97e4a615f1aa26d11dbcdec0d intercepted.png $ md5sum original.png 04e2562c19e680b6493b2a31d65c51e3 original.png Entonces, podemos deducir que hay algún tipo de esteganografía aplicada en intercepted.</description></item><item><title>Bizz Fuzz</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/bizz-fuzz/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) No tenemos el código fuente del binario, y además está despojado:
$ file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836e2f666bd53c2307bff4801d330e444556a006, stripped Ingeniería inversa Realizar ingeniería inversa sobre el binario será más complicado ya que no tenemos los nombres de las funciones.</description></item><item><title>Blackbox</title><link>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/blackbox/</guid><description>Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario llamado blackbox que es SGID:
blackbox@ubuntu-512mb-nyc3-01:~$ ls -l total 16 ---x--s--x 1 root blackbox_pwn 8936 Jan 31 2019 blackbox -r--r----- 1 root blackbox_pwn 33 Oct 9 2017 flag.txt blackbox@ubuntu-512mb-nyc3-01:~$ file blackbox blackbox: setgid executable, regular file, no read permission Como se puede ver, no tenemos permisos de lectura, por lo que no podemos transferir el archivo a nuestra máquina, ni descompilarlo, ni depurarlo.</description></item><item><title>Blacksmith</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/blacksmith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/blacksmith/</guid><description>Se nos proporciona un binario de 64 bits llamado blacksmith:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Si lo abrimos en Ghidra, veremos esta función main:
voidmain() { size_tlength; longin_FS_OFFSET; intanswer; intoption; char*message_1; char*message_2; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setup(); message_1 ="You are worthy to carry this Divine Weapon and bring peace to our homeland!\n"; message_2 ="This in not a weapon!</description></item><item><title>BlinkerFluids</title><link>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/blinkerfluids/</guid><description>Tenemos una página web donde podemos escribir en Markdown y transformar el documento a PDF:
Por defecto, tenemos este contenido en Markdown:
Como tenemos un proyecto en Node.js, si leemos el archivo package.json veremos las versiones de las dependencias de terceros:
{ "name": "blinker-fluids", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "start": "node index.js" }, "keywords": [], "author": "rayhan0x01", "license": "ISC", "dependencies": { "express": "4.17.3", "md-to-pdf": "4.1.0", "nunjucks": "3.2.3", "</description></item><item><title>bloat.py</title><link>https://7rocky.github.io/ctf/picoctf/reverse-engineering/bloat.py/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/reverse-engineering/bloat.py/</guid><description>Se nos proporciona un script de Python llamado bloat.flag.py:
import sys a = "!\"#$%&amp;amp;'()*+,-./0123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"+ \ "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ " def arg133(arg432): if arg432 == a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68]: return True else: print(a[51]+a[71]+a[64]+a[83]+a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+\ a[81]+a[67]+a[94]+a[72]+a[82]+a[94]+a[72]+a[77]+a[66]+a[78]+a[81]+\ a[81]+a[68]+a[66]+a[83]) sys.exit(0) return·False def arg111(arg444): return arg122(arg444.decode(), a[81]+a[64]+a[79]+a[82]+a[66]+a[64]+a[75]+\ a[75]+a[72]+a[78]+a[77]) def arg232(): return input(a[47]+a[75]+a[68]+a[64]+a[82]+a[68]+a[94]+a[68]+a[77]+a[83]+\ a[68]+a[81]+a[94]+a[66]+a[78]+a[81]+a[81]+a[68]+a[66]+a[83]+\ a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+a[81]+a[67]+a[94]+\ a[69]+a[78]+a[81]+a[94]+a[69]+a[75]+a[64]+a[70]+a[25]+a[94]) def arg132(): return open('flag.txt.enc', 'rb').read() def arg112(): print(a[54]+a[68]+a[75]+a[66]+a[78]+a[76]+a[68]+a[94]+a[65]+a[64]+a[66]+\ a[74]+a[13]+a[13]+a[13]+a[94]+a[88]+a[78]+a[84]+a[81]+a[94]+a[69]+\ a[75]+a[64]+a[70]+a[11]+a[94]+a[84]+a[82]+a[68]+a[81]+a[25]) def arg122(arg432, arg423): arg433 = arg423 i = 0 while len(arg433) &amp;lt; len(arg432): arg433 = arg433 + arg423[i] i = (i + 1) % len(arg423) return "</description></item><item><title>Block Hunt3r</title><link>https://7rocky.github.io/ctf/htb-challenges/osint/block-hunt3r/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/osint/block-hunt3r/</guid><description>Tenemos información de que alguien ha subido imágenes a la red de pruebas Görli (una Blockchain de Ethereum) entre 2020-07-30 y 2020-08-01. Necesitamos encontrar una imagen que contenga la flag.
Para interactuar con Görli necesitamos ir a https://goerli.etherscan.io. Podemos encontrar el rango de números de bloque entre las fechas indicadas manualmente yendo a https://goerli.etherscan.io/blocks/&amp;lt;número&amp;gt;. Probando y probando, llegamos a que https://goerli.etherscan.io/block/3134050 es el primer bloque en el rango y https://goerli.etherscan.io/block/3151326 es el último (un total de 17276 bloques).</description></item><item><title>Box</title><link>https://7rocky.github.io/ctf/imaginaryctf/box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/box/</guid><description>Se nos proporciona el siguiente código en Python que cifra la flag:
fromCrypto.Util.numberimportbytes_to_long flag=open("flag.txt", "rb").read().strip() TABLE=[ lambdaa, b: f"({a}+{b})", lambdaa, b: f"({a}-{b})", lambdaa, b: f"({a}*{b})", ] defbuild_box(s: bytes): e="(x)" forbins: e=TABLE[b%len(TABLE)](e, b) returneval(f"lambda x: {e}") box=build_box(flag) ct=box(bytes_to_long(flag)) print(ct) print(box(1337)) print(box(0x1337)) """ Output: 5545457088879574964209613711409478327714366805681091501255101702161458272094830554232779120250 3011454617406654839679120250 10002638090931457241529120250 """ Se trata de una forma extraña de cifrar un mensaje. Básicamente, box es un conjunto de operaciones que contiene una sola x, y al llamar a box con un valor dado, se sustituye dicho valor en la x para obtener el resultado final.</description></item><item><title>Brainy's Cipher</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/brainys-cipher/</guid><description>Se nos proporciona el siguiente archivo de texto (brainy.txt):
++++++++++[++++++++++++++++++++++++++++++++++++++++++++.-----------.+.-------------.++++++++++++.------------.+++++++++++++.--------------.++++++++++++++++++++++++++. Se trata de un lenguaje esotérico llamado Brainfuck. Si usamos una herramienta como www.tutorialspoint.com, podemos obtener el resultado:
En resumen, tenemos:
p = 7901324502264899236349230781143813838831920474669364339844939631481665770635584819958931021644265960578585153616742963330195946431321644921572803658406281 q = 12802918451444044622583757703752066118180068668479378778928741088302355425977192996799623998720429594346778865275391307730988819243843851683079000293815051 dp = 5540655028622021934429306287937775291955623308965208384582009857376053583575510784169616065113641391169613969813652523507421157045377898542386933198269451 dq = 9066897320308834206952359399737747311983309062764178906269475847173966073567988170415839954996322314157438770225952491560052871464136163421892050057498651 c = 62078086677416686867183857957350338314446280912673392448065026850212685326551183962056495964579782325302082054393933682265772802750887293602432512967994805549965020916953644635965916607925335639027579187435180607475963322465417758959002385451863122106487834784688029167720175128082066670945625067803812970871 $p$ y $q$ parecen parámetros para un criptosistema RSA, y $c$ debe ser el texto cifrado. Sin embargo, necesitamos saber qué son $dp$ y $dq$.</description></item><item><title>BruXOR</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/bruxor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/bruxor/</guid><description>Se nos proporcionan estos caracteres:
TCQ{rveyln'bH_varHuebcrqxetrHOXEj Nos dicen que se ha utilizado un cifrado XOR, pero necesitamos descubrir la clave. Para esto, podemos realizar un ataque de fuerza bruta utilizando el módulo &amp;ldquo;XOR Brute Force&amp;rdquo; de CyberChef](https://gchq.github.io/CyberChef). Si filtramos por CTFlearn, obtenemos la clave y la flag:
Flag: CTFlearn{y0u_Have_bruteforce_XOR}.</description></item><item><title>Buscar</title><link>https://7rocky.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/search/</guid><description>BuscarBusca por palabras clave en soluciones de CTF y HTB &amp;lt;- INICIO Total: 0 let fuse const options = { findAllMatches: true, ignoreLocation: true, keys: ['title', 'summary', 'contents'], threshold: 0, } document.forms[0].addEventListener('submit', e = { e.preventDefault() executeSearch() }) function loadSearch() { fetch('\/index.json').then(res = res.json()).then(data = { fuse = new Fuse(data, options) }) } function executeSearch() { const results = fuse.search(document.getElementById('search').value).filter(r = r.item.section !== 'imc') let searchitems = '' for (let result of results) { searchitems += `${result.</description></item><item><title>Cache Me Outside</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cache-me-outside/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cache-me-outside/</guid><description>Se nos proporciona un binario de 64 bits llamado heapedit y un archivo libc.so.6 como librería externa:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):
$ chmod +x heapedit $ ./heapedit zsh: segmentation fault (core dumped) ./heapedit Está configurado para utilizar Glibc desde el directorio actual:
$ ldd heapedit linux-vdso.</description></item><item><title>Character Encoding</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/character-encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/character-encoding/</guid><description>Se nos proporcionan estos caracteres:
43 54 46 6C 65 61 72 6E 7B 34 35 43 31 31 5F 31 35 5F 55 35 33 46 55 4C 7D Como son todo números y letras entre A y F, parece que se trata de una codificación en ASCII hexadecimal.
Por ejemplo, 0x43 es el código de la C, 0x54 es el de la T y 0x46 el de la F.</description></item><item><title>Chase</title><link>https://7rocky.github.io/ctf/htb-challenges/forensics/chase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/forensics/chase/</guid><description>Se nos proporciona un archivo PCAP con mensajes HTTP y segmentos TCP:
Si filtramos por el protocolo HTTP, veremos algunas peticiones y respuestas:
Podríamos pensar que el cibercriminal encontró una vulnerabilidad de subida de archivo y subió un cmd.aspx y luego nc64.exe para ejecutar comandos. De hecho, podemos ver que el cibercriminal consiguió una reverse shell en la máquina Windows:
Al final de la captura PCAP, vemos que el cibercriminal intenta acceder a un archivo llamado JBKEE62NIFXF6ODMOUZV6NZTMFGV6URQMNMH2IBA.</description></item><item><title>Classic, yet complicated!</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/classic-yet-complicated/</guid><description>Se nos proporciona un texto cifrado:
alp gwcsepul gtavaf, nlv prgpbpsu mb h jcpbyvdlq, ipltga rv glniypfa we ekl 16xs nsjhlcb. px td o lccjdstslpahzn fptspf xstlxzi te iosj ezv sc xcns ttsoic lzlvrmhaw ez sjqijsa xsp rwhr. tq vxspf sciov, alp wsphvcv pr ess rwxpqlvp nwlvvc dyi dswbhvo ef htqtafvyw hqzfbpg, ezutewwm zcep xzmyr o scio ry tscoos rd woi pyqnmgelvr vpm . qbctnl xsp akbflowllmspwt nlwlpcg, lccjdstslpahzn fptspfo oip qvx dfgysgelipp ec bfvbxlrnj ojocjvpw, ld akfv ekhr zys hskehy my eva dclluxpih yoe mh yiacsoseehk fj l gebxwh sieesn we ekl iynfudktru.</description></item><item><title>Close Enough</title><link>https://7rocky.github.io/ctf/other/close-enough/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/close-enough/</guid><description>Se nos dice que una implementación de RSA utiliza un número primo y el siguiente número primo. Tenemos el texto cifrado:
4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 Y también el código fuente:
from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open("key", "w") as f: f.write(key) m = bytes_to_long(flag.encode()) c = pow(m, e, n) print(f"</description></item><item><title>clutter-overflow</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/clutter-overflow/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Tenemos también el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets y después comparar una variable local (code) con el valor de una variable global (GOAL):
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define SIZE 0x100 #define GOAL 0xdeadbeef const char* HEADER = "</description></item><item><title>Compressor</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/compressor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/compressor/</guid><description>Para este reto solamente tenemos una instancia remota a la que conectarnos:
$ nc 157.245.33.77 31001 [*] Directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv Component List: +===============+ | | | 1. Head 🤖 | | 2. Torso 🦴 | | 3. Hands 💪 | | 4. Legs 🦵 | | | +===============+ [*] Choose component: Podemos elegir el primero, por ejemplo:
[*] Choose component: 1 [*] Sub-directory to work in: 9wIylX4fBakMNG8u6YfY37k3k1geVXHv/Head Actions: 1.</description></item><item><title>Cookies</title><link>https://7rocky.github.io/ctf/picoctf/web-exploitation/cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/web-exploitation/cookies/</guid><description>Se nos proporciona una página web que pregunta por una cookie:
Mirando en las herramientas de desarrollador, vemos que tenemos una cookie name=-1. Si ponemos snickerdoodle como el campo de texto sugiere, la cookie cambiará a name=0:
Vamos a modificar el valor de la cookie usando curl y mostrar solo el mensaje:
$ curl mercury.picoctf.net:27177/check -sH 'Cookie: name=0' | grep -oE '&amp;lt;b&amp;gt;.*?&amp;lt;/b&amp;gt;' &amp;lt;b&amp;gt;I love snickerdoodle cookies!&amp;lt;/b&amp;gt; Ahora vamos a usar un bucle en Bash para ver si algo cambia al poner otro valor como cookie:</description></item><item><title>cos1</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos1/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 6 decimales. Esto es simple:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; import math &amp;gt;&amp;gt;&amp;gt; math.cos(42) -0.39998531498835127 &amp;gt;&amp;gt;&amp;gt; round(math.cos(42), 6) -0.399985 &amp;gt;&amp;gt;&amp;gt; 'ictf{' + str(round(math.cos(42), 6)) + '}' 'ictf{-0.399985}'</description></item><item><title>cos2</title><link>https://7rocky.github.io/ctf/imaginaryctf/cos2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/cos2/</guid><description>Se nos pide calcular el coseno de 42 radianes, redondeado a 10 decimales. Para esto, podemos usar Wolfram Alpha:
Y la flag es:
ictf{-0.3999853149883512939547073371772020283804228791424190606167446601513424425835587794388549191368621883}</description></item><item><title>Cult Meeting</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/cult-meeting/</guid><description>Se nos proporciona un archivo binario llamado meeting:
$ file meeting meeting: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=72d8b06e4ca750d5c24395d3349c3121b9b95283, for GNU/Linux 3.2.0, not stripped Ingeniería inversa Usando Ghidra, podemos leer el código descompilado en C. Esta es la función main:
intmain() { intret; char*pointer; charinput_data[64]; setvbuf(stdout, NULL, 2, 0); puts("\x1b[3mYou knock on the door and a panel slides back\x1b[0m"); puts(&amp;amp;DAT_00102040); fwrite("\"What is the password for this week\'s meeting?</description></item><item><title>CVE-XXXX-XXXX</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/cve-xxxx-xxxx/</guid><description>Tenemos el siguiente enunciado:
The CVE we&amp;rsquo;re looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.
Se nos pide buscar el identificador de CVE de la primera vulnerabilidad de RCE en Windows Print Spooler Service de 2021.</description></item><item><title>Da Vinci</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/da-vinci/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/da-vinci/</guid><description>Se nos proporcionan tres imágenes JPEG:
monalisa.jpg: Plans.jpg: Thepassword_is_the_small_name_of_the_actor_named_Hanks.jpg: $ file monalisa.jpg monalisa.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 300x300, segment length 16, comment: "CREATOR: gd-jpeg v1.0 (using IJG JPEG v62), quality = 92", comment: "Optimized by JPEGmini 3.9.20.0L Internal 0x8c97c7da", baseline, precision 8, 1280x1936, components 3 $ file Plans.jpg Plans.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 100x100, segment length 16, baseline, precision 8, 800x600, components 3 $ file Thepassword_is_the_small_name_of_the_actor_named_Hanks.</description></item><item><title>Don't Bump Your Head(er)</title><link>https://7rocky.github.io/ctf/ctflearn/web/dont-bump-your-header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/web/dont-bump-your-header/</guid><description>Se nos proporciona una URL para interactuar con ella. Vamos a usar curl para ello:
$ curl 165.227.106.113/header.php Sorry, it seems as if your user agent is not correct, in order to access this website. The one you supplied is: curl/7.81.0 &amp;lt;!-- Sup3rS3cr3tAg3nt --&amp;gt; Parece que tenemos que utilizar un agente de usuario concreto (a lo mejor funciona con Sup3rS3cr3tAg3nt):
$ curl 165.227.106.113/header.php -H 'User-Agent: Sup3rS3cr3tAg3nt' Sorry, it seems as if you did not just come from the site, "</description></item><item><title>Down the Rabinhole</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/down-the-rabinhole/</guid><description>Se nos proporciona un código en Python para cifrar la flag, y el correspondiente archivo out.txt:
from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b"HTB{--REDACTED--}" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 256)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = "</description></item><item><title>Emdee five for life</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/emdee-five-for-life/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/emdee-five-for-life/</guid><description>Tenemos la siguiente página web:
Parece que tenemos que calcular el hash MD5 de la cadena de texto mostrada y enviarla:
$ echo -n Vzf9GeB5zAFDZ2M3oKSa | md5sum c03463878fee34e249962c4aef9af84c - Pero hemos sido muy lentos&amp;hellip;
Por tanto, tendremos que programar un script que envíe la petición lo más rápido posible. Una cosa importante a tener en cuenta es mantener la cookie PHPSESSID configurada por el servidor:
$ curl -I 134.209.187.167:31212/ HTTP/1.</description></item><item><title>Encryption Master</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/encryption-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/encryption-master/</guid><description>Se nos proporciona el siguiente texto:
This is NOT going to be fun. TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE= Vemos una cadena de texto larga que está codificada en Base64. Si la decodificamos, tenemos otro texto:
$ data=TmljZSEgTm93IGtlZXAgZ29pbmcuIDU0Nzc2ZjIwNmQ2ZjcyNjUyZTIwMzEzMDMwMzAzMTMxMzAyMDMxMzEzMDMxMzAzMDMxMjAzMTMxMzAzMTMxMzEzMDIwMzEzMTMwMzAzMDMwMzEyMDMxMzEzMDMxMzEzMDMwMjAzMTMwMzAzMDMwMzAyMDMxMzAzMDMwMzEzMDMwMjAzMTMxMzAzMDMxMzAzMTIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMTMwMzAzMTMwMjAzMTMxMzEzMTMwMzAzMTIwMzEzMTMxMzAzMDMwMzAyMDMxMzEzMTMwMzEzMDMwMjAzMTMxMzAzMTMwMzAzMTIwMzEzMTMwMzEzMTMxMzEyMDMxMzEzMDMxMzEzMTMwMjAzMTMwMzAzMDMwMzEyMDMxMzAzMDMwMzAzMDIwMzEzMDMxMzAzMDMwMzEyMDMxMzEzMDMwMzAzMTIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMxMjAzMTMxMzAzMDMwMzEzMDIwMzEzMDMwMzAzMTMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzAzMTMwMzAzMDIwMzEzMTMwMzAzMDMxMzEyMDMxMzEzMDMxMzEzMDMxMjAzMTMxMzAzMTMwMzEyMDMxMzEzMDMxMzEzMTIwMzEzMDMxMzAzMDMxMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMDMwMzAzMTMwMjAzMTMwMzEzMDMxMzAzMDIwMzEzMDMxMzAzMTMxMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMDMxMjAzMTMxMzAzMTMwMzEzMTIwMzEzMTMxMzAzMDMxMjAzMTMwMzEzMDMxMzEzMDIwMzEzMDMxMzAzMDMxMzAyMDMxMzAzMDMwMzEzMTMwMjAzMTMxMzEzMDMwMzEyMDMxMzAzMTMwMzAzMDMwMjAzMTMwMzEzMDMwMzEzMDIwMzEzMTMwMzEzMTMwMzAyMDMxMzEzMTMwMzAzMTIwMzEzMDMxMzEzMDMxMzAyMDMxMzAzMTMwMzEzMDMwMjAzMTMxMzAzMDMwMzEyMDMxMzAzMTMwMzEzMTMwMjAzMTMxMzEzMDMwMzE= $ echo $data | base64 -d Nice! Now keep going. 54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031 Esta vez parecen datos en hexadecimal. Vamos a decodificarlo otra vez:
$ data=54776f206d6f72652e2031303030313130203131303130303120313130313131302031313030303031203131303131303020313030303030203130303031303020313130303130312031313030303131203131313030313020313131313030312031313130303030203131313031303020313130313030312031313031313131203131303131313020313030303031203130303030302031303130303031203131303030312031303130303130203130303031313120313130303031302031303030313131203130313031313020313130313030302031313030303131203131303131303120313130313031203131303131312031303130303131203130313031313020313131303031203130303030313020313031303130302031303130313130203131313030312031303130303031203130313031303120313130313031312031313130303120313031303131302031303130303130203130303031313020313131303031203130313030303020313031303031302031313031313030203131313030312031303131303130203130313031303020313130303031203130313031313020313131303031 $ echo $data | xxd -r -p Two more. 1000110 1101001 1101110 1100001 1101100 100000 1000100 1100101 1100011 1110010 1111001 1110000 1110100 1101001 1101111 1101110 100001 100000 1010001 110001 1010010 1000111 1100010 1000111 1010110 1101000 1100011 1101101 110101 110111 1010011 1010110 111001 1000010 1010100 1010110 111001 1010001 1010101 1101011 111001 1010110 1010010 1000110 111001 1010000 1010010 1101100 111001 1011010 1010100 110001 1010110 111001 Y ahora tenemos información en binario.</description></item><item><title>Enhance!</title><link>https://7rocky.github.io/ctf/picoctf/forensics/enhance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/enhance/</guid><description>Tenemos el archivo de una imagen SVG llamada drawing.flag.svg:
A simple vista, no se ve nada, pero si miramos en el código XML que aparece en el archivo SVG, veremos los caracteres de la flag:
&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&amp;gt; &amp;lt;!-- Created with Inkscape (http://www.inkscape.org/) --&amp;gt; &amp;lt;svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="210mm" height="297mm" viewBox="0 0 210 297" version="1.1" id="svg8" inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)" sodipodi:docname="drawing.svg"&amp;gt; &amp;lt;defs id="defs2" /&amp;gt; &amp;lt;sodipodi:namedview id="base" pagecolor="</description></item><item><title>Enormous</title><link>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/enourmous/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* m=bytes_to_long(open('flag.txt', 'rb').read()) n=1 foriinrange(5): n*=getPrime(2025) e=31 c=pow(m, e, n) print(f'{n= }') print(f'{c= }') Y tenemos el texto cifrado $c$ y el módulo $n$ de una implementación RSA. Nótese que $e = 31$ es muy pequeño y que $n$ es muy grande. Por tanto, seremos capaces de hacer la raíz de orden 31 para recuperar el mensaje $m$, ya que</description></item><item><title>Evaluation Deck</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/evaluation-deck/</guid><description>Se nos proporciona la siguiente página web:
No obstante, la interfaz no es interesante&amp;hellip;
Análisis de código estático También disponemos del código fuente. La aplicación web está construida en Flask (Python). El siguiente archivo es application/blueprints/routes.py:
fromflaskimportBlueprint, render_template, request fromapplication.utilimportresponse web=Blueprint('web', __name__) api=Blueprint('api', __name__) @web.route('/') defindex(): returnrender_template('index.html') @api.route('/get_health', methods=['POST']) defcount(): ifnotrequest.is_json: returnresponse('Invalid JSON!'), 400 data=request.get_json() current_health=data.get('current_health') attack_power=data.get('attack_power') operator=data.get('operator') ifnotcurrent_healthornotattack_powerornotoperator: returnresponse('All fields are required!'), 400 result={} try: code=compile(f'result = {int(current_health)}{operator}{int(attack_power)}', '&amp;lt;string&amp;gt;', 'exec') exec(code, result) returnresponse(result.</description></item><item><title>Exif</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/exif/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/exif/</guid><description>Se nos pide encontrar la flag en esta imagen:
Sin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en los metadatos del archivo.
Para extraer los metadatos, podemos utilizar exiftool:
$ exiftool Computer-Password-Security-Hacker\ -\ Copy.jpg ExifTool Version Number : 12.30 File Name : Computer-Password-Security-Hacker - Copy.jpg Directory : . File Size : 54 KiB File Modification Date/Time : - File Access Date/Time : - File Inode Change Date/Time : - File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.</description></item><item><title>Fast Carmichael</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/fast-carmichael/</guid><description>Se nos proporciona el código fuente en Python del servidor:
fromsecretimportFLAG fromCrypto.Util.numberimportisPrime importsocketserver importsignal classHandler(socketserver.BaseRequestHandler): defhandle(self): signal.alarm(0) main(self.request) classReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass defsendMessage(s, msg): s.send(msg.encode()) defreceiveMessage(s, msg): sendMessage(s, msg) returns.recv(4096).decode().strip() defgenerate_basis(n): basis=[True] *n foriinrange(3, int(n**0.5) +1, 2): ifbasis[i]: basis[i*i::2*i] =[False] *((n-i*i-1) //(2*i) +1) return[2] +[iforiinrange(3, n, 2) ifbasis[i]] defmillerRabin(n, b): basis=generate_basis(300) ifn==2orn==3: returnTrue ifn%2==0: returnFalse r, s=0, n-1 whiles%2==0: r+=1 s//=2 forbinbasis: x=pow(b, s, n) ifx==1orx==n-1: continue for_inrange(r-1): x=pow(x, 2, n) ifx==n-1: break else: returnFalse returnTrue def_isPrime(p): ifp&amp;lt;1: returnFalse if(p.</description></item><item><title>Fasting</title><link>https://7rocky.github.io/ctf/imaginaryctf/fasting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/fasting/</guid><description>Se nos proporciona un servidor puzzler7.imaginaryctf.org:5005. Si enviamos una petición GET usando curl, obtenemos la siguiente respuesta:
$ curl puzzler7.imaginaryctf.org:5005 {"api_message":"Yet another sourceless web..."} $ curl -i puzzler7.imaginaryctf.org:5005 HTTP/1.1 200 OK date: server: uvicorn content-length: 47 content-type: application/json {"api_message":"Yet another sourceless web..."} Empleando ffuf, descubrimos dos rutas docs y redoc:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://puzzler7.imaginaryctf.org:5005/FUZZ docs [Status: 200, Size: 931, Words: 150, Lines: 31, Duration: 114ms] redoc [Status: 200, Size: 891, Words: 176, Lines: 31, Duration: 111ms] [Status: 200, Size: 47, Words: 4, Lines: 1, Duration: 111ms] Ambas sirven para mostrar una documentación de API para gente que quiera consumir dicha API:</description></item><item><title>Favorite Color</title><link>https://7rocky.github.io/ctf/ctflearn/binary/favorite-color/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/favorite-color/</guid><description>Se nos proporciona un servidor al que conectarnos por SSH. Existe un binario de 32 bits llamado color que es SGID:
color@ubuntu-512mb-nyc3-01:~$ ls -l total 20 -r--r--r-- 1 root root 714 Sep 12 2017 Makefile -r-xr-sr-x 1 root color_pwn 7672 Sep 12 2017 color -r--r--r-- 1 root root 722 Sep 12 2017 color.c -r--r----- 1 root color_pwn 24 Sep 12 2017 flag.txt color@ubuntu-512mb-nyc3-01:~$ file color color: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>fermat-strings</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/fermat-strings/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir dos números y tratar de buscar uno que rompa el Último Teorema de Fermat.
Como recordatorio, el Último Teorema de Fermat dice que no existen números positivos $a$, $b$, $c$ que cumplan la ecuación:</description></item><item><title>filtered-shellcode</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/filtered-shellcode/</guid><description>Se nos proporciona un binario de 32 bits llamado fun:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments No tenemos el código fuente en C. Esta vez, en lugar de hacer ingeniería inversa con Ghidra, analizaremos el binario con GDB.
Primero, vamos a ejecutar el programa:
$ ./fun Give me code to run: asdf zsh: segmentation fault (core dumped) .</description></item><item><title>Find Marher's Secret</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/find-marhers-secret/</guid><description>Se nos proporciona un sódigo en Python y un servidor al que conectarnos:
$ nc 161.35.172.25 32275 Connected to the cyborg's debugging interface Options: 1. Encrypt your text. 2. Claim the key. &amp;gt; Análisis de código estático Esta es la parte importante del código:
defchallenge(req): key=bytes.fromhex(KEY) assert(len(key) ==27) req.sendall(b'Connected to the cyborg\'s debugging interface\n') whileTrue: req.sendall( b'\nOptions:\n1. Encrypt your text.\n2. Claim the key.\n&amp;gt; ') try: response=json.loads(req.recv(4096).decode()) ifresponse['option'] =='encrypt': iv=bytes.fromhex(response['iv']) pt=bytes.</description></item><item><title>Find The Easy Pass</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/find-the-easy-pass/</guid><description>Se nos proporciona un binario de 32 bits llamado EasyPass.exe que es un archivo Windows PE:
$ file EasyPass.exe EasyPass.exe: PE32 executable (GUI) Intel 80386, for MS Windows Si lo ejecutamos en una máquina Windows, nos preguntará por una contraseña:
Como la contraseña será incorrecta, veremos un mensaje &amp;ldquo;Wrong Password!&amp;rdquo;:
Un análisis de código estático con Ghidra no es útil. Por tanto, vamos a utilizar un depurador como x32dbg para depurar el binario.</description></item><item><title>Fleet Management</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/fleet-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/fleet-management/</guid><description>Se nos proporciona un binario de 64 bits llamado fleet_management:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si lo abrimos en Ghidra, veremos esta función main:
intmain() { setup(); fprintf(stdout, "%s%sFleet Management System %s\n", &amp;amp;DAT_001023e5, &amp;amp;DAT_001020e9, &amp;amp;DAT_001023e0); fprintf(stdout, "\n%s[*] Loading . . .\n%s", &amp;amp;DAT_001020f1, &amp;amp;DAT_001020e9); sleep(2); menu(); return0; } Está llamando a menu:
voidmenu() { longin_FS_OFFSET; undefined8 uVar1; charlocal_13 [3]; undefined8 canary; canary =*(undefined8 *) (in_FS_OFFSET +0x28); memset(local_13, 0, 3); do{ fwrite("</description></item><item><title>fno-stack-protector</title><link>https://7rocky.github.io/ctf/other/fno-stack-protector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/fno-stack-protector/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Si lo abrimos en Ghidra, veremos las siguientes funciones:
voidbad_function() { execve("/bin/sh", NULL, NULL); } voidvuln() { chardata[10]; read(0, data, 170); } intmain() { setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return0; } Existe una vulnerabilidad de Buffer Overflow. Vemos que data es una cadena de caracteres de 10 bytes, y el programa lee hasta 170 bytes.</description></item><item><title>Forensics 101</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/forensics-101/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/forensics-101/</guid><description>Se nos pide encontrar la flag en esta imagen:
Sin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en su contenido en crudo.
Para extraer los caracteres imprimibles de la imagen podemos utilizar strings y filtrar por CTFlearn encadenando el comando anterior con grep:
$ strings 95f6edfb66ef42d774a5a34581f19052.jpg | grep CTFlearn CTFlearn{wow!_data_is_cool}</description></item><item><title>Format</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/format/</guid><description>Se nos proporciona un binario de 64 bits llamado format:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Después de ejecutarlo, vemos que el programa solamente repite lo que introducimos:
$ ./format asdf asdf fdsa fdsa Usando Ghidra, podemos hacer ingeniería inversa para ver el código fuente y observar lo que hace el programa:
intmain(EVP_PKEY_CTX *param_1) { longcanary; longin_FS_OFFSET; canary =*(long*) (in_FS_OFFSET +0x28); init(param_1); echo(); if(canary !</description></item><item><title>fs0ciety</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/fs0ciety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/fs0ciety/</guid><description>Se nos proporciona un archivo ZIP llamado fsociety.zip:
$ unzip -v fsociety.zip Archive: fsociety.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 729 Defl:N 186 75% 08-15-2017 17:44 e126a116 sshcreds_datacenter.txt -------- ------- --- ------- 729 186 75% 1 file Vemos que está protegido con contraseña:
$ unzip fsociety.zip Archive: fsociety.zip [fsociety.zip] sshcreds_datacenter.txt password: Por tanto, podemos probar a realizar un ataque de fuerza bruta usando rockyou.</description></item><item><title>Full Stack Conf</title><link>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/full-stack-conf/</guid><description>Se nos proporciona esta página web:
Al final de la página podemos introducir texto:
Si ponemos algunos datos, vemos un mensaje:
No obstante, la página pide que mostremos un alert(). Esto se suele usar como prueba de concepto para un ataque de Cross-Site Scripting (XSS). Uno de los payloads de XSS más sencillos es:
&amp;lt;imgsrc=xonerror=alert(1)&amp;gt; Si lo usamos, veremos la flag en el alert (HTB{p0p..p0p..p0p...alert(1337)}):</description></item><item><title>GET aHEAD</title><link>https://7rocky.github.io/ctf/picoctf/web-exploitation/get-ahead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/web-exploitation/get-ahead/</guid><description>Se nos proporciona una página web que muestra dos colores de fondo:
El botón rojo utiliza una petición GET y el azul usa una petición POST. Pero no vemos nada más.
Como el nombre del reto incluye HEAD, vamos a ver si qué pasa si hacemos petición HEAD con curl:
$ curl -I mercury.picoctf.net:47967 HTTP/1.1 200 OK flag: picoCTF{r3j3ct_th3_du4l1ty_cca66bd3} Content-type: text/html; charset=UTF-8</description></item><item><title>Git Is Good</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/git-is-good/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/git-is-good/</guid><description>Se nos proporciona un archivo ZIP que contiene un fichero flag.txt:
$ ls flag.txt $ cat flag.txt CTFlearn{REDACTED} Pero esta no es la flag. Mirando un poco más en la carpeta, descubrimos un directorio .git, por lo que estamos en un repositorio de Git (también, el nombre del reto nos lo indica):
$ ls -a . .. .git flag.txt Podemos utilizar git log para mostrar commits anteriores (es decir, confirmaciones que son como guardados del proyecto a lo largo del tiempo):</description></item><item><title>Glory of the Garden</title><link>https://7rocky.github.io/ctf/picoctf/forensics/glory-of-the-garden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/glory-of-the-garden/</guid><description>Se nos proporciona una imagen JPEG llamada garden.jpg:
El archivo se reconoce correctamente como imagen JPEG:
$ file garden.jpg garden.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 2999x2249, components 3 Sin embargo, si mostramos las cadenas de caracteres imprimibles en el contenido del archivo, obtendremos la flag (se puede indicar la longitud de la cadena a mostrar):
$ strings -50 garden.</description></item><item><title>Gobustme 👻</title><link>https://7rocky.github.io/ctf/ctflearn/web/gobustme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/web/gobustme/</guid><description>Tenemos esta página web:
En la parte de abajo se indica el uso de gobuster con un diccionario de rutas llamado dirb/common.txt:
Como el reto sugiere, vamos a usar gobuster con dirb/common.txt:
$ gobuster dir -u https://gobustme.ctflearn.com -w $WORDLISTS/dirb/common.txt -q -r /call (Status: 200) [Size: 42] /carpet (Status: 200) [Size: 69] /flag (Status: 200) [Size: 15] /hide (Status: 200) [Size: 65] /index.html (Status: 200) [Size: 2712] /sex (Status: 200) [Size: 58] /shadow (Status: 200) [Size: 68] /skin (Status: 200) [Size: 120] Perfecto, vamos a /flag para conseguir la flag:</description></item><item><title>Gonna-Lift-Them-All</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/gonna-lift-them-all/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
fromCrypto.Util.numberimportbytes_to_long, getPrime importrandom FLAG=b'HTB{??????????????????????????????????????????????????????????????????????}' defgen_params(): p=getPrime(1024) g=random.randint(2, p-2) x=random.randint(2, p-2) h=pow(g, x, p) return(p, g, h), x defencrypt(pubkey): p, g, h=pubkey m=bytes_to_long(FLAG) y=random.randint(2, p-2) s=pow(h, y, p) return(g*y%p, m*s%p) defmain(): pubkey, privkey=gen_params() c1, c2=encrypt(pubkey) withopen('data.txt', 'w') asf: f.write(f'p = {pubkey[0]}\ng = {pubkey[1]}\nh = {pubkey[2]}\n(c1, c2) = ({c1}, {c2})\n') if__name__=="__main__": main() También tenemos la salida del script:
p = 163096280281091423983210248406915712517889481034858950909290409636473708049935881617682030048346215988640991054059665720267702269812372029514413149200077540372286640767440712609200928109053348791072129620291461211782445376287196340880230151621619967077864403170491990385250500736122995129377670743204192511487 g = 90013867415033815546788865683138787340981114779795027049849106735163065530238112558925433950669257882773719245540328122774485318132233380232659378189294454934415433502907419484904868579770055146403383222584313613545633012035801235443658074554570316320175379613006002500159040573384221472749392328180810282909 h = 36126929766421201592898598390796462047092189488294899467611358820068759559145016809953567417997852926385712060056759236355651329519671229503584054092862591820977252929713375230785797177168714290835111838057125364932429350418633983021165325131930984126892231131770259051468531005183584452954169653119524751729 (c1, c2) = (159888401067473505158228981260048538206997685715926404215585294103028971525122709370069002987651820789915955483297339998284909198539884370216675928669717336010990834572641551913464452325312178797916891874885912285079465823124506696494765212303264868663818171793272450116611177713890102083844049242593904824396, 119922107693874734193003422004373653093552019951764644568950336416836757753914623024010126542723403161511430245803749782677240741425557896253881748212849840746908130439957915793292025688133503007044034712413879714604088691748282035315237472061427142978538459398404960344186573668737856258157623070654311038584) Analizando operaciones matemáticas Vamos a expresar los pasos del cifrado en términos matemáticos:</description></item><item><title>Guessing Game 1</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-1/</guid><description>Se nos proporciona un binario estático de 64 bits llamado vuln
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.</description></item><item><title>Guessing Game 2</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/guessing-game-2/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Análisis de código estático Tenemos también el código fuente en C. Básicamente, lo que hace el programa es pedir un número, compararlo con otro aleatorio y si es el mismo, solicitar un nombre para mostrar un mensaje:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.</description></item><item><title>Gunship</title><link>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/gunship/</guid><description>Tenemos una página web con una interfaz bastante chula:
Solamente existe una entrada de usuario:
Se trata de una aplicación en Node.js que utiliza pug como motor de plantillas (como se muestra en los archivos disponibles del reto).
También utiliza flat para parsear los datos en JSON, como se muestra en el siguiente archivo llamado routes/index.js:
const path = require('path') const express = require('express') const pug = require('pug') const { unflatten } = require('flat') const router = express.</description></item><item><title>H1 Thermostat</title><link>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/h1-thermostat/</guid><description>Tenemos un archivo APK de Android llamado thermostat.apk:
$ file thermostat.apk thermostat.apk: Zip archive data, at least v0.0 to extract, compression method=deflate Como se muestram un archivo APK es solo un archivo ZIP. Por tanto, podemos extraer su contenido:
$ 7z x thermostat.apk Scanning the drive for archives: 1 file, 2595443 bytes (2535 KiB) Extracting archive: thermostat.apk -- Path = thermostat.apk Type = zip Physical Size = 2595443 Everything is Ok Files: 569 Size: 4968479 Compressed: 2595443 $ ls AndroidManifest.</description></item><item><title>Hackerman</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/hackerman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/hackerman/</guid><description>Se nos proporciona una imagen JPEG llamada hackerman.jpg:
$ file hackerman.jpg hackerman.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 960x540, components 3 Como es una imagen JPEG, podemos pensar en esteganografía usando steghide. Pero no parece que funcione de momento.
Si miramos los caracteres imprimibles de la imagen, veremos una cadena de texto que parece un hash MD5 (32 dígitos hexadecimales):</description></item><item><title>Hash the Filesystem</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/hash-the-filesystem/</guid><description>Se nos proporciona un código fuente que nos pide iniciar sesión y nos ofrece algunas funcionalidades. Esta es la función principal:
defchallenge(req): fnames=initializeDatabase() file_record['admin'] =[fnameforfnameinfnames] req.sendall(b'Super secret file server for malicious operations.\n'+ b'Who are you:\n'+b'&amp;gt; ') user=req.recv(4096).decode().strip() ifuser=='admin': req.sendall( b'Administrator can access the server only via ssh.\nGoodbye!\n') return token=json.dumps({'username': user, 'timestamp': str(time.time())}) file_record[user] =[] key=os.urandom(16) iv, token_ct=encrypt(key, token.encode()) req.sendall(b'Your token is: '+token_ct.encode() +b'\n') whileTrue: req.sendall( b'1. Upload a file.\n2. Available files.</description></item><item><title>Hello World!</title><link>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/hello-world/</guid><description>Se nos proporciona un binario de 64 bits llamado vulnerable:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Si ejecutamos el binario, parece que no hace nada:
$ ./vulnerable asdf fdsa 1 2 Si insertamos datos desde la entrada estándar (stdin), vemos que el programa funciona:
$ echo asdf | ./vulnerable Hello asdf ! Vamos a enviar 100 caracteres utilizando Python para ver si falla:</description></item><item><title>Here's a LIBC</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/heres-a-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/heres-a-libc/</guid><description>Se nos proporciona un binario de 64 bits llamado vuln y un archivo libc.so.6 como librería externa:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' Si ejecutamos el binario obtendremos una violación de segmento (segmentation fault):
$ chmod +x vuln $ ./vuln zsh: segmentation fault (core dumped) ./vuln Está configurado para utilizar Glibc desde el directorio actual:
$ ldd vuln linux-vdso.</description></item><item><title>Hextraordinary</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/hextraordinary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/hextraordinary/</guid><description>El reto nos presenta a ROXy, una codificadora que se especializa en códigos secretos con cifrados cortos y difíciles de descrifrar.
Se nos proporcionan estos valores en hexadecimal y sabemos que ella ha realizado algo para generar el código secreto:
0xc4115 0x4cf8 De hecho, el nombre ROXy es una pista porque está utilizando cifrado XOR. Si operamos estos números utilizando XOR, obtenemos el código secreto:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; hex(0xc4115 ^ 0x4cf8) '0xc0ded' Luego la flag es: CTFlearn{0xc0ded}.</description></item><item><title>Highlighter</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlighter/</guid><description>Se nos proporciona un binario llamado highlighter:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
intmain() { int__fd; longin_FS_OFFSET; undefined8 *where; undefined8 what; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setbuf(stdin, (char*) 0x0); setbuf(stdout, (char*) 0x0); __fd =open("flag.txt", 0); read(__fd, flag, 100); puts("Write what?"); __isoc99_scanf("%ld%*c", &amp;amp;what); puts("Where?"); __isoc99_scanf("%ld%*c", &amp;amp;where); *where =what; memset(flag, 0, 100); puts("</description></item><item><title>Highlights</title><link>https://7rocky.github.io/ctf/imaginaryctf/highlights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/highlights/</guid><description>Se nos proporciona un binario llamado highlights:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra, veremos el siguiente código descompilado de la función main:
intmain() { undefined8 *address; FILE *fp; setbuf(stdout, (char*) 0x0); setbuf(stdin, (char*) 0x0); fp =fopen("./flag.txt", "r"); __isoc99_fscanf(fp, "%s", flag); printf("What address (in hex) would you like to read?\n&amp;gt;&amp;gt;&amp;gt; "); __isoc99_scanf("%lx%c", &amp;amp;address, &amp;amp;dead); printf("Value at 0x%x: %016lx\n"</description></item><item><title>Hope you know JS</title><link>https://7rocky.github.io/ctf/other/hope-you-know-js/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hope-you-know-js/</guid><description>Se nos proporciona un código JavaScript ofuscado llamado good-luck.js. Al ejecutarlo en un documento HTML sencillo, muestra una ventana para validar la flag:
&amp;lt;!doctypehtml&amp;gt; &amp;lt;htmllang="en"&amp;gt; &amp;lt;head&amp;gt; &amp;lt;metacharset="UTF-8"&amp;gt; &amp;lt;title&amp;gt;Hope you know JS&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;scriptsrc="good-luck.js"&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Haciendo uso del formateador Prettier en Visual Studio Code, pude encontrar patrones que se repetían a lo largo del código. Por ejemplo, empezé a sustituir expresiones como +!![] o ![] por sus valores finales.</description></item><item><title>How The Columns Have Turned</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/how-the-columns-have-turned/</guid><description>Se nos proporciona un código en Python para cifrar la flag (source.py), y también tenemos dialog.txt y encrypted_messages.txt:
importos withopen('super_secret_messages.txt', 'r') asf: SUPER_SECRET_MESSAGES=[msg.strip() formsginf.readlines()] defderiveKey(key): derived_key=[] fori, charinenumerate(key): previous_letters=key[:i] new_number=1 forj, previous_charinenumerate(previous_letters): ifprevious_char&amp;gt;char: derived_key[j] +=1 else: new_number+=1 derived_key.append(new_number) returnderived_key deftranspose(array): return[rowforrowinmap(list, zip(*array))] defflatten(array): return"".join([iforsubinarrayforiinsub]) deftwistedColumnarEncrypt(pt, key): derived_key=deriveKey(key) width=len(key) blocks=[pt[i:i+width] foriinrange(0, len(pt), width)] blocks=transpose(blocks) ct=[blocks[derived_key.index(i+1)][::-1] foriinrange(width)] ct=flatten(ct) returnct classPRNG: def__init__(self, seed): self.p=0x2ea250216d705 self.a=self.p self.b=int.from_bytes(os.urandom(16), 'big') self.rn=seed defnext(self): self.rn=((self.a*self.rn) +self.b) %self.p returnself.rn defmain(): seed=int.</description></item><item><title>HTB Console</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/htb-console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/htb-console/</guid><description>Se nos proporciona un binario de 64 bits llamado htb-console:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Ingeniería inversa Si usamos Ghidra, veremos la siguiente función main:
voidmain() { charcommand[16]; setup(); puts("Welcome HTB Console Version 0.1 Beta."); do{ printf("&amp;gt;&amp;gt; "); fgets(command, 16, stdin); console(command); memset(command, 0, 16); } while(true); } El código anterior solamente pide datos al usuario y los pasa a console:</description></item><item><title>HyperStream Test #2</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/hyperstream-test-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/hyperstream-test-2/</guid><description>Se nos proporciona este texto con solo letras A y B:
ABAAAABABAABBABBAABBAABAAAAAABAAAAAAAABAABBABABBAAAAABBABBABABBAABAABABABBAABBABBAABB El reto dice que huele a bacon. De hecho, existe el Cifrado Bacon y podemos usarlo para descifrar el texto en CyberChef:
Y la flag es: CTFlearn{ILOUEBACONDONTYOU}.</description></item><item><title>IMC 1999, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-1999/</guid><description> getProblemPdf('es', '1999', '1')</description></item><item><title>IMC 1999, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-1999/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-1999/</guid><description> getProblemPdf('es', '1999', '7')</description></item><item><title>IMC 2000, Problema 3</title><link>https://7rocky.github.io/imc/problem-3-2000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-3-2000/</guid><description> getProblemPdf('es', '2000', '3')</description></item><item><title>IMC 2004, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-2004/</guid><description> getProblemPdf('es', '2004', '7')</description></item><item><title>IMC 2004, Problema 8</title><link>https://7rocky.github.io/imc/problem-8-2004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-8-2004/</guid><description> getProblemPdf('es', '2004', '8')</description></item><item><title>IMC 2005, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2005/</guid><description> getProblemPdf('es', '2005', '1')</description></item><item><title>IMC 2005, Problema 8</title><link>https://7rocky.github.io/imc/problem-8-2005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-8-2005/</guid><description> getProblemPdf('es', '2005', '8')</description></item><item><title>IMC 2006, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2006/</guid><description> getProblemPdf('es', '2006', '1')</description></item><item><title>IMC 2007, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-2007/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-2007/</guid><description> getProblemPdf('es', '2007', '7')</description></item><item><title>IMC 2010, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2010/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2010/</guid><description> getProblemPdf('es', '2010', '1')</description></item><item><title>IMC 2012, Problema 2</title><link>https://7rocky.github.io/imc/problem-2-2012/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-2-2012/</guid><description> getProblemPdf('es', '2012', '2')</description></item><item><title>IMC 2013, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2013/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2013/</guid><description> getProblemPdf('es', '2013', '1')</description></item><item><title>IMC 2013, Problema 6</title><link>https://7rocky.github.io/imc/problem-6-2013/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-6-2013/</guid><description> getProblemPdf('es', '2013', '6')</description></item><item><title>IMC 2017, Problema 6</title><link>https://7rocky.github.io/imc/problem-6-2017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-6-2017/</guid><description> getProblemPdf('es', '2017', '6')</description></item><item><title>IMC 2018, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2018/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2018/</guid><description> getProblemPdf('es', '2018', '1')</description></item><item><title>IMC 2019, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2019/</guid><description> getProblemPdf('es', '2019', '1')</description></item><item><title>IMC 2019, Problema 2</title><link>https://7rocky.github.io/imc/problem-2-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-2-2019/</guid><description> getProblemPdf('es', '2019', '2')</description></item><item><title>IMC 2019, Problema 5</title><link>https://7rocky.github.io/imc/problem-5-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-5-2019/</guid><description> getProblemPdf('es', '2019', '5')</description></item><item><title>IMC 2019, Problema 7</title><link>https://7rocky.github.io/imc/problem-7-2019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-7-2019/</guid><description> getProblemPdf('es', '2019', '7')</description></item><item><title>IMC 2020, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2020/</guid><description> getProblemPdf('es', '2020', '1')</description></item><item><title>IMC 2020, Problema 2</title><link>https://7rocky.github.io/imc/problem-2-2020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-2-2020/</guid><description> getProblemPdf('es', '2020', '2')</description></item><item><title>IMC 2021, Problema 1</title><link>https://7rocky.github.io/imc/problem-1-2021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/imc/problem-1-2021/</guid><description> getProblemPdf('es', '2021', '1')</description></item><item><title>Infinite Descent</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/infinite-descent/</guid><description>Se nos proporciona un código en Python que implementa RSA de forma extraña (fastprimes.py):
#!/usr/bin/env python #********************************************************************** # filename: fasterprimes.py # version: 0.06.2-alpha # release date: 20170806 # dev: Cayce Pollard # qa: NOT PASSED, open defects. # finds a specified length prime, then a neighbouring prime for speed. # DEFECTS # ID[243], category A4, owner: CayceP, comment: may have to be run several times to generate valid RSA values # ID[552], category A9, owner: AppSec, comment: Doneighbouring primes present a security risk?</description></item><item><title>information</title><link>https://7rocky.github.io/ctf/picoctf/forensics/information/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/information/</guid><description>Se nos proporciona una imagen JPEG llamada cat.jpg:
El archivo se reconoce como imagen JPEG:
$ file cat.jpg cat.jpg: JPEG image data, JFIF standard 1.02, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 2560x1598, components 3 Sin embargo, si extraemos los metadatos del archivo, veremos algo curioso:
$ exiftool cat.jpg ExifTool Version Number : 12.30 File Name : cat.jpg Directory : . File Size : 858 KiB File Modification Date/Time : File Access Date/Time : File Inode Change Date/Time : File Permissions : -rw-r--r-- File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.</description></item><item><title>Insane Bolt</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/insane-bolt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/insane-bolt/</guid><description>Tenemos este juego:
$ nc 206.189.125.243 30182 1. Instructions 2. Play &amp;gt; 1 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 🔩 [*] Help the 🤖 reach the 💎. 🔩 🔩 [*] You need to find the shortest route. 🔩 🔩 [*] You need to collect 500 💎 and at least 5000 🔩.</description></item><item><title>Insp3ct0r</title><link>https://7rocky.github.io/ctf/picoctf/web-exploitation/insp3ct0r/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/web-exploitation/insp3ct0r/</guid><description>Se nos proporciona una página web como esta:
Como sugiere la página, tenemos que inspeccionar el código HTML de la página web (atajo: Ctrl + U):
Podemos ver un trozo de la flag. Vamos a inspeccionar el archivo CSS (mycss.css):
Genial, tenemos otra pieza. Vamos a echar un vistazo al archivo JS (myjs.js):
Perfecto, podemos juntar todas las piezas y formar la flag: picoCTF{tru3_d3t3ct1ve_0r_ju5t_lucky?f10be399}.</description></item><item><title>Intergalactic Post</title><link>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/intergalactic-post/</guid><description>Se nos proporciona una aplicación web en PHP con una única funcionalidad, que es poner un email en un formulario.
Empezamos analizando el código fuente. El archivo index.php muestra que solo hay dos rutas (GET y POST):
&amp;lt;?php spl_autoload_register(function ($name){ if (preg_match('/Controller$/', $name)) { $name = "controllers/${name}"; } else if (preg_match('/Model$/', $name)) { $name = "models/${name}"; } include_once "${name}.php"; }); $database = new Database('/tmp/challenge.db'); $router = new Router(); $router-&amp;gt;new('GET', '/', 'IndexController@index'); $router-&amp;gt;new('POST', '/subscribe', 'SubsController@store'); die($router-&amp;gt;match()); Vemos que Database.</description></item><item><title>Jeeves</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/jeeves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/jeeves/</guid><description>Se nos proporciona un binario de 64 bits llamado jeeves:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Podemos usar Ghidra para analizar el binario y echar un vistazo al código en C descompilado. Este es el main:
intmain() { charname[44]; intfd; void*data; uintcode; code =0xdeadc0d3; printf("Hello, good sir!\nMay I have your name? "); gets(name); printf("Hello %s, hope you have a good day!</description></item><item><title>Jenny From The Block</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/jenny-from-the-block/</guid><description>Se nos proporciona este código fuente en Python:
fromhashlibimportsha256 fromCrypto.Util.Paddingimportpad, unpad importsignal importsubprocess importsocketserver importos allowed_commands=[b'whoami', b'ls', b'cat secret.txt', b'pwd'] BLOCK_SIZE=32 defencrypt_block(block, secret): enc_block=b'' foriinrange(BLOCK_SIZE): val=(block[i]+secret[i]) %256 enc_block+=bytes([val]) returnenc_block defencrypt(msg, password): h=sha256(password).digest() iflen(msg) %BLOCK_SIZE!=0: msg=pad(msg, BLOCK_SIZE) blocks=[msg[i:i+BLOCK_SIZE] foriinrange(0, len(msg), BLOCK_SIZE)] ct=b'' forblockinblocks: enc_block=encrypt_block(block, h) h=sha256(enc_block+block).digest() ct+=enc_block returnct.hex() defrun_command(cmd): ifcmdinallowed_commands: try: resp=subprocess.run( cmd.decode().split(' '), capture_output=True) output=resp.stdout returnoutput except: returnb'Something went wrong!\n' else: returnb'Invalid command!\n' defchallenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.</description></item><item><title>Lazy Game Challenge</title><link>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/lazy-game-challenge/</guid><description>Se nos proporciona un servicio que consiste en un sistema de apuestas. Tenemos que apostar una cierta cantidad de dinero y luego adivinar un número entre 1 y 10 en menos de 10 intentos. Por ejemplo:
$ nc thekidofarcrania.com 10001 Welcome to the Game of Luck !. Rules of the Game : (1) You will be Given 500$ (2) Place a Bet (3) Guess the number what computer thinks of !</description></item><item><title>Leet Test</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/leet-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/leet-test/</guid><description>Se nos proporciona un binario de 64 bits llamado leet_test:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Si lo abrimos en Ghidra, veremos el siguiente código descompilado en C:
uintwinner =0xcafebabe; voidmain() { longin_FS_OFFSET; uintrandom; inturandom_fd; intflag_fd; void*flag; charname[280]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); initialize(); urandom_fd =open("/dev/urandom", 0); read(urandom_fd, &amp;amp;random, 4); close(urandom_fd); random =random &amp;amp;0xffff; while(true) { printf("Welcome to HTB!\nPlease enter your name: "</description></item><item><title>Letter Dispair</title><link>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/letter-dispair/</guid><description>Se nos proporciona la siguiente página web:
Muestra un listado de directorio. Si vamos a /mailer.php veremos esta página para enviar correos:
El archivo mailer.zip contiene el código fuente de mailer.php. Es bastante largo como para ponerlo aquí.
La clave está en que utiliza PHPMailer, que es vulnerable a CVE-2016-10033 y CVE-2016-10045. De hecho, existen exploits públicos como el que aparece en www.exploit-db.com.
Básicamente, el exploit dice que pongamos este payload como nuestro correo:</description></item><item><title>Login Please</title><link>https://7rocky.github.io/ctf/imaginaryctf/login-please/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/login-please/</guid><description>Tenemos que iniciar sesión aquí: http://puzzler7.imaginaryctf.org:5001/:
Si inspeccionamos el código HTML de la página, veremos un comentario que apunta a /source:
Ahora tenemos el código fuente del servidor:
constexpress=require('express') constcrypto=require('crypto') functionmd5(text) { returncrypto.createHash('md5').update(text).digest('hex') } constapp=express() constusers={ guest: '084e0343a0486ff05530df6c705c8bb4', admin: '21232f297a57a5a743894a0e4a801fc3', '1337hacker': '2ab96390c7dbe3439de74d0c9b0b1767' } constlocalIPs=['127.0.0.1', '::1', '::ffff:127.0.0.1'] app.use(express.urlencoded({ extended: false})) app.use(express.json()) app.get('/', (req, res) =&amp;gt;{ res.send(` &amp;lt;form action="https://7rocky.github.io/login" method="POST"&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="username"&amp;gt;Username: &amp;lt;/label&amp;gt; &amp;lt;input name="username" type="text" id="username"&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;label for="password"&amp;gt;Password: &amp;lt;/label&amp;gt; &amp;lt;input name="</description></item><item><title>Lookey here</title><link>https://7rocky.github.io/ctf/picoctf/forensics/lookey-here/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/lookey-here/</guid><description>Se nos proporciona un archivo de texto grande llamado anthem.flag.txt:
$ wc -l anthem.flag.txt 2146 anthem.flag.txt 2146 son muchas líneas para buscar la flag a ojo. En su lugar, podemos usar grep para encontrar la flag, ya que tienen un formato común (picoCTF{...}):
$ grep picoCTF anthem.flag.txt we think that the men of picoCTF{gr3p_15_@w3s0m3_4c479940}</description></item><item><title>looking glass</title><link>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/looking-glass/</guid><description>Se nos proporciona esta página web:
La funcionalidad que tiene es usar el comando ping:
El problema puede estar relacionado con inyección de comandos, porque probablemente el servidor hace algo como:
&amp;lt;?php $cmd ='ping -c 4 '.$_POST['ip_address']; system($cmd); A lo mejor no en PHP, pero el concepto es el mismo. Por tanto, podemos probar a poner un punto y coma e inyectar otro comando de sistema (; id):
Ahí está, el servidor es vulnerable a inyección de comandos, que deriva en ejecución remota de comandos (RCE).</description></item><item><title>Lost Flag</title><link>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/lost-flag/</guid><description>Se nos proporciona un archivo ZIP llamado flag.zip que contiene una imagen JPEG y también un archivo llamado .DS_Store, que es un archivo temporal que aparece en máquinas macOS:
$ file flag.zip flag.zip: Zip archive data, at least v2.0 to extract, compression method=store $ unzip -v flag.zip Archive: flag.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 07-03-2022 05:49 00000000 flag/ 86710 Defl:N 86391 0% 07-03-2022 05:29 a0cfb753 flag/flag.</description></item><item><title>Maze</title><link>https://7rocky.github.io/ctf/overthewire/maze/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/overthewire/maze/</guid><description>Este laboratorio sirve para practicar técnicas de explotación, programación e ingeniería inversa. El laboratorio consta de 9 niveles, en una arquitectura Linux/x86 (todas las protecciones están deshabilitadas: NX, PIE, canarios e incluso ASLR).
Para conectarse al primer nivel, se nos proporcionan las credenciales de SSH para el usuario maze0.
Realizando un reconocimiento inicial, la máquina nos muestra que hay binarios SUID que deben ser explotados para pasar al siguiente nivel. Además, tenemos algunos archivos que contienen las contraseñas de los usuarios mazeX:</description></item><item><title>Micro-CMS v1</title><link>https://7rocky.github.io/ctf/hacker101ctf/micro-cms-v1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/micro-cms-v1/</guid><description>Tenemos una página web sencilla que nos permite editar y crear artículos en Markdown:
Vamos a pinchar en &amp;ldquo;Testing&amp;rdquo;:
Ahora, podemos intentar editar el artículo actual. Se nos muestra una caja de texto para escribir el código Markdown ahí:
Markdown es un lenguaje de marcado similar a HTML pero más sencillo. Además, Markdown soporta el uso de etiquetas HTML. Por tanto, podemos intentar a poner un payload de Cross-Site Scripting (XSS) como este:</description></item><item><title>Milkshake</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/milkshake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/milkshake/</guid><description>Se nos proporciona un archivo MP3 llamado Milkshake.mp3. Podemos echar un vistazo a las cadenas de caracteres imprimibles o los metadatos:
$ file Milkshake.mp3 Milkshake.mp3: Audio file with ID3 version 2.4.0, extended header, contains:MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, JntStereo $ strings -20 Milkshake.mp3 The Neptunes Present-Clones-ADTRCK 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CCOMM 000007A5 000006CA 00007311 000075EA 0001A567 0001A567 00008000 00008000 0000005C 0000005CTPE1 Chad Hugo/Pharrell Williams !</description></item><item><title>mixup</title><link>https://7rocky.github.io/ctf/imaginaryctf/mixup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/mixup/</guid><description>Se nos proporciona un archivo flag.txt que contiene algunos caracteres Unicode. Este es el volcado hexadecimal del archivo:
$ xxd flag.txt 00000000: 69e2 808e 63e2 80ae 74e2 808e 66e2 80ae i...c...t...f... 00000010: 7be2 808e e280 8e75 6e31 6330 e280 ae64 {......un1c0...d 00000020: 655f 6de2 80ae 3467 3163 5f6e 61e2 808e e_m...4g1c_na... 00000030: e280 ae68 e280 8e73 e280 ae64 e280 ae66 ...h...s...d...f 00000040: 6fe2 80ae e280 8e61 7369 e280 8e68 e280 o.</description></item><item><title>Mod 26</title><link>https://7rocky.github.io/ctf/picoctf/cryptography/mod-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/cryptography/mod-26/</guid><description>Se nos proporciona un mensaje cifrado:
cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_GYpXOHqX} Vemos que el mensaje tiene más o menos el formato de una flag de picoCTF (picoCTF{...}), ya que hay 4 letras minúsculas y 3 mayúsculas antes de {, y termina con }. Además, también hay varios _.
Parece claro que el algoritmo de cifrado utilizado es de sustitución (cifrado César). El algoritmo más común es ROT13. Utilizando CyberChef, podemos descifrar el mensaje utilizando ROT13 y ver la flag:</description></item><item><title>Model E1337 - Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-rolling-code-lock/</guid><description>Tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y, después de unos segundos, veremos que es incorrecto:
No hay nada en el código fuente de la página. En este punto, podemos aplicar fuzzing para enumerar más rutas existentes:
$ ffuf -w $WORDLISTS/dirbuster/directory-list-2.3-medium.txt -u http://35.190.155.168/c33a5d03b6/FUZZ admin [Status: 200, Size: 287, Words: 25, Lines: 11] unlock [Status: 405, Size: 178, Words: 20, Lines: 5] [Status: 200, Size: 302, Words: 16, Lines: 13] Existe una ruta /admin:</description></item><item><title>Model E1337 v2 - Hardened Rolling Code Lock</title><link>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/hacker101ctf/model-e1337-v2-hardened-rolling-code-lock/</guid><description>Este reto está muy relacionado a Model E1337 - Rolling Code Lock, especialmente en la parte de criptoanálisis. Se recomienda leerlo si no se ha hecho antes.
Como en el reto anterior, tenemos una simple página web que solicita un código para desbloquear:
Podemos poner cualquier número y veremos que es incorrecto:
La diferencia con el primer reto es la longitud del número, esta vez es de 64 bits.
Deberíamos de tener el código fuente en Python para realizar el proceso de criptoanálisis.</description></item><item><title>Morse Code</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/morse-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/morse-code/</guid><description>Se nos proporciona esta ristra de . y -:
-.-. - ..-. .-.. . .- .-. -. ... .- -- ..- . .-.. -- --- .-. ... . .. ... -.-. --- --- .-.. -... -.-- - .... . .-- .- -.-- .. .-.. .. -.- . -.-. .... . . ... Como sugiere el título del reto, se trata de código Morse. Por tanto, tenemos que decodificarlo.
Esto lo podemos hacer manualmente: -.</description></item><item><title>Mutation Lab</title><link>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/mutation-lab/</guid><description>Se nos proporciona una página web como esta:
Nos tenemos que registrar e iniciar sesión para ver un dashboard chulo:
La única funcionalidad que tenemos es la de exportar las imágenes SVG que vemos como archivos PNG. Podemos capturar la petición con Burp Suite:
Después de un poco de investigación, podemos ver que hay una vulnerabilidad en la conversión de SVG que deriva en lectura de archivos locales (más información en security.</description></item><item><title>Nice netcat...</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/nice-netcat.../</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/nice-netcat.../</guid><description>Se nos proporciona un nombre de dominio y un puerto para una instancia remota. Si nos conectamos utilizando nc, nos envía una lista de números:
$ nc mercury.picoctf.net 22902 112 105 99 111 67 84 70 123 103 48 48 100 95 107 49 116 116 121 33 95 110 49 99 51 95 107 49 116 116 121 33 95 100 51 100 102 100 54 100 102 125 10 ^C Estos números parece que son la representación en ASCII decimal de algunos caracteres.</description></item><item><title>Notepad as a Service</title><link>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/notepad-as-a-service/</guid><description>Se nos proporciona un binario de 64 bits llamado notepad:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, veremos la función main:
voidmain() { setbuf(stdout, (char*) 0x0); do{ notepad(); } while(true); } Básicamente, ejecuta notepad de forma infinita:
voidnotepad() { longin_FS_OFFSET; charoption; inti; undefined notes[136]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); for(i =0; i &amp;lt;128; i =i +1) { notes[i] =0; } puts("</description></item><item><title>Obedient Cat</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/obedient-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/obedient-cat/</guid><description>En este reto se nos da un archivo. El contenido de este archivo es la flag:
$ cat flag picoCTF{s4n1ty_v3r1f13d_28e8376d}</description></item><item><title>One Step Closer</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/one-step-closer/</guid><description>Se nos proporciona el código fuente en Python para cifrar la flag, y una aplicación Flask que llama a la función de cifrado:
fromCrypto.Util.numberimportlong_to_bytes, bytes_to_long, getPrime, inverse importrandom FLAG=b'HTB{--REDACTED--}' p=getPrime(1024) q=getPrime(1024) n=p*q e=257 defencrypt_flag(): a=random.getrandbits(1024) b=random.getrandbits(1024) flag=bytes_to_long(FLAG) msg=a*flag+b ct=pow(msg, e, n) return{'ct': format(ct, 'x'), 'n': format(n, 'x'), 'e': format(e, 'x'), 'a': format(a, 'x'), 'b': format(b, 'x')} fromflaskimport* fromchallimportencrypt_flag app=Flask(__name__) @app.route('/', methods=['GET']) defindex(): returnrender_template('index.html') @app.route('/api/get_flag', methods=['GET']) defget_flag(): payload=encrypt_flag() returnjsonify(payload) if__name__=='__main__': app.</description></item><item><title>Personalized</title><link>https://7rocky.github.io/ctf/imaginaryctf/personalized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/personalized/</guid><description>Se nos proporciona el código fuente en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* fromrandomimportseed, getrandbits m=bytes_to_long(open('flag.txt', 'rb').read()) print("What's your name?\n&amp;gt;&amp;gt;&amp;gt; ", end='') name=open(0, 'rb').readline().strip() seed(bytes_to_long(name)) e=2*getrandbits(32)+1 p=getPrime(512) q=getPrime(512) n=p*q c=pow(m, e, n) print(f"Here's your flag, {''.join(chr(i) foriinname)}!") print(f'{n= }') print(f'{e= }') print(f'{c= }') Utiliza una implementación de RSA en la que podemos proporcionar un nombre que será usado como semilla de un Generador de Números Pseudo-Aleatorios (PRNG, Pseudo-Random Number Generator).</description></item><item><title>Pickle</title><link>https://7rocky.github.io/ctf/imaginaryctf/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pickle/</guid><description>Se nos proporciona un archivo llamado out.pickle. La flag está almacenada dentro, podemos visualizar su contenido en hexadecimal:
$ xxd out.pickle 00000000: 8004 958c 0000 0000 0000 008c 085f 5f6d .............__m 00000010: 6169 6e5f 5f94 8c0b 466c 6167 5072 696e ain__...FlagPrin 00000020: 7465 7294 9394 2981 947d 9428 8c04 666c ter...)..}.(..fl 00000030: 6167 945d 9428 4b69 4b63 4b74 4b66 4b7b ag.].(KiKcKtKfK{ 00000040: 4b63 4b75 4b63 4b75 4b6d 4b62 4b65 4b72 KcKuKcKuKmKbKeKr 00000050: 4b73 4b5f 4b6f 4b72 4b5f 4b70 4b69 4b63 KsK_KoKrK_KpKiKc 00000060: 4b6b 4b6c 4b65 4b73 4b3f 4b7d 658c 0466 KkKlKeKsK?</description></item><item><title>PIN</title><link>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/pin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/pin/</guid><description>Se nos proporciona un binario llamado rev1:
$ file rev1 rev1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5f9af621b132c2028d8e689cbb5b707f3f3cd28, not stripped Si lo ejecutamos, el programa espera un PIN:
$ ./rev1 Masukan PIN = 1234 PIN salah ! Vamos a depurarlo con GDB y a mostrar el código ensamblador del main:
$ gdb -q rev1 Reading symbols from rev1... (No debugging symbols found in rev1) gef➤ disassemble main Dump of assembler code for function main: 0x00000000004005d6 &amp;lt;+0&amp;gt;: push rbp 0x00000000004005d7 &amp;lt;+1&amp;gt;: mov rbp,rsp 0x00000000004005da &amp;lt;+4&amp;gt;: sub rsp,0x10 0x00000000004005de &amp;lt;+8&amp;gt;: lea rdi,[rip+0xdf] # 0x4006c4 0x00000000004005e5 &amp;lt;+15&amp;gt;: mov eax,0x0 0x00000000004005ea &amp;lt;+20&amp;gt;: call 0x4004a0 &amp;lt;printf@plt&amp;gt; 0x00000000004005ef &amp;lt;+25&amp;gt;: lea rax,[rbp-0x4] 0x00000000004005f3 &amp;lt;+29&amp;gt;: mov rsi,rax 0x00000000004005f6 &amp;lt;+32&amp;gt;: lea rdi,[rip+0xd6] # 0x4006d3 0x00000000004005fd &amp;lt;+39&amp;gt;: mov eax,0x0 0x0000000000400602 &amp;lt;+44&amp;gt;: call 0x4004b0 &amp;lt;__isoc99_scanf@plt&amp;gt; 0x0000000000400607 &amp;lt;+49&amp;gt;: mov eax,DWORD PTR [rbp-0x4] 0x000000000040060a &amp;lt;+52&amp;gt;: mov edi,eax 0x000000000040060c &amp;lt;+54&amp;gt;: call 0x4005b6 &amp;lt;cek&amp;gt; 0x0000000000400611 &amp;lt;+59&amp;gt;: test eax,eax 0x0000000000400613 &amp;lt;+61&amp;gt;: je 0x400623 &amp;lt;main+77&amp;gt; 0x0000000000400615 &amp;lt;+63&amp;gt;: lea rdi,[rip+0xba] # 0x4006d6 0x000000000040061c &amp;lt;+70&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x0000000000400621 &amp;lt;+75&amp;gt;: jmp 0x40062f &amp;lt;main+89&amp;gt; 0x0000000000400623 &amp;lt;+77&amp;gt;: lea rdi,[rip+0xba] # 0x4006e4 0x000000000040062a &amp;lt;+84&amp;gt;: call 0x400490 &amp;lt;puts@plt&amp;gt; 0x000000000040062f &amp;lt;+89&amp;gt;: mov eax,0x0 0x0000000000400634 &amp;lt;+94&amp;gt;: leave 0x0000000000400635 &amp;lt;+95&amp;gt;: ret End of assembler dump.</description></item><item><title>Poor Login</title><link>https://7rocky.github.io/ctf/ctflearn/binary/poor-login/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/poor-login/</guid><description>Se nos proporciona un binario de 64 bits llamado login:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled También tenemos el código fuente en C:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int menu() { printf("*** WINBLOWS LOGIN *********\n" "1. Login into user.\n" "2. Sign out.\n" "3. Print flag.\n" "4. Lock user.\n" "5. Restore user.\n" "&amp;gt; "); int resp = 0; scanf("%d", &amp;amp;resp); while (getchar() !</description></item><item><title>POST Practice</title><link>https://7rocky.github.io/ctf/ctflearn/web/post-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/web/post-practice/</guid><description>El reto pide que nos autentiquemos en una URL dada mediante una petición POST.
Primero de todo, vamos a realizar una petición GET para ver si nos dan las credenciales, utilizando curl:
$ curl http://165.227.106.113/post.php &amp;lt;h1%gt;This site takes POST data that you have not submitted!&amp;lt;/h1&amp;gt;&amp;lt;!-- username: admin | password: 71urlkufpsdnlkadsf --&amp;gt; Y aquí las tenemos. Ahora solamente tenemos que usar una petición POST con esta información. Si usamos -d en curl para poner el cuerpo de la petición, el método de la petición se pone por defecto en POST, por lo que no es necesario indicar -X POST:</description></item><item><title>pqqp</title><link>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/pqqp/</guid><description>Se nos proporciona este código en Python que cifra la flag:
fromCrypto.Util.numberimport* p=getPrime(1024) q=getPrime(1024) n=p*q e=65537 m=bytes_to_long(open("flag.txt", "rb").read().strip()) c=pow(m, e, n) pqqp=(pow(p, q, n) +pow(q, p, n)) %n print(f"{n= }") print(f"{e= }") print(f"{c= }") print(f"{pqqp= }") Y tenemos el archivo output.txt:
n = 19678109133542698592305708016218863883460540049917712329432013892172528110292745184992950044286234053071380305255840348326164548510255147118470308166391801316954651278311516797693549738950638924838729113122082201649970553380521265027078990142823602788816122841173521655481024888439982252740049512798598085061773695717897738054691150959372485365062487195925100664710335322057804378500514036943988819273662050112952925141139754952427282840502980857190361170607335143494354546987865462698409956206631411308141753183566771545343693446609738596094372008339052131415140340456565555396933183573996686236769224009352680776141 e = 65537 c = 4072247787644405517693225466780406787448185227848467266590680538951503737695652776519815815044794587161578707809819763441075707137469351267404539758695849074266727221320662086207093016080297854717488042255308770890593983978724257303414642859978484084458380098954259220304333391581145689059564973907676661078965777905977665249069877734867259119271333543347675967002480182290529431802723432351160734165536930587939120516653618367482414081000718254774375447568464759357446892747598177493342245946293460645987948522541784101210339329312458616738544161953857715180345325332187115407714964472659039920532267119264418919947 pqqp = 286274681617083968101800572253589724107707315933733496895870570711787172051691156975540599189839527166581986519156360694553593020374681020209511667035419131460916677948315029070571749042370272329205309015536090768801019566664262350433731622252363771741528214379501493482631649996976367966453784254842455722642 En primer lugar, tenemos que expresar $p^q + q^p \pmod{n}$ de otra manera.
Por el Pequeño Teorema de Fermat, tenemos que:</description></item><item><title>Practice Flag</title><link>https://7rocky.github.io/ctf/ctflearn/miscellaneous/practice-flag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/miscellaneous/practice-flag/</guid><description>Este reto es solamente una introducción. La flag se muestra directamente: CTFlearn{4m_1_4_r3al_h4ck3r_y3t}.</description></item><item><title>Pusheen Loves Graphs</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/pusheen-loves-graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/pusheen-loves-graphs/</guid><description>Se nos proporciona un archivo binario llamado Pusheen. Si lo ejecutamos, veremos un dibujo de un gato:
$ ./Pusheen ▐▀▄ ▄▀▌ ▄▄▄▄▄▄▄ ▌▒▒▀▄▄▄▄▀▒▒▐▄▀▀▒██▒██▒▀▀▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▄▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄ ▀█▒▒█▌▒▒█▒▒▐█▒▒▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▀▌▒▒▒▒▒▀▒▀▒▒▒▒▒▀▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▄▄ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌▄█▒█ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▒█▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▀ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌ ▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐ ▐▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▌ ▀▄▄▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀▀▀▀▀▀▄▄▀ Si miramos las cadenas de caracteres imprimibles, vemos que hay muchas que empiezan por e_ (de hecho, hay desde e_0_0 hasta e_66_100). Podemos contarlas de esta manera:
$ strings Pusheen | wc -l 6767 Estas cadenas de caracteres pueden ser nombres de funciones, ya que el binario no ha sido despojado de sus símbolos:</description></item><item><title>QR Code</title><link>https://7rocky.github.io/ctf/ctflearn/miscellaneous/qr-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/miscellaneous/qr-code/</guid><description>Se nos proporciona una imagen que contiene un código QR:
Si lo escaneamos, tendremos la siguiente cadena de caracteres:
c3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI= Parece que está codificada en Base64, vamos a tratar de decodificarla:
$ echo c3ludCB2ZiA6IGEwX29icWxfczBldHJnX2RlX3BicXI= | base64 -d synt vf : a0_obql_s0etrg_de_pbqr Pero no vemos nada legible. Parece que se está utilizando un algoritmo de sustitución como ROT13. Vayamos a CyberChef para comprobarlo:
Vemos: &amp;ldquo;flag is : n0_body_f0rget_qr_code&amp;rdquo;, por lo que la flag es: CTFlearn{n0_body_f0rget_qr_code}.</description></item><item><title>Rebuilding</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/rebuilding/</guid><description>Se nos proporciona un binario llamado rebuilding:
$ file rebuilding rebuilding: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c7a145f3a4b213cf895a735e2b26adffc044c190, not stripped Si lo ejecutamos, nos pide poner un argumento de línea de comandos:
$ ./rebuilding Preparing secret keys Missing required argument Vamos a abrirlo en Ghidra para descompilarlo. Esta es la función main:
undefined8 main(intargc, longargv) { int__c; size_tlength; undefined8 ret; intchecks; inti; intj; if(argc !</description></item><item><title>Red Island</title><link>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/red-island/</guid><description>Tenemos una página web como esta:
Podemos registrar una nueva cuenta e iniciar sesión para ver la siguiente funcionalidad:
Esta vez no tenemos el código fuente de la aplicación web, por lo que tendremos que encontrar una vulnerabilidad clara o encontrar el código fuente de alguna manera.
Podemos comenzar a pensar en Server-Side Request Forgery (SSRF). Como en otros retos, sabemos que el servidor web escucha en el puerto 1337, por lo que vamos a probar http://127.</description></item><item><title>Redaction gone wrong</title><link>https://7rocky.github.io/ctf/picoctf/forensics/redaction-gone-wrong/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/redaction-gone-wrong/</guid><description>Se nos proporciona un archivo PDF llamado Financial_Report_for_ABC_Labs.pdf. Este muestra algo de texto:
Pero vemos que hay palabras que se han ocultado utilizando una especie de &amp;ldquo;color de fondo&amp;rdquo; negro. Sin embargo, podemos usar el ratón para selecctionar el texto, y ahí está la flag:
Financial Report for ABC Labs, Kigali, Rwanda for the year 2021. Breakdown - Just painted over in MS word. Cost Benefit Analysis Credit Debit This is not the flag, keep looking Expenses from the picoCTF{C4n_Y0u_S33_m3_fully} Redacted document.</description></item><item><title>Reflection</title><link>https://7rocky.github.io/ctf/imaginaryctf/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/reflection/</guid><description>Se nos proporciona un archivo binario llamado reflection:
$ file reflection reflection: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d57b0acdb0fda3fe599c48fa63ca61e7694b8b60, for GNU/Linux 3.2.0, not stripped Si abrimos Ghidra y echamos un vistazo al código fuente en C descompilado, veremos la función main:
undefined8 main() { longj; char*__format; byte flag_input[100]; intk; int_j; int_length; inti; intlength; printf("&amp;gt;&amp;gt;&amp;gt; "); fgets((char*) flag_input, 100, stdin); _length =0; _j =0; k =0; while(true) { length =_length; i =_j; j =(long)_j; _j =_j +1; if((flag[j] ^flag_input[i]) !</description></item><item><title>Reg</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/reg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/reg/</guid><description>Se nos proporciona un binario de 64 bits llamado reg:
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Podemos utilizar Ghidra para analizar el binario y mirar el código fuente en C descompilado. Esta es la función main:
intmain() { run(); return0; } Vamos a ver run:
voidrun() { charlocal_38[48]; initialize(); printf("Enter your name : "); gets(local_38); puts("Registered!"); return; } El binario es vulnerable a Buffer Overflow porque la variable llamada local_38 tiene 48 bytes asignados como buffer, pero el programa está usando gets, que es una función insegura ya que no limita la longitud de los datos de entrada, desbordando el buffer reservado si el tamaño de los datos de entrada es mayor que 48 bytes.</description></item><item><title>Relatively Small Arguments</title><link>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/relatively-small-arguments/</guid><description>Se nos proporciona el código en Python utilizado para cifrar la flag:
#!/usr/bin/env python3 fromCrypto.Util.numberimport* p=getPrime(512) q=getPrime(512) n=p * q phi=(p - 1) * (q - 1) d=getPrime(32) e=pow(d, -1, phi) m=bytes_to_long(open('flag.txt', 'rb').read()) c=pow(m, e, n) print(f'{n= }') print(f'{e= }') print(f'{c= }') ''' n = 134872711253918655399533296784203466697159038260837702891888089821702090938512308686613559851138816682269099219724900870388583883202954112422023894133671598222066489215524613014212242490437041258588247678792591072443719118562580052842727775772283919113007499992167089258075609504428713653013187230671841726369 e = 50920242742169837294267124730818234703309561711363177522992049271988492365017092545331352650316729342598781520444569769450329777448285534584484096179230968844630486688656705514759778561817709539781927624692111848722199024819005269510690240743887870339853351421726436719236180272680237157536332997570569192069 c = 133155317855020316110137499609990113815646625767974277474197900721563685454745247616867035013963212538345727281661922602291072931578581035070345294335733120033652413487827994383327148598029065495228796201084369245315585407592741900307825557286213370482646401885352854920924352919398804532780740979273692054391 ''' El criptosistema utilizado es RSA, pero la implementación es errónea. El problema es que el número privado $d$ es relativamente pequeño (un número primo de 32 bits).</description></item><item><title>Reverse Polarity</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/reverse-polarity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/reverse-polarity/</guid><description>Se nos proporciona esta ristra de bits de un disco duro:
10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101 Necesitamos representarlo en forma de caracteres legibles. Primero, podemos utilizar Python para expresar el chorros de bits como un número en hexadecimal:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; hex(0b10000110101010001000110011011000110010101100001011100100110111001111011010000100110100101110100010111110100011001101100011010010111000001110000011010010110111001111101) '0x4354466c6561726e7b4269745f466c697070696e7d' Nótese que hay que añadir 0b para que Python interprete el número con base binaria.
Mirando los dígitos en hexadecimal, podemos prever que serán caracteres ASCII (por ejemplo, 0x43 es C, 0x54 es T y 0x46 es F).</description></item><item><title>Reykjavik</title><link>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/reykjavik/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/reverse-engineering/reykjavik/</guid><description>Se nos proporciona un binario de 64 bits llamado Reykjavik:
$ file Reykjavik Reykjavik: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9bc04368dbcefb4491573ac8feea3a32e31ed59f, for GNU/Linux 3.2.0, not stripped Si lo ejecutamos, vemos que necesita un argumento de línea de comandos:
$ ./Reykjavik Usage: Reykjavik CTFlearn{flag} $ ./Reykjavik 'CTFlearn{flag}' Welcome to the CTFlearn Reversing Challenge Reykjavik v2: CTFlearn{flag} Compile Options: ${CMAKE_CXX_FLAGS} -O0 -fno-stack-protector -mno-sse Sorry Dude, 'CTFlearn{flag}' is not the flag :-( Vamos a usar GDB para depurar el programa.</description></item><item><title>RIP my bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/rip-my-bof/</guid><description>Se nos proporciona un binario de 32 bits llamado server:
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) También tenemos el código fuente en C. Básicamente, lo que hace el programa es llamar a la función gets, que es vulnerable a Buffer Overflow:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void win() { system("</description></item><item><title>Robot Factory</title><link>https://7rocky.github.io/ctf/other/robot-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/robot-factory/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Nos dan un Dockerfile que comienza por FROM ubuntu:18.04, así que podemos coger Glibc desde el contenedor y usar pwninit para parchear el binario:
$ docker run --rm -v "$(pwd)":/home/rocky -it ubuntu:18.04 bash root@c591782492e6:/# ldd /bin/sh linux-vdso.so.1 (0x00007ffde1fb3000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbcde5ef000) /lib64/ld-linux-x86-64.so.2 (0x00007fbcdec00000) root@c591782492e6:/# /lib64/ld-linux-x86-64.</description></item><item><title>Rolled my own Crypto</title><link>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rolled-my-own-crypto/</guid><description>Se nos proporciona el código fuente de un servidor que ejecuta un Algoritmo de Firma Digital (DSA, Digital Signature Algorithm):
fromCrypto.Util.numberimportgetPrime, isPrime, inverse fromhashlibimportsha256 fromrandomimportrandrange q, g=0, 2 whilenotisPrime(p:=2*q+1) orpow(g, q, p) !=1: q=getPrime(256) x=randrange(2, q) y=pow(g, x, p) defH(m): returnint.from_bytes(sha256(m).digest(), 'big') defsign(m): k=randrange(2, q) r=pow(g, k, p) %q s=(H(m) +r*x) *inverse(k, q) %q returnr, s defverify(m, r, s): u=inverse(s, q) returnpow(g, u*H(m), p) *pow(y, u*r, p) %p%q==r defmain(): print("Hello admin, here are the parameters!</description></item><item><title>Rotating Secret Assembler</title><link>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/rotating-secret-assembler/</guid><description>Se nos da un socket al que conectarnos. Al realizar la conexión se muestra el código fuente usado para cifrar la flag:
$ nc puzzler7.imaginaryctf.org 3000 ================================================================================ #!/usr/bin/env python3 fromCrypto.Util.numberimport* classRotator: QUEUE_LENGTH=10 def__init__(self): self.e=65537 self.m=bytes_to_long(open('flag.txt', 'rb').read()) self.queue=[getPrime(512) foriinrange(self.QUEUE_LENGTH)] defget_new_primes(self): ret=self.queue[-2:] self.queue.pop() while(len(self.queue) &amp;lt;self.QUEUE_LENGTH): self.queue=[getPrime(512)] +self.queue returntuple(ret) defenc_flag(self): p, q=self.get_new_primes() n=p*q print(f"Public key: {(n, self.e)}") print(f"Your encrypted flag: {pow(self.m, self.e, n)}") rot=Rotator() print('='*80) print(open(__file__).read()) print('='*80) whileTrue: inp=input("Would you like an encrypted flag (y/n)?</description></item><item><title>RSA Beginner</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-beginner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-beginner/</guid><description>Se nos proporcionan estos números:
e: 3 c: 174422460809195453539354885823735245900172562989776845322302 n: 245841236512478852752909734912575581815967630033049838269083 Tenemos el exponente $e$, el módulo $n$ y el texto cifrado $c$.
Está claro que estamos ante un criptosistema RSA. Vamos a recordar cómo funciona RSA:
Se eligen dos números primos $p$ y $q$ de forma que el módulo $n = p \cdot q$. Luego se escoge un exponente $e$ (normalmente 3 ó 65537) que sea coprimo con $\phi(n) = (p - 1) \cdot (q - 1)$.</description></item><item><title>RSA Noob</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-noob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/rsa-noob/</guid><description>Se nos proporcionan estos números:
e: 1 c: 108193852288406505568171818194994500452464483136775497973720445 n: 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139 Tenemos el exponente $e$, el módulo $n$ y el texto cifrado $c$.
Está claro que estamos ante un criptosistema RSA. Vamos a recordar cómo funciona RSA:
Se eligen dos números primos $p$ y $q$ de forma que el módulo $n = p \cdot q$. Luego se escoge un exponente $e$ (normalmente 3 ó 65537) que sea coprimo con $\phi(n) = (p - 1) \cdot (q - 1)$.</description></item><item><title>runme.py</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/runme.py/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/runme.py/</guid><description>Se nos proporciona un script con código Python para que lo ejecutemos:
$ python3 runme.py picoCTF{run_s4n1ty_run}</description></item><item><title>SaaS</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/saas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/saas/</guid><description>Se nos proporciona un binario de 64 bits llamado chall:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Análisis de código estático También tenemos el código fuente original en C (chall.c):
#include&amp;lt;errno.h&amp;gt; #include&amp;lt;error.h&amp;gt; #include&amp;lt;fcntl.h&amp;gt; #include&amp;lt;seccomp.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;string.h&amp;gt; #include&amp;lt;sys/mman.h&amp;gt; #include&amp;lt;sys/syscall.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; #defineSIZE0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;amp;arch=x86-64&amp;amp;as_format=inline#assembly #defineHEADER"\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #defineFLAG_SIZE64 charflag[FLAG_SIZE]; voidload_flag() { intfd; if((fd =open("flag.txt", O_RDONLY)) ==-1) error(EXIT_FAILURE, errno, "open flag"); if(read(fd, flag, FLAG_SIZE) ==-1) error(EXIT_FAILURE, errno, "</description></item><item><title>Safe Opener</title><link>https://7rocky.github.io/ctf/picoctf/reverse-engineering/safe-opener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/reverse-engineering/safe-opener/</guid><description>Se nos proporciona un archivo fuente Java llamado SafeOpener.java:
import java.io.*; import java.util.*; public class SafeOpener { public static void main(String args[]) throws IOException { BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder(); String encodedkey = ""; String key = ""; int i = 0; boolean isOpen; while (i &amp;lt; 3) { System.out.print("Enter password for the safe: "); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes()); System.out.println(encodedkey); isOpen = openSafe(encodedkey); if (!</description></item><item><title>same</title><link>https://7rocky.github.io/ctf/imaginaryctf/same/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/same/</guid><description>Se nos proporciona un código fuente en Python para cifrar la flag:
fromCrypto.Util.numberimportgetPrime, bytes_to_long m=bytes_to_long(open("flag", "rb").read()) n=getPrime(512)*getPrime(512) e=[1337,31337] print(n) print(pow(m,e[0],n)) print(pow(m,e[1],n)) Y tenemos la salida del programa:
88627598925887227793409704066287679810103408445903546693879278352563489802835708613718629728355698762251810901364530308365201192197988674078034209878433048946797619290221501750862580914894979204943093716650072734138749420932619469204815802746273252727013183568196402223549961607284086898768583604510696483111 45254947860172381004009381991735702721210786277711531577381599020185600496787746985669891424940792336396574951744089759764874889285927022268694128526139687661305707984329995359802337446670063047702309778972385903473896687843125261988493615328641864610786785749566148338268077425756876069789788618208807001704 16054811947596452078263236160429328686151351092304509270058479526590947874445940946506791900760052230887962479603369427120610506778471930164144528718052332194666418267005043709704814833963217926271924910466448499814399455203725279998913865531351070938872586642424346857094632491904168889134624707595846754719 El criptosistema utilizado es RSA, pero tiene una vulnerabilidad. La flag ($m$) se cifra dos veces como
$$ c_1 = m ^ {e_1} \pmod{n} $$
$$ c_2 = m ^ {e_2} \pmod{n} $$
El problema aquí es que el mismo mensaje se eleva a dos exponentes diferentes pero usando el mismo módulo $n$.</description></item><item><title>sanitize</title><link>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/sanitize/</guid><description>Se nos proporciona esta página web:
Si miramos el código HTML de la página, veremos /debug:
Y ahí tenemos el código fuente de la aplicación web:
fromflaskimportFlask, request, render_template, Response, url_for, g fromsqlite3importdbapi2assqlite3 fromfunctoolsimportwraps app=Flask(__name__) defget_db(): db=getattr(g, '_database', None) ifdbisNone: db=g._database =sqlite3.connect(':memory:', isolation_level=None) db.row_factory=sqlite3.Row withapp.app_context(): db.cursor().execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT);') withapp.open_resource('schema.sql', mode='r') asf: db.cursor().executescript(f.read()) returndb @app.teardown_appcontext defclose_connection(exception): db=getattr(g, '_database', None) ifdbisnotNone: db.close() defquery_db(query, args=(), one=False): try: withapp.</description></item><item><title>scrambler</title><link>https://7rocky.github.io/ctf/other/scrambler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/scrambler/</guid><description>Se nos proporciona un binario de 64 bits llamado scrambler:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) También tenemos el binario de Glibc (libc.so_1.6) de la instancia remota, por lo que podemos usar pwninit para parchear el binario y usar esta librería, de manera que el exploit sea igual en local y en remoto:
$ pwninit --libc libc.so_1.6 --bin scrambler --no-template bin: scrambler libc: libc.</description></item><item><title>Secret Note</title><link>https://7rocky.github.io/ctf/other/secret-note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/secret-note/</guid><description>Se nos proporciona un binario de 64 bits llamado main:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Si abrimos el binario en Ghidra, veremos las siguientes funciones:
voidget_name() { longin_FS_OFFSET; charname[40]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); puts("Please fill in your name:"); read(0, name, 30); printf("Thank you "); printf(name); if(canary !=*(long*) (in_FS_OFFSET +0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } } intmain() { longin_FS_OFFSET; charsecret[56]; longcanary; canary =*(long*) (in_FS_OFFSET +0x28); setvbuf(stderr, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); get_name(); puts("</description></item><item><title>seed-sPRiNG</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/seed-spring/</guid><description>Se nos proporciona un binario de 32 bits llamado seed_spring:
Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Ingeniería inversa Esta vez no tenemos el código fuente. Sin embargo, podemos utilizar una herramienta de ingeniería inversa (reversing) como Ghidra para descompilar el binario y obtener código en C más o menos legible. Esta es la función main:
void main() { uint local_20; uint local_1c; uint local_18; int local_14; undefined *local_10; local_10 = &amp;amp;stack0x00000004; puts("</description></item><item><title>Serpentine</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/serpentine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/serpentine/</guid><description>Se nos proporciona un script de Python que debería mostrar la flag, pero no lo hace:
import random import sys def str_xor(secret, key): # extend key to secret length new_key = key i = 0 while len(new_key) &amp;lt; len(secret): new_key = new_key + key[i] i = (i + 1) % len(key) return "".join([chr(ord(secret_c) ^ ord(new_key_c)) for (secret_c, new_key_c) in zip(secret, new_key)]) flag_enc = chr(0x15) + chr(0x07) + chr(0x08) + chr(0x06) + chr(0x27) + chr(0x21) + chr(0x23) + chr(0x15) + chr(0x5c) + chr(0x01) + chr(0x57) + chr(0x2a) + chr(0x17) + chr(0x5e) + chr(0x5f) + chr(0x0d) + chr(0x3b) + chr(0x19) + chr(0x56) + chr(0x5b) + \ chr(0x5e) + chr(0x36) + chr(0x53) + chr(0x07) + chr(0x51) + chr(0x18) + chr(0x58) + chr(0x05) + chr(0x57) + chr(0x11) + \ chr(0x3a) + chr(0x0c) + chr(0x5d) + chr(0x5c) + chr(0x52) + \ chr(0x42) + chr(0x50) + chr(0x5a) + chr(0x5d) + chr(0x14) def print_flag(): flag = str_xor(flag_enc, 'enkidu') print(flag) def print_encouragement(): encouragements = ['You can do it!</description></item><item><title>Shell time!</title><link>https://7rocky.github.io/ctf/ctflearn/binary/shell-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/shell-time/</guid><description>Este reto es la continuación de RIP my bof. Échale un vistazo si no lo has visto ya.
Ahora, la flag está en /flag2.txt, por lo que tenemos que conseguir algo más que redirigir la ejecución del programa a system(&amp;quot;cat /flag.txt&amp;quot;), como en RIP my bof.
Lo primero que pensé es Ret2Libc. La idea es obtener una consola de comandos llamando a system dentro de Glibc con argumento &amp;quot;/bin/sh&amp;quot;.
Para ese propósito, necesitamos burlar ASLR, porque Glibc es una librería de sistema y está afectada por la aleatorización de direcciones si ASLR está habilitado (probablemente sí).</description></item><item><title>Shifted</title><link>https://7rocky.github.io/ctf/imaginaryctf/shifted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/shifted/</guid><description>Se nos proporciona este código fuente en Python:
importstring importrandom flag=open("flag.txt").read().strip() mystery_num=random.randint(100,1000) new_alphabet=list(string.ascii_lowercase+string.digits+string.punctuation) enc_flag="" defshift(char): index=new_alphabet.index(char) new_index=(index+mystery_num) %len(new_alphabet) returnnew_alphabet[new_index] forcharinflag: enc_flag+=shift(char) mystery_num+=10 print(enc_flag) # 15[=&amp;gt;ts-!]kgjhz%6cn~";=;.1b3:&amp;gt;}sq7n'\^]42t Lo que hace el script es crear un alfabeto y un número aleatorio (mystery_num). Luego, para cifrar la flag, encuentra el índice del carácter en texto claro correspondiente, le suma el número aleatorio (módulo la longitud del alfabeto) y devuelve el carácter en ese nuevo índice.</description></item><item><title>show-me-what-you-got</title><link>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/show-me-what-you-got/</guid><description>Se nos proporciona un binario de 64 bits llamado vuln:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Si usamos Ghidra para extraer el código en C descompilado, vemos la función main:
undefined8 main() { longin_FS_OFFSET; charlocal_118[264]; longlocal_10; local_10 =*(long*) (in_FS_OFFSET +0x28); setvbuf(stdout, (char*) 0x0, 2, 0); setvbuf(stdin, (char*) 0x0, 2, 0); puts("Send your string to be printed:"); fgets(local_118, 256, stdin); printf(local_118); puts("</description></item><item><title>Simple bof</title><link>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/binary/simple-bof/</guid><description>Se nos proporciona el código fuente en C de un binario y una instancia remota a la que conectarnos. Básicamente, lo que el programa hace es llamar a gets, que es vulnerable a Buffer Overflow, y luego comparar una variable local con un cierto valor:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; // Defined in a separate source file for simplicity. void init_visualize(char* buff); void visualize(char* buff); void safeguard(); void print_flag(); void vuln() { char padding[16]; char buff[32]; int notsecret = 0xffffff00; int secret = 0xdeadbeef; memset(buff, 0, sizeof(buff)); // Zero-out the buffer.</description></item><item><title>Simple Programming</title><link>https://7rocky.github.io/ctf/ctflearn/programming/simple-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/programming/simple-programming/</guid><description>Se nos proporciona un archivo llamado data.dat y nos piden contar las líneas que tienen un número de 0 que es múltiplo de 3 o que tienen un número de 1 que sea múltiplo de 2.
Podemos echar un vistazo a las primeras líneas del archivo:
$ head data.dat 0001100000101010100 110101000001111 101100011001110111 0111111010100 1010111111100011 1110011110010110 11100101010110111 10101101011 1111011101001 0001110001 Genial. La idea es iterar el archivo en cada línea y añadir 1 al contador (inicializado a 0) si la condición se cumple.</description></item><item><title>Slippy</title><link>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/slippy/</guid><description>Tenemos un simple back-end que permite subir un archivo .tar.gz. Como tenemos un archivo Dockerfile, vamos a utilizar un contenedor de Docker en local:
En el código fuente vemos que se trata de una aplicación sencilla en Flask (Python):
@api.route('/unslippy', methods=['POST']) def cache(): if 'file' not in request.files: return abort(400) extraction = extract_from_archive(request.files['file']) if extraction: return {'list': extraction}, 200 return '', 204 El archivo se descomprime y se escribe el /tmp:</description></item><item><title>Snakecode</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/snakecode/</guid><description>Se nos proporciona un binario llamado chall.pyc, por lo que sabemos que es un binario compilado mediante Python:
$ file chall.pyc chall.pyc: python 2.7 byte-compiled En primer lugar, podemos extraer el código fuente en Python usando uncompyle6. Como está compilado con python2.7, podemos emplear un contenedor de Docker para ello:
$ docker run -v "$PWD":/ctf -it python:2.7 bash root@11d1f884672f:~# cd /ctf root@11d1f884672f:/ctf# pip install uncompyle6 DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020.</description></item><item><title>Snowboard</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/snowboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/snowboard/</guid><description>Se nos pide encontrar la flag en esta imagen:
Sin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. En cambio, podemos encontrar la flag en su contenido en crudo.
Para extraer los caracteres imprimibles de la imagen podemos utilizar strings y ver los primeros valores con head:
$ strings snowboard.jpg | head JFIF CTFlearn{CTFIsEasy!!!} Q1RGbGVhcm57U2tpQmFuZmZ9Cg== Exif Canon Canon EOS 6D Mark II GIMP 2.</description></item><item><title>So many 64s</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/so-many-64s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/so-many-64s/</guid><description>Se nos proporciona este archivo enorme:
Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZadGNFSmxSbGw1VTJ0V1ZXSkhhRzlVVmxaM1ZsWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVm14YU0xWnNXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0xNFlVMHhXbk5YYlVaclVqQTFSMVV5TVRSVk1rcElaSHBHVjFaRmIzZFdha1poVjBaT2NtRkhhRk5sYlhoWFZtMHhORmxWTUhoWGJrNVlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRWxhU0hCSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNSGhPUm14V1RVaG9XR0pyTlZsWmJGWmhZMnhXY1ZGVVJsTk5WbFkxVkZaU1UxWnJNWEpqUld4aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STlNHaFBVbTE0VjFSVmFHOVhSMHB5VGxac1dtSkdXbWhaTW5oWFkxWkdWVkpzVGs1V2JGa3hWa1phVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5UUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSGFGQlZiVEUwVmpGU1ZtRkhPVmhTTUhCNVZHeGFjMWR0U2tkWGJXaGFUVzVvV0ZreFdrZFdWa3B6VkdzMVYySkdhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWV3hrTkdGR1ZYZGhSVTVVVW14d2VGVnRNVWRWTWtwV1lrUmFXR0V4Y0hKWlZXUkdaVWRPU0U5V1pHaGhNSEJ2Vm10U1MxUXlVa2RUYmtwb1VqSm9WRmxZY0ZkbGJHUllaVWM1YVUxWFVraFdNalZUVkd4T1NHRkdRbFppVkVVd1ZtcEdVMVp0UmtoUFZtaFRUVWhDTlZaSGVHRmpNV1IwVTJ0a1dHSlhhR0ZVVnpWdlYwWnJlRmRyWkZkV2EzQjZWa2R6TVZZeVNrZGhNMmhYWVRGd2FGWlVSbFpsUm1SMVUyczFXRkpZUW5oV1YzaHJUa2RHUjFaWVpHaFNWVFZWVlcxNGQyVkdWblJOVldSV1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYxcEhhR2hOU0VKMlZtMTBVMU14VVhsVmEyUlVZbXR3YjFWcVNtOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0VDFOSFJrZFJiRnBwVmtWVmQxWnRjRWRWTVZwMFVtdG9VRlp0YUZSVVZXaERUbFphU0dWSFJtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZucFdkbFl3V25KbFJtUnlXa1prVjJFelFqWldhMlI2VFZaWmVWTnJaR2hOTW1oWVdWUkdkMkZHV2xWU2JGcHNVbTFTTVZVeWN6RlhSa3BaVVc1b1YxWXphSEpVYTJSSFVqRmFXVnBIYUZOV1ZGWldWbGN4TkdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkpIU2toVmJHeGhWbGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFZERk9TRkpyWkZKaVJuQndWbXRXVm1ReFduUmpSV1JXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVWJGcGhVMGRXU0ZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubFhhMXByVmpKRmVsRnFXbGRoTWxJMlZGWmFXbVZXVG5KYVIyaE9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xkV2JHTjRUa2RSZVZaclpGZGliRXBQVm14a1UxWXhVbGhrU0dSWFRWZDRlVlpYTVVkWFJrbDNWbXBTV2sxSGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hoalJXaG9VakpvVDFVd1ZrdE5iRnAwVFZSQ1ZrMVZNVFJXVm1oelZtMUZlVlZzVmxwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTWtwSVUydG9WbUpIZUdoV2JHUk9UVlpzVjFaWWFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRlpFUms5VFJrcHlXa1pLYVZKdVFuZFdiWFJYVm0xUmVGZHVVbXBTVjFKWFZGWmFkMDFHVm5Sa1J6bFdVbXh3TUZsVldsTldWbHBZWVVWU1ZXSkdjR2hWTUdSWFUwWktkR05GTlZkTlZXd3pWbXhTUzAxSFJYaGFSV2hVWWtkb2IxVnFRbUZXYkZwMVkwWmthMkpHYkROV01qVkxZa1pLZEZWdWJGaGhNWEJ5Vm1wS1JtVnNSbkZYYkdSb1RXeEpNbFpHV21GWGJWWlhWRzVLWVZJeWFFOVVWekZ2VjFaa1YxVnJaR3ROYTFwSVZqSjRWMVV5U2tkalNFNVdZbFJHVkZSV1dsWmxWMDQyVW14b1UyRXpRbUZXVm1NeFlqRlplRmRZY0doVFJYQldXVlJLVTFOR1ZuRlNiVVpZVm01Q1NWbFZXazlXTVZwSFYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pHbGlSWEJRVm0xNGExVXhXWGhWYkdoclUwZFNXRlJXWkRSbFZscFlUVlZrV0ZKcmJETldiWEJUVjJzeFNHRkZlRmROYm1ob1ZqQmFWMk5zY0VoU2JHUlhUVlZ3VWxac1VrTldhelZYVjFob2FsSlhhRzlWYWtwdlZERlZkMVpyZEU1aVJuQXdWRlpTUTFack1WWk5WRkpYVm0xb2VsWnRNVVpsVmxaelZteHdhVmRHU1hwWFYzQkhWakpPVjFSdVVsQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbHBGVW1zNVZGSnJjSGxYYTFwTFlWWktkVkZ1WkZkaVdGSllWbTB4VW1WR1pIVlZiWEJUVmpGS1dGWkdXbUZrTURGSFZtNVNhMUo2YkZkVmJYaDNUVVpzVmxkc1RsZFdiSEJaV1ZWV1UxWlhTa2RqUjJoV1RVZFNXRlV3V2t0a1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGSllhR0ZTVjJoVldXdGtiMkl4Vm5GUmJVWlhZa1p3TVZrd1dtdGhNa3BIWWtST1YwMXFWa3haYTFwTFpFWldkV0pHYUdoTldFSjVWbTF3UzFKdFZuTlNia1pZWWtkU2IxUlhlRXBOYkZwSFYyMUdXR0pXV2xoV1J6VkxXVlpKZVdGRk9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRiMVV5UlhwUmJVWlhWbTFOZUZscVJscGxSbVJaWTBkb1ZGSllRbGRYVmxKTFZURk9SMVp1UmxOaVZWcFpWbTAxUTFOV2JGWlhhemxYVFZad1NGWXllR3RXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwSGJHbFNXRUpSVm0weE5HRXhWWGhYV0doV1lrZG9jbFV3WkZOWFJsSlhXa1JTYkZac2NGbFVWbFpyVjBaS2NtSkVUbGRpV0VKVVZqSnplRk5IUmtabFJtUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVGxkaGVsWllWakZvYjJGc1NsaGhSemxXWVd0d2RsWkVSbFprTVZweVpFVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm0weGIyVnNXblJOVlZwc1ZteGFlbFp0ZUhkaFZtUkhVMWh3V0ZZelFraFdha3BQVmpGU2RWVnNRbGRpVmtwVlYxZDRiMkl4YkZkYVJsWlNZbFZhYjFSWGRIZFRWbFY1WkVjNVYySlZjRWxhVldSdlZqSktTRlZyT1ZWV2JIQjZWbXBHWVZkWFJrZGhSazVwVW01Qk1WWXhXbGRaVjBWNFZXNVNVMkpyTlZsWmExcGhWMFpzVlZOc1NrNVNiSEJHVlcxek5WWkdTbkpqU0d4WVlURndURmxXV2t0a1ZrWjFXa1prYVZkR1NsbFdiVEI0VlcxV1IxcElWbFppV0VKVVZtcEdTMWRHV2tkWGJVWnJUVVJHU0ZadE5WTmhNVW8yWWtaa1ZtSllhRE5VVlZwelZteGtjMVJzWkZkaVNFSmFWMVpXVjFVeFdsaFRhMlJxVWpKb1YxUlZaRk5YUmxWM1YydDBhMUl3TlVkVWJGcHJWR3hhV0dRemNGZGlXR2hVVlhwQmVGTkdTbGxoUjBaVFZqSm9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaWldsVmFhMVl3TVhGV2JrcFhWa1Z3VEZVeFdrZGpiVVpIV2taT1RrMXRhRlpXYlhoVFV6RktkRlp1VGxOaWExcFlXV3RrVTFaR1VsVlRiVGxwVFZad2VWWlhkREJWTURGWFlrUlNWMUo2VmxoV2JURkxVbXhPYzJGR1dtbFNhM0JaVm1wR1lWbFdTWGhpUkZwVFlsZDRUMVpxUmt0VFZsbDVaRWRHYUUxWFVrbFZNblJoWVd4T1JrNVdaRnBpUmtwSVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGT1pVWnNjVkpzY0d4U2JWSmFXVEJrYjFaR1NsbFJiR3hYWWxoU1dGZFdaRmRqTVdSMVVteE9hVkl4U25oV1JscHJWVEpXYzJKR1dtRlRSVFZZVkZaYWQwMVdWbGhsUldSWFRXdFdORmt3Wkc5WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMDFHV1hoVVdHaGhVbGRTVjFsclpGTlhWbXgwVFZaT2FrMVdjREJVVmxKRFZHc3hWMkpFVmxWaVIxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVW05WlZFNURVMVprVlZOcVVtaE5helV3Vm0xMGExbFdTWGxoUnpsVlZrVktURlpYZUdGak1WWnlXa2RvVGxaVVJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXeG9UbVZHV1hkWGJIQnJUVlp3ZVZwRlZURmhWa3AxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWbTB3ZUdJeVZuTlhiazVZWWxoU1ZWVnFSbUZUUmxsNVpVaGtWMDFWY0ZoWmFrNTNWMFpaZWxGcmFGZGhhM0JRVm1wR1YyUldUbk5XYld4VFRWVndWbFl4WkRSaU1rbDNUbFprV0dKc1NrOVZhMVpoWWpGU1YxZHVUazlTYkd3MVZHeFZOV0ZIU2taalJXUldUV3BHZGxacVNrdFRSbFp5VDFaV1YySklRbTlXYWtKclZHMVdkRkpyWkdoU2F6VndWVzB3TlU1R1dYaFZhMDVhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcHpWMGRTUm1SSGNHbFNiR3Q1VmxjeE1FMUhSblJTYWxwWFlrZG9XVmxVUm5kaFJteFhWMnQwYWsxck5VaFphMXByVlRKS1JtTkZNVmhXTTBKSVZrUkdXbVZHY0VsVGJXaFRUVEpvVlZaR1ZtRmtNV1JYVjJ0a1lWSkdTbFZVVmxVeFYwWlplV1ZIT1doTlZXOHlXV3RqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZSZUdKR1pGUmhNWEJaV1d4a2IxbFdjRmhrUjBaT1RWWmFlbFl5ZUd0aE1VbDNUbFZrVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVGJHeG9VakJhVkZacVNtOVdiR1JZWkVkMGFVMXJiRFJXYlRWSFZXMUtWbGRzYUZwaE1YQXpWRlphY21ReFpIUmtSMmhPWVROQ1NWZFhkRk5VTVZsM1RWaEdWMkpGU2xoVmExWjNWRVpXZEUxVk9WUldNRFZJV1ZWa2IxUnRTa1ppUkZwWFRWWndhRmRXV2xKbFJrNTFWR3hXYVdFelFuZFdWekI0VlRGUmVHSklVbXhTV0ZKelZtMHhVMWRzYTNkV2JYUlhUV3R3V0ZZeWVHOVdNVW8yVm14b1YyRXlVa3hWYWtaUFpGWkdjMXBIYkZOaWEwWTJWbTF3UjFsV2JGZFRXR2hwVWtad1ZGbHNaRFJVTVZweFVtdDBWRlpzYkRWYVJXUkhZVVV4V0ZWcmJGWk5ibEpvV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGa01XUklWbXRzVldKSFVuQlZha1pMVG14YWNsa3phR2xOVm13MVZXeG9kMVZzWkVoaFJtaFhZbFJHVTFSVlduZFNWa3B6WTBkNFYyRjZWalpYVjNSaFdWZEdWMU5ZYkdoU2VteFlWbXBPVTFkR1pGZFhiazVYVFdzMVNGWXlNVWRWTVdSSFUyeGFWMkpVUmpaVVZtUlhZekpLUjFkdFJsTmxiWGhYVjFab2QxSXhXWGhoTTJSWVlsaFNXRlJYZEhkVFZscElZMFpPVjFZd1ZqVldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNbEY0VWxob2FWSnRhRlpaVkVwVFYwWnNkR1ZGZEdwTlZsWXpWMnRhVDJGck1WaGxTR3hYVFdwV1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVekpPZEZOclZsVmlSMUp3VmpCV1MxWldXbkZUYm5Cc1VtdHNORlpITlU5VmJVcElWV3M1V2xZelVtaFZNRnByWXpGa2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZWHBzVmxadWNFZGtiRlY1WlVad2JGSnNXbmxaTUdRMFZUSkdObEpVUWxkV1JWcDJXWHBHVm1WV1NsbGlSbHBwVmtkNFdGZFhlRzlpTVZKSFYyNUtXR0pWV25GVVYzUmhVakZhU0dWR1RsVmlSbkF4VlZab2ExWXhTbk5qUmxKV1ZrVmFhRmt5YzNoV01XUnlUbFprVTJFelFscFdNV1F3WVRKSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVVbTE0ZVZZeU5XdGhSbHAwVld0c1dsWlhUVEZXYWtwTFYxWkdjbUZHY0d4aE0wSlFWMnhXYTFReFNuUlNhMlJTWWtkU2NGWnRkSGRXYkZsNFdrUlNhVTFyYkRSWmExcHJXVlpLYzFkc1RscGlSbHBvV1dwR1UxZEhVa2xhUmxKWFlrWlpNVmRyVm1wT1ZsbDVVMnhhYWxKWGVHaFdiR1JUWkd4YWNWTnJkRlJTYkZwNVZERmFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5V2tkb1UyRjZWbmRXVnpBeFVXc3hWMWRZYUZoaVIxSmhWbXBDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFHY0hwV2JGcFBZekZPY2s1V1RtbFRSVXBJVm14amVHVnJOVmRXV0dST1ZtMVNjVlZyVm1GWFJteHpZVWM1V0ZKdGVGaFdNblF3WVRGYWNsZHFSbGROYm1oMlZtcEtTMUp0VGtaV2JHaG9UVlZ3UkZaR1dtdFViVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWMnRhYjJKR1NYZFhiVVpYWWxSR1ZGWXdXbHBsVjFaSVQxZG9UbFpYT0hsWFYzUnFUbFphVjFkdVRsaGhhelZXVm14YWQyVnNXblJsUjNScVRWWktlbGRyV210aFZrNUdVMjFHVjAxV2NGaFdha1pXWlVaa2RWTnJOVmhTYkhCMlZsZHdTMkl4YkZkalJtaHJVakJhVDFSV1dtRmxiRmw1WlVkMGFFMVZiRE5VYkZaclZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWV0pIZUhCVmJYTXhZakZTV0dWRmRGZGlSMUpaVkZab2QxUnNXbk5qUm1oYVlUSm9URmRXV2t0T2JVcEhZVVp3YUUxWVFYcFhiR1EwVjIxV1ZrNVdhR3RTYkZwdldsZDBZVmRXWkZWUmJUbHFUVlpzTTFSV2FFZFZNa1Y1WVVkR1YyRnJOWFpaVlZweVpWZE9ObEpzYUZkTlNFSkpWMVpXYTJJeFVuTmFSVnBVWWtWd1dGUldXbmRoUm1SWFYyczFiRlpzU2pGV1YzaFhZVVV4VjJOR2NGaFdNMUp5VmxSS1NtVkdWbk5oUjNCc1lUQndVRlpYTUhoVk1XUnpZVE5rVjJKWVVsaFVWM1IzVjBaWmVXVkhPVmROVlc4eVZtMTRiMVl5UlhsVmEzaFdZV3RhVUZwR1drZGpNWEJJWWtaT2FXRXdXVEpXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwellrUldZVkpYVWtoWlZWVjRWMFpXY21KR1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHYTAxWFVrbFdiWFJ6VmxkS1NGVnVRbFpoYTFwTVZHMTRZV05zYTNwaFIyeE9WbTEzTVZaWGVHOWtNVlp6V2tWb2FGSnRhRmhaYkZKSFZURlNWbGR1WkZOV2EzQjZXVEJrTkZZeVJqWldhbHBZVmpOU2FGZFdaRWRXTVU1WllrZG9VMlZ0ZUZsV2JYQlBWVEZrUjFwR1pGaGlhelZZVkZkek1WTkdXWGxOVldSV1RWZFNTRlV5ZUdGV01rcFZVbXBhVlZadFVsaFpla3BMVWpGa2RGSnNUbXhpV0doWVZqRmFiMlF4U1hoWFdHaG9UVEpTV1Zsc1ZtRlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydGtWV0Y2VmxoV01GWkhUbFphZEUxVVVtaGhla1paVmxab2MxWldaRWhsUmxaWFRVZFNkbFpxUm5OamJIQkhWR3hvVjJKWVozZFdSbHBoVkRKR2NrMVdhR3hUUjNoWVZGZHdWMVZHV2tWU2JVWnJVakZLUmxaSGVHdGhWbHBHVm1wT1YySllRa05hVlZwTFZqRk9kVk5zYUdsU2JrSjNWbXBDVjFNeFRsZFhia1pVWVd4S1lWWnRNVk5UUmxwMFRsWmtXRkl3Y0VsV1YzTTFWMjFLVlZKdVdscGhhMXBvV1RGYVIyUkdTbk5hUlRWb1pXeFpNbFl4VWtOV01rbDRWbGhzVkdFeWFGZFphMlJ2Vm14YWRHVkhSazVOVm5CWldsVmtSMkZyTVZsUmEzQllZVEZ3VkZaSGVHRldWa3BWVVd4a1YxSldjREpYV0hCSFZtMVdWMU5zYkdsU01taFVXbGN4TkZkR1pGaGtSMFpVVFZkU1NGWXhhR3RYUjBweVRsaEtWbUZyV2t4VmFrWjNVbXhhVlZKdGFGZGhNMEY0VmxaYWIyRXhXWGhUYms1cVVteEtWMVpyVm1GaFJtdDVZek5vVjAxWFVubFViRnByVlRKRmVsRnNjRmRpVkVJeldsVmtTbVZXV25WVWJHaHBZWHBXV2xkWGVHOVZNVnBYVm01R1UySlZXbFZWYlhoelRsWndWbUZIZEZkTlJFWlhXVEJhYjFkdFJuSk9WRTVYVFVad2FGbDZSbXRrUjBaSFdrZG9hRTB3U2xKV2JURjNVakZWZVZWc1pGZGlhelZUV1d0a1UyTkdXblJrU0dSWFlrWnNORmRyVWtOV01ERnpVbXBTV0dFeWFGQldNR1JHWlZkR1NWUnNXbWhoZWxaRlZteFdZVmxYVWtoV2EyeFZZWHBzVkZsclpETk5WbHBJWlVaYVQxWXdXa2xWTW5SaFlXeEtkR1ZIUmxkaVJuQXpXbGQ0WVdOV1RuSlhiWGhUWWtoQ1lWZFdWbXRTTVZWM1RVaHNhRkpHY0ZoWmJHaERVMFprVjFkdGRGaFNhM0I1V1ZWa2QxVXdNWFZoUm14WFlXdEtXRlY2Ums5U01XUjFWVzE0VTAweFNsRldWM0JEVmpBMVIxZHNhRTlXVkd4WlZXMHhVMU5XY0ZaWmVsWlhZbFZXTkZZeWNFOVdNREZIWTBod1YwMUhVbFJWYlRGVFUwZE9TR0pHVG1sU00xRXhWbTE0YW1WRk1VWk5WV2hUWW14S1ZGbFhlSGRYUm14eVdrYzVXRlp0ZUZaVmJUVnJZVzFLU0dWR2FGZE5ibEYzV1ZkemVHTnJOVlpoUm5Cb1RWaENlVlpzVWt0VE1VcDBWR3RhYVZKdFVsbFZNRlpMVWtaYVIxZHRkRlZpVmxwSVdUQldjMVpIU2xoaFJsSlZWa1ZhVEZac1dtRlNNVnAwVW0xMFRsWXhTbGxXTW5SaFlqSktSMU5ZWkZoaVZWcFlXV3hTUjFaR1dYZFhiSEJzVmpGYVNWUXhaRzlVYkZwWVQwaHNXRll6VW5GVWJGcGhWakZrZFZSc2FHaGhlbFpYVm0xNFlXUXlWbk5YYmxKc1VqTlNjVlJXV2t0bGJHUnlWMjEwYUZack5VZFZNakZIVmpBeFYyTkdhRmRoYTFwWFdsVmFhMlJXVG5KT1ZtaFRZa2hDTWxac1pIZFRNa2w0WWtaa2FsSnRhSEpWYWtKaFZERlNWMWR0Um14aVJtdzFXbFZrTUdGRk1WWmlSRTVWWWtaYWNsWnNaRXRTTWs1SlUyeGtVMDB5YUc5V2FrSnJWVzFXZEZSclpHRlNNbmhaVldwS2IxWnNXbk5oU0dSU1lsWmFTRlpIZEd0V1IwcElaVWM1Vm1GclNtaFdhMXBoWTFaT2RFOVdaR2xTTVVwYVYydFdhMDFIUmxaTldFcHBVa1pLV0Zsc1VsZFRSbHBZVFZWMFYySkhVbnBaVlZwM1lVVXhXVkZZY0ZkU2JGcG9Xa1JHWVdSR1NuSmhSM1JUWWtad2RsZHNaREJaVm1SeldraE9WMkpWV205VVZscHpUVEZTVjJGRlpGZE5hM0I1V1RCYWIxWXlSWGhYYWs1WFVsWndWMXBWV210amJIQklZMGRzVjFadVFrcFdha293V1ZaUmVGVnVTazVYUmtwdlZXMTRkMWRHYkhOaFJ6bFhVbXhaTWxWdGREQmhNVXB6WTBSR1YxSXphRkJaVm1SR1pVZE9SMkpHYUZkTk1VcDVWbXhTUjFsV1NYaFdiazVYWWtaS2NGWnJaRFJrTVZwSFYyMUdhMDFzV2xoV01uaHZZVEZLUmxOc1pGVldWa3BJVmpCYWMyTnNWbk5VYkdST1ZsYzRlVlp0TVRSaU1WbDVVMnhXVTJFemFGZFpiR2h2VlVac05sTnJaRk5OVjFJd1dXdGFUMkZGTUhkVGJVWlhZbFJHTTFWcVJuTldNa3BIV2taU1dGSXlhSGRXVjNSaFpERmFSMkpJVG1GU1JrcFdWRlphZDJWR1ZuUmtSRUpYVW14d2VsbHJVbGRaVmtwWVZXdG9XbFpXVmpSV01GcFhZMjFLUjFkck5XbGlSWEIyVmpGYWEwNUdVWGhUYmtwUFZtMVNhRlZ0TlVOalJsWjBaRWhrVkZac2NEQmFSV1JIWVRBeFdGVnJiRmRpV0ZKNlZteGtTMU5HVm5WUmJGcG9ZVEZ3VFZaSE1UUlpWMDV6WVROd2FGSXllRTlXYlRFelRWWmFXR1ZIT1d0TlZscDZWMnRXYjJGR1NuUmhSbWhhWWtaS1NGWlVSbE5XYkdSMVdrWk9WMkV6UWpaWFZFSnJUa1paZVZKcVdsZGhiSEJaVm1wT1UyRkdaRmRhUldSWFRWVTFXbGxyWkc5Vk1sWjBaVVpzVjJKWVFsQldWRVpyVWpGd1IxcEdhR2xoZWxaWlZrWmtlazFXVGtkWFdHeE9WbGRTVjFSV1pGTlRSbFY1WlVkR1YwMXJjRlpWYlhCaFZsWmFkRlZzYUZwbGEzQk1WV3BHYTJSR1NuTlViWGhwVjBkb1dWWnFSbUZpTWxGNFUxaG9XRmRIYUc5VVZFcFRWMVpzYzJGR1RsaFNiRXBaV2tWb2ExWkdXbk5qUld4YVRVWndVRlpxUmxwa01WcHhWbXhrVjAweWFGRldNVnBoV1ZkTmVWUnJhR2hTYmtKUFdXMHhibVZzV2xoalJXUnJUVlUxU1ZVeWRHOWhWa3B5VGxac1ZtSkdXak5XVkVaaFpFVXhTVnBIZUZOV1JscEtWbGQ0YjJJeFdYaGFSV2hvVW0xNFdGUlZaRk5rYkZweFVtNU9hbUpJUWtsVU1XUjNZVlpLYzFkWWNGZE5ibEpvVmtSR2ExSXhUblZVYkZKcFVqSm9XbGRXVWtkVE1WcEhZa2hLV0dKVlduRlVWM014VTBac2NsZHNaRmROYTNCSVdUQm9jMVl5Um5KVGJXaFdaV3R3VUZwRldrOWpiRnB6Vm0xc1UwMVZjRE5XYlhCRFZqRk5lRmRzWkZoaWExcFZXVzAxUTJNeFZuUmpla1pVVm14YU1GcEZaRWRoVmtweVkwUkNWMVl6VFRGV01qRkxWbFpLZFZkc2NHaGhNWEJ2VjFSR1lWSXlVa2RUYms1aFVsUldiMXBYZUZwTmJGbDRWV3RPVjAxcmJEUldiR2h6VmtkRmVXRkdaRnBoTWxKMlZtMTRZV1JIVmtoU2F6Vk9WbTVDV2xkc1ZtdFNNa1p5VFZaa1dHSnRlRmhWYWs1dlkyeHNWbHBHWkdwTlYxSjZXV3RhYTJGSFJYaGpSRXBZVmpOQ1RGVnFTazVsUmxKMVZHMW9VMDF0YUZWWGJHTjRUa1prUjFwR1pHRlNSVXB5VkZkNFMyVnNXWGxrUm1SV1RXdHdTRmt3YUV0V1ZscHpZMFJPWVZac2NETlZiWGhoVmxaS2RHRkdaR2hOTUVZMFZteGFZV0l5UlhoWFdHaFVZbXMxY1ZWdGVFdFdNVnB5Vm0xR2FGSnRkRFZaZWs1dlZqQXhXRlZ1YkZWaVJuQnlWbFJLUm1Wc1JuTmpSbVJwVmtWSmVsZHNWbXRUYlZaWFYyNVdWV0pIYUhCWmExWjNWVVphZEdWSFJtdE5hekUwVmpJMVUySkdTWGRYYms1YVlURndNMVJWV25kV2JVWklaRWRvVTJKSVFYZFdiR1F3WWpGYWNrMVdhR2hTUlRWWVZGVmFkMWxXY0ZobFJXUnFZbFZhU0ZkclpHOWhSVEIzVTJ4S1YySlVSak5WYWtaV1pWWldjMXBHWkdsaGVsWlVWMWQwYTFVeVRrZFhibEpyVTBkU1dGbHJXbk5PUm1SeVZXeE9hRlpVUm5sWmExSlRWMjFGZUdOSVNsaFdiSEJNV1hwR2EyTXhVbk5qUjJ4VFlraENkbFl4WkhkU01WVjRXa1ZvVm1FeWVHaFZiWGhMVjBac2NsZHNjRTVXYlZKNVZtMHhkMVF4V25OaVJGWldUVzVvYUZsWGVFdFhSMVpJWVVaa2FWSXhTbFZYYTJRMFdWZE9WMVJ1U210U2JFcFVXV3RhZDA1V1drVlNiVVpYVFZac05WVXlkSE5WYlVaelkwWm9XbUpIYUVSVk1GcHJWakZrZEdSR2FGTmhNMEkxVmpKMGEySXhWWGxTYWxwWFltMVNXRlp1Y0VKbFJsWllZek5vVjAxWFVscFpWVnB2WVZaSmVGTnRhRmRpV0VKRVZtcEJNVkl4WkhOaFJUbFhZWHBXV0ZaR1pEQmtNbFpYVlc1T1dHSnJOVmxaYkZaWFRrWnJkMXBIT1ZkTlJFWklXVEJvZDFZeVNrZGpSa0phWld0YVVGa3ljekZXTVZKMFlrWm9VMDF0YUZwV2JURTBZVzFXU0ZadVNrOVdiVkpZVmpCa1UxUXhXblJOVms1cVZteGFlVlp0TVVkWFJrcHpWMjVvVjFKNlFURlpWRXBMVTBkV1IyRkdaRTVpYkVZelYxWmtlbVZIVG5KT1ZscG9VbTVDYjFSV2FFTk5iRnAwWTBWS2EwMXNXa2hXUnpWSFZrZEtTRlZzYUZwaE1Wb3pWVEZhWVdOc1ZuSmFSbWhwVm14d1NWZFVRbGRqTVZwSVUyeGFXR0pHU21GWlZFcHZVa1p3U0dWSFJsTk5XRUpHVmxkNFUxUnNXWGhUYTJ4WFlXdHZkMWxVUm10VFJrNXpWMnhvYVdFelFsZFdiWGhoVXpGT1IxWllaRmhpVlZweVZXeFNWMWRHV2toTlZ6bFZZa1p3V1ZRd2FITlhSbGw2Vlcxb1dsWkZXbWhhUlZwUFl6SktTR0ZHVWxSU1ZYQllWakZrTUZsWFVYbFdiazVZWW14S1QxWnNaRk5XUm14eVYydDBiR0pIVW5sWGEyaFBWakF4V0ZWclpGWk5ibEYzVm1wQmVGWXlUa2RoUm1Sb1lURndXRmRzVm1GaE1rMTVVbXRrVm1KWGVGUlVWRXB2VFd4YWMxVnJUbGROYkVZMFYydFdhMkZXVGtaalJteGFZbFJHVkZac1dsZGtSVFZXVkd4T1RsWnRkekZYYTFaVFVUSkdSazFXV21sU1JUVldXV3RhWVdOc1duTmFSWFJUVFdzMVNsVXllR3RWTURCNVlVYzVWMkZyU25KV1Z6RlhaRVpTY2xwSFJsTk5ibWhhVmxkd1MySXhXbk5YYms1b1UwZFNVMWxzV21GVFJscElaRWQwVjFJd2NFbGFWV00xVm0xR2NsTnRhRmRoTVhCb1dURmFUMlJGT1ZkYVIyeFRUVlZ3WVZZeWRGZGhNREZJVW14YVRsZEZjSEJWYTFwTFYwWnNjMVZzWkZSU2JIQlpWRlpXTUZZeVNraFZibkJhVmxad00xbFZWWGhYVmtaWlkwWmtVMkpJUW05WFZFbDRWVzFXUjJORmJGWmlXRkpVVkZjeGIxVkdaRmRWYXpsU1RWVTFXRmRyV205aE1VcHlUbFphVlZac2NIcFVWRVpUVmpKR1JscEdaRTVoTVZreVYxWldhMUl4WkhOWGExcFlZV3MxV0ZWc1duZE5NVlowWlVkMGFrMVlRa2xhUlZwclZHeE9SbE5yY0ZkTlZuQllXVlJLU21WR1ZuVlViVVpUVm01Q1ZsZFdaRFJaVm1SSFlraE9WbUV5VWs5VVZscGFUV3hXZEdSRVFtaE5WWEI2V1RCU1IxWXhTWHBoUmtKYVZtMVNSMXBWWkU5U01rNUhZVVprVGsxVmNEVldiWGhUVXpGT2RGWnJaRmRpYXpWdlZXcE9iMVpHV1hkV2EzUldVbTFTV1ZwRlpFZGhNREZXVGxWb1YwMVhhSHBXUjNoaFYwWldjMkpHV21oaE1HOTZWbXBDWVZZeVVraFVhMXBRVm0xU1dGbHJhRU5PYkdSVlVXMDVWRTFXYkROVVZsWnZWbTFGZW1GR2FGVldWMUpVVmpCYVZtVkdaSE5VYlhCT1lYcFdTVll5ZEdGVU1WbDVVMnhXYUdWcmNGaFpiRkpIVFRGV2NWSnVUbGhTYTNCYVdWVmtSMVV4V1hsaFJteFlWbXhLVEZscVJsZFdNV1IxVlcxMFZGSXhTbGRXUmxwaFpESldjMWRzYUd0U01GcFdXV3RXZDJWc2EzZGhTR1JZVWpCV05GVXllRk5YYkZwWFZtcFNWMDFIVWxoVmFrcEhVakZrY2s1WGJHbFdNbWN4Vm1wR1lXRXdOVWRWV0doVVltdHdVRlp0TVZOaFJsWjBUbFZPYWxKc1dqQmFSV2hyVmtaYWMyTkVRbUZTVjFKSVZqQmtTMVl4WkhOaVJtUnBWMFpLTWxkV1VrZFRiVlp6VW01V1VtSkdjSEJXYTFwaFVsWmFkR05GWkZwV2JWSkhWRlphVjFadFNsaGhSVGxYWWxoU00xUnRlR0ZqVms1VlVteGtUbFpzYjNkV1Z6QXhWREpHYzFOdVVteFNiV2hoVm10V1lXRkdXa1pYYms1WFlrZFNNRlZ0TVhkV01rVjZVVmhrV0dFeFdtaFdSRVpUWXpGa1dXRkdVbGhTTW1oWlYxWlNTMVZyTVVkWGJGWlVZVEpTVkZsWWNFZFhiRnBZVFZjNVZrMXNXakJhVlZwelZqSktXVkZzUWxkV1JWcHlWV3BHZDFJeGNFZGhSMnhvWld4YVdsWnJXbXRsYXpGWFZHdGtXRmRIZUU5V2JHUlRWakZTVjFwR1RsUlNiRlkxV2xWa1IxWXdNWEpqUmxwV1lsaENhRlpzV21Ga1JsWnpZVVp3YkdFelFrMVdWM0JIWVRKU1IxTnVUbFZpV0dod1ZqQmtiMWRXV25GU2JVWnBUV3hHTkZVeGFHOVhSbVJJWVVjNVZWWkZjRlJXTVZwell6SkdSMVJzYUZOaVJYQmFWMnRXYjJFeFdrZFhiazVxVWxkNFlWUlZXbmRWUmxweFVteHdhMDFXY0hoV2JYaHJWakF3ZVdGR1JsZE5WbkJvVjFaa1RtVldVbkpoUjJoVFltdEtVRmRYTUhoaWJWWnpWMnhvYWxKWFVuSlVWbFV4VTFaVmVXUkhPV2hXYTNCNVZHeGFjMVp0U2tkWGFrNVhWa1ZhYUZwRlZYaFRWbkJJWlVaT1YxSnNjRXRXYkdRMFlqSkplRmRZYUdGU1YyaHZWVzB4TkZkR1VsWmFSazVyWWtad2VGVnROVTloYlVwSlVXdHNWVTFYVWpOWlZscExZekZrV1dOR1pFNWliRXB2Vm10U1IyRXhTWGhVYmxaVllrWktjRlZxU205WGJHUlhWV3RrVkUxV2NFaFphMmhMVjBkS1ZsZHVSbFZXTTAxNFZUQmFjMk5zWkhOYVJtUk9ZVE5DU1ZkVVFtOWpNVmw1VW01S1ZHSlhhRmRhVjNSM1ZVWndSbGRyT1dwaVJuQjZWbTB4YzFVd01WWmpSRTVYWWxoQ1JGWnFSazVsUm1SeldrWm9hV0V4Y0ZaWFZ6QXhVVEpOZUZadVVtcGxhMXBWVm0xNFlVMUdjRVphUldSb1ZtdHdlVmt3VWtOV01WbDZWRlJHVjAxcVJreFdiRnBMWkZaa2MyTkhhR2hOV0VKMlZqRlNSMWxXU1hsVmEyUlVZbXMxYUZWc1VsZGlNWEJZWlVad1RtSkdiRFJXVjNSUFZqQXhjbUpFVWxkaVIyaDZWbXRrUm1WWFJrZGFSbkJvVFd4S01sWnRNVFJaVjFKSVZtdG9VMkY2Vms5V2JUVkRWMnhrYzFadGRGTk5hMXA1VkZaYWExZEhTblJsUm1oV1lXczFkbGt5ZUhOV2JIQkhXa2R3VGxZeFNqWlhWM1JoWVRKR1NGSllhR3BTUlhCWlZtcE9RMVJHVm5GVGF6VnNVbXhLTVZaSE1XOVZNREYwWVVaV1dHSkhUalJVYTFwclVqRndSMXBIUmxOU1ZYQjVWa1prTkZNeVZuTlhXR3hyVW0xU1YxUlhkSGRUUm10M1lVVjBWMVpzY0hwWk1GSlBXVlphYzJORVRsWmlXR2hvVm14YVMyUkhSa2RhUjJoT1RVVlpNRlp0ZUdGWlYwbDVVbGhvV0ZkSGFGVlpiWE14WTFaV2RHVkZkRmROVm5CNVZtMHhSMkZHU25Sa1JGWmFaV3MxZGxacVFYaFhSbFoxWWtaV2FWSnVRbmxXYkZKTFVtMVdjMUp1VG1wU2JWSndWbXRXU21Wc1pITldiWFJVWWxaYVdGWXlOVmRXVjBwSVlVaENXbUV4V2pOV1ZWcGhaRWRXU0ZKdGRFNWhla1V3Vm1wSk1WVXlTa2RUV0dSWVltczFZVmxVUm5kTk1WSldWMjVrVjJKVldrbGFSV1J2VlRKS1NWRllaRmRpUjFGM1dXcEdZV05yTVZkaFIyaFRVbFJXV1ZaR1ZtRmtNV3hYWTBab2JGSlhVbkZaYkZaaFUwWmtjbHBIT1doU1ZFSXpWVEo0UzFZeVNsVlNhazVXWVd0YVYxcFdXbGRqTVhCSFdrZHNhR1ZzV2xWV01XUXdZVEZWZVZSclpGaGliRXB5VlRCa1UxZEdiSEpYYms1UFVtMVNlVlpYZUU5aFJscFZVbTVzV21FeFNsUldNakZHWlVkT1NWTnNhRmRpU0VKTlYxaHdSMkV5VFhoVmJrNXFVako0VkZscmFFTmtiRmw0V2toa1UwMVdWalJYYTFadlZtMUZlV1ZIYUZaaVdHaE1WakJhYzJOc1pITmpSVFZYWWxaS05WWnRNSGhrTVZGNFYyNU9hVkpHV2xkVVZ6VnZZVVpzV0dWRmRGaFNNVnBKV1ZWYWEyRldTWGhUYkZaWVlUSlJNRmRXWkU5V01WSjFVMjEwVTJKRmNGVlhWM1JoWkRBMVYxZHJWbE5pVlZwWVZGWmFjMDVXVlhsa1NFNVdZbFZhZWxrd1dtOVhiVXBJWVVWU1ZrMUdjSEpXYWtaclpFZFNSMkZHVG1oTk1Fa3hWbXBLTUdFeVNYaFdXR3hUWVd4d1dGbHRNVk5YUmxwMVkwVktiRkpzV2xsWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVkdUblJoUm1ScFYwVktSVlp0Y0VKTlZrbDRXa2hPYUZKVWJGaFpXSEJYVjBaYVIxcEVRbXROYkZwWVZsYzFUMWRIU25KT1ZteGFZa1phV0ZSclduSmtNWEJJVDFaa1RsSkZXa2xYVkVKdlpERlplVk5yWkdwU2EwcGhXbGQwWVZWR2EzbGpla1pYVFZaS01GbHJXbTlWTURGMFlVWndWMkpVUlRCWlZ6RlhVMFphZFZOck9WZGlWa3BaVm1wQ2ExVXhVWGhYYmxKT1ZtczFjVlp0ZUdGbFZscDBUVlZrV0ZKcmNIcFdNalZ2VmpGS05sRlVSbHBXUlhCTVZUQmtWMUl5UmtkYVJUVnBZa1ZaZWxZeFdtdGxiVlpJVkc1S1QxWnNjRzlWYlRWRFlqRlNWMkZGVGs1aVJuQXdXVEJXUzJFd01YTlhhMmhYVW5wV1NGWnJaRXRUUmxaellVWndhRTFXYjNwV1ZFWmhXVmRPYzFadVNtRlNiV2h3Vm0xNGQxTldaRlZSYkdScVRWWndTVlV5ZUdGWFIwcEhVMjFHV2xaRmNIWlZhMXAzVTBkV1NGSnNUazVYUlVwSFZteGtORlV4VW5OWFdHaFVZVEo0V0ZsWGRIWmtNV3hWVW0xMFZGSnJOWHBXTW5odllWZEZlbEZzWkZkaVdHaG9WWHBHVDFJeFdsbGFSbWhwVmxad2VWWlhlRk5XTVdSSFYydG9UbFo2YkZaWmExcDNWMVpSZDJGSVRsaFNiR3cyVmxjeGIxZHNXa1pYYldoaFVsWndVRmw2U2t0VFIwWkhWV3hTVTFaWVFsbFdha1pyVFVac1dGVlliRmRpYXpWWldXMTRTMVF4V25OYVJrNVhVbTE0ZVZZeWREQmlSMHBJVlc1c1dHRXlhRkJXYWtGNFYwWldjbHBHV2s1aWJFWXpWbTF3UW1WR1dYbFVhMlJvVW0xU2IxbFVSbmRYUm1SelZtMUdhRTFyTVRWVmJYUnJWbTFLV0dWR1VsVldSWEIyVkZkNFlXTXhWbkpVYkdST1lrVlpNRll5ZEZkaE1rWlhWR3RhYWxKdGVHRlpiRkpIVmtaYWMxZHNaR3RTVkZaWFZrZDRUMVJzV25Sa2VrWllZVEZhVkZWVVNrZFNhekZYVjIxc1UxSlVWbGRYVjNSaFdWZE9jMWR1VG1GU1dGSlVWRmR6TVZOc1ZYbGxSM1JXVFVSQ05WbFZZelZXTWtaeVUyNUtWMVo2UmxoYVJWcFRZMnh3U0ZKc1RrNWliV2hoVm14a2QxTXlTWGhYYms1WVltczFiMVV3WkZOVk1XeHpWMjFHVkZKc2NFbGFSV1F3VmpGSmQyTkZiR0ZXVjAweFZtMHhSMk5zVG5SaFJtUm9UVmhDYjFkVVJtRlVNbEpHVDFaa1lWSXllRlJVVmxaM1dWWlplV1JHWkdoTlJFWkpWVzE0WVZSc1pFWmpTRUpXWVRGd1RGWXdXbk5qTVZaeldrWlNVMkpJUWxwV1JscFhUVVpaZVZOcmFGWmlia0poVm14YWQwMHhiRlpXV0doWVZtdGFXbGt3V210Vk1rcEhZMGM1V0dFeFNraFhWbVJUVWpGT2RWTnRhRk5OTVVwVlYxZDBZV1F5VW5OYVNFNWhVa1ZLWVZadE1WTmxiR1J5WVVVNVYwMXJjRmRXTWpBMVZsWmFjMk5JY0ZWV1JWcFVWbXBLUjFKc2NFZGFSVFZvVFRCSk1WWXhVa05aVjBsNFYxaHNVMWRIYUZsWlYzTXhWMFpXYzFkdVpGZE5XRUpYVmpJeE1HRnRTa2xSYTJ4YVRVZFNlbFpxUm1Ga1ZrWnlZMFprYUdFeU9UTldNVnBoVlcxV1IxWnVWbFJoZWxaWlZXMTBkMlJzV2xoTlZGSnJUVmRTU0ZscmFFOWhSa28yWWtab1ZtSllhR0ZVVjNoWFpFZFNSVkZ0YUU1V1dFSTJWMVJDVTFJeFdYaFRXSEJvVW10S1lWWnRNVk5TTVhCV1drVTVVMDFyY0VoWlZWcHJWR3N4Vm1ORVZsZGlXR2hVVldwR2MxWXhUbGxoUm1ScFlYcFdXVmRYZEdGVE1rNUhWMjVLWVZKR1NuSlVWbHAzVTBaWmVVMVZaR2hOUkVaNlZqSjRiMVl3TVhWaFNGcGFWa1ZhVEZWdGVFOWpNWEJIVm14a1YyRXpRa3BXYlhCRFdWZE5lVlJ1VGxkaWF6VldXV3RrVTFReFduTlplbEpzVm14d01GUldVbE5oVlRGWFlrUldWazF1YUZoV1ZFcEdaVzFHUjFwR2NHbFNNbWd5Vm14V1lXTXdOWE5VYmtwaFVtczFUMVpxUmtwa01XUllaRWRHVlUxcldrZFVWV2hyVmtkS1ZsZHNhRnBpUmtwSVZGUkdWMk5XU25WVWJHUk9ZVE5DU1ZZeWRHRlZNV1JIVTFoc2FGTkhVbGhXYWs1VFlVWndSVkp0UmxOTmEzQktWa2N4UjFVeFNuSmpSbVJYVW14d2FGcEVTbGRTTVZwMVZXMTBVMUpWY0ZsV1Z6RTBaREpXYzJKSVNsWmlSMUpoVm0xMGQxZFdXbGhrUnpsWVlrWndXRlp0Y0ZOV01ERkhZMFpvV2sxcVJreFZha1pyWTJzMVdHSkhiRk5YUlVsNVZtMXdSMWxYUlhkT1ZXUldWMGRvVlZsdGRIZFZSbHAwVFZaT2FGSnNXakJVYkZaUFlXeEtjMWRxUW1GU1YyaHlWbXRhWVdNeVRrVlJiVVpUVmpGS1NWZFdVa0psUm1SSFZtNUthVkp0VW5CV01GcExUbXhhZEdWSGRGUk5WVFZJVm0wMVYxVnRTa2RqUnpsYVZrVmFNMVpHV21GVFJURlZWV3h3VjAxRVZqWlhWbEpQWkRKR1IxTlliR3hTVkd4WVdXeFNSbVZzVWxkWGJVWllVakZhU1ZReFpEQlViRnB6WTBSYVYwMXVVbGhaYWtwSFVqRk9kVlZ0YUZOaVYyaG9WMWQwWVZNeFRrZFhiRlpUWWtVMVdGbHJaRk5OVm1SeVYyczVWMDFyVmpaVlYzQmhWMFphUmxOdVNsVmhNWEJoV2xaYVMyTldaSE5hUjJocFUwVktZVlp0TVhkVU1WVjVVbXRrWVZKdFVtaFZiR1JUVjBaU1YxWlVSbGhpUjNoNVYydGpOVlpyTVhOWGFrSmhWbFp3ZWxacVNrdFhWa1p6VVd4a1YxSldjSGxXVjNCSFpERkplR05GWkdoU01uaHZXbGQ0WVZkc1duSlhiWFJzWVhwR1dGWkhkR3RYUm1SSVpVVTVWMkpIVWxSV2FrWlRWakZ3UjFSc1VsTmlSbGt4VjJ4V2ExSXhXWGROV0VwcVVteHdWMWxzYUVOaFJscHpWMjFHYTFKc1ducFpWVnAzWWtkRmVsRnJNVmRXTTBKSVdWUktVMUl4VG5WVWJGWnBWMGRvZDFacVFtdGlNV1JYVjI1R1UySlZXbkJVVjNoSFRrWlZlR0ZIT1ZoU2JWSkpXVlZqTlZaV1drWmpSbEpYVFZad2VsbDZTa2RTTVZKellVWk9hVkpZUW1GV01uUlhZakpGZUZkclpGaGlhelZ4Vld4a05GbFdVbFpYYm1SV1VteHdlRlZ0ZUhkaE1ERlhZMGhvVjJKWWFISldha0YzWlZkR1IxSnNaRTVXYmtKdlZqRmFhMVJ0VmxkVmJrcG9VakpvVkZsdGRFdFZSbVJZVFVob2FXSldXbnBXTW5odllXeEtXRlZ1U2xWV2JGVjRWVEZhVm1WWFVraFBWMmhYWVROQ05WWkhlR0ZqTVZwMFUydGtXR0ZyTlZoV2ExWmhZVVp3UmxaWWFGUldia0pKV2xWYVQxWXhTbk5qUlhSWFlrZFJNRmxxU2twbFJtUlpZVWRHVTFZeWFIWldWekI0VGtaa1IxVnNXbUZTYXpWeVdXdGFkMlZHVm5ST1ZUbG9ZbFZ3U2xWWGRITldWVEZZVldwT1dsWnNjRXhaZWtaclYxZE9SMXBGTldsaVJYQjJWbTEwVTFJeVJYaFRXR2hWWW14YVZsbHJXa3RqUmxaeFUyMDVXR0pIVWxoV1YzUnJWa1V4VjJORmFGcGhNbWhNVmpCa1MxWnNaSFZTYkZaWFRUQXhORlpVUW1Gak1rNXpXa2hPWVZKdFVrOVpWRTVEVTFaa1ZWRnRPV3BOVm13MVZXMDFTMVpIU2xoaFJtUmhWak5TTTFaVlduZFNiR1J5VDFkd2FWSnVRalpXYlRCNFl6RlZkMDFXV21wU1JUVllXV3hvUTFKR1duRlNhelZzVW0xU2VsZHJXbTloVjBWNFkwWmFXRlo2UVhoVlZFcE9aVVphZFZWdGNHeGhNWEJXVm0weE5GbFZNVWRqUlZwaFVsZFNiMVp0ZEhkbFZtdDNWV3RPVjAxV2JEWldSbEpIVmpBeGNWSnJlRmRpUm5CTVdrWmFhMk15VGtoaFIyaE9WMFZLTWxacVJsTlNNV3hYVTFoc1ZtRXlVbFZaYlhNeFlVWldjMVZzWkdsTldFSlpXbFZhZDFSdFNrZGlSRkpYVmpOU1VGWnFRWGhqYlVwRlZXeGthVkl5YURaV2JYUnJVbTFXV0ZKclpHRlNia0p2VkZkNFMwMXNXblJOVkZKYVZqRktTVlp0ZEc5Vk1rWTJWbXM1VjJKVVZrUldNbmhyWXpGYWRHUkdUazVoTVhBMVZrWmFZV0V4WkVoVGJsSnNVbTFvVjFsWGN6RmtiR3Q1WlVoT1YySklRa2hYYTJSM1ZHeFplRk5xV2xoV00xSm9XVlJLUjFOR1NsbGhSM0JUVWxoQ1dsWnRjRTlSTVZKSFZtNUdWR0Y2Vm5OVmJYaExUVlphU0UxWE9WWk5SRVl3V1ZWYVYxZEhTa2hVYWxKVllURndjbFZxUm5kU01YQklVbXhPVTFaWVFqVldhMXByVGtaTmVWWnVUbGhYUjNoeVZXMHhVMVl4VWxoa1NHUlVVbTEwTTFsVlZqQldNVnB6WTBod1drMUdTbEJYVmxwaFl6Sk9SVlJzV21sWFIyaHZWbTE0WVZNeVVraFNhMlJoVWpKb1QxUlZWbHBOUmxwMFpVZEdXbFl3YkRWVmJHaHZWMFprU0dGR1ZscGlXRTE0V1RGYVYyUkhWa1prUm1ST1ZtNUNOVlp0TUhoU01rWkhVMjVTYTFKR1dtRmFWM014Wkd4YWNWRllhRmhTYkZveFdXdGFWMkZXU25WUmJteFhZa1pLVEZWdE1WZGpNVXAxVkcxd1UySldTbmRXYlhSWFUyMVdjMXBJVGxkaVdGSlZXV3hhWVZkR1dYbE9WbVJYVmpCd1NWbFZhRU5YYlVWNFYycE9WMVpXY0doYVJXUlhVMFpLZEdSRk5XaGxhMVYzVm0xd1NrMVdWWGxUYTJSVVYwZFNXVmx0Y3pGWlZteFZVbTVrVGsxV1NsZFdNalZyVmpKS1ZsZHJiR0ZTVjFKMlZsUktTMU5XUmxsYVJtUnBVakZHTTFkWGNFZFpWMDV5VFZaa2FGSXlhRlJWYkZKWFYxWmFSMVp0Um10TlYzaFlXVEJhYjJKR1NsaFZia1phWWtaYWFGVXdXbXRqYkhCSVQxZG9VMVpGU1hwV1ZFbzBVekZaZVZOc1ZsTmhhelZYV1ZkMFlWWXhjRmRYYkdScVRWaENTRmRyWkhOaFIxWnpWMnhXVjAxWFVYZFpWRVpXWlZaU2NscEdhR2xpUlhCNVZsUkNhMVV4WkVkaVNFcFlZbXMxVUZWdE1WTmxWbHBZWlVVNWFGSnNjRlpWYlRWelYyMUZlRk5zVWxkTmFrWkhXbFZrVDFOV1RuTmhSbVJwVTBWS1RsWXhhSGRTTWtWNVZGaG9WbUpyTlhGVmFrbzBWa1pzY21GRlRtdGlSbXcwVjJ0b2ExVXdNVmRXYWxKWVlURmFkbFp0TVVabFYxWklZVVphYVZkSGFFMVdha0poWXpKT2MxcElUbXBTVkZaWVdXeGFTMDVXV25STlNHaHJUVlpHTkZZeU5VOWhWa3BIVjJ4a1ZWWjZWblpaVlZwelYwZFdSbVJHYUZOTlZuQktWMVpXWVdFeVJsZFRXR2hVWWtaYVdWbFVTbEpOUm1SWFdrVTVWMDFXU2pGVk1qRXdWVEpLUm1OR1ZsaFdNMUpvV2tSQk1WWXhaSEpXYkU1cFZsWndXVlpHV21Gak1EVlhWbGhzYTFORk5WZFpiRlpoWld4cmQxZHRPVmhpVlhCSldWVldVMVpyTVVkalNFcFhZV3RhY2xwRlpGTlNNa1pIVkcxb1RrMUZhM2hXYlhCTFRVZEZlVk5ZYUZkWFIzaFVXVmQ0ZDFkR2JIUk5WazVZVW14d01Wa3dWa3RpUmtwelYyeHNXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWa2RVYmxKb1VtMVNjRll3Vmt0U1ZscDBZMFZLVGxacmJEUlhhMmhQWVVaS1ZXSkdhRnBYU0VKWVZqQmFZVkl4Y0VWUmJYUk9Za1p3V1Zac1l6RlVNV1JJVTI1S1QxWnRlR0ZaYTFwaFYwWlNjbGR1U210TldFSkpWREZhYTFSc1NrWlhhMnhZVmtWS2RscEVSbHBsVms1eVdrZHdVMkV3Y0doWGJHUXdXVlpXUjJFemJHcGxhMXBZVkZaYVMwMUdiSEpYYlRsV1RVUkdNRmxWV25kV01rcFZVbFJDV2xaNlJsaFZNRnBoWkZaT2NrOVdaR2xXYTNCYVZtMXdRMkV4VlhoVldHaFlZbXhLVDFadGN6RmpWbHAwWlVkR2JGWnNjREJVVmxaclYwWktjbU5JY0ZkTmFsWjJWbXBHUzA1c1JsVlNiSEJYVWxoQ1RWWlVRbXRXTVVsNVVtdGtZVkpVVm5CWmExWmFaV3haZUZkdGRHeGlWbHBKVmtjMVMxUXhXbk5qUnpsV1lsUldSRmxxUmxOV01rWkdWR3MxYVZKdVFYZFhWRUpYVXpKRmQwMVlUbGhoTW1oWVZXNXdWMU5HV25KYVJYUlVVbXhhZWxsVlduZGhSVEZYWWpOd1YxWkZXbWhYVm1SUFl6RmFkVk50UmxOaVYyaDNWbTB4TkdReFRsZGFSbFpTWWtkU2NWUldXbmRUVmxWNVpVZEdXRkl3Y0VoVk1qRkhWMnhhUm1OSVdsWmhNWEF6VlRCa1YxTkdTbk5VYXpWWVVsVndTRlp0ZUd0T1JsVjRWVzVPV0ZkSGFGVlpWRW8wVjBac1dHUklXbXROVjNoV1ZXMHhNRlpHU25KT1dIQlhUVzVvZGxsV1pFWmxiRVp6V2taa2FWZEhhRzlXV0hCSFZERkplRmRzYkdGU2JXaHdWbXhhZDJWV1dsaGxSazVYVFZkU1NGWXlkRzlVYkZvMllrWmFXbUV4Y0ROV01WcFNaREpHU1ZSc2FGTmlSM2N5Vm14amVHSXhaSE5YYTFwWVlsZG9hRlZzV25kVlJtdzJVMnQwVkZJd1draFdWM2hUVlRGYVdWRnNiRmRoYTFweVZGVmFjMWRHVmxsaVJtUnBZWHBXV2xkWE1UUlRNVkY0VjI1T1lWSnJOVmhWYlRFMFpWWlplV1JFUW1sU01IQkpWbGMxYzFkSFJYbGhSa0pYWVd0R05GWXdXbGRqYkhCSFYyczFhV0pGV1hwV2JURjNVVzFXUjFkWWJGVmhNbEp2VlcweFUySXhiRlZTYm1SWVVtMVNlbFp0TVVkaFJURnlUVlJXVm1KWVVuSldiVEZMVjBkV1IxVnNWbGRTV0VJeVZrWmtORmxYVFhoV2JrcFZZa2RTVDFsclZscE5SbGw1WkVaa2FFMXJXbGhXUjNSaFlXeEtkR1ZIUmxwaVJrcElWbXRhWVdNeFpITmFSM1JUVmtaYVdGWnJaRFJVTVZKelYyNVNhMlZyV2xsWlZFWmhWa1pXVlZOclpGTmhla1pZVmpJeGMxVXhTbFZXYkdSWVZqTlNhRmRXWkU5ak1XUjFWRzFHVTFkR1NsVldSbVI2VFZaT2MxWlliR3hTTTFKWFZGVlNRMDVXYkZaWmVsWlhUV3RhZVZVeU5VdFdNVm8yVW14b1lWSldjRlJaTW5oM1UwWktjMVJyTldsaVYyaG9WbTE0YTJReFRYbFRXR2hZWW1zMVdWbHRjekZpTVZWM1drWk9WazFYZUhwV01qRkhWa1pLYzJORmJHRlNWMUYzVm1wR1NtUXlUa1ppUjBaWFZqQXdlRlp0TUhoU01rNXpWRzVTYUZKdFVtOVVWbWhEWWpGa1ZWSnRSbFZOYkVwSFZERmFhMWxXU1hsbFJsSlZWbXhhTTFkV1dscGxWMUpIV2tkb1RsSkZXa3BXVnpFMFdWWlNjMXBGV21wVFJVcFhXVlJHZDFSR1dYZFhiazVxVFZaYWVsZHJXbE5WTWtwSlVXeHdWMUpzY0ZoVVZWcGFaVlpPY21GR1dtbGlhMHBvVm0xNFlXUXdNSGhpUmxwWFYwZG9XVlp0ZEdGWGJHdDNWMjEwVmsxcmNFcFZWekExVjBaYVJtSkVVbGRXZWtaWVZXcEtUMUp0U2tkWGJXeFlVbXR3VmxacldtcGxSMGw0Vm10a1lWSnRVbGRaV0hCelZURlNWMVpVUmxoU2JWSjVWakl3TldGRk1WWmpTR3hWWWtad2FGWnNXbUZqTWs1SlkwWldWMUpXY0ZWV2JYQkxVakZLYzJORlpHRlNWRlp2VkZaYWNtVldXWGhYYkdSb1RWVnNORmRyYUU5WFIwVjRZMFpzV2xZelRYaFdNRnBYWXpGa2RWcEZOVTVXYkc5M1YyeFdhMDFIUm5KTlZteFNZVEo0YUZWc1duZGpiRnBJWlVVNVUySkZOWGxaTUZwclZHeGFkVkZzYkZoV2JFcE1WVEl4VjFJeFduVldiRlpwVmxad1ZWWnRNREZSTVZweldrWmtZVkpHU21GV2JURlRVMFpzY21GRk9WZGlWVlkxVmxkek5WWldXbk5qUjBaVlZqTm9XRnBGWkZOU1ZrWjBZVVUxVjFkRlNUSldNVkpEVlRGSmVGZFlhRlJYU0VKdlZXMTBTMWxXV25STlZrNVRUVmhDVjFkclZUVlZNREZ5VGxWb1dsWldjSEpXUjNONFZtMU9SVlpzWkdsWFIyaFZWbGh3UjFReVVrZFhia3BoVW0xU2NGbFljRmRrYkZwWVkwVTVhVTFXY0VoV01XaHJWakpGZWxWc1pGWmlWRVpVVmpGYWQxSnNjRVphUjJoT1VrVmFXRlpIZUZkaU1WbDNUVlpvYUZOSVFsaFZhazV2WVVaWmQxZHNaR3BOYTNCSVZqSXhiMkZGTVVoUFZGcFhZbGhDUkZkV1dscGxWbFp5WVVaV2FFMVlRbEpXYlRCNFZURmtSMkpJU21oU1ZUVlFXV3RrVTFac1ZsaE5SRlpYVWxSR1dGbHJVazlXVmxwelYyNWFWMkpVUmtkYVZ6RkhVakpHUjFac1pGZE5WWEJXVm0xd1ExbFdXblJXYTJSaFUwVTFWbGxzYUVOVU1XeFpZMFprVkZac2JEVmFSV1JIVmxVeFYySkVWbFpOYm1oWVdWVmtWMk50VGtkaFJuQnBVbXR3U1ZaR1VrZFdNazVYVTI1V1ZXSkhhRlJaVkU1RFdWWmtWMVp0ZEZOTlZsWTBWakZvYzJGR1NuUmxSbXhYWWxob1RGWkZXbk5qVmtweldrWmtUbFl4U1hoV2JHTjRUVVphUjFOWWFGUmlSMUpZVlcxNGQyRkdjRVZUYkdScVRWZFNlbGxWWkRCVk1ERkhZMFprV0ZZelVsaGFSRXBYWXpKRmVscEhhRlJTTVVwYVZsZHdRMVl3TlVkV1dHeHNVbXMxV1ZsclduZFhSbHAwWTBaT1YwMUVSa2xXVjNodlZtMUdjbU5GYUZaaGExcHlXVEp6TVZkSFNraGlSbVJPWWxkT05GWnRNWGRTTVd4WVVsaGtUMVpYVWxkV01HUnZWbFpzZEdSSVpGWlNiSEF3VkZaYVQyRkdTbk5YYWtKVllrWmFVRmxYZUV0ak1XUnhVVzFHVTFZeWFIbFdiWFJoV1ZkTmVWUnJWbEppVlZwVVZtcEdTMU5XV25GUmJYUlVUVlpzTkZkcmFFOWhWa3AwVlc1Q1YwMUdjRXhVVjNoclZqRldjbHBHVW1sV2JIQTJWbGN3TVZZeFZuUlRhMlJxVTBWS1dGbFVSbmRoUmxaelYyMUdhMUl3TlVkWGExcDNWakpLVjFOcmFGZFNiSEJvVm1wR1lXUkdUbk5oUjJoVFZrZDRXVmRYZUc5Vk1EQjRWVzVTYkZJd1duRldiWE14Vm14V2RHVkhkRlZpUm5CNldXcE9hMVl4V2paUldHaFhVa1Z3U0ZsNlJrOWtWbFowWlVaT2FWWXlhRzlXYlRFd1ZqRnNXRkpyWkZoaE1YQlpXVzF6TVZkR2JISmFSazVPVW14YU1GUldhR3RXTURGeVZtcGFWbFp0YUhKV01HUkdaVVprZEdGR1pGTlNWbkJWVjFod1IyRXhaRmhTYTJSV1lrZG9WRlJYTVc5WGJGbDRWMnhPVkUxV1dubFVWbFpyVjBkS1IxZHNWbHBXUlhCVVZtdGFjMWRYVGtaYVJtaHBVbTVDV2xaR1dtcE9WbHB5VFZoT1dHRnJTbWhXYkZwM1pXeGFjVk5yZEZoV2ExcDZWVmQ0YTFZeFNsZGpTR3hYVmpOQ1NGcEVSa3BsUjA1R1drZG9VMDF1YUhaWGJHUTBXVlprYzFkdVNsaGlXRkp6V1Zod1IxZEdXa2hrUjNSWVVtMVNTVnBWVlRWV01rcElWV3hTVjJGcldsUldha1ozVWpGU2MxVnNUbWxTYkd0NFZqSjRWMkV4U1hoWFdHUk9WMFZ3Y1ZWdGVIZFdNV3h6WVVWT2FGSnNjSHBXTWpGSFlURktjMWR1Y0ZwV1ZuQXpXV3RrUm1Wc1JuSk5WbVJYVFRCS1NWZFdVa3RWTVVsNFZHNVdWV0pHV25CV01HUnZaREZhY1ZGdGRHbE5WMUpZVmpJMVIxVXlTbFpYYmtKVlZqTm9TRlJyV2xabFIwWklUMVpvVTJKV1NrcFhWbFpxVGxaYVYxZHJXbXBTYkVwWVZGWmFkMlZzYkRaVGEyUlRUVlpLZWxsVldrOWhWa3BaVVcxR1YwMXVVbGhaYWtwR1pVWmtjbHBHYUdsaGVsWjRWbGQ0YTA1R2JGZFZiRnBZWW0xU1YxVnRlSGRsUmxaMFpVaGthRTFFUmxoWk1HaHZWakpLV1dGSVNsZGhhMFl6V2xaa1IxSXhTbk5hUlRWWFltdEtkbFpxUm1GaE1WSjBWbXhrVm1KcmNHOVZha3B2Vmtac2RHUkZkRlpTYlZKWlZGVm9iMkZYU2xkWGJuQlhUVzVvZGxsWGVFdFhSbFoxVTJ4V1YySkdWalJXVkVaaFZtMVdXRlZyYUZCV01taFlXVlJPUTA1V1draGxSMFpxVFZad01GVXlkR3RYUjBaeVRsWm9WMkV4V21oWlZWcDNVbXhhV1dGR1VsZGlhMHBLVjJ4V1lWUXhXWGhUYms1cVVsaFNXRmxyWkZKTlJteHhVMnR3YkZKdFVscFpWV1JIVlRGWmVXRklXbGRXZWtJMFZHdGFhMUl4Vm5OWGJVWlRZWHBXZVZkWGRHRmtNbFpIVm01U1QxWlViRzlaYkZaM1UyeFdXR1JJVGxkV1ZFWlpWbGR3VDFkc1duTmpSWGhhWld0YWNsWXhaRTlTTVhCR1RsZHNhVkpZUWpKV2JURXdWVEZKZVZKWWFGUlhSMmhXV1cxNFlWWnNiSEpYYTNScVVteGFlRlV5TURWWFIwcElWV3hvVjFZelVuSldhMVY0VmpKT1JtRkdjR2hOYldoTlZtcENhMU14V25OYVNGWlRZa1phV0ZSVVFYaE9SbHBWVVcxR2FrMXJOWHBYYTJoUFdWWktkRlZyT1ZwV1JUVkVWVEZhYTFaV1JuUlBWM0JPVm0xM01WWlhNREZUTVZwSVUyeG9hRkp0VW1oV2FrNVRUVEZhVmxkdVpGTmlSMUo1VkRGa2QyRldTblZSYWxwWFlsUkNORmw2Umxaa01ERlhWMjF3VTFKVVZsbFhWM2h2VVRGS1IxZHVSbE5oZWxaelZXMHhVMlZzWkhKWGJUbG9WakJXTkZrd1dtRlhSbG8yVVZob1ZsWkZjRTlhVlZwaFpGWldkR05IZUdoTldFSlhWbTB3ZUU1R2JGWk5WV1JxVWxad2FGVnNaRk5pTVZwMFpFaGtiRlp0ZEROV1YzUlBWakF4VjJKRVdsZFNiRXBJVm1wQmVHTldTbkpsUm1ScFVtNUNUVmRyV21GaE1rMTVWR3RvYUZJeWFFOVdNRlpMVFd4YWNWSnNUbE5OVjNoWVZURm9jMVp0UlhsVmJGWmFZbGhOZUZsVldsZGpNVlp6V2tkc1RsZEZTbHBYYkZaaFpERlNkRk5yWkdsU1JrcFlWbXBPVTFWR1duRlJXR2hxWWxWd1JsWlhlR3RoVmtsNVlVUmFWMkpZVW5KVmJURlhWMFpLY2xwSFJsTmlhMHAyVmtaa05GTXdNWE5YYmxKT1ZrWktZVlpxUmt0VFZscDBaRWM1VmsxcldUSldiWE0xVmpKS1ZWWnJVbGROYm1oeVdYcEdZV1JIVWtkVWF6Vm9UVmhCTVZacldtRlpWMFY0V2tWb1ZHSnNTbk5WYlRGdlZqRnNXR042Um10aVIzUTFXbFZvVDFZeVNrbFJhMmhZWVRKU00xWkhlRnBsUms1eFYyeG9WMDB4U205WFZsSkxVakZPUjFOc2JHaFNNMEpVVld4b1ExZHNXblJqUlRsU1RWWktTRlp0TlVkV1IwWTJWbTVPVm1KWWFFeFVWbHBoVTBVeFdFOVdXazVTUlZsM1YxWldZVll4WkVoVGEyaFZZV3hLVmxsVVJuZGpiRlp4VW01a1UwMVlRa2xWYlhoUFZURmFXVkZxVmxkaE1YQnlWR3RhVG1WV1duVlViR2hZVWpOb2VWWlhNSGhWTVZsNFZXeG9hMU5IVWxWVmJURXdUVEZzVmxacVFsZE5WbkI2V1RCb2QxZHJNVWRUYkVKWVZteHdhRmw2U2s5U1ZsSnpWMjFzV0ZJeWFIWldiVEUwV1ZaTmVWVnJhRk5oTWxKb1ZXcEtiMVF4VWxaV2JIQk9VbXh3TUZwVlpFZFhiRmwzWWtSV1ZtSkhhSFpXTUZwclUwZEdSMVpzY0dsWFJURTBWMVJHWVZZeVVraFdhMXByVW0xU1QxWnROVU5PVmxwMFRVaG9VMDFyV2toVk1qVlRZVEZLUjFkdFJtRldNMDE0V2tkNFlXTldSbGxoUm1oVFlrWnZlRmRYZEdGV01rWlhVMjVXVW1KdGVGaFphMXBMVkVaV2RFMVdaR3BOVlhBeFZrY3hkMVV5U2xkVGJtUlhZbGhTV0ZVeU1WZGpNWEJKVkd4a2FWZEdTbFpYVjNoaFdWWmtSMWRZYkU5V2JWSllWbXBDZDFOV2JGWmhSVTVZWWxWV05GWXljRTlXTVZwWFkwZG9ZVkpYVWxoVk1GcExaRWRTUms1WGFHeGhNVll6Vm0weGQxTnJNVmRXV0d4VVlUSlNWVll3WkZOWFZteDBZM3BHV2xadGVGWlZiVFZyVkdzeFYxTnNaRmROYWxaeVZtcEtTMVpzWkhKaVIwWlRWakZLTWxac1VrdFRNVTVYVW14c1lWSnRVbkJWYWtaSFRURmtXR05GWkZwV01EVjVWRlphYTJGR1NYbGhSbEpXWWtaS1dGWXhXbUZTTVZwMFVtMTBUbFl6YUZsWFZFSmhZakpLUjFOc2FGWmlhMXBoV1d0YVlXRkdWWGRYYlhScVlraENTVlF4Wkc5Vk1WcEdVMWh3VjFaRmJ6QlZla1phWlZaT2MxWnNUbWhoZWxaWVYxWmtNRmxXV1hoalJtUllZa2RTY1ZSV2FFTlRSbVJ5V2toT2FGSXhXbnBXTW5oWFZqQXhXRlZZWkZwV1JWcFhXbFphVTJOc2NFZGhSMnhwVWxoQ05WWnNVa05oTVZWNFdrVmthVk5GY0ZsWmJYTXhWVVpXZEUxV1RteFdiSEJaV2xWVk5XRkdTbk5qUmxwV1lsUldlbFl5TVVabFJrNXpWV3hrVG1GcldraFhiRlpyVkRGT1YxUnVUbWhTYlZKd1ZUQldTMVJzV1hoaFNHUlRUV3RXTlZaR2FHOVdiVXB5VGxoR1ZtRnJiekJXYTFwelkyMUdSbFJ0ZEdsU2JYY3dWakowYjJFeFZYZE5WbVJYWVd4S1dWbFVSbUZrYkZwMFRWVmFiRll4V2tsWlZWcGhZVlprU0dGRk1WZGhhMHBvV1hwS1QyTXhjRWxVYlhCVFZrWmFXVmRYZUdGVE1EVlhWMjVTVGxOSGFISlVWbHBIVGtaWmVVNVZPV2hXYTNCSVZqSjRhMVpXV2paV2JscGFWbFp3ZWxZd1pGZFNiVkpIWVVaT1RsWnVRa3RXTVZwWFdWZEZlVkpzWkZSWFIyaFZXV3RhWVZkV2JGVlRiRXBPVW0xU1dGZHJWVFZXTURGWFUycEdWazFxUlhkV1ZFcExVbTFPUjFac2FGZE5NVXB2VjJ0U1FrMVdXWGhhU0VwWFlrVTFjRlpzV25kWFZscEhWMjFHYWsxRVZsaFdiR2h6WVRGT1JrNVdaRnBpUmxwb1dsZDRjbVF4WkhSUFZtaHBWbGhDU2xkV1ZsZFZNVnB5VFZWa2FsTkZjRmhaVjNSaFkyeHdSbHBHVGxOTmExcElWa2N4YjFSck1VWmhNMmhYWWxoQ1RGUlZaRVpsVms1WllVWmtXRkl6YUZWWFZtUTBaREZrUjJKSVVrNVdhelZaVlcxNGQwMVdhM2RXYTNScFVtdHdlbFl5ZUhOWGJWWnlUbGhhVjJGclJqUldNRnBYWXpKT1IyTkdaRmRpYTBsNVZqRmFZVmxXVG5SV2EyUlZZbXhLYjFWdE1WTmpSbGwzVm10MFUxWnNjREJaTUZaTFZHeGFjbUpFVWxoaE1taFFXVlZhUzFaWFNrZGhSbkJZVTBWS1dWWnFRbUZaVmtsNFkwVldVbUpZVWs5WmExcDNWMVphYzFsNlJsVk5WMUpKVlRJMVMxUXhXblJsUjBaYVlURndhRll3V2xOamJHUjFVMjEwVGxkRlNrcFdSRVpoWVRGU2MxTnJXbGhoTW5oWlZtdFdTMlJzY0VWU2JIQnNWbXMxZVZkclpIZFZNa1YzWTBkb1dHSkhVWGRYVmxwWFVqSkZlbUpIY0d4aE1YQlpWa1phWVZNd01VZGlTRXBZWWtVMVYxUldXbmRYYkZaWVpFaGtWMDFyY0ZaVmJGSkRWMnhhTmxKc2FGWk5SbkJvV2taYVQyTnJPVmRhUjJ4WFlUTkNhRlpxUm1GVk1VMTRWbGhvV0dKSFVuQlZNRnBMWTJ4VmQxcEdUbXBXYkhBd1dsVmFhMVJyTVZoVmJteFhWak5vVUZZd1drdGpNazVGVVcxR1YxWnVRbTlXYlRCNFV6RmFWMWR1VmxSaVIxSndWVzAxUTFSV1pISldiWFJYVFZWc05WVnRkR3RaVmtwVlZtNUNXbUV4V21GYVYzaGFaVVprYzFSc1RrNVdNMmhhVm10ak1WUXhiRmRVYTFwWVlrWktZVmxVU2xOa2JHeHhVbXhPVjAxcldrZFdSekUwVmpKS1YxTnNiRmRoYTJ3MFZXcEtSMUpyTVZkWGJXeFRVbXR3V1ZaWE5YZFdNVlpIWWtaa1dHRXpVbkpWYlhoaFRWWldXR1ZIZEdoU1ZFWllXVEJXTkZZeFNuTlhiV2hZVm0xU1QxcFZaRVpsYlU1SVlVWk9hVlpyY0ZGV2JURTBZVEF3ZDAxVlpHRlNiRnBUV1d0a1UyTldVbGRYYms1UFZteFdOVnBGWkRCaFIwcEdUbFZrVmsxdWFIWldiRnBoVmpKT1NHRkdaRk5XYmtKdlYxaHdSMkV5VWtkVGJsSnJVbXMxVDFWcldtRlRWbHB4VTJwQ1dsWnNWalJXVnpWUFYwWmtTR0ZHVmxwV1JXOHdWakJhYzFkSFVrbFhiWFJPVmpOb1YxWlhNSGhOUmxwSFUyNUtUMWRJUWxoVVZ6VnZaR3hzVjFwRldteGlSVnA2VjJ0YWEyRldaRWhoUnpsWFYwaENTRlpFUmtwbFJtUnpZa2RHVTJKWGFIZFdiWGhoWkRKV1YxZHNhR3hTYXpWWVZGWmtVMU5HV1hsa1J6bFZZa1p2TWxscldtRlhiVVY0WTBST1YwMVdjRk5hUkVwSFUxWlNjMkZHVG1sU00yTjVWbTE0YW1WSFNYaGFTRTVZWVRGd1dWbHNaRzloUmxaelYyNWtWbEp0ZHpKVk1uUXdWa1pKZDFkcmFGZFNNMmhRVm1wR1MyTXlUa2RpUm1ScFZrVkpNRlpIZEdGak1XUkhWbXhzYVZKdFVuQlpXSEJYVjJ4a1dFMVVVbFJOYXpFMFZtMDFSMVpYU2taT1dFWlhZbGhvVEZZd1dscGxWMUpGVVcxc1UwMUlRa3BXYkdNeFl6RlpkMDFZUmxOWFIxSmhWbXhhZDJGR2EzbGpla1pYWWtoQ1NGWXljekZoUjBWNFkwVndWMkpVUmpOVlZ6RlhVakZrV1dKR1ZtaE5iRXAyVmxjd2VGVXlTWGhpUmxaVFltMVNXVlZ0TVZObGJGcDBUVlZrYUZKVVJubFVWbEpYVm0xS1dWVnVTbGRpVkVaTVZqQmtSMUpyT1ZkalIyaE9WbTA1TmxaclpEQlpWbXhZVkZob2FsSlhlR2hWYlhoTFZERnNWVk5xVGs1U2JIQjRWVzB3TldGVk1WZGpSRUpXVFc1U2NsbFhlRXBsVjBaSFdrWndhVkl5YUZCWGJGWmhWMjFXUjFwSVRtRlNNMUpVVkZaYWQxTldXWGxrUmxwT1ZteEtlbFl5TlZOaE1sWnlWMnhzV2xaRldtaFdhMXBYVmxaT2NscEdUbWhsYTFwWlZtcEplR014VlhoVGJGWlhZa2RTV1ZacVRsTmhSbVJYV2tVNWFrMVhVakZXUnpGSFZURmtSMU5zVmxkU2JWSTJWRlphVDJNeFdsbGlSM2hUVFRGS1dGWkdWbE5STURWWFlrWmFXbVZzV2xoVVYzUmhaVlpWZVU1VmRGZE5WbTh5VlcxNGIxbFdTbGRqUmxKYVRXNW9NMVV3V2t0ak1WSnlUbGRzYVZZeWFHOVdiVEUwWVRKUmVGUlliRlJYUjJoWldXMXpNVmRXYkhSamVrWnBUVlpXTTFkcldrOVdhekZZWlVod1YwMXFSa2hXYTFwTFl6Sk9SbUpIUmxOV01VWXpWbTF3UjFOdFVYbFVhMXBwVWpCYVdGWnFRWGRsUmxwMFRVaG9VMDFyTlhwV1J6VlRZVVpLZEZWdE9WVldiV2hFV1dwR2ExWldTblJTYkZaT1lrVndTRlpFUm1GaE1XeFhVMWhzYkZKc1NsWldiWGhoVFRGa1YxZHNjR3hXTVVwSVYydGtiMVJzU2taWGEzQlhWbnBGTUZkV1dsTmpNWEJHVjIxd1ZGSlZjRmhYVmxKSFpERlNSMWRZWkZoaWF6VnhWRlphWVdWc1pISlhiRTVXVFd0d1NsVlhlSGRXTVVwelkwWm9WVlpXY0dGYVZscFBZMjFHUjFkdGJHbGhNSEJ2Vm0weE5GbFhVWGROU0docFVteHdXRll3Wkc5WFZscDBaRWRHV0dKSGRETldNakV3Vm1zeGNtTkZjRlpXZWtFeFZqQmFZVkp0U2tWVmJHUlhaV3RhV1ZaWGNFdFVNVXAwVTJ0a1dHSlhlRmxWYlhSM1ZteGFjbGR0Y0d4U01HdzBWbTEwYTFsV1NuUlZiR1JhVjBoQ2VsWlVSbE5XTVZwVlVteG9VMkpXU2pWV2FrbDNUbGRHUmsxV1dtcFRSM2hXV1d0YWQyRkdXbk5YYlVacVRXczFTbGt3V2xkV01VcFhZMFpXVjJKWVFreFZha1pMWXpKT1JscEhSbE5XUmxwMlZrWmFZV050VmxkWFdHaFlZa2RTYjFSV1ZuTk9SbVJ5WVVVNVdGSXdWalJaTUZwelYyeFplbFJZYUZkTlJuQllXWHBHYTJSV2NFWk9WVFZYWWtjNU0xWXllRmRoTURGSVVtNUtUbFp0ZUZOWlZFbzBZVVpXYzFkdVpHcGlSbkJKV2xWVk5WVXlTa1pPV0d4YVRVWndjbFpIZUdGa1ZrWnpZa1pvVjJKRmNFMVdWRWw0VmpGSmVGZHVWbGRpUmxwd1ZteGFkMVpXV25STlJFWlNUVlp3ZWxkcldtdFpWa3BIVTIxR1YySlVSbFJWTUZwelkyMUdSazlXWkdsV1Zsa3hWbXhrZWs1V1dsZFhiazVxVWpCYVZsWnFUbTlYUm5CR1drWk9VMVpyV2pCWlZWVXhWakZrUmxOVVNsZE5Wa3BFVmxSR1NtVkdaRmxoUmxKWVUwVktkbFpYTVRCVE1XeFhWMjVTVGxack5WUlVWbWhEVmpGa2NsWlVWbFpOUkVaNVZHeFdiMWRzV2xkalNFcFhVak5PTkZadE1VOVNWbHB6V2tkc1dGSXlhRlpXYkdoM1VqRlJlVlZyWkZoaWEzQm9WVzB4VTJOR2JGbGpSbVJyWWtad1dWa3dWVFZoVlRGWFkwVm9WMDFYYUhKV2FrcEdaV3hXYzFwR1dtbFdSVnBWVm1wR1lXUXhTbk5qUlZwaFVqSm9UMVZyVm1GWFJscElaVVprYVUxV2JETlVWbHB2WVVaT1NWRnNhRlpoYXpWMldWVmFXbVF4WkhOYVIzQk9ZVE5DU1ZacVNYaGlNa1pHVFZWb1VGWkdjRmhaYkdoRFVrWmtWMWRzY0d4V2JGcDVXVlZhVjJGRk1WbFJiRXBYWWxSQ05GWlVSbXRTTWtwSlUyMW9VMVpVVmxGWFYzUnJWVEZhYzFac2FFNVNSbHBZVld4U1IxZEdiSEpWYXpsWFZteHdlbFl5TldGV01rcFZVbXRrWVZaNlJraFZha3BIVWpGYWMxcEdaRTVXV0VKWFZtMHhkMUV4YkZkWGJsSlhZVEpTYUZVd1ZURldiR3h6WVVWT1ZVMVhlRnBaTUZwclZrWmFjMkpFVm1GU1YxSklWbXhWZUZZeVNrVldiRnBPWW0xb1dWZFdWbXRXTWs1MFZHdGthRkp1UW5CVmJYUjNVMVphUjFWclpGZE5helZZVlRJMVYxWlhTa2hoUmxKYVZrVTFSRmRXV210V01WcDBaRVpPVGxac1dUQldha1p2WXpKR1IxTnVVbXhTYlhoWVdXeG9iMVJHV2taWGJrNXFWbXR3ZWxkcldtdFViRmw0VTFob1YySkhUalJVVlZwaFVqRk9XV0ZHVW1sU01VcFpWbGN4TkdReVJrZGpSVlpVWWtkU2NWUldaRk5sYkd4V1drUkNWazFFUmtoWk1GcHJWMFpaZWxWc2FHRlNSWEJZV1hwS1JtVnNjRWhoUmxKVFRWVndZVlpzWkhkUk1WbDNUbFZrVjFkSGVITlZiWE14VjFac2NsZHVaRmhTYkhBd1dUQmFUMVl3TVVWU2EyeFhWak5vZGxadE1VZGpiVTVHWVVaYWFHRXhjSGxYVkVwNlRWWmtTRk5yYUdsU2JWSlBXV3hrVDA1R1duUk5XR1JUVFZkNFdWVnNhR3RVTVZwWVZXeGtWMDFIVW5aV2JGcHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSa2RUYms1WVlXdEtWbGxyV21GVlJteFlaVVYwYWsxWFVuaFZWekZIVlRGWmVXRkliRmRpV0ZKb1YxWmtUbVZXVW5KV2JFcHBWbFp3VlZadGNFZFRNVTVYVjI1R1VtSllVbFZVVmxwelRrWmtjbUZGT1doV2EzQXdWbGMxUTFZd01VZGpSWGhWVmpOb2NsWnFSbGRqYkhCSFZXMXNWMkpJUVRKV2JHTjNUVlpaZUZadVVsUmhNbEp4VlRCV1MxZEdiRlZTYm1Sb1VteGFlbFl5TVVkaE1VbDNUbFZrV0dFeGNETldha3BMVmpGT2NtRkdaRk5pU0VKdlZtMXdSMWxYVWtkVWJrNW9VakpvVkZaclpEUlhWbVJZWlVjNVZrMUVRalJXVnpWVFlrWkpkMWR1UmxkaVdFMTRWbTE0VjJSSFZraGtSbFpwVW01Q05sZFhjRTloTVZsNFYycGFVbGRIYUZoVmExWjNVMFpzTmxKck9XdFdiRm93V2xWYVQyRldXWGxoUnpsWFlsUkZkMVpxUm5OWFJrcHlXa1pvYUUxWVFscFhWekY2VFZaa1IySklTbUZTYXpWUFZXMTRZVTFHVWxkaFIzUlhUVVJHZVZadGNHRldiRnAwWVVoS1YwMUhVa2RhVlZwclpFZEdSMXBHVGxOV2JrSldWakZvZDFJeVJYaGFSbWhUWVRKU1YxbHNaRFJYUmxwMFRsVk9XbFpzY0RCVVZsSkRWakF4VmsxVVZsWmlXRkp5VjFaYVMyUkdWblJoUmxwcFVqRktWVlpxUm1GV01sSklWV3RzWVZKdGFIQlZhazVTWld4YWNWTnFRazVTTUZwSVZqSTFTMkZXU2tkalIwWlhZa1p3TTFwWGVGcGtNV1J6WTBkNGFWWldjRXRXYWtvMFlURlplRk5zWkdwVFIzaFlWbXBPUTFOR2NFVlNhM0JzVWpBMVIxbFZXazloVmtwVlZtNWtWMkpVUlhkYVJFRXhVakZrZFZOc2FHbFdWbkIyVmtaYVlWWXdNSGhWYkdSWVlsaFNXRlJYZEhkbGJGVjVUbFU1VjJKVmNFaFZNalYzVjIxR2NsZHRhR0ZTVjFKVVZURmFVMk5yT1ZkVWJXeFRZa2QwTkZadGRHdE9SMFp5VGxaa1dGZEhVazlXYlhoM1kxWlZkMkZGVGxwV2JFcFhWMnRqTlZaV1NuTmpTR2hXWWxSR1NGWlVTa3RXYXpWV1lVWndWMVp1UVhwWFYzUnJVbTFXYzFKdVNrNVdiVkpZVkZSQ1MxTldaRmRWYTNSV1RWVnNORlpITlZkV1YwcEhZMGhDVm1KR1NsaFdNVnBoVjBVeFZWVnRkRTVXTTJoWlZtcEpNVlV5UlhoVFdHUllZbFZhV0Zsc1VrWk5SbGw0VjIxR1YwMXJXa2xhUlZwWFlWWktkVkZZWkZkaVIxRXdXV3BHYTJSR1NsbGlSbHBwWWtoQ2FGZHNaREJaVm1SSFlrUmFVMkp0VWxSVVZscExaV3hzVmxkck9XaFdhM0JhVlZjeFIxWXdNWFZWYkdoWVZtMVNSMXBWV2xkWFYwWkhWVzFzYVZKWVFqVldiR1F3Vm1zeFYxcEdaR2xTYkZwVldWaHdWMVF4V25SbFNFNU9UVlpzTlZwRlVrTmhSMFkyVW01c1ZXSkdXbWhXYlhoYVpXMUdTVk5zWkdoaE1GbDZWMnhhYTFJeFNYaFRiazVoVWxSV1dGbHRkRXRrYkZweFVtMUdhRTFXU2pCV2JYaHJWbTFLY21OSE9WWmhhM0IyVm10YWMyUkhVa1prUmxwVFlsWktXbFpHVm05aU1rWllVMnhrV0dKdVFsaFVWelZ2Wkd4c1dHVkZkRmhTYkZveFZUSjRWMVl5U2tkalJGcFhVak5vYUZacVNsTlRSbFp5WVVkMFUySldTbGxXUmxaaFkyMVdWMWR1VWs1WFNFSlFWbTB4VTAxR1ZYbGtSemxYWWxWd2VWWXlNVzlXTWtwSFkwUk9XbFpXY0ROVmJYaGhWMWRHUjFwR1pHbFNiVGt6VmpGYVYxWnJNVmRXV0doVVlrZFNjVlZzYUVOWFJteHpZVVZPVkZKdGVIaFZNblIzWWtaS2RGVnVjRmhoTWxKSVZsUkdXbVZYUmtsWGJHUlhUVEJLVFZkWGNFZFhiVlpJVTJ0c1ZHSlZXbFJaV0hCWFYxWmFXRTFVVW10TmJGcElWbTAxVTFReFdsVmlSemxhWWtaYU0xVXllRmRYUjFKSVQxWmtUbFpYZHpKWFZsWnZXVlpaZVZKdVNtcFNXR2hZVkZaYWQwMXNjRmhsU0dSVFRWaENTRlpITVhOV1JrcFdZMFJLVjJKVVJYZFdWRVpPWlVaT1dXSkdWbWxoTTBKUVZtMHdlRlV5UmtkV2JrWlZZVEExV0ZWdGVHRmxiRnAwVGxkMFYwMUVSbGhaTUZKRFZsWmFjMU5zVWxkaE1WWTBWbTB4VDFKdFJrZGFSVFZwWWtWdmVWWXhXbXRsYlZGNVZteG9VMkV5VW05VmJYaGhWMFpTVlZKcmNHeGlSbkJaVkZaU1UxZHNXWGhUYTJ4WFlsaFNjbGRXV2twbFYwWkhZVVp3VjFKWE9UWldSbFpoV1Zaa1JrMVdiR0ZTYkZwUFZtMHhNMDFXV2xoTlJFWlVUVlp3U1ZVeWVHOWhSa3AwVlcxb1YyRnJOVlJVVkVaaFZteGtkVnBHVG1sU01VbzFWa1JHYTJReVJsZFRibFpTWVd4d1dGbHNVa05PUm13MlVteGFhMDFFUmxoV01qRjNWVEZLVlZac2JGaFdNMmgyVlZSR1MxSXhaSFZTYkU1b1pXeGFlbFpYTUhoVk1sWnpXa2hLV0dKVWJHOVdha0pYVGtacmQxZHRSbGhTYkc4eVZWWm9iMVpzV2taalJUbGhWbFp3YUZwR1dsZGtSMUpIVld4T1YxSnNjRk5XYlhocVpVVTFTRlZZYUZWaVIxSlhXVzF6TVZkR1duSlhiVVpZVW0xNGVsWnROV3RXTURGWVpFUk9WMkpVVmxCV2FrRjRWakpLTmxOc1dsZGlSWEJKVm0xd1FtVkhVbGhTYTJob1VteHdjRll3VlhoT1JscDBUVlJTVjAxck1UUlhhMmhMVkRGYWRGVnVRbHBXUlVveVZGWmFZV1JGTVVsaFJUbFRZbGhvV1Zac1dtOWpNVnBZVTJ0b1ZtSkhhR0ZaYkdodlZFWnNjVkpzWkdwTlZscDZWMnRrYzFSc1pFWlRiSEJZWWtaYWFGbFVSbE5qYXpGWFdrZHdVMUpWY0ZkV2JYaHJZakpTYzFkcmFHeFNXRUp5VkZaYWQyVkdXbGhsU0dSb1VsUkdXbFZYTlhOV01rcFpWVzFvV2xaRldsQlZNRnBoWTIxR1IxRnNaR2xUUlVvelZqRmplRTFHVFhkT1dFNVlZbXhLVDFacldrdFpWbHB4VVZSR2JHSkdiRFZVYkZZd1lVVXhWbU5JY0ZkTmJtaFVWakl4Um1WWFJrWlZiR1JPWW0xb2VWZFljRWRaVjFKSVZXdGtWV0Y2Vm05VVZtaENUVlphY2xkdFJscFdNRlkwVjJ0V2IxWkhTbk5UYms1V1lsUkZNRmRXV21GamJGcDFXa1prVTJKclNrcFhiRlpyVWpGYVIxTllhRmhoTW5oWFdXeG9iMk5zV25GVGExcHNZa1ZhZWxkcldtdFdNa3BYVWxoa1dGWnNTa2hXTWpGWFVqRlNkVlJ0UmxOTk1FcFZWbGQ0YjFFeFpITlhibEpxVWxSc1UxUldXa3RUUmxwMFRsVmtWMUl3V1RKV2JUVlBWbTFLV1dGRmVGVldiSEJvVlRCVmVGZEZPVmRYYXpWb1RUQktURlpzV21wTlYwVjRWMWhzVkdKSGVGTlpWRTV2V1Zac1dHUkhSbXBpUmxwNFZXMDFhMVV3TVhKWGEyeGhWbFp3VUZsclpFdFhWMFpIWVVaa1RsWXhSWGRXTVZwaFl6RlplRlZ1U21GU2JXaFpWV3BLYjJSc1dsaGpSVGxXVFZkU1dGWnROVWRWYlVwMFZXeFdXbUV4Y0doV01WcFRZekZhY1ZGc1pFNVdia0kyVjFSQ2IyUXhaSEpOVldSVVlrVktXVlp0ZUhkaFJtdzJVMnM1VTFac1NucFdNakZ6VjBaSmVXRklXbGRpVkVVd1YxWmFUbVZXVm5KaFJrNW9UV3hLYjFaWGNFdGlNVkY0Vld4YVYySklRazlWYlhoM1RVWndWbHBGWkZoaVJtd3pXV3RTVjFadFNraGhTRnBYVFVad2NsVXdaRWRTTVZwelkwZHNXRkpVUlRCV01WSkhXVlpaZVZWcmFGZGhNWEJ5VlcweFUxUXhXblJPVlU1UFZteHdNRlJWYUc5Vk1ERnlWMnRvVmsxcVZsUlpWRVpMVWpGa2RGSnRSbGROTURFMFYydGtORmxYVGxkU2JHeG9VbTFvVkZsclduWmxSbVJZWkVkR1YwMXJXbGhWTWpWWFZXMUtkR1ZHYUZwaE1YQk1Wa1ZhVjJSRk1WZGFSM0JPVmxoQmVGWnJZM2hrTVZWNVUyeGtWR0p0VWxoWmJHaFRWMFpWZVUxV1pHcE5XRUpLVmtkNGEyRldaRWRUYkZwWVZqTm9hRmRXV210U01XUlpZa1U1VjJKV1NsbFdiWEJEWkRGT1YySkdXbWhTVlRWWldXdGtVMU5zVmxobFJ6bFhUVVJHTVZsVmFFdFdNREZJVld4b1ZrMUdWVEZXYWtaclkyczFWMXBIYkdoTlNFSm9WbTB3ZDJReVVYZE5WbVJVVjBkb1dGWXdaRFJXVm14eVYyNWtXRlp0ZUhsV01qRkhWakF4V0dWSWNGcFdWMDB4V1d0a1MxSXhUblZqUm1ST1lXeGFlVlp0Y0V0VE1WcHpXa2hLYVZJd1dsUldiVFZEWlZaYWNscEVVbFJOVlhCNlYydG9UMkZHU25SaFJtaFdZa1phTTFscVJtdFhSMDVHV2tkb1RtSkZjRWxXVkVreFZqRmFTRkpxV21sU2JXaFhXV3RhUzFkR1dYaFhiVVpUVFZad01GVnRNVEJVYkZsNllVWnNXRlpGU21oWmFrcExVakZPYzJGR1dtbGhNWEJvVjFkMFlWbFhSa2RXV0dSWVlsaFNjVmxyYUVOVFZsRjRXa2M1VmsxV2NFZFZNV2gzVmpGYVJtSjZRbFpsYTFwaFdsWmFUMk14V25OVWJXaG9aV3hhV1ZZeFdtdE5SbXhYWWtaa2FsSnRVbGxaYTJSVFkxWlNWMkZGVGxSU2JIQXdWRlpvVDJGR1NYaFhibkJYVFc1b00xWnFRWGhYUmxaVlVXeHdWMUpWVmpSV1YzQkhZVEpPYzJORlpGaGlWM2hVVkZaV2QxZHNXWGhaTTJSc1VteFdORmRyVm10aFZrNUdZMFpzV21KWVRYaFdWVnBYWkVVeFYxUnRlRmRpU0VKYVYyeFdWazVYUmtkVGJrNXFVbXh3VjFsc1VsZGxiRmw1VFZWYWJGSnJOWHBXVjNoclZHMUdjbGRyYUZoaVJscHlWa1JHVDFZeFVuVlViV2hUWWxaS2QxWlVRbGRUTVZKelYxaG9hRk5IVWxSVVYzUlhUbFphUjJGSE9WZGlWWEI1Vkd4b1IxWnRSbkppZWtKWFlURndlbGt5TVVkU2JGSjBaRWRzVTJKWVkzZFdha293WWpKRmVGWllaRTVXYlZKWVdWZDRTMWRHVWxkYVJ6bHJZa2Q0V1ZwVlZqQlhSa3B6VjI1d1YwMXVhRE5aVlZWNFYxWkdjazFXWkdsWFJrcHZWMWh3UzFReVRYbFVhMXBYWWtaYWIxcFhlR0ZYVm1SWVpFYzVVazFWTlhwWGEyaFBWakpLVmxkdFJsZGlXR2hJVkd0YVdtVkhSa2hrUm1oVFRVWlpNVmRzVm1GaE1WcFhWMnBhVjJKR1NtRldiRnAzWld4WmQxcEdaRk5pVmtwSVZrY3hjMVV4V2tkV2FrNVhUVlp3V0ZkV1pFWmxWa3B6V2taU1dGSXlhRlpYVjNSaFdWWmtSMWR1U2xkaE0xSnZWVzB4VTFkR1pISldWRVpwVW10d01WVlhkSGRXTVZsNllVWkNXbFpzY0V0YVZWcFBZekZHYzJGR1pHbFdNbVEyVm0weGQxSXhVWGhYV0doaFVtMTRjRlZxVGxOV1JsSldWMjVrV0Zac2NFaFdNakZIWVdzeFJWWnNhRmRpUjJoNldWUkdUMUpyTlZkYVJuQnBVbXh3YjFkc1pEUmpiVkY0V2toU1VGWnRhSEJXYkdoRFUyeGtWMVpzWkZaTlZuQjVWRlpXYTJGc1RrWmpSbWhhVmpOU2FGa3llSGRTYkhCSFZHeE9UbUV4Y0VsV2EyTjRZakZTY2sxVldtaE5NbWhZV1ZkMFlXRkdXbkZUYTFwc1ZteGFXbGxWV210WFJrbDRVMnhDVjJGclNtaFhWbVJLWlVaYWRWVnJOVmRTYTNCYVZsY3dlRTVHWkZkalJWcFhZV3RLV1ZWdGRIZGxiRmw0Vld0MFYySlZjRnBXUmxKSFZqRmFSbEpxVWxkTlJuQllXVEZhUzJNeGNFZGFSM2hvVFZaWmVsWnRNVFJWTVVaMFZWaHNWMkV5VWxaWmJYTXhWa1pzY2xwR1RsaFNiRXBXVlZkME1GVXhXbk5qUkVKYVRVWmFURlpIZUdGamJVcEZWV3hvYUUxdGFGRlhWbFpoVXpGYVdGTnJaR2hTYmtKWlZUQldTMWRXV25GUmJVWmFWbXRzTkZrd1ZsZFZiVXBaVldzNVdtRXhjRE5XTVZwaFl6RnNObEpzVms1V01VcEtWbFJKTVZNeFVYaFhibEpzVWpCYVlWbFVSbmRoUmxsM1YyeE9hbUpIVWpGVk1qRXdWR3hrUmxOcmNGZFNSVnBvV1ZSR1UyTXhUbkpYYkdob1RXNW9XbFp0ZEZkVE1sSnpZMFZXVTJKSVFuTldiWE14WlZaa2NscElaRlpOYTFZeldUQmtiMWRIU2toVldHUllWbXh3V0ZWcVNrWmxiVXBJWTBkNGFFMVlRbHBXYTFwaFdWWk5kMDFWWkdsVFJYQlpXV3hTYzFZeFVsWlZhMlJPVW0xNFYxWXlOV3RXTURGeVkwWmFWbUpHU2tSV01uaGhUbXhLYzJGR1drNVNia0p2VjJ0YVlWUXlUbkpQVm1SaFVqSjRXRmxVVGtOWlZscDBUVmhrVWsxclZqUldiR2h2Vm14a1NHRkdiRnBpV0doTVZrUkdZV1JIVGpaU2JYQlhZa2hCZDFkc1ZtdFNNa3BIVjI1T2FsSkZTbFpXYlhoaFkyeFpkMWRyZEdwaVZUVktXVEJhYTFSdFJuTlhha3BYWWxoQ1NGVjZRVEZqTVVwelZteE9hVk5GU2xsV1YzaHZVVEZTVjFkc1ZsSmlXRkpZVkZaV2MwNVdWblJrUjNSYVZtdHdWbFp0TlVOWGJVVjRWMjFHWVZZemFHRmFWVnByWkVkU1NHVkhiRmRpU0VKTFZtMTBhazFXVFhoVldHaFlZbXMxY1ZWdWNITldNV3h6Vld4a1UxSnRlSGhWYlhoUFZqQXhjbGRyWkZkU00wMTRXVlphUzJSV1JsbGFSbWhYVWxWd1dWWlljRXRTYlZGM1RWWnNWV0pIYUc5VVZ6RnZWMVphV0U1WVpGZE5WVFZJVmpJMVMxbFdTbGxWYkZaV1lsaG9hRnBYZUhOV2JHUjFXa2RvVTFaRldsbFhWM0JQWkRGWmVGZHJXbGhpVjJoaFZtdFdZVmxXY0ZaWGJVWnJWbXMxTUZWdGVFOWhWbGw1WVVST1YySlVRalJVYTJSU1pVWlNjMXBIUmxOaVJuQlVWMWQwYTFVeVRsZFZiR1JZWW0xU1ZWWnRlRmRPVm5CV1dYcFdhRkpyY0hsWk1HaDNWbXN4ZFdGSGFGZGhhM0JIV2xWYWEyUkhSa2RhUms1WFltdEtkbFl4YUhkU01rVjVWV3RrVkdKck5WWlpXSEJYVjBac2RHUkZaRTVOVm5CNlYxUk9hMkpHU2xWU2EyaFhWbnBXVUZZd1dtdFRSMFpIVm14d2FFMXNSWGRXYWtKaFZURmtSazVXWkZWaVYyaFVXV3hvYjA1R1dsVlRha0pPVW14V00xUldXbUZVTVZwMVVXeHNXbFpGV2pOYVIzaHpWakZrZEZKc1pFNWhlbFpKVjFkMFlXSXhXWGROU0d4b1VrVndXRmxVU2s5T1JscHhVbXR3YkZKdVFraFphMlJIVlRKS1dHRklaRmRpV0dob1drUktWMVl4WkhOaFIzaFRZWHBXV1ZaR1dtdFZNVTVIVjFoc2ExSjZiRlpaYTFwMlRXeHNjbGR0UmxoaVZWWTBXVEJTVDFZd01WZGpSazVoVWtWd1NGVXhXbE5qTWtaSFZHMXNVMDB5VGpWV2JURTBZVzFXU0ZOWWFHRlRSVFZaV1ZSR2QxZFdiSE5hUnpsb1VteGFlbFl5Tld0V2JFcDBaSHBLVmsxdVVYZFdhMXBLWkRGa2NtRkdaRmROTW1oVlZteFNSMWxXWkZkU2JrNXBVbTFTYjFsVVJuZGxWbHBIVm0xR2FrMVhVa2hXYlhoellWWktkRlZ1UWxwWFNFSllWako0YTFkRk1WVlZiRkpPVm10Wk1GWnFTVEZVTVd4WFUyNUtUMVp0YUZkWmJGSkdUVVp3VjFkc2NHeFdNVXBHVlZjeGMxVXdNVWxSYTNCWFlrZE5lRmw2Um10VFJrcFpZa2RvVTJFd2NGbFhWbVF3VWpBMVIxZFlaRmhpUjFKeFdXdG9RMU5HV1hsamVrWm9WakJ3UjFZeGFIZFdNa3BWVW1wT1ZsWjZSbGhWYWtaclYxZEtSMVp0YUU1aVJYQXlWbXhqZDJWR1ZYbFRXR2hwVW14YVZGbHRNVk5YVmxaMFRWWk9iR0pHY0RCVVZsWnJZVVpLVlZKdWJGVldiRXBZVm0weFMxZFdWblZUYkdScFZrVmFUVlpxUW10V01VbDRWbTVPVjJKSFVsUldNRlpLWlZaYWNsZHRkRTlTYlhoWlZrWm9iMVl5U25KalJscGFZVEpTVkZaRVJuTmpiRnB6WTBVMVUySkhkekZYYTFaaFlUSkdSazFZU2xoaVIyaFlWV3BPVTJGR2JGaGxSWFJyVWpGYVNWVnRlSGRoVmtweVkwVnNWMkpZVW1oWFZtUk9aVVp3U1ZSdFJsTk5NVXBWVm0xMFlWbFdaRWRYYmtwaFVrWktWbFJXV2t0bGJGbDVUbFpPYUUxc1dubFdNbmh6VjJ4YVJsZHRhRmRoTVhCWVZteGFUMk5zY0VkVWJXaHNZVEZ3V2xadGNFcGxSMDE0Vmxob1ZHSkdXbGhaYTJSVFYxWmFjVlJzVG1oU2JWSllWMnRWTldGck1WaFZha1pYVW5wR1NGWlVSbXRTTVU1elZteGtVMkpXU1RKV1JscGhWREpOZUZkc2JHbFNNMmhVVkZSR1MxZEdXa2RXYkU1U1RVUldXRmxyV21GWGJWWnpWMnhvVlZZelVtaGFWbHBXWlZVMVZtUkdaRTVXYlRoNVZsY3hOR0l4YkZkVGJHUnFVbXhLWVZSWE5XOU5NVlYzVjJ0MGFrMVdTbmxVYkdSellWWlplV0ZIT1ZkaVZFVXdXVlJLVW1WR1VsbGlSbEpZVWpKb1dsZFhNWHBOVm1SWFlraFNhbVZyV25CVVZscFhUVEZrY2xkck9WZGhla1paV2xWb2QxWXdNWEZTYTJoWFlURndURmw2U2s5U2JVcElVbXhPVjAxVldYcFdiVEYzVWpGT2RGVlliRlZoTVhCd1ZXcENZVmRHV25GUldHUnNVbXh3TUZSVmFHOVZNREZ5VGxod1YxSjZWbFJaVlZwTFpFWldkRTlXVmxkaVYyaEZWMWR3UjJFeFdsZFRibEpUWWtaYVQxbHJWbmRUUmxwRlVtMUdhRTFYZUZoVk1XaHpZa1pLYzFOc1dsZGlXR2hvVkZSR2ExWXhaSE5qUjNoWFRWVndTVll5ZEd0aU1WSnpVMnRhV0dFelFsaFdibkJHVFVaa1YxZHNUbXBOV0VKSFZqSXhkMVpHU2xaalJtaFlWbXhLU0ZwRVJsTlNNV1JaV2tab2FXRjZWbmhXUmxwaFdWZFdjMXBJU2xoaVJUVlhWRmQwZDFOc1ZsaGxTR1JYVFZWd2Vsa3dXbTlXVmxwWFkwZEdZVlpzY0ZCWk1qRkhVakZrZEdKSGJHaE5TRUoyVm0wd2VFNUdiRmhWV0dST1UwZG9jRlZ0ZUhkWFJsbDNXa2M1V0Zac2NEQmFSV1JIVjBkS1NHUkVUbGROYWtWM1ZtMXplR050VGtaaFJuQk9VakF3ZUZacVFtdFNiVlpIVkc1S2FGSnRhRmhaYkZwTFZsWmFXR05GWkZWTmJFcFlWa2MxVTJGR1NuSk9WVGxWVm14YU0xWnRlRnBsUm5CRlVXeHdWMDFWV1RGV2JHTXhWREZzVjFScldrOVdNbWhYV1ZSR1lWUkdaRmRYYlVaclVsUkdXRlpITVRSaFZrbDRVMnBXV0Zac1dsZFViRnBhWkRBeFdWTnRjRk5pVmtwWlZrWmtkMUZyTVZkWGJrNVlZbFZhY1ZSWGN6RlRiR3QzVjJ4a1YwMVZjRmhaTUZwWFZqSktXVkZyZUZaaGExcE1XWHBLVDFKc2NFaFNiRTVYVW14d01sWnJXbE5STVU1eVRWWmtXRmRIYUZkWlZFRXhXVlphY1ZGdVRrOVNiR3cwV1ZWb1QxWnJNVmhWYTJ4YVZsWndlbFl5ZUZwbGJGSlpZVVprVGxKdVFsbFhXSEJIWVRKU1YyTkZaR0ZTVkZaWlZXeFdkMWRXV25SalJYQnNVbFJHU1ZWdE5WTldSMFY1WlVaT1dsWkZiekJYVmxwVFZteHdSMVJ0ZUdsU2JrSTBWbGN3ZUZJeVJYaFhia3BZWW0xNFlWUlZXbmRqYkd4V1drVmFiRlpVYkZaV1IzaHJWR3hhZFZGdE9WZGlSMDQwVm1wR1NtVkdaSFZXYkdScFVtdHdkbGRzWkRSWlZtUnpWMnhvVGxaRlNuSlVWM2hMWld4WmVXVkhPVlZpUm5CSVZUSTFTMVpXV25SVmJGSldUVVp3ZWxreU1VZFNhemxZWVVaT2FFMXFhRFZXTVdRd1dWZEplRmR1VWxSaVIzaHZWV3BDWVZac1duRlViVGxZVW01Q1IxZHJXazlWTVZweVYycENXbFpXVlhoV2FrWnJVbXhPVlZOc1pFNVdhM0JGVm14U1IxTnRWa2RhUm14b1VteEtXVlV3Vmt0a2JGcFlUVlJDVkUxWGVGaFdNalZUVkd4YWNrNVdVbFZXYldoRVZtcEdhMk5zV2xWV2JGcE9Va1ZhTlZkVVFsZGlNV1J6VjJ4a2FsTkZjRmhWYWs1UFRrWmFkRTFWT1ZOV2JIQjZWMnRrYzFkR1NYbGhSbHBYWWtkU00xVnFTazVsUm1SWllVWldhVkl6YUhaV1Z6QjRWVEpPUjJKR2JHcFNiVkpaVm0weFUxZFdjRVphUldSWFVsUkdlVlJzVm05V01ERnhWbXQ0V0Zac2NFeFZha1pQWkZaT2MxWnNaR2xUUlVZMlZteFNRMWxXWkhSV2JGcE9WbXh3YUZWcVNtOVVNVlp5Vm0xR1QySkdjSGhWTW5CVFlWVXhWMkpFVGxWV2JXaFlXVlZhVDFJeVRraFNiR1JvVFZad2IxWnJWbUZXTWxKSVZtdGFVRll6UWs5V01GWkxVMVphZEUxVVVtaE5WbXcxVld4b2QxVnRSWHBSYkdoYVlrZG9SRlZyV210V01YQkdUbGQ0VjJKRmIzaFdhMlEwWVRKR1dGSnFXbGRpUjFKWlZtcE9VMk5zV2xWU2JFcHNVbTFTTVZaSGVIZGlSMHBHWTBod1YySlVSVEJhUkVGNFVqRldjMXBHV21sU1ZGWjJWbTE0VTFJeFpFZGlTRXBXWWtkU1dGbFljRWROVm14V1YyMDVWMDFXY0VkWk1GWnJXVlphTmxKcmFGWmhhMW96VldwS1QxTkhTa2RVYXpWcFZqSlJNVlp0TUhoT1JsbDRZa1pvVlZkSFVsQldNRlV4Vm14c2RHUklaR2hTYkZvd1dUTndSMVpWTVZkalNHaFdZbGhTTTFsVVFYaFhSbFp6WWtkR1UxWXhTa2xXYlhoV1pVZE9jMXBJU21GU2JGcFlWbXBLYjJWV1duUmtSM1JVVFZad2VsZHJhRTloUmtwMVVXNUNWbUpZVWpOVk1WcGhVakZXY2xwR1pFNWhlbFpaVmxSSk1WWXhXbGhUYTJoV1lYcHNZVlpyVlRGU1JsVjRWMnh3YkZZeFNrbFZiWGhoVkd4WmVGTnJiRmRXUlZwMldYcEtSMUl4VW5KaFJscHBVakpvV1ZkV1pIcE5WbHBIWWtaYVdHSnRVbFJXYlhSM1RVWldkR1ZGT1ZWaVZWWTJWVmQwTUZZeVJYbFVhbEpXWVd0YVYxcFZXazlrVms1MFkwWk9hVlpyY0ZwV2JHTjRUa2RSZVZKclpHcFNWbHBWV1d0a1UxWkdVbGRYYm1ST1ZteHdXVlJXVWtOV2F6RldZMFprV2sxR2NIcFdha1poVG14S1ZWRnRSbE5TV0VKWlYxaHdTMU14VGxkVWJrNVlZbGQ0VkZSV1ZuZGlNVnAwVFVob1RsSXhSalJYYTFwclYwZEtTR0ZJU2xaaWJrSjZWakZhYzJOc1pIVmFSbWhUWWtoQmQxZFVRbUZVTVZsM1RWVldVMkV5YUdGVVZWcDNaR3haZVdNemFHcFdhM0I1V2xWYVlXRkhSWGhqU0d4WVZrVndObFJXV210VFJrNXlZVWRzVTJGNlZscFdWM2hYWXpBMVYxZHVVazVYUjFKVVZGWmtORmRXVm5OaFIzUlZUVlp3V1ZaWGVHdFdNREZJVlc1YVYySkdjSHBhUldSVFUxWndSMWRzVG1sVFJVWXpWbXRhWVZsV1VYbFNhMlJVWW1zMVdWbFhkRXRXYkd4eVYyMUdWbEp0ZUZsYVZWWXdZV3N4V0ZWdWFGWldla1pJVmxSR1dtVlhSa2xpUm1ScFYwWktiMVl4V210VWJWWlhWVzVLVjJKRmNIQldiRnAzVmxaYWRHTkZaRlJOVlRWWVYydGFhMVp0UlhkalNFNVdZbFJHVkZVd1dtRmtSVFZXWkVkb1YyRXpRWGRXYkdNeFVURlpkMDFWWkdwU1dHaFdXV3hvYjJGR2NFWmFSbVJVVWpGS1NGWlhjekZXTVZwSFYydHdWMkpVUWpOVVZscGFaVVphZFZWc1VtaE5iRXA0VmxjMWQyTXhiRmRYYmtwWFlsVmFUMVJXV25kVFJsbDVUVlZrVjFKcmNGWlZiWGhoVmpGWmVtRkVUbGRoYTBZMFZXeGFZV05XWkhOaFJtUnBVbGhDVWxZeWRGTlRNVWw0VTFob1ZXSkhlSEJWYWs1dlZrWmFjbHBFVWxoV2JWSlpXbFZhVDFVeVNsZFhibkJYVmpOb2NsWXdaRXRXYkdSellrWmFhR0V4Y0c5V1ZFWmhWVzFXUjJORlZsSmlSbHB3VlcwMVEwNXNaRlZSYkU1YVZteHNNMVJXYUZkV2JVcElZVWRHV2xZelVqTlZNRnBYWTFaS2NrOVhkRmRpUm05M1YxWldZVlF5UmxkWFdHeG9VbnBzV0ZSV1pGSmtNV1JYVjJzMWJGSnNTbmxYYTFwdllVVXhWMk5HVmxoV2VrSTBWbFJHYTFJeVNrbFRiVVpUWVhwV1VGWnRNVFJrTVU1WFZXeGthRkl6VWxoVVZWSkhaVlphZEdOSFJsZGlSbXcyVlZjeGIxWXdNVWRqUjJoV1lsaG9VRnBHV2s5ak1WcDBZVVUxV0ZKVmNGcFdha28wV1Zac1YxVlliRlZYUjJoeFZXeGtVMVl4YkhOYVJGSllVbXh3TUZSc1ZrOVhiRnB6WTBSQ1ZWWnNTa1JXYWtGNFZtc3hWVlpzWkZObGJGcFJWMVphWVZReFNuTmFTRTVXWWtoQ2NGVnRlSGRpTVZwMFpFZEdWazFXYkRSV01uaFhWVEpLV1dGSVFsWmhhelYyVkd4YVlXTldUbkZSYXpWVFRVWndTVlpxU1RGVE1rWlhVMnRrYWxJd1dsaFphMXAzVFRGd1dHVkdjR3ROVjFKNldUQmtOR0ZXV2xkalJYUlhZV3R2TUZsVVJscGxSazV6V2tkd1ZGSXphRmxXYlhCUFVURk9SMk5GVmxOaE0wSnpWV3BCTVZJeGJGWlhhemxvVm10d1ZsWnROV3RXTWtwVlVsaGtZVkpGUlhoVmFrWnJaRlpPYzJGSGJGZFdia0l5Vm10YVlWbFdXWGROU0doV1lrZFNXVmxzYUZOWFJsSllaRWhrYkdKR1ZqVlViRlUxVmpKS1ZtTkZhRlpOYWxZelZqSXhSMk5zWkhSaFIwWlRWakZLVlZaVVJtRlZNazV5VDFaa1ZXSlhlRlJaYTJRd1RrWmFkR1JIZEU5U01GcDVWR3hhYTFkR1pFaFZhemxYWWxob00xa3hXbFprTWtaR1ZHeHdWMkpGY0ZoV01uUnFUbFphVjFOdVRtcFRSMmhYV1d4U1IxTkdXbFZUYTNSWFlYcFdWMWxWV25kV01WcDFVVmh3V0ZZelVuSlZiVEZYWXpGS2RWTnJOVmRpVmtwWlZrWlNRMU14VGxkYVJtUldZVE5TVjFSV1ZuTk9SbHBJVGxaa1YxWXdjRWhaTUdoRFZtMUtSMU5zYUZkTlZuQm9WakJWZUZaV1ZuUmtSVFZYVFRKb1dsWnRjRXBOVmxWNVVsaG9WRmRIVWxsWmJGWmhWMFpzYzFWcldrNVNiR3cwVmpJeFIxWXdNWEpYYTJ4aFVsWndXRmxXV2t0a1ZrWlpXa1prYVZJeFJYZFhWM0JIWVRKU1IxTnNiR2xTYkhCd1dXdG9RMkZHWkhOYVJFSmFWbTFTU0ZsclVtRlZNa3AwVld4U1ZWWnNjRXhhVjNoelZteGtjazlYYUZkaE0wSmhWbFpqZUZJeFdYZE5XRlpXWWtkb1dWWnRNVk5TTVhCV1YyeGtXRll3V2toV1Z6RnpZVlpLV1ZGcVZsZGlSMUYzVm0xemVGWXhjRWRhUjJ4VFlrWndWbGRXYUhkV01WRjRWMjVTYkZORk5VOVVWbHB6VGxad1JsVnJUbWhTTUZreVZXMDFjMVpYU2tkWGJXaFhZbGhvWVZwWE1VZFRWazV6V2tkb2FFMUdiRFpXTW5oaFlURkplRk5ZYUZSaWF6Vm9WV3hTVjFkR2JIUmtSWFJyWWtad2VGVnRNVWRoUlRGWFUycENWMkpZYUhKV2JURkxZMjFPU0U5V1dtaGhNMEl5Vm0xMFlXTXlVa2hWYTFwclVteHdWRmxzV2t0WGJGcEhWbTA1YVUxcldsbFZNbmhyVjBkS2RWRnNhRlZXZWxaMldrZDRjMWRIVmtaa1JtaFRZa1p2ZUZaVVNqUldNVmw1VTJ0a2FsSkdjRmhWYWs1dllVWmFjVk5zVGxSU2JGcDVXVlZrTUZVeVNsZFRiR3hYVW14YWFGa3lNVmRXTVdSMVZXczFXRk5GU2xGV2JUQjRWVEF4UjFaWWJHdFNlbXhZV1d4V2QyVldXWGxOVnpsWFRXdHdTRmt3VWs5WGJGcFhZMFJPVm1KWWFHaFdNV1JIVWpGd1IxcEhiRk5pVkd0NlZtcEdZVll4V25KTlZtUlhWMGRvVlZsclpGTmpWbFp6WVVWT1dGSnRlSHBaVlZaUFZrWktkR1ZJYUZaTmJsSXpXV3RhUzJSR1ZuVmpSbWhvVFd4S1NWWnNVa2RYYlZaWVVtdHNXR0pIVWxoVVZFSkxWRlprV0dORlpGaGlWbHBKVlRKMGMxWkhTbFpYYkZKYVYwaENXRll4V21GWFJURlZWVzEwVG1KR2NFbFdiVEF4VlRGUmVGZHNWbWxTZW14aFdXdGFZVTB4VlhsbFJtUllVakZLU1ZReFdtdFViRnBZWkhwS1dGWnNXblpYVmxwYVpWWktkVk50Y0ZOWFIyaFpWa1phWVdRd01YTmpSbWhzVTBkU1ZGUldhRU5UUmxwSVRWaE9WMUpyY0ZkWk1GSkxWakpLVlZKWVpGZFdSVnBQV2xWYVQxZFhTa2RXYld4b1RUQktVVlp0TUhkbFJsVjVVbXRrVjJKcldsWlpWRUV4VjBaV2RHVkhSbXhpUm5Bd1ZHeGtNRll3TVVWU2JHaGFUVVpLUkZac1dtRmpNVTV6Vld4a2FFMVdXVEJXYlRCNFZERktkRkpyWkdGU1ZGWndXV3RXZG1WV1dYaFhiWFJzWWxaR05WWnRlRzlWTWtWNVZXMDVWbUpZYUdoV01GcFRWbFpLY21OSGVHbFNia0phVmtaYVUxVXhaSE5YV0doVVlUSjRXRmxzYUZOamJHUlhWMnR3YkZZd1draFpWVnAzVmpGS1dFOVVXbGRTYkZwb1YxWmFhMUpyTVZkaVIwWlRZa1p3VUZadE1IaE5NREZYVjJ4b1RsSkZXbFZVVmxwM1UxWlZlV1ZIT1doU2EzQXdWbGN4YjFZeVJuSk9WbEpWVmtWYWFGWnRlR3RrVm5CSFZHMXNVMDFWYnpGV2ExSkhZVEpSZVZKc1pGUmliRnBUV1ZkNGQxZEdiSE5WYTA1UFVtMTNNbFZ0ZUdGaE1ERkZVbXhvVjAxcVJqTldWRVpMVmxaYWMySkdhRmROTW1neVZsWlNSMU14U1hoYVNGWlRZa1UxYjFwWGVHRmxiRnBZVFVob1ZrMXNXbnBYYTJoTFYwZEtWV0pIT1ZkaGEwcFlWR3RhY21ReFpIUlNiR2hUWWtjNGVWWldXbTlpTVZwelYydGFhbEpVYkdoV2JGcDNZVVp3UjFkc1pHdFNNVXBJVmxkNFQxWXhTbk5qUms1WFlsaG9jVnBWVlRGVFJsWlpZVVpXYVZJeFNsaFhWekY2VFZaa1IxZHVTbGhpVlZwWlZXMHhOR1ZzV25ST1YzUlhUVVJHV1ZwRlVrOVdNa3BWVm14Q1YyRnJSalJXYWtwTFVsWmtjMXBHVG1sU1dFSktWbTB4ZDFGdFZraFZiR2hUWVRKb1ZGbHNWbUZYUmxKVlUyMDVXRlp0VW5sV2JURXdWVEF4Vm1KRVVsaGhNbWhNVmtSR1lXTnJOVmxSYkhCWFVsVnZlVlpHV21GWlYwNVhVMjVTVUZZelVrOVdiR1F6VFZaYVdHVkhPV3BOVm5Bd1ZXeG9jMVp0U2tkWGJVWmFZa2RvVDFwVlduTldiR1J6V2tkd1RsWnNjRFpXTW5Scll6RlNjMXBGV2xSaVNFSlpXV3RhWVdGR2NFVlNiRTVyVW1zMWVWZHJaSE5WTVVweVkwWnNWMkpZUWxCV1ZFWlhVakZrZFZKc1NsaFNNbWg0VjFkNFYyUXhTbk5YYkdoc1VqTlNiMVp0ZEhOT1ZteFdWVzFHVjAxcmNGcFdWelZMVm0xS1ZWSnNhRmROUm5CTVdUSjRkMU5HU25OVWJXeG9UVWhDYUZadGVGTlJNVmw0VkZoa1QxZEZOVmxaYlhoTFZERmFjbGRyZEZwV2JIQjRWVzEwTUZkR1duTmpSV3hoVWxkU1NGWXllR0ZqYlVwRlYyeGtWMlZzV2tWV2JUQjRVekZrV0ZKcmFGTmlSbHBZV1d0b1EyVldaRmxqUldSYVZqRktTRlV5TlZOaE1VcFZWbTA1VlZaRlNreFZNbmhoWXpGV2NtTkZOVmRpUlZrd1ZqSjBWMkl4V2toVGJrNVVZbXMxVjFsWGRFdGhSbHAwWlVkR2FrMVlRa2hXUjNoaFZHeGFjbU5HYUZkaGEydzBWV3BHV21WR1pIVlRhemxZVWpOb1dsZFdVa2RXYXpGWFlrWmtXR0V6VWxsV2JYUmhaV3hrY2xkdGRGZE5hM0JZVld4b2ExZEdXbk5UYTJoWFRXcEdXRlZxUmxOa1ZsSjBVbXhPVGsxRmNGWldiR1EwWWpGRmVGcElUbGhpYTFwVFdXeFNjMVV4VWxkV1ZFWlVVbXhzTlZSc1drOVdWMHBIWTBSQ1YxWXphSFpXYkZwaFl6RmFXV0ZIUmxkTk1tZzJWMVJLTkdReFRsZFZiazVZWVhwV2IxUlVRa3RVUmxwelYyMXdUbFl3VmpSV01XaHpWa2RLU0dWR1pGcGlXRkl6Vm0xNGMxWldTblZhUjNCcFVteHdORlpYTURGaE1WVjNUVmhLV0dFeWVHaFdiRnAzVlVac2NscEZkRmhXTUZwR1ZrZDRhMkZGTVZsUmJUbFhUVlp3YUZaSE1WZFNNVloxVTIxR1UySlhhRnBXVjNCUFlqRldWMWR1VW14U2VteFhWRlprVTFkR1duUk9WV1JXWWxWd01GWlhlRzlXVmxwelkwaHdWV0pHY0ZSWmVrWmhaRWRTUjFwRk5WZGlhMGt5VmpGa01GVXhiRmRYV0doWVlXeHdWRmx0ZUhkWFJteHpWV3RrVkZKdGREVmFWV1F3WVRGSmQxZHJhRmROYmsxNFZsUkJlRlp0VGtkalJtUnBVakZKZWxaWGNFZFdiVlpYVld4c2FGSnRhSEJaYTFaM1pERmFXRTFZY0U1V01EVklXV3RhVjFWdFNrbFJhemxXWWxob00xUlZXbmRXYkhCR1drWm9hVkp0ZDNwWFYzUlRWakZhZEZOcmFHaFRSbkJZVkZWYWQyTnNWWGRhUldSVFRWWndlbGt3WkhOWFJrcFZVbFJDVjAxV1NraFhWbHBhWlZaV2NtRkdaR2hOV0VKNVZsY3dlRlV4VVhoWGJsSlBWbFUxVUZadGVIZE5SbEpXWVVjNVZrMUVSbmxXTW5SdlZtc3hjVlpzVWxwV1JWcE1WV3BHYTJSR1NuUlNiR1JPVFVSRk1GWXlkR3RPUm14WVZHeGtVMkpIZUc5VmJURnZWa1pzY2xkdVdteFNiVkpaV2tWa1IxWXdNWEpYYkdoV1RXcFdXRlpYTVV0a1IxWkhZVVp3YUUxWVFrMVdhMVpoVmpKU1JrMVdaR0ZTTTBKUFZteG9RbVZHV25KWk0yaHJUVlpXTlZVeWVHdFdSMHBHVTJ4b1dtSkhhRVJWTUZwWFkxWkdXVnBIZUZOaWEwcEpWakowWVZsWFJrWk5TR2hVWWtad1dWWnFUbTloUm1SWFYyMTBVMDFYVWpGV1YzTTFWakpLVjFOc2JGZGlXRUpFV2tSR1QxWXlTa2RYYkdocFlYcFdXVmRYZUZkWlYxWlhWMWhzYTFKR1NsaFVWVkpIVFZac1ZtRkZkRmROUkVaSlZsZDRiMVpyTVVkV1ZFWlhZV3RhY2xreWN6RldNWEJJWWtkb1RsTkZTbTlXYlRCM1pESlJlVlZZWkU1V2JWSlZWakJrYjFkR2JIUmxSWFJYVm0xNGVWWXlOV3RYUmxwMFpVaHNWMDFxUmtoV2FrRjRWMGRXU1dOR1pGZE5NVXB2Vm10a05GTXlVbGRTYms1b1VtMVNUMWx0TVc1bGJHUllaRWRHV2xac2NGaFdNalZQWVZaSmQxZHNVbGRoYTFwTVZGZDRZV014Vm5Ka1JsSk9WbFJXV1ZaWE1UUmpNV3hYVTI1U1ZtSnJTbGRaVjNSaFUwWlNWVkp0ZEZoV01EVkhWMnRrYjFSdFJqWlNWRUpYVFc1U2RsWkVTa2RTTVU1MVZHeG9hVkl5YUZoWFYzUmhaREF3ZUZkWWFGaGlXRkpZVkZab1ExSnNWbGhOVkVKVllrWndlVmt3Vm5OV01rWnlWMjVhV21GclduSlZNRnBMVjFkS1IxZHRiR2hOV0VKdlZqRmtNRmxXYkZoU2EyUlhWMGRTV1ZsdGRIZGpiRkpYWVVWT1UySkdjRmxVVm1NMVZtc3hWMk5GWkZaTlYyZ3pWbXBHWVZKdFNqWlJiRnBvWVRGd2FGZHJVa0psUm1SWFYyNVNhRkpyTlhCV2FrcHZZakZhZEUxVVFsZE5WM2hZVm14b2IyRnNTbk5qUm14YVYwaENlbGt5ZUdGa1IxWklVbTE0YVZKdVFrcFdSbHBxVGxaYVdGTnNXbXBTVjFKaFZGVmFkMWRHV25GUldHaFlVbXhhV2xkclduZFdNVXBYWTBab1dHSkdjR2hXVkVwUFl6Sk9SbHBIYUZOTmJtaDNWbGQ0YjFFd05WZFhiazVXWVRBMWIxUldXbGRPUm1SeVZtMTBhRlpyTlVkWk1GcHpWMjFLV1ZSWWFGZFdWbkJZV2tWVmVGWXhVblJsUm1ScFUwVktZVll5ZUZkV2F6VllVbXRrVkdKck5YRlZiWGgzVmpGc2MxVnNaR3hpUm13MVZGWldZV0pHU25KT1dIQlhWak5vY2xaSE1VZGpiR1J5WVVab2FWSnNjSGxXYTFKSFZERlplRlZ1VmxWaVYyaFVXV3hhUzJReFdsVlJiR1JVVFZaS2VsWXhhRzloUms1SVZXeFNWVll6VWxoVWJGcGhVakpHU0U5V1pHbFdXRUkxVmtkNGIxSXhXblJTYmtwcFpXdEtXRmxVUm5kbGJHdDVUVlZrVTJKR1NqQmFSV1J6VlRKS1dWa3paRmRoYTI5M1dXcEtSbVZHV2xsYVJUVlhZbFpLV1ZkV1pEUlRNV1JYWWtaV1UySlZXbkpaYTFwM1RVWlNWMVp0Um1sU2JHdzBWakowYzFkc1dsZGpSMmhhVm14d2NsVXdaRWRTYXpGWFdrZG9hRTFJUW5aV01XaDNVekZSZVZSWWFHcFNWM2hXV1d4b1ExWkdXbkpYYlVaWVZtMVNXVnBWWkVkV1JURkZWbXhvVjAxcVZsUldSM2hQVTBkR1NWTnNWbGRpU0VKSlZrZDBZVmR0VmxaT1ZscFFWakpvV0ZsVVRrTlRWbHB4VTJwU2FFMVdjRmhXTW5CaFZqSktjMk5IUmxkaVJuQXpXbGQ0V21ReGNFZGFSazVwVm10d1NWZFdWbUZVTVZKelYyNVdVbUV6VWxoVVZscDNWMFprVjFwRldteFdhM0I2VjJ0YVUxZEdTWGxoUmxwWVZqTlNhRmRXV210V01rcEhWbXhTYVZKWVFsQldWekI0VlRGa1IxcElTbGRXUmxwWVZGVlNSMWRHVlhsalJXUlhZWHBHZUZWc2FHdFdNVnBHWTBWNFZtSlVSbEJWYWtaaFl6SkdSMXBGTlU1V1dFSXlWbXBLTUZVeFJuSk5WbVJZVjBkb2FGVXdWbmRYUm14eVZsUkdhbEpzY0hwV01qVnJWMFphYzJORmFGZE5ha1pJV1ZkemVGSldXbk5oUm1ScFVqSm9ObGRXVWtkVU1VcHlUbFprWVZKdVFuQlZiWGgzWWpGa2MxcEVVbXBpVmtZMFYydG9VMVZHV25SaFNFSlhZa2RvUkZVeWVHdFdNVnB6V2taYVRsWnVRalZXUmxwWFlUSkdjMVJyV21wU2JXaGhWbXBPVTJGR2EzbGxTR1JUWWtoQ1NGWkhlRTlVYlVWNFkwVnNWMkV5VGpSWmFrWlRZMnN4VmxkdGFFNU5iV2haVjFkNGIxRXhVa2RWYkZwaFVsWndjMVp0Y3pGWGJHeFdWMjEwV0ZKcmJEWlpWVnBYVjBaYWRGVlVRbUZTUlZweVZXcEtTMU5XVm5KT1ZtUm9aV3hhWVZac1kzaE9SMUYzVFZaa2FFMHlVbGhaVkU1VFkwWldkR1JJWkd4aVJtdzFXbFZvVDFkSFNsZFhibXhWWWtkb2FGWnFTa2RqYkVweFZXeGtUbEp1UWxsWFdIQkxWREZKZVZSclpHRlNiVkp3V1ZSQ2MwNVdXbkZTYlVaYVZtMTRXRlpITlZOV01rVjVWV3hhV21KWWFFeFpha1pYWkVVeFYxUnRjRk5pUjNkNlZtMHhNRTFHVlhoWGJrNXFVa1ZLWVZSVldtRlVSbHBJWlVkR2FtSlZjRVpXVjNodllVVXhkR0ZHUmxoV2JGcG9WWHBHWVZkR1RuSmFSMmhUWW10S1dsWlVRbGRUTVdSWFYyNUdVbUpWV21GV2JYUnpUa1pyZDFac1pGWmlWWEJhVmxkek5WZHRSWGhqUkU1WFRWWndhRmw2Um5OT2JFcHpWbXMxVjAxVmNFdFdiRkpLVFZaTmVGVllhRmhpYkVwelZXcENZVmxXYkZWU2JtUm9VbXhzTTFZeWVFOWhiVXBJVldwR1ZrMXFSWGRXUjNoclVteE9jbU5HWkZOU1ZuQnZWMVpTUjFVeVRYaFVia3BZWWtkb2IxUlhOVzlYYkZwMFpFWmtWRTFzU25wWk1GWlhWVEpLU1ZGdVRsZGlXRTE0V2xaYWEyTnNjRWxhUmxwT1lURlplbGRVUW10aU1XUklVMnRvVmxkSFVsbFdiWGgzVjBaV2NWTnJXbXhpVlhCSldUQmtOR0ZGTVZsUmJIQlhZVEZ3YUZkV1drNWtNREZXV2tkc1ZGSllRbHBYVjNoVFl6RlplRlZzV2xaaE1sSlBWVzB4TkZZeFdYbE9WM1JYVFVSR2VWa3dXbUZXYlVwSFUydFNWMDF1YUdoVWJYaExZekpHUjFkck5WTmlhMHAyVmpKMFlWbFdVWGxVYmtwUVZtMVNhRlZxU2pSWFJteFZWR3RPV2xac2NEQlVWbWhyVldzeGNsWnFVbGRpUjJoMlZtMTRhMU5IUmtkaVJuQnBWMGRvVFZaclVrZFpWMUpJVkdwYVUySllRbGhaYTJoQ1pERmtjMVp0ZEZOTmEzQklWakkxVDJGc1NrWlRiRnBYWWxob2FGa3llRnBrTVdSeVpFZHdhVlpVVmt0WFZFSmhZVEZTZEZKdVRsaGhhM0JZV1d4b1ExTkdWalpSVkVacVRWVndlbFp0ZUU5aFZrNUdVMnhzVjFZemFIWlZWRVpUVmpGa2MxWnNTbWxYUmtwWlZrWmFWMk13TlZkV2JsSnJVak5TWVZadGRIZFdiRnAwVGxWT1dHSlZWalJXTWpGSFdWWlplbUZIUm1GV1ZuQnlXa1ZrVTFOSFZraGlSbVJwVTBWS1RGWnRNVEJoYXpGWFZGaG9WbGRIYUZsWmJYTXhZMVpXZFdOSVRsZE5WM2g2VmxkNGExVXhTblJsU0doV1lsaG9VRlpxUVhoamJHUnlXa1prVTAwd01UUlhWbHBoVXpKU1YxSnNiR0ZTYldoWVZXeFdkMWRXV2xsalJYUlRZbFpHTTFSV1duTldWMHBJWVVjNVZWWjZSblpXTVZwaFYwVTFXVnBHWkU1V1ZGWkpWbXBKTVZNeGJGZFRiR3hXWWtaYVYxbHNhRzloUm5CWVpVaE9WMkpIVWpGWGEyUnZWVEZhUmxkc2JGaFdNMEpRV2tSR1dtVkdaSEpYYkdocFZqSm9XbFp0TUhoVk1WWkhZa1JhVTJKVlduSldiWE14VFVaV2RHVkZPV2hXYkd3MVdWVlNUMVl5U2xWUmFsSlZZVEpTVTFwVldsTmpNWEJJVW14T2FWSnVRbFZXTVdRd1lURlZlVlJzWkZaaVIxSlpXVzB4VTFaV1duUmxSbVJQVm01Q1YxZHJWbXRYUmtweVlrUk9XazFHV25aV2JYTjRZMVpLY21GR1pFNWliV2h2Vmxjd2VGUXhUbGRhU0U1WVlsZG9UMVl3VmtkT2JGcHpWV3RPYUUxV2JEUldSM1JyVmtkS2NrNVdXbHBYU0VKWVZqRmFWMk14V25WYVJsSlRZa2hCZDFkc1ZtdE5SbEY0VTI1T1YyRnNTbGhXYm5CWFZVWlpkMWR0ZEZSU01GcElWbTE0ZDFZeFNsaFBTR1JYWVd0S2FGbDZSbXRUUmxaeVlrWm9hVmRHU2xCV2JYQlBZakZaZUZkc2FFNVRSMmhQVlcxNGQxTkdWWGxPVlhSVlRWZFNTbFZYZUc5V1ZsbzJWbTVhWVZJemFIcFdha1ozVW14a2RHVkhiRk5XYmtFeVZtcEtNRmxYUlhsU2JHUmhVbGRvYjFWdWNITlhSbGwzWVVWT1ZGSnNjRVpWYlhSM1lrWktkRlZ1Y0ZwaE1sSklWbFJLUzFkSFJrbGFSbVJwVjBkb2IxZHJVa3RXTVZsNFdraE9hRkl6YUZSWldIQlhWMVphUjFkdGRGWk5WVFZJVmpGb2MyRXhTalppUmxwYVlURndNbFJYZUhOamJHUjBVbXhvYVZaV1dUQlhWRUpUVkRGWmQwMVdaR3BTYXpWb1ZXdFdkMU5HVlhoWGJFNXFUV3RhU0ZaSE1YTlZNREI1VkdwV1YySlVSVEJaVnpGWFUwWk9XV0ZIUmxSU1ZGWmFWMVpTUjJReFpGZGlTRTVoVW5wc2IxVnRlR0ZsYkZsNVRsZDBWMkpGY0RCYVNIQkxWbXN4ZFZWWVpGZGhNWEJMV2tSR2EyTnRSa2RhUm1ST1RXMW9WbFp0ZUZOU01XeFhXa1prVTJKck5YQlZiVEZUWWpGc1ZWSnVaR3hXYkhCSVZtMHhSMkZyTVZoVmEyaFhZbGhvZWxsV1drdGtSbFoxVVd4d1dGTkZTbGxXYWtvMFlURmtSazFXVmxaaVJrcFBWbTEwV2sxR1duRlRWRVpWVFZkNFdGVXlOVXRVTVZwMFlVWmtXbUpHU2tkVVZWcDNWakZrYzJOSGVGZE5WWEJIVmxaamVHTXhWWGROVld4U1lUTkNXRmxyWkU1bFJtdzJVbTEwVkZKcmNGcFphMlJ2VlRKRmQyTkdiRmhXYlZGM1ZXcEJNVkl4WkZsYVJtaHBVakZLZUZkWGRHOVJNVTVIVjFoc2FtVnJXbTlXYWtKM1VqRlplR0ZJWkZkTmEzQldWVzF3VDFac1dqWlNiR2hXWVd0YWNsWXhaRXRTTVZwMFlVVTFhVkpZUVhsV2JYaHFaREpXUjFaWWJGUlhSMmh3VlcxNFlWWkdiSFJOVms1WVZteGFNRlJXV2s5aVIwcEhZMFJDVlZac1duSlpWVnBMVmxaS2RXSkdWbGRpUlhCWlZtMHdlRk14WkZkV2JsWlVZa2RTY0ZaclZtRlVWbHB4VVcxMFYwMVZiRFJXYlRWUFZqSktTRlZzVWxkTlJscExXbFphWVdOc1pIUmtSVGxUWWxob1dsWnJXbTlpTVZsNVUyNUthbEpzY0dGWlZFcFRWa1phUlZKdVRtcGlSbkI2V1RCVk1WVXlTa2hrZWtaWVlURmFhRmxVU2tkU2F6RlpVMnhvYVZJeWFGbFdWM0JQVlRKR1IySkdhR3hTV0ZKeVZXcEdZVk5XVm5SbFNHUm9WbXR3ZVZrd1ZuTldNa3BaVlcxb1dGWnRVazlhVlZwM1UxWlNkRkpzVGs1TlZYQldWbTB4TUZsV2JGZGFSV1JZWW10d2FGVnJXa3RXYkZKWFYydDBiR0pHYkRWVWJGcFBZVVV4YzFkdWJGZE5ibWg2VmpKNFlWSnNaSFJoUm1Sb1RWaENXVlp0ZUdGVU1rNXpZMFZrVldKWGFITlpWRVozVjJ4YWRHTkZjR3hTTURFMFZteG9iMVpIU2tkWGJHaGFZVEpTVkZZeFdtRmpWbEp6Vkcxb1UySldTbGxXTW5SV1RsZEdjazFXYUZaaGExcFlWVzV3UjFOR1dsVlNiWFJUVFZVMWVsWnRlR3RWTWtwWFUxUktWMUpzY0doV1JFcE9aVVprYzJKSGJGTk5NbWhWVmtaU1IxTXhaRWRYYTJSWFlrVTFVMVJWVWxkWFJteHlWMjFHV0dKV1ducFdNbmh2VmxaWmVsVnRhR0ZXYkhCWFdsWlZNVlp0VWtkYVJUVlhZbFJvTlZac1kzaE9SMGw0WWtaa1ZHSkhVbkZWYlhoTFdWWlNXRTVYT1U1TlZsWXpWakowTUdGck1WZFRibXhWWWtkU2VsbFdXbHBsVjBaSVQxWmthVlpGVlhkWFZsSkxWVzFXUjFWc2JHbFNiRXBaVldwS2IxZHNaRmhOV0hCT1ZtMVNXRmxyYUZOaGJWWnlWMjVDVlZac2NGaFVWRVpyWTJ4a2NrOVdaR2hsYTFwYVYyeFdiMlF4V1hkTldFWlRZVEpvV0ZsVVJuZFVSbXcyVTJzNVUySlZjRWxWYlhoUFZqQXhWbGRZY0ZkaVZFWXpWV3BHYTJSR1ZsbGlSbFpvVFZoQ2QxWlhjRU5aVm1SSFYyNUdWR0pVYkZSV2JYaDNUVVpTVm1GSE9WZFNWRVpaVmxkNGIxWXhXWHBoU0hCYVZsWndURnBHV2tka1JUbFhZMFprVTFadE9UWldiVEUwV1Zac1dGUnNaRk5pYkVweVZXMHhVMVF4V25OaFJVcHJUVlp3ZWxkclVrTmhSVEZZWlVab1ZrMVhhSHBaYTFwTFl6Rk9jMWRzWkdsWFIyaHZWa1pTUjJFeFdYaGFTRkpUWWxoQ2NGVnFSa3BrTVZwWVRVaG9hazFXU2pCVk1uUmhWMFphUmxOc2FGcGhNbEpQV2xWYVlWSldTblJrUmxKVFlYcFZlRlpVU25wT1ZtUkhVMnhrYWxKdGFGbFdhazV2VmtaV2NWTnNUbXBOV0VKSVYydGFiMkZYUmpaV2JHeFhZbFJHTmxSV1ZYaFNNVlpaWVVab2FWSXhTbGhXUm1Rd1pERmtSMVpZYkd4VFJUVllWRmQwWVdWV2JIRlViWFJYVm14d1dGa3dXazlaVmxwelkwWkNXbVZyV25KYVJXUlBVakZTYzFwRk5XbFdNbWd5Vm0wd2QyVkZOVWRpUm1oV1YwZFNUMVV3Wkc5alJsWjBaVWhrV0ZKc2JETlhhMk0xVjBaYWMyTkVRbUZTVjFKSVZqQmtTMU5IVWtWVWJHUk9ZV3RGZUZkV1ZtRlpWMDUwVTJ0V1ZtSkdjSEJWYWtwdlpWWmFkR05GZEZOTmF6VXdWVEowVjFadFNraFZiVGxhVmtWYU0xbHFSbXRXVms1MVkwVTFWMkpIZHpCWFZFSlhZakpHUjFOdVNrOVdWR3hXVm0xNFlVMHhXblJsUm5Cc1VtNUNSbFZYZUhkV01ERldWMVJHVjJKSFRYaFdSRVp6VmpGU2NsZHJPVmROYldoWVYxWlNSMWxXVWtkYVJtUllZbFZhY2xWc1VrZFhSbHBJWlVjNVZrMXJjRmhWTW5CWFZqSkdjbUo2UWxwV1JWcG9Xa1ZhVDJNeFpIUmpSazVwVTBWS2IxWXhXbE5UTWtsNFZHdGtXR0pyTlZsWmJGWmhZMVpTV0dONlJsUmlSM1F6VmpKNGExWXdNVlpqUm1oYVRVWndXRlpxU2t0WFZrWnlaVVphYUdFeGNFMVhXSEJMVkRGS2MyTkZaR2hTTW1oeldXdGFkMDFzV25KWGJVWmFWakExTUZadGRHdFhSbVJJWVVac1dtRXlVbFJaYWtaVFZqRmFkVlJyT1ZOaVIzY3dWMVpXYjFReFduSk5XRXBxVTBkNFlWUlZXbmRTUmxweFVWaG9VMDFyTlVaV1IzaHZWakpLU1ZGdE9WaFhTRUpJV1ZSS1UxWXlUa1poUjNoVFlsWktkMWRXVWtOa01XUnpWMjVHVkdGclNsaFpXSEJYVjBaYVYyRklUbGRTTUZZMFdUQm9SMVpyTVVoaFJWSllWbXh3YUZsNlJtdGtWbkJJWTBkc1UySnJTa3RXTW5oWFZtczFWMVpZYkZSaE1YQlFWakJrTkZsV1VsWlhibVJxWWtad1NWcFZaRWRoTVZweVYyNXdXbUV4Y0haV2FrcExVbTFPUmsxV1pGZFNWM2N3Vm0xd1IxTnRWa2RhU0ZaWFlrZFNjRlZ0ZUhka01WcDBaVWRHYTAxV2NGaFdNalZUVkd4S1JsZHNUbFZXYkhBeldsZDRhMk5zWkhSUFYyaE9WbGhCZDFac1l6RlRNVnBYVjI1U1ZtSkdTbGRVVlZwM1lVWlpkMXBHWkZSU01VcElXVlZhVDFSc1RrWlNhazVYWWxob2NWcEVRVEZXTVdSMVZXeFNhVkpzY0ZWWFYzUmhVekZrUjFWc1dsaGliVkpoVm0wMVExZEdaSEpXVkZaVlRXdHdSMWt3VWtOWGJVVjRZMFpDV2xac2NGQlZiWGhQVmxaT2MxcEhiRk5oTTBKT1ZqSjBVMUl4VG5SV2EyUmhVbTE0YjFWdE1XOVhWbFYzVm10MGEySkdjRmxVVldodllWVXhXR1ZHYUZkTmFsWlFWakJrUzFOR1ZuTlJiRnBwVjBkbmVsZHNWbUZXYlZaWVZHcGFWMkpHY0U5VmExWmhUbFphU0dWR1pHbE5WMUo2VmpKNGEyRnNUa1pqUm1oV1lXczFVRlJyV21Ga1JURldUMVpPVjJKSVFqWldNblJyWXpGa1IxTlliR2hTYkhCWVdXdGtiMDB4Vm5GU2JFcHNWbXhhZVZkcldtOWhWMFY2VVcwNVYxWjZRalJXVkVwUFVqSktSMkpIY0ZOaVZrcDVWMWQwWVdReFpGZGhNMlJYVmtaYVYxbFljRWRsVmxKWFZXeE9XR0pWVmpSWk1GcHZWakZhTmxKcmVHRlNWbkJZV1hwR2QxSXhaSFJpUm1oVFRXMVJNbFp0TVhkU01XeFhWbGhvV0dKc1NsUlpWRXB2VlZaYWRFMVdUbWxOV0VKWldrVmtSMWRIU2tkalNIQllWMGhDU0ZsVVFYaFhSbFoxWTBaa1RtSnNTbTlXYTFKSFlURktkRlJyWkdoU2JrSllWRlJHU21Wc1duSldiVVpZWWxaYVNGZHJhRTlaVmtsNlVXczVXbFpGV2pOVk1WcGhaRVV4VlZWdGFFNVdhM0ExVmtaYVlWbFhSbGRUYTJScVVtMW9ZVmxyWkc5U1JsWnlWMjEwVjAxWFVqQmFSV1F3VlRKS1NWRnFXbGhXYkZwb1dWUktSMUpyTVZsVmJXaFRZVE5DV1ZkWGVGTlJNRFZIVjJ4V1UySkZjSE5WYlRGVFRWWmFTR1ZJWkdsU01IQkhXVEJvZDFZeVNsVlNWRUpoVWtWR05GVnFSbGRqTVhCSFYyMXNVMVpHV2pKV2JURTBWVEZKZUZwRlpHbFRSWEJYV1d0a1UxZEdiSE5XYm1SVVZtMTRWMWxWYUd0V01ERnlZMFphVm1KWVVuSlhWbHBoVG14S2NtRkdXbWhoTVc5NlZsZHdTMVF4U1hoalJWcFBWbFJXV0ZZd1ZrcGxWbHAwVFVob1QxSnNiRFJaYTFwdlZteGtTR0ZHVmxkTlIxSjJXVlZhVm1ReFduVmFSMmhUWWtad05GWnJaREJVTVZwV1RWWmthVkpGTlZoWmJHaFNaREZhY2xwRmRGUlNiRnA2V1d0a1IxVXhXWGhUYTJ4WFlsaG9WMXBWWkU5ak1YQkpWRzFzVTJKSVFuZFdWM0JMWWpKV1YxZHVSbEppVlZwaFZtMTBkMDFHV2toa1IzUm9VbXR3TVZWWE5VTldiVXBaVldwT1ZrMVdjR2hWYWtaWFkyeHdSMXBGTldobGJGcGFWbXhTU2sxV1dYaFhiR2hVWVRKb1YxbFljSE5aVmxweVZsUkdVMUpzVmpSV01uaDNZa1paZUZOcmJGWmlXR2hvVmtkNFdtVkdUbkppUm1SWFVsWndNbGRZY0V0U01VbDRWVzVLYUZKc2NIQlZha3B2VjFaa1YxcEljRTVXYkhCSVdXdGFZVmRIU25SVmJGSlhZbGhTTTFSVldsZGtSMVpHVDFaV2FWWldXVEpXVm1Rd1RVWlplVkpZYkZWaGJFcFhXVmQwWVZZeGNGWlhhemxyVm1zMU1Ga3dXazloVmxweVkwWndWMkpIVGpSVWEyUlNaVlpLY2xwSGNGTldiSEJXVjFkMGExVXhXa2RWYkdSWVltMVNUMVp0ZUhkWFZsSlhWV3RPVjJGNlJsZFpNRnByVjJzeFIyTkljRmRoYTFwb1ZHMTRTMVpXUm5SU2JFNVRWbFpyZDFac1pIZFNNa1Y1VkZoc1UyRXlhSE5WYlhoTFZrWmFjbGR0Um1sTlZuQXdWRlZvYjFSc1NYaFNhbEpZWVRGd2NsWXdaRVpsVmxaeldrWndWMUpZUWxWV2FrSmhWVEZaZUZwSVZtRlNhelZQVm0xNGRtUXhaRlZSYlVaVlRWWnNNMVJXYUV0WFIwcDBaVWRHVlZaV2NETlZhMXBoWkVVeFZtUkdaRmRoTTBJMVYyeFdZVmxYUmtoU1dHaHFVMGQ0V1ZsVVJtRmpiRlkyVW10d2JGSnNXakZWTW5NMVZqQXhkV0ZHYkZkU2JWRXdWVzB4VjFJeFpIVlZhelZZVWpGS1ZWWkdXbXRPUm1SWFZtNU9hRkl6VWxaVVZscDNWMVphV0dWSGRGZE5SRVpKVmxjMVlWWXlTa2RqU0hCaFVsZFNWRlV4V25kU01XUnpWRzFzVkZKVldYcFdiWFJoV1Zac1YxVlliRk5oTWxKVldXMXpNVmRXYkZoa1JYUlhZa2Q0ZVZZeU1VZFdiRXAwWlVac1lWWldXWGRaVjNONFYwWldkV0ZHV2xkbGExcEpWbXhTUjFkdFZsaFNhMnhwVW0xU2NGWXdXa3RpTVZsNFYyMTBWV0pXV2xoV1Z6VkxWakpLUm1OSVFsZGlSbkF6Vm14YVlXUkhUa1phUmxKT1ZsUldXVlpxU1RGU01WWjBVMnhzVm1KR1dsWldiWGgzWld4U2NsZHRkR3BpVlZwSFZERmtiMVl5UlhwUldHUlhZa2ROZUZWVVJscGtNREZXV2tkd1UxZEhhRmRXYlhCUFlqSk9jMWR1UmxOaVIxSnhXV3RvUTFOR1dsaE5XRTVYVFd0d1NsVldVa3RXTWtwSVZHcE9WVlpzY0dGYVZWcGhaRlpXYzFWdGFFNWlSWEEwVm14U1ExWXhUWGhhUldScFVteGFWRmx0TVZOaU1WWjBaVWRHYkdKR2JEVlVWbFpyWVVVeFZtSkVUbFZpUmxweVZqQmtSbVZIVGtWVWJHUm9ZVE5DVFZadGNFZFVNazUwVW10a1lWSnJOWEJWTUZaTFpHeGFkRTFZWkZOTlYzaFpWbGQwYTFaWFNuSk9WemxXWVd0d2RsWnJXbUZqYkhCRlZXeG9WMkpXU2xwWGJGWnFUbFphY2sxVlZsSmhiRXBZVm01d1YxWkdiSEpYYTNCclRWZFNNVlZ0ZUd0aFZtUkdUVlJTVjJKVVJUQldha3BUVTBaYWNtRkhkRk5pUm5CM1ZsY3dNVkV3TlhOYVJtaHFVbFJzYjFSV1duTk9SbGw1WTBkR1ZtSkhVa2xaVlZwdlZtMUZlRmRxVGxaTlJuQjZWRzE0UzJOck9WaGtSbVJwVW0wNU0xWXllRmRaVmxGNVVteGtXRmRIZUc5VmJuQnpWMFpzYzFWcldtdE5WbkI0VlcwMVQxZEdTbkpqU0d4WVlURndkbGxWVlhoWFZrWnpZMFpvVjJWcldUSldSbHBoWVRGSmVWTnJiRlJpVlZwVVdWaHdWMVZHV2xoTlZGSmFWbFJHU0ZaWGVHdGhSa2w2Vld4b1ZWWldTa2hhVmxwaFpFZE9TRkpzWkdsU2JrRjNWMVpXYjFNeFdYZE5WV2hXWVRKU2FGWnNXbmRqYkhCR1drVmtVMDFZUWtoV1IzaFBWakpLY2xOc1pGZGhhMXAyV2tSR1NtVldTbGxoUjBaVFlsZG9WVmRXVWt0Vk1WbDRZa2hPWVZKR1NsbFZiWGgzVFVaU2MxWnJPVmhpUm5CNldUQlNRMVpXV25OVGExSlhZV3RHTkZadGMzaFdWbHB6VjIxc1dGSnJjRFZXYWtaaFdWWk5lVlZyWkZkaWJFcHZWVzE0ZDJOR1ZuRlNhM1JYVm14d2VGVnRNVWRXTURGelUydHNWMVl6VW5wWFZscExaRWRHU1ZGc1dtaGhlbFpVVjJ4a05GbFhUbGRVYmtaU1lYcFdWRlJWV25kVFZscHhVMVJHVkUxcldsaFZNblJyWVd4SmQxZHNhRnBoTVhBelZGUkdkMWRIVmtkalIzUk9WakZLTmxkVVFtdE9SMFpYVjJ4a2FsSllVbGhaVjNSMlRVWnNWVkpzY0d4U2F6VjZWMnRrZDFaR1NYcGhSbXhYWWxoQ1VGVlVSazlTTWs1R1ZteE9hRTB3U25wV1YzQkNUVlpKZUdKR1dsaGhlbXh2Vm0xMGQxWnNXblJPVjNSWFRXdHdWbFZzYUd0WlZrcEdVbGhvVm1GclduSmFSbHBQWXpKR1NHSkdaRmRpYTBsNVZtMTBZVmxXYkZkWFdHUk9VMGRvVjFsclpGTlhWbXh6WVVaT1dGSnNTbGxhUldocllrZEtSMVpxVmxWaVJsVXhWbXBLUzFadFRrWmhSbHBPWVd4WmVsWnFTWGhTTWs1eldraFNhRkl3V2xSV2FrWkxWbFphVlZKdFJsWk5helY1VkRGYWExWlhTbGhsUmxKYVlUSlJkMVJyV21Ga1IxSklaRVU1VTAxR2NEVldSM2hoWVRGa1IxcEZhRlpoZW14WVdXeG9iMDB4YTNoWGJGcHJUV3RhUjFaSGVIZFdNa3BHWTBab1YwMXVVbkZVYkZwaFZqRk9kVlJ0Y0ZSU01taFlWMWQ0VTFJeFRrZFhiRlpVWVROU1dGbFljRmRXTVd4V1YyNWtWMDFXY0RGVlZtaDNWMFpaZWxWdVNsWmlWRVpZV1hwR1MyUldUbkpPVm1ScFZtdHdXbFpyV2xOUk1VMTRWR3hrWVZKdFVsZFpWRTVUVmpGU1YxWnVUazlTYkhCSlZHeGFhMVl4V1hkalJXaGFUVWRvUkZadE1VdFNNVTV6WVVaa1RsWnVRbTlXYWtKV1pVWmFWMVp1VW10U1ZGWllWRlJLYjFkc1duUmpSWEJPVm14V05WVnNhRzlXUm1SSVZXeHNXbUpHV21oV01GcHpZekZXY2xkck5WTmlSM2N3Vm1wSmVGSXhXWGROV0VwWVlUSjRhRlZzV25kWFJteFhWMnQwYTFacldscFhhMXByWVZaSmVGSllaRmhXTTBKSVdWUktVMUl4VG5OaVIyeFRZa2hDZDFkWGRHOVJNa1pIV2toT1lWSkZTbUZXYlRGVFUwWnNjbFZ0UmxaTmEzQXdWbGQ0VTFaV1duTmpSWGhoVmpOb2VsWnRlR3RqYXpsWVlVWmthRTB3U21oV2JGcHFaVVpKZUZkWVpFNVhSbHBYV1d0a2IxZFdXblJOVms1VFRWaENWMVl5ZUd0WFJsbDNWMnRvVjFaNlJucFpWbHBMVjFaR2NWWnNaR2xTTVVZelZtMHhlbVZHV1hoalJXUmhVako0VkZsclduZFdiR1JYWVVoa1YwMVdSalJXTWpWVFlrWk9SazVWT1ZWV2JIQjZWR3hhZDFKc1ZuSlViV2hUVFVacmVWWlhNREZqTVZwWVUydGtXR0pYYUZoWmJHaHZXVlp3V0UxVlpGUldhelY2VjJ0a2IyRkZNVWRpUkZwWFRXNW9hRmxVUmtwbFJrNVpZVVpTYVdGNlZtOVdWM2hUVmpGa1IySklVbXRTV0ZKeVdXdGFkMlZHVm5STlZXUm9VbFJHV0ZVeWNFTldNa3BaWVVoS1YySlVSa3haTWpGUFUwVTVWMWR0YUdoTk1FbDVWbTB4TUZsWFRYbFZhMmhXWVRGd2NsVnRlSGRXUm14elYydDBXR0pHY0VoV2JUQTFZVlV4Y2xkc2JGWk5ibWh5VmpCa1MyUldSbk5oUmxaWFpXeGFNbGRyWkRSak1XUklWbXRhYTFKdGFGUlphMXAyWlVaYVZWTnFVbGROVm13MVZUSjBhMkZzU2tkalJtaFdZV3MxZGxsVldtRmpWazV6Vkd4U1UySkdjRFZYVmxaclRVWlZlVk5zWkZSaVIzaFlWVzE0WVdGR2EzbE5WbVJYVFZkU01WWlhjekZYUms1R1UyeEdWMkpVUWpSV1ZFRjRVakZhV1dKSGRGTmxiWGhaVjFkNFYyUXlWbGRYV0d4T1ZucHNXRlJYZEhkVFJtdDNWV3M1V0dKR2NGaFpNRkpQVm0xS1dXRkhhRmROVjFKSVZXcEdkMUl4Y0VoaVJrNXBWa2QwTmxadGNFZFpWbGw0VjI1S1RsWnRVbGhXTUdSdlZsWnNjbHBHVG1wV2JGcDZXVlZXVDFkR1NuUmxTSEJhVmxaYVVGWnJXa3RrUjFaSllVWmFUbUpzU1hwWFYzUmhVekpTUjFadVZtcFNiV2h2VkZkNFMxTldXbk5WYTJSWVlsWmFXVlZ0ZEhOWFIwcElWV3hvVlZaRlNreFdSbHByVjBkT1JscEdhR2xXYkhCS1ZsUktNR014V2toVGJGcFlZa1pLWVZZd2FFTlhSbGw0VjIxR1dGSlVSbFpXVnpFd1ZHMUtSMk5GYkZkaVZFRjRWbFJHVW1WR1pITldiV3hUWlcxNGFGZFhkR0ZaVlRCNFZsaHNiRkp0VWxsVmFrWkxVMVpSZUZkdGRGVmlSbkJaV2tod1MxZEdXbk5YYmxwWVZteHdZVnBXV2t0a1ZrNTBZMFpPV0ZJeWFGcFdhMXBoV1ZkUmQwMVlUbXBTYldoelZUQmtVMVpHVWxkaFJVNVVVbXh3U1ZSV2FFOVdNVXB5WTBaa1drMUdTa3hXYWtwTFZsWktXVnBHWkZkU1ZuQlFWMnhXWVZReFpGaFRhMlJYWWxkNGIxUlVRa3RWVmxwMFRVaGtiRkpzVmpWVmJYUnJWakpLY2xkc1dscFdSVVY0VmpCYVYyUkhWa2hTYlhocFVtNUJkMVpIZUd0TlJsbDNUVlZXVTJKSGFHRlVWVnBMVWtaYWMxZHRSbXBOVlRWNlZsZDRhMkZGTVZkWFZFSlhZbFJDTkZaRVJrdGtSa3B5V2tkR1UxWkdXbmRYVjNSWFpHMVdWMWRZYUZoaVdGSnpXV3hhUjA1V1duUmxSemxXVFd0V05WWlhNRFZXYlVwWllVZG9WMDFHY0ZSV2JGcExZMjFPU0dWSGJGTmlhMHBoVm10YVlWVXhWWGhhU0U1WVYwZG9WVmxVU2pSWFJteHpZVVpPYW1KSFVsaFdNblIzWWtaWmQxZHJhRnBXVm5BelZtcEdTMWRGT1ZWWGJHUlRZa1p3YjFZeFdtRmhNVXB5VFZaa2FWSXdXbFJaYTFwM1ZVWmFkRTFJYUU1TlJFWllWako0YjFSc1NrWlhiRlpWVm14d00xVXhXbFpsVjFaSVQxZG9VMkV6UVhkV2JHTjRZakZaZVZKdVNrOVdiRXBXVm10V1lXRkdXblJsUjNSclZtNUNTRlpITVhOVk1ERldZbnBHVjJFeFNraFpWRXBTWlZaS2MxcEdVbWxpUm5CVVYxWmtOR1F4WkVkaVNFNVdZVEExVUZWdE1UTk5iRlowWlVkR2FFMUVSa1pWYlhodlZqQXhjVkpxVGxkV1JWcE1WbXhhWVdNeVNrZGhSbVJPVFcxbmVWWnNXbE5TTVUxNFUxaG9ZVk5HV2xSWmExVXhZakZ3V0dWSFJteGlSbkJaVkZWb2IxWnJNWE5YYm5CWVlUSm9URll3WkV0V1YwcElUMVprYUdFd2NGbFdSM1JoWTIxUmVGcElVbE5pUjJoVVdXdGpOR1ZXV2xkWGJUbHBUVlp3ZWxZeWRHRmhiRXBWWWtkb1YySkdjRE5aVlZwM1VqRmtjMXBIZEZOTlZYQkpWbXhrTkZReFdYaFRiazVxVW1zMVdGbHNhRzlqVm5CV1ZsUkdWRkpzV2xwWlZWcFhZVlpKZUZOc2FGaFdla1kyVkZaYWExSXhaSFZUYkdocFZsWndXbFpYTUhoT1IxWnpWMjVTVDFZelVsaFVWVkpIVjFad1JsVnJPVmROYTNCV1ZtMTRRMVl5Um5KU2FsSlhZV3R3VEZWc1dtdGpNWEJIVkcxc1UxZEZTa3RXYlRCNFpERkdkRlpyYUZaaVIyaFVXVlJLYjFaR2JITldiVVpZVW14S1ZsVXlNRFZYUmxwMFZXNXNWMkpVUlhkV1ZFRjRWbTFLUlZWc2FHaE5iV2hOVm10U1IxbFhUbkpPVm14U1lraENXRlZzVm5abFZscEhWMjFHV2xZd05WaFZNalZUVlVaWmVsVnJPVmRpUjFGNlZGWmFZVmRIVmtoUFYzQk9WbTVCZDFaWGVHOWpNVnAwVTJ0a1dHSlZXbUZaYTJSdlZERndWbGR1VGxkaVIxSjZWMnRrZDFSc1duTmpSRnBYVFc1U2NsbDZSbE5qTVhCR1YyeFNhVk5GU2xwWFYzUmhXVmRHUjJORlZsTmlSVFZ5Vlcxek1XVldaSEphU0U1V1RWVndlVmt3V25OV01rcFpVV3hDVjFaRldsaFZha1pyWkZaS2MxTnNhRk5OYldnMFZqRmtORll5VVhoVGJrNVlZa2RvYzFWcVRsTmlNVnAwWkVoT1QxWnRlRmRXVnpGSFZqQXhjbU5HY0ZkV2VsWk1WbTB4UzFaV1NuTmhSbVJPVW01Q1RWZFVTalJrTVU1SFUyNU9WV0pYZUc5VVZXaERZVVphZEdWR1RsSk5WbXcwVmtab2ExUXhaRVpPVm14YVlsaG9URlpFUm1GamJHUnlaRVp3VjJKSVFqUldWekV3VFVaa1IxZHVUbXBTVjNob1ZXeGtVMU5HV1hsbFIwWnFZbFZ3UmxZeWVHdFdNbFp6VjJ0V1YySlVRalJWZWtaclYwWktjbUZHVG1sU2JIQlpWMWQwYjFFeVZsZGFSbXhxVWxkU1lWWnFSa3RUUmxWNVRsWk9hRTFWY0ZaV2JUQTFWbFphUmxOcmVGWk5ibWhvV1hwR1YyTnRUa1pPVm1ScFVsWnJkMVpxU2pCV01rbDRWMnRvVkdKck5WVlpiWE14VmpGc1dHUkZkR2hTYkhBd1dsVmtSMkZyTVZsUmEyaFhVak5vYUZaSGVHRmpiVTVIWVVaa2FHRXlkekJXVjNCSFYyMVdSMXBJVmxSaGVteFpWV3BPYjFkc1pGZFZhMlJYWVhwR1dGbHJXbXRYUjBWNlZXeHNWMkpZVW1oYVYzaHJZMnhrZEdSR1pFNWhNMEpaVmxkNGIyRXhaRWRYYms1VVlUSm9XRlJYY0VkWFJsWnhVbXhPYTFac1NqQlZiWGhQVkdzeFJtTkdXbGRpUjFFd1dXcEdSbVZHY0VsVWJHaHBZVEZ3VkZkWGVGTmpNVlY0Vld4a1YxWkZXbFZWYlhoelRsWlNjMWRyT1ZkV01IQklXVEJTUTFZeFdYcGhTRnBYWWtad2FGbDZSbUZYVjBaSVVteGtUazF0WnpKV01WSkxUa2RSZUZSc1pGWmlhelZaV1Zod1YySXhVbFZSYTNSVlVteHdlbFl5TVhkVWJGbDNWbXBTVjAxWGFIcFdhMlJMVTBkV1IxcEdjR2xYUmtsNlZtMHhOR014V2xkVGJsWmhVak5DY0ZWdGVIZE9SbHBZVFVSR2FFMVdWak5VVm1oTFYwZEZlV1ZIYUZkaVJuQXpWbFZhYzJOc2NFWmtSbWhYVFVad1IxWnJaRFJoTWtaR1RWWnNVbUpVYkZoVVZscDNZVVphU0UxV1pGTk5WbG94VlRJeFIxVXlTbGhoUm5CWFZqTkNVRmxxUmxkV01XUjFWVzE0VTJWdGVGaFdSbHByVlRGa1IxZHVVazlXVjFKWFdXeFdkMDFHV2xobFJ6bFhWbXh3ZWxrd2FIZFdWMHBIWTBaU1dtVnJXbWhhUldSVFVqRndSazVXWkdsaE1HdDVWbXBHYTAxR1ZYaGlSbVJZVjBkb1dWbFhlSGRXUm14MFpVaGtXRkp0ZUhwV1YzUnJWa1pLZEdSRVZtRldWMUYzV1ZSR1NtUXhaSEpoUm1ST1ltc3hORlpzVWtKbFJscDBWR3RrYWxKdFVuQlZha1pLWld4YVdHTkZaRmRpVmxwWVZsZDRjMkZHU25SaFNFSmFZVEZhTTFwRVJtRlhSVEZaWTBVMVYwMUVWa2xYVjNSaFZqRldkRk5yYkZKaGVteFhXV3hvYjAweFVsWlhibVJYWWtoQ1IxZHJXbTloVmtwMFpETndXRll6VWxSV2FrWmhaRVpPY21GSGFGUlNia0paVmtaV1lXUXlUbk5XV0dSaFVsZFNWRlJXV25kbGJHdDNXa2hPV0ZKcmNGWlZiRkpEVmpBeFYxTnJhRmhXYkhCaFdsWmFWMk50UmtkYVIyaE9WMFZLTlZac1kzZGxSbFY0VlZob1dHSnNTbEJXYkZVeFZVWmFkR1ZJWkU1U2JFcFhXVlZqTlZack1VVlNibXhYVFc1U2RsWnRjM2hqVmxwelZXeHdWMUpXY0UxV1YzQkhZVEpTUjFOdVVsTmlSMUpQVkZWU1JrMUdXWGxrUjNSUFVtMTRXVlpIZUd0Vk1rcElaVWM1Vm1KVVJuWldhMXB6WTJ4a2RWZHRlRk5pVmtwYVYydFdhMUl4V1hkTldFcFlZa2RvVjFSWGNGZFhSbHBZVFZWMGExSXhXa2haVlZwM1lVVXhXVkZyTVZkaE1WcG9WbXBLVTFKck1WZGFSMFpUVFRCS1VGWnRlRzlSYlZaSFYyNUtXazB5YUhKVVZscFhUbFpWZVdWSGRGZFNNSEJIVlRKNGIxZHRTa2hoUlZKV1RVWndXRmt4V2tkWFZuQklaVVpPYVdFd2NFcFdha293V1Zac1dGSnJXazVUUjJoVldXdGFkMWRXV25GVWJUbG9VbTFTV0ZZeU1UQlZNREZZVldwR1YxWXpUVEZXYWtwTFZqRk9jMkpHWkdsWFJVcEZWMnRTUjFReFdYbFRhMlJZWWtkb2NGbFljRmRYVm1SWVpVWmtXbFl4V2xoV01XaHpZVEZLUjFOc2FGVldWa3BJVkZaYWMxWnRSa1prUm1ST1VrVmFTbFpzWkRSaU1WcHlUVlZrVjFaRldsaFpWM1JoWTJ4cmVXTjZSbGROV0VKSldXdGtiMVJzVGtaVGJUbFhZbFJDTTFwRVNsSmxWbFpaV2tVMVYySldTbFpXYWtKcllqRmtSMkpJVW14U1dGSllWbTB4TkdWV1dYbE9WM1JZVW14d01GcFZhSE5XTURGeFVtdG9WMkZyUmpSV01HUlhVMWRPUjFwR1pFNU5WWEIyVm0xMGEwNUdUWGxWYkdSVFltczFiMVZ0TVZOVU1XeDBUVmMxYkdKSFVsbGFSV1JIVjJ4YWMyTkdhRmROYWxaUVdWWmFTbVF4WkhOVmJHUm9ZVEZ3VFZaR1pEUlpWMDE0Vm01S2ExSnNTazlXYkZKWFYxWmFXRTFVVW1wTlYzaFlWVEkxVTFadFNuSlRiR1JhVmpOU2FGVXdXbE5XVmtwMFpFWm9WMDFFVmtoV01uUnJZakZTZEZKcVdsTldSVXBZVkZjMVUyUnNXa1ZUYTJSVFRWVTFNVlpIZUc5aFZrbDVZVVpvV0ZZelVtaGFSRUYzWlVaa1dXRkdhR2xYUmtwWlZrWmFiMUV4U25OV2JHaE9Wa1ZLVmxsclduZGxWbXQzVm01T1YwMXJXbmxaVkU1dlZqRktSbGR1U2xaTlJuQk1WakZrVDFJeFpIUmlSazVPWWxkb1lWWnFSbXRPUjBsNFZsaHNVMkV5VW5GVmJURnZZekZWZDFadVpHcGlSa3BZV1ZWV1QxVXlTa2RqUm14VlZtMU5NVlp0YzNoV01rNUdXa1phVGxZeVozcFdiWEJIV1ZaS2RGTnFXbEppUm5CeldWUkdkMkZHWkhKVmEwcHNVbXhzTlZWdGRHOWhSa3B5VGxaU1YyRXhjR2hXTVZwYVpWZFdTR1JGTlZOaVdHaFpWbTE0YjJJeVJuTlRiazVxVW0xNFlWWXdhRU5sYkd0NVpVZEdhMUl4V2tsVmJURTBZVlpLZFZGcmNGZFNiSEJ4Vkd4YVlWZEdUbk5YYlhCVFZqRkthRlpHVm1Ga01XUkhWMjVHVWxkSGFGbFZiWGhoVjJ4a2NsZHVaRmROVlhCWVdUQmFiMWRIU2tkWGJXaFhZV3RhY2xZd1drdGpiSEJIWVVkc1YwMHlhRlpXTVdONFRVWk5lRnBJVGxoWFIyaGhWRlJLVTJNeFZuUmxSbVJQVW0xU2VWWnRNVEJoUmxweVRsVmtXazFHY0hwV01qRkxWMVpTV1dGR1pGZFdia0paVjJ0V1ZtVkdXWGhWYmxKc1VtMVNjRlV3Vmt0WlZsbDVaRVprVjJGNlZsbFZiWFJyVmtkS2NrNVlSbFppV0dnelZtcEdjMk15UmtoUFYzQnBVbTVDTkZaVVNqQk5SbVJIVjI1S1dHSnVRbGRXYWs1dlkyeHNWMWRyY0d4U2F6VjVWRlphYTFZd01IZFRhMnhZVm14S1RGWlVSbHBsUmxaMVZteFdhVlpXY0ZWV2JYUmhXVlphVjFkclpGaGlSMUp5VkZaYVMyVnNXWGhoUnpsWFlsVldObFZYTlU5V2JVcFpZVVZvVldFeGNHaFZNR1JUVTBkU1IxcEdUazVUUlVreFZtdGtORmxYU1hoYVNGSlRWMGQ0VjFscldrdFhSbXhWVW01a1dsWnVRa1pWYlRGSFlXMUtWMU5yYUZoaE1sSjZWbFJLUzJOc1NuRlViR1JPWW0xb1dWWXhXbXRTYlZaSFkwVnNWV0pIYUhCWmExWjNaV3hhV0UxSWFFOVNiVkpJVmpJMVIxWlhTa1pPV0VwYVlURndNMXBWV2xabFYxSklVbTFzVTJKSGR6Qldha293WWpGWmQwMVlWbWhTUlRWWVZGVmFkMVZHVm5SbFJUbHFWbTFTZWxkclpITlhSa3B5WTBoYVYwMVhhRE5WZWtaU1pWWlNXV0pHVm1oTldFSlpWMWQwWVZsWFNYaGpSbWhzVWpCYVdWWnRNVk5YVm5CR1dYcFdWbUY2UmxkVWJHaDNWMGRGZVdGR1FsZGhhM0JNVm0xNGEyUkdTbk5hUjJ4WVVqSm9TbFpyWkRCWlZtUjBWbXRvVTJFeWFISlZiVEZ2VmtaU1ZsZHNjRTVXYlZKNlZtMHhSMkZGTVZkalJtaFhUVzVDYUZacVNrdFNNVTUwVW14a2FWSnVRWHBYYkdRMFYyMVJlR05GWkdGU2F6VndWbTEwZDFOc1pISldiVVpWVFZaS2VsWXlOVmRWYlVWNlZXeG9XbUV5VWxCVWExcFRZMnh3UmxkdGVGZGhNMEkyVmpKMFlWVXlSbGhUYTJScVVteEtXRmxYZEV0a2JGWlZVbTEwVjAxcmNFcFZNakZIVlRKRmVsRnNRbGRXZWtJMFZsUkdhMUl4Y0VsVGJHUlhVbXh3V1ZaR1ZsTlNNV1JIVmxoc2FsSlhVbGhaV0hCSFRWWnNWbUZIUmxoaVJuQjZXVEJvUzFack1VaFZhMmhXWVd0YWFGbDZTa2RTTVhCR1RsVTFWMVo2YXpGV2JURTBXVlpWZUZOWWJGVlhSMmhaVmpCa2IyTldWbk5hUms1b1VteGFNRlJXV2s5aGJFcHpZa1JPVjAxdVVYZFdha1poWXpKT1JtRkdaRTVoYTFwSlZtMXdRbVZHU2xkU2JrWldZa2RTV0ZSVVNtOWlNV1JYVm0xR1ZVMVZjSGxVYkZwdlZVWmFjMk5JUWxkTlJuQkxXbGQ0WVZaV1JuUlNiWEJwVm10Wk1GWXlkRzlWTVZaSFYyNVNhRk5GU2xoWmEyUnZVa1pWZVdWSGRGZE5WbkI2VjJ0YVlWUnNXblZSYWxaWFVteHdXRmxVU2tkak1WSnlWMjF3VTJKWGFHaFdiWEJQVlRKR1IyRXpiR3hUUjFKVVdXdG9RMU5HV2tobFJUbFZZbFZXTkZrd1ZuTldNa1Y1VkdwU1dtRnJXbFJaTW5ONFZteGtkR0ZGTlU1aVYyaGFWakZrTkdJeFJYaFZhMlJXWWtad2FGVnNXbmRqTVZwMFkzcEdXR0pIZUZkV01qRXdWMFpLY21KRVdscFdWbkJZVmpCYVlXUkdWbFZSYlVaVFVsWndlVlpYY0V0VE1VNVhWbTVLVDFadFVtOWFWM2hoV1ZaYWMxa3phRTlTTVVZelZGWmFhMkZGTUhsVmJHaGFWa1UxVkZrd1dsZGtSMUpKV2tkNGFWSnRkekZYYkZadlZERmtTRk5zWkZoaWJYaFdXV3RrYjJGR1duRlRhMlJxWWtWd2VGWlhlR3RVYkVwMVVXeHNXRmRJUWt4V1JFWktaVlpTY2xwSFJsTmlWa3AzVjFaU1EyTXdOVmRYYmtaVFlsVmFZVlp0TVRSWFJscElUbFpPVjAxclZqVldWM2hoVjIxS1dXRkZlRnBoYTFwWVdrVlZlRll4VW5SalJrNXBVak5rTmxadE1IaE5SVEZIVmxob1dHSnJOWEZWYTFaTFdWWlNWbGR0UmxWU2JIQkpXbFZrUjJGdFNsWmpSVnBYVmpOb2RsbFZWWGhrUjBaSFVteG9WMkpHY0c5V1dIQkhXVlprUjFSdVNtRlNNbWhVV1cxMFMxZHNXbFZSYkdSVVRWZFNXRll5TlVkVmJVcFdWMjFHVjJKWVVucFVhMXB5WkRGYWMxcEdXbWxXV0VKaFZteGtlazVXWkhSU1dHaHFVa1UxV0ZSV1duZGhSbXcyVW01T1QySkZjSHBXYlhNeFZqQXhWbU5GZEZkaVJrcExWRlphVG1WR1ZsbGhSbWhwWWtWd2VsWlhjRU5aVm14WFlrWldVMkp0VW05VmJYaHpUVEZaZVdWRk9XaGlWWEJKVmxkd1IxWnJNWEZTV0dSWFVqTm9jbFZ0ZUU5amJVNUhXa1pPVTFadVFuWldNVnBUVWpGVmVWUllhRlZpYTNCWldXdGtiMkl4VWxoT1Z6bFlZa1p3TUZwRldtdFdSVEZ6VTI1d1drMUdXbGhXVkVwTFUxWkdkVlJzWkdsWFJURTBWMnhhWVdFeVRuTmpSV3hoVW14d1QxbFVSbHBsYkdSVlVXMTBhVTFYVWtsVk1uUnZWbXhrU0ZWc2JGZGlXR2d6VmpCYVYyTldUbkpYYlhocFZsaENTbGRVUW10T1IwWkdUVlpzVW1KSVFsaFpWRVozWVVaa1YxZHJOV3ROUkVaWFYydGtjMVpHU2xsUmJIQllWak5vZGxaVVNrcGxSbHAxVkd4YWFFMUVWbEJXUmxwaFZqQTFWMVZzWkZwbGJGcFlWRlZTUjJWV2EzZFhiVVpYWWtac05sVlhlRk5YUmxwelkwVjRWbUpZYUhKWk1uTTFWMFpLYzFSc1RsZFdiWFF6Vm0wd2QyVkZOVWhTV0d4VlltdHdVRlp0TVZOaFJsWjBUVlpPVlUxWGVIcFhhMk0xVmpBeFYyTklhRlppVkVZeldXdGFTMVpXU25KaVJtUlhZbGRvTWxadE1UUmhNVTVJVW10a2FWSnVRbkJXTUdSdlZGWmFjbFZyWkZwV01VcEpWa2R3WVZVeVNraGhSbEphWVRKb1ExcEVSbUZTTVdSelZHeGFUbFl4U2tsV2Fra3hWakZXZEZKWWJGWmlSM2hoVm10V1lXRkdhM2xsUm5CclRWZFNlVnBGWkhkaFZscFZWbXQwV0ZaRlNtaFpWRVpUWkVaT2RWTnNVbWhOYm1oWlYxWmtNR1F3TlhOalJscFlZVE5DYzFWdE5VTlRiRnAwWlVaT2FGWnJOVWRWTW5oelZqRlplbUZJV2xaV1JWcFVWbXBHYTJNeVJraGpSazVZVW10d1dGWnJXbUZXTWsxM1RsVmtZVk5GY0c5VmJGSnpWMVpXY1ZGc2NFNWlSbkF3Vkd4V1QxZEhTbFpXYWxKWFRXcEdTRmRXV2xwbGJVWklZVWRHVTFZeFNsbFdWM0JIVlRKTmVGUnVVbWxTYlZKd1ZUQldTMVJHV25STlZFSm9ZWHBHV0ZaR2FHOVdiR1JJWVVac1dtSllUWGhaTVZwWFpGZE9TVlJzWkU1V00yZzJWbXhrTkdFeFZYaFRibEpzVTBkb1YxbHNhRzlWUmxweFVWaG9hbUpIVW5sWGExcHJWVEpXY2xaWVpGZGlXRUpNVlhwR1QxWXhTblZTYkdocFVqRktkMVpYY0VkU01EQjRWMnRrVjJKVldtRldiWFIzWlZaU1YxZHRkRmhTTUhCYVZWZDRVMVp0U2tkWGFrNVhUVlp3YUZZd1pFOVNhemxYVjJzMWFFMVlRa3BXYlhCTFRVZEplVk5yWkZSWFIxSlpXVzEwZDFZeGJGaGtSWFJvVW14V00xWXlOVTlXTWtwSVZXNXdXR0V4Y0hKV1IzaGhWMVpHYzJGR2FGZFNWWEJZVjJ4V1lWZHRWa2RhU0VwWVlrZG9jRlpxU205WGJGcDBUVWhvVmsxV1draFphMUpoVlRKS1ZsZHVTbGRpV0UxNFZGVmFWMlJIVmtaUFYyaFhZa2QzTVZkV1ZsTlVNVmw1VTJ4V1VtRnNTbFpaVkVwVFZURndWbGRzVG1wTldFSkpWVzE0VDJGV1NuVlJiRlpYVFZkUmQxbFVSbFpsVmxKeldrWmFhVkl4U2xwWFZ6QjRWVEZhVjFkdVVteFNiVkpRVm0wMVExWXhaRmxqUm1Sb1VtdHdlVmt3YUhOWGF6RklZVVJPVjJKWVRqUmFSbVJIVTBkR1IxcEhhR2hOTUVwSlZqSjRWMWxYUlhsVWJHUldZbXhLVkZsclZURlVNVkpZVFZjNWEySkdiRFJaVldoclZUQXhjbFpxVmxkV00xSnlWbXRrUzJOck5WZFhiSEJZVTBWS1dWWnFRbUZqTWxKSVZXdGFZVkpVVms5V2JUVkRUbXhaZUZWck9XaE5hM0JJVlRKNFYxVXlSWGxoUm1oWFltNUNXRlpyV21GV1ZrcDBaRVpTVTAxR2NFdFdWekUwV1ZkR1YxTllhRk5YUjFKWVdWZDBTMkZHYkRaU2JYUlVVbXhhZVZscldsTmhWbVJJWVVaV1dGWXpVblpWVkVaYVpVWmtjMkZGTlZkU2EzQlhWa1prTUZsWFZsZFZiR1JZWWxoU1dGVnFRbmROUm5CV1drVmtWMDFyY0VsV1YzaFRXVlpKZW1GSGFGZGlSbkJRV1RJeFUxSXhjRVpPVm1SWFVteHJlVlp0Y0V0TlJteFlVbGhzVTJKSFVsbFpWRVozVjBaWmQxcEdUbGhTYkVwWVZqSTFhMkZ0U2tkalNHaFdUVzVOZUZscldrdGpNazVGVW14a2FWZEhhRlZYVmxwaFUyMVdXRkpyYkdGU2JWSndWakJrYjJJeFpISlZhMlJvVFdzeE5GZHJhRTloUmtsNllVWlNXbGRJUWxoV01WcGhVakZrZEZKdGNFNVNSbHBKVm1wS05HRXlSa2RUYWxwcFVtMTRWMWxYZEV0Tk1WcDBaVWhPYW1KSFVqQmFSVnByVmpKS1NWRnNiRmRXUlc5M1dXcEdZV05yTVZsV2JXaFRZbGRvV1ZaR1ZtdFZNV1JIVmxoa1YxWkdXbGhVVm1oRFVqRlNjMXBIT1ZWaVIxSkhWV3hvYjFZeVJuSlhia1pWVm0xU1UxcFZXa3RYVjBaSVVteFNVMVpHV21GV01WcFRVakpSZUZwR1pHbFRSVFZvVlc1d2MySXhWblJsUjBac1lrWnNOVlJzWkRCV01rcEdZMFJDWVZOSVFreFdiWE40WkZaV1dWcEdaR2hOV0VKTVYydFNSMkV5VG5SU2EyUmhVbTFTVDFSWE1XOVdiRnAwWlVaT1UwMVhlRmhYYTFwclZUSktjazVZUWxaaVZFWlVXV3BHYzFaV1NuVmFSM2hYWWtoQ1NWWnRNSGhTTWtaeVRWWm9WbUV5YUZoWmJHaHZaV3hzVjFkcmRHdFNiRm94VlZkNGQxZEdUa1pUYkd4WFlXdHZNRmxVUm10U2F6RlhWbXhhYVZKcmNGQlhWbWgzVW1zeFIxZHVVazVTUlZwVVZGWmFkMWRXVlhsa1IwWlZUVmRTUjFZeU1VZFhiRnBHVjJwT1dsWldjRE5XTUdSWFUwWktjMkZHVGxkU2JIQlpWbXRTUjFsWFNYaFdXR3hUVjBoQ1UxWXdaRk5YVm14eVYyMUdhRkp0ZUZaVmJURXdWa1pLY21OR2NGcGhNbEoyVmxSS1JtUXlUa2RpUm1oWFRUSm9NbFpyVWtKTlZrbDRWMjVXVldKSGFHOVVWRVpMWlVaYVIxZHRPVkpOVlRWSVdWUk9hMVl4V2taWGJHUlZWak5TTTFVeFduZFNiRlp5VDFaa1RtRXpRbGRXVnpGM1ZERmFkRlp1U2xoaGVteG9WbXhhZDFWR1dYaGFSWFJUVFZad01GbFZWVEZoVjBwWVlVWm9WMkZyV25KVVZWcHpWakpLUjJGR1VsaFNNbWhZVjFkMGEySXlUWGhXYms1b1VtczFXRmxyV21GTlJsSlhWMnM1YVZJd2NFaFpNRkpEVmxaYWMxZHVTbHBXVm5CTVZteGFTMlJYVGtkWGF6VnBZbGRuZVZadE1YZFNNVTEzVGxoT1dHSnJjSE5WYlRGVFZrWldjMWR1WkdsTlYxSjVWbTB4UjFZd01YSk5WRlpXWWxoU2NsWnFTa3RUUmxaMVVXeGFhVlpGUlhoV1J6RTBXVmRPYzJORlZsSmlTRUpZV1d4b2IxZHNXbkpYYlRscFRXdGFlbFV5ZUc5aVJrbDVZVVprV21KSGFIWldSVnBoVWxaS2RWUnNaRmRoZWxZMFZtdGtlazFXVlhsVGJHUlVZa2hDV1ZsVVJtRmpiRlp4VTJ0a1UyRjZSbGhYYTJSM1ZURktWbU5HYUZkU2JVMTRWbFJLVTJNeFpIVlZhelZYVjBaS1ZsWlhjRWRaVms1WFZtNVNiRk5IVW05V2JYUjNaVlpyZDFadVRsZE5hM0JhVmxjeGIxZEdXblJWYkVKWFlXdGFVRnBHV2xOa1JrcHpWR3MxVGxaWVFsZFdiVEI0VFVaWmVHSkdaRmhYUjJoWldXdGtVMkZHVlhkaFJVNVdVbXh3TUZwVldtdFVNVnB6Vm1wV1lWSlhUVEZaVlZWNFl6RmtkV0pHWkU1aWJXZzJWbXBKZUZKdFZraFVhMmhvVW01Q1QxbHRNVzlXVmxwMFRWUlNhMDFWY0hwWk1GWnJWbTFLUms1WE9WVldSVXBMVkZWYVlXUkhUa1prUlRsVFlrVlpNVlpYTVRSaE1WcEhXa1ZzVW1KVWJGZFpiRkpHVFVaWmQxZHVUbXBOVmxwNlYydFZNVlJzV25WUmFsSlhWa1Z2TUZsVVNrZGphekZYWVVaYWFHRXhjRmxXVnpWM1VqRk9SMWRzVmxOaVdGSlVWRlpWTVdWc1duUmxSM1JXVFd0d1dGVXhVa3RXTVVwelkwZG9WMUpGY0U5YVZWcHJZekpLU0dKR1RrNU5iV2hXVm10YVUxSXhUWGhhUldSWVlUSlNXRmxyVlRGVk1WSldWV3hrV0ZKdGVIbFdNakZIVjBkS1YxZHVjRmROYm1oMlZteGFXbVZzVm5SaFIwWlhZa2hDV0Zkc1dsWk5WbHAwVld0a1lWSlVWbGhaYkZKdlRsWmFjMWt6YUU5U01HdzBXV3RhYTFaSFNraFZia1pXWWxob1RGZFdXbE5YUlRWWVQxVTFUbFpzV1hwV2Frb3dUVWRHY2sxV1pGUmliWGhXV1d0a1UyVnNiRmRYYkhCc1ZqQmFTVlF4V210aFZscEdWbGhrV0Zac1NreFdWekZYVWpGV2MySkhiRk5pUlhCYVZsZHdTMkl4WkhOYVJtaE9WMGhDVDFadE1WTlhSbXh5WVVaT2FHSldXbmxXTWpWRFZsWmFjMk5HYUZWV1JWcHlXVEo0YTJOck9WZGFSMmhzWVRGd1lWWXllRmRpTWxGNFYxaGtUbGRGV2xSWlZFcHZWMFpzVlZKdVpGVlNiWGN5VlRKek5WVXlTbFpqUld4V1lsaG9VRlpxUVhoV2JHUlpZMFprYVZaRldYcFdWM0JIVkRKU1IxWnNiR2xTYkZwdlZGWm9RMlF4V2xoalJVNWFWbTFTU0ZZeU5VZFZiR1JJVlc1T1ZtSllhRE5VVlZwVFZtMUdTRTlXV2s1U1JWbzFWa2Q0YjJReFdYaFRhbHBYWWtaS1lWWnNXbmRVUm5CR1YyeGthMUpVYkZoV2JYaHJZVlpaZVdGRldsZE5WMUl6VldwS1JtVkdaSE5hUmxKcFlrVndWVmRYZEdGWlZsRjRZa2hLVjJKdFVsVlZiWGgzVW14V2RFMVZaR2hTVkVaWldsVmFiMVpyTVZoaFNIQmFZVEZ3VEZsNlJrOWpNV1J6V2tkc1dGSXlhSFpXYTFwVFVqSkZlRmRZYUdGVFJUVnhWV3BPYjFkR1VsZFdibVJVVm14c05WcEZaREJoVlRGWFUyNXdWazF1VW1oV01HUkdaV3hHYzJGR1pHbGlhMHBJVmtaV1lXRXhXWGhhU0U1VllsaENUMVl3Vmt0VFJscHhVMWhvYTAxV2NFaFZNbmhoWVd4S2RHRkdiRmRpV0doTVZUQmFkMUpXU25OVWJFNU9WakZLWVZZeWRHRmlNa1pZVW1wYVYySnRhRmhWYlhoM1lVWmtWMXBHWkdwTldFSktWVEo0YjJGV1NsVldiR2hYVW0xUmQxcEVSazlqTVZwellVZDRWRkl4U2xsV1JscFhaREpXYzJFelpGaGlWR3hZVm0xNGQxZEdhM2RhUldSYVZteHdlbGt3V2tOWGF6RnhVbXRvVm1GclduSmFSV1JMVTBkS1NHRkZOVlJTVlc5NVZtMHdkMlF5VmtaT1ZXUnBVbTFvVjFZd1pGTlVNVlYzV2tjNWFsSnNXakJhVldoclYwWktjMkpFVGxoaE1rMHhWakJhWVdNeVRrVlJiVVpUVmpGS1NWWnFRbXRUTVU1SVZXdFdWV0pIVWs5WlYzUlhUVEZhZEUxWWNHeFNNRFV3VmtkMFlXRkdTblZSYXpsV1lXdEdNMXBWV21GalZrWjBaRVpPYVZac2NFbFdhMk14VXpKR1IxTnVVbWhTYldoaFdXdGFkMVJHV25OWGJVWllVakExUjFkcldsZFViVXBHWTBac1YyRXlUWGhXVkVwSFVqRk9kVk5yT1ZkV1IzaFhWbTB4TkZsVk1IaFhibEpzVW01Q2MxVnROVU5TYkZaWVpVaGtWMDFFUmxkV01WSkhWakpLU0ZSWWFGZFNSVnA2Vm1wR1UyTnNaSEpQVm1ST1lsZG9XVll4V2xOU01XeFhWV3RrWVZKdFVsbFpiRlpoWTJ4V2MxVnJaRmRpUm5CWldsVmpOVlpyTVhKalJXeGhVMGhDU0ZZd1pFdFNNV1IxVTJ4V1YxWnVRbmxYV0hCSFlUSlNWMVJ1VW1wU2F6VllWRmN4YjFkV1duSlhiWFJyVFZac05GWkhkR3RYUjBweVRsWnNXbUpHV21oWk1uaFhaRWRXU0ZKc1pHbFNiSEJhVjJ4V2EwMUdXbGhUYTFwcVVrVmFWMVp1Y0Vka2JGbDNXa1YwVTAxck5VcFZNbmhyWVVkRmVHTkdSbGRXZWtZMlZHeGFXbVZXU25KaFIyaFRZWHBXZGxkc1pEUlpWVEZ6VjI1S1dHSkZOVk5VVmxWNFRsWldkR1JIZEZoU2JWSkpXVlZhYzFkdFJYbFZiRkphWVd0YVZGWnFSbUZrVmxKeVQxWk9hVlpyYnpGV01WcFhWbXMxVjFwRlpGUlhSMUpZV1ZkNFMxbFdVbFpYYm1Sc1lrWnNOVnBWV25kaVIwcEhVMnh3V2xaV2NIWldha3BMVTFaR2RFOVdhRmhUUlVwSlYxWlNTMVV4V1hsVWExcG9VakpvVkZsWWNGZGtNVnB4VVcxMFZVMUVWbGhXTWpWUFYyc3dlVlZ1VGxaaVJrcElWVEZhVjJSRk5WZFViR1JUVFVoQ1NsWnNaRFJXTVdSelYydGFhV1ZyU2xsV2JYaDNWa1phZEdWSGRHcE5WMUl3V2xWYVQyRldTWHBhUkZwWFlsaENURlJWVlhoU01XUlpZa1pTYVZKdVFsRldiWGhyVlRGc1YxVnNXbGhpYlZKeFdXdGFkMU5XY0ZaYVJXUm9UVlp3ZVZZeU5YZFhiVVY0WTBoYVYyRnJjRXhWYlRGUFVtc3hWMXBHWkZOV00yTjNWbTB4ZDFJeFRuUldhMlJoVTBaYVdGbHJaRk5qUmxaMFpVaGthMDFXY0RCYVZXUkhZVEF4VjJOR2FGZE5hbFpVVmtkNFMxSnNaSE5VYkZaWFlraEJlbGRzWkRSaE1rNXpXa2hTVUZZeWFFOVdiR2hDWkRGYWMxbDZSbFJOVm5CWVZqSTFVMVp0U2tkVGJHUlZWbFp3TTFsVldscGtNWEJIV2taU1UwMVZjRWxYVmxaaFZERlNjMVJyV2xOaGF6VllXV3hvYjJOV2NFVlJWRVpYVFZkU01WWlhlRk5oVmtwelkwWldXRll6VW1oVmVrWnJVakZXYzFkc2FHbGlWa3BvVm0wd01WRXhaRWRhU0VwWFZrWmFWbFJYZEhkU01XdDNWV3RPV0dKVlZqUlpNRnBEVjJ4YWMyTkdRbFppV0doUVZteGFUMk14Y0VoaVJrNW9UVEJLVDFacVNqQlZNVWw0Vkc1U1YyRXlVbWhWYlRFMFlqRldkRTFYT1ZoV2JGWXpWbTEwTUdFeVNrZGpSbXhWVmxkb2RsbFdWWGhYUjFaSFlVWmtUbUZzV2xGV2FrSnJVekZPUjFadVRsSmlSbkJ3VmpCa2JtVnNaSE5XYlVaWFlsWmFXVlpIY0dGV01rcEhZMFU1Vm1FeFdtaFViRnBoVTBkV1IxcEhiRTVXTVVvMlZtcEtOR0V5Um5OVWExcHFVbTFvVjFsWGN6RlZSbEp5VjIxR2ExSlVSbGRVTVZwUFZqSktTVkZxV2xkTmJsSnlXWHBHYTFJeFRsbGlSMmhUWWtoQ1dWZFhkR3RpTURCNFZtNUdVMkpIVW5KVmJYaDNaVlprY2xkc1pHaFdhMncyV1ZWb1lWWXhXalpSYWxKYVlXdHdVRlZxU2t0VFZrNXpZVWRzYVZacmNGcFdiVEIzWlVaVmVGcEdaR3BTVm5CWldXeG9VMkl4VWxaVmEyUllWbXh3V1ZwRll6VldNREZ5WTBaYVYySllhRVJXYWtwSFkyMU9SbVZIUmxOV2JrSlpWMWh3UjJReFNYaGFTRkpwVW0xb1ZGUlhNVkpOYkZwMFRWaGtVMDFYZUZoV2JHaHZWMGRLYzFOc1VscFdSWEIyVmxaYVlXUkZNVmRVYld4T1YwVktXbGRyVm10U01XUklVMnRrYWxOSVFsbFdNR2hEVTBac1ZWRllhRmhTYkZveFdUQmFhMVJ0U25OVGJUbFhZVEZLU0ZsVVJrdGtSbEp5V2tkb1UySnJTbGxXUmxKSFUyMVdjMWR1U2xkaVZWcFpXV3hhWVZOR1pISmhSVGxhVm10c05sVlhjelZYYkZwR1YycE9WazFXY0doYVJWVjRWbFpXZEdGRk5WZGhNMEV4Vm10YVlWbFdiRmhTYkdSVVlUSlNjVlZ0TVc5WlZteHlXa2M1VTFKc1dubFdNakV3VmpBeFdGVnVjRnBOUjFFd1ZtcEtTMUl5VGtWV2JHaFhZa1p3YjFadGNFdFNNVXB5VFZaa2FWSnJjSEJWYkdoRFYxWmtXR1ZHVGxKTlJGWklWako0VjFVeVNsbFZiRkpWVmpOU00xVXllRlpsVlRGWVQxWmFUbFp1UWxkV2JURTBVakZrUjFkWWNGWmlWMmhvVld0V2QxZEdWbkZTYlVaWVZqQmFTRll5TVc5VWJVcEdZMFJLVjJFeGNGaFdWRVpLWlVad1IxcEdhR2xTTW1oUlZtcENhMVV4WkVkVmJGcFdZVEpTVDFadE1UUldNV3hXVm1wQ1dGSXdjRWhaYTFKaFYyeGFWMWRVUWxkaGEwWTBWakJhVjJOdFJrZFhhelZUWW10S1RsWXhhSGRTTVd4WVZGaG9hbEpYYUhOVmFrbzBWa1pzZEdSRmRGWk5WbkF3V1RCV01GUXhTbk5pUkZKYVlURndjbGRXV2s5U01VNXpXa1prVGxJeFNqSldha1poWXpKT2MxcElVbE5pUjJoVVdXeG9iMDVXV1hsa1IwWlZUVlp3VjFSV1dtOWlSa3AxVVcxR1ZWWldjRE5aTW5oaFkyeHdSbVJHVWxOaVJuQTJWMVpXWVdFeVJsZGFSV2hvVW5wc1dGbFVTbEpOUmxsNVRWWktiRkp1UWtwV1J6RnZWVEpLVjFOc1FsZGlXRUpNV1dwQk1XTXhjRWRhUm1ScFZsWndWbFpHV210Vk1VNUhWMjVTVDFaVWJHOVZiWFIzVFZaV1dFNVZUbGRpVlhCYVZsZHdUMVpyTVZkalIyaFdZV3RhV0ZreWVIZFNNWEJHVGxkb2JHSkdjR0ZXYlhoVFUyc3hWMWRZYUZoaVIyaFZXVlJLYjJJeFZuUmxSWFJhVm14d2VWWnNVa2RWTVVwMFZXeG9WMDFxUlhkV2FrRjRWakpPUlZGc1dtbFdSVm8yVm10a05GZHRWa2RVYmtwcFVtMVNXRlZzV25kTmJHUlpZMFYwVTAxVmJEUldWelZMWVVaSmVXRkdVbHBpUjFKMlZqRmFhMVl4Y0VsalJUVlhUVlZ3TmxkWGRHRlpWbVJJVTJ4c1ZtSkhhRlpXYlRGVFZrWndXR1ZHY0d4V1ZFWldWbGQ0WVZSc1NrWlhhM1JYVm0xUmQxUlZXbHBsVmtwWllrWldhR0pGY0doWFZtUXdXVlpaZUdOR1pGaGhNMUp4Vm0weFUyVnNaSEphU0U1b1ZteHNOVmxWV25kV01rcFZVVmhvWVZKRldreFpNbk40Vm14d1NHTkdUbGRpU0VKVlZtMXdRMkV5U1hoWGEyUldZa2RvY1ZwWGRHRldSbEpYVjI1T1QxWnVRbGRYV0hCWFlVWktjMkpFVGxwTlJuQjJWbTF6ZUdSWFJrbFRiR1JPVW01Q2FGZHNaRFJXTWsxNVVtdG9VMkpGTlZSV01GWkxWMnhaZUdGSVpGUk5WWEF3Vm0wMVQyRnNTbGhoUnpsV1lsaE5lRmw2Um5Oak1rWklUMVpvYVZKdGR6Qldha2wzVGxkRmQwMVdXbWxTUlRWV1ZtMTRkMk5zV25GVGEzUlVVakJhU2xaSGVHRmhWbVJHVFZSU1YyRnJTbWhXVkVaclUwWldjbUZHVG1sWFIyaFpWMWQwWVdSdFVYaGFSbFpTWWxWYVZsUldXbk5OTVZKWFlVVjBXRkl3Y0RCYVZWcHZWbFpaZWxGcmFHRlNNMmhoV2xaa1RtVnRSa2RhUlRWb1pXeGFTMVl4V2xkWlYxRjVVMnRvVTFkSGFIRlZNR1EwVjFaYWNsWnVaRTlpUmtwWVZqSXhNRlpHU25KT1dHeGFWbGRTZWxaVVNrZE9iRnB6WTBaa1YwMHlhRmxXYlhCQ1RWWkplRnBJVmxaaGVsWlpWV3BHUzFaV1drZFhiWFJQVW0xU1dGWnROVTloUmtsNlZXeGFWVlpzY0ROV01WcGhWMGRXU0dSR1pFNVNSVnBLVm14ak1WbFdXWGxUYTJScVUwaENhRlZzWkZOV1JsVjRWMjVrVTAxWFVucFdSekZ6VmtaS1ZsZFljRmRpV0ZKb1YxWmFjMVl4VmxsaVJrNW9UV3hLVmxkWE1YcE5WbVJYWWtab2ExSllVbGhaYTJRMFpWWlplVTFWWkZkaVJYQXdXbFZhYzFsV1dsZFhXR1JhVmpOT05GWXdXbGRrVjBaSFYyeGtiR0V4Y0VwV2JYaFRVakZrZEZac2FGTmhNbmh3VlcweFUyTkdXWGRYYTNScFRWWnNORll5TVRCV1YwcFhWMnhvVjFaNlZreFdha3BMVW0xT1NWRnNaR2xTYmtGNlZtMTRZVmxYVWtoVWExcGhVbXhLVDFac1VsZFhWbHB4VTFSR1ZrMVdTbnBYYTFaelZXMUtjazVXWkZwaVIyaDJXbGQ0VTJNeFpITlhiWGhYVFZWd1NWWXlkR0ZoTWtaWFYyeHNVbUV6UWxsV2JYaGhZMVpTYzFkdFJsZE5WMUo0VmpKNFQyRlhTa2xSYkd4WFlsUkZNRnBFU2tkU01rVjZZVVpvYUUxc1NubFdWM0JIVXpGT1IxZHNhR3BsYTFwWVZGVlNSMVl4YTNkYVJXUlhUV3R3U1ZaSGNGTldWbHBZVld0a1lWWnNjRXhaTW5oM1VqRldkR0pIYUd4aVJuQm9WbXBHYTAxSFJYbFRXR2hoVWxkU2NGVXdWVEZpTVZaMFkzcEdWVTFXU2xoV01qVnJZa1phYzJKRVZsVldiRXBFV1ZWa1IwNXNTbk5pUm1SWFRUQktSVlp0TUhoVE1XUllVbXRXVldKSFVtOVpWRTVEVkZaYWRHTkZaRlZOYXpVd1ZXMTBhMWxXU25KT1dFSldUVVphVEZwSGVHRmtSVEZaV2taT1RsWXphRnBXYkdRd1lURmFXRk51U2s5V2VteFhXVmR6TVdSc1duSlhiVVpxWWtoQ1JsWlhlRzlXTWtwWFUyeHdXR0pHV25GVWJHUkhWbXN4VjJGSGVGTmlWMmhaVm0xd1QySXlUbk5YV0dSaFVsaFNXRmxyWkZObGJHeHlWMjFHYUZJd1ZqUlpNR00xVmpGYVJsZHRhRmRXZWtaWVZXcEtUMUpzV25OVGJXeFRZa2hDTTFac1kzZE5Wa1YzVGxoT1lWSnRhSEZWYkZKellqRlNWMWR1VGs5U2JHdzFXa1ZrUjJGR1dYaFhibXhXVFc1b2VsWnFTa3RYVjBaRlZHeHdUbUp0YUZoWGExSkhZVEpPY2s5V2FHcFNNbmhZVm0wMVExTXhXWGhYYkdSYVZteEdOVlZ0ZUd0WFJtUklaVWM1Vm1KdVFucFdNRnBUVmpGd1IxTnRkRTVXTVVwWlZtcEtlazFYU2tkVGJrNVVZbTE0V1ZsVVJuZGtiR3hXVmxob1YwMXJOVWhXYlhodlZqSldjbE5VUWxkaVJrcElXVlJHU21WV1RuSmlSbEpwVmxad1ZWZFdhSGRXTVZaSFYyNVNUbFpHU25KVVZsVXhWMFphV0dWSGRHaFNhMncyVmxkNGIxWldXbGRUYTJoaFZteHdhRnBGWkU5VFJrcHpXa2RzVTJKWVkzbFdiRnBxWlVkSmVGZFlaRTVXVjFKeFZXcEtiMVl4YkhOaFJ6bFdVbTVDU0ZZeWN6VmhhekZYWTBSQ1dsWldWWGhXTUZwTFZtMU9SMk5HWkdoaE1qaDNWakZhWVdNeFdYaFdiR3hwVW14YVdWVnFTbTlsUmxwWVpVZDBWazFXYkRSWmEyaFBXVlpLTm1KSVJsWmlXR2hvV2xkNGMxWnNXbkpQVm1oVFRVaENTVmRYZEZOVk1WbDNUVmhHVTFkSFVsaFZhazV2VXpGd1ZsZHJPV3RXTUhCSVZtMTRhMkZXU25WUmFsWlhZbFJHTTFWNlJrcGxWbEpaWWtaV2FFMXNTbGxYVjNSdlVURmtSMVp1VG1oU1ZUVllWbTE0ZDAxR2NGWmFSV1JYVFVSR2VsVXlkSE5XTVVsNlVXMW9WMVpGY0V4V01XUkhVakpHUjJOSGFFNWlSVmt5Vm10YVlWbFdiRmRUV0doaFUwWktVVlpxU205VU1WcDBUbFZPVDFac2NFaFdNbmhyVmpBeFYxWnFWbFppVkZaTVZtdGtTMVpzWkhOaFJuQm9UVmhCZWxaR1VrZFZNVnBYVTI1U1UySllRbGhaV0hCWFRsWmtjbFp0Um1oTlZtdzFWV3hvYjJGc1NrZFRiR2hhWVRKU1UxUlZXbk5XVmtwelkwZDRWMkpJUVhoV1ZFbzBZakpHVjFOdVNtcFNia0paVm1wT1UyRkdaRmRhUldSVFRXczFSMVp0ZUU5aFJUQjNVMjV3VjFZelFrTlVWbHBLWlVad1NWTnRSbE5sYlhoWVZrWldVMUl3TVZkaVJscG9VakJhV1ZWcVFuZFRWbHBYVld0T1dGSnNjSHBaTUdoTFYyMVdjbGR1U21GU2JIQlFXWHBLUjFOSFNrZGhSazVvVFRCRmVWWnRjRWRaVjBsNVZWaG9WRmRIYUdoVmJHUlRWMVpzVlZOdE9XcGlSbHA0VmtkNFQxZEdXbk5YYWtKVlZteHdVRlpyV21Ga1ZrWnpXa1p3VjFac1ZYaFdiWEJMVXpGYWRGUnJWbE5pUm5CWVdsZDRXbVZzV25GVFdHaFRUV3MxZWxkcmFGTmhSa2wzVjJ4U1YyRnJXa3hXYkZwaFZsWktkRkpzV2s1aGVsWTFWa1JHWVdFeFdsaFRiR2hzVW14S1lWbFVTbEprTVZKeVYyMUdhMUl4U2tsYVJWVTFWVEF4UjJORVZsZFNNMmhvV1ZSR2ExSXhjRVpoUmxwb1pXMTRXVmRYZUc5aU1EQjRZVE5vV0dKSFVuRlphMXAzWlZad1JsZHRPVlpOYTNCS1ZWWm9hMVl4U25OalNFWlZZa2RTU0ZwRldrOWpiSEJJWWtaT1UxWkdXbHBXYTFwclpERkplRlJyWkdsU2JXaHhWRlJLYjJOV2JGbGpSbVJYVFZkU2VWZHJWbXRXYXpGWFlrUlNWazF1VW5wV2FrcExWMVpHY21GR2FGZGlWa3BWVm0xd1IxTXlVbGRWYmxKcFVtczFjRlp0ZEhkTmJGbDRWMnhPVTAxc1JqVldiWGhyVjBkS1NHRklSbFppUjFKVVZteGFjMk14WkhSU2JHaFRZa1paTVZaSGVGZE5SMFpIVTI1S2FWSkdXbWhXYkZwM1ZrWlplVTFWZEZSU2JGb3hWako0YTJGV1NuVlJibXhYWWxoQ1NGWnFTazlqYXpsWFdrWlNhVll6YUZsWFYzUnZVVEZrYzFkdVVtcFNXRUpQVm0xNFYwNVdWWGxrUjNSWFVtMVNTbFZYZUd0WGJVcFpWV3BPVjJKWWFHaGFSV1JYVTBaS2RHVkhiRk5oTTBFeFZtMXdTazFXVVhsU2JsSlVZVEpvVjFsWGRFdFdiRkpYVjI1a2FtSkdjRWxVVmxaaFlrZEtSbGR1YUZkaVdHaHlWbFJCZDJWWFJraFBWbWhZVTBWS1NWWnFTWGhWYlZGM1RWWmtXR0pYYUZSWmEyaERWMVphV0dWR1pHdE5hMXBJVjJ0b1QxbFdTa1pUYlVaWFlsUkdWRlV3V25OamJGWjBVbXhhVG1FelFYZFdiR1EwVlRGYVYxZHVUbXBTV0dob1ZtcE9iMlZzV25SbFIzUnFZWHBzV1ZsVldtdGhSVEIzVTIxb1YySkdjSEZhVlZwS1pVWmtXVnBGTlZoU2JIQllWMWQwYTJJeFpGZFhibEpPVm1zMVZGUldhRU5XTVZsNVpVZDBXRkpzYkROV01uUnZWakZhTmxKdWNGcFdiSEJNVmpGYVIyTldXbk5hUjJ4VFRWVlplbFp0TUhobGJWWkhWMWhvYWxKWFVtaFZha28wVmtac2NsZHVaRmRpUjFKWVdWVm9hMVl3TVZkU2FsSlhUV3BXVkZscldrOVNhelZXVDFaV1YySklRalpXUjNoaFpERktjMVp1U2xWaVYyaFVWRlZhY21WV1dsaE5SRVpxVFZad1dWVXlkR3RYUjBwWVlVWm9XbUpIYUhaWFZscDNWMFV4VmxwR1VsZGhlbFkyVmpKMGEySXlSa1pOVldScFVrWndXRlJYTlc5aFJteFZVbXR3YkZKck5WcFpWVnBUWVZkR05sWnRPVmRXTTJoVVZtcEdhMUl5U2tsVmJYUlRWMFpLZVZkWGRHRmtNbFpIVm01U1RsWlhVbTlWYkZKSFYwWlZlV05GVGxkTmEzQmFXVlZvUzFZeVNsVlNhM2hhVFdwR1VGVXdWVFZXTVdSMFlVZG9UazFGYkRWV2JUQjRUVVpzV0ZSWWJGWmhNbWhYV1ZSR2QyTnNWblJsU0dSWFVtMTRlbFl5ZERCWFIwcEhZMFZvVjJKVVFURlpWbFY0WTJ4a2MySkdXazVpYldoNVZtcENhMU15VWxkU2JrNW9VbXhhV0ZwWGVHRk5iR1J5V2tSU2FrMVhVa2xXYlhSaFlURktkR0ZHVWxwaE1YQXlXbFZhWVZaV1RuRlZiR1JPVm0xM01WWlVTakJoTWtaelUydGthbEp0YUZkWlYzTXhaR3hzVmxkdFJtcFdhelY2VmtkNFUxVXlTa2RqUkZaWVZteGFjbFJWV2xabFZrNXpXa1pTYVZJemFGbFdWekUwV1ZkR1IyRXpiRTVXYlZKWVZGWmtVMDFXV2xoamVrWllVbXMxUjFVeWVFZFdNa3BWVVdwU1YxWkZSalJWYWtaaFYxZEtTR1JHVG14aVdHaGFWakZrTkZZeVVYbFdiR1JZVjBkNFQxWnVjSE5YUmxKWVpFaGtWRkp0ZEROV1YzTTFWMGRLUjJOR2FGcE5Sa3BRVm0weFMxZFhSa2hoUm1ST1ZqRktTVlpYY0Vka01VbDRZMFZvYVZKck5YQldhMlF3VG14YWRHTkZaRnBXYkd3MFZqSTFTMVJzV25SVmJHaFhUVWRTZGxac1duTmpiSEJIVkcxd1YySkdjRFpYVmxaWFZERmtSMU51VW14VFNFSmhWbXhhWVZWR1duSlhhM1JyVWpGYVNsbFZXbUZVYlVwelUxaHdXRll6VW1oVmVrcFRVakZhZFZadGNGTmlWMmgyVmtaa05GTXhUbGRYYms1V1lUSlNXVmxzV21GWFZsWjBaRWhPV0ZJd2NFbFdWM2h2VmxaYVJsTnJlRmRTYkhCeVZqQmtUMUpzY0VkaFIyeFhZa2hDUzFac1VrdE5SMDE0VjJ0b1ZHSkdjRmxaYTFwTFdWWlpkMkZGVGxoU2JHdzBWakl4UjFkR1NsVlNiRnBYVm5wR00xWkhlRXRTYkU1VlVXeGthR0V4Y0RKWFdIQkhWVzFXUjFwSVRsZGlWM2hVV2xjeE5GWXhXblJOVkZKYVZqRmFlbFpYTlV0WFIwcEpVVzVPVjJGcldreFZNVnAzVW14a2RWcEdaRTVoTVZreVZsWmtOR1F4V1hsVGEyaFdZV3MxV0ZWclZtRmpiR3cyVW0xMGExWnNTakJaTUZwUFYwWkplV0ZIT1ZkTmJtaHlWRlZhYzFkR1VuVlViR2hZVWpKb2IxWlhlRk5qTVZwSFZXeGthRkpWTlZSVVZscExaV3hrY21GRk9XaFNiSEI1V1RCYWQxWnNXWHBSYTNoWFlXdHdURlpzV2t0WFZuQkhXa1prVTFadVFsRldNbmhYV1ZaUmVGcEdhRlJoTWxKWVdXeGtOR0l4VWxWUmEzUldWbXh3TUZSVmFHdGlSa3B6Vm1wV1ZrMVhhSFpXYWtwTFkyeGtjMWRzY0dsU2EzQTJWbXBDWVZsWFVraFdhMmhUWWxob1ZGbHJhRU5UYkZwSFZteE9WMDFYVWtoVk1qVlBZV3hPU1ZGdFJsVldWbkJvV2tkNFdtUXhjRVpYYlhoWFRVWndTMVpVU2pSaE1rWklVbGhrV0ZaRlNsaFpiR2hEVTBac1ZWTnJPV3RTYTNCNVYydGtSMVV4V2tkWGJtUllWak5TV0ZwRVJtdGpNV1IxVlcxNFUyRjZWbFpXUmxwV1pVVTFSMWRZYkU5V1ZHeGhWbTF6TVZOR1dYbGxSbVJZWWxWV05WWlhlRk5YYXpGSFkwZEdZVkpGV25KWk1qRlRVMGRLUms1V1pFNVdWemg1Vm0xd1MwMUdWWGhXV0d4VFlURndUMVl3Vm5kVlJsbDNZVVZPV0ZadGVGWlZNakExVjBaS2RGVnNhRmROYmxGM1dWUkdTMk14WkhWaVJsWk9WbTVDZVZkV1dtRlpWa3B6VjI1R1dHSkhVbFJaYTFwM1lqRlplRmR0Um1oTlZYQjVWRlphYTJGV1NYZFhiRkphWVRGd00xWlZXbUZrUlRGSllVVTFUbEpGV2xsV2FrbzBZakZTYzFOcldsaGlSbHBXVm0xNGQwMHhWWGhYYkZwc1ZqRmFTVlF4Wkc5Vk1rVjZVVmhrVjJKSFRqUlpha1phWlZaS2RWTnJPVmRpUlhCWFZtMTBWMWxYUmtkWGJsSnNVak5TY2xadE5VTlRSbHBJVFZoT1ZrMUVSbGRaYm5CSFZqSkZlRk5yYUZwV1JYQlRXbFphUzJNeGNFZFZiV3hwVW01Q1ZWWXhXbXRPUjFGNFdrVmthVk5GTlZkWlZFRXhWVVpXZEUxVVRrNWlSbG93V2xWa1IyRkZNVVZTYTFwV1lsaG9kbFpxUVhoalZrcHhWR3hrVjFKV2NFMVdiWGhoV1ZkTmVWTnJaR2hTYlZKUFZGY3hibVZXV25OWGJFNVRUVlV4TkZVeGFHOVpWazVIVjJ4U1dtRXhWWGhaYWtaM1YwZFdTRkp0ZUdsU2JrSmFWa1pXYjJJeFduSk5XRTVZWW01Q1dWbFVTbTlVUmxsM1drVjBWMVl3Y0VsVU1WcHJZVWRGZDJOR2JGZFNNMUpvV1RJeFVtVkdjRWxWYkU1cFVqSm9WVmRYZEdwT1IxWlhWMnhrV0dKVWJIQlVWbHAzWld4WmVXUkhSbWhpUlhCV1dXdGtiMVl5U2tkalJFNWFWbFp3TTFWcVJtdGpNWEJJWkVaT1RsSkdXa3RXTW5oWFlUSkplRlZ1VG1GU1ZuQlZXV3RrYjFkR2JITlZhMDVPVFZoQ1YxWnNVa2RWTURGeVkwVm9WMDF1VFhoV2FrWmFaVVpPZFdGR1pGZE5NbWh2VjJ0U1MxSXhTWGhYYmxaVllsVmFWRmxZY0Zka01WcEhWMjFHYTAxRVJraFpNRlpoWVVaSmVsVnVRbFppV0dnelZGVmFkMUpzVm5KUFZtUk9WbTEzTWxac1pEUlJNVmw1VW01S1UyRnNTbGhaVjNSM1ZFWldjMWR0ZEdwTldFSklWa2N4YzFVeFpFWlRhM1JYWWxSQ05GcEVSa2RrUmxweVlVWldhVkl4U2xaWFZ6RXdaREpOZUZadVVrNVdhelZ4VlcxNFlVMUdVbk5XYXpsWFZteHdNRlpYTlhOV01ERnhVbXRvV2xaV1ZqUlpNbk40VmxaYWMxcEdUazVOVlc5NVZqRmFWMWxXVG5SV2JHaFRZVEZ3VVZadE1WTlVNVlowWlVoa1ZWWnNjRWhYYTFKVFYyeFpkMDVXYUZaTmFsWlFWbXhrUzFKck5WWlBWbVJvWVhwV01sWnFSbUZaVmxwWFUyNVNVRll6UWs5V2JUVkNaREZhV0dWSE9XcE5WbkF3VlRKMGExZEhTbFpYYlVaYVlUSlNkbFpFUm5kV2JHUjFWR3hrYVZJeFNqWldNblJyWkRGU2MxZHVUbXBTUm5CWVZGYzFVMk5zYkRaU2JFNXFUVmhDUjFZeWVGTmhWazVHVTJ4d1dGWXpVbWhYVm1SSFVqSk9SbFpzVG1sU1ZGWjVWbGN4ZWsxWFZsZGFTRXBoVTBVMVYxUldWbmRsVm10M1YyNU9WMDFyY0ZwVlYzaERWakZhUmxkc2FGWmhhMXB5V2taYVMyTXhUbk5oUms1T1lsZG5NRlpxUm10T1JsbDVWVmhvVkdKck5WbFphMlJ2WXpGV2NWUnNUbWxOVm5Bd1drVm9UMVF4V25SbFJtUlhWbnBHU0ZacVFYaGpiVTVIWTBaa1YyVnNXazFXYlRCNFV6RmFWMU51VG1oU2JWSlBWVzAxUTFSV1pGVlRhbEpyVFZVMVNGVXlOVTlXVjBwWVpVYzVWVlpYYUVOYVZscGhaRWRTU0ZKdGFFNVNSbHBKVm10YWIyRXhVbk5hUlZwUFZtMTRZVmxzYUc5VVJscEZVbTFHYW1KSFVubGFSVnAzVmpKS1NWRnFVbGRXZWtWM1ZGVmFZVkl4WkhWVWJYQlRVbFZ3YjFaWGVHdFVhekZYVjI1U2FrMHlhSEZaYTJSVFZteFZlV1ZIZEdoV2JWSkhWRlZvYjFZeVNsbFJhM2hXWld0YWFGWnFSbXRrVms1elYyMXNVMDFWY0ZGV01XTjNaVWRKZVZac1pHRlNiWGh4Vld4a1UxbFdXbkZTYTNSVVZteHdXVnBGWkRCV01WbDNWMVJLVjJKVVFURldiRnBoWkVkR1JsUnNWbGRpU0VKdlYxUktOR0V5VWtkVGJrNXFVbTFTVDFWdGVISmtNVnB4VTJwQ1YwMXJiRFJXTW5SdlZrZEtjazVXVmxwaVdFMTRWbXBHYzJNeFZuSmFSM1JwVW01Q05GWlhNREZVTVdSSFUxaGtUMUpGY0ZkWmJGSkdaREZzVjFkcmNHeGlSbHBXVlcxNGIyRldTbk5qUkVwWFlURktTRll5TVZkV01WSjFVMjFzVTJFelFuWldSbU40WWpGa2MxcEdaRlpoTTFKWFZGVlNRMDVHV1hsa1J6bHBVbXR3TVZWWE5VOVdiVXBaVkZob1lWWldjR0ZhVm1SWFUwVTVWMXBGTlZOU1ZXdDNWbXhTU21Rd05WZGFSV1JZWW1zMVZWbFVUbTlXTVd4WVpFZEdWbEpzV25oVmJYTTFZV3N4Y21ORmJGcFdWbkJRVmtkemVGSnRUa2RYYkdScFVqRkZkMWRYY0VkU2JWWkhZMFZzVldKSGFIQlphMVozWlVaYVdHVkdUbXBOVmxZMFZsZDRhMWRIUlhwVmJGWldZbGhvTTFSVldsTmpNVnAwWkVaa1RsWlhkM3BXYWtaVFV6RlplVk5zVmxkaVJVcFlXV3hTUjFSR1dYaGFSV1JUWWxaYVNGWnRlR3RoVms1R1UyNWFWMkpHU2tSV2JURlhVakZ3Umxkc1FsZGlWa3BhVjFab2QxWXhXa2RXYms1WVltczFUMVJXV25OT1JsbDVaVWQwV0dKR2NIcFphMUpUVjBkRmVGZHVXbGRoTWxKSFdsWmtSMUl4WkhOalJtUk9UVzFvVGxadE1IaE9SMDE0VjJ4a1ZHSnNXbWhWYWs1RFkwWldkR1ZJWkU5U2JIQlpWRlZTUjJGRk1WZFdhazVWVm14d2VsWlhNVVpsVjFaSFdrWndhVkl5YURKV2JGWmhXVlphVjFOdVVsTmlSMmhZV1ZSR2QwNUdXblJOVkZKb1RXdGFSMVJXV25OVmJVcDBaVVpvVm1Gck5WUlpWVnBoVTBVeFYxcEdaRTVXTVVsNFZtMHhORll5UmxkVFdHeG9VbTVDV0ZacVRrTlZSbXh4VTJ4a1YwMVhVbnBaVlZVeFZrWkplV0ZHYUZkU2JIQm9XWHBCTVZJeFpITmhSM2hUWlcxNGRsWkdXbFpOVms1WFYyeG9iRkp0VWxoWmJGWjNWbXhXYzJGSGRGZFdiSEJIVmpJMWQxWXlTbGxoUjJoYVRWWndTRmw2Um5kU2F6VlhXa2RzYUUxSGREVldiWEJIVlRGRmVWTlliRlpYUjJob1ZUQldkMVF4V25OYVJrNVhWbTE0ZVZadGREQlhSbHB6WTBSQ1lWWlhhSEpaVlZwTFpFZFNObE5zV2s1aWF6QjRWbXhTUjFsWFRYaFVibFpxVW0xU1QxbFhkR0ZPYkZweFVXMUdWR0pXV2xsVmJYUnpWMGRLU0ZWdVFsZGhNVnBYV2tSR1dtVkdaSFJTYkZacFZteHdXVlp0TURGVE1rWkhVMjVLVDFaNmJGWldhazV2VkVac2NWSnRSbGhTTURWSFdrVmtjMVJzV25KWFZFSlhZa2RSTUZkV1dscGxWazV5WWtaS2FHVnRlRmhYVjNodllqQXdlRlZzV2xoaWJWSllXV3RvUTFJeFpISlhiVGxvVm10d01GcEVUbmRYUmxsNlZXeFNWMkZyV21oYVJWcFBZMjFHU0dGR1VsTmlhMHBhVm10YVYxbFhVWGxVYms1WFYwZFNhRlZzWkZOV1JsSlhWMjVrYkdKSGRETlhhMmhQVjBaS2NtTkdXbFppUmtwRVZtcEJlRll4VG5KaFJtaFhZa2hDYUZkc1dtRldNazUwVW10a1lWSXlhRTlXTUZaTFRsWmFjMWt6Wkd4U2JGWTBWbFpvYjFkSFNuTlRiRUpYWWtaVmVGWlZXbUZrUjFaSldrVTFVMkpGY0ZoWFZsWnFUbFphY2sxVlZsTmliWGhZVkZjMVUyUnNXblJqTTJocVZteHdlbFpYZUhkV01VcFhZMFV4VjFZelFraFpWRXBUVWpGT2RWVnNUbWxTTVVwUVZrWldVMUpyTVVkWFdHeHJVak5TVUZWdE1UUlhWbHBJWlVkMFZrMXJjRWxhVldNMVZtMUtWVkp1V2xkaE1YQjZXVEo0YTJSV1pIUmxSazVwVm10d1lWWXlkRmRoTVVsNFYxaGtUbGRGY0ZsWmEyUnZWakZTV0dOR1pGaFNiSEJaVkZaV01HRXhTWGhYYTJoYVZsWndNMWxWVlhoWFZrWnlUVlprYUUxV2NHOVdiWEJMVlRGS2NrMVdaR0ZTTUZwVVZGUkNTMVZHV25SbFJ6bFNZbFphU0ZZeU5VdFhhekI1WVVoS1ZWWnNjRmhVYkZwV1pWZFdTR1JHWkZOTlNFRjNWbXhrTkdJeFpIUlRhMmhvVW14S1dGUlZXbmRXTVhCWFZsaG9WMDFZUWtsWk1GVXhWMFpLVm1ORmVGZGlXRkp5Vkd0a1JtVldTbk5hUjBaVFZqRktWbGRYZEdGa01XUlhWMjVHVldKVWJHOVZiVEZUVjBaWmVVMVVRbFpOUkVaWlZsZDRkMWR0UlhoV1ZFWlhZV3R3VEZacVJrOWpNa3BIV2tkc1dGSlZjRVpXTW5SVFVqRlJlRmRZYkZSaE1sSlpXV3hrYjFaR1duTlZiR1JZWWtkU1dWcFZXbXRXTURGRlZtdG9WMDFYYUhwWlYzaExWbGRLUjJGR1ZsZGlTRUY2Vm1wQ1lXTnRVWGhqUldoUVZtNUNXRmxVVGtOWGJGcHpXa1JTYVUxV2NIbFVWbFpyWVd4S1dXRkhhRlppUjFKVVZtdGFWMlJIVGpaU2JHaFRUVVp3U2xkc1ZtdGlNVkp6VjI1T2FWSkdjRmhaYkZKRFRURndWbHBHU214U2JFb3hWVEp6TVZZeVNsZFRiR3hYWVd0S2NsUnJXbUZXTWtwSFZteFNhVkpVVmxsV2JURTBZekF3ZUZwSVNsaGhlbXhaVlcxNGQwMUdjRlpWYTA1WVlYcENObFZYZEc5V01ERjFZVWRvWVZKWFVsaFZha1pyWXpGa2RHSkdaRk5pU0VFeFZtcEdhMDFIUlhoVVdHaFVWMGRvVmxsdGVHRmpWbFowVFZaT1ZVMVhlRmxhVldSSFlrWmFjMk5FUWxwTlJsbDNWbXRWZUZZeVRrbGpSbWhvVFcxb1RWZFdXbUZUYlZGNFdraE9WbUpIVW05WlZFWjNWRlphUjFwRVVscFdNREUwVm0wMVMyRXhTbk5UYXpsWFlrWktXRll4V21GWFJURlZWVzF3VGxZemFGbFdWRWt4VlRGYWRGTnVTbFJpUjFKaFZtcE9VMkZHVlhkWGJFNVhWbXR3TUZwRldtOVZNREZGVm10b1YwMXVVbWhhUkVaYVpEQXhWbFpzWkdoaVJuQlpWbGN4TkdReVJrZGlSbFpVWVRKU1ZGUldWVEZYYkd4eVdrYzVWazFyY0VkWk1GcHZWMFpaZWxWdGFGWmxhMXB5VldwR2ExZFhSa2RoUjJ4WFZtNUNWbFpyV21GWlYxRjNUVlZrVjJKc1NrOVdhMVpMVm14c2MxWnNaRTlTYlhRelZtMDFUMWRHU25OaVJGcFhWak5vVkZZd1dtRmpNazVIV2tkR1YySklRbEZYV0hCTFV6RkplRnBJVW1sU01taFBWRlZXZDFkc1duRlNiVVpvVFVSR1NGWkdhSE5WTWtWNVZXeG9WMDFIVWxSV01WcHpZekpHUjFSdGNGZGlXR2cxVjFaV1YxUXhXa2RYYms1VFlXeEtXVmxVU2s1TlZscDBZek5vVjAxck5VZFhhMXBoVkd4WmVWb3pjRmRpV0VKSVYxWmFTMlJHVG5GWGJFcHBVakpvV1ZkWGRHOVJNa1pIV2toT1dHSlZXbFpVVjNNeFpXeHJkMVp0ZEZkaVZYQlpXVlZWTlZZeVNraGhSVkpZVm14d2FGcEZWWGhUVjBaR1QxWk9UbFpXYTNoV2JUQjNUVlpSZUZwRlpHRlNWMmhYV1d0a05GbFdiRlZTYkZwc1VtMTBOVnBWWkVkaE1VbDRWMnRrWVZKV1ZYaFdWRXBMVWpKSmVscEdhR2xTYkhCdlZtdFNSMWxYVG5KTlZteFVZa2RTYjFscmFFTlhSbHAwWTBVNVVrMVhVa2hXTWpWSFZrZEZlbFZzVmxaaVdHaE1XbFZhWVZkRk1WWmFSbVJPVWtWSmVsWkhkRk5STVZsNVUyeHNVbUV5YUZoWlYzUmhZMnhaZDFkcmRHcGlTRUpJV1ZWa2MxWXdNSGxoUmxwWFRWZE9ORlJWV2s1bFJuQkpWR3hvV0ZJeWFHaFdSbEpMVlRKTmVGWnVVbXhTYlZKUVZXMHhVMlZXV25STlZFSm9VbXh3ZVZSc1ZtdFhhekZIWTBod1YwMXFSa3hXTVZwVFYxZEdSMXBHWkZkaWEwcGFWakowVjFadFZrZFhXR2hXWW14S2MxVnRNVk5qUmxWM1ZtdDBXbFpzYkRWYVJWcHJWakpHTmxac2JGWmlXRkp5Vm10a1MyTnJOVmxTYkZwcFYwZG5lbFp0Y0Vkak1rMTVVbXRvVUZZelFuQlZiVFZEVGtaYVZWTnFRazVTYlZKSVZqSTFTMWRIU25WUmJHUlhZV3MxZGxreWVITldNV1J5WTBkNFUyRjZWalZXUmxwaFlURlpkMDFJWkZSaE1uaFpWbTE0UzFSR1dsVlNiSEJzVW14YU1WWnRlRmRoVmxwWFkwWldWMkpZVW1oWFZscGhWakZrY2xwR2FHbFNNVXA1VmtaYVlWTXlWbk5YV0dob1VucHNXRmxzVmxkT2JGWllUbFU1VjJKVmNGcFpWVlp2VmxkRmVHTkhhRlpOUjFKVVZUQmtVMUl4Y0VkVWF6VlVVbFZyZUZadGRHdE9SbXhZVTFob1lWTkdTbFJXTUdRMFZqRnNjbGRyZEZoU2JYaFdWVzAxYTFkc1duVlJhMXBXWWxSR1NGbFhNVXRXTVU1eVlVWm9hRTFzU2paV2JGSkxVekpPYzFOdVJsVmlSMUpQV1cweGIxZFdXWGhYYlhSVFlsWmFTRmt3Vm5OV1YwcElZVWhDV21FeFdqTmFWM2hoVjBVeFNXRkZPVk5pVmtwSlZtcEpNVkl4V2xoVGExcFBWMFZ3WVZsVVJuZE5NWEJXVjJ4YWJGWXhTa2xWYlRGelZUSktTR1I2UWxkaGEyOTNXV3BHV21Rd01WbFdiV2hUVWxSV1dWWkdWbUZrTVZaSFZtNVNiRkpVYkhGV2JURlRaV3hrY2xwSVRsaFNhM0I1V1RCb1lWWXdNVmhoUkU1V1pXdGFVMXBXV2xOWFYwcEhWbTFvVGxkRlNscFdNV1F3V1Zac1dGTllhR3BTYldoelZXcENZVmRXV25STlZrNVlWbTVDUjFkWWNGZFdiVVkyVW14a1ZXSkhhRE5XTUdSR1pWZEdSMUZzWkdoaE0wSk5WbTB4TkdFeVVrZFRiazVoVWpKNFdWVnFTbTlUYkZweVdrUkNXbFp0VWpCV2JYUnZWVEpGZVdGSVNsWmlWRVoyVm10YVUxWnNaSE5qUlRWWFlsWktObFp0TUhoU01rWkdUVlprYWxKdGFGaFVWelZEWVVaYWNWTnJkRk5OVlRVd1ZXMTRhMkZXU25WUldIQllZa2RSTUZZeU1WSmxSMDVHV2tkR1UyRjZWbmRXYlRFd1pERk9jMXBJU2xkaVZWcFdWRlphUzJWc1dYbE9WbVJXWWxWV05sWlhlRzlYYlVWNVZXeENWV0V4Y0ZSWk1uaDNVbXhrZEdWR1pHaE5NRWt5Vm1wS01GbFdWWGxTYkdoVVlUSlNjVlZ0ZUV0WFJteFlaRVYwYTJKR1dsWlZiVEV3VmpBeGNtTkZjRlpOYWtaSVZsUktSbVZzUm5OUmJHUlhaV3RKTUZac1VrZGhNVWw0WTBWc1ZHSkhVbGhWYlhoM1YxWmFSMVpzVGxOTlYxSklWbXhvYzJGc1NsaFZiR2hhVjBoQ1NGUldXbk5XYlVaSVVteG9hVkp1UWpaWFZFSnZVekZhY2sxVmFGWmhNbWhYV1ZkMFlXRkdiRFpUYTJSVFRWaENSMVJzVlRGV01WbzJZWHBHVjJKVVJUQlhWbHBXWlVaT1dXSkdWbGhTTW1oYVZtcENhMkl5VGxkV2JrNWhVbXMxYjFWdGVHRk5SbEpYVjJzNWFHSkZjSHBaYTFKUFZqQXhkVlZZWkZkaGExcG9XWHBLVDFKdFJrZGFSVFZvWVRGd1NsWnRNWGRSYlZaSFUyeGtVMkpyV2xkWmEyUlRWMFpTVlZOdE9XbE5WMUpZVm0weFIxWlZNVlpqU0d4VllrWndkbFpWV21Gak1rNUpVV3hrVGxKdVFreFhiR1EwV1ZaYVYxSnVVbE5pV0VKd1ZtMTBXazFHV1hsa1J6bFdUVlphU0ZZeU5WTmhSazVHVTJ4b1dtRXlVblpWYTFwV1pWZFdTR1JHWkU1V2JrSTJWakowWVZsV1VuTlhibFpTWVd4YVdGVnRlSGRYUm14VlUydGthazFXU25sV01qRjNWVEpLV0dGSGFGZGlXRUpRVmxSS1IxSXlSWHBpUjNoVVVqRktWVmRYZEc5Uk1VNUhWMnRvYkZKVWJGWlpiRlpYVGtacmQxWnVUbGROYTFZMVZrZHdVMWR0Um5KWGJGSmFUVzVPTkZadGVHdGtSMFpHVGxVMWFWWXlhR0ZXYWtaclRrZEplRkpZYUZaaE1sSlhXV3RhZDJGR1ZuTlhibVJxVFZad01Ga3pjRWRYUjBwSVpVWmtWMDFxUlhkV01GcExZMjFLUlZkc2NGZFdia0paVm1wQ1lWbFhVa2RXYkZaU1lsVmFWRlZzV25kbFZscFlZMFYwVkUxVk5WaFdiVFZMVkRGYWRGVnRPV0ZXTTJob1YxWmFZV014YTNwaFJUbFRUVlZaZWxaR1dtRmhNa1pHVFVoc1ZtSkhhR0ZXTUdoRFpXeGFkR1ZJVGxoV01EVkhWMnRhYjFVeVNrZFhWRVpYVWpOb2RsbFVSbHBrTURGWlUyMXdVMVl5YUZoV1JtTXhWVEpTYzFkdVJsTmlWVnBVV1d0V2QyVkdXbGhsUjNSVllrVndNVlZYZUhOWFJtUkpVV3Q0VjFKRldrdGFWbHBUWTJ4d1NGSnNUbWxXYTNBelZqRmFVMUV5VVhkTldFNVlZbXRhVkZsc1ZtRlhSbEpYVjI1a1RsSnNjREJhUldRd1ZqRkpkMk5GYkZkV00yaDZWakl4UzFkWFJrWmxSbkJvWVRGd1dWZHJWbFpsUmxsNFZXNVNhbEpyTlhCVmFrNXJUbXhhZEUxSWFFNVNWRVpJVm14b2IxZEhTbkpPV0VaV1lURmFURmRXV2xOV2JHUjBVbXhXVTJKSVFrcFhiRlpyVWpKR2RGTnNXbXBTVm5CWVZtcE9iMlJzYkZaV1dHaHJVakJhU0ZWdGVHOVdNa3BIWTBjNVYxZElRa2hYVmxwclVqRlNkVk50UmxOTmJXaFZWMWQ0WVZNeVVuTlhhMlJoVWtaS1ZGbHNXa2RPUmxsNVRsVmtWMUl3V25wVk1qRkhWakpLVlZKc1VsWmhhMXBVVm1wR1lXUldVblJoUms1b1RUQkpNbFl4VWtOV2F6VlhWMWhzVkdFeVVsVlphMlJ2VjBaU1YxZHVaR3BpUm5CNlZqSjBhMkV4U25KalNIQmFUVVp3Y2xsV1dtRmpiVXBGVkd4a2FWWkZTWHBXUmxwaFZXMVdSMk5GV21oU2JFcHZWRmN4YjJSc1dsaGpSVTVhVm0xNFdGbHJXbGRWTWtwMFZXMDVWbUpZYUhwVVZFWmFaVmRXUms5WGFHbFdXRUpLVm14ak1XUXhaSEpOVldoV1ZrVktXRmxYZEVkT1JsWnpWMjFHYW1KVldraFhhMXBQVlRGYWRWRnVXbGROVm5CVVZXcEdWbVZXVWxsaFJsWnBZVE5DV2xkWGRHdGlNa2w0Vld4b1QxWjZiRmxaYTFwM1RVWndSbGR0ZEZkU1ZFWjVWakowYjFZd01YVmhSbWhYVmtWd1RGVXhXa2RrVmxKeldrZHNXRkpyYkRaV2ExcGhXVlphZEZac2FGZGhNbWhSVm1wS2IxZEdVbFpYYkhCT1lrWndXRmRVVG10VU1WcHpZa1JTVjAxdVFtaFdWRVpoVW14T2RHRkdXbWhOVm5CSlZrWlNSMlF4V25OYVNGSlRZa2RvV0ZsdGRFdFRiRnBZVFZSU1ZVMVdiRE5VVmxwaFlXeEtjMk5HYUZwV1JWb3pXVlZhYTFZeFpISk9WM1JPVWtWYVdGWXlkR3RqTVZwSFUyeHNVbUpJUWxsV2JURnZUVEZzTmxOcmNHeFNiVkl4Vmxkek1WWXlSalpXYkZwWFZucEZNRmRXWkZkak1rcEhWMnh3YkdKR2NGbFdSbFpUVWpKV1YyRXpaRmhpVlZwWVdXeFdkMU5HVlhsa1JrNVhUVVJHTVZsVlpHOVdWMHBaWVVWNFdtVnJjRWhWYWtaclpFZEtSMkZHVGxkU2ExbDZWbTB3ZDJReVVYbFdhMlJVVjBkb1ZWWXdaRzloUmxWM1ZsUkdhVTFXV2pCWk0zQkhWbFV4VjFOc2JGVldiVTB4VmpCYVMyTXlUa2xoUmxwcFZrVmFTVlp0TVhwbFJscHlUVlpXVm1KSFVuQlZha3B2VFd4YWNWRnRkRlJOVlRWSVZtMDFWMVZ0U2tkalJUbFdZbFJXUkZaR1dtdFdWa3AwVW0xMFRsWXhTa3BXYkdRd1lqRlZlVk5yYUdoU2JFcGhXVlJLYjFFeGNFVlNiVVpUVFZkU2VsWkhlR0ZVYkZsNFUydHNWMkZyYTNoV2FrWlhaRVpLV1dKR1dtbFNNMmhvVm0xMFYxbFhSa2RoTTJ4c1VtNUNjbFJXWkZObFZuQkdXa2hrYUZac2NGWldiWFJyVmpGYWRGUnFVbFpoYTFwaFdsVmFhMWRYU2toU2F6Vk9UVVZ3V2xZeFdtdE5SMUp5VFZWa1lWSnRVbGxaYkdoVFZrWlNWMWR0Um14aVJuQXdXbFZWTldGR1duSmlSRkpXVFdwV2NsWnFSbUZPYkVaWllVWmFWMUpXY0ZWV2JYQkhaREZPVjFSdVRtRlNNbmhaVlcxMGQxZHNXbkpYYlVaWFRXc3hNMVJzV210V01rcHpVMjVLVm1Gck5WUlhWbHBoWkVkU1NWcEdaR2xTYmtGM1ZrZDRWMVF4WkVoVGJGcFhZV3hLV0ZSWGNFZFRSbVJYVjJ4d2JHSlZXa2xWYlRGSFZqRmFkVkZ1YkZoaE1WcHlWbFJHVDFOR1duSmhSMnhUWWxaS2QxWlVRbGRUTVZKSFYyNVNUbFpGU205WldIQkhWMFphUjJGSE9WZGlSMUpKV1ZWYWMxZHRTbGxVV0doYVRWWndXRnBHWkU5VFZsSnpXa1UxVjAweVp6SldiWGhyVGtkRmVGWllhRlJpYkVwelZUQmtiMVl4YkhOaFJ6bFdVbXh3ZUZWV2FHOWhiVXBJVlc1c1dHRXhjSEpXVkVwWFkyeGFXVnBHWkdsWFJVcE5WbGh3UjFReFdYaFRibFpUWWtkb2NGVnFSa3RrTVZwWVkwVmtVMDFFUWpSV01uUnJWakpLVmxkdFJsZGlXRkl6V2xaYVUxWXhaSFJrUm1oVFRVaENZVlpXWkRSVk1WcDBVMnRrV0dGck5WaFVWbHAzWVVaWmQxcEZPVk5oZW14WVZqSnpNV0ZGTVZsUmEzQlhUVmRSZDFkV1pFWmxSbkJHWVVaT1dGTkZTbGhYVnpFd1pERlplR0pJVG1oU2VteHZWVzAxUTFkV2NGWmhSVGxvWWxWd1NWWlhjRU5XYlVwWllVWm9XbFpzY0V4V01WcEhZMVprYzJGR1pGTldXRUpaVmpKNFYxbFdaSFJXYTJSaFVtMTRjVlZ0ZUhkalJscHhVMjA1V0dKR2NEQlVWbEpUWVRBeFZrMVVVbHBOUm5Cb1ZqQmtTMlJHVm5OV2JHUnBWMGRvYjFaR1ZtRmtNVXB6V2toS1VGWXlhRmhaVkU1Q1pVWmFWMXBJWkZWTlZtdzFWVEo0VjFWdFJuTlRiRnBhVmtWd1ZGWlVSbmRXYkdSelZHMXdUbGRGU2twV1Z6RTBWREpHVjFOdVZsSmlSbHBZVkZaa1VtUXhiRlZTYkZwc1ZteEtlbGRyV21GaFZrbDRVMnh3V0ZaNlFqUldWRVpoVmpGa2RWVnRlRk5pVmtwUlZtMHdNVkV4V1hoYVNFcFhZbGhTV1ZWdGRIZGxWbXh5VldzNVdHRjZSa2hXTWpWaFZqSktXVlJxVWxwTlZuQk1XVEl4UjFJeGNFWk9WMnhwVmpKb01sWnRlR3BrTWxaSFZWaG9WV0pIVW1oVk1GVXhWMVpzYzFwSE9WVk5WbXd6Vm0xMGExUXlTa2RqU0hCWFZqTlNVRmxWVlhoV01rcEZWV3hrVTAweFNubFdiWFJyVXpKT2NrNVdaRmhpU0VKWlZUQldTMWRXV25GU2JVWlhUV3N4TkZZeU5WZFpWa3B6VTJ4U1dtRXlhRU5hUkVacll6RmFkR1JGTlZOaVJWa3dWbFJKTVZReFdYbFNiazVVWWtkb1dGbHROVU5YUmxwV1YyeHdhMDFYVWpCYVJWcFRWVEF4UjJORmJGZGlWRVV3V2tSR1dtVkdUbk5oUmtKVVVqRktXVmRXWkRCVE1rWkhZa1JhVTJKWVVsVlZiWGhoWlZac2NsZHRPV2hXYlZKSVZUSjRRMVl5U2xsUmJFSmFZV3RhWVZwVldtdGpNa1pHVGxaU1UwMXRhRkZXYkdONFRrZFJlRlJyWkZkWFIzaFFWbXhvVTFac1VsZGFSazVVWWtaYVdWcFZZelZXTVZwellucEtWMkpVVm1oWFZscEtaVzFHU1dOR1pHaGhNVzk2VmxjeE5HRXlVa2hXYTJSVllYcFdWRlZ0ZUhkVE1WcDBZMFYwVGxKdGVGbFZiR2h6VlRKS1NGVnRhRlppUjFKMldXcEdWMlJYVGtsVWJHaFRZa2QzZWxkV1ZsZFVNVnBIVTI1U2JGSnNjRmRaYkdoVFRURnNjbGRyZEd0V2ExcDVXVlZhZDJGRk1YTlRhMnhYWWtaS1RGVjZSbXRUUmtweVlrZEdVMkpXU25kV2FrSnJZakpKZUZwSVNsWmhNMUpZVkZaYWMwNUdaSEpoUlRsb1VtdHNObGxWV2xOWGJHUkpVV3hvVjAxV2NHaFZha1pyWkVkU1IxZHJOVmRXUmxwS1ZtMXdSMkl5VFhsU1dHaFVZV3h3Y0ZWdGVIZFpWbXhWVW01a1RtSkdTbGxhVldoUFlXMUtTRlZxUWxaaVdHaDJXVlphWVZZeFpGVlJiR2hYVWxWd1ZWWnJVa2RYYlZGM1RWWmtZVkl6UWxSVmJGSlhWMFprV0dSSFJtdE5WbkJJV1RCV2ExZEhTblJWYkZKVlZtMW9SRlZxUmxOak1YQklUMVpXYVZJeFNraFdWM2h2WWpGWmVWSnVTbGhpYTFwV1ZtMHhVMVV4Y0ZaWGEzUllWakJhU1ZWdGVGTlZNVnBIVjIxR1YwMVdjRlJWYWtwU1pVWndSMXBIYkZSU1ZGWnZWbGMxZDJNeVNYaFdibEpzVWpCYWMxbHJXbk5PVmxKeldrUkNWMDFyY0VkWk1GSkRXVlpPU1ZGcmVGZGlXRTQwV2taYVYxZFdjRWRhUjJoT1YwVktUVll5ZEZOU01rVjVWRzVTVTJFeVVtaFZiVEZUVkRGU1dFMVhPVmRpUm5Bd1dsVmFUMVV3TVZobFJtaFlZVEZ3Y2xaVVNrdGphelZaVVd4YWFWWkZXbFZYVjNCSFl6RmFWMU51Vm1GU00yaFlXV3RvUTFOV1duUk5TR2hUVFd0YWVWUldXbTlXYlVWNVlVWm9XbUpIYUhaYVYzaHpWakZrY21SSGRGTmlSbTk0Vmxaa05HUXhaRWRVYTFwVVlrZDRXRmxYZEhaTlJteFZVbTEwVTJGNlJsaFdiWGhoWVZaS2NtTkdRbGRpVkVWM1ZqSnplRkl4WkhWU2JGSlhVbFp3VjFaR1dtdE9SbVJIVmxoc1QxWllVbFpVVmxwM1RVWnNWbGR0ZEZoaVZYQklWVEowYTFaV1dsZGpSRTVYWVd0YWNsbDZTazlUUjFaSFdrVTFWMWRGU2tsV2JYaGhZVzFXU0ZSWWFGZFhSMUpQVm14a05GVXhiRlZVYTA1WVVtMTRlVmRyVlRGaVJrcDBaSHBLVm1KVVJYZFdhMXBMWTIxT1IyTkdjR2hOYkVveVZteFNTMUp0VVhsVWEyUnBVbTFvV0Zsc1drZE5NVnBZWTBWS1RsWnJiRFJYYTFweldWWktkR0ZJUWxaaGExcE1XbFZhYTFkSFVraFBWa3BPVmxSV1NWWnFSbTlqTWtaMFZtNUtXR0pVYkZoWlYzUkxUVEZXY1ZKc2NHeFNNRnBLVjJ0YWExUnRSWHBSYkdSWFZucEdNMVpFUm1Gak1XUnhWMnhPYVZJeWFGaFhWbVF3V1ZkT2MxZFlhR0ZTV0ZKVVZGWmFkMDFHYkZaV1ZFWm9WbXR3V2xWV2FITldNa3BaWVVoR1lWSkZjRmhWYWtaaFYxZEtSMVZzYUZOTmJXZ3pWbXhqZUU1R2JGZFhhMlJwVTBaS1QxWnRjekZYVmxaMFpVZEdUbEpzU2xoV01uTTFZVlpKZDJORmFGcE5Sa3BFVm14YVlXTXhUbkpWYkdSb1lURndUVlp0ZUdGVE1rMTRZMFZrYWxJeWFFOVdiR2hEVm14YWRHTkZkR3hpVmxwSVZURm9iMWxXVGtkWGJGWmFZVEpTVkZrd1dtRmpiRnAwVW14V1YySklRalJXVm1ONFRVWlZkMDFXV21wVFIzaFdWRlphZDJOc1pGZFhhM1JYVm14d2VsWlhlSGRoUlRGMFlVVldWMkV5VVRCWFZtUlBWakZPZFZWc1RtbFRSVXBaVjFkNFlWTnRVWGhYYmxKT1ZrVktiMVJYZEdGU01WSldZVWhrVm1KVmNGWlphMXByVjIxRmVHTkZlRmROUm5Cb1dUSjRhMk14VW5OYVJUVlhZbXRKTWxZeFVrTldhekZYVmxoc1ZHRXlhSEphVjNSaFYxWnNWVkp0Um1oU2JYaFdWVEowYTFVeVJqWlNiSEJXVFc1b2RsbFdXa3BsVjBaSFlVWmtVMkpXU1hwV2JYQkhXVlpKZVZOclpGaGlSMmh2V2xjeE5GWldaRmhsUmxwT1ZtczFTRmRyYUV0WFIwcDBWV3hvVlZaV1NrUlVhMXBXWlZkTmVtRkdhRk5pU0VJMlZtcEplR0l4WkhSV2JrcHFVbXRLV0ZsWGRHRlZSbkJIVjJ4T2ExSnJjSHBXUjNNeFZHeGFXVkZzWkZkaVZFSTBWRlZhYzFZeVNrZGFSMFpUVmpGS1dsZFhNVEJrTWtaSFZtNUtXR0V6VWxoWmExcExWMFpaZVdSRVFtbFNNSEJJV1d0U1YxWlhTa2RqU0VwWFlsUkdURlp0ZUd0a1YwNUhZMFUxVTJKclNYbFdiWEJLWlVaS2RGWnNaRmRpYXpWV1dXdGFZVmRHV25ST1ZVNVBZa1p3TUZwVlpFZFdSVEZ5VFZSV1YxSXpVblpaVkVaTFZsWmFjMVZzV21sU2JrRjZWbXBHWVZsWFVrWk5WV3hvVWxSc1ZGbHJWbHBOVmxwWVRWUlNhRTFXY0VoWGExWnZZa1pLTm1KR1pGcFdNMUl6V2tkNFdtUXhaSE5hUjNSVFRWWndTbFpYTUhoa01rWlhVMWh3YUZKR1NsaFdhMVoyVFVac1ZWTnJaR3BoZWtaWVdWVmFZV0ZIUlhoalJteFhWbnBXTTFWcVJrOVNNV1J6Vm14T2FWZEdTbFZXUmxwV1RWZFdjMWR1VW14U00xSlhWRmQwZDFkR1ZYaFZhM1JYVFZWd2Vsa3daRzlXTVVwR1kwVTVZVlpXY0hKWmVrcExVMGRLUjFSck5VNWlWMmhZVm0xNGEyUXhTWGhVV0doaFVtMVNXVmxVU2xOaFJsWnlWbXQwYW1KR1NsaFhhMXBQVmtaS2MyTkljRnBXVjJoUVdWVlZlRlp0U2paVGJIQm9UVmhDTmxadE1IaFNNazV6Vkc1T2FGSnNXbTlVVm1oRFYwWmtjMWR0ZEZaTlZUVkhWREZhYTJGR1NYbGxSbEphWWxoU1RGVXhXbUZrUjA1R1kwVTFWMkY2UlRCV2FrWnZZVEZTYzFkc2FGWmlhMXBYV1d4b2IxUkdaRmRYYkU1WVVsUldXVlF4VlRGVWJGcHpWMWh3VjJGcmIzZFVWV1JIWTJzeFYxcEdVbWxpV0doWFYxZDBhMVV5Vm5OaVJtUllZa2hDYzFacVFtRlRWbEY0VjIxMGFGWnNjRWRXYkdoclYwWmFjMU5yZUZkV2VrWllWV3BHVjJNeVNraGlSazVwVWxoQ1lWWnNaSGRTTVUxNFZteGtXR0pzU25OVmFrNVRWakZTVjFwR1RsaFNiR3cwV1ZWa01GZHNXbkpqUldoV1RXcFdTRll5TVVabFIwNUlZVVpXVjFadVFqVlhiR040VkRGS2MyTkZaR0ZTTW1oeldWUkdkMWxXV1hsbFJtUnBUV3hHTkZZeGFHdFViR1JHVjJ4U1dsWkZjSFpXTUZwelZsWktkVnBHVmxOaVdHTjVWbFJLTUUxR1ZYaFhiazVZWW01Q1lWUlZXbmRqYkZweFVWaG9VMVpyV25oV1YzaHJZVlphUmxkWWNGZFhTRUpJVmtjeFYxSXhjRWxXYkZwcFVteHdkbFpHV205Uk1sRjRWMnhvYWxKVk5XRldiVEZUVTBaWmVVNVZaRlppUjFKSlZsYzFUMVp0U2xsaFJFNVZWbFp3VkZadE1VZFRSVGxYV2taT1YxSldjR0ZXYlhoclRrZE5lRmR1VWxSaVIzaFhXV3RrYjFkR2JISmFSazVWVW14V00xWXllR3RoYlVZMllrWm9XR0V5VW5wV2FrWkxZekpPUmxkc1pHbFhSVXBKVmpGYWExSnRWa2RhU0U1aFVteEtjRmxyVm5kV1ZtUllaRWRHV2xac1JqUlphMmhMVmpKS2RGVnNWbFppV0dnelZXMTRWMlJGTVZaYVIyaFRWa1ZhTlZacVNqQmlNVnB5VFZab2FGTklRbUZaVkVaM1ZFWnNObEpyT1dwTlYxSjZWMnRrYzFkR1NYbGhTRnBYWVRGd1ZGVnFTa1psUm1SWllVZEdWRkpyY0ZWWFYzaHZVVEpPUjFadVJsTmhNMEp5VkZaYWQxZFdVbFpoUnpsb1lYcEdXRlV5Y0VOV2F6RjFWVzFvVjAxR2NHaFZiWGhQWXpKR1IyTkhhRTVpUlhCUlZqSjRWMWxXYkZkVGJHUlVZbXhLY2xWdGVFdFdSbXhaWTBaYWJGSnNjRlpWTWpWM1ZERmFkRlZyYUZaTmJtaHlXVmQ0UzJSSFJrZGlSbVJvWVhwV01sWnRkR0ZXTWs1WFZHNU9WV0pZUWs5V01GWkxVMVpaZVdSSFJtbE5hMXBaVlcxd1lWWXlTa2hsUm1oYVlrWktTRlJ0ZUZOV01WcFpZVVpPVGxac2NHRlhWbFpoWWpKR1YxTllhRlJpUjJoWVZXMHhVbVF4Y0VWU2JYUlRUVlp3V2xsclpEUldSa3BWVm14c1YxSnRVWGRYVm1SWFZqSktTVkpzVm1sWFJrcFpWbTB4TkdReFpFZGhNMlJZWVhwc1lWWnRlSGRsYkd0M1YydE9XR0pXV25sV01qVkxXVlpLV0ZWc1FsWmhhMXBVV1hwR2QxSnJOVmhpUm1ST1lsZGtOVlp0TUhka01sRjVWbXRhVDFaWFVuQlZiVEZ2VmpGWmQxcEdUbFZOVmxZelYydGpOV0ZzU25OWGFrSmhWbGRvY2xZd1drdGpNa3BGVkd4b2FFMXJNSGhXYWtKaFdWZE5lVlJyVmxKaVZWcFVWbXBHUzFOV1duRlJiWFJVVFZVMVNWWlhkRmRXVjBwSVZXczVXbFl6VWxoVVZFWmhaRVV4V1dOSGVGTk5SRlYzVm10a01GbFhSa2RUYmxaU1lYcHNWMWxYZEVkTk1YQldWMjFHYWxacldqQmFSVnBQWVZaYWMyTkZiRmRoTWsxNFZYcEtSMUl4VG5WVmJXaFRZbGRvYUZkWGRHRmtNVkpIVjI1T1dHSlZXbGxWYWtFeFVqRmtjbGRzWkZWaVZYQkhXVEJhYzFZeVJYbFVXR2hYVmtWd1NGVnFSazlrVms1eVQxWmtWMUl6YUZoV2JUQjRUa1pzVmsxSWFGaGliRXB6VlcwMVEyTXhWblJPVlU1VFlrWmFXVnBWYUd0V01ERkZVbXhrVjAxV1NraFdha3BMVTBaU1dXRkdaRk5TVm5BMlZtMXdSMVV5VG5OYVNFcFFWbTFTVDFsc1pHOVhWbGw0VjJ4T1UwMVhlRmhXVjNScldWWktkRlZzYkZwaVJscG9XVEo0VjJNeFZuSmFSbWhUWWtoQ1NsZHNWbXBPVmxweVRWaEthbEp0YUZkVVZ6VkRWMFphY1ZOclpHcGlWWEJHVmtkNFYyRldTWGhUYTJ4WFZucEdObHBWV2xwbFJuQkpWVzF3VTJKRmNGVldSbEpMWWpGa1IxZFlhR0ZTUlVwaFZtcEdSMDVXVm5Sa1IzUllVakJ3ZVZSc1duTlhiVXBIVjIxb1drMVdjRlJXTUdSUFRteEtjMVZ0YkZOTk1VWTJWbTF3UzA1SFJYaFhXR1JPVm14d2NWVnRNVzlaVmxKV1YyNWtXRkpzY0hoVk1uUXdWMFphY2xkdWJHRldWbkJvV1ZWa1JtVkhUa1pOVm1oWVUwVktUVlpyVWtkVE1rMTVWR3RhYUZKck5YQlZiRkpYVjFaYVdFMVVVbXROUkVaNlZqSTFTMWRIU2xaWGJVWlhZV3RGZUZSVldtRmtSMVpJWkVab1UySldTa3BYVmxaaFl6RmtkRkpZYkZaaVJrcGhXVmQwWVZaR1duRlNiVVpyVm14S2VWUXhXazloVmxweVlucEdWMDFXY0ZoV2JYTXhWakZ3UmxwR1VsaFNNVXBaVjFaa05GTXhiRmRWYkZwWVltMVNjMWxyV25OT1ZuQldWMjVrYVZJd2NFaFZNbmgzVjJ4YVYyTklTbGRTTTJoTVdrWmFSMk15U2tkaFJtaFVVbFZ3U2xZeFdsTlRNVlY0VjFoc1ZXRXhjRmxaV0hCelYwWmFjbGR0UmxoV2JWSlpXa1ZrZDFReFdsVlJhbEpYVFZkb2VsbHJXa3RrUmxaMFQxWldWMVpyY0VsV1ZFWmhWakpTUms1V1dtdFNiRnB3VlcwMVFtUXhaSE5XYlVaVlRWZFNlbFl5ZEdGaFYxWnlVMjFHVjJKR2NETldNRnB6VG14S2RHUkhkRmRpYTBwS1YxUkNhMk14VlhsVGJrcFVZVE5TV0ZSWE5XOVhSbHAwWTNwR1YwMVdjRnBaYTFwVFlVVXhXVkZzUmxkaGEwcHlWR3RrUjFJeFduVlViR2hwWWxaS2VGZFhkR3RPUm1SSFYxaHNhMU5IVW05VVZWSkhVbXhhZEdSSFJsZGlSbXcyV1ZWb1MxWXhXa1pTYWs1aFZsWndVRnBGVlRWV01YQklZa1pPVGxKR1JqTldiVEI0WkRGSmVGUnVVbGRoTW1oV1dWUkdkMkZHVm5GVGFsSlhVbXhLVjFZeU5XdFdNVnB6WTBSQ1lWSlhVa2hXTW5oaFpFWldjMkZHYUdoTldFSXlWMVpTUjFNd05YUlRhMlJWWWtaYVdGUlVTbTlUVmxwSVpFZEdXR0pXV2xsV2JYUnZWVVpaZVdGRk9WZGlSMUY2V2xkNFlXTldUbFZTYkZKT1ZtNUNXVlpxU1RGVk1WcDBVMnRrVkdKSFVsWldiRnAzVFRGc1ZsZHNjR3ROV0VKSVYydGFVMVV3TVZaalJXeFlWbXhhYUZaRVJsTmpNVkp5VjJ4T2FHRjZWbGxYVjNodllqSk9WMk5GVmxKV1JWcFlWRlprVTAxV1dsaGxSazVvVm10d2Vsa3dXbGRYUmxsNlZXMW9WbVZyV25KVmFrWlhZekZrYzJGSGJHbFdhM0J2Vm0wd2QwMVdSWGhhUldSWVltczFWMWxVU2xOWFJsSllaRVp3VG1KSGVIbFdNakExVjBkS1IyTkdhRnBOUm5CRVZqSjRZVll4V25GVWJVWlRVbFp3VVZadGVHRlVNazE0WTBWb2FWSnJOVzlVVkVKTFZERmFjVk5xUWxaTlZXdzBWa2MxVTFZeVJYbFZiV2hXWWxSRk1GbHFSbGRrUlRGWVQxWm9WMkpHV1hwV2JURXdUVWRGZVZOclpHcFNiWGhXVm14a2IyUnNiRmRXV0doWVVqRmFTRmxWV210VWJVWnpWMnhHVjJGclNuSlZla1pQVWpGYWRWUnNTbWxTYmtKM1ZtcENhMkl3TlhOWGEyaHJVakJhV1Zsc1dtRlhWbHBZWkVjNWFFMVZiRFZaVlZVMVZqSktWVlpyVG1GV1ZuQm9WbXBHZDFKV1JuUmlSVFZYVFZWd1MxWnNaRFJpTWtsNVVtNU9WV0V4Y0hGVmFrSmhXVlphY2xadVpGZFNiRnA0VlcwMWExVXhXbkpPV0d4WFRXcEZNRmxXV2s5U2JFNXlZa1prVG1Kc1NubFhXSEJIWVRGSmVGUnNiR2xTTW1oVVdXdG9RMWRXWkZoa1IzUnBUVVJDTkZadE5VZFZNa3BJVlc1S1ZtSllhRE5hVmxwclkyeGtjMXBIYUZkaE1uY3lWMVpXYjFsV1dYaFhhbHBTWVd4S1lWbFhkSGRWUmxaeFUydDBWRlpyTlhwWlZXUnpZVlphY21OR2NGZGlWRUl6V2xWYVZtVkdjRWRhUjNCVFZtNUNXbGRYZUZkWlZscHpZa2hLV0dKck5VOVVWbVEwWlZaYVdHVkZPVmROUkVaWVdXdFNZVmRzV2xoaFJYaFhUVzVvYUZacVNrOVNiVlpIV2tkc1dGSlVSVEJXYlhCSFdWWlZlVlJZYUdwU1YyaHdWVzB4YjFaR1VsaE5Wa3BPWWtad01GcFZXazlWYXpGWVpVWm9XR0V5YUZSV2FrcExVakpPUms5V1pHbFhSMmh2Vm14U1IyTXlUbk5qUldSVllsZDRUMVl3Vmt0WGJHUnlWbTEwVTAxWFVrbFZNblJyWVd4T1NWRnNiRnBXUlZwTVZXdGFjMVl4V2xsaFJtUk9ZVE5DUjFaclpEUldNVmw1VTJ4b2FGSnRlRmxXYlhoaFlVWmFSVkpyY0d4V2JFcDVXVlZhVDJGV1NYaFRibHBYVW14d2FGcEVTa3BsUm1SMVUyeGthVlpXY0ZsV1JtUTBVekZPVjFkdVVtdFNNRnBYVlcxNGMwNXNWbGhqZWxaWFRVUkdTRll5ZERSV2F6RlhZMGRvWVZKV1ZqUldiRnBYWkVkR1JrNVdaR2xYUjA0MFZtMTRhMDVIU1hsVldHaFhZbXhLVkZZd2FFTlZNV3h5V2tjNVdsWnRlSGxYYTJNMVZURktjMVpxVGxkTmFrVjNWbXBCZUZkR1ZuRlNiR1JUVFRKb2VWWnJaRFJoTVVwelZHNUthRkp0YUZoWmExcDNZakZaZUZkdGRGTk5WWEI1VkZaYWMxWnRTbGhoUmxKYVZrVTFSRll4V210WFIxWkhWR3hLVGxKR1drbFdha28wVmpGYVNGSlljRkppYXpWWFdWZDBSbVZHVlhkWGJrNVhZa2hDUmxWWGVHRlViVVY2VVdwV1YxWkZhM2hhUkVaYVpVWmtjVmRzU21oaVJYQlpWbTEwVjFsWFRuTldia1pUWWxoU2NsWnRlR0ZsVmxKelYyczVWazFyY0VwVlYzQkxWakpGZUdOR2FGZFdSVnBMV2xWYWQxSXhjRWRoUjJ4VFRXMW9OVlpzWXpGa01rMTRXa1ZrVm1KR2NGZFpWRXBUWXpGV2RHVklaRTVTYmtKWFZtMXpOVmRHU1hkalJXaGFZVEZLYUZZeWVHRldNV1JWVVd4a2FHRXdXVEJXYlhCTFZERkplVkpyYUZOaVJUVllWRlpXZDFOc1duTmFTR1JUVFd4R05GWkhkRzlWTWtWNVlVYzVWbUZyTlhaWk1GcFhaRVV4VlZSck5WZGlTRUYzVmtaYVUxVXhXbkpOVmxwWFlXeEtZVmxVUm5ka2JGcHpWMjEwVkZKc1ducFZWM2hyVkd4S2MxWnFVbGRpV0dob1dYcEtVMU5HVW5GWGJFNXBWakpvVlZkWGRHRmtNRFZIVjI1S1lWSkZTbFpVVmxwM1ZqRlNWMWR0ZEdoV2EzQkhWR3hhYjFkdFNraGhSazVoVWtWYWFGa3llSGRTYlZKSFZXeE9hVkp1UVRKV01WcFhXVmRGZVZKc1pGaGhNWEJZV1Zkek1WZFdXblJsU0dSWFRWaENWMWRyVlRWaE1VcHpVMjVzVjAxcVJucFdWRXBMVTFaR2MxRnNhRmRsYTFWM1ZsaHdTMVl4V1hoalJXUmhVbTFvY0Zac1duZFdiRnBIVjJ4a2FrMUVWa2hYYTJoTFlVWktWV0pIT1ZaaVdGSXpWRlphVjFkRk5WWlViR1JwVmxoQ1lWWnNaSGRVTVZweVRWWmthbEl5YUZkWlYzUmhWMFpyZVdWSVpGTk5XRUpIVkd4a2IySkhTa2RqUjBaWFlsaG9WRlV5YzNoV01XUlpZVVpvYVZJeWFGWlhWbEpMWWpKSmVGWnVVbXhTV0ZKaFZtMTRkMlZXV25OVmEyUldUVlZ3TUZaWGVHOVdNREZ4VWxoa1YyRnJSalJXYWtwUFVsWkdkRkpzVGxkaWEwcFNWbTEwYTA1R2JGaFVXR2hoVW14YVUxbHJaRk5pTVd4VlVtNWtUbUpIVWxwWk1GWXdWVEF4Vm1KRVVsZFNlbFpZVm0weFMxZFhSa2RWYkhCcFVqSm9NbFpxUm1GaE1XUklWbXRvVUZZeWVFOVdiWFIzVTFaYWNWTnFRbHBXYlZKSlZUSTFTMVF4WkVaWGJHaGFZa2RvVkZSVVJuZFhSMVpJWkVkd2FWSXhTWGRYYTFaaFZqSkdWMU51VW10bGEwcFlWbXRXWVdSc2JIRlNiSEJzVm1zMWVWbFZXbGRoUjBwR1kwWmtWMkpZYUdoYVJFcEhVakZhZFZKc1RtaGxiWGhhVm0xd1ExbFdUa2RYYkdoT1YwVTFWMVJWVWtkV01XdDNWMjVrVjAxcmNFbFdSM0JUVmxkRmVWVnNUbUZXYkhCTVdUSjRkMU5IVGtkVWJHUnBVMFZLVmxadE1YZFJNa1Y1VTFob1dHRXlVbGRaYTJSdlkxWndXR1JIUmxkU2JFcFlWakkxVDFReFduTlRiR2hZVjBoQ1dGWnFTa2RPYkVweVYyeGFWMDB3U2xWV2JURjZaVWRTV0ZKcmJHcFNiVkp2V1ZSR2QySXhXa2hOVkZKVVRWWndXRlZ0TlZOVk1rcEdUbFpTVjAxR1dreFdNbmhhWlVkR1NWcEdVazVXV0VGM1ZtMHdNVlF5Um5OVGJHaG9VbnBzVjFsc2FHOVVSbHB5VjJ4T1YwMVdjREZYYTFwM1ZqSktTVkZxV2xkTlZrcFFXVlJLUzFJeFRuVlViR1JvWWtWd1dWWlhOWGRXTVZaSFYyNUdWR0V6VWxWVmFrSmhVMnhWZVdWSFJtaFdNSEI1VlRKd1lWWXlSbkpUYldoWFZrVmFjbFV3V2xkamJIQklVbXhPVjFJemFGWldNV1F3WWpGR2RGVllhR0ZTYkZwVFdXeFdZVlpzVWxkWGJrNU9UVlpLV0ZadGVHdFdhekZ5Vm1wV1dsWlhVa2hXYkZwaFZqSk9SVlJ0UmxOTk1taG9WMnhhYTFSdFZuUlNhMmhxVW0xU2IxUlVRa3BOVmxsNVpVWmtXbFp0ZUZsVmJYUnZWVEZrU0dGSVJsWk5SMUV3VmpGYVlXTnNXblZhUlRscFVtdHdXVlpxU1hoTlJscEhVMjVLVDFkSGVHRldiR1JUWld4YVZWTnJaRTlpUm5CNldUQmFhMVl3TUhsaFJteFlWMGhDUTFSV1dscGxSbkJKVm14YWFHVnNXbHBXVjNCSFV6RmFWMWRyWkZoaVdGSlFWVzB4VTFkR1duUk9WVGxvVW10c05sWlhlR0ZXVmxwelkwUk9WMDFXY0doV01HUlhVMGRTUjFwRk5WTlNWbkJMVm0xNGFrMVdiRmRYV0d4VVlUSlNjVlV3YUVOaFJsWnpXa1pPVjFKc1ZqUldNalZyVlRBeFdGVnVjRmRTZWtaNlZtdGFTMVpzWkZsalJtUnBWMFpLYjFZeFdtRmpNVmw0Vm14c2FWSnJOVzlVVjNoTFZteGtXRTFZY0U1V2JWSllXV3RhYjJFeFNsbFZiR2hhWVRKUk1GcFdXbHBsVlRGV1drWmthVkpZUVhkWGJGWmhZekZzVjFkc1pGaFhSMUpoVm1wT1QwNUdXWGRYYkdSclZqQmFTRll5ZUd0aVIwVjRZMFZ3VjJKWWFGUlZha1pyWkVaYWMyRkdUbWhOYm1oM1ZsY3dlRlV5VGtkWFdHUllZVE5TY0ZSV1duTk9SbGw1VFZSQ1YxWXdjRmhXTW5odlZqRmFObFpyZUZkaGEzQk1WVzB4VDFOV1JuTmFSMnhUWW10R05sWnRNVFJaVm14WVZXdG9WV0V4Y0doVmJYaExWREZhYzFWc1pGaFdiR3cxV2tWa1IyRkZNVmRqUkVKV1lrZG9jbGxYZUU5U2F6VlhXa1p3YVZKcmNFbFdiWFJoVm0xUmVGcElVbE5pV0ZKVVZtdGFZVmRHWkhKV2JYUnBUVlpzTlZWc2FIZFZiR1JJVld4b1dtRXlVazlhVlZwWFZsWktjMk5IZEU1U1JWcFlWakowYTJReFZYaGFSV2hvVW0xU1dWWnFUbTlrYkd4eFUydGtVMDFyTlVkV01qRkhWVEpLVjFOc1dsZFdNMEpJVlhwR1QxSXhaSE5oUjNCc1lURndXVlpHV21Ga01VNUhWMWhzYTFOSFVsaFVWM1IzVm14V1dHTkZPVmRXYkhCNldUQmtSMWxXV2xkalIyaGhVbXh3V0ZsNlJsZGtSMFpHVGxkc1UxZEZSWGRXYlRFMFlXc3hXRlZZYkZWWFIyaHdWVzB4VTFkV2JIUmtTR1JZVW0xNGVsWnRNVWRXVlRGWFUyeG9WMDFxVm5KV2ExcExZekpLUlZac1ZsZGlSbkI1Vm0xd1IxTXlUblJVYTJSWVlrWndjRll3Wkc5aU1WcDBZMFZrV0dKV1dqQlZiWFJYVmxkS1NGVnRPVnBXUlVwaFZGVmFZVmRIVmtoU2JIQlhUVVJXV1ZZeWRHOVVNa1pIVTI1U1ZtSnJTbGRaYTJSdlVrWmFXR1ZHY0d4V01VcElWa2Q0VTFSc1dsaGtla0pYVmtWYWRsbHFSbUZYUms1eVlVZDRWRkpWY0ZoWFZtUjZUVmRTYzFkdVNsaGlWVnB4V1d0b1ExSnNXbGhsUnpsWFRXdHdXRlV5ZUhkWFIwcEhWMjVHVldKSFVraFdiWE40VmpKR1NHVkdUbWxXTW1oYVZtMHhkMVF5U1hsU2EyUllWMGRTYUZWc2FGTlhSbXh5V2taT1RsWnNXakJhVldRd1lVWmFkRlZyWkZWV2JFcFVWakJrUzFJeFpIUmhSbVJvWVRGd2VWWlVRbUZaVjA1MFUydG9VMkpGTlhCV2JYUjNWVlpaZUZkc1RsVk5WVlkwVjJ0YWExZEhTa2RYYkZaYVZqTlNURmt5ZUZOV01XUjFWR3M1VTJKSGR6RlhWRUpyVWpGYWRGTnJhRlpoTW5oaFZteGFkMlJzV25STlZWcHNVbTFTZUZaSGVHRlViRXAxVVdwYVYxSjZSVEJWZWtwUFkyczVWMkZIZEZOaVZrcDNWbGN3ZDA1Vk1IaFhXR2hZWWtkU1lWWnRlRWRPVmxaMFpVZDBXRkp0VWtsYVZXTTFWbTFLZFZGdWNGZE5SbkI2V1hwR1YyTnNaSFJrUlRWWFltdEpNRlpzWTNkTlZsRjRXa1ZrVkdKcmNIRlZNR1EwVjFac1ZWTnNUazVOVm5CV1ZUSjBNRll3TVZaT1dIQmFUVVp3ZGxacVNsZGpiRTVWVVd4a2FWSnJjRWxYVmxKSFUyMVdWMVJ1U21sU2JFcHdWbXhhZDFaV1pGZGhTR1JYVFZaYVNGWXlOVk5VYkZwSFUyNUtWVlpzVlhoV01GcGhWMGRXU0dSSGFGTmhNbmN5Vm14a05HSXhXbGRYYkdSVVlUSm9hRlp0ZUhkaFJuQkdXa1U1VkZKcmNIcFhhMlJ6VlRKS1dWa3piRmRpUm5CeFdsVmtTbVZHWkZsYVJUVlhWakZLZUZaWGNFdGlNVmw0WWtoT2FGSjZiRmRWYlRWRFUwWlplV042Vm1oaGVrWllXVEJTUTFkc1dsZFdXR2hYVFVad1RGWnRNVTlTTWs1SFdrZG9hRTFxYUROV2FrWmhXVmROZUZkWWFGZGlSM2h3VlcxNFlWZFdWbkZUYlRsc1VteHdXVnBWWkRCV2F6RlhZa1JTV21FeWFGQlhWbHBMVWpGT2MySkdXbWxYUjJkNlZrWldZVlV5VFhoWGJrcFFWbTFvY0ZWdE5VTk9iR1JWVVd4T1VrMVdjRmhXTWpWUFZrZEZlRk5zYUZwV00xSklWR3RhWVdSSFRYcGhSbVJYWWtoQ05sWnFTWGhqTVdSSFUyNUthbEpHV2xoWlYzUmhZVVprVjFkck5XeFdiRnA1VjJ0YWEyRlhTa1pqU0ZwWFZucEZNRnBFU2s5U01WcDFVbXhPYUUweFNsbFdiVEUwWkRKV1IxWnNhRTVXVjFKWVdWaHdSMWRHYkhKVmJFNVhUVVJHTVZsVldtOVdNVnBHWTBWNFZrMUhVa2hWTVZwSFl6RmtkR0ZIYUd4aVJtdzFWbTEwYTA1R2JGZGFTRkpYWWtkb1YxbFVTbTlqVmxaelZXNU9XRkp0ZUhsWlZWWlBWREZhYzJORmFGZE5ha0V4Vm10VmVHTnNaSFZqUmxwT1lXeGFWVmRYZEdGVGJWRjRXa2hPYUZKdVFtOVVWbWhDWld4YVIxVnJaRlpOVm5CWVZUSTFUMkZzU1hwVmF6bFhZV3RhVEZSdGVHdFdWa1owWkVVNVUwMUdjRmxXVkVreFZESkdWazFJYkdoU2JXaFlXVlJHWVUxc1VsWlhiazVYVm10d2Vsa3daRFJXTWtwSlVWaG9WMVpGYnpCWmFrcEhWakZPZFZOdGNGTmlhMHBhVm0xd1QxVXlSa2RhUm1SaFVsUnNjVlJXWkZObFZscDBaVVU1YUZKVVFqUlZNalZ2VmpGS2MyTklTbGRXUlVZMFZtcEdhMk50UmtobFJrNXBWbXR3TWxadE1IaE9SMDEzVGxaa2FWSnNjRzlWTUdSVFYxWldkR1ZJVGs5aVIzaFhXVlZrUjFkSFNsWlhibXhYVFdwR2RsWXlNVmRqYkdSMVUyMUdVMkpJUWxGWFdIQkxVakZPU0ZOclpHRlNiVkp3V1ZSQ2QwMXNXblJOU0dSc1VqRkdORlV4YUc5V1JtUklWV3M1VmsxSFVuWldha1p6WTJ4d1IxUnNhRmRpV0dnMlYxWldZVlF4WkVkVGJrNVVZa2Q0YUZWc1pHOWpiR3h5V2tWMFUwMVdjSGhXYlhoWFlWWktjMVpZYUZkaVdFSk1WWHBHWVdSR1VuSlhiV2hUWWtoQ1VGZFdaRFJYYlZaelYyNUdWRmRIYUZSVVYzTXhaV3hrY21GR1RtaFNhMnd6VmpKNFUxWXlSbkpYYTNoWFRWWndhRlpzV2t0a1JrcDBaRVUxVjFZelkzaFdiR040VFVkRmVGZHNhRlJpUjJoelZXMHhORll4YkhOaFJrNWFWbXhLV1ZwVlpFZGhNVXBWVW14d1dHRXhjRlJaVldSWFkyeGtjMk5HWkZkTk1tZ3lWMWR3UjJFeFNYaGpSVnBvVW14d2IxcFhNVFJYVmxwSFZtMUdXbFpVUWpSWlZFNXZWMGRLU0ZWdVNsWmhhMXBvVlRKNGEyTnNaSFJrUmxacFVtNUJlRlpXV205aE1WbDRVMjVPYWxORldsWlphMlJUVWpGd1YxZHJPV3BpU0VKSldUQmFUMVV4V2xsUmJscFhZbFJGTUZsVVJsWmxSbEp5V2tab2FWSnNjRlpYVmxKUFZURmFWMVp1VW14U01GcFBWbTB4TUUweFdYbE5WV1JYVFVSR1JsVlhjRmRYYkZwWVlVaHdWMDFHY0doWmVrWnJaRlpPYzFkdGJGZFNWbkJhVmpGb2QxSXhUWGxWYkdSVlltdHdVRlp0TVZOalJscDBaRWhrV0dKR2NIbFdNbmhQVldzeFZrMVVVbGRTTTJoeVYxWmFTMlJHVm5OYVJuQlhVbFJXVlZadE1UUmpNazE0V2toU1UySkhhRlJaYTFwYVRWWmFTR1ZHWkU1U01GcElWVEkxUzJGV1NrZFhiVVpYWWtad00xWnJXbUZqTVdSMFVteE9hVlpVVmt0V2FrbDRVakZWZUZOc1pHcFNlbXhaVm10V1lXRkdWbkZUYkU1VVVteGFlVmxWWkhOVk1WcEhWMnhzVjFKc1NreFpha1pyWXpGa2RWVnRjRk5YUlVwUVZtMHhORll3TlZkV2JrNW9VbnBzV0ZWdE1WTlRWbHBZWlVoT1dHSlZjRWhXTWpGdlZqQXhSMk5JY0ZwbGExcFlXVEo0YTJOck5WZFViV3hUVFRKT00xWnRNWGRUYlZaSFUxaG9XRmRIVWs5V01GWjNWMVpzVlZOcVVsZGlSa3BZVmpJMWEyRnRTa2RqU0doV1ZtMW9kbFpVUVhoWFJsWnpWMnhhYVZkSGFIbFhWbHBoVTIxV1IxTnNiR0ZTYldoWlZUQldTMU5XV25GVFdHaFdZbFpHTTFSV1dtdFhSMHBZWVVaU1dtRXlhRVJXTVZwaFYwZFdSMXBIZEU1aE1YQkpWakowYjFReGJGZFRhMXBVWWxWYVdGbHNVa2RXUmxWM1YyNU9WMVpzU2pCVU1WcHZWVEF4UjFkVVJsZGlSMDE0VlhwR1lXUkdUbk5pUmxwb1lYcFdiMVp0Y0U5aU1sWnpWMjVTYkZJelVuRlpXSEJ6VjFac1ZsZHRkR2hTVkVJelZUSXhiMVl5U2tkalNFWmhWbFp3UzFwVldtdFhWbkJHVGxab1UySklRbGxXTVdRd1lUSkplR0pHWkdsU2JXaHlWVEJrVTFaR1VsZGhSVTVYVFZac05WUldVa05oUjBwV1kwVndWbFl6VW5aV01uaGhWMFpXZFdOR2NGZFdNVXBaVjFod1IyRXlUbGRXYms1aFVqSjRWRlJXVmxkTk1WbDRWMnhPVW1GNlJsaFZNV2h6VmtkRmVWVnRhRlppV0dneldUQmFWMlJGTlZaVWJHaHBVakZLV2xaR1ZtOWlNVnB5VFZaa2FWSkdTbGhaYkZKWFZrWnNjbGRyT1ZSU2JGb3hWa2Q0WVdGV1pFaGhSemxYVW14YWFGcEVSbUZrUmtweVlVZDBVMDF0YUZWV2JYUlhXVlpKZUZkc2FFNVdSa3B3VkZaa1UyVldVbGRXYlRsb1VtczFTRmt3V205WGJGbDZWV3BPVjFKV2NHRmFWVnAzVW14d1IxVnNaR2hsYkZreVZtcEtNR0V5U1hsU2ExcE9WbGRTY0ZWclduZFhSbEpZVGxjNWFGSnRlRlpWYlhSM1lrWktjazVXY0ZwV1ZuQlVXVlprUjA1c1duUlBWbVJYVFRKb1ZWWnRjRWRoTVVsNVUydHNWbUpZVWxSV01GcExaVlprV0dSSFJtdE5iRnBJVm0wMVUxUnNXbGhWYlRsV1lrWktTRll3V2xabFYwNUdWR3hrVG1FelFtRlhWbFp2VXpGWmVWTnNWbE5oTTJoaFZGZHdSMVZHVlhkV1ZGWlhUVmRTTUZsVlpHOVVhekZHWWtSV1YySlVRalJVVlZwelYwWlNXV0pHV21oTmJXaFlWMVpTUjJReVRuTldibEpzVTBkU1dGVnRNVFJsYkZsNVpFUkNXRkl3Y0VoWk1GWnZWakpLVlZGVVJscFdiRlkwV1RKNGEyTXlTa2RYYXpWcFlsZG9OVlp0Y0VOaE1VMTVWV3hrVTJKck5XOVZiWGhoVjBad1dHVkhSazVpUjFKNVYydFNVMkZyTVZoVmEyeFhZbGhTYUZsVVJrdGtSMFpIVld4d2FFMVlRWGxYYkZaaFdWWmFWMVJ1UmxaaVIxSlBWbTB4TTAxV1dsVlRha0pvVFd0YWVsVXlkR3RoYkVwMFlVWmtXbFl6VFhoYVIzaHpWbXhrZEZKdGNGZGhlbFkyVm10a05GVXhWWGxUYTJScVVrWmFXVlp0ZUdGamJGSldWMnhhYkZack5YcFhhMXBUWVZaSmVtRkdiRmRXZWtVd1YxWmtSMUl5UlhwaVJUVlhZbFpLV1ZaR1dtdFZNREZYVjJ4b2FtVnJXbGxWYlhNeFVqRlZlV1ZGWkZkTmEzQldWVmR3VTFZeFdrWlNhbEpXWVd0YWFGWXhaRXRUUjFKSFZHMTRhVmRIYUdGV2FrWnJUa1paZVZWWWJGZGlSMUpaVmpCa05GUXhXblZqU0U1WVVteEtXVnBGYUd0V1JrcDBaRVJPVjFZelRURldNR1JMVWpKT1IyRkdjRTVTYTNCUlZtMHdlRk14WkZoU2EyaG9VbTFTVDFacVJrdFRWbHBZWTBWa2EwMVZiRFJaTUZadllWWktjazVZUWxkaE1sRjNWRzE0WVdSSFRrWmFSbkJYWWtkM01GWnFTVEZUTVZKelYyNVNhRkpzU21GWlZFcFRWa1phYzFkdVRtcGlTRUpJVmtjeGMxUnNXbkpqUm1SWFZrVnZNRlpFUm10U01VNTFWVzE0VkZJemFGcFhWbEpIWkRGU1IxZHJhR3hTV0ZKeVZXcEdZVk5zYkZaWGJVWlZZbFZ3ZWxVeGFIZFhSbGw2Vlcxb1dGWnRVbEJhUlZwVFkyMUtTR05HVG1sV01tZ3lWbXRhWVdJeFJYaFhiR1JoVW0xU1dWbHNhRk5XVmxKWFZtNWtUbEpzY0VsYVJXaFBWMFpKZDJORmJGZFdNMmgyVjFaYVdtVnNWbk5hUjBaVFVsWndlVmRVU2pSV01rNXpZMFZvYWxKVVZsaFpiR2hxWkRGYWNWTnFRbWxOVm13MFZqSjBiMVpIUlhsaFJtUmFZbGhTVEZkV1duTmpiR1IxV2taV1UySkhkekJXYWtsNFVqRmtSMU5zVmxOaVJuQllWbTV3UjAweFdraGxSWFJUWWtVMVZsVlhlR3RoUjBWNFkwUktXRmRJUWtoV1Z6RlhVakZ3U1ZSc1pHbFdNMmhWVjJ4amVFNUdXWGhYYmxKT1ZrWktZVlpxUm1GbGJGcFlUbFYwV0ZJd2NFcFZWelZQVmpKR2NsZHJlRlpOVm5BelZXMTRhMlJXY0VkYVJUVm9UVlpyZVZac1dtdE9SMUY0VjFoc1ZHRXlhRmRaVjNNeFYwWldjbFp0UmxwV2JrSlhWakp6TlZkR1dYZE9WV3hhVmxad1VGWkhNVXRYUjBaSVQxWmtUbUp0YUhsV1JsWmhZekZrUjFWdVZsVmlSMmhaVldwS2IySXhXbGhsUms1cVRWWndTRlpYZUd0aFJrcFdUbFpTVlZac2NFeGFWM2hyWTIxR1JrOVhhRk5pU0VJMVYxUkNZV1F4V25OWFdIQlNZVE5vV0ZsWGRIZFVSbHB6VjJ0MFdGWnVRa2hYYTFwclZURmFkVkZzUmxkTmJtaFlWMVphVW1WR2NFZGhSbEpvVFd4S1dWZFhlR3RPUjBsNFZXeFdVbUV6VWxkV2JYaDNUVVpTVm1GSGRHbFNhM0I2Vm0xd1YxWnJNVmhoU0ZwWFlXdHdURmt5ZUd0ak1XUnpZMGRzVTJFelFUSldiWEJEV1Zac1dGVnJhRmRoTW1oVVdXeG9iMVpHYkhKaFJVNVVZa1p3U0ZadGVFOVdNREZZVld0b1ZrMXFWbEJaVjNoUFUxWkdkRkpzVmxkV2JrSnZWMnRrTkZkdFVYaGFTRkpyVW14S1dGbFVSbmRPVm1SWFZtMUdhMDFXYkRWVk1uUnJWMFphUmxOc2JGZGhNVm96VkcxNFUxWXhaSFJrUm1oVFlrVndOVll5ZEd0U01WVjRWMnRrV0dKdFVsbFdhazVUVjBad1JWSnRkR3BOVjFJeFZsY3hORlV5UmpaV2JGcFhVbXh3VjFwVlZURlNNV1JaWWtVNVYxWkhlR2hXYlRGNlRWWk9SMWRZYkd4U2JWSlpXV3hXVjA1V1dsaGxSazVZWVhwR1NGa3daRWRaVmtwR1YyNUtXazFxUmxSVk1HUkxVbXMxVjFwRk5WZFdlbWcxVm0weGQxTXdNVWRXV0doWFYwZDRWRmxVUm5kVU1WbDNWbTVrVmxKc2JETlpWVlpQVjBaYWRHVkdXbFpOYWtFeFZqQmFTMlJHVm5OaFJtUk9ZbXhHTTFkV1VrZFRNazE0V2toV2FWSnNXazlXYlRWRFpWWmtWMWR0UmxwV2EzQjZWakkxUjFkSFNraFZiRkphWVRGd00xbHFSbHBsUm1SMFVtMW9UbFpZUWpWV1JscGhZVEpHVjFOWVpGaGlSa3BoV1ZSR2QwMHhXbFpYYlVaclVsUkdTbGxWVlRGVWJFcEdWMnhzVjJGcmJ6Qlpha1pUWXpGT2NsZHNhR2xTYkhCWFZtMHhOR1F3TUhoV1dHaFlZa1p3YzFacVJtRlRWbEY0V2tjNVZrMXJWalpWVm1oclZqSktTRlZVUWxoV2JIQmhXbFphUzJSV1RuSlBWbVJYWVROQ1dWWnJXbGRaVjFGNVVtdGtXR0pyTlZsWlZFNVRZMnhhZEU1VlRsUlNiVko1Vm14U1IxWXdNVVZTYkdSYVltNUNURlpxU2t0WFZsWjFVbTFHVjFZeFNsUlhiRnBoVXpKTmVHTkZaRlppUjJoVVZGY3hiMVl4V25SalJVNW9UVlpXTkZkcldtdFhSMHB6VTI1T1ZtRnJTbWhaYWtaWFpFZFdTVnBHVG1sU2JGa3hWMnRXYTAxR1pFZFRia3BxVTBkNFlWUlZXbmROTVZsM1drVmFiRlpzV25oV1IzaHJWakZLV1ZGcmFGaGlSbHB5VmtSR1NtVldUbkphUjJoVFlsWktVRlpHV2xka01EVlhWMjVTYTFKck5WTlpiRnBIVGxaYWRHUkhkRmROYTNCNVZHeGtiMVp0U2xWU2JscGFZV3RhVkZacVNrZFNiRkowWlVaa2FWTkZTa3BXYlRCNFRrWlJlRlpZWkU1V2JXaFhXVzAxUTFkR1VsaE9WazVyWWtkNGVWWXlkREJVTWtwV1kwVnNWVTFXY0hKWlZXUkdaREpPUjJKR1pGTk5NVXB2VjFSSmVGVnRWa2RqUld4V1lrVTFjRlZxU205V1ZtUllaRWR3VDFJeFdsaFdNbmhyVjBkS1ZXSklRbFZXYkhBeldsZDRXbVZYVWtoU2JXaHBVbGhDVjFkWGRHdGlNVmw1VTJ0a2FsSkZOV0ZXYkZwM1RURldjVkp0ZEdwTldFSkpXa1ZhVDFSc1NrZFhhM1JYVFc1b1dGbFVTa3BsUmxaMVZHMUdVMVp1UWxaWFYzUnJZakZrUjJKSVRtaFNlbXh4Vm0wMVExWXhXbk5WYTJSWFVtdHdlbFl5ZUhkWFIwVjRWbGhvVjJGcldtRmFWVnBQWXpKR1IyRkdaR3hoTVd0NVZtdGFZVmxYUlhoWFdHeFVZVEo0Vmxsc1pHOVdSbXhaWTBaa1dHSkdjREJVVmxKVFYyeGFWVkpyYUZwTlJscG9XVlZhUzFaWFNrZFhiSEJZVTBWS1NWWnFSbUZrTVVwelZtNUtVRlp0VWs5WlZFNURWakZhZEUxVVVsSk5WbXcxVlcwMVMxVXlSbk5UYkdoYVZqTlNNMVpGV2xkak1XUjBaRWR3VGxkRlNrbFdhMk40WXpGVmVGcEZXbFJoTTFKWVdXeFNRMDVHY0VWU2EyUnJVbXh3ZVZsVldtRmhWa2w1WVVaV1dGWnNTa3haYWtaaFVqSktTVlJzWkdsV1ZuQmFWbGN4TkZNeFduTldXR3hPVWtaYVdWVnRlSGROUmxwWVRsaE9WMDFyY0ZaVmJHaHJWakZhUmxKcVVsZGlWRVpNVld4YVYyTXlSa2hoUlRWcFZqSm9UMVp0TVRCVk1VbDRZa1pvVldKcmNGQldiVEUwVlRGc2NtRkZUbGhTYkZwNlZtMDFZV0pHV25OalJXaFhUV3BHU0ZZeWVGcGtNRFZYWVVaYVRtRnNXbFZXYkZaaFYyMVdjMVp1U2xCV2JWSndWV3BHUjA1c1drZFhiVVphVm0xU1NWWnRkRzlWUmxsNlVXczVWMkpVVmtOYVJFWmhWMGRXU0U5WGNFNVdia0YzVmxSS01HRXhaRWhUYkZwWVlsVmFZVmxVU2xOa2JGcEZVbTVrVjJKSFVqRldSM2hyWVZaSmVGTnFXbGROYmxKeVdrUkdVMk14WkhWVWJYQlRVbTVDV1ZaR1l6RlZNazV6WWtSYVUySkZOWEZVVm1oRFVqRlplV1ZHVG1oV2F6VkhWVEo0ZDFkR1dYcFZiV2hZVm0xU1NGVnFTazlTYkZwelZHMXNVMVpHV2pWV2JHTjRaV3N4V0Zac1pHRlRSWEJvVlRCVk1WWXhVbGRXYm1Sc1ZtMTBNMVl5TlU5V01ERnlZMFp3VmxZemFFUldha1poVW14a2MyRkdXbWhoTVhCNVYydGFZVk15VFhoVWJrNW9VbXMxVDFsc1pHNU5SbHB4VW0xMFQxSnNiRFZXVm1odlZrZEtjazVXYkZwaE1sSjJXWHBHVjJOV1VuTlViV3hPVm01QmQxZHJWbTlVTVZGNFYyNVNiRkp0VWxoV2JuQkhVMFphY1ZGWWFHcGlWVFZJV1RCYWExWXlWbk5YYXpGWFlsUkNORlY2Um1GV01VNTFWRzFvVTJKV1NsQldWekF4VVRGU1YxcEdWbFJoYkVweVZGWlZNVk5HVlhsT1ZUbFhWakJ3V1ZwVll6VldWbHBZWVVWU1dsWldjR2hhUldSWFVqRlNjMU5yTlZkaVdHTjNWbTEwWVdJeVJYaFZXR2hoVWxad1VGWnRNVFJaVm14ellVYzVWVkpzY0VaVmJURkhZVzFLU0ZWdWJHRlNWbkF6Vm1wS1MxTldSbkZWYkdSWFpXdFdNMVpHVm1GaE1VbDRXa2hXVldKWVFsUldhazV2WWpGYVdHVkhkRlpOVlRWSVZqRm9jMkpHU1hkWGJrWmFZa1phTTFWdGVGcGxWMVpJWkVaa1RtSkdjRFpXYWtvd1ZqRlplVk5zVmxKaGJFcFhXbGQwWVdOc1dYZFhhM1JxWWxWYVNGWkhNWE5WTWtwSlVXeHdWMDFYVVhkWmFrWkdaVlphYzFwSFJsTmlXR2g0VmxkNGExVXhiRmRYYmtaVFlUTlNWVlZ0ZUZkT1ZsSnpWMnM1YUZKVVJsZFpNRnBoVmpKS1ZWRlVSbGRpUm5Cb1ZXMTRUMk50VmtkWGF6VnBZbGRvZGxZeGFIZFNNVmw1Vkc1U1ZXRXhjRkJXYlRGVFkwWldjMWR1U210TlZuQjRWVEp3UTFZd01YSmlSRkpYVFc1U2RsWnJaRXRqYXpWWFZteHdhVmRGTVRSV2JYQkhZekZrU0ZWcldtdFNNbWhVV1d0b1FtUXhaSE5XYlhSVFRXdGFlVlJXV25OVmJVVjVZVVpvVm1Gck5YWlpWVnBoVTBkV1NGSnRjR2xXVkZaSlYxWldZV0V5UmtoU1dHeHJaV3RLV0ZacVRrTlRSbGw1VFZaa1UwMVlRa3BXYlhoVFlVZFdkR1ZHY0ZkV00wSlFXV3BHYTJNeGNFZGFSbHBvVFd4S1dWZFdhSGRTTVdSSFlraEtXR0pZVWxsVmFrSlhUbXhhV0dWSVRsZE5hM0JhVmxjeGIxbFdXWHBoU0VwYVRXNW9jbHBGWkZOU01YQkdUbGRvVGsxRmNHRldiWGhyVGtkSmVWSllhR0ZTVjFKWldXMXpNVlpXYkZWVGJUbFlVbXhLV1Zrd1ZtdFhSa3B6VjI1b1ZtSllhRkJaVkVaaFl6Rk9jVkZzV21sWFIyaFJWbXRrZW1WR1NuUlVhMlJZWWtkU2NGVnFSa1prTVdSWVkwVmtVMkpXV2toWk1GWnpWbGRLU0dGSVFscFdSVm96Vm10YWExZEhWa2RVYlhCT1ZteFpNRlpzWkRSaE1WbDRWMnRhV0dKR1dsZFpiR2h2Wld4U2MxZHNUbXBOVjFKNVZERmFhMVl3TVVsUmEyeFlWa1ZLVkZWVVJscGxSbVJaWTBkb1ZGSnVRbGxYVjNSaFpESkdSMkpFV2xOaVZWcFpWbXBDWVZOV1ZuUmxSM1JWWVhwR01GZHVjRXRXTURGWFUydDRWV0V5VWxOYVZWcFRZekZ3UjFkdGJHaGxiRnBoVmpGYWIyUXhXWGxUV0doV1lrWmFVMWxVVGxOV2JGWjBaVWhrYkdKR2JEVlVWbWhyVmxkS1IySkVUbGRpV0VKVVZtcEJlRmRIUmtsalJtUm9UV3hLVFZaVVFtdFdNVWw0WTBWa2FsSXllRmxWYlhSelRteGFkRTFJYUU5U01ERTBWako0YTFaSFNuTlhiV2hXWVdzMVJGa3dXbGRrUjFaSldrVTVVMkpJUWxwV1JsWlRVakpHUmsxV1pGZGhhelZXVm0weGIxUkdXWGRhUlZwc1ZqRmFTVmxWV210aFZrcDFVVmh3VjJKR1dtaFpla3BQWXpKT1JsZHRkRk5pVjJoWlZrWldZV1F4U1hoWGJrcGhVa1pLYjFSWGRHRlNNVkpYVjI1T1ZtSlZjRlpaYTFwdlZsWmFjMk5FVGxwV1ZuQm9WVEJWZUZZeGNFZFVhelZYWWtjNU5GWnNVa3BsUmtsNFZsaHNWR0pIYUc5VmJUVkRWMFphY1ZSclRsWlNiWGg0VlcxNGExWXdNVmhWYWtaWFZucEZNRlpVU2xka1IxWkhZVVprVTJKSVFubFdiRkpIWVRGSmVGcElWbFpoZW14WVZtcEdTMWRHWkZobFJtUnJUVVJHU0ZZeWVHOWlSa28yWWtab1YySllhRE5hVjNoeVpESkdTVnBHWkZkTlNFSkpWMVJDWVZVeFpIUldia3BZWWxkb2FGVnNaRk5XUmxaeFVtNWtVMkY2VmxoWGEyUnpZVVV4U0dSRVZsZGlXRUpJV1ZSQmVGSXhXbGxoUjJ4VFlsWktXbFpxUW10aU1XUlhZa1pvYkZOSFVsaFZiVEUwVFVad1ZtRkhkRmhTYTNBd1dsVm9kMVl4V1hwVmJrcFhZVEZ3VEZwRlpGTlNWbHAwVW14a1YwMVZXWHBXTVZwVFVqRk9kRlZZYUdGVFJYQnZWVzB4VTFReGJIUmpNMmhQVW14d2VsWlhkRXRpUmtwelkwUkNWMUl6VW5KWlYzaExaRVpXZFZGc1dtaGhNWEJNVjJ4a05GbFdaRWhVYTFwaFVtMVNjRlp0ZUhkWFZscHpXa1JTYWsxcldraFZNalZUWVVaT1JsTnRSbHBXUlZwb1ZGUkdkMUpXU25SU2JHaFRWa1ZhWVZkVVFsWk5WbGwzVFZWV1YyRXllRmxXYWs1VFlVWmFjVkpzWkd0U2F6VjVXV3RhUzJGSFZuUmxSbWhZVmpOb2RsbHFRWGRsUmxaelYyeG9hV0pXU2xsWFYzUnZVVEZKZUZwSVNsaGlWR3h2Vm0xMGQwMUdjRVZVYm1SWVVteHNObFpYZUZOV01rWnlWMjFvWVZKV2NGQlpNakZIVTBkR1IxVnNUbWxoTUhCaFZtMTBZVll4YkZoVldHeFZZbXMxV0ZZd1pGTmhSbFp6V2taT1YxSnNTbGhXTWpWcllrZEtTR1JFVGxoaE1taFFWakJhUzJOdFRrZFhiRnBwVW10d1JWWnRjRUpsUmxsNFZHNUthRkp0YUZoWmEyaERZVVprYzFkdFJsZE5helV3VlcxMGExbFdTWGxoUlRsWFRVWmFURlJzV21Gak1XdDZXa2Q0VTJKR1dUQldiRnB2WWpGa1NGTnVUbFJpUlVwWVdXdGFWbVZHV2xaWGJVWnJVakZhU2xkclZURlZNa3BHWTBab1dGWnNXbkZVYkZwaFkyc3hWbFpzVG1saVdHaFpWa1pqTVZVeVVuTlhibEpxVFRKb2NWWnRlSGRsYkZwWVpVaGtWMDFWY0ZoWk1GVjRWakZaZWxGcmFGcFdSWEJVVldwR1QyUldWbk5VYld4VFRWVndVVlpyV2xkVk1VcHlUVlZrV0ZkSGVISlZhazVUVlVaV2RFMVVVbGhXYkhCSldsVmtNRlpyTVhKalJXeGhWbGROTVZadE1VdFdWa3AxVjJ4a2FFMVlRalpYVkVvMFlUSlNWMXBJVW14U2F6VndWbTEwZDFsV1dYbGtSbVJvVFZWc05GWXhhR3RVYkdSR1kwWnNXbUV5VW5aV2FrWlRWMGRPUjFwR2FGTmlTRUphVmtaYVYwMUhSWGhUV0doWVlUSm9ZVlpzV25kTk1XeFdWbGhvV0ZacldubFVWbHByWVVVeFYyTkhPVmRpV0VKTVZsUkdTMk5yTVZkYVIwWlRUVVp3VlZaR1VrTlRNVlpIVjI1U2JGSjZiRk5aYkZwaFUwWlplVTVWZEZoaGVrSTFXVlZvUzFaV1duTmpSbWhWWWtad1YxcFdaRmRUUjFKSFdrWk9UbE5GU2tsV2JGSkxUa2RKZUZwSVVsUmhNbWh2Vld4YVMxWXhVbFpYYm1SWVVtMTBORll5ZEd0WFJscDFVV3RzWVZaV2NGQlpWbVJHWkRKT1JtTkdaR2hoTWprelZqRmFZV014WkVkVGJrcFlZWHBXVlZWcVNtOVdiR1JZWkVkR2EwMVhVbGhXTWpWSFZsZEtWV0pIT1ZaaVZFWlVWakJhV21WVk1WVlJiRnBPVWtWYVdsWnNaSGRTTVZsNFYxaHdWVlpGV2xoWlYzUjNWRVphY1ZKck9XcE5hM0JJVjJ0a2MxZEdTbFpqUlZwWFRXNVNWRlZxUmxKbFJtUlpZa1pTYUUxc1NscFhWM1JyWWpKT1IySkdiR3BTYlZKWlZtMHhVMWRXY0ZaWGJYUllZa1pzTkZZeWVHOVdNREZZWVVod1dsWkZXa3hWYWtaUFl6SkdSMVpzWkZkaE0wSktWbXRhWVZsWFRYaFhibEpUWVRGd2NsVnRNVk5VTVZaeVZtMUdWR0pHY0hwWGExSlRZVlV4VjJOSWJGVldiRnB5Vm1wR1lWSnNaSE5oUm5CWFRURktiMWRVU2pSamJWWllWR3BhVTJKSFVrOVdNRlpMVTJ4a1dHUkhkR2xOVmtwNlZrZDBZVlpIU2xWaVJtaGFZa1pLUkZSVVJuZFNWazV6VTIxNFYySkdjR0ZXTW5SV1RWWlplVk5zWkZSaVJuQllXVmQwUzJOc2JIRlNiWFJUVFd0d1NsWlhNVFJWTVdSSFUyeHNWMkpVUWpSVWEyUlhWakZrV1dKRk9WZE5NVXBhVmxjeE5HUXdNVWRqUmxwb1UwVTFXRlJWVWtkbFJsWjBaRWM1VjAxcldubFZiWEJUVmpBeFNGVnNhRlpOVjFKUVZXcEdkMUl4Y0VaT1ZUVlhWMFZKZVZadE1IaE5SMFYzVGxWa1ZWZEhlRmRaYTJSVFZrWnNkR042Um1sTlZsb3dWRlphVDFaVk1WaGxSRUpWVm0xTmVGbHJaRXRUUmxaellrZEdVMVl4U2tsV2FrbzBXVmROZVZSclpHaFNiVkpQV1ZkNFlWVldaRmRYYlVaVVlsWkdORmRyYUU5V2JVcElWVzA1V2xaRldqTldSbHBoVWpGd1JWVnNjRmROUkVVd1ZtMHdNVk15UlhoVGJrNVVZWHBzV0ZscldrdFhSbGw0VjIxR1dGSlVSbFpXVnpGM1ZHeFplbUZHYkZkV1JXdDRWbFJHWVdSR1RuVlRiRkpwVWpGS2FGWnRjRTlWTWtaSFZsaGtXR0pGTlZoV2JYUjNUVVp3UmxkdE9WZE5SRVpHVm0xMGIxWXdNWFZWYmtwYVlXdGFWRnBGV2t0alZtUnpWR3hrVTFaWVFscFdhMXBxVFZaVmVWVnVUbGhoTVZwVldWUktVMVpHVWxkV1ZFWk9WbXh3U1ZwVll6VmhSbHB5WWtSV1dsWldjSFpXTUZwYVpXeFdkR0ZIUmxOU1ZWbDZWMnhXWVdFeFpGaFNhMlJvVWpKNFdWVnRkSGRYYkZweVYyMUdhVTFWVmpSVk1qVlBWakpLU0dGRk9WZGhNVnBNVm0xNGMyTnNaSFZhUjNoWFlsaFJlbFp0TURGVU1WbDNUVmhLV0dKdGVHRldhMVV4Wkd4YWNWSnJkRk5pUjFJeFZUSjRZVlJzU25WUmF6RlhZV3RhY2xaRVJrcGxSbkJKVlcxc1UyRjZWbEJYVjNocllqRnNWMWR1UmxOaVdGSlFWV3BDYzA1R1duTmhTRTVXVFd0V05WWlhOVWRXYlVwVlVtNWFXbVZyV2xkYVJFWmhaRlp3U0dOSGJGTmhNMEphVmpGYVYxWXhVWGhXV0d4VVlUSlNjVlZ0TVRSV2JGcDBUVlUxVGxac2NEQlplazV2VmpBeGNrNVZaRmhoTVhCb1ZrZDRXbVZXYjNwalJtUnBWMFZLU1ZZeFdtRlRNbEpIVkc1R1dHSkZjSEJWYlRWRFpXeGtWMVZyWkd0TmExcElWMnRvUzFadFJYZGpTRTVXWWxob2VsUnNXbGRrUjFKSVQxZG9VMkV6UWpWV1IzaGhWVEZaZVZKWWFHcFNNbWhZVkZaYWQxbFdjRmRhUm1SVVVqRktSMVJzV2s5aFZtUklZVVp3VjJKVVJUQlpha3BLWlZaS2RWUnNVbWxoZWxaNFZsY3dlRTVHYkZkWFdHUm9VbFUxYzFsclpEQk9WbkJXV2tWa2FFMVZiRFJXTW5SelZtMUtWVkpVUWxwV2JIQk1Xa1phUjJOdFRrZGFSazVwVTBWS05GWnJaRFJaVm14WFdrVmtWV0pyTlZsWmJHaERWa1phY1ZKcmRHaFNiSEJJVm0weFIyRXdNVmhWYTJoWFRXcFdTRlpYZUd0VFIwWkhZa1phYVZkSGFHOVdha28wWVRKT2MxcElWbUZTYlZKUFZteG9RMWRXWkZWUmJVWnBUVmRTU1ZVeWRHdFhSMHBZWVVab1dsWXpVbWhaTW5oYVpERmtjbVJIY0dsVFJVcEpWMVpXYTJNeFdYZE5TR3hvVW14d1dGUldaRTlPUmxKV1YyczFiRkp1UWtwV1IzaHZWMFpKZVdGSGFGZFNiRXBNVmxSS1RtVkdXblZWYlhoVFlsWktVVlpYTUhoVk1sWlhWMjVTVGxaRlNtOVZiWGgzWlZaU2MxWnRkRmhoZWtaSVdUQm9kMVl3TVhGU2EzaFhUVlp3VkZZeFpFZFNNWEJIV2taa2FXRXdjR0ZXYWtvd1ZqRmFkRlpyWkZoWFIyaFhXVzE0UzJNeFZuUk5WazVxVW14V00xWnRkREJYYkZwellrUldZVkpXY0hKV2FrcEhUbXhhYzJKR1dtbFhSa3A1Vm0xMGExTXlUbkpPVm14VFlrWndjRll3Wkc1bGJGcDBZMFZrYWsxck1UVlZiWFJ2VlVaWmVsRnVRbFppVkZaRVZHdGFZVlpXVG5GUmF6VlRZbFpLU1ZacVNURlRNV1JJVTI1V1VtSkhVbGhaVjNNeFpHeHJlV1ZJVGxkTlYxSjVXVEJrTkZVeVJqWldhbFpYVW14d2FGbFVSbHBrTURGSldrWlNhRTF1YUZwV2JURTBVekZTUjFkc1ZsTmlTRUp6VlcxNFlVMVdXblJsUm1Sb1ZteHdXRmt3V2xkV01rcFpWVzFvV0Zac2NHaFdha1pyWTJ4d1IyRkhiRk5OVlhBMVZtdGFZVmxXVFhsV2JrNVlWMGRvYjFWdWNITlhSbXh6Vm14a1QySkdXbGxVYkZVMVZqSktWbU5HY0ZwV1ZscDJWbXhrUm1WSFRraGhSbHBPVWpGS1ZWWlVRbXRWTVVsNFkwVmtWV0Y2VmxWVmJGWnlaVVphZEdSSGRFOVNiWGhaVlRGb2IxbFdUa2RUYkZKWFRVZFJNRlpxUm5OamJHUnlaRVpvVTJKWWFGZFdWekF4WVRGa2MxZHVWbEpoTVhCWFdXeFNSMU5HYkZoTlZYUlhUVlUxZVZsVldtOWhSVEZ6VTJwYVYySkdTa3hWZWtwUFl6Rk9kVkpzVm1sU01VcFFWMWN3ZUdJeFpGZFhXR2hZWWxoU1ZGbHNXbUZUUm10M1ZtNU9WMVl3Y0VsWlZXaERWMjFGZUZkcVRtRldNMmhvVmpCVmVGTlhSa1pQVms1cFZtdHdTbFp0Y0VwTlZrbDRWMnhvVkdFeGNGQldNRlozV1Zac1ZWSnVaRTVOV0VKWFZqSjRZV0pHV1hoVGEyeFdZbFJHZWxaVVNrdFRSMUkyVVd4a2FHRXlPVE5YVjNCSFYyMVJkMDFXYkZkaVYyaFVWV3hTVjFkV1drZFdiVVpyVFZaYVNGWnROVk5pUmtwVllraEdWMkpVUmxSYVYzaHJZMnh3U1ZSc2FGTmhNMEkxVjFSQ2IxbFdXWGROVm1ob1VrVTFWMXBYZEdGVk1YQlhWMnhPV0ZZd2NFaFdiVEZ2Vkd4a1JsTnNjRmROVjFGM1YxWmFjMWRHVGxsaFIzQlRZbGRvZWxaWGNFTlpWbVJYVjI1U1RsWnJOVmxXYlRWRFVqRmtXV05HWkZkaVZWa3lWVzE0YTFaWFNraGhSRTVYVFVkU1IxcFdaRWRTTVVaeldrZG9hRTB3U2s1V2JUQjRUa2RGZVZWclpGUmlhelZvVldwS05GZFdWbkZUYlRsVVlrWndlVmRyVWtOWGJGcDBWV3BDVjJKWVVuWldWRXBHWlZkR1NWTnNXbWxXUlZveVZtMTBZVlV4V25OYVNFNXFVbFJXV0Zsc1drdE9iRnAwVFVob1UwMXJXa2RVVmxwcllXeEtkR0ZHYUZWV2VsWkVXVlZhWVdOV1RuSmtSazVPVmxSVmQxWlhNVFJoTWtaWFUyNVdVbGRJUWxsWmEyUlNUVVpaZVUxV1NteFNNRFZIVjJ0a1IxVXlSalpXYm1SWFlsUkZkMXBFUms5ak1YQkpVMnhrYVZaV2NGZFdSbHBoVXpKV2MxZFliRTlXYlZKWFdXeFdWMDVzV2xobFJ6bFlZbFZXTlZaWGVFTldWMFY0WTBaU1drMXVhRE5WYlhoclpFZFdSMXBIYUU1TlJXdDVWbTF3UzAxR2JGZFdXR3hUWWtkb1ZWbFVTbE5qVmxaMFpVVjBXRkp0ZUZsYVJWWXdZVEpLUjFkc1dsWmlWRVYzVm1wQmVHTnRUa1pqUmxwT1lXdGFTVlpzVWt0U2JWWnpVbTVPVW1KSFVsaGFWM1JLVFVaYWMxVnJaR2hOVld3MFdUQldjMVpIU2toVmJHaFdZbGhvTTFZeFdtRlNNVnB6Vkd4T1RsWXhTa2xXYlhodll6SkdjMU5zYUZaaVIyaGhWakJvUTFOR1VsZFhiazVYWWxWYVNWVnRlRzloVmtwMVVXcGFXRlpGU25aVmVrWmhZMnN4Vm1GR1dtaE5iV2hZVjFaa01GbFhSa2RpUkZwVVlUSlNWRlJXYUVOU01WSnpWbFJHVjAxV2J6SlpXSEJIVmpKS1ZWSlVRbGhXYkhCWFdsVmFUMWRYU2tkV2JHaFRUVzFvWVZadGNFTmhNa2w1Vkd4a1YySnJOV2hWYlhNeFlqRldkR1ZIUms1U2JFcFlWakp6TldGSFNrWmpTSEJhWVRGS1VGWnFRWGhrVmxaWldrWmthR0V4Y0c5WFdIQkxWREZLZEZKclpHRlNWRlp2V1ZSR2QxTnNXblJOV0dSU1lsWmFTRlV5ZUd0Vk1rcHlWMnhrV21FeVVsUldNRnBUVmxaT2RFOVhiRTVXTVVwWlZtMHdlRkl4V2xaTlZscHFVMGQ0VmxsclduZGtiRnBXVjIxR2FrMXJOVXBWVjNoclZHeEtkVkZyZUZoaVIxRXdWMVphWVZZeFNuVlZiRTVwVjBWS2QxWnRNVEJYYXpGSFYxaHNhMUo2YkZkVVZscGhVMFpaZVU1V1RtaFNhelZIVlRKNGIxZHRSWGxWYmxwV1lURndWMXBXWkZkVFIxSkhXa1UxVjJKclNUSldha293V1Zac1YxVnVUbGhpYkZwVFdWZDRZVmRHVm5SbFNHUllVbTE0VmxVeWRHdGhhekZYVTI1c1YwMXFSak5XVkVwTFYwZEdTR0ZHWkdsWFJVcFJWbXhTUzFJeFNYbFNXSEJwVWpOb1ZWVnFSa3RXVm1SWVpFYzVVazFWTlVoV01uUnZZa1pLVldKR1dscGlSbHBZVkd0YWNtUXhXblZVYkdST1lURlpNVlpyWkhkVk1XUjBVbTVLV0dKR1NtRlVWelZQVGtaYWRHVkhkR3RTTUZwSFZHeFZNV0ZXV1hsaFIwWlhZV3RhY2xSclpFcGxSa3BaWVVaYWFFMXNTbGhYVjNSaFpESkdSMVp1VGxoaWJWSnhWRlphZDAxR2EzcGpSV1JZVWpCd1NWcFZXbXRXTURGeFVsaGtWMDFHY0V4Wk1qRkxVbFprYzJOR1pGZGlhMHBhVm0xd1ExbFdiRmhWYTJSWFlrWmFVMWxzVm1GV1JsWnpWMjVrYkZac2NGbFpNRll3VmtVeFZrNVdhRmRpVkZaTVZrUkdZV1JHVm5SUFYwWlhUVEpvYjFZeFdtRlpWMDE0WVROd2FGSlViRlJVVmxaYVpXeGFSMWR0Um1oTmExcEhWRlZvYzFadFNraGhSMFpYWVRGVmVGWnJXbkprTVdSeldrZDBVMDFWY0V0V01uUnJUa2RHVjFOdVVtdGxhMXBaV1d0YVlXUnNXa1ZTYlhSVVVtczFlbGRyV205aFYwcFpZVVprV0ZZelVuSlpha3BIVWpGa2RWSnNVbWhOYkVwNFYxZDBWMlF5VmtkWGJHaHNVak5TVmxsclZuZE5WbFpZWlVoT1dGSnRVa3BWVjNRMFZqRktSbGRyZEdGV2JIQlVXVEo0ZDFOR1NuTlViV3hYWVROQmVsWnFSbUZWTVVWNVZGaGtUMVp0VWxsWmJYUmhWa1pzYzFadFJscFdiSEF3VkZaU1UxZEdTbk5qUld4VllrWndVRlpxUVhoamJGcHhWbXhrVjAweWFHOVdha2w0VXpGa1dGSnJXbXhTYmtKdldWUkdkMWRXWkhKV2JGcHNVbXhzTkZaWE5WTmhiRXB5VGxoQ1ZtRnJOWEpVYlhoaFpFVXhTV0ZGTlZOV1JWcEpWbTE0YjJJeFpFaFRia3BQVjBWYVYxbFVSbUZVUm1SWFYyeE9WMkpIVWpCVmJYaFhWVEpLU1ZGcmNGaGlSbHB5VldwS1IyUkdUbk5YYlhCVFZtNUNXVlp0Y0U5aU1sSnpZa1phVjFkSGFISlZha0poVTBaV2RHVkhPVmROYTNCSVdUQmpOVll4WkVsUmEyaFlWbXh3Y2xWcVJsTmtWazUwVW14T1RtSlhhRlpXTVdONFRVWk5lRnBJVGxoaVJscFRXV3RrVTFaV1VsZGFSazVZVW14c05WUnNWbXRXYlVwV1kwWmtWMDFxUmtoV2FrcExWMVpXZFdOR1ZtaE5XRUkxVjJ0U1IxbFhUWGhqUldSWVlsZDRXRll3Vmt0aFJscDBaVWQwYkdGNlZsaFhhMmhUVlRGa1NHRklSbFpoTVZWNFZqQmFVMVl4WkhWYVIyaFRZbGhqZVZaWE1ERlVNVkY1VTJ0YWFsTklRbGhaYkdoT1pVWmFjVkZZYUZkaVZUVkhXa1ZhYTJGV1NuSmpSWGhYVW14d2FGWkhNVmRTTVZwellrZG9VMkpYYUhkWFYzUlhaREpXYzFkc2FHcFNWVFZoVm0weE5GZEdiSEpYYkdSV1RXdHdNRlpYTURWV2JVcFpZVWh3VlZaRldtRmFWbVJYVW1zNVdHRkhiRmRYUlVwTFZtMTRhMlF4U1hoWGJrcE9WMFZhVkZZd1pGTlhSbFp4VkcwNWFtSkdXakJhVlZVMVlXMUtWazVWYUZoaE1YQlFWbFJHWVdSV1JuVlhiR1JPVm01Q1ZWWlhjRWRXYlZaWFZXeHNhRkpzV25CWlZFNURWMnhrV0dSSGRHbE5hMncwVmxkNGIxUXhXalppUm14YVlURndNMVJWV25kU2JHUjBaRVprVTFaRldqWldWRWt4WkRGa2NrMVZaRmhpUjJoWVZtdFdkMVJHVlhoWGEyUnJWbXhLZWxkclpITlhSa3BWVWxSQ1YwMXVhR2hYVm1SR1pWWlNkVlJ0Y0ZOV00yaHZWbGN4TkdReFVYaGlSbFpUWWtoQ2MxbHJaRk5XYkZaWVRWUkNhRlpVUmxsV1YzUnpWbXN4ZFZWdVdsZGlXR2h5VlRCYVYyTXlTa2RhUjJ4WVVqSmtObFp0Y0VOWlZsbDVWR3hrVldKcmNGbFpiR2h2WTBaYWMyRkZUbFJpUjFKV1ZWY3hNRlF4U1hkWGEyUlZWbXh3ZWxaWE1VdFRWa1p6WVVad1YxSldiM3BYVmxaaFlURlplRnBJU2s5V00xSlBWV3RXWVZkR1dYbGtSM1JxVFZad1NGVXllSE5WYlVwSlVXeHNWMkZyTlhaYVIzaGhWbFpPY21OSGVGTmlTRUY0Vm10a05GbFhSa1pOVlZaWFlrVktXRlZ0ZUhkaFJscHhVVlJHVjAxV1ducFhhMXAzWWtkS1IyTkdiRmRTYkZwVVZXcEtWMVl5UlhwYVJtaHBWbFp3V1ZkWGRHRmpNRFZ6Vm14b2JGSnJOVmxWYlhoM1pXeHJkMVpxVWxkaVZYQmFXVlZvUzFkck1YVlVWRVpYVFVad1RGbDZSbE5qTVZKeldrWmthVmRHUmpaV2JUQjNaREpSZVZacldrOVdWMmhVVmpCa05GWnNiSFJrU0dSV1VteHdNRlJXV2s5aFJrcHpWMnBDVlZac2NGQldiRlY0VjBkV1NXTkdhR2hOYXpCNFZtMXdRbVZHV1hsVWEyeG9VbXh3Y0ZaclZscGxiR1JZWkVkR1ZFMVdjRmhWTWpWTFlWWktkRlZzYUZwaVIxSjJWRmQ0WVdSRk1WVlZiV2hPVmxSV1NsWlhNVEJoTWtaWFUyNVdVbUpyU2xoVVZXUlRaR3hhUjFkdFJtcGlSbHA1VjJ0YWQxWXdNVlpqUlhCWFlUSlNNMWRXV2xabFZrNXlZVWRvVTJKRmNHaFhWbEpMWWpGRmVHTkZWbE5pVlZwVVZGWmtVMlZzV2tobFIwWlZZa1pzTkZVeWRITldNa1p5WVROb1YyRnJXbGhhUlZwTFYxZEtSMWR0YkZOTk1taHZWbTB4TUZZeGJGaFNhMlJvVFRKNGMxVnROVU5qYkZKWFdrWk9iRlp1UWtkWGEyaHJZVVphYzJOR1dsZGlXRkYzVmpCYVlWSnNUblJoUm5CWFVsWndWVmRyVm1GVU1sSlhWRzVPVm1KWGFFOVpiVEZ2VjJ4WmVGZHRkRTVTTVVZelZHeG9UMkZzU25OalJteGFWa1UxUkZsNlJsZGtSVFZXVkd4U2FWSnVRWGRYYkZaaFZESkdSMWR1U2s5V1YxSlhWRmMxYjJWc1duRlNiSEJzWWxWYVNsWXllR0ZXTVVwWFkwWldWMkpZUWtoWlZFcE9aVlpLY21GSGNGTmhlbFphVmxjeE1HUXhaRWRYYmtwWVlsVmFXRlJYYzNoTk1WSnpWbTEwV2xack5VZFpNR00xVm0xS1IxTnVjRmROVm5CWVdURmFSMk15VGtaT1YyeFRZbXRHTTFaclpEUldNVkY0V2tWb1ZHSkdjRmhaVjNoTFYwWlNXR05GWkZSU2JWSllWako0ZDJKSFNsWlhhMnhhVmxkU1NGWlVSbHBsUms1ellrWmtWMDB3U2tsV2JGSkxWRzFXUjFWdVZsWmlWM2hVV1d4YVMyUXhXbFZSYkdSVVRWWktTRll5TlZOVWJGcEdVMjA1V2xkSVFraFdNRnBoVWpKR1NFOVdaR2xTTVVwS1YxWldZV014WkhSVGJHeFZWMGRvWVZSV1duZFhSbkJIV2tVNVZGWnNTbnBYYTFVeFZqQXdlVnA2U2xkaVdHaHlWR3RrUm1WR1dsbGhSbEpwWWtWd2VsWlVRbXRpTVZsNFlraE9hRko2YkZkVmJYaDNaVVpXVjJGSE9XaGlWWEJKVmxjMWMxZEhSWGhqU0VwWFZrVkdNMXBFUVhoV1ZsWnpZVVprYVZORlNuWldiR2gzVXpGVmVGZFlhRlJpYXpWd1ZXcENZVlpHYkhOYVJ6bFlWbXh3V1ZwVldtdGhNREZZVld4b1YwMXVhSHBaVjNoTFYxWldjMVZzY0dsU2JrSkpWa1pTUjFVeFdYaGFTRlpWWWtkU1dGUlZhRU5UYkdSWFZtMXdUMVpzY0ZoV01uQmhWVEpLYzJOR2FGVldiSEF6V1ZWYVdtUXhXbFZTYkdoWFltdEtTVll5ZEZaTlZsbDVVMjVLVkdFelFsaFpiR2hEVkVaU2NsZHVUbGROV0VKSFdWVmFVMkZXU25WUmJIQllWbnBGZDFwRVJscGxSMHBKVkcxb1UyVnRlSFpXVnpFMFV6RlplRmRZYkd4U1dGSndWVzEwZDAxR1dsaGpSV1JZVWpCV05Ga3dhRXRXTVVsNllVZG9WMDFXY0VoWmVrWjNVakZ3U0dKR1pGTldiR3cyVm0weE5GVXhTWGhhU0ZKWFlUSlNWbGx0ZUdGV01XeHlWMjVrV0ZKc1ducFdiVFZyWVVaS2MyTkVRbUZTVm5CeVdWUkJlRll4U25GVmJIQk9VbTVDYjFacVFtdFRNV1JYVm01V1ZHSkhVbkJXTUdSdllqRmtjMXBFVWxwV2F6VkhWRlphYzFaWFNrZGpSVGxhVmtWYVlWUlhlR0ZXTVhCSldrWldUbFp0ZHpGV1ZFbzBWakZXZEZKdVRsUmlSbkJoVm10V2QxWkdXbFZTYm1SWFlrZFNlbFpITVhkVWJHUkdVMnR3VjFaNlJUQldSRXBIVmpGT2RWWnNTbWxTYkhCWlZrWmFhMVZ0VVhoaVJsWlRZa1p3YzFadGVFdGxiR1J5VjIxR2FGWnJiRFJWTW5oM1YwWmFObEZxVWxkV1JWcG9WbXBHYTJSV1ZuUmxSazVwVm10d1VsWnRNSGROVmtWNFYxaG9ZVkp0ZUhGVmJURlRZakZXZEdSSVpHeFdiWFF6V1ZWb1QxZEhSalpTYTJ4YVZsWktVRlpxU2t0WFZsSnhWVzFHVTJKV1NrbFdWRUpyVWpGSmVHTkZhR2hTTW1oUFZGVldkMU5zV25GVGFsSlhUVmQ0V1ZWc2FITldiVVY1WVVaU1dsWkZjRlJaVlZwWFpFZE9ObEpzYUZOaVdHZDNWMnRXVjAxSFJYbFRhMlJwVWtaS1lWWnNaRzlqYkZwVlVWaG9hbUpHY0hoV2JYaHJWakF3ZUZOdWJGZGlXRkp5VlhwS1QyTnJOVmRhUm1ocFUwVktXbFpVUWxkVE1XUlhWMjVHVW1KVlduRlVWM2hMVTFaYVdHUkhSbHBXYTNCV1ZtMXpOVll5U2xWV2ExSlZZbGhvWVZwVldsZGphemxZWVVVMWFFMHdTa3BXYkZKTFRrWlplRlpZYkZOWFIzaHZWVzB4YjFkR2JIUk9WVTVZVW14d2VWWXlNVWRXTVZweVkwUkNZVkpXY0ZSV1ZFRjRVakpPUm1SR1pGZGxhMVYzVmpGYWExSXhXWGhVYkd4b1VtczFXVlZxUmt0WFZtUlhXa1JDVkUxcldraFphMUpoVlRKS1dWVnNWbFppV0dob1dsWmFjMk5zWkhOVWJXaFhZbFpLU2xkV1ZtRldNV1JIVjFod1ZtSnNjRmRXYTFaaFdWWndWbGR0ZEdwTmExcEhWR3hhYTFVeVJYcFJiR2hYWVRGd2NsUlZXbk5YUmxweldrWmFhVkl4U2xwWFYzaHZWVEZrUjFadVJsSmliVkpQVlcwMVExWXhaSEpXYlhSWFRVUkdlVmt3Vm5OV01WbDZZVVpTV0Zac2NFdGFWekZIVTBkR1IxcEhiRk5pYTBwU1ZqRlNTbVZHVlhoVFdHaHFVbFp3VUZadE1WTlhSbFowWlVoS2JGWnNjREJaTUZZd1ZHeEtkR1ZHYkZaaVIyaDZWbFJLUzFOR1ZuTmlSbkJYVWxadmVsWnFRbUZYYlZGNFkwVmtWV0pIYUZSWmJHaHZUbXhhYzFwRVFsVk5Wa1kwVlRJMVQyRnNUa2hoUm1SYVlrZG9WRlJVUm5OamJHUnlaRWQwVjJFeGNEVlhWbFpoWkRKR1JrMVlUbFJoTW5oWVdXdGFTMVJHVmpaU2JYUlVVbXR3ZVZsclpFZFZNa3BYVTJ4c1YxWXphRmhhUkVaclZqRmtjMkpIY0ZOWFJrcFpWa1prZW1WRk5VZGFTRXBvVW0xU1dGbHNWbmRYYkZaWVpVWk9WMDFyV25sV01uUTBWMnhhVjJOSGFHRlNWbFkwVmpGa1QxSnJOVmRhUjJ4WFlUTkNTMVp0TVhkVE1EVklVbGhzVTJFeVVsVlpWM2gzWTBaV2NWRnRSbGhTYlhoNldWVmFUMVJ0U2tkVGJHeGhWbGRvVUZsWE1VdFRSbFp4VVd4YWFWZEhhREpYVmxwaFdWWlplRnBHVmxKaVIyaFlWV3hXZDFaV1duSlZhMlJZWWxaR00xUldXbXRaVmtsNlVXeFNXbGRJUWxoWmFrWmhWMGRTUjFwSGRFNVdWRlpKVm0xNGIySXhaRWhUYTFwUFYwVmFWbFpxVGxOaFJsVjNWMjFHVkZKVVJscFdSM2hoVkd4S1JsTlVSbGRoTWxJelZtcEdXbVZXVG5OV2JFNVhVbFZ3YUZadGNFOVVNRFZIVjI1R1UyRjZiRmxXYWtKaFUwWnNWbHBJVGxaTlJFWXdXVlZhYTFZd01WZGpSbEpXWld0YVYxcFdXbE5qTVhCSFdrZHNhRTFZUWxkV01XUTBWVEpOZUZwR1pGZGliRXBQVm10YVMxZFdXblJPVlU1VFRWZFNlVlp0TVRCaFJrbDNZMFprV2sxR1dqTldiWGhhWld4V2RWZHNaR2hoTUZrd1YydGFhMUl4U1hoU2JrNXFVbTFTVDFSVlVsSmtNVmw0Vld0MFQxSXdWalZXUnpWVFZrZEZlVlZ1UmxaaVZFWlVWakJhVTFZeFduVlhiWGhYWWtkM01GWXlkRk5STWtaR1RWWmFUbFpHU2xkVVZtUnZaV3hhYzFwRldteFdiRm94VlZkNFlXRldXa1pYYkZaWVZrVkthRmRXWkU5ak1XUjFVMjF3VTFaR1dsVlhWM1J2VVRGT2MxcElTbGRpV0ZKVVZGZDBZV1ZXVWxkWGJUbFhZbFZXTlZsVldtOVhiVXBJWVVoYVlWWXphSHBXYWtaclkyMVNTR1JHVG1sU2JUazBWbXhhYTA1SFVYaGFSV1JWWVRGd1ZWbHJaRFJYUm14WVpFaGFUbEp0ZUZaVmJURXdWVEpHTmxKc2FGZGlXR2hvV1ZaYVMyTnRUa2RSYkdoWFlsZG5lbFpYTVhwbFJrbDRXa2hXVm1GNlZsUlZiRnAzVmxaYVIxZHRSbXROVjFKWVZteG9jMkV4U1hkWGJGcFZWbTFTVkZWcVJscGxWMVpJVDFab2FWWllRa3BYVmxadldWWlplRk5zWkdwU01GcG9WV3RXWVdOc2JEWlRhemxVVWpGYVNGZHJWVEZXTVdSR1UydHNWMkpZYUdoWlZ6RlhVMFpTV1dGR1pGaFNNVXBRVm0xNGEwNUdWWGhpUmxaVllUQTFXVlp0TVRSbFZsbDVUVlZrYUZKcmNEQmFWVnBoVm0xS1ZWSllaRmRoTVhCTVdUSXhUMUl5VGtkalIyaE9Za1Z2ZVZadGVGTlRNVXAwVlZoc1ZXRXlVbkJWYlRGdlYwWnNjMWRyWkU1TlZuQlpXVEJXUzFSc1duSmlSRkpZWVRGd2VsZFdXa3RrUjBaSlVXeGFhR0V4Y0UxWGJGWmhZVEZrU0ZWcmFGQldhM0JQVm14U1YxTldXbkZTYlRscVRXdGFNRlp0TlV0WFIwcFZZa1pvV2xZelVreFVWRVpYWTFaS2RWUnRjR2xTYkc5M1ZsY3hOR0V4VW5SU1dIQlNZa2RTV0ZadWNFZE5NVnBGVW0xR2FrMVhVbmhXTW5oUFlWWkplV0ZHYUZoV2JWRjNWMVprVDJNeFpGbGhSMFpUVmpGS1ZWWkdXbUZrTURGSFlraEtZVko2YkZaWldIQkhVakZyZDFkdVpGZE5hMXA1VmpJMVMxWldXbGhWYTJSaFZsWndhRll4WkV0U01WWnpZVVpPVG1KWFozcFdiWGhxWlVVMVIySkdaRmRYUjJod1ZUQldkMkZHVm5SamVrWlhUVlphTUZwVlpFZFViRXAxVVd4a1dsWlhVWGRXTUZwTFl6Sk9SVkZ0UmxOV2EzQlJWbTF3UzFNeFdsZFRiR3hoVW01Q1dGWnROVU5VVmxwMFpVZEdWRTFzU2xsV1IzUnJWMGRHTmxadVFscGlSMUoxV2xaYVlXUkZNVmxhUms1T1ZsUkZlbFpIZUc5VU1XUklVMjVLYWxORk5WZFpiRkpIVmtaYWNsZHNaR3BOVjFJeFYydGtjMVJzV1hoVGFsWlhZbFJDTkZSVldsWmtNREZYVjIxc1UxSnJjRmxYVjNoVFZqRldSMkpHYUd4U1dFSnpWbXBDWVZJeFVYaFhibVJvVm10c05GVXljRXRXTVZvMlVsUkNXRlp0VWxCWmVrWjNVMVpXZEdSR1RsZFNNMmhXVmpGa05HSXlTWGhhU0U1WVltdHdXVmxzVW5OalJsSlhWMjVPVDFac1ZqVlViRll3WVVkS1JtTkljRnBOUjFKSVZqSjRZVkp0VGtkVmJHUm9UVmhDYjFaWGVHRlRNbEpYVlc1U2FsSXllRlJaYlhSS1RXeFplRlZyVGxkaGVrWllWbXhvYzFaSFJYbGhTRXBoVmpOU2FGWXhXbk5XVmtwMFVtMW9VMkpZYUZkV1ZFb3dZVEZWZVZKcVdsTmlTRUpYVkZjMWIyUnNiRmRYYTNCc1ZqQmFTRmxWV210Vk1rcFhVMWh3VjJKWVFraFhWbHBLWlZaT2NscEdhR2xTTW1oMlYyeGplRTVHV2xkYVJtaHNVbXh3VDFadGN6RlRSbVJ5WVVWMFdGSXdjREJXVjNodlZsWmFWMU5yVWxWaE1YQlhXbFprVG1WdFJrZGhSazVwVTBWSk1sWnRjRXBsUjBsNFdraFNWMkpyY0hGVmJYUkxWMFpzV0dSSFJsWlNia0pJVmpKNFQyRXhTbkpqU0hCWFVqTk5lRlpIZUdGWFZrWnpXa1prYVZaRlNUQldSbFpoWXpGWmVWTnJaR0ZTTUZwVVZtcEdTMWRzWkZoTlZFSnJUV3RhU0ZadE5VdFhSMFY2Vld4b1dtRXhjRXhXTUZwYVpWZFNSVkZ0YkZOTlNFSkpWMWQwVTFZeFdsaFRhMlJxVW10S1lWWnNXbGRPUm13MlVtMTBhMVl3Y0VoWGExVXhZVmRLV0ZwNlNsZGlXRUpNVkd0YWMxWXhUblZVYlVaVVVtdHdkbFpYTUhoVk1rbDRWV3hrYUZKVk5WbFdiWGgzVFVad1ZscEZaRmRXVkVaNVZHeG9kMWRyTVVkWGJrcFhZa2RTVEZZd1pFZFRWbEp6WTBaa1UxWnRPVFpXYlhCTFRrWnNXRlZyYUZWaE1YQnhWV3BPYjFaR1VsWlZhMXBPVW14d01GcFZZelZoVlRGWFkwVnNWazF1VW5KV01HUkxVMGRHU0ZKc2NGZFNXRUpWVm0xMFlWZHRWa2RhU0ZKVFlsaENXRmxyVm5kT2JGcHlXVE5vYVUxV1ZqVlZNbmhyVmtkS1NHVkdhRlZXZWxaVVZtcEdVMk14Y0VaYVIzQm9aV3RhV1ZkV1ZtRlpWMFpJVWxob2FsSnRlRmhXYm5CWFRURldjVkpyT1ZOTlYxSjZWbTE0VDJGV1pFZFRiRlpYVW14d1YxUldaRmRqTVdSMVZXMTRVMDB4U2xoV1JtUXdaREZrUjFaWWFGWmhNMUpZVkZaV2QyVnNhM2RhUnpsWFRWVndSMWt3VlRWWlZscFhZMGhLV21WcmNFeFZNR1JMVWpGU2NrNVZOV2xXTW1oWVZtMHhNRmxXVlhoVFdHaFZWMGRvYUZWc1pGTlhWbXhWVTJ4T1dGSnRlSGxXYkZKSFZtc3hWMU5zWkZkV00yaHlWakJhUzJSSFZrbGlSbVJPWVd0YVNWWnFRbXRUTVZsNFdraFdhbEp0VWs5WmJURnZUV3hhZEdWSFJsaGlWbHA2Vm0wMVUyRkdTWGRYYkdoYVlUSm9SRll3V210ak1XUnpWMnMxVjJKSVFYZFdiR1F3WVRGc1YxTnNWbGRpUjJoaFdXdGFTMlJzVW5OWGJVWnFUVmQwTmxsVlZUVlZNREZJWkhwQ1dGWXpVbWhaVkVaaFUwWk9jbUZHV21saE1YQllWMWQ0YjJJeFVrZGFSbVJZWWtVMVdWVnNVbGRYVmxGNFZsUkdWV0pHY0hwV01XaDNWakpHY21JelpGVldWMUpJV1RKemVGWXhjRWRWYld4cFYwZG9XRll4WkRCaE1WVjVWbTVPYVZKdFVsbFphMmhEWXpGYWNWRnRSbFJXYkVZMFZqSXhNR0ZHV25OalJXUlhZa2RvY2xZd1dtRmpNVTV5WlVaa1YyVnJXbGxXVjNCSFZqSk5lVk5yYUdsU2F6VndWV3hvUTFsV1duTmFTR1JVVFd0c05GZHJhRTlaVmtwMFlVVTVWMDFIYUVSV1JFWmhaRVV4VjFSc2FGTmlXR2cxVjFaV1lWUXlSa2hUYkdSWVltMTRXRlJYY0ZkU1JscHpWMjFHYWsxck5VaFpWVnBYVmpGS1YyTkliRmhXUlc4d1dWUktUMk5yT1ZkYVIwWlRUVzFvZWxkV1VrZGtNV3hYVjFoc2JGSnRVbkJVVjNoSFRrWlplR0ZIZEZWaVIxSkhWako0VTFkc1drWmpTRnBYVFVad2VsWnNXa3RrVm5CSFZteE9hVmRIVGpWV2JGSkxaV3MxVjFaWWJGUmlSbkJ4Vld4a05GWXhiSE5oUnpsV1VteHdlRlZXYUc5V01rcElWV3h3V2sxR2NISlpWbHBoVW14a1dXTkdaRmROTUVwSlZtdFNTMVV4U1hoWGJrNXBVako0VkZsclduZGtiRnBIVjIwNVVrMXNSalJXTW5odllXeEtWazVYUmxkaVZFWlVWVEJhV21WVk5WWmFSbHBwVWpGS1NsWnNZekZVTVZwMFUyeHNhRkpGTlZaV2JGcDNWa1phZEUxVlpGUlNWR3hZVmpKek1WVXhTbGRpZWtaWFlUSlJNRmxxU2xKbFJtUlpZVVpTYUdKSVFsbFhWM1JoVXpGc1YxZHVUbGhpYlZKV1ZXMDFRMUl4V1hsbFIzUm9UVlZ3VmxscldtOVdNa3BaWVVoS1dsWnNjR0ZhVm1SSFVteGtjMXBGTlZkTlZXdzJWbXhrZDFNeFNuUldhMlJoVTBVMWFGVnRlRXRqUm14eVZtNWtWMVp0VWxsYVJXUkhWMnhhYzFKcVVscGhNbWhNVm1wS1MyUkdWbk5XYkZwcFYwZG5lbFpYTVRSV01sSkdUVlphWVZJeWFGUldhMVpoVjJ4a2MxWnRSbWxOVm5CNVZGWmFiMkZHVGtsUmJVWmFWa1ZhTTFaRlduTk9iRXB5VDFkd1RsWXhTalpXTW5Scll6RmtSMU5ZYkdoVFJuQllXVlJHZDFaR1ZuRlRhMXBzVW0xU1dsbFZaRWRXUmtwVlZtNW9WMVl6UWxCWmFrWnJVakZXYzFwR1pHbGlWa3BXVm0weE5HTXdOVmRqUlZwaFVrVktiMVpzVWtkWFJsVjVUbGhrVjJGNlJqRldWekZ2VmpBeFNGVnJaR0ZXTTJoSVdYcEtSMUl4Y0VoaVIyeG9UVWhDU2xadGRHRldNV3hZVWxob1dGZEhhR2hWTUZVeFZteHNjMkZGVGxWTlZtd3pWbTEwTUZaR1NuTmpTR2hXVFZkb2RsbFVRWGhXTWs1R1lVWmFUbUp0YUc5WFZtUTBVekpTU0ZKclpHbFNiVkp3VmpCa2IxUldXbFZSYlVaclRWVndXRlV5TlU5V1YwcEdUbFU1VjJGcldreFhWbHBhWlZkU1NGSnRiRTVoTVhCYVZsY3hkMWxXV1hsVGJsSm9VbTFvVjFsc2FHOU5NV3hXVjIxMFYwMVlRa2hYYTJSM1ZHeGtSbE5yZEZkV1JXOHdXV3BLUjFZeFRuTldiR1JwVWpKb1dWWlhNSGhWYlZGNFkwVldVMkY2YkhGVVZscDNaV3hzVmxwRVVsZFNhMncwVlRKNGMxWXhTbk5qUm1oaFVrVndXRmw2U2tabGJIQkhZVWRzVjFJemFGcFdiVEI0VGtkUmVGcEZaR2hOTWxKb1ZXeGtVMWxXV25SbFNHUnNZa2QwTTFZeWRFOVhSMFkyVW01b1ZtSllVblpXYlRGSFkyeGtkVk50UmxOV01VcE5WbFJDYTFNeFRraFNhMXBQVm14S1ZGWnNZelZPVmxwMFRVaGthMDFzUmpWV2JYUmhWREZhV0ZWdVFsWmlWRVoyVm1wR1dtUXhjRWRVYkZaT1ZteFplbFl5ZEdwT1YwWnpVMjVPV0dGclNtaFdiR1J2WTJ4WmQxZHJkR3BOYTNCR1ZrZDRiMkZGTVhKTlNHaFhZV3RLYUZkV1pFNWxWbEp5Vm14S2FWWldjRlZXYlhCSFV6Rk9WMWR1UmxKaVdGSlZWRlpWTVZOV1dsaGtSbVJYVmpCd1NWWlhjelZYYkZsNlZXeG9WVlpGV21oYVJWVjRWMWRPU0dWR1RrNVNSbFl6Vm0xMGEwMUdiRmhTYTJSVVlteGFVMWxZY0hOV01XeFlaRVZrVGsxWVFsZFdNakZIWVd4YWNsZHFRbUZTVm5CUVdWWmFZV015VGtaaVJtUm9UV3N4TkZaWWNFdFNNVWw0Vkc1V1ZtSlhhRlJaYkdSdllVWmtXR1JIUm10TlZrcElWakkxVDFkSFNsWlhiR3hXWVd0RmVGVnFSbXRqYkdSeldrWldhVlpZUWtoWFZFSmhZekZaZVZKWWJGVlhSMmhZVm10V2QxTkdWbkZTYXpsclZtczFlVlF4V210V01VbDZZVVpvVjJKVVFqUlVhMXB6Vm1zeFNXRkdhR2xpUlhCNlZsY3dNVkV5VFhoV2JsSlBWbFUxVkZscldtRlhWbkJXWVVkMFYwMUVSa1pWYlhoclZqQXhWMU5yYUZkaGEzQk1WVEJhVTFkWFJrZGFSazVUVm01Qk1sWnRNWGRTTVZWNVZHNU9ZVk5GY0ZGV2JURlRWREZzYzFwSE9WaFdiR3cwVmpKNFQxVXdNVmhsUm1oWFZqTlNjbGRXV2t0a1JsWnpZa1p3YVZKc2NHOVhWRW8wVmpKTmVGWnVTbUZTYldoVVdXdG9RMU5zV2tkWGJFNVdUV3RhU0ZZeU5VdGhWa3BIVTJ4a1ZWWjZWa1JXTUZwYVpERmtkRkp0Y0U1V01VbzJWakowWVZZeVJsZFRibFpTWWxkb1dWbFVSa3RSTVhCV1YyMTBWMDFXU2pGV1Z6RjNWVEpHTmxadVpGZGlWRVYzV2tSR2EyTXhaSFZUYkdocFYwWktlVlpHV2xkWlYxWlhWV3hrV0dKWVVsbFZha0ozWlZaU2MxZHVUbGhpVlhCSVZqSXhiMWRyTVZkalJsSlhUVWRTVUZSdGVFdGpNVlowWWtaT1RrMVZXVEpXYlRGM1V6QTFTRkpZYUZoWFIxSlBWbTE0ZDJOV1ZuUk5WemxhVm14S1YxWXlOV3RYUmtwelkwaG9WazF1VVhkV01GcGhZMnhrZFdKSFJsZFdia0p2VjFaV2ExSnRWa2hVYTFwT1ZtMW9XVlV3Vmt0VVZscHlWV3RrVkUxck1UVldSM1JoWVVaS2NrNVlRbFppUmtwWVZqRmFZVmRGTVZWVmJYUk9Va1ZhTmxacVNURlRNV1JJVTJ0YVQxWnJOVlpXYlhoV1pVWndWMWRzVGxkTlYxSXdXa1ZhYjFVeVNsZFRhM0JZVm14YWFGbFVSbXRqTVdSeVYyeE9XRkl5YUZwV2JURTBaREpHUjJFemFGaGhNbEp5Vm0xNFMyVldVWGhYYXpsb1ZtdHNObGRVVG10V01ERlhZMFpvV21GcldsTmFWVnByWkZaT2NrNVdaR2xXTW1oWlZqRmFVMU13TlVkaVJtUllZbXMxV1ZsdE1WTmpNV3h5VjI1T1QxWnVRbGRXTWpWcllWWkpkMk5GYUZaTmJtZ3pWako0WVZZeVRrbFRiR1JUVFRKb1RWZHJXbUZTTWsxNVUydGthRkp0YUZWVmJGWjNVMnhaZUZkc1RsUk5WbFkwVmpGb2MxWlhSWGhqUjJoV1lXdEthRlpyV21GamJHUjBVbXhvYVZKdVFscFhiRlpoWVRKRmQwMVdhRlppUjJoWVZGZHdWMVpHYkZobFJYUllWbXRhTVZaSGVHRmhWa3B5WTBWc1YxWkZXbWhXYWtwVFVtczFWMXBHVm1sU01VcFZWa1pXWVZkck1WZGFTRTVYWWxWYVZsUldaRk5sYkZsNVpFZEdhRll4V25sVk1uaHpWakpLV1dGRVRsZGhNWEJvV2tWa1YxTldjRWRVYXpWWFlUSTVNMVl5ZUZkaE1rMTRWbGhzVkdKcmNGVldhMVpMVjBac2NscEZPVTVOV0VKWFZqSjBkMkpHV25KalJuQmFWbFp3ZGxsV1pFWmxiRVp6WTBab1YyVnJTVEJXUjNSaFl6RlplRlp1VGxoaVIyaHdXV3hhUzJWR1pGaGtSM1JQVW14c05GZHJhRXRXTWtwV1YyNUNWbUpZYUROV2JYaHpZMnhrZEZKc1pFNVdWM2N5VjFaV2IxTXhXWGhUV0hCb1VqSm9hRlZ0ZUhkVFJuQkdWbFJXVjAxWVFrbFphMXBQVkd4S1IxSnFUbGRpVkVJMFdrUkdTbVZHVW5WVmJHUm9UV3hLYjFaVVFtRlpWbVJIWWtoS1lWSnJOWEZWYlhoaFRVWndSbUZIZEdoTmEzQkpWbGMxZDFkSFJYaFRiRkpYVFc1b2FGcEZXbGRrVjA1SFdrVTFhV0pYWjNsV2JYUnJUa1pzVjFOdVRsVmliRnBWV1d0YVlWZEdVbFZUYlRsVlZtMVNlbGRyVWxOWFIwcFhWMnhzVjJKWVVuWldWVnBoWXpGa2RWRnNXbWxXUmxwRlZsUkdZVmxXV2xkVWJGWlRZa1pLVDFadE5VTlhWbHB4VTFSR1ZrMVdjREJWTW5SclZrZEtTRlZzV2xkaVJuQXpWRlJHZDFkSFZrbFRiWGhYVmtWYVdGWXlkR0ZVTWtaSVZtNVNiRkp0ZUZoVVZ6VlRZMnhzTmxKc2NHeFNiVkl4VmtjeGIxUnJNWFJoUm14WVZqTm9kbGxxU2s5ak1rNUhZVWR3YkdFeGNGbFdSbHByVlRKV2MxcElTbGhpVkd4dlZtcENXazFzV25ST1Z6bFhUVlpzTmxWWGRGTlhSbHB6WTBkb1dtVnJXbkphUmxwTFl6RmFkR0pHWkZOTk1taG9WbTE0YW1Rd01WZFNXR2hVVjBkb2FGVXdWbmRYUmxweVYyMUdWMkpHU2xsYVJXaHJWVEF4V0dSRVRsZFdNMUpRVmpCa1MxWnNXbkZWYkhCT1VtNUNSVlpxU2pSWlYwMTVWR3RrVW1KR2NIQldNR1J2VlZaYWRHVkhSbFZOYXpFMFdUQldiMkZXU25KT1Z6bFZWa1ZLVEZaRVJtRmpWazV4VVd4YVRsWlhkekJXYTJNeFZURlplVkpZYkZaaVYyaFhXV3hTUmsxR2JIRlNiR1JyVWpGYVIxcEZXbTlXTWtwSFYxaHdWMkpVUlhkVVZXUkdaVlpPY2xwSGNGTmlXR2hYVm0xNGEySXlVbk5pUm1SWFYwZG9XVlZxUm1GVFJteFdWMjEwVldKVlducFdNbmhYVmpKRmVWVlVRbGhXYlZKUVdUSnpNVll4Y0VkWGJXeFRZa2hDV2xZeFpEUmhNa2w0VTJ4a1dHSnJXbFJaYkZaaFkyeFNWMWR1Wkd4aVJtdzFWR3hhVDJGRk1WWmlSRlphVmxaVk1WWnFTa3RXVmtwWlkwZEdWMDB5YUc5WFZFWmhWREpPVjFKdVVtbFNWRlpZVkZaV2QxTXhXbk5hUkZKcFRXdHNOVlZ0TlU5V1YwVjRZMGhHVm1GclNtaFhWbHBoWTJ4YWRWcEdaRk5pUm5BMFZsY3dNV0V4VlhoWGJrcFBWMGQ0V0ZSWGNFWk5SbXhYVjJzNVUySkZOWGxaYTFwclZHMUtjMU5zYUZkU2JIQm9Wakl4VW1Rd01WZGFSbWhwVmpOb1ZWWlhNREZSTVdSWFdrWm9hMUl6VW5CVVZWSkRUa1phZEU1VlpGWk5hM0JKVmxjMVMxWnRTbGxoUkU1aFZteHdjbGt5ZUd0ak1YQklZVVprYUUxdVkzbFdNVnBYWWpGc1YxZFlhRmhoYkhCVFdWZDRTMWxXYkZoa1NHUldVbXhhZUZVeWREQldSbHB5VGxod1dsWlhVbnBaVmxwaFkyMU9TRkpzWkdsU01EUjZWMnhXWVZadFZrZGpSV1JoVWpOQ1ZGbHJhRU5oUm1SeldrUlNXbFl3YkRSV01qVlBWbTFGZVZWc2JGWmlWRVYzVkZSR1dtVlZNVVZXYkdST1VrVmFOVmRVUW1GWlZsbDVVMnhzVm1Kc2NGaFpWM1JoWVVaV2RFMVZPVk5pU0VKSlZXMTRhMVJyTVhSaFJuQlhUVzVTYUZkV1dsWmxWbEpaWWtaV2FFMXRhSFpXVjNoVFZqRmtWMVp1VGxkaVNFSlBXV3RhZDAxR2NFWmFSV1JYVFVSR1dWcFZXbTlXTWtwSVlVaGFWMDFIVWt4WmVrWlBZekZXYzJOR1pGTlhSVWw1Vm0xNFlWbFdiRmhWYTFwT1ZtMVNWbGxzWkRSVU1WbDNWbXQwV0dKSFVubFdiVEV3VlRBeFdGVnJiRlpOYmxKeVdWZDRUMU5XUm5OaVJtUk9VakpvUlZaVVFtRmpNVnBYVW14c2FGSnRhRlJaYTFwMlpVWmtWVkZ0Um1oTlZrb3dWVEkxVDFaSFNsVmlSbWhhVmtWYVRGVXdXbk5XVmtweVpFZDBVMkpGY0RWV01uUnJZakZWZVZOdVNsUmlSM2hZVlcxNFMxTkdWWGxOVm1ScVRWZFNNVlV5ZUd0aFZscFhZMFp3V0ZZemFHaFhWbHBQVWpGd1NWTnRhRk5XUjNob1ZtMHhNR013TlhOV2JHaHFaV3hhV1ZsclduZFNNVmw1WTBVNVYyRjZSbGhaTUdSdldWWktWMVpxVWxkaVJuQllXa1ZrUjFKck5WZGFSMmhPVFVWV05GWnRNVEJaVm14WFlrWmthVkp0YUZSWmEyUlRWbFpzVlZOc1RtcFdiRm93VkZaak5WZHNXblJsU0d4WVlUSk5NVlpVUmt0ak1XUjFZa1prVG1GclZqTldiWEJDWlVaa1IxWnVSbEppVlZwVVZtcEdSMDB4V25OVmEzUlVUVlUxV0ZWdE5VZFhSMHBJWVVab1dtRXhjRE5aYWtaclZqRldjbVJHVGs1V1dFSTFWa1phWVdNeFduUlRiR2hvVW14S1lWWnJWVEZTUmxsNFYyMTBXRkl4V2toV1IzaExWR3hLUjFkcmJGZGhhMjh3Vm1wR1ZtVldUbkpYYlhCVVVsUldXRmRYZUZOU01WcEhWV3hrV0dKVldsVlZha1poVTJ4a2NscElUbFpOUkVaS1ZWZDBiMWRHV2taVGJscGhVa1ZhWVZwV1drOWpNVnB6Vkd4a1UxWllRblpXYkdRd1ZqRkpkMDVWWkZkaWExcFVXV3RrVTJOV1VsZGhSVTVVVW14c05WUldhRTlXYXpGWFkwVm9WMDF1YUhwV2FrRjRWakpPU1ZkdFJsTlNWbkJNVjJ4V1lXUXhTWGhqUldSb1VqSjRWRlJYTVc5VmJGcDBZMFZPYUUxV1ZqUlhhMVpyVm0xS1IyTkdaRnBXUlhCVVdYcEdWMlJIVmtsYVJUVlRZbXRLV0ZadE1YcE9WbVJIVTFoa2FsSlhhR0ZaVkVaTFlVWlplV1ZIUmxkTlYxSldWVmQ0YTJGSFJYZFhWRUpYWVd0S2FGWnFTazlrUmtweVdrWm9hR1ZzV2xWV1JscFhaREZPYzFkdVRtRlRSMUpVVkZkMFYwNVdXbGhrUnpsWFVqQldOVlpYTURWV2JVcFpWRmhvVjFKRlducFpla1pyWTJ4a2RHVkdaR2xUUlVZelZtdGFZVlV4VlhoWGJrcE9WbXh3V0ZsWGVFdFpWbXhWVW01a2EySkdjSHBYYTFZd1lXc3hWazVZY0ZwV1ZuQXpXVlZWZUdNeFRuRlRiR1JwVmtWVmQxZFljRWRoTVU1SFYyNUthVkl3V2xSWmJHUnZWbFprV0dWSE9XbE5SRlpZVmpGb2MyRXhTWGRYYkZwVlZteHdNMVpxUmxOV01XUjBaRWRvYVZKWVFraFdWRW8wV1Zaa2RGSllhR3BTTW1oWVZteGFkMkZHVm5OWGF6bHFZbFpLU0ZaSGN6RmhSVEIzVTJ0b1YySlVRak5hVlZwS1pVWmFXV0ZHYUZoU01taFZWMVprZWsxV1pFZGlSbFpUWVROU1ZWVnRlRmRPVmxKWFYydDBhVkpyY0RGVlYzUjNWbXN4Y1ZKcmFGZFdSWEJNVldwS1QxSXlTa2RoUm1ST1RWVnZlVlpzV2xOUmJWWklWRmhvWVZOR1dsWlphMlJUWTBaYWMxZHVaR2hTYkhBd1ZGWlNRMkZyTVVWV2EyaFlZVEpvVEZsVldrdFdWMHBJVDFaYWFWZEdTWHBXUmxwaFZqRmtSazVXV2xWaVIxSndWbXhvUTFsV1duTmFTR1JWVFZad2VWUldXbXRoYkVsNVlVWmtXbFl6VW1oV01GcHlaVmRXU1ZwR1RrNVhSVXBJVmtkNGEySXlTa2hUYTJScVVqQmFXRmxzYUc5V1JsVjVZek5vVjAxWFVscFpWVnB2WVZaSmVXRkdXbGhXYkVwTVdXcEtTbVZHV25WVmJYaFRWMFpLYUZadE1UUmtNbFpYVjI1T1ZtRXlVbGRVVmxaM1RVWmFXR1ZIT1ZkTlJFWjRWV3hvYTFZeVJuSlNhbEpYWVd0d1VGVnNXa2RqTVdSMFlrWmtVMVp0T0hsV2JURXdZVEExUjFwSVVsZGhNbEpXV1cxMGQyTkdWblJOVms1WVVteGFlbFl5Tld0VWJVcElWV3h3V2sxR1dYZFdWRUY0Vm0xS1JWVnNaRk5sYkZwWlZtMHdlRk14WkZoU2EyUldZa2hDY0ZWcVNtOU5iRnB4VW0xR2FFMVhVa2RVVmxaWFZUSktSbU5GT1ZkaVIxRjZWRlZhYTFaV1JuTmFSbVJPVm14Wk1WWlVTVEZWTVZwMFUydGtWR0pIYUdGWmEyUnZWREZ3VmxkdVpGZE5WMUl3V2tWa2QyRldTWGhUYWxaWFVrVmFhRlpxU2tkV01VNTFWbXhLV0ZJeWFGbFdiVEUwWkRKU2MySklSbE5pU0VKelZXMHhVMlZHV1hsbFJUbFhUVlZ3VjFrd1duTlhSbHAwVlZoa1lWSkZXbEJWYWtaclpGWktjMVJ0YUd4aVdHZzBWbXRhWVZsWFVYbFdiazVoVTBWd2FGVXdWVEZXTVZKV1ZXdGtWMDFYZEROV01qVnJWakF4Y21ORmJGZFNNMEpVVm14a1JtVldWbk5VYlVaWFlraENWVmRyV21GVk1rMTRXa2hTYVZJeWFFOVVWVlozWVVaYWNWSnRkRTlTYkd3MFdXdGFiMVpYU2toVmJHUmFZVEpTVkZZeFduTmtSVEZYVkd4V1RsWnVRWGRYYkZadllURmtSMWR1VW10U1JuQmhWRlZhZDJOc1duRlJXR2hUVm10d2VWWXllR0ZXTURCM1UyeFdWMkpVUmpaYVZXUlRWMFpLY21KSGNGTmlWa3AyVjFaU1IyUXlTWGhYYTJoT1ZrWktWVlJXV25kWFJsWjBUbFpPVmsxcmNFZFViRnBUVmpBeFIxZHJlRmROYm1oaFdsVmtSMU5XY0VkVmF6VlhWMFZHTTFadE1IZE5WbEY1VW01T1ZHSkhhRzlWYm5CelZqRnNjMkZGTld4U2JYY3lWVzAxVDJGck1YSlhhMnhWVFZad2RsbFdXa3RrUjFJMlVXeGthR0V5ZDNwV1IzaHJVbTFSZDAxV1pGaGlWM2hVVld4U1YxWXhXblJOVkZKclRXczFlbFl5TlVkV1IwVjZWV3hXVm1GclNtaFZNbmhoVTBkV1NGSnRhRmRpVmtwSVZrWmFVMVV4V1hsU2JrcFVZbGRvV0ZaclZtRmpiRlYzVjJ4a2FtSlZXa2hXUnpGelYwWkplV0ZHY0ZkTlYxRjNWMVprVTJSR1ZsbGhSMFpUWWtad1ZGZFhlRmRaVmxwelZXeGtXR0pyTlU5VVZscExWMFpzVmxacVFsaFNhMnd6V1RCU1ExbFdXbGRqU0ZwWFlrWndZVnBYZUVkamJVWklVbXhPVGsxdGFHOVdNbmhoWVRGU2RGWnVVbE5oTWxKb1ZXeFNWMkl4Y0ZobFIwWlVUVlpzTkZZeWVHdFhiRmw0VW1wV1ZrMXVVblpXVkVaclUwZEdTVkpzV2s1U01VVjNWbXBHWVZsWFRuTlhibFpoVWxSc2NGVnRkSGRYVmxweFUxaG9UbEpzY0VoVk1qVkxWREZrU0dWSFJsZGlSMUpVV2xkNFlWWldUbkphUlRscFVtNUNObGRVUW1GaE1WbDNUVWhzYUZKdGVGaFpiR2hEVVRGU1YxZHJjR3hTYmtKS1ZtMTRZV0ZIVm5OWGJIQlhWak5DU0ZWNlJtRldNV1J5V2tab2FWZEdTbEZXVnpCNFZURmtSMWR1VWs5V1ZHeHZWVzEwYzA1c1dsaGxSMFpYVm14d2Vsa3dVazlXTURGWFkwZG9WMDFIVWxoVk1HUlRVakZ3Ums1V1RsTldia0pNVm0weE5HRnJNVmRpUm1SWVYwZDRWVmxVU2xOalZsVjNZVVZPYUZKc1ducFhhMXBQVmpGS2MxWnFVbGROYWxaeVZsUkJlRmRHVm5WalJtUlRaV3RhTmxadGRHRlRNVnB6V2tac2FsSnRVbkJXTUZwTFlqRlplRmR0Um1wTlZtdzBWbTE0YzJGV1NuSk9WemxWVmpOb1RGWnRlR3RYUlRGWlkwVTFWMkpXU2xsWFYzUmhZakpGZUZOc2JGWmlSMmhoV1ZSS1VrMUdjRmRYYkhCc1ZsUkdWMWRyV210aFZrcFpVVmhrV0dKR1dtaFpla1p6VmpGa2MxcEdhRmhTTVVwb1ZtMXdUMVF3TlVkWFdHUllZa2RTY2xacVFtRlRSbGw1WlVkMGFWSXdWalJaTUZaM1ZqSktXV0ZHVWxaaGExcHlXa1ZhWVdNeVJrZFViV2hPWW0xb00xWnNZM2RsUmxWNVZHdGtXRmRIVWxsWlZFNVRZMFpTVjFkdVRrOVNiR3cxVkZaU1ExWXhXWGRqUm1oWFRXNW9kbFpxUm1GT2JGcHlaVVprYUdFelFrMVdWekI0VkRGT1YxSnVUbUZTTW5oVVdXMTBSMDVzV25STlZGSmFWbTE0V1ZaWGRHOVdWMFY0WTBkb1ZtSllhRXhXUkVaaFl6RldjMXBHYUZkaVNFSTBWbFJHVTFJeFduSk5WbVJVWW01Q1dWbFVSbUZsYkZwWVRWVjBhbUY2VmxoWGExcDNZVlpKZVdGRVNsaGlSMUV3VmxSS1RtVkdjRWxVYkdocFYwZG9XVlpHV2xka01VNVhWMWhzYTFJd1dtOVVWM1JoVjBaWmVXVklUbFppVlZZMlZWZDRjMVl5U2xsaFIyaGFUVlp3VkZsNlJtdGtSa3B6V2tVMVYwMVZiekJXYlhCTFRrWlJlVkpzYUZSaE1uaFRXV3RrTkZkR2JITlZhMXBPVW01Q1JsVXlkR3RWTURGeVZtcGFXbFpXY0haWlZWVjRZekZPZFdKR1pGZE5NRXBKVmxod1IxUXhTWGhhU0U1b1VqTkNjMWxVUm5kWFZscEhWbXhPVTAxV2JEUlpWRTVyV1ZaS1dGVnNhRlZXTTFJelZURmFZVk5IVGtkVWJHUlhZa2hDV2xac1pEQmhNV3hYVjI1T2FsSllhR0ZVVnpWdlRURldjVkpzWkd0U01IQkpXVlZrTkdGV1NuVlJiVGxYWWxoQ1NGbFVRWGhUUmtwWllrWlNXRkl5YUc5V1YzaHJWVEpPUjFaWVpGZFdSVnB3VkZaYVlVMUdhM3BqUldSWFZsUkdXRlV5ZUc5V01ERnhWbTVLV21FeGNHaFpla3BMVWxaYWMxWnNaR2xTV0VKR1ZqRmFWMkV4U1hkT1dFNVVZbXMxY0ZWdE1WTlhSbEpWVVd0MFUxWnNjREJVVldodlZrVXhXRlZzYkZaaVdGSllWbXhrUzFOR1ZuUlBWbkJYVWxSV1JWWnJXbUZaVjFKSVZHdGFZVkpzV2s5WldIQldaREZhV0UxVVFtaE5WM2hZVlRJMVMxUXhaRVpUYkdSVlZsWndhRlpGV25kVFIxWklVbTEwVTFaRldtRldNblJoVkRGU2MxZFljR2hTYmtKWVdXdGtVbVF4YkZWU2JVWllVbXMxTVZVeWN6VldNbFowWlVab1dGWnRVWGRhUkVwVFl6RmtkVk5zYUdsV1ZuQjRWMWQwYjFFeFNuTlhiR2hzVW5wc1dGUlhkSGRYUmxWNVpVaGtXRkl3Y0VoV01qVkhWbGRLUjJOSGFGcE5iazQwVm0xNFlXTXhUblJoUjJ4VFYwVktZVlp0TUhkTlYxRjRWMWhvV0dFeVVuQlZNRlozVjFac1ZWUnJUbXBpUmtwWVYydGFUMVJzV25OWGFrSmhWbGRSZDFsVldtRmtSbFp5V2taV1YySkZjRlZXYlhCTFV6RmFWMU5zVmxKaVIxSnZXVlJPUTFaV1dsVlJiVVphVmpBMU1GVnRkRzloTVVweVRsaENWbUpVVmtSVVZFWmhZekZyZWxwRk5WZGhNVmw2VmtkNGIxUXhiRmRUYmxKb1UwVmFWMWxyV2t0bGJHeHhVbXhPVjAxWFVqRldSM00xVlRKS1NHUjZSbGhXUlVweVZXcEdZV1JHVG5KaFJscG9UVzVvYUZadGVHRmtNbEp6VjI1U1RsWldjSE5WYlRGVFpVWmFTR1ZIUmxWaVJYQXhWVmR3WVZZeFNqWlNWRUpXWld0d1VGa3ljelZXTWtaSVpFWk9hVlpyY0ROV2JHTjNaREExVmsxSWFGaFhSM2h6VlcweFUxbFdXblJsUldSUFZteGFNRnBWWkRCWFJrcDBWV3RzWVZaWFRURldiVEZMWkZaR2RXTkdaRTVTYmtJMlYxaHdSMVl5VG5OYVNGSnJVbFJXV0ZsdGRFcE5SbHB6V1ROa1RsWnNSalJYYTFaclZrZEtjbU5JUmxaTlIxRXdWakZhYzFaV1NuVmFSM1JwVWpOb1dGWnRlRzlpTVdSSFYyNUtXR0p1UW1GVVZWcDNaR3hhY1ZOc1pHcGlSMUpXVlRKNGExVXlTa2xSYlRsWVZteEtTRlV5TVZkV01WSjFVMjFzVTJKRmNIZFdiWGhoWkRGYVYxcEdaR2hUUjFKWVZGWmFZVk5HV1hsbFJ6bFZZa1p3U0ZVeU1VZFdNa3BIVTJ0b1ZrMUdjR2hXTUdSWFUwZFNTR0ZHVG1oTmJtTjVWbTE0YTA1SFNYaFhiR1JZWWtkU1ZWbFVTbTloUmxwMFpVaGthRkp1UWtkWGExVTFWa1pLY21OSWNGaGhNbEo2VmxSS1MyTnNTbkZVYkdST1ZtNUNXVmRYY0VkVWJWWkhXa1pzWVZKVVZsaFdha3B2VjBaa1YxVnJkRlpOYTFwSVZqSTFUMWRIU25SVmJrWmFZVEpvUkZWcVJtdGpiRnAwWkVaYVRsSkZXbUZXVm1Rd1lqRlplRk5ZY0doU2EwcFlXVmQwZDFSR2EzbGxSVGxxVFZoQ1NGZHJaRzloUlRGWlVWaHNWMDF1VWxSVmFrWlBaRVphYzFwR1VtbFNNMmgyVmxkd1ExbFdXa2RpU0U1aFVucHNXRlp0TVZOWFJscFlaRVJDVjJGNlJsaFphMUpUVjIxRmVXRkZlRmhXYkhCTVZHMHhTMUl5UmtkWGJXeFlVakpvVGxadGNFZFpWbFY0VjFob2FWSkdjRmhaYTJSdlZrWlNWbUZGVGxSV2JWSlpXa1ZhVDFack1WZGlSRTVWVm0xb1dGbFZXa3RqYkU1ellVWndWMUpXY0ZsV1IzUmhXVmRPVjFOdVVtdFNNMUpZVkZWb1ExTldXblJOVkZKb1RXdGFXRlV5TlZkVmJVWnpWMnhvV21KSGFFUlZhMXB6VmxaS2NrNVhlRk5oZWxaaFYxWldhMUl4V2tkVGJGWlhZa2Q0V1ZacVRsTmtiRlpWVW0xMFUwMVdjREZXUnpGdlZURmFWVlpzYkZkaVZFVXdXa1JCZUZJeVRrWlhiVVpUVmpGS2RsZFdhSGRTTVdSWFYyeG9iRk5GTlZoVVZsWnpUbXhhV0UxWE9WaFNiSEI2V1RCV05GbFdTbGhWYTJoV1RWWndTRmw2Um10a1IwcEhXa1pPYVZORlNraFdiVEI0WkRGTmQwNVZaR2xTYlZKVlZqQmtiMkZHVlhkWGEzUnFWbXhhZWxaWE5VOVhSa3AwWlVoc1dsWldXbEJXUkVaaFl6Sk9SbUZHWkU1aGEwVjRWbTE0Vm1WR1pFZFdia3BwVW14d2NGWnJXbUZVVmxwMFpFZDBWRTFYVWtsVmJYUnJZVVpLZFZGdE9WVldiV2hEV2xkNFlWSXhWbkphUjNST1ZqRktTbFp0TVRCaU1WVjVVMnhzVW1KSGFHRldNR2hEVjBaU2MxZHRkR3BpUm5Bd1ZXMHhjMVJzV25Sa2VrWlhWak5vZGxscVNrZGpNVTV5V2tkd1UySlhhRmxYVjNoVFVqRlZlRlZzV2xoaWF6VllWbTEwZDJWc2EzZGFSRkpXVFd0Wk1sWnRjR0ZXTURGMVZXNUtZVkpGV21oVmFrWlBWMWRPU0dGR1RtbFhSMmhhVmpGa05HSXhSWGhXYTJSWFlrWmFWRmxZY0hOV1JsSllZM3BHVTAxV2NEQmFWVlUxWVVaS1ZWRnFUbFpOYWxZelZtcEdXbVZzUm5KVWJGWlhZa2hDVEZkc1ZtdFRNVWw0V2toT2FGSXlhSE5aYkdodlRXeGFkRTFJYUU1U01VWTBWakkxVDFkSFNuTlRiazVXVFVaVmVGWXdXbE5XTVdSMVZHczVhVkpzY0ZwWGJGWlhWREZrU0ZOc1dsaGliWGhYV1d0a2IyUnNXblJOVldScVlrZFNNVlV5TVVkVk1rcEpVV3hHV0ZkSVFreFZha1pQVTBaT2NscEhSbE5pVmtwM1YxWlNRMlF3TVhOWGJsSk9VMGRTYzFWcVJrZE9SbFY0WVVjNVYxSnRVa2xXVjNNMVZtc3hTRlZ1V2xkaGExcDZXVEo0ZDFJeFVuTmhSbVJwVjBkbk1sWXhXbGRaVmxGNFdrVmtWR0pyTlZWWmEyUTBZVVpXYzFwSE9XcGlSM2g1VjJ0V01GVXdNVmRqU0doWFlsaG9XRmxXV2t0ak1WcFpZVVprYVZkRlNrMVdXSEJIV1ZkU1IxVnVTbUZTTTBKVVdXeGFTMVpXWkZobFIzUnBUVVJHZWxZeU5VZFdSbVJJWVVaU1ZWWXpUWGhhVjNoclkyMUdSazlYYUZOaE0wRjRWbFpqTVZReFpITlhhMXBZWVdzMVdGUldXbmRqYkZwelYyczVhbFpzV25wV01uTXhZVWRXYzFkVVJsZGhNVXBJVjFaa1JtVkdaSE5oUmxKcFVqSm9lbFpYTVRSVE1XeFhZa1pXVkdKRmNISlVWbHBMWlZaWmVVMVZaR2hpUm5CNVZHeG9iMVl4V1hwaFNFcFhVbnBHUjFwVldtdFdWa1p6V2taa1UxWnVRWGxXTVdSM1VqSkZlRk5ZYUdwU1ZuQnZWVzE0ZDJJeGNGaE5WRkpZVm14d1NGWnRNVWRYYkZwVlVXcFNXbFpGTlhaV01HUkxVMFpXZFZOc1dtaGhNWEJ2VmxSS05HRXlUbk5hU0ZKclVteGFjRlZ0TVROTmJHUlhWbXhPV2xadFVraFdNalZQVjBkS1NHRkdhRlpoTVZvelZUQmFWMk5XU25KUFYzUlhZa1Z2ZDFkVVFtRlZNVnBIVTJ4YWFsSnVRbGhaVkVaM1kyeHdSVkpyY0d4U2JFcDVWMnRrYzFVeVNsaGhTR2hYVW14S1RGbHFSbXRTTVZaellVZHdiR0V4Y0ZaWFYzUnJUa1paZUZkWWJFNVdSVXBZVkZWU1IxSnNWbGhqUm1SWVlrWndXVlpHVWtkV01ERkhZMGRvV21WclduSmFSbHBQWXpGa2RHSkdaRk5XYmtKaFZtMTRVMUV4YkZkV1dHeFZZbXhLVkZsVVNsTlZNV3h5V2taT2FsSnNjSGhWTWpBMVZHMUtSMk5JYkZkTmFrWklXVlpWZUZac1duRldiRnBPVmpKb01sWnFRbXRUTWsxNFZHNVdVMkpHY0hCVmFrcHZWbFphZEdORlpGWk5WbXcwVmpKNFYxVXlTa2RUYkZKYVlUSlJlbFJXV21GVFIxWkhXa1UxVTJKV1NqWldha2t4VXpKR2MxUnJiRkppUjJoV1ZtcE9RMWRHVm5KWGJVWnJVbFJHVjFkclpIZGhWa2w0VTJwV1dHSkdXbWhaVkVwSFZqRk9kVlpzU21sV1IzaFpWbTF3VDFFeFRrZFhia1pVWVhwc2NsVnRlR0ZsVm14V1draE9WazFFUmpGWlZWcHpWMFpaZWxWdVdsWldNMDQwV1hwR2EyUldWblJqUms1WVVsVndVVlp0TUhoT1JsbDNUbFprVjFkSGVISlZhazVUVjBaV2RFMVdUbFJpUmxwWldsVmtNRmRIU2xaalJuQlhWak5DVUZacVNrdFhWMFpJWVVkR1UxWXhTbGxXVkVKaFV6Sk5lVkpyWkZWaVYzaFVWakJXUm1WV1duUk5XR1JVWWxaYVNGVXhhRzlYUm1SSVZXczVWMDFHV2pOV01WcHpWbFpPY1ZWc1pHbFNhM0JaVm1wSk1XRXhVbkpOVm1ScVUwZG9WMVJYTlZOamJGcEZVMnQwVTAxck5VcFphMXAzVmpGYWRWRnViRmRpUmtwRFdrUktWMWRHU25KV2JGSnBVakZLV1ZkWGRGZGtNVTVYVjFob1dHSllVbGRVVmxaelRrWmFXRTVXWkZkV01IQlpXbFZhVTFaV1dqWlNibHBYWWtad2FGWXdaRmRTTVZKeldrVTFWMDFWY0ZwV2Frb3dXVmRGZUdKR1pGUmhNWEJWV1d4V1lWZEdiRmhrUjBab1VtNUNXVnBWYUU5V01WcHpVMnBHVjFKNlJucFdWRXBHWlZkUmVtTkdaR2hoTWpoM1YxZHdSMWR0VmxkVWJrNXBVbXh3YjFsWWNGZGlNVnAwWTBVNWFVMXNXbnBXTWpWVFlrWkplbFZ1UmxwWFNFSjZWakZhYzFac1pIUmtSMmhUVmtWSmVsWlVTWGhpTVZsNVUydGthbE5GY0ZaWlZFcFRWREZ3VmxkdGRGaFdNSEJJVmxjeGMxVXdNSGxoUkVwWFlrWktSRlpxU2xKbFJtUjFWR3hvYVdGNlZtOVdWekY2VFZaYVIxVnNaR2hTVlRWWVZGWmFjMDVXVW5OYVJFSlhZWHBHZVZrd1ZuZFdiRmw2Vlc1YVYwMXVhR2hXTUZwWFpGZE9SMk5HWkZkTlZYQmFWakZvZDFJeVJYbFViR1JYWW1zMWFGVnFTalJXUmxKV1ZXeE9UMkpHYkRWYVZWcHJZVVV4Vms1VVFsZGlXRkoyVm10a1JtVldWblJoUmxwcFZrVmFNbGRVUW1Gak1XUllWR3RrWVZJeWVFOVdiVFZEVjJ4YVIxZHNUbEpOYTFZelZGWm9TMVF4WkVsUmJHaFhZV3MxZGxreWVGcGtNWEJHWkVkd2FHVnNXbGhXUkVaaFZqRlplVk5yYkZKaGJIQllWV3BPYjJGR2NFVlNhM1JxVFZad01WVXllRmRoVmxsNVlVWldWMUpzV21oWk1qRlhWakZrYzJGRk5WTlNWbkI0VmtaYVlXUXhaRmRXV0d4clVqTlNXVlZxUW5kWFZteFdWMjA1V0dKVmNFbFpWV2hoVjBaYWMyTkVUbGROUmxZMFZtMTRkMUl4Vm5OYVIyaHNZa1pyZVZadGNFdE5SMFY1VTFoc1UyRXhjRTlXYkdSVFkwWldjbGR1WkZoU2JFcFpWR3hqTldGR1NuUmxSbHBXWWxoU00xbHJXa3RqYXpWWFkwWndWMVp1UWxWWFZscHJVakExYzFkdVVsQldiVkpZVkZSS2IxWldXblJqUldSb1RWVnNOVlV5ZEhOV2JVcFpWV3hTVjAxR2NFeGFWbHByVjBkU1NGSnRkRTVpUm5CSlZtMHdNVlV4VW5OWGJHaFdZbFJzVjFscldrdFRSbGwzVjJ4YWJGWXdOVWRXUjNoclZHMUZlbEZ0UmxoV2JGcDJWWHBHV21WV1RuTldiRTVvVFRKb2FGWkdaSGRTTVZaSFZsaGtWMVpHV2xoVVZtUlRUVVpzVmxwSE9WVmhla1pIV1d0U1YxWXlTbFZSYWxKVlZsWndlbFl3V2xOWFYwcEhWMjFvVG1KWGFGbFdNVnBUVWpKUmVWUnVUbGRpYkVwelZUQmtVMWRHVm5STlZGSnNZa1pzTlZwRlVrTlhSa2wzWTBWb1drMUdXblpXYWtwTFZsWkdWVkpzY0ZkaVJsa3dWMVJLTkdFeVRYbFRhMlJZWVhwV2NGbHNaRzlPVmxwMFkwVk9hRTFWTVRWV1YzaHJWVEpLY2s1WE9WWmlXR2hvVmpCYWQxZEhWa2hTYXpWcFVqRktOVll5ZEZOVk1rWnlUVlpvVm1FeWVGaFpiR2hUWVVac1ZWSnJkR3RTTUZwSVZsZDRkMkZGTVZsUldHeFlZa1phYUZkV1dtRldNVkoxVW14YWFWSXhTbEJXYlRCNFRUQXhWMWRzVmxSaGEwcHZWRlphYzA1V1ZuUk9WVGxYVWpCd1NWbFZXbTlYYkZwR1YyMW9XbFpXY0hwV2JYaHJaRVpLZEdSR1RsZFNWbkJhVm1wS01GbFhTWGhXV0d4VVlUSlNjVlZyV21GWFZscDBaVWRHYUZKc1dsWlZiWGgzWVRBeFJWSnNjRmRXZWtaMlZsUktTMWRYUmtkalJtUnBWa1ZWZDFaWWNFZFdNVWw0VjI1T1YySkZjRmhWYkZwM1YxWmFSMWR0ZEZaTmJGcFlXV3RhWVZsV1NrZFRiR1JWVmxaS1NGVXdXbkprTWtaSVQxWmtUbFpZUWpaWFZFSnJZakZzVjFOcldsTmhiRXBYV1ZkMFlXRkdXWGhhUlhSVVVqRktTRlpIY3pGVWJGcFpVVzFvVjJKWWFISmFSRVpHWlZaV1dWcEZOVmRXTVVwNFZsY3hOR1F5UmtkV2JsWnFVMFUxV1ZWdGVFdFhWbkJHWVVkMFdGSXdjRWxhVlZwclZqRlplbFJVUmxkTlIxSk1WV3BLVDFJeVJrZGpSVFZUWVROQ1VsWnRNSGRsUmsxNFdrWm9VMkV5YUc5VmJURlRWREZhY1ZKcmRGUldiSEJaV1RCV2EyRXdNVlppUkZKYVRVWmFkbGxXV2t0amF6VlpVV3h3VjFKVmNGbFdSM2hoV1ZkU1JrMVZiR2hTTTFKUFZteFNSazFXV25STlJFWlVUVlpLZWxZeU5WTldiVXBJWlVab1ZWWlhVbFJhUjNoYVpVWmtkVlJ0ZEZOTlJGRjVWbGN3ZUdNeFVuTlhia3BxVW0xU1dGWnJWbk5OTVZKelYyMTBVMDFWTlRGV1Z6RTBWa1pKZW1GR2NGaFdiRXBJV2tSR1UxSXhaSEpoUjNoVFYwWktlVlpYY0VkWlZrNXpZa1phV0dKVldsWlpiRlozWld4VmVHRklaRmhTYkd3MlZsY3hiMVp0Vm5KalJsSldZV3RhYUZwR1dsTmtSMDVIVkcxc2FFMUlRbUZXYlRCNFpERkplRlJZYUZWaVIxSlpXVzF6TVZZeGJGVlRiRTVZVm0xNGVsWXlNVWRYUmxwelYycENZVkpYYUZCWlZXUkxVbTFPUlZGc1pGZE5NbWd5VmpGYVlWZHRWbk5XYms1aFVqQmFWRlZzV25kbFZtUlZVMnBTVjAxck5YcFpNRlp2WVd4S1ZWWnNhRnBpUjJoeFdrUkdZV05XVG5GUmJXeE9WbTEzTUZacVNqQmlNVnBJVWxoc2FGSnRVbUZaYkdoVFZFWmtWMWR1VG1waVIxSXhWMnRhVjFVeVNraGtla0pYWVd0c05GVnFSbXRTTVU1elZteE9hVkp1UWxsV2JUVjNVakF3ZUZkcmFHeFNXRkpVV1d0Vk1WWnNWbGhsUjNSb1VqQldORmt3VWt0WFJtUkpVV3RvVjFaNlJsaFZha1ozVTFaU2MxcEhiRmROTW1oV1ZqSjRhbVZGTlVkWFdHaFlZbXhLVDFacldrdFpWbHB4VW0xR2JHSkdjRmxVYkZZd1YwWkpkMk5GYUZwTlIyaFFWbXBLUjJOc1pISmxSbHBPWW0xb2IxWlVRbXRXTVU1SVZXdG9hRkp0VW5CVk1GWkxZVVphYzFkdGNHeFNhMncwVjJ0V2ExZEhTbkpPVm14YVlsaFNNMWRXV25OWFIxSklVbXh3VjJKclNsaFdha3A2VGxaa1IxZFlaRTlXVjNoaFZteGFkMVZHV2tobFJYUnJWbXRhTVZZeWVHdGhWbHBHVjFod1YyRXhTa3hWTWpGU1pEQXhWMkpHVm1sWFJVcFZWMWQ0YTJJeVZuTlhiRlpTWWxoU1YxUldXbmRUUmxwWVpVZDBhRkpyY0ZkVWJGcFhWbTFLV1dGRVRsWk5WbkJVVm1wS1IxSnJPVmRhUlRWWFYwVkpNVll4VWtOWlYwVjRXa2hLVGxaWFVsVlpWRTV2VjBac1dHUklaRlZTYkhCNlZqSjBNRmRHV25WUmEyaFlZVEZ3Y2xaVVJtRmtWa1p5VFZaa1RtSnRhRzlXTVZwaFZHMVdSMk5GWkdoU2F6VnZWRmQ0UzFkR1pGaGtSM1JwVFZad1NGWlhlRzlVYkZvMllrWnNWbUpZYUhwVWExcHJWbFpTZEU5V1ZrNVdXRUYzVjJ4V1lXSXhXWGROV0VaWFlrVktZVlp0ZUhkVlJsWjBUVlU1VTAxcmNFaFpNRnByVlRGYVIxZHNXbGROVmtwSVYxWmFXbVZXVm5KaFJtUm9UVzFvVlZkWGVHOWlNVnBIWWtoS1dHSklRazlXYlhoM1UwWmFkR1ZGT1ZkTlJFWlpWbGQwYjFack1YRldiRUphVmpOb1VGVXhXa2RrUmtwelZteGtWMkpyU25aV01uUnJUa1prZEZWWWFHcFNWbkJaV1d4b2IxZEdVbFpYYm1SVVRWWndWbFV5Y0ZOaFJURnlWMnRzVm1KSGFISldNRnBoVW14T2MyRkdjR2xTTW1oRlZsUkNZV014V2xkVWJrcFFWak5TVkZsVVRrTk9WbGw1WkVkMFUwMVdWalJXTW5SclYwZEtkRlZzYkZkaGF6VlVWakJhZDFKV1NuUmtSM0JPVmpGSmVGWnNZM2hPUmxWNVVtcGFWMkpHY0ZoVmJYaDNWakZ3VmxaVVJsTk5WMUphV1d0Vk5WWXhXa2hsUjJoWFlsUkdObFJXV2s5U01XUlpZa2Q0VTJKV1NscFhWM2hYVmpBMVYxZHNhR3hTYXpWWldWaHdSMU5HYTNkYVJXUmFWbXR3UjFZeU5VdFhhekZ4VW14U1ZrMUhVa3hWYlhNeFZqRndSazVXWkZkbGJXY3hWbTB3ZDJWSFVYaFVibEpYWVRKU1ZWWXdaRFJXUm14VlVtNWtWVTFXYkROV2JUVnJWbXhLYzJKRVRscFdWbHBRVmpCYVlXUkhWa2RYYkZwT1lXdEZlRlpxUW1GVE1sSkhWbTVPYUZKdFVrOVpiWGhIVFRGa1YxVnJaRlJOYXpFMFYydG9WMkZXU25OWGF6bFhZbFJXUkZwV1dtdFdNV1IwVW14d1YyRXpRalpXYWtreFVqRmtTRk5yYUZaaVJrcGhXVlJHZDAweGJIRlNiSEJzVW0xU01GVnRNVzlVYkZwWlVXcFdWMUpzY0doWlZFcEhWakZPV1ZwR2FHbFNhM0JvVjFaU1IyUXdNSGhYYkZwWVlsVmFjbFZzVWtkVGJHeFdWbFJHVldKRmNFZFdNbmh6VmpKR2NtSjZRbGRoYTFwb1ZUQmFTMlJXVW5OVmJXeG9UVmhDV0ZadE1IaE9SMUY1VW10a1ZtSkdjRmxaYTJSVFkxWlNXR1JIUmxSV2JrSkhWako0YTFaWFNrZGpSRUpoVTBoQ1NGWXdXbUZqTVdSMFlVWndhR0V4Y0hsWGExWmhVekZrV0ZKcmFHcFNhelZVVm10YVlWZEdXblJOVkVKWFRWZDRXVlZ0ZEd0V01rcHpVMjVPVm1Gck5WUlpNbmhYWkVkU1NWcEZOVk5pV0ZGNlZtcEplRTFIUmtkVGJGWlNZV3MxVjFSV1drdFRSbHB4VTJ0YWJGSnJOWGxaVlZwM1ZqRktWbGRVUWxkV00wSklXVlJHYTFkR1RuSmFSbFpwVmpKb2QxWlVRbGRUTVdSelYxaG9XR0pZVWxCVmFrWkhUa1prY2xkdGRGaFNNSEI2VlRJMVQxWnRSbkpUYldoYVRWWndlbGt5ZUhkU1ZsSnlUbGRzVTJKSE9UTldNbmhYWVRGSmVWSnNaRlJpYXpWeFZUQmtORlpzYkhKWGEzUlVVbXh3TUZsNlRtOWhNVmwzVjJ0b1YxWXphRE5XYWtaYVpVWk9jbUpHWkZObGExVjNWakZhYTFSdFZsZFVia3BoVWpKb1ZGbHNXa3RWUmxwSFdUTm9hVTFXY0hwV01qVlBWMnN3ZVZWdVRsWmlXR2hvVkZWYVlXUkhVa2hrUjJocFVsaENXbFpzWTNoaU1WcDBVMnhXVTJKc2NHRlVWVnAzWld4WmVGcEZPVk5OV0VKSVdWVmFhMkZXV25KalJuQlhUVlp3V0ZscVNrWmxSbHBaV2tVMVYySlhhRmhYVnpBeFVURmtSMVZzYUU5V2F6VnlXV3RrTkdWV1dYbGtSRUpWVFd0d1Yxa3dWbk5XVlRGWFkwaEtXbFpYVWtkYVJFcEtaVzFPUjFwR1pFNU5SWEJLVmpGU1NtVkdWblJXYTJScVVsZDRWVmxyV21GalJsWnhVbXQwVmxKc2NEQlVWVkpIVldzeFZrNVZhRmROYm1oWVZtdGFZVkpzWkhOV2JGWlhZbFpLVlZaR1ZtRldNbEpHVGxaYWExSnRhRlJVVldoRFYyeGtWMVp0Um1sTlYxSjZWakZvZDFadFNsaGhSbWhWVmxad00xcFhlRk5rUjFaR1pFZDBWMkpyU2tsV2JHUTBWREpHUmsxSVpGUldSWEJZV1d4b1UyTldjRlphUlhCc1ZtczFlVmxWV2xOaFJURnpVMjVvVjFZelFreFpha1pyVWpKS1NWUnRhRk5sYlhoNFZtMHdNVkV4V1hoWGJrNVdZVEpTV0ZWdGRIZGxiRmw1WlVoa1dGSXdWalJXYkdodlZqSkdjbGR0Um1GV1ZuQlFXWHBLUjFJeVJrZGFSM2hvVFZkME5WWnRkR0ZaVm14WVVsaG9XRmRIZUZWWlZFbzBWbXhzYzFwSE9WZFNiWGhhV1RCYWExZEhTa2RqUkVKVlZteEtWRll5ZUdGV1ZrcHlZVVp3VGxKc2NHOVhWbFpoVXpGYVdGTnJaRmhpU0VKWlZUQldTMU5XV25GU2JVWnJUVlZ3ZWxadE5VdFZSbHAwVldzNVdsWkZOVVJXYWtaaFpFVXhWVlZzU2s1V2JYY3hWbGN3TVZNeFZYbFNiazVVWWtkb1lWWnFUbE5OTVZwR1YyeE9hMUl4V2tkVU1XUjNWR3haZUZOcVdsZE5ibEp5V1hwR1ZtVkdjRVpYYkZKb1RURktXVmRYZUZOUk1EVkhZMFZXVTJFeVVuSlZiWGgzWlZac1ZsZHRSbWhXYTJ3MVdWVmFWMWRHV25OVGEzaGFZV3R3UzFwVldtRmtWbFowWlVaU1UwMVZjRFJXYkdONFRrZE5kMDFJYUdGVFJYQmhXbGQ0WVdOR1ZuUmxTR1JPVW14d1dWcFZaRWRXTWtwV1kwWmFWbUpZVW5aV2FrcExWMVpTY1ZWc2NFNWlhelF3Vm0xNFlWbFhUWGhqUldSVllYcFdUMVpzWXpWT1ZscHhVbTFHVjAxWGVGaFdSelZUVmpKS1NHRkdVbHBXUlZvelZsWmFZV1JGTVZkVWJGWk9WbXh2ZDFkc1ZtOWhNVnBYVjI1T2FsSlhhRmxaVkVaTFZrWlplV1ZHY0d4U2F6VjVWMnRhVjFZeVNrbFJhbHBYVFZad2FGVjZTazlrUmxKeVYyeENWMkpXU25kV2JYUmhXVlpLUjFwSVNsWmhNbEpoVm1wR1MxSXhVbGRYYkdSV1lsVndXVmxWVlRWV01rWnlWMnQ0VmsxdWFHaFdiRnBQWTFaR2RHSkZOVmRpYTBZelZteFNTMDFIU1hsU2EyUlVWMGRTV1Zsc1ZtRlpWbXhWVTJ4T2EySklRa2xhVldSSFZUSktTRlZxUmxkU2VrWXpWbXBLUm1Wc1JuRlhiR1JPWW14S2VWZHJVa2RWTWsxNFdraFdWV0pZUWxSVmJUVkRWMVphUjFsNlJsWk5helY2V1d0U1lWVXlTa1pPV0VaVlZtMW9SRlZxUmxwbFYxWkhWRzFvVjJGNlZraFdWRW8wWkRGa1IxZFljRlppVjJoWlZtMHhVMU5HVm5GVGEzUlRUVlp3ZWxaSE1YTlZNVnBIVjJwU1YwMVdjSFphUkVaS1pVWndSbHBIUmxSU1dFSnZWbFJDYTFVeFdYaFZiR1JYWW0xU1dGUldaREJOTVZsNVRWUkNWMDFFUm5sWk1GcDNWMnhhV0dGRmVGZE5ha1pJV1RJeFQxSXhWbk5qUjNob1RWaENOVll4VWtwbFJrbDRWR3RvVjJFeVVsWlphMlJ2VmtaYWMyRkZTazVXYkhBd1drVmtSMWRzV25SbFJteFhWbTFvZWxacVNrWmxWbFp6WWtad2FFMXNTakpYV0hCSFZtMVJlR05GWkZWaVYzaFBWbTE0ZDA1c1duTmFSRUpvVFZkU1NWVXlkR3RYUjBwSVpVWmFXbUV5VW5aV1ZWcGhZMVpHV1dGSGNHbFdWRlpKVjFSQ1lXRXhXWGxXYmtwWVlXdHdXRmxYZEhaTlJtUlhWMnQwYWsxWVFrcFdSM2hMWVZaS2RWRnNRbGRXZWtGNFZWUktTbVZHY0VkV2JGSllVakpvVlZaR1dsZGpNRFZIVm01U1QxWlViR0ZXYlhSelRsWndWbGRzWkZkaVZYQklWakp3UzFsV1dYcGhSMmhhVFZad1RGcEZaRTlUUjFaSFZHeGtVMVp1UWt0V2JURXdXVmRKZVZKWWFGWlhSMmhvVld4YWQxVkdXblJOVkZKYVZtMTRlbGxWWXpWV1ZrcHpZMFZhVm1KVVJraFpWekZMVTBaV2RXSkhSbE5XYmtGNlZtMXdTMU14VGxkU2JrWldZa2RTV0ZscmFFTldWbHBZWTBWMFZFMVZOVWhXUnpWTFdWWkplV1ZHVWxaaVdHZ3pWbXBHYTFkSFVraFNiR2hwVm10Wk1GZFhkR0ZaVmxsNFdrVm9hRkp0YUdGWmExcFdaVVpWZVdWSVNtdE5WMUl3V2tWYVYyRldXbGxSV0dSWVZteGFhRlpxUmxwbFZrcDFVMjFzVTFKcmNGaFhWM2hUVWpGa1IxZFlaRmhoTTFKeFdXdGtVMlZzV1hsTldFNVdUVVJHVjFrd1drZFdNREZZVkdwT1lWWlhVa3RhVmxwaFl6RndTRkpzVG1sWFIyZzBWbXhrTkdFeFZYaGlSbVJZWW10YVZGbFVUbE5XVmxwMFpVaGtXRlp1UWtkWGExSkRWakF4VjJKRVRsZE5Wa3BNVm1wS1MxWldSbFZTYkdScFVtNUNiMWRyVm10U01VcHpWVzVPVjJKSFVuQlZNRlpMWkd4WmVGVnJkRTlTTUZZMVZsZDBhMVpIU25KT1dFWldZbFJHVkZaRVJsZGpiRnB6VjIxMFRsWnVRWGRXUmxadllURlNjMWR1VGxkaGJFcFlXV3RrYjJSc1pGZFhhM1JZVWpCYVNWUXhXbUZVYkVwelkwYzVWMkpZUWtoWmVrcE9aVVphZFZOdFJsTk5NVXAzVmxjd2VFMHlWbk5YYmtaVVZrVmFWbFJXWkZOVFJsVjRZVWQwVlUxVmNFZFpNRnByVjIxS1IxTnJaR0ZTUlZwNlZtcEdhMk50VWtoalIyeFhWa1phU2xacVNqQlpWMFY0VjFoc1YySnJjRlZXYTFaTFYwWmFjVlJyVGxWU2JGcDRWVEp6TVdKR1NuVlJhM0JYWWxob1ZGbFdXa3BsVjBaSldrWmtWMUpWY0ZsV1dIQkxVakZKZUZwSVZsWmlXR2hVVkZWYWQyVldXa2RYYlVaYVZtczFTRll4YUhOaE1VbzJZa2hDVm1KWVVqTlVWbHBYVjBVMVZrOVdaR2xXV0VKaFZtdGFiMkl4YkZkWFdIQm9VMFZ3WVZSWE5XOWpiSEJHV2taT1UwMVlRa2RVYkdSelZUSktjbEpZYUZkaVZFSTBWR3RrU21WV1NsbGhSMFpUVmpGS1dsZFhNWHBOVmxwWFlrWldWV0pVYkZoVVZtUTBWMVp3UmxwRlpGZFdhM0F3V2tWU1YxZHRWbkpPV0ZwWFlXdEdORll4V2tkamJVcEhZMGRvVGxkRlNsSldNVnBYVm0xUmVWVllhRlZpYTFwVldXdGtVMVF4V25ST1ZVNVhWbXh3ZVZaWGRHdFZNa3BYVjJ0b1drMUdXbnBXYkdSTFUwZEdTVkZzY0doTlZtOTZWMnhXWVZsV1pFaFdhMlJWWWxoQ1QxWnRlRnBOUmxweldrUlNhRTFYVWtsVmJHaDNWbTFLUjFkc1pGcGlSMmgyVkZSR1UxWnNaSE5VYlhCT1ZtNUJkMWRyVm1GaE1WSnpWMnhvYTAwelFsaFpWM1JoVmtaV05sSnNjR3hXYXpWNlZtMTRhMkZXU2xaalJteFlWak5vVkZWcVJsTlNNV1JaWVVkR1UxWXhTbFZYVjNoaFdWWk9SMWR1VW14U00xSnZWbTF6TVZJeFZYbE9WMFpYVFd0d1NGVXlkRk5XTWtwVlVteG9WbUZyV2pOVmJYaHJZekZHYzFwSGJGZGhNMEpvVm1wR1lXSXlVWGhYV0doWVlUSlNXRmx0Y3pGWFZteDBZM3BHVlUxV1NsaFdNalZQVkRGS2MySkVWbUZXVjFGM1ZqQmtTMUl5VGtWUmJVWlhWbTVDTWxadGNFSmxSbVJJVW10c1dHSkhVazlWYlRWRFpWWmFWVkp0UmxOTmJFcEhWREZhYTFkSFNsaGxSbWhXWWtad01scFdXbHBsUm1SeldrWndWMkpIZHpGV2EyTXhWREZrU0ZOdVRsUmlSa3BoV1d0a2IxSkdhM2RYYkdSclVqRmFTbGRyVlRWVk1rcEpVV3h3VjFKc1dsUlZha3BIVW1zeFYxcEdaR2hoZWxaWFZtMHdlR0l4VWtkWFdHUmhVbFp3YzFacVJtRlRWbXhXVjIxMGFGWnJjREZWVm1oM1ZqSktSMWR0YUZwbGExcG9XWHBLVDFKc2NFaFNiRTVPVFVWd1VWWnRNWGRTTVUxM1RsaE9XR0pyV2xWWlYzaExZakZTV0dSSFJsTk5Wa3BZVmpJMVQxWnRTbFpqUkVKaFZsWndkbFp0TVVkamF6VlhWV3h3VjFadVFtOVdWRUpXWlVaWmVHTkZaR0ZTVkZaWVZGWldjMDVHV25STlNHaFBVbXhzTlZWdGVHdFdSbVJJWlVjNVZtSlVWa1JXTUZwaFkxWlNjbFJzV2xOaVdHZzBWbGN4TkdFeFdYZE5WbWhXWVd0YVdGWnVjRVpOUmxwVlUyeGthMUl4V2toWlZWcHJWVEpLU1ZGdWJGZGlSa3BJV1ZSR1NtVkdjRWxXYkZwb1pXMTRXVlp0Y0VkVE1XUkhXa1pvYkZKdFVuSlVWVkpIVTBaWmVXVkhPV2xTYTI4eVdXdGFiMVl5U2xsaFJFNWhWak5vZVZwRVNrZFRWbkJIV2taa1RsTkZTa3BXTVZKRFdWWlZlRnBJVWxkaWEzQlpXV3hrYjJGR1ZuTmFSazVYVW14YWVGVnROV3RWTWtZMlZteG9XR0V5VW5wWlZWVjRVMGRTUlZac1pHbFhSVXBKVjFaU1FtVkdTWGhYYkd4b1VqSjRWRmxzV2t0WGJGcHhVVzEwYVUxWFVsaFphMXB2WWtaT1NGVnNhRlppVkVVd1ZGVmFkMVp0Umtoa1JtaFRZVE5CZDFkc1ZtOWtNVmw0VjFod1ZtSnJjRmhaVkVaM1ZFWndSbHBHVGxOV2JIQXdWVzE0YTFZd01WWlhXSEJYVFZad1ZGVnFSazlrUmxaWllVZEdWRkpZUW5aV1Z6QjRWVEZSZUdKSVVtcE5NbWhRVlcxNGQyVnNXbGhrUlhScFVtdHdlbGt3VWtOV01VbDZWVzVLV2xZemFFeGFSVnBYWkZaR2MxZHRhR2hOV0VKTlZqSjRhMDVHYkZkYVJXaFZZVEZ3YUZWdE1WTmpSbHAwWlVoa1dGWnNjSHBYYTFKVFlXc3hjbGRyYUZaTmFsWlVXVlZhVDFKc1RuUlNiSEJYVWxad2IxWkdVa2RrTVVwWFUyNVNVMkpIYUZSV2ExWmhXVlprVlZGc1drNVdiR3d6VkZaV1YxWXlSWGxsUm14WFlXczFWRmxWV21GalZrcHpXa2QwVTJGNlZqVlhWM1JoVXpKR1NGWnVVbXhTYldoWlZtcE9iMlJzYkhGUldHUnNVbXhhZWxZeWVHOWhWMHBYVTJ4c1dGWXpVblpWVkVaS1pVWndTVk5zYUdsV1IzaDJWbTB4TUdRd01VZGpSVlpWWW0xU1dWVnRlSE5PYkZwWVpVWk9WMDFyV25sV01qRnZXVlpLVjJOR1FscE5ha1pJVlRCa1IxSXhWbk5VYld4b1RVaENhRlp0TVRCWlZsbDRZa1pvVmxkSGVGWlpiWE14VjBaWmQxcEdUbWhTYkZwNlYydGFUMVl4U25OVGJHaFhUV3BXY2xsclpFdFRSMUpGVkd4b2FFMXRhRkZXYWtKaFV6Sk9kRlJyWkZoaVJuQndWVzEwZDFKV1duUmpSVXBzVW14c05GWkhOVXRoUmtwMFlVWm9XbUV5YUVSWlZWcHJZekZrZEZKc1pFNWhlbFYzVmxjeE1HRXhiRmRUV0d4b1VsUnNXRlJWV21GVVJsSnpWMjFHYWsxWGREWlhhMlEwVlRKS1IxZFVRbGRpUm5CMldXcEdhMU5HVG5WVWJGSnBVbFZ3V1ZkWGRHRldiVlpIVjJ4YVdHSlZXbkpWYWtaaFUyeGtjbFpVUmxaTmEzQkhXVEJhYjFkR1duTlhia1pWWWtad2FGa3ljM2hXYkZwelZHMXNhVmRIYUZwV2ExcHFUVlpWZVZWdVRsaGliRXB4VkZSS2IyTldXblJsU0dSc1lrWndXVnBWYUd0V01ERldZMFpvV2sxR1ZqUldha1phWld4R2NtRkdjRmRTV0VKVlZsZHdSMVF5VWxkV2JrNVZZbGQ0VkZSV1ZuZFZWbHB5VjJ4a1ZrMVZjSGxVVmxaclYwWmtTR1ZJU2xaaGF6VlVWbFZhVjJSRk1WVlZiR2hYWWtoQ1NsZHNWbXROUmxweVRWaEthbEpYZUdoV2JHUk9UVlphZEUxVmRGZFdhM0F4VmpKNGEyRkZNVmxSYWxwWVZrVnZNRmxVU2xOV01YQkpWVzE0VTJGNlZuZFdiVEV3WkRGc1YxZFliR3RTYlZKdlZGWldjMDVHV1hoaFIzUlZZa2RTUjFrd1duTlhiVVY1Vlc1YVYyRnJXbFJXTUdSUFVqRndSMkZHVG1sVFJVcGhWbXRhWVZZd01VaFNXR2hVVjBkb1dWbFVTbTlaVmxwelYyNWtUazFYZUZkV2JHaHZWMFphY2xkdWJGVldiSEJ5V1ZWVmVGWXlUa2hQVm1ScFYwVktUVlpzVWtkVE1rNXlUVlprWVZJd1dsUlVWVnAzVmxaYVIxVnJUbFJOVmxwSVZqSTFVMkpHU2paaVJrNWFZa1p3YUZVd1dscGxWVFZXWkVab2FHVnJTVEZYVmxadlV6RmFWMWR1VG1wU2JXaFdXV3RhZDFZeGNGZGFSbVJVVWpGS1NGZHJXazlVYkU1R1UydHNWMkpHU2t4VWEyUktaVVp3U1ZWc1VtaE5iV2gyVmxkNFlWTXhXWGhWYkZwWVltMVNXVlZ0TVRCT1JsbDVaRWQwV0ZKc2NERlZWM1J6V1ZaYVYyTkdRbHBXYlZKSFdrUktUMUp0VGtkYVIyaG9UV3ByZWxacVJtRlpWMDE0V2tWa1ZHSnJjRmxaV0hCWFZsWldjVk50T1ZkaVIxSlpXa1ZrUjJFd01WaFZiR2hYVFdwV1NGWnNaRXRXVjBwSVQxWmFhVlpGV2xWV2FrSmhWMjFXVmsxV1ZsSmlSbkJQVld0V1lWZHNXbk5hU0dSVFRWWnNORll4YUhkV1ZscEdWMnhvV2xZelVqTldSVnBoWTFaS2NrOVhjRTVoTTBKSlZqSjBhMk14WkVkVGJGcHFVbFp3V0ZSWE5WTldSbFp4VW14S2JGSnRVbHBaYTFwVFlVVXhjMU5zY0ZoV00xSnlXV3BLVDFJeVNrZGlSM0JUWWxaS1dsWnRNSGhWTVdSWFkwWmFXR0pZVWxsWmExcHpUa1paZVdWSE9WZE5SRVpaV1ZWb2QxZHNXa1pYYTNoV1lXdGFVRmw2U2tkU01WcHpXa1prYUUwd1NrdFdiWFJoV1Zac1dGUllhRmhpYkVwVVdWUkdkMk5zVm5STlZrNVZUVlphZVZadE1VZFdSMHBIWTBod1dHRXhTbFJaVmxWNFZqSk9TV0pHVmxkaVJuQjVWbTF3UjFsV1NuTmFTRTVvVW01Q1dGUlVSa3RpTVdSVlUycFNhbUpXV2xsV1IzQmhWVEpLU0ZWck9WZE5SbHBNVlRKNGExZEhVa2hrUjJ4T1ZtdHdObFpyWkRCWlZscElVMnhXYVZKdGFHRlphMXBMVWtaU1ZWSnVaRk5XYXpWNlZUSXhORll5U2tkalIwWlhUVzVTVjFSV1dscGxWazV6V2taU2FWSnVRbGxYVm1Rd1V6Sk9jMkpJUmxOaVdGSlVWRmQwZDFOc1dsaE5WRkpXVFZkU1NGVXllSE5XTWtwVlVXcFNWV0V5VWxoV2FrWnJWMWRLUms5V1pFNU5WWEJoVm14amVFNUhVWGROVldScVVteHdiMVV3VlRGWFJsSldWV3RrYkZKc1dqQmFSV00xVmpBeFJWSnJhRnBOUmxrd1YxWmFTMWRHVm5OaFJscE9WakZLVVZaWGNFZGtNVWw0WTBWYVQxWlVWbGhXTUZaS1pWWmFkRTFJYUU1U01GWXpWR3hXYTFaV1pFaGxSbHBYVFVkUk1GWnRlSE5XVms1eFZXMXNUbFpzYjNkWGJGWnZZVEpHYzFOdVRtbFNSVFZaV1ZSS1RtVkdiSEphUlhSVVVteGFlbGxyWkVkVk1WbDRVMnRzVjJGcmJ6QlhWbVJPWlZaU2NscEhhRk5pU0VKUVYxWmtORmxXVmxkWFdHaFlZbFZhVlZSWGVFdFRWbFowWkVjNVZsSnNjSHBXTW5odlYyMUtTRlZ1V2xaaVJuQnlXWHBHYTJSR1NuTmpSbVJPVmxoQ1MxWnRkR3ROUm14WFYydG9WR0pIZUc5VmJYaExXVlpaZDJGRlRsaFNiR3cwVmpJeFIxZEdTbFZTYTFwV1lsaG9WRlpITVVabFIwNUdZa1prVjFKWGREUldiRkpMVWpGSmVGUnVWbFppVjJoVVdXeGFTMkZHWkZkVmEyUnJUV3RhU0ZaWGVGZFZNa3BXVjI1R1ZWWnRVbFJVVlZwWFpFZFdTRTlXV2s1U1JWcEhWbTB4TUdJeFdYZE5XRlpXWWxkb2FGVnJWbUZaVm5CRlVWaG9WMkpHY0hwV1IzaHJWVEZhV1ZGc2NGZGhNWEJ4VkZaYVZtVldWblZVYkdScFlURndWVmRYZUc5Vk1WcFhWbTVTYW1WclduTldiWGh6VGxaU1YyRkhkRmRoZWtaNVdUQmFjMWRzV2xkalNGcFhUVVp3WVZwWGVGZGtSMFpJVW14T1UxWldiRFpXTW5oWFdWZEZlRnBHYUZOaE1sSnZWV3BLTkZkV1ZuUmtTR1JZWWtad2VWWXlNVWRoVlRGV1ZtcFNWazFxVmxCV2FrcExVMGRHUms5V1pHaE5WbkJOVm0weE5HTXlUbk5hU0ZaaFVqTm9XRmxzYUZKbGJGcDBUVVJHVlUxV2JETlVWbWhMVjBkS2RHVkhSbGRoTVZWNFdrZDRZV05XU25Ka1JrNXBVakZKZUZaVVNqUlpWbEp6VTI1V1VtRjZSbGhaVjNSaFkyeGFSVkpyY0d4U2JrSktWbGN4YzFVeVJqWldiRUpZVmpOb2NsbHFSbk5XTVdSMVVteE9hVmRHU2xGV1YzQkRZekExUjFkdVRtaFRSVFZYVkZkMFYwNVdXbGhPVldSWFlsVndWbFZ0TldGWGJWWnlWMnhrWVZKRldtaGFSbHAzVTBkT1NHSkdUbWhOTUVwaFZtcEdZVll4V1hoVldHaFhWMGQ0VlZsVVNsTmpWbFowVFZSU1YySkdjREJVVmxVeFZHeGFjMk5FUWxwbGF6VjJWbXBCZUdOck5WWmFSbWhvVFZoQ2IxWnJaRFJYYlZaWFlqTndhbEp0VW5CV01GWkxVMVpaZUZkdFJsUk5iRXBJVmtjMVIxZEhTa1pqU0VKV1lsUldSRnBYZUd0V01WWnlXa2QwVG1FeGNFbFdNblJ2VXpGYWRGSllaR3BUUlRWWFdXeG9iMlZzVW5OWGJHUnJVakZLU1ZReFpHOVZNa1Y2VVdwV1YxSXphR2hXVkVaYVpWWktXV0ZIY0ZOTmJXaFpWa1phWVdReGJGZGpSbHBZWWxoU2NsVnFSa3RTTVZKelYyczVWV0pHY0ZoWlZFNXJWakpLVlZKVVFscGhhM0JMV2xaYVMyUldVbk5WYld4b1pXeGFORlpzWTNkbFJUVkhZa1prYVZKc1dsUlphMXAzWXpGV2RFMVVRazlTYkd3MVdsVlZOVll3TVVWU2JteFhUVzVTY2xacVJrcGxiVVpIVld4a1YxSllRazFXVkVaaFVqRmtWMk5GWkdGU2F6VndWVEJXU21WV1duUmtSazVVVFZWc05GVXhhRzlaVms1SFYyeFdXbUpIYUVSV2ExcHpaRWRTUm1SR2FGTmlTRUYzVjFSQ1ZrNVdWbkpOVm1oV1lUSm9XRlJYY0ZkVFJscHlXa1ZhYkdKR1ducFdiWGhoWVZaa1NHRkZNVmhpUmxwb1YxWmFhMUpyTVZkWGJVWlRZbFpLVUZaWGRGZFRiVlp6VjJ0b2ExSnJOVk5VVmxwelRsWlZlV1ZJVGxaaVZWWTFXVlZhYjFkc1dYcFZiV2hhVFc1b1lWcEVSbXRqYlZKSVkwZHNWRkpWY0VwV01WcFhZVEpOZUZkWVpFNVRSM2h2VlcxNGQxZEdVbGRhUlRsUFVteEtWMVl5Y3pGaVJrcDFVV3R3VjFJemFIWldNRnBLWlZkR1NHRkdaRk5pUlhCTlZteFNTMVJ0VmtkWGJsWldZbGhvVkZsc1drdFZWbHBZVFVob1ZrMXNXbGhXTWpWVFZHeGFSbE50T1ZaaVdHZ3pXbFphVTJNeFduUmtSbWhvWld0YVNWZFVRbTlrTVZsM1RWaEdVMkV6YUZoVVZscDNWa1paZUZwRlpGTk5XRUpJVjJ0YWEyRlhSWGRqUjBaWFlXdHZkMVpxUm1Ga1JscHlXa1pvV0ZJeWFGaFhWekUwVXpKTmVGWnVVazVXYXpWeFZXMTRWMDB4V25Sa1JFSllZa1p3ZWxsclVsZFpWa3BYWTBoS1YyRnJjRWhVYlhoaFl6SktSMWR0YkZoU2EzQTFWbTB4TUdFeFRYbFVia3BQVm0xNFZGbHJXbmRqUmxsM1drYzFiR0pHY0RCWk1GWnJZV3N4Y2sxVVZsWmlXRkoyVmxWYVdtVnNSblZSYkZwcFZrWmFSVlpIZEdGWlZscFhWRzVHVW1GNlZsUlpiRnBMVTFaYWNWTlVSbFJOVjFKSlZUSTFWMVZ0U2toVmJHaGFWak5OZUZwSGVISmxWMVpKVkd4a1RsWXhTalZYVkVKclRrWlZlVkpxV2xkaGJGcFlWVzE0ZDJGR2JGVlNiSEJyVFVSR1NsZHJXbE5oUlRGMVlVWndWMkpVUlRCVmVrWlRVakZrYzFac1RtbFRSVXA2VmxjeE5GbFZNVmRYYmxKc1VtMVNiMVp0ZUhkWFJtdDNWMnhrVjAxcmNGcFdWekZ2VjBaYWMyTkhhRmRoYTFweVdUSjRkMUl5UmtoaVJrNU9WbGhCTVZadGRHRlpWbXhYVkZoc1YySnJOVmxXTUdRMFZVWmFjMVZ1VGxwV2JIQXdXVE53UjFaR1duTmpSbXhoVmxad1VGWnFSbUZqTWtwRlYyeGtWMDB5YURKV2JYaHJVekZKZVZScmFHaFNiSEJ2V1ZST1ExTldXbFZSYkZwUFZteHNOVlZ0ZEd0V1YwWTJWbXhXVm1KR1dubGFWVnBoWkVkU1NHUkZPVk5OUmxreFZsUkdiMkl4WkVoVGJrNVVZa1phWVZaclZuZFdSbHB6VjI1T2FtSklRa2xVTVZwdlZUSktXV0ZHWkZkV2VrRjRXVlJHV21WR1RuVlViWEJVVWpKb1dGZFhlRk5TTVU1SFlrWldVMkpWV25KV2JYUmhaVlpzVmxkdE9XaFNWRVo2VlRKd1lWWXlTa2RUYTNoV1pXdHdVRmw2Ums5a1ZrcHpWbTFzVTAxVmNGRldNV04zWlVkSmVGcEdaRmhYUjJoWldXeG9VMVpHYkhOWGJVWlVVbTEwTTFadE5VOVdNVmwzWTBWc1dsWlhhRVJXTWpGR1pVWmtjVlJ0UmxkTk1taHZWbXBDVm1WR1RsaFNhMXBRVm1zMWNGWnRkSGRUYkZwMFRVaGtUbFpyYkRSV01uaHZWa2RLUjFkdVFsWk5SbHBvVjFaYWMxWldTblZhUlRWT1ZtNUJkMWRzVm1GWlYwcEhWMWhvVkdFeGNGZFdibkJIWkd4c1ZscEdaR3BpUjFKNldUQmFhMkZXU1hoVFdIQlhWbXhLU0ZsVVNrNWxSbkJKVkcxR1UwMHdTbFZXUm1ONFlqSkdSMWR1VWs1V1JrcHlWRmR6TVdWc1duTmhSM1JhVm10d1dWWlhlRk5YYkdSSlVXdG9WMDFHY0hKWk1uaDNVMFU1V0dGR1RsZFNWbkJNVm14YWFrMVdiRmRYV0dST1ZtMW9iMVZyVlRGV01YQllaRWRHVmsxWVFsaFdNbmhQVjBaWmQxZHJiRnBOUm5CUVZtcEJkMlZYUmtkaFJtUk9WakZGZDFkWGNFZFNiVlpIV2toS1lWSnRhSEJaVkU1RFYyeGtXR1ZHWkZwV2JWSllWakkxVTFSc1duSk9WbXhYWWxSV1JGWnFSbXRqYkZwMFpFWmtUbFpZUWxkV1Z6RXdXVlpaZVZOc2JHaFRSbkJZV1ZkMFIwNUdhM2hYYlVacVRWWmFlbGRyV2s5VWF6RjBZVVpLVjJKR1NrUlpWRVpLWlVaU2MxcEdWbWxoZWxaWlYxZDBhMVV5VGtkV1dHUlhZVE5TVlZsclduZGxWbVJ5Vld0T1dHSkdjREJXVjNCRFZqSktXV0ZIYUZkU1JWcG9XWHBLVDFJeFNuTmFSMmhvVFRCSmVWWnRjRU5aVjAxNFYyeGtWbUpyY0ZaWmExcExWMFpzY21GRlRrOVNiSEJXVlRJMWExWnJNWEpYYTJSVlZteHdjbGxYZUV0a1IwWkhZVVpXVjJWc1drVlhWbFpoV1ZkT1YxUnVTbXRTTTBKUFdWaHdWMU5zV2xoTlZGSm9UV3RhV0ZVeU5WZFZiR1JKVVd4c1dtRXlVbE5VVlZwYVpWVXhWMU50ZUZOTlJGWklWakowYTFJeFZYbFNhbHBYWW0xU1dGbHNVa1prTVhCRlVtczVWMDFZUWtoWGExcHJZVlphVjJOR1pGZFNiSEJvVlhwS1YyTXhaRmxpUlRsWFlsWktXRmRYZUZkV01EVnpWMnhvYkZKNmJGaFdiWGgzWld4cmQxVnJPVmROUkVaSVdUQm9TMVl5Um5KWGFrNVdZbGhvY2xwRlpGZFNNWEJJWVVVMVRsSlhkRFZXYlRGM1V6QXhSMkpHWkZkWFIyaG9WV3hrVTFaV1dYZGFSRkpwVFZaYU1GcFZhR3RYUmxwelkwaG9WMUl6YUZCWlZWcExaRVpXYzJGR1pFNWhhMVl6Vm0xd1FtVkhUblJVYTFwb1VtMVNjRll3Wkc5V1ZtUlhWMjFHVkUxWFVsaFZiVFZQVlcxS1NGVnNhR0ZXTTFKTFZGVmFZV014Vm5KYVIyaE9WbGQzTUZkVVFsZGpNVnBJVTJ0b1ZtSkhhRmRaYkdodlRURlplRmR0UmxOTlZuQjZWa2Q0VDFSc1dYaFRhMnhYWWxob2RsbDZTa2RqTVU1ellVWmFhVkl5YUdoV2FrSnZVVEZPUjJOR1dsaGlSMUp4VkZkMFlWTldjRVpYYlhSVllrWndNVlZYZEc5WFJscEdVMnhvVldFeGNHaGFSVnBQWXpGYWMxUnRiRk5XV0VKWlZqRmFhMDFHYkZoU2EyUnBVa1p3VlZsVVNsTldSbEpYWVVWT1UwMVdTbnBXYkZKSFZqQXhXRlZyWkZaTlYyaDZWbXBLUzFkV1JuSmxSbFpYVm01Q1dGZHNWbUZUTWxKWFZHNUtUMVp0VW5CV2JYUjNXVlphZEdORlRtaE5hMncxVlcxMGExWXhaRWhWYkdoYVlsUkdWRll4V2xka1JURlZWVzE0VjJKSVFqWldiR1F3WVRKR1NGTnJXbXBUU0VKaFZGVmtiMDB4V25GUldHaHFWbXh3TVZVeWVHdFViRXAxVVcwNVdGZElRa3hXUkVaTFpFWktjbHBIUmxOV1JscDJWMVpTUjJReFRuTlhXR2hZWWxoU2MxbHNXbUZUUmxWNVpVZDBXRkl3Y0hsVWJHTTFWbTFLVlZKc1VscE5SbkJZV1RGYVQyUkZPVlpQVjJ4VFRWVndXbFp0ZUd0TlIwVjRWMnhhVGxac2NIRlZNR1EwVm14c2NsZHVaR3BpUjFKWVZqSjBNR0V4V25KWGFrWldWak5vYUZsV1dtdFRSbTk2WTBab1YwMHdTa2xYVmxKTFZHMVdTRlJyV2xkaVJuQndWakJXUzJReFduUk5WRUpZWVhwR1NGWXhhSE5oTVVvMllrWmtWVlpzY0doVk1GcGFaVlUxVjFSdGFGTmhlbFpJVmxSS05HSXhaSFJTV0d4V1lteHdWMWxVUm5kV01YQlhXa1prVkZJeFNraFhhMVV4VmpKS2NsTlVTbGRoYTI5M1YxWmFjMVl4Vm5WVWJHaHBZa1p3VkZkV1pEUlpWbVJIVm01U2JGTkhVbGxWYlRFMFZteFZlV1JIZEdoaGVrWllWVEkxYzFZd01YRlNhazVYVmtWd1RGWXdaRWRUUjBaSFdrZHNXRkpWY0ZKV2JYaFRVekZKZUZOWWJGTlhTRUp3VldwT2IxWldWbkZTYTNSWFZtMVNXVnBGWXpWVmF6RldUbFZvVjAxdVVuWlphMXBMVmxkS1IxZHNjR2xTYkhCWlZrZDBZV050VVhoWGJsWlZZa2RTVDFsVVJscE5WbHB5V2toa1ZrMVhVakJWYlRWTFYwZEtSMU50UmxWV2VsWlFWR3RhWVdSSFZraGtSM1JUVFVad1NGWkhlRlpOVjBaWFYxaHNhRkl3V2xoWlYzUmhZMnhTY2xwRmNHeFNhM0JhV1ZWYVlXRkZNWE5UYkdoWVZqTlNhRnBFU2tkU01WcDFWR3hvYVdKV1NuaFdSbHBoWkRBeFIyRXpjR3BTVjFKWlZXcENkMU5XY0ZaWGJYUlhUVVJHZUZWc2FHdFdNREZIWTBWNFdrMXFSa3hWYkZwcll6Sk9SMXBHWkdsaE1IQmhWbTB4ZDFFeGJGZGlSbWhXWVRKU1dGbHJXbUZWTVd4elZtMUdWMUpzV25wV01qVnJZa1phYzJOR2JGcE5SbGwzVm10VmVGWnJOVmRoUm1ScFZrWmFUVlpyVWtkWlYxSkhWbTVTVUZZd1dsaFVWRXB2WWpGWmVGZHRSbHBXTURFMFdWUk9kMkZHU2xWaVJsSlZWbXhhWVZwWGVHRlNNV1IwVW0xb1RtRXhjRWhXUmxadll6RmFkRk5yYUdoU01GcFlXVlJHVm1WR1duSlhia3ByVFZkU2VsZHJaREJWTURGV1kwVjBWMDF1VW5KVWEyUkhWakZPZFZWdGRHeGhNWEJhVjFkMFlWbFhVbk5YYTFaVFlsaFNWVlZ0Y3pGbGJHUnlWMjA1YUZZd2NGcFpWVnByVjBaWmVsVnVTbHBoYTNCSVZXcEdhMlJXU25OVmJXaE9Za1Z3TkZZeFpEQldNbEY1Vm10a1dHSkhhSE5WYWs1VFZteHNjbFp1WkU1V2JGcFpXbFZvVDFkR1NuUlZhM0JXVmpOUk1GWnFSa3RTYkdSeVpFZEdWMkpJUWxWWFZFbzBaREZPUjFOdVRsVmlWM2hZV1ZST1FtVnNXbkZTYlVaV1RWVldOVlpHYUd0VU1WcDBWV3hzV21KWVVtaFdhMXB6WXpGYWRGSnNjRmRpU0VGM1ZrWmFVMVV4WkVkVGJrNXFVbGQ0VmxsclduZFZSbHB4VVZob2FtSkdjSGhXYlhoclZqQXdlV0ZIT1ZkaGEydzBWWHBHYTFkR1NuSlhiWGhUWW10S2RsZFdVa2RrTVdSWFdraEtWMkpHY0hOVmJYaHpUa1phV0U1V1RtaGlSWEI1Vkd4b1ExWnRSbkpPV0VwVllsaG9hRnBGVlhoVFYwWkdUbFpPVjFKV2NFcFdiVEUwWWpKSmVGcEZhRlJpYTNCUVZqQldZVll4YkZWU2JVWlZVbTFTV0ZZeWVFOVdNa3BJVldwQ1ZtSllhRmhXVkVwTFUxWkdjbU5HYUdsU2JIQjVWbGR3UzFJeVVrZFViazVZWWxoQ1ZGWnROVU5YVmxwMFkwVTVhVTFzU25wWmExcGhWakZrU0dGSVNsWmhhMHBvVlRCYVYyUkhWa2hQVm1ST1lUTkNTVmRVUW1wT1ZsbDRXa1ZzVW1FeWFGbFdiWGgzWTJ4V2NWSnNUbXRXYXpVd1ZXMTRUMVJ0U2xoaFJscFhUVmRPTkZSVldrNWxSbkJKVkd4b2FWSnNjRlJYVjNSclZURmFWMVZzWkdGU2F6VlpWVzE0YzA1V1VuTldiWFJYWWxWd1Yxa3dXbXRXTURGeFVtdG9WMkZyY0V4V01WcFhaRmRPUjFadGFFNVhSVWt4VmpKMFUxSXhiRmhVV0docVVsZFNXVmxzWkRSWFJsbDNWbXQwYUZKc2NEQmFWV1F3WWtkR05sWnNhRmhoTW1oVVZsUkdhMU5IUmtsU2JGcG9UVlpXTkZacVFtRlZNVmw0V2toV1lWSXlhRlJaYkdocVpWWmFXRTFFUmxWTlZrWTFWVEowWVdGc1RrbFJiR2hhWWtkb1QxcFZXbUZqVmtaWllVWmthVlpVVmtoWGExWmhZVEpHVjFOdVNtcFNXR2hZVlcxNGQyRkdXa2hOVm1SVFRWWndlbGxyWkc5Vk1rcFlZVWhrV0ZZelVsaGFSRXBYWXpGa2MyRkhjRk5XVkZab1ZtMHdlRTVHWkVkaVNFcFlZa2RTVjFSWGRIZE5SbHBZVFVSV1YySlZjRnBaVldoM1ZsWmFSbGR0Um1GV2JWSllWVzF6TlZkSFJraGlSbVJZVWxWd1RGWnRNVFJoTWxGNFUxaG9XR0pyY0U5V01GWmhWa1paZDFwR1RsaFNiRnA0Vmtjd05XRnRTa2RYYWtKaFZsWlZNVmxYTVV0V2F6VldZVVpvYUUxWVFsRldiRkpIV1ZkU1YxSnVWbGhpUjFKUFZtMDFRMVpXV2xoalJXUlhZbFphV0ZaWGVITmhSa3B6VjI1Q1dsWkZOVVJXTW5oclYwZFNTR1JIYkU1aE1uY3dWbXhrTkdJeFVYaFhhbHBwVW0xNFlWbFVSbmROTVZKV1YyNWtVMkpIVWpCYVJWcHJWVEZhUmxkcVdsZFdSV3Q0V2tSR2EyTnJNVlphUm1ocFVqSm9XVlp0ZEZka01WSkhWbGhvV0dFeVVuSldiWGhMWld4a2NscElUbGhTYTNCV1ZXeFNRMVl3TVhWaFIyaFlWbTFTUjFwV1dsTmtWbEowWTBaT1YwMHlhSFpXYkdONFRrZFJlRlZZYUdsU2JGcFVXV3RvUTJNeGJISmFSazVYWWtaYVdWUldVa05oUmxwVlVteHNWMVl6VW5wV2JYTjRaRlpXZFZkc1pHbFhSMmg1VmxSQ1lWWXlUWGxUYTJSaFVqSjRXVlZxU210T2JGcDBZMFZPV2xac2JEVldSM2hyVmxkS2NtTkdiRnBpUjJoMldUQmFZV015UmtaVWJGSnBVakZLVjFaV1kzaE5SbEY0VTFoa1dHRXlVbFpXYlhoM1pXeGFXRTFWZEZSV2ExcDZXVlZhZDFZeFNsZGlNM0JZVm14YWFGbFVSbHBsUm5CSlUyczVWMDB4U2xCV1YzUlhXVlprUjFkWWJHdFNNMUp4VkZaYWQxTkdWWGxsU0U1V1lsVndTbFZYZUhOV01rWnlUbGhhWVZJemFHaFdiRnBQWTIxT1NHVkdUbWxUUlVZMFZtMTBhMDVHYkZoU2ExcE9WbFphV0ZsclZrdFhSbFowWlVoa2FGSnNjSGhWVmxKSFZqQXhWMWR1Y0ZoaE1YQXpXV3RrUzFJeVRrZGlSbVJUWWtad1ZWWlhjRXRXTVZsNVVsaHdZVkp0YUhCV2JGcDNWMVprV0dSSFJtcE5SRlo2Vm0xNGIySkdTbkpPVm14V1lsaG9NMXBYZUhKa01WcHhWV3hrYVZaWVFtRlhWbFp2VXpGa2NrMVlWbFZXUlZwWVZGVmFkMVJHYkRaU2JFNXFUVlpLZWxkcldtdGhWbVJIVW1wYVYySlVRak5hUkVwU1pWWmFjbGRyT1ZkV01taFZWbXBDYTA1R1duTmlTRkpyVTBkU1YxVnRlSGROUmxKWFYyczVhRkpyY0hwV01uQkRWbFphYzJOR1FsZGlSbFkwVmpCa1YxTlhUa2RoUjJoT1lYcENORlp0TVhkUmJWWkhWMWhzVldFeWVHOVZiWGgzWTBaYWNsWnNjR3hpUjFKWldrVmtSMVpGTVZkalJtaFdUV3BXVEZsV1drdGtSbFp6WVVad2FWSXhTakpXUm1RMFdWZFNSazFXVmxaaVYyaFBWbXhTVjFOc1dsaE5WRUpvVFd0YVdGVXlOVmRWYlVweVUyeG9WVlpYVWxSYVIzaGhVakZrZEZKdGNHbFNiSEExVmpKMFlXUXhXWGROVmxwcVVsaENXRmxVU2xOTk1XUlhWMnhhYkZack5YbFpWV1J2VlRKS1JtTkhhRmhXYkVwTVdXcEdSbVZIVGtaV2JFNXBWbFp3VlZaR1dtdFZNbFp6VjJ0b2JGSXdXbFpaYTFwelRrWlZlV1JJVGxkTmExcDVXVlJPYjFZeVJuSlhiR2hoVWxad1RGWXhaRXRTTVdSMFlrWk9UazF0YUhaV2JUQjRUVVpaZUdKR2FGTmhNbEp2VkZSS05HTXhWblJPVlU1cVlrWktXRmRyV2s5aVJscDFVV3RrV0dFeWFISlpWVnBoWXpKT1IxZHNaR2xYUmtZelZtcENZVmxXU25OVWJsSm9VbTVDV0ZWc1duZFdWbVJ5Vm0xR1ZVMXNTbGhXUnpWUFZtMUtXR0ZGT1ZwaVZFWjJWako0V21WR1pIUmtSVFZUVFZWWmVsWkhlRzlVTWtaelUyNU9hbEp0ZUdGV2ExVXhVa1pzTmxKc1pHdFNWRlpYVmtkNFUyRldTblZSV0dSWVlrWmFhRlpFU2tkU01XUjFVMnM1VjFZeFNsaFdSbU14WWpKV2MxZHVSbE5pU0VKeldXeFdZVk5zV1hsbFIwWlhUVlZ3V0Zrd1dsZFdNa3BaVVd0b1dsWkZjRTlhVmxwTFkyMUdTR05HVG1obGJGcGhWbXhqZUUxSFVYaGFSV1JZWW10d1dWbHNWbUZYUmxKWVl6Tm9UazFXU25wV2JURXdWMnhhY2s1VlpGcE5SMDB4Vm0weFMxSXhUblZqUm1ST1ZtNUNXVmRVUm1GU01rMTVWR3RhVDFZeWVGUlpiWFJIVFRGYWNscEVVbGROVmtZMFYydFdiMVpIU2tkalJtaGFWak5vVEZZd1dsTlhSMDVHV2taU1UySldTbGxXYWtvMFpESktTRk5zV2xoaE1uaGhWbXhrVTFOR1dsVlNiSEJzVW1zMWVsbHJXbXRXTURCM1UydHNWMkpHU2t4V1J6RlhVakZXZFZac1dtbFdNMmhWVjFkNFlWTXlVWGhYYkZaU1lrZFNWVlJXV2t0VFJsbDVUbFpPVldKR2NFZFZNakExVjJ4a1NWRnJhRmROUm5Cb1ZXcEtSMU5GT1ZkYVIyeFRUVlZ3UzFZeFdsZFpWMDE0V2toU1ZHSkhlRlpXTUdSdldWWlNWMWR1WkZoU2JrSklWMnRWTlZaR1duTlRibkJZWVRGVmVGWnFRWGRsVm5BMlUyeGthVmRIYUhsV1IzUnJVbTFXUjFkc2JHaFNiRXB3V1d0V2QyVnNXbFZSYlhScFRWWnNORmxyYUU5aFJrbzJZa1prVm1KWWFETmFWVnBYVmpKR1NFOVhhR2xXV0VKS1ZteGpNV014WkVoU1dHaHFVMFZ3V0ZaclZrZE5NWEJGVVZob1YxWnNXbnBaVlZwcllWWk9SbE51V2xkaVIyZ3pWWHBHVm1WR1pGbGhSbEpwWVhwV2QxWlhjRU5aVmxwSFlraE9ZVko2YkZsV2JYaDNWMVp3VmxkdGRHaE5SRVpaVmxkNGIxWXdNWFZoU0hCYVZqTm9URll4V2xkak1WWnpZMGRzVTJKclNrcFdhMXBUVWpGVmVGZFlhR0ZUUmxwV1dXdGtVMWRHVWxaaFJVNVVZa2RTV0ZadE1YZFVNVnB6WTBab1YwMXVRbWhXVkVwTFl6Sk9SMkZHVmxkaVNFRjZWMVpXWVZkdFVYaFhiRlpUWWtkb1dGbHRkRXRUVmxsNVpFWmFUbFpzYkRWVk1qVkxWa2RGZWxGc2FGcGlSMmhFVmtWYVUyTnNaSFZVYkdST1YwVktTRmRXVm1GVk1rWlhVMjVXVW1KSVFsbFdibkJHWkRGd1JWSnNjR3hTTUhCS1ZrY3hiMVV5Vm5SbFNGcFhWbnBGTUZWNlJscGxSbVJaWWtkNFUxZEdTbmRXVnpFd1pEQXhSMWRzYUdwU1YxSlpWV3BDVjA1R2EzZGhSWFJYVFZWc05sbFZaRzlXTURGWFkwVm9XbVZyV2pOVmFrWjNVMGRLUjFwR1RsZGlSM2N5Vm0wd2VFNUdWWGhUV0doaFUwWktXRmxVU2xOV2JHeDBaVWRHVjAxWGVIbFdNalZyVjBaS2MxZHVjRmRpVkZaeVdWVmFTMk15VGtWUmJVWlRWbTVDZVZkV1VrSmxSbGw0VTI1R1ZtSklRazlWYlRWRFlqRmFjVkZ0ZEZSTlYxSllWbTAxVjFaSFNraFZia0pYVFVkU2RsbHFSbXRqTVhCRlZXeHdWMkY2VmtoV1JscGhZekZhV0ZOclpHcFNWR3hoVm10V1lWbFdVbGhsUjBaWFRWaENTbGRyV2xkVWJGcDBaSHBHVjFaRmJ6Qldha1pYWkVaS2RWUnNVbWxTYmtKb1ZtMTBWMlF4V2tkWGJGWlRZbTFTV0ZsclpGTmxiRnBJVFZoa1ZXSkhVa2RWTW5SM1ZqRmFObEpVUWxkU1JYQklWbXBHVDJSV1duTlRiV3hUWWtoQ1dsWnJXbUZoTVZaMFZWaG9hVkpzV2xSWmExcDNZekZhZEdWRmRHeGlSMUo1VmpJeFIyRkdXbkppUkZKV1RXNW9NMVl3V21GT2JFWnhWV3hrVjFKV2NHOVdiWEJIWVRKU1YxWnVVbXhTYXpWd1ZtMTBkMVZzV25STlNHUk9WbXRXTkZZeGFHOVpWa3AwWlVoR1ZtSlVSbFJaYWtaWFpFZFNTVnBIZUZkaVdGRjZWMVpXYjFReFpFaFNhbHBUWVRKNFlWWnNXa3RWUmxweFUydDBXRlpzU25oV1Z6RkhWVEpLVjFOcmJGZFdSVXB5VldwR1NtVkhUa1poUjJoVFRXMW9VRlpHVmxka01VNXpWMjVHVkdGc1NsaFVWbVEwVjFaV2MyRklUbGRpVlZZMVdWVmFVMWRzV2taalJsSmFWbFp3V0ZwRlpFOU9iRXB6WVVaT2FWZEhaRE5XTW5SWFZqQXhTRkpZYkZSaE1sSndWV3RhUzFsV1duTmFSemxxWWtad1ZsVldhRzloYlVwSFkwaG9WMkpZYUhKV2FrRjNaVVpPZFdKR1pHbFhSa3A1Vmxod1MxUXlUbkpPVm1SaFVtMW9jRlV3Vmt0WGJGcFZVV3hrVkUxWFVsaFdNalZIVlcxS1ZsZHVSbFZXTTJoTVZURmFZVmRIVWtoU2JIQlhZVE5DVjFadE1YcE9WbGw1VTJ4V1YyRXhTbFpaYkdodldWWndWbGRzWkdwaGVteFpXVlZWTVdGRk1IZFRhM0JYWWtaS1RGUnJXbHBsUmxwWllrWk9XRkl6YUhaV1Z6QjRZakZrUjJKSVVrOVdWVFZaVlcxNGQyVldXWGxOVldSWFRWWndlVmt3VWtOWlZrcFhZMFpTVjFaRlJqUlZha3BQVW0xU1IxcEdaR3hoTVZZelZtcEdZV0V4U1hoWFdHaFZZa2Q0YjFWdGN6RlhWbFp4VW10MFdGWnRVbGhYYTFKRFZrVXhjbGRyYUZwaE1VcG9WbFJLUzFkV1ZuTldiRnBwVjBkb2IxZHNXbUZqTWs1eldraE9WV0pYYUZoWmJGcExVMnhrVjFadFJsZE5WMUpJVmpGb2QxWnRTbk5qUm1SWFlURmFhRmRXV25kV2JHUjBaRWR3VG1FeGNFaFdSM2hoWVRGVmVWSlljRkppUjJoWVdWUkdkMk5zVWxaWGJrNVlVbXh3ZWxkcldtRmhWa2w0VTJ4d1dGWXphSFpXVkVaclVqRmFkVkpzU21saVZrcFFWbGN3TVZFeFdYaGFTRXBYWWxoU1dGUlZVa2RsVm10M1ZtNU9WMDFXYkRaWlZWcFRWMFphYzJORmRHRldla1pJVlRCa1IxSXhjRWhpUms1cFlUQndVMVpxUmxOVGJWWkhWbGhvVkZkSGFIRlZiRnAzVlVaYWRFMVdUbGhTYkZvd1dsVm9TMkpHV25OalJFSmFUVVpaZDFaSGVFdGtSMVpIWWtaYWFWSXlhRFpXYkZKTFV6Rk9SMVp1VG1sU2JrSllWV3hhZG1Wc1duRlJiVVpZWWxaR05Ga3dWbXRXVjBwSVlVWlNXbUpIYUhaVWJYaGhZekZ3UlZGc1ZrNVdhMWt3VmxSSk1WUXlSbk5VYTJob1VtMVNZVmxyWkc5V1JsSlZVbTVPYW1KSFVubGFSV1F3VmpKRmVHTkVWbGhXYkZwb1drUktSMUpyTVZsVWJGSm9UVzVvV1ZkWGRHRlRNVkpIVm1wYVUySllVbFZWYlhSM1pWWnNjbHBGWkZaTmEzQllWVEo0YzFZeFdYcGhSbWhoVWtWYWNsWnFSbXRqTWtwSVkwWk9XRkpyY0ZwV2ExcHJaVzFXUms1VlpHRlRSWEJ2VlcweFUxZEdiSE5XYm1SWVlrWmFXVnBWV2s5V01ERnlWMjVzVjAxdVVUQldNbmhoVmpKT1NHRkhSbE5XYkZrd1ZtcEdhMVF4U25KT1ZtUmhVako0V0ZsVVRrTlRNVnAwVFZoa1ZFMUVWa2xWYkdoelZUSkZlVlZzVmxwV00yZ3pXVEJhVjJOV1JuUlNiR2hUWWxob05sZFdWbUZVTVZKMFUydGtWR0pIZUdoV2JHUnZWVVpzV0UxVmRGUlNiRnA0VlZkNFlXRldaRWhoUkVwWVZteHdhRmRXV2xwbFJuQkhWbXhLYVZJeWFGbFdWM2hYWkRGYVYxZHVTbFpoTWxKWldXeGFSMDB4VWxkWGJYUmFWbXRzTmxWWGVGTlhiR1JKVVd4b1dtRnJXbWhXTUdSVFVqRndTR1JGTlZkV1JscEtWbTB4TkdJeVNYaGFSV2hVWVRGd1VGWXdWbUZXYkZweFZHeE9hRkpzVmpOV01qRkhWa1pLVlZKc2NGZFNNMmhvVmtkNFMxSnNUbFZTYkdSb1RXeEplbFp0Y0VkWGJWWlhWRzVPVjJKRk5WaFZiRlozWVVaYWRHTkZPVlZOUkZaSVZqSTFSMVV5UmpaaVJteFhZV3RLYUZVd1duTldiSEJKVkd4YVRsSkZXWGRYVmxaaFlURlpkMDFXWkdwU2JFcFhXbGQwWVZZeGNGZFhiRTVxVFZoQ1NGZHJaSE5oUlRGWlVXeGtWMDFYVVRCV1ZFcE9aVVp3UjFwR1pHbGlSWEJRVm0xMFlWTXhaRmRYYmxKUFZsVTFWRlJXWkZObFZscDBUVlJDYUZKcmJETlpNRnByVjJzeFIxZHFUbGRpV0doaFdsZDRWMlJXWkhOYVIyaG9UVVpyZDFZeWRHRmhNVWw0VTFob1UySnJOWEZWYlRGVFZERlNWbFZzU210TlZtdzBWbGQwTUZReFNYZFdhbFpYVW5wV1ZGWnJaRVpsVmxaMVVteGFhVlpGV2xWV2FrSmhWVEZaZUZkdVZsaGlXR2hZV1d0a00wMUdXWGxrUms1U1RXdGFSMVJXV21GVWJGcEhVMnhrVlZadFVuWmFWM2hoWXpGd1JsZHRlRmRpUm05NFZsWmtORmxYUmxkWGExcFlZa1phV1ZaclZrdGhSbVJYV2tVNWFrMVhVakZWTWpGM1ZURmFSMWRzVmxoV00xSjJWVlJHVDJNeGNFbFRiR1JwVjBaS1ZWWkdaREJaVjFaWFZXeGtXR0pVYkZoWmJGWlhUbFpzVmxkdE9WaGlWWEJKV1ZWb1lWbFdXWHBoU0hCWFlXdGFjbGt5TVZOVFIwNUlZVWQ0YVZKdVFtaFdiWFJUVWpGc1YxZFlhRmhYUjFKUFZUQmtOR0l4Vm5OVmEyUllVbTE0V1ZwRmFHRlViRXAwVld4b1dHRXhWVEZXYWtGNFZtMU9SVkpzWkZkbGExWXpWbXhTUzFNeFRsZFNiazVTWWtkb1dGbHJWbmRUVm1SeVZXdGtWVTFXYkRSWGEyaFhWbTFHTmxac1VsWmlSbkF6Vm1wR1lWSXhaSFJTYlhST1VrVmFTVlp0ZUc5ak1WRjRWMnhzVm1KR2NGWldiWGgzVFRGU1ZsZHRSbGhTTVZwSldrVmFiMkZXV2xsUmEyeFhWa1Z2ZDFsVVJtRldNV1J6V2tkd1UxSlVWbGxYVm1Rd1dWZE9jMkpFV2xSaGVteFZWV3BHWVZOR1pISlhiWFJXVFd0d1NsVlhNVzlXTWtaeVlqTmtWMkZyY0VkYVZscFRWMWRHUjFwR2FGTk5WWEJSVm0weE5HRXdOVWRXV0docFVteGFWbGxVUVRGWFZsWjBUVlJTYkZadFVubFdiRkpIWVZaS2NtTkVRbUZUU0VKTVZtMHhTMWRYUmtWVWJIQm9UVmhDYjFkVVNucE5WbVJZVTJ0a2FGSXlhRTlXTUZaTFZteFplRmRzWkZkaVZscEpWbGQwYjFVeVJYbGhSemxXWWxSR1ZGa3dXbHBrTVhCSVQxZHNUbFl4U2pWV2JHUXdZVEZhY2sxV1dtbFNSa3BaV1ZSS2IxZEdXbk5hUlhSVVVqQmFTVlF4V2xkV01VcFhZMFV4V0dKR1dtaFhWbHBLWlVkT1JtSkhjRk5XUmxwWlYxWm9kMVl4VGxkWGJrWlRZbFJzY1ZSWGRIZFRSbFY0WVVoa1YySlZjRlpaYTFwdlYyMUtTR0ZHVWxWV1JWcGhXbFprVjFJeGNFZGhSazVPVmxoQ1RGWnFTakJaVjBWNFZXNVNVMWRJUWxOWmEyUlRWMFphZFdORlpFNU5WbkJHVlcweFIyRXhTbk5qUkVaV1RXNW9kbGxWWkZka1IxWklUMVprYVZkSGFHOVhhMUpDWkRKV1IxZHVWbE5pUlRWd1dXeGFTMVpXV2tkWGJVWlVUVVJHU0ZscmFFdFpWa28yWWtaYVdsZElRa2hWYWtaelpGZE9SbVJHWkU1aE0wSmhWMVpXYjFJeGJGZFhiR1JYVjBkb1YxbFhkSGRVUmxaeFVtNWtWRkpyY0hwV1IzaHJWR3hhV1ZGdGFGZGhhMXB4V2xWVk1WSXhVbGxpUmxaWVVqSm9XVmRYTVRSVE1WRjRWMjVTYW1WcldsaFVWbHBoVFVad1ZscEZaRlZpUlhBeFZWZDRhMWRzV2xoVldHUlhUVVp3VEZsNlNrOVNWa1owVW14T1YyRXpRbEpXYlRGM1V6Rk5lRmRzWkZSaVIzaG9WVzAxUTFkR1duUk9WVTVWVm14d01GcFZaRWRXUlRGelUyeHNWMUl6VW5KV01HUkhUbXhhZFZGc2NHbFNNVW94VjJ4YVlWbFhVa1pOVm14aFVtczFUMVpzVWtabGJGcElaVWM1VlUxWFVrbFZNalZMWVd4T1JrNVdaRnBpUmtwSVZtdGFZV05zWkhOYVIzQk9WakZKZUZZeWRHdGpNVkp6VjFob1ZHRnNXbGhaYkZKRFRrWlNWbGRzV210TlJFWllWakl4YzFVeFNuSmpSbXhZVmpOb1ZGWnFSbGRTTWtwSFlVZDRVMWRGU25wV2JYQkRXVlpKZUZWWWFGaGliVkp2Vm0xMGMwNUdWWGxqUlhSWFRWWnZNbFZzVWtOWFJscDBWV3hDV21WcldqTlZNVnBYWkVkU1IxUnNaRk5OTW1oWFZtcEdhMDVIU1hsVFdHaGhVMFUxV1ZsdGRIZFhWbXh6Vlc1T2FsSnNTbGhXTWpWUFZERmFjMVpxVmxWaVJsbDNXVlZrUzFKdFRrbGpSbkJPVWpGS1NWWnFTalJaVmtwMFZHdGtWbUpIVW05VVZtaERZakZhV0dWSFJsUk5iRXBZVmxjMVUyRnNTWGxsUmxKYVlsaFNTMVJYZUZwbFJsWnlWR3hrYUdWcldsbFdiWGh2WXpGYVNGSlliR2hUUlhCb1ZtcE9VMkZHV1hoWGJrNVhWbXR3TUZWdE1XOVZNa3BaWVVaa1YxWkZiM2RaVkVaV1pWWktjVmRzVG1sVFJVcFlWa1pqTVdJeVVuTmlSbVJZWVROQ2MxWnFRbUZUUm14V1YyMTBWazFyY0ZoVk1XaDNWakpLV1ZGcmFGaFdiSEJMV2xaYVQyTnNjRWRoUjJ4VFRXMW9NbFl5ZUdwbFJUVkhWMnhrWVZKdGFITlZiWGgzVkRGYWRHTjZSbFJTYlZKNVdWVldNRmRHU1hkalJFSlhWak5vZGxac1dtRldNVTV5Vld4V2FFMVlRbGhYYkZwclZHMVdkRkpyWkdoU2F6VndWVEJXU2sxc1duUmpSWEJzVWpCc05GZHJhRk5XTWtweVkwaEdWbUpZVWt4V01GcHpWMGRTU0ZKc1dsTmlhMHBKVm1wS05GUXlSWGhUYmtwcVUwaENXRlZxVGs1bFJscElaVWRHV0ZaclducFhhMXByWVZaYVJsTlVRbGRTYkZwb1dYcEdXbVZXVG5KYVIwWlRUVVp3VlZadGNFZFRNV1J6V2tab1RsWkZTbkpVVjNSaFUwWmFkRTVWZEZoU01GWTJWbGQ0YjFkdFJYaGpSWGhYVFVad1lWcFdaRk5TVmtaMFlrWk9UbE5GU2twV01XUXdWVEZaZUZkc2FGUmhNbEp4VlcxMFMxbFdXbk5YYkdSUFVtMTNNbFZ0TVRCaE1WbDNZMFZvV0dFeFZYaFpWbVJMVjBad05sTnNaR2xYUlVwTlZrZDBZV014V1hoVWJsWlZZbFZhVlZWdGRIZGtiRnBZVFVob1ZrMXJiRFJXVjNocllVWktWazVXYkZkaVdHZ3pWRlZhZDFac2NFWmFSbVJYVmtWYU5WWkhlRzlrTVdSeVRWVmtXR0pyY0ZoWmEyUlRWRVpaZDFwRlpGUldiRXA2V1RCYWExVXhXblJQVkZwWFlsaENURlJyV25OWFJsWnlZVVpXYUUxWVFuaFdWM0JQWWpGYVIxVnNXbFpoTVhCUFZXMTRkMDFHY0ZaWmVsWm9WbFJHV0Zrd1ZuTldhekYxVlc1S1YwMUhVa3hWTUdSSFUwWktjMk5HWkZOWFJVcFdWbTB4TUZsV1pIUldhMlJoVTBaS1ZGbHNhRU5YUm14eVZtNWtUMkpHY0hsWFZFNXZZVlV4VjFacVZsWk5ibWh5Vm10a1MxTkhWa2RoUmxaWFpXeGFWVlp0Y0VkVk1rMTRZMFZhWVZJelFtOWFWM1JoVjFaa1YxWnRSbHBXTUZwSlZXeG9iMkZzU25SbFJtaFhZbTVDV0ZSVVJsZGpWa3B5VDFaT1RsWXhTalpXYlRFMFZESkdWMXBGWkZSaVJscFlWVzE0ZDFZeFVsZGFSbVJxVFZkU01WWlhNVFJWTURCNFUyeG9WMUp0VVhkYVJFWnJVakZhV1dGR1dtaE5NVXBaVmtaYVYyUXlWbk5oTTJSaFVucHNXRlJXVm5kU01XdDNWbFJXV2xac2NGaFpNR2hMVjIxV2NtTkZlRlpOUjFKTVZXcEdVMk5yTlZaT1YyeFhUVzFvV1ZadE1IaE5SbXhYVmxob1ZGZEhhRlpXTUdSdllVWldjMXBHVGxoV2JYaFdWVEo0VDFkR1NuUmxTR3hYWWtaS1NGWnRjM2hXTVU1eldrWmtWMDB5YUhsV2FrSmhVekpTU0ZacmJHbFNiVkpQV1ZkMFlWTldXbkZSYlhSVVRWWnNORmRyYUZkaGJFcDBWV3M1V21KVVJuWlVWM2hoWkVkV1NGSnNhR2xXYkhBMlZtMHdNVlV5UmtkVFdHUllZa2RvWVZsVVNtOVNSbGwzVjIxMGFrMVhVbnBXTW5NeFZqSktTVkZZWkZkaVIxRjNXVlJHYzFZeFRuTldiR1JwVWpKb2FGZFhkR0ZUTWxKelZXNU9XR0pWV25GVVZtUXdUbXhzVmxaVVZsWk5SRVpKV2tod1ExZEdXWHBWYldoYVZrVmFhRlV3V2s5amJVWkhWMjFzYUUxWVFsbFdNV1EwWWpKSmVGVnJaR0ZTYlZKWldXdFZNVmRXVm5OVmJHUllWbXhHTkZac1VrZFdWMHBIWTBod1YwMVhhRE5XYWtwSFkyMUplbHBHVmxkV01VcEpWMVJLZW1WR1dYaGpSV1JXWWxkNGNGWXdaRzlYUmxsNFdrUkNhRTFXVmpWV2JUVlBZVlpLZEZWc2JGcGhNbWhFV1hwR1lXTldSblJTYkZKWFlrVlpNRlpxU1hoTlIwWkhWMjVPYWxKWFVsaFphMlJ2WTJ4WmQxZHRSbXBOVlRWNVdsVmFhMVl5Vm5KWGJHeFhWak5DU0ZacVNrNWxWazV5WVVkc1UyRjZWbmRXVjNodlVURnNWMWR1VG1GVFIxSlZWRmQwYzA1R1pISmhSVGxhVm10d01GbFZWVFZXTURGSVlVVlNWMUpGV21oYVJWVjRWakZTYzJGR1RtbFhSMmN4VmpGYVYxbFdVWGxTYTJoVVlrZFNXVmx0TVRSWFJsSllZMFprVTFKc2NIcFdNakZIWVdzeGNrNVZhRnBXVm5CWVZtcEdTMVl5VGtsaVJtaFhVbGM0ZDFkV1VrdFVNazV5VDFaa1lWSXdXbFJVVnpGdlpXeGtWMVZyWkd0TlYzaFlWakZvYzJKR1NuUlZia0pWVmpOb1NGUnJXbHBsUjBaSVpFWldhVkl4U2toV2FrbzBWVEZrYzFkcldtcFRSbkJZVkZWYWQyVnNXbk5YYTNSclZtNUNTRlp0ZUU5aFZtUklWR3BXVjJKR1NreGFWM014VmpGYVdXSkdVbWxTYmtKNFZsZDRhMDVHV1hoaVNFNW9VbnBzVjFWdGVIZGxSbFpYWVVjNVYwMXJjRWxXVjNoM1Yyc3hSMk5JU2xwV2JIQm9WVzE0YTFkWFRrZGFSbVJPVFVWd1NsWXhXbE5UTVZWNFUxaG9XR0pyTlhCVmFrbzBWa1pzY2xkdVpHdGlSbkJJVmpJd05WVnJNWE5TYWxKWFRXNW9kbGxYZUV0V2F6VllVbXhrYVZaRldsVldWRUpoVjIxV1ZrNVdXbUZTYlZKVVZGVm9RMVl4WkZoa1IwWldUVlpzTlZVeWVITmhSa3BHVGxaYVYySkdjRE5XYTFwaFpFVXhWbHBHVWxOV1IzaFpWakowWVZReFdYaFRiR1JxVWpCYVdGbHNhRzlqYkZKeVdrVndiRkp0VWxwWlZWcHZWMFpPUmxOdVdsZFdSVXAyVlZSR2MxWXhaSFZVYkdocFlsWktWMVpYTURGUk1VNUhWMWhzYTFJelVtOVVWbFozVm14c2NsZHRPVmhoZWtaSVdUQm9TMVl4V2taWGJXaGhVbFpWTVZac1dtdGpNWEJJWWtaa1UxWnNXWHBXYlhCSFdWWnNXRlJZYUdGU1YxSlhXVzF6TVdGR1ZuUmpla1pxVW0xNGVWWnROV3RpUmxwelkwWnNWVlpYYUhaV2JYTjRWakZLY1ZWc1pFNWhiRnBSVjFaV1lWTXhXblJVYTJ4VVlrWmFXRmxyYUVKbGJHUnpXa1JTYUUxck5YcFdiVFZMVmxkS1dHRkdVbGRoTVZwb1ZqSjRhMk14V25SU2JXeE9WbTVDTlZaR1dtRmlNa1pIVkd0c1VtSlZXbUZXYTFaaFRURmFSbGR1VGs5aVJYQjVWREZrZDFSc1dYaFRhbHBYVFc1U2NsbDZSbXRTTVU1WllrZG9WRkp1UWxsWFZsSkhaREZhUjFadVJsUmhNWEJ6VlcweFUxZHNiRlphUldSWFVtdHdlVmt3V2xkWFJsbDZZVWhhVmxaRmNGQlZha1poWkZaS2MxUnRhRTVOUlhBMVZtdGFZVmxYVVhoYVJtUldZa1p3YjFWdWNITmlNV3haWTBWa1dGSnNWalZaTUZaUFZqSkdObEpxUmxkV2VrWjJWbXBCZUZJeVRraGhSbHBwVjBkb1VWZFljRXRTTVVsNVZHdG9hRkpVVm5CVmJHaERWV3hhY1ZOcVVsZE5WM2hZV1d0YWExWkhTa2hWYkZaYVlsaG9URmt5ZUZka1IxWkdaRVprVTJKWWFHRlhWRUpoV1ZkS1IxTnVUbXBTYkhCWFZGZHdWMDB4V2tWU2JVWnJVbXhhZVZsVldtRlViVXAwWVVoc1dGWnRVVEJWZWtwVFUwWktjbHBIYkZOaVZrcDJWMVpvZDFZd01YTlhibEpyVWpCYVdGUlhjekZYUmxwSVRsVTVWMVl3Y0ZwVlYzTTFWakF4UjFkcmVGWk5WbkJoV2xaa1UxTkdTblJpUlRWb1RWaENZVlpzWTNoa01XeFhWMWhzVkdFeWFITlZiVEZ2V1Zac2NsZHJkRlJTYkVvd1dsVmFUMVl3TVZkalJuQmFWbFp3VUZaSGVHRmpNazVJVW14b1YySkdjRzlYVjNCTFVqRlplRlJzYkdoU2JFcHdWV3BLYjFkV1dsaE5TR2hXWWxaR05Ga3dWbGRWTWtwWlZXeFNWVlpzY0ROV01uaHpZMnh3UlZWc1pGTmhNMEpYVm0weE5HTXhXWGhUYmxKV1YwZFNXVlp0TVZOWFJscHhVMnQwVkZacmNIcFdiVEZ6VjBaS2NtTkdjRmRpVkVJMFZHdGtVbVZHY0VaYVIyaE9UV3hLV2xkV2FIZGpNV3hYVjI1U2JGTkhVbk5aYTJRd1RURlplV1JGT1ZoU01IQllWakkxYzFZd01YRldhM2hZVm14d1RGWXdXbGRqTVVaelYyMW9hRTFZUWxaV01XaDNVakpSZUZOdVNrOVdiV2h3VlcweFUxUXhiSE5hUjNSUFZteHdNRlJWYUd0aE1ERnpVbXBXVjJKWVVtaFdSRVpoVjBaV2RWRnNXbWxXUlZveVZtMXdSMWR0VVhoalJXUlZZa1phVDFadGVGcGxiRmw1WkVkd1QxWXdXbnBWTWpWUFYwZEdjbE50YUZkaVIxSjJXVEo0V21ReFpISmtSM0JPWVROQ1IxWnJaRFJpTWtaR1RWaEtUbE5IYUZoWlYzUkxZVVprVjFwRk5XeFdiRXA1Vm0xNFMyRldXbGRqUmxaWFlsaENTRlY2Ums5V01XUjFVbXhLYVZkR1NsWldSbHBXVFZaT1YxZHNhR3RTYlZKWVZtcENkMU5XV2xoamVsWllZa1pzTmxaWGRHdFpWbHBYWTBoS1YyRnJXbWhhUlZwTFl6Sk9SMXBGTlZOU2JGbDZWbTE0VTFNd01VZFhXR2hZWW14S1ZWbFVTbE5qVmxWM1ZtdDBWMDFYZUZsYVJXaHJZVEpLU1ZGc2FGZE5ha1pJV1ZSR1NtUXdOVlphUjBaVFZtNUNVVlpyWTNoU01EVnpWMnhzWVZKdFVsaFZiR00xVFRGYWRHTkZaRnBXTVVwSVZrYzFTMkZHU25OalNFSlhZVEpSTUZsVldtRmtSMUpIV2tad1YxWkZTVEJYVjNSdlVqRlZlVk5zYkZaaVIyaFlXV3hvVG1WR1VsZFhia3ByVFZad1ZsVnRlR3RVYlVWNlVXdHdXR0V5YUROVlZFWnJVakZrY2xkc1VtbFNNbWhvVjFaa01HUXhUa2RXYmtaVFlYcHNjbFp0Y3pGbFZsRjRWMjEwVjAxVmJEWlpWVnB2VmpKS1ZWRnFVbFZoTVhCNlZtMXplRk5YUmtkaFIyeHBVbGhDTmxac1kzZE5Wa1Y1VkZob1YySnNTbEJXYkZVeFZrWnNjbGR0UmxoV2JrSlhXVlZrTUZZd01VVlNhMXBXWWxob2NsWnFRWGhXTVU1eVlVWmthR0V6UWsxV1ZFSmhWVEZrV0ZKclpHRlNhelZVVm0wMVFrMXNXblJOV0dSVFRWWldOVlpITlU5WlZrNUdZMFpHVjJKVVJsUldSRVp6WXpGd1NFOVdhRmRpUjNjd1ZtcEtORlF4VlhkTlZtaHNVbTFvV0ZacVRsTmpiR1JYVjJ0MGExSnNXbnBaYTFwM1lWWktjMk5IT1ZoV1JXOHdWbXBLVG1WR1duVlRiVVpUWWxkb1ZWZFhkRzlSTVU1eldraE9WMkpZUWxCV2JYaDNaVlpTVjJGRmRHaGlSWEF3V1ZWYWExWldXalpXYTFKWFRVWndhRmt4V2s5amJIQklZMGRzVjFaNmFEVldiRnByVGtkUmVGZFlhRlJpUjFKeFZXNXdjMWRXYkZWU2JVWm9VbXh3UmxVeWN6RmlSa3AxVVd0d1YxWjZSak5XVkVwSFRteGFkVnBHWkZkU1ZYQlpWbGh3UzFOdFZrZGFSbXhvVW0xb2NGVnNVbGRXYkZwSFdrUkNhazFFVmtoV01uUnZZVEZKZWxWc2JGWmhhMG96V2xaYVUyTXhaSFZVYkdocFZsaENTVlpxU1hoaU1XUnlUVlprYWxKc1NsaFVWV1JUVlVaU2RHVkZkR3BOVmxvd1dXdGFUMVJyTVZaWFZFcFhZbFJHTTFWNlFURlRSa3BaWVVab1dGSXhTbEJXYlRFMFpESk9WMVp1VWs1V2VteGhWbTE0UzFZeFdYbE9WM1JZVW10d2Vsa3dhRzlXYXpGMVZWaGtWMDFHY0doWk1uaHJaRmRLU0ZKc1pGZGlhMHAyVmpGYVYyRXhTblJXYTJoVllURndUMVp0TVc5WFZsVjNWbXQwVlZac2NIbFdWM1JyVmtVeGNrMVVWbGRTTTFKb1YxWmFTbVZYUmtkVmJGWlhaV3RhTWxkc1pEUmhNV1JJVld0b1UySllVazlWYTFaaFRteGFjVk5VUmxSTlYxSkpWVEo0WVZkSFNsWlhiR2hhVmpOU1IxcFZXbE5XYkdSMFVtMTBVMDFWY0VwWGExWmhZakZWZVZOc1pGUmhNMEpaVm0xNFlXRkdiRFpTYlhSclVtdHdXbGxyV21GaFZrcHlZMGRvV0ZadFVYZFhWbHBoVWpGa2RWSnNUbWxXVm5CNVZtMHhORk15VmxkVldHaFlZWHBzYjFadGRITk9iR1JWVkcxMFYwMUVSbGhaTUZwdlYyMUdjbGRzVG1GV1ZuQnlXa1phVDJOck5WZGhSazVZVWxWdk1GWnRlRk5STWtWM1RsVmthVkp0VWxkWmExcDNWMVpzZEUxV1RsZFNiRm93V2xWb2EySkdTbk5YYkdoYVZsZE5NVlp0YzNoU1ZrcDFZa1pXYVZKc2NHOVdiWEJIVTIxV2RGSnJiRmhpUjFKdldWUk9RMVJXV2xWU2JVWlRUV3hLUjFReFdtdGhSa3AwWVVaV1ZtSkdXak5WTW5oYVpVWmtjMVJzVWs1V2JGa3dWbXBHYjJNeFdsaFNXR2hxVW5wc1YxbFhjekZrYkZweVYyNU9hazFYVW5sYVJXUXdWR3haZUZOc2JGZGlSMUYzVmtSS1JtUXdNVmRoUmxwcFltdEtXVlpHWkhkV01VNUhWMjVLWVZKWFVuRlphMVV4Wld4c1ZsZHVaRmhTYXpWSFZUSjRjMVl5Um5KVGJXaFlWbXh3WVZwV1drdGpiVXBIVm0xc1UwMVZjRlpXYTFwWFdWWmtjazFWWkdGU2JGcFRXV3hTYzFaR1VsZFhibVJzVm14S1dGWnRNRFZoUmtweVkwWm9WazF1YUhwV2FrcExWMWRHUlZSc2NGZFdia0kyVmtjeE5GTXlVa2hWYTJoclVtMVNjRmxVUW5kVE1WbDRWV3RPYUUxck1UUldiR2h6VmtkS2NtTkdWbHBXUlRWVVZqQmFVMWRGTlZoUFZtaFRZa2hCZDFkVVRuZFNNVmwzVFZaa2FsSnVRbUZaVkVaM1ZrWnNWbFpZYUZoV2ExcDZWVzE0YTJGSFJYZGpTR3hYVWpOU2FGbDZSbHBsUmxwMVZHeG9hVkl5YUhkWFYzaGhVekpXUjFwR2FHdFNNRnB5VkZaVk1WZEdhM2RYYlVaYVZtdHdXVlpYTURWV1ZscHpZMFJPWVZac2NHRmFWbFV4VjFad1IyRkhiRmRXYkd0M1ZqRlNRMkl4YkZkWFdHeFRZbXR3Y1ZWc2FHOVdNV3h6Vld0a1ZsSnNXakJaZWs1dlZqQXhXVkZyYUZoaE1YQlFWbXBCZDJWV1VuRlViR1JwVmtWSk1GZHJVa2RUYlZaSFZXNVdWbUpIVW05VVYzaExZakZhVlZGdFJscFdiVkpJV1d0b1MxbFdTbkpPV0VaV1lsaG9hRlJWV25kV2JVWklaRWRvVGxKRldsbFhWRUpUVVRGc1YxZHNhRlpoTW1oaFZtdFdSMDVHV25GVGF6bFRUV3RhU0ZkclZURmhSMHBIWTBaYVYySllVbkpVYTFwT1pVWk9kVlJ0UmxSU1ZGWlhWMWQwWVZsV1pFZGlTRXBvVWxWd2MxbHJaRk5sYkdSeVZXeE9hRkpVUm5sVWJHaDNWMGRGZVdGR1VsZFdWbkJoV2xaa1IxSnJPVmRhUjJ4VFRXMW9SVll5ZEZOU01XeFlWRmhvYVZKR2NGUlphMXBMVkRGYWRFNVZUbGhXYkhCNFZURlNSMVpyTVZkalJFSldUVzVTY2xaclpFdFRSbFp6VjJ4a2FWSnVRWHBXUmxKSFl6RmFjMXBJVG1wU00xSlBWakJXUzFOV1dYbGtSMFpXVFZaV00xUldXbUZoYkVwWVpVWnNWMkpZYUdoWlZWcGhVbFpLYzFSdGNFNVdhM0ExVm1wS05GUXlSa2hTYWxwWFlrZDRXVlpxVG05a2JHeHhVMnM1VjAxck5VZFdiWGhMVmpGS1YyTkdiRmRTYkhCeVZsUkJlRll4WkhOaFIzaFRZWHBXZGxadE1UQmtNbFp6WVROa1dHSkhVbGxWYlhoelRteGFXRTFYT1ZkaVZscDVWakkxUzFadFJuSlhiR2hhWld0YWNsbDZTa2RUUjBwSVlrWmthRTB3U2pKV2JUQjNaREpSZDAxV1pGTlhSMmhvVld4a1UyRkdWWGRXYm1SWVVteHdlVll5TVVkV01rcEhVMnhzWVZKWGFISldWRUY0VjBkU1JWUnNaRmROTVVwUlZtcENhMU14V25OWGJrWldZa2hDVDFWdE5VTlNWbHB4VTJwU1dsWXdNVFZXUjNSclZXMUtSMk5JUWxkTlIxSjJWbFphWVdSSFZraFNiRlpPWVhwRk1GZFVRbGRpTWtaWFUyNUtUMVo2YkZaV2ExWkxWRVphUlZKdFJtcFdhelY0VlZkNFlWUnNXbGhrZWtKWFlUSk5lRlpVUmxwbFZrcFpZa1phYVZZeWFGaFhWM2hUVW1zeFIySklSbE5pUjFKeVZXeFNSMWRXVVhoWGJUbFhUV3R3U0ZZeGFIZFdNa3BWVWxoa1ZWWlhVa2RhVmxwUFkyeHdTR05HVG1sWFIyaFlWbTB4TkdFeVNYbFZiazVwVW0xU1dGWXdaRzlYVmxaeFVtMUdWRkp0ZUZkV01qRXdWbGRLVmxkdWNGZE5ibWhJVm1wS1IyTnNUblZUYkZwc1lURndVVlpYY0VkWlYxSlhWVzVPVkdKWGVGUlpiWFJMVFRGYWRHTkZUbWhOYTNBd1ZtMDFUMWxXVGtaT1ZtaGFZa1phYUZZd1duTmpNV1IwVW14b1YySklRa3BYVkVKclVqRlpkMDFZU21wU1YyaGhWRlZhVmsxV1duUk5WVnBzVW0xU01GbFZXbGRoVmtwMVVXMDVWMVpGU25KV2FrWktaVWRPUm1GSGJGTldSbHBaVmtaYVYyUnJNWE5YYmxKcVVsaFNVRlZxUWxkT1ZsWjBUbFU1VjFZd1ZqUlpNR2hIVm0xS1ZWSnVXbGRoYTFwNlZqQmtUMDVzU25OWGJFNXBVbGhCTVZadGNFcGxSa2w1VWxob1ZHSkdXbFJaYTJSVFZteFNWMWR1WkZaU2JIQjRWVEowTUZaR1duSlhibWhYVFc1b2NsWkhNVXRqTVU1MVlrWm9XRk5GU2tsWFZsSkhVMjFXUjFWdVRtbFNNbmhVVkZjeGIxWldaRmhrUnpsU1RWZFNXRmRyV205aE1VbDZWVzVDVlZaV1NrUlVhMXBoWkVVMVZscEdXazVoTTBKSVYxUkNiMVF4V1hsVGJHeG9VakpvYUZadGVIZGpiR3Q1WlVkMGExSlViRmxaVlZwclZHeEtjMkV6YkZkaVJuQnhXa1JCTVZZeFpGbGhSbWhvWWtoQ1ZGZFdaRFJUTVdSSFYyNUtWMkp0VWxkVmJYaGhaVVpWZVdSRVFsWk5SRVo1V1RCV2MxZHJNVWRqUmtKYVZteHdhRmt5TVU5U1ZscHpXa1UxVjAxVldYcFdha1poWVRGV2RGWnJaR3BTVjFKb1ZXcEtiMVF4VWxobFJYUllWbXh3TUZwRlpFZFhiRnB6WWtSU1dtRXhjSHBaVjNoTFYwWldkVlJzWkdsWFIyaE5WbXBDWVZsV1pFaFdhMXBRVm0xb1ZGUlZhRU5YUmxwMFRWaGtWazFYVW5sVVZsWnJZV3hPUjJOR2FGcFdNMUpvV1ZWYVUyUkhWa1prUjNCcFZteHdTbFpYTVRSVU1WbDVVMjVLVkdKSVFsaFVWbVJ2VFRGV2NWTnNTbXhTYXpWYVdWVmtSMVpHU25KalNHUlhWbnBDTkZscVJtRlNNVlp6WVVVMVYyRXpRbEJYVjNSaFpEQXhSMVZzWkdoU00xSlhWRlZTUjFkV2NGWlhiVGxYVFd0d1NWbFZhR0ZXTURGSVZXdDRXbVZyV2xCWmVrWlhZekpPUjFwR1RsaFNWV3cxVm0weE5GbFdiRmRpUm1oV1lURndUMVp0TVZOV2JHeHpXa1JTVlUxV2JETldiWFF3VjBkS1NGVnViRmRpVkVWM1ZsUkJlRmRHVm5KaVJscE9ZbXhLZVZkV1pEUlVNVTVYVW01T2FWSnRVazlWYWtwdlVsWmFWVkZ0Um1wTlZuQllWVzE0YzJGR1NuUmhSbEphWVRGd01scFZXbXRXVmtaMFVtMW9UbFpyYjNkV1ZFa3hWREZhU0ZOc1ZtbFNiV2hoVm10V1lWUkdWWGRYYms1WFZtdHdlVnBGWkRCVk1rcEdZMFJXVjAxdVVuSlpha1pXWlZaT2RWTnNVbWxTTTJoWlZsY3hORk14VGtkV1dHeE9WbTFTY1ZSV1pGTk5WbFY1WlVkMGFGWnNjRmhaTUZwM1YwWlplbUZIYUZoV2JIQlFWV3BHZDFOV1RuUmhSazVYVWpOb2IxWnRNSGhOUjAxM1RsaE9WMkpIYUhGYVYzaGhWMVpzY2xkdVpGTk5WbXcxV1RCVk5WWXlSalpTYkdoYVRVZFNkbGRXV2t0V01WcHhWV3hrYVZKdVFsbFhhMVpyVWpGS2NrNVdaR0ZTTW1oUFZGVldWMDVHV25STlZFSmFWbTE0V0ZscldtdGhWa3AwWVVaU1dtRXlVbFJXYkZwelZsWk9jMVJ0Y0ZkaVJtOTNWa1phYWs1V1pITlhibEpzVTBkNFdWbFVTazVOVmxwVlVtdDBhazFYVWpGWmExcHJWRzFHY2xacVRsZGlXRUpEV2xWYWExSXhXblZTYkVwcFZsWndWVlp0Y0VkU01EQjRWMjVPVm1FelVsVlVWbFV4VjBaV2RFNVZaRmhTTUhCSldWVmFiMWR0UlhoalJFNWFZV3RhY2xacVJsZGpiVkpIVkdzMVYxZEZTVEZXYTFwaFdWZE5lRmR1VWxSaVIyaHZWVzE0UzFsV1duSldWRVpUVW14c05GWXlNVEJYUmtsNFYydG9WMUl6YUV4V1IzaExVakZrY21KR1pHaGhNamgzVm0xd1IxWnRWbGRVYmtwWVlsaENWVlZzVWxkWFJtUllaVVpPVTAxV2NFaFdWM2hyVjBkS1ZsZHNWbFpoYTFwb1ZUSjRhMk5zY0VsVWJGcE9Va1ZhUzFaV1pEQmlNV1JIVjJ0YVZHSnNjR2hWYTFaaFdWWndWMWRyT1dwTlZuQjZWa2Q0YTFVeFdsbFJibHBYWWtkUmQxWnFSa3BrTURWV1drWmthV0V4Y0ZWWFYzUnJWVEpPVjFWc1pHaFNWVFZWVlcxNGMwNVdVbGRoUlRsWFlYcEdXRmt3Vm05V01ERjFVV3Q0VjJGcmNFeFdiRnBMVmxaR2MxcEdaRk5XYmtKTlZqSjRWMWxYVVhoVGJrNXFVbGRvY0ZWdGVFdFdSbGwzVm10MFdGWnNiRFJYYTFKRFlVVXhWMVpxVWxoaE1WcHlXVlphVDFKck5WZGhSbkJwVmtWYVZWWnRlR0ZaVjFKR1RWWldWbUpIVWs5V2FrNXZWMFprVjFadGRFNVNiR3d6VkZaV1YxVXlTblJsUjBaVlZsWndNMWxWV21Ga1JURldaRVpvVjJKR2IzaFdWRW8wWWpGWmVWTnJiRkppVkd4WVZXNXdSazFHVmpaVGF6bHJVbXR3ZVZkcldtOWhWbGw1WVVoYVYxSnNjSEZVYkZVeFl6RmtkVlJ0UmxSU01VcFdWa1phWVZJd05VZFdXR2hvVW5wc2IxbHJWbmRYUm10M1YydE9WMDFyY0VoVk1uaHZWakF4UjJOSFJtRlNSVnBvV1RJeFQxTkhWa2RhUjJ4VVVsVlplbFp0ZEdGV01rbDVVMWhvVmxkSGFGVlpiWE14WTBaV2NsZHJkRnBXYlhoV1ZXMDFhMkV5U2tkalJFSmhWbGRSZDFacldrcGtNV1J5WVVaa2FWZEhhSGxXYTJRMFUyMVdSMVJ1UmxSaVIyaFlXV3RhZDJJeFduUk5TR2hXWWxaYVNGZHJhRmRXTWtwV1YyeFNWVlo2Um5aV2JGcHJWMGRTU0ZKdGRFNVNSbHBKVm1wSk1WTXhiRmRUYTFwVVlrWndWbFp0ZUhkTk1WcHhVbXhPVjAxWFVqQmFSV1J2VmpKRmVsRnJhRmRTTTJob1dXcEdhMlJHVG5KaFIyaFRZWHBXYjFaWGRGZFpWMFpIWVROc2JGTkhVbFJaYkZwTFUwWmFXR1ZGT1doV2EzQXhWVlpTUzFZd01WaFZXR1JhVmtWYVMxcFZXbUZYVjBaSFlVWm9VMDF0YUZkV01WcFRVekExUjFwRlpHbFRSVFZ2Vlc1d2MxZEdVbGRoUlU1WFRWZFNlVlpzVWxkaFIwWTJVbXh3VmxZelVqTldha1pMVG14S2RXTkdaRmRTV0VKTlZsUkdZVkl5VWxkalJXUmhVbTFTVDFSVlZuZFViRmw0V2toa1ZFMVdiRFJXTVdodldWWk9SMWRzVWxwaE1Wb3pXVEJhWVdNeFpIVmFSMmhUWWtoQmQxWkdXbE5STWtWM1RWVldVMkV5YUZoVVZ6VlRaR3hzVlZKcmNHeGlSbG93VkRGYVlXRldaRWRUV0hCWFVteHdhRlpxUm10U2F6VlhWMnhXYVZJeFNuZFdiWGh2VVRGc1YxZHVUbUZUUjFKV1ZGWmFkMlZXVWxkWGJYUm9Za1ZzTlZsVldtdFhiRmw2Vlcxb1YwMUdjSGxhVm1SWFUxWndSMVJyTlZoU1ZYQkpWbXRrTkdFeVNYbFRhMmhVWVRKU2NWVnFRbUZYUm14ellVYzVWMUpzVmpWWmVrNXZWakF4V0ZWc2NGcFdWbkIyV1ZaYVNtVlhSa2RYYkdoWFlrVndUVmRYY0V0VGJWWkhWMjVXVm1KWWFGUldNRnBMWVVaYWRFMVVVbXROYkZwWVZqSTFUMVp0UlhsVmJHUlZWbXhhTTFSVldtRlhSMVpJVDFaa1RsSkZXalJXVjNodllURlplVkp1U2xOaGJFcFlXVmQwZDFWR1ZuTlhhMlJxVFZkU01GbHJXbXRWTVZwMFQwaHNWMkpVUlhkWlZFRXhVakZ3U1ZWc1pHaE5iRXBYVjFjeE1HUXlUa2RXYmxKT1ZtczFXVlZ0ZUdGbGJGbDVUbGQwVldKVmNFbFdWM2gzVjJzeFIxZFlaRmRXUlVZMFZtMHhTMUpXVm5OYVJrNXNZa1p3V2xadE1IZGxSazE0V2tab1UyRXlVbGRaYTJoRFkwWldjVk50T1U1aVJuQjRWVzB4UjJGRk1WaFZhMlJWVm14YVdGWlVTa3RTYlU1R1QxWmthVkl4UmpaV1JsWmhZVEZhVjFKdVRtRlNiVkpQVm0xNFdrMVdXbFZUVkVaV1RWWndNRlV5ZEd0V1IwcElZVWRHV21FeVVuWldSRVozVm14a2RWcEdaRTVXTVVsM1YydFdhMlF5UmxkVFdHaFVZV3hhV0ZWclZtRmhSbHB4VTJ0a1YwMVZOVEZXYlhoTFYwWkplV0ZHYkZkaVZFVXdXa1JLVTJNeVNrbFNiRTVwVTBWS2VsWlhNSGhWTWxaSFYxaHNiRkpVYkZoVVZsWjNWakZyZDFkdVRsaFNiSEF3Vmxab2ExbFdTa1pYYkVKV1lXdGFjbHBHV2t0ak1WSjBZVWQ0YVZkSFp6QldiWFJoV1Zac1dGVlliRmRpYXpWb1ZUQldkMkZHVlhkV1ZFWlhUVlpLVjFaWGRHdFdNREZZWkVST1YwMXFWbkpXYWtGNFkyMU9SbUpHWkZOTk1FcFZWbTE0YTFKdFZsZFdiazVWWWxWYVdGbHJhRU5XVm1SeVYyMUdWazFyTVRSWGEyaFRZVlpKZVdGRk9WVldWbG96V1ZWYVlXTldTblJrUlRsVFlrZDNNRmRYZEdGaU1WcFlVMnRvVm1KSFVtRlpWRXBUVmtaWmVGZHVUbXRTVkVaWVZrZDRWMVJzV25WUldHUllZa1phZGxsVVJtdFNNV1IxVlcxMFUxSnVRbWhXUmxaaFpESk9jMWR1UmxKWFIyaFVWbTEwZDJWV1dYbGxSMFpYVFVSQ00xVXllRmRXTWtwVlVtcGFZVlpYVWxSV01GcExZMjFLU0dOR1RtbFdhM0F5VmpGYVUxSXlVWGxUV0doWVlUSm9UMVpyV2t0V1ZsSlhWMjVrV0ZKc1dqQlViRnBQVm1zeGNtTkZaRlZpUm5CVVZtcEtTMUl5VGtsaVIwWlRVbFp3YjFkWWNFZGtNVTVYWTBWa1ZXRjZWbTlVVmxweVpVWmFkR1JIUm1sTmF6RTBWbXhvYzFVeFpFaGxSemxXVFVaVmVGWnFSbk5qTWtaSVQxWldVMkpJUWpWV2FrbDRVakpHZEZOcmFGWmhhMHBYV1d4U1IyVnNXa2hsUjBaclZtdGFXbGRyV210Vk1rcEhZMFJLV0ZZelFraFdWRXBPWlVaU2MySkhhRk5oZWxaMlYxZDBWMlF4WkhOYVJtUldZVEpTY2xSWGN6RmxiRmw0WVVkMFdsWnJjRmhaTUdoUFZqSktXV0ZIYUdGV00yaHlXVEo0YTJSV2NFZGFSVFZYVjBWS2FGWnNXbXRPUmxsNFYxaHNVMkpyY0ZWWmJHUnZWMFphY2xadFJscFdia0pYVmpJMWExWkdXbk5qUkVKV1lsaG9VRmxWWkZkak1XUnpVbXhrYVZaRlNUQldSM1JyVlRKU1IxWnNiR2hTTUZwVVdXdGFkMVpHWkZobFJtUmFWbXh3ZWxaWGVHdFhSMHB5VGxVNVZWWnNjRXhXTUZwelZteGFjVkZzYUZOaE1uZDZWMVJDVTFFeGJGZFhiR1JxVTBad1dGbHJXbmRaVm5CWVpVVmthbUpWV2tsVmJYaFBWR3N4ZEdGSE9WZE5ibWhvV1ZSR1UyUkdXblZWYkU1b1RXeEtiMVpYZUZOV01rbDRZMFpvYkZJd1dsVlVWbHB6VGtaWmVXVkhkRmhpUm13MFZXMXdWMVpyTVhWVmJscFhWa1ZhY2xVd1pFZFRWa3B6VjJzMVUwMVZWak5XYlhCSFdWWnNXRlJ1VGxoaWJGcG9WV3hTYzJOR1ZuUmtTR1JZVm14d2VGVXhhRzlVYkVwelkwVm9WazFxVmt4V1JFWnJVMGRXU0ZKc1pHbFNNVXBWVjJ4a05GbFdXbGRVYmtwaFVsUnNjRlZ0TlVOT2JHUlZVVzFHYUUxV2JETlVWV2h6WVVaS2RHVkdiRmROUjJoRVZWUkdVMVl4WkhOalIzaFRZbXRLUzFadE1UUlpWMFpJVm01T1dHSklRbGhXYWs1RFUwWldObEp0UmxkTlYxSjVWMnRhYjJGV1pFZFRiRVpYVm5wQ05GWlVSbXRTTVdSMVZXczVWMVpIZUhaV1Z6RXdZekExYzFkc2FHeFNNRnBZVm0xNGQyVnNhM2RWYXpsWFRVUkdXRmt3Wkc5V01ERklWV3hvVmsxSFVsUlZha1ozVW1zMVYxUnNUbGRpYTBwTlZtMHdlRTVIUm5KTlZtUnBVbTFTV1ZZd1pEUldWbXhWVTJ4T2FsWnNWak5aVlZaUFlVWktjMWR1Y0ZoaE1YQlFWbXBHUzJNeFduRlZiR1JPWVd4YWVWWnNVa0psUm1SSFZtNVdhbEp0VWxSYVYzUmhUbXhhZEdSSFJsUk5WbkI2VjJ0YWMyRnNTblJWYmtKWFRVWndURmxxUmxwbFJtUjBVbTF3VGxadGR6QldiVEUwWXpKR1YxTnVTazlYUlVwWFdXeFNWMUpHV2xaWGJVWnJVbFJHU2xsVldtRlViRmw0VTJ4c1dGWXpVbWhaYWtwR1pVWk9jMkpHV21sU01taG9WMVpTUzFWck1VZGpSbVJZWWtoQ2MxWnNVa2RXTVdSeVYyMTBhRlpyY0ZwVlZtaHJWMGRLUjFkdGFGcGxhMXA2Vm1wR2EyTXhjRWRoUm1oVFRWVndiMVp0TVhkVU1WRjNUbFZrV0ZkSFVsbFphMlJUWTFaYWRHUklaR3hpUjNRelZqSXhNRll3TVhKalNHeFdUV3BXYUZacVNrdFhWbFoxVW0xR1YxWnVRa3hYYkZwaFZUSlNWMVZ1VGxaaVYzaFVWRlJLYjAxc1duTlpNMlJzVW14V05WWkhkR3RYUm1SSVZXeG9XbFpGTlZSV2JGcGhaRWRXU1ZSck9WTmlSM2N4VmtaYVUxRXhXWGhYV0dScVVtMW9XRlJYTlc5a2JGcHhVbTFHVDJKR2NIbGFWVnByVkd4SmVGTnJNVmRoYTBweVZXcEdTbVZHV25WVWJYQlRUVzVvVlZkWE1UQlRNVkp6VjI1U2FsSlhVbUZXYlRFMFYwWlZlR0ZIT1ZkTmEzQjVXVEJrYjFadFNsbGhSWGhYVWtWYWVsa3llR3RrVm5CSFlVWmthVkl6WTNoV01uUlhZVEZKZVZKcldrNVdiVkp4Vld0V1MxWXhiSEphUnpscVlrZDRXVnBWVlRWVk1rWTJWbXhvV0dFeGNETlpWbHBLWlZkR1JWTnNhR2xTTVVWM1ZteFNTMVJ0VmtkalJXeFZZa2RvY0ZZd1pHOVhWbHBIVjJ4a2EwMVZOVmhXTVdoellURkpkMWR0T1ZWV00xSm9WakJhV21WWFZrbFViRnBwVmxaWk1sWldaRFJqTVZsNVUyeHNhRkl5YUdGVVZscDNWa1pzTmxKdGRHdFNhM0I2VjJ0Vk1WWXdNVlppZWtKWFlsaENURlJyV2xKbFZrcHpZVVpTYUUxdWFGUlhWM1JyVGtaa1YxZHVSbFZpUlRWdlZXMDFRMUpzVlhsamVsWm9ZWHBHV1ZaWGNFZFdiVXBaWVVaQ1dsWnNjRXRhVlZwUFpGZEdSMkZHWkU1TlZXOTVWbXhhVTFJeFVYaFRXR2hoVTBVMWIxVnNVbGRYVmxaelZXeGtXRlpzY0VoWGExSkRZVEF4Vms1WWNGZGlXR2h5Vm0weFJtVnNWbk5oUmxaWFRURkplbFpVUm1GWlZrNUlWR3RhVUZadFVsaFphMmhEVG14a1ZWRnRkRk5OVjNoWVZqSjRhMkZzU1hsaFIyaFdZbGhvTTFZd1duTk9iRXB6V2tkMFUwMUdjRWhXUjNocll6RlZlRnBGV2xOWFIxSllXV3hTUmsxR2JGaGpNMmhZVW14YVdsbHJXbGRYUmtsNVlVaGtWMVo2UWpSV1ZFWnJWakpLU1ZWdGRGUlNNVXBhVmxjd2VFNUhWbk5YYmxKT1ZsZFNXRlpzVWtkWFJsVjVaVWM1VjAxRVJuaFdiVFZMVmpGYVJsSnFVbGRoYTNCTVZXeGFZV014V25OYVIyeFRWMFZLUjFacVJtRldNa1Y0VkZob1dHSnNTbFpaVkVaM1lqRldkRTFXVGxWTlYzaFpXbFZrUjFReVNrZGpTR2hXVm5wRmQxWlVTa3RXTVdSeVlrWmtVMDB4U2xsV2JYaHJVekZPUjFadVVsQldia0pZVld4U1YxSldXbFZSYlVab1RXc3hORmt3VmxkV2JVcEdUbFU1V2xkSVFrZFVWbHBoVmxaT2NWRnRhRTVXTTJoWlZsUkpNVlV4V25SVGEyUlVZa2RvWVZacVRrNWxSbHBWVW14T1YySkhVakJWYlRFd1ZUQXhWMk5GYkZkaE1sRXdWbFJHVTJNeFpITmlSa3BZVWpGS1dWZFhlRk5TYlZGNFlrWldVMkpWV2xsVmJYTXhaVlpzVmxwRVVsZFNhM0JYV1RCYWIxZEdXblJWYWxwVlZtMVNWRmw2Um10a1ZrNXpZVWRzVjFadVFqUldNV1F3WWpGRmVGTnVUbGhpUjJoelZXNXdjMWRHVWxoa1NHUllVbXhXTlZwVmFHdFhSa2wzWTBWb1YwMXFSblpXYWtaTFVteGtjMXBIUmxkaVNFSlJWMWh3UjJReFNYbFNhMmhwVWpKNGIxUlZhRU5rYkZwMFpFZEdWMDFYZUZsV1ZtaHpWbTFLY2s1WVFsWk5SbG96VmpGYWMxWldVbkpVYlhCcFVtdHdXVll5ZEdGVU1rcElVMnRrYWxKdGVHaFdiRnAzWTJ4YWNWRllhR3BpVlRWSVdWVmFZVlJ0U25SaFJteFhZV3RLY2xWNlJrOVNNVnB6Vm14S2FWTkZTbGxXVjNodlVURldWMXBHYkdwU1dGSldWRlpXZDAxR1ZuUmtSM1JXWWxWd1NWWlhOVU5XYlVwVlZtdFNWVlpGV21oYVJWVjRWbFpXYzJOR1pHbFdhMjh4Vm10YVlWWXlSWGhpUm1SVVltczFXVmxyVlRGWlZteFZVMnhPVjFKdGRETldNbmhQVmpBeFdGVnFSbGRTTTAweFZsUktTMUl4WkZWU2JHUlRUVEpvV0ZaSGVHRmhNVWw0Vkd4c1lWSXpRbFZWTUZaTFlVWmFSMVp0ZEZaTlZUVklWMnRhYTFkSFNrbFJiazVhWVRGd2FGcFZXbUZUUjFaSVpFWmFUbFp1UVhoV1ZtUTBZekZrUjFkcldsaGlWMmhYV2xkMGQxVkdhM2xqZWxaWFRXdGFTVnBGV2s5aFZscHlZMFJPVjJKSFRqTmFSRUV4Vm1zeFNXRkdhRmhTTW1oYVYxZDBhMVV4YkZkWGJsSnNVbGRTVUZWdGVIZFhWbEp6VmxSV1YwMVZiRE5aTUdoM1ZqQXhkV0ZHUWxkTmFrWk1WV3BHVDJSWFRrZGFSVFZUWW10S1ZsWnRNWGRTTWtWNVZXeGthbEpYVW1oVmJYTXhZMFpXZEU1VlNrNVNiSEI2VmxkME1GUXhTbkpOVkZaV1RXNVNjbFpyWkV0amF6VlhZa1p3YVZaRlZYZFdha1poWXpGYVYxTnVWbUZTTTBKd1ZXcE9iMWRXV25GVGFrSk9VakJhZVZSV2FFdFVNVnBZWVVab1dtSkhhSFphUjNoaFkxWk9jMXBIY0dsU1ZGWlhWbFprTkdFeVJsZFRia3BxVWxkNFdWWnRlRXRUUmxWNVRWWmtWMDFXU2pGVk1qRnpWVEpLUm1OSVpGZGlXR2hvV2tSR1lWWXhjRWRhUjJoVVVqRktXVlpHV21GWlZrNUhWMWhzVDFack5WWlphMXAzVTBaVmVVNVZkRmRXYkhCNlZteG9iMVl3TVVkalIyaFhUVWRTV0ZVd1pGTlRSMFpIVkcxb1RtSnRUalZXYlRFMFlUQTFTRk5ZYUZoaVIxSlpXV3RrVTFaV2JGVlRiVGxvVW14d01GcFZhR3RoUmtwMVVXdGtXR0V4VlRGV2ExcExZMjFPU1dOR2FHaE5iRW8yVm14U1MxTXhaRmRoTTNCcFVtMVNjRlZ0TlVObFJtUnpWbTEwVkdKV1draFhhMXB6V1ZaS1ZWWnNhRmRoYTFwTVdsVmFZVmRIVGtaa1IyeE9WbTEzTUZkWGRHOVVNa1pIVTJwYWFWSnRVbGRaYkZKWFVrWlZkMWRzY0d4V01EUXlWbTB4YjJGSFZuSlhiR3hZVmtWS1ZGVlVSbXRqTVdSeldrWmtXRkl5YUZsV1JsWmhaREZTUjFkdVVrNVdWR3hVVkZkek1WTkdaSEphUnpsb1VsUkdlRmxWVWs5V01rWnlWMjFvV0ZadFVrOWFWVnByVjFkR1IxcEhiRk5OTW1nelZteGplRTVHYkZkYVJtUlhZbXRhVlZsc1VuTmpNVlowWlVoa1dGWnVRbGRYYTFKRFZqSkdObEpzYUZwaE1VcFVWakl4Um1WWFJrZFJiR2hYWWtoQ1RWWkhNSGhUTVU1WFUyNU9XR0pYZUZsVmFrcHZaR3hhY2xkc1pGcFdiRlkxVmtab2IxZEhTbkpqUmtaWFlsUkdkbFpyV2xOV2JVWkdWR3hTVjJKV1NscFhhMVpoVkRGYWNrMVdaR2xTUlRWV1ZtMHhiMU5HV2xWU2JYUlVVbXhhZWxsVldtRmhSMFkyVm1wS1YxZElRa2hhUkVaaFl6RndTVk5zUWxkTk1VcFpWa1pXYjFFeFRsZFhibEpPVmtaS2IxUlhkR0ZYUmxWNVRsWmtWbUpWV25wV01uaHZWMjFLU0dGRlVsWmhNWEI2Vm14YVMyTnJOVmhsUms1b1pXeGFhRll4V2xkaE1VbDRWMnRrVkdKR1dsaFphMlEwVjFaYWNWUnNUbXRpUmxwV1ZXMHhNRlV3TVZkalJFWlhVbnBHZGxaVVJtRldWbHB6WWtaa2FWWkZWWGRYYTFKTFZqRkplRmR1VmxaaGVsWllWbXBHUzFkV1drZFdiRTVUVFd4YWVsWnNhSE5oTVU1R1RsWm9WVlpzV25wVWJYaFhWMFV4V0U5V1pFNVdia0pJVjFSQ1YwNUdXWGROVm1oV1lUSm9WMWxYZEhkVFJsWnhVMnM1VkZJd2NFaFdSM014WVZaWmVWVlVSbGRpVkVWM1dWUkJNVkl5U2tkYVIyeFRZbGRvVjFkWGRHdFZNVnB6WWtoU2ExSXdXbGRVVm1RMFYyeHJkMWR0ZEZkTlZYQjZWVEo0YTFZd01YRldia3BYWVRGd2FGbDZTazlUVjBaSFYyczFWMkV6UWtwV2JURXdWbTFXU0ZSdVRtRlRSVFZ2VlcxNGQxUXhiSFJsUlhSc1ZteHdlRlZYTVRCV1JURlhZMGh3V0dFeWFGQlpWVnBMWkZaR2RFOVdWbGRpVjJoRVYyeGtORmxXU1hoV2JrcGhVak5TVDFacVJrdFRiRnAwVFZSQ2FFMXJXbnBWTVdoM1ZtMUdObUpHYUZwV00xSm9Wa1ZhVTJSSFZraGtSbVJYWVRGdmQxZHJWbFpPVmxWM1RWVmthbEp0ZUZoWlYzUjJUVVpzVlZOclpHcE5WVFY2V1d0YVlXRldTWGxoUjJoWFlsaENVRlpVUVhoak1WWnpWMnhvYVdGNlZsbFdiVEV3WkRKV2MyRXpaR0ZTUmtwWFZGZDBXazFzV25SalIwWlhUVVJHTVZaWE5VdFpWa3BHVjIxb1ZtRnJXbEJXTVdSUFUwZEdSMVJ0YkZoU01taGhWbXBHYTA1SFNYaFNXR2hYWVRKU1dGbHJXbUZXUm14WlkwaE9WMUpzU2xsWk0zQkhWVEF4VjJORVFtRldWbFV4V1ZWYVMxWldSbkZVYkZwT1lXeFplbFp0Y0VkWGJWWnpVbTVLVldKR1dsaFphMmhEVkVaa2MxWnRkRlJOVld3MFYydG9UMkZHU1hsaFNFNWFZa2RvZGxSWGVHRmtSVEZKWVVVMVUwMVZXVEJXYWtreFZERmtTRk51VGxSaVJVcFlXVmR6TVZaR1dYZFhiRTVZVWpGS1NsZHJXbXRoVmtwelkwUmFXRlpzV25KVVZWcHJZekZrZFZOdGNGTldNVXBZVjFkMGEySXlVbk5YYmxKT1ZsZFNjVmxyWkZOTlZsVjVUVlZrVmsxcmNFcFZWM2hIVjBaa1NWRnJlRlpoYTFwUVZUQmFUMk5zY0VoU2JFNXBWbXR3TTFZeFdsTlJNazEzVGxaa1dHSnNTazlXYTFaTFdWWmFkRTFVVWxoU2JYaDVWakl4TUZkR1NuUlZhMnhYVmpOTk1WWnRjM2hUUmxaMVYyeGthR0V4Y0RaWFZFbzBaREZKZUZWdVRtaFNiVkp3VmpCa2JrMXNXWGhYYkdSYVZteEdORmRyVm10V1IwcHlUbFpXV21FeVVUQlpWVnBYWXpGd1NFOVhjR2xTTTJnMVZqSjBWMDFHVlhkTlZtUnFVMGRvV0Zsc2FHOVhSbXhYVjJ0MGFrMVdjRnBaVlZwcllWWmtSbE5yTVZkWFNFSklWMVprVTFJeFZuVlRiR2hwVmpKb1ZWZFhkRzlSTVZaSFdrWmtZVkpHU2xsWmJGcGhaV3haZVU1VlpGZFNiVkpKV1ZWYVUxWldXWHBVV0doaFZqTm9jbGt5TVVkU01WSjBZVVpPYUUxdVpEWldiWEJMVGtaVmVGZFliRk5pYTNCWldWUk9iMWRHYkhKWGJtUm9VbXh3ZWxZeWREQmhNVXB5WTBod1YwMXVUWGhaVldSWFl6RmtWVkpzWkdoTlZYQkpWakZhYTFKdFZrZGFTRTVvVW14S2NGVnFTbTlsYkZwWVRWUlNWRTFYZUZoWmExcFhWa2RLUm1OSVNsVldiSEJNV2xaYVdtVlZNVlphUjJoT1ZsZDNNRlpVU2pCak1XeFhVMnhrVjFaRldsaFdhMVpIVGtaV2NWTnJPVk5XYkhCNlYydGFUMVJyTVhSaFNGcFhUVlp3VkZWcVNrWmxSazVaWVVkd1UxWnVRblpXVnpFMFpESkplR05HYUU1V1JrcFpWbTB4VTFkV2NGWlplbFpvVmxSR1JsVlhjRk5YYkZwR1RsaGFWMDFIVWt4VmFrcFBVMVpPYzFac1pFNU5WWEIyVm14a2QxSXhiRmRVYTJoWFlUSjRhRlZ0TVZOVU1XeFZWR3RPVkZKdFVsWlZWekZIWVZVeFYySkVUbFZXYldoWVZtMHhTMk5zWkhOWGJIQm9UVmhCZWxkV1ZtRlpWMDVYVTI1S1VGWXpVbGhaYTFaMlpERmtWVkZ0UmxaTlZsWXpWRlpvVTJGR1NuUmxSbWhWVm0xU1UxUlZXbUZXVmtweVkwZDRVMkpGY0RWV01uUmhZakpHVjFOdVRtcFNiSEJaVm0xNFMxVkdXbFZTYlhSVFRXdHdTRmxyWkhkVk1rcFhVMnhzVjFKc2NISlVhMXBhWlVaa1dXSkZPVmROTVVwWlZrWldVMUl4WkVkaE0yUldZVEpTV0ZsclduZE5SbXhXVldzNVYwMUVSa2haTUdSSFdWWlplbUZHYUdGU2JIQlFXWHBHYTJSSFNrZGFSazVYWW10S2FGWnRjRWRpTWxGNFUxaG9WVmRIZUZkWmEyUlRWbXhzZEdSSVpGWlNiSEF3VkZaYVQyRnNTbk5qUkVKaFVsZG9jbFl3WkV0U01rNUpZa1prVG1KdGFGRldiR1I2WlVaYWNrMVdWbFppUjFKVVZGUktiMlZXV1hoWGJVWlVUV3hLU0ZadE5VOVpWa3AxVVd4b1ZtSkdTbGhXYkZwaFpFZE9SbHBHV2s1V2JYY3dWbXBKTVZZeFdsaFNhbHBwVW14S1lWbFVTbTlTUmxWNVpVZEdWRkl4V2tsVmJURnZWR3hhZEdSNlFsZGhhMXAyV1ZSS1IyTXhUbk5oUjJoVFlsZG9WMVp0Y0U5Uk1XUkhWbTVLV0dKVlduRldiWFJoVjJ4c1ZsZHNUbFpOYTNCSVdXcE9iMVl5Um5KaVJGSldZV3RhVjFwVldrOWpNWEJJWTBaT2JHSllhR0ZXYlRFd1ZqRnNXRkpyWkZkaWExcFZXV3RWTVZaV1ZuUmxSMFpzVm0xNFYxZHJhRTlXYXpGWFkwVm9WMDF1YUhwV2FrWkxZekpPUjJGSFJsTlNWbkI1VjFod1IyRXlVbGRXYmxKcVVtczFXVlZzVm5kVlZscDBUVWhvVGxJd01UTlViRlpyVjBkS2NrNVhPVlpOUmxWNFZqQmFWMk5XUm5WYVJsSlRZbGhSZWxacVNURlVNV1JJVTJ4YWFsSnVRbGhXYWs1U1RVWmFjVk5yZEZoV01GcEpXVlZhZDFSc1duVlJiRlpZWVRGYVYxUnNXbHBsUmxwMVZHeFdhVll6YUZWV2FrSlhVbTFXUjFkdVVrNVhSMUpWVkZWU1YxTkdiSEpYYlRsWFVqQldOVlpYZUZkV01ERklWV3hTVjAxV2NIcFdiRnBQWTFaV2MxcEhiRk5oTTBKYVZtMXdTazFYUlhsU1dHeFVZVEpTY1ZWdGVIZFdNVkpZVGxaS2EwMVdjSGhWVm1odlZqSkdObFpzY0ZwaE1YQXpWa2Q0UzJSV1JuRlRiR1JwVjBWS1RWWlljRWRUYlZaWFZXNUthVkl5YUZSWmJGcExWbFphUjFWcmRHbE5hMncwVmpGb2IxZEhTbFpYYkd4YVlrWndhRlV3V25Ka01WcDFWR3hrVTAxSVFrcFhWbFp2VVRGWmQwMVZaRmhoTTJoWVdXdGFkMk5zV1hkYVJrNVRUVmhDU1ZwRlZURldNREZXWTBad1YyRnJiM2RYVm1SR1pVZEtSMXBHVW1oTldFSldWMWQ0VjFsV1pFZGlSbWhyVWpCYWIxVnROVU5YVm5CV1YyNWthVkpzY0ZaV2JYaHJWbFV4VjJOSVdsZFdSVVkwVlRGYVIyTnRSa2RhUms1T1RXMW5lVlpzWkhkU01XeFhWMWhvWVZOR1dsWlpiR2hEVmtaWmQxcEhPV2xOVm5Bd1dUQlZOV0ZWTVhOWGJuQlhUV3BXVkZscldrcGxiRloxVW14d1dGTkZTalpXYWtaaFl6RmFjMXBJVW10U01taFVWbXRXU21Wc1dsVlRXR2hwVFZac05WVXlkR3RoYkU1R1YyMW9WMkpHY0ROVmVrWjNWbXhrZEdSR2FGZGlhMHBJVmtkNFlXSXhWWGxUYTJ4U1lrZDRXRlJXWkZKa01XeFZVMnR3YkZJd2NFaFhhMlJ6VlRKS1dHRkliRmRXUlVweVZsUkdZVkl4Vm5OYVIyaFRWbFJXV1ZaR1dtRmpNRFZYVld4a1ZtRXdOVzlWYWtKM1ZqRnJkMVp1WkZkaVJtdzJWbGMxWVZZd01YVmhSMmhYVFVad1dGcEdaRTlTTWs1SFdrWmtUbFpZUW1GV2FrWnZaREZKZVZKWWJGVmlSMUpZV1cxek1XRkdWbkZUYWxKWFVteEtXRlp0ZUd0VWF6RlhZa1JTVjAxdWFGQldWekZIVG14S2MyRkdXazVXTW1nMlZtMTBhMUp0VmxkV2JsSm9VbXh3Y0ZZd1pHNWxiR1JWVVcxR1YwMXNTa2RVYkZwaFZsZEtTR0ZJUWxaaGExcE1Wako0WVZJeFduUlBWMnhPVm01Q05WWkdXbUZoTWtaWFUydGtWR0pIYUdGWmExcExWMFphY2xkdVRtcGlSMUo1VkRGYVUxVXlTa2RpTTJoWFlUSlJNRmRXWkVkV01YQkdZVWRvVTJWdGVGbFdWekUwV1ZkR1IyTkZWbE5pVlZweVZXMTBkMlZXYkZaYVJFSldUVVJHTUZsVldsZFdNa3BaVld4b1dGWnNjRXRhVlZwcll6SkdSazVXWkZOaE0wSXpWbXRhWVdFeFZYbFdiR1JXWWtkU1dGbHNVbk5pTVZaMFkzcEdWRkp0ZEROV01qQTFWMGRLUjJKRVdsZFdNMEpRVm1wR1MxWXlUa2hTYlVaWFZtNUJlbFpYTVRSa01VbDRWbTVPWVZJeWFITlphMXB5WlZaYWRHTkZkRTVTTUZZMVZURm9jMVV5UlhoalJUbFhZa2RTVkZrd1dsZGpiR1IxV2tab1UySkZjRnBXUjNocVRsZEdSMU51VW14U2JIQlhXV3hvVTAweGJISlhhM1JxWVhwV1dGa3dXbmRXTVZwMVVXeFdXRlpzY0hKVmFrRXhZekZrZFZWc1FsZGlWa3BaVmtaU1MySXhXbGRYYmxKcVVsZFNiMVJXVm5OT1ZsVjVaRWhPVjJKVmNGcFdWM2hUVmpBeFIyTkZlR0ZXYkhCeVZqQmtVMU5HU25Sa1JUVnBVbTVDU2xadE1IZE5WbFY0Vlc1T1dHSkhhRmRaYkZKelZqRnNjbGRyZEZSU2JHd3pWako0WVdKR1dYZE9WV1JYVWpOb2NsWkhNVVpsYkVaMFVteG9WMkpHY0RKV1dIQkhWMjFXVjFSdVRsZGlSVFZ2VkZSS2IyRkdXa2RhU0dSVFRWWmFTRlpzYUd0V01WcEhWMnhvVlZadFVsUlVWVnB6Vm14d1NFOVdWbWhsYTFwSVYxZDBVMVl4V1hsVGJGWlNZV3hLVmxac1duZGxiRmwzVjJ4T1dGWXdjRWhXTWpGdlZHMUtXR0ZHYkZkTlZuQlVWV3BLVW1WV1VuVlViR1JwWWtWd2VsWlVRbXRWTVdSSFZtNVNUbFpHU25OWmExcHpUbFp3UmxWclRsaFNhMnd6V1RCV2IxZHJNVWRYYmxwWFlXdHdURlpzV2tkV1ZrcHpZMFprYVZKc2EzZFdNVkpMVGtkRmVWUlliRlJoTWxKWldWaHdWMk5HYkhOYVJ6bFBWbXh3TUZrd1ZrOWhSVEZXVFZSV1YxWXphSEpXVkVwTFkyczFXRTlXV21sWFIyaHZWbXBDWVdReFpFaFdhMmhUWVhwV2NGVnFSa3RPVmxsNVpFWk9WazFyV25sVVZscHZWbTFGZVdWR2FGcGlSMmhVV1ZWYWMxWldTbkprUjNSVFRVWndTVlpzWkRSa01rWkdUVlpzVWxkSGVGbFphMXBoWVVaa1YxZHRSbGROVmtveFZXMTRZV0ZXU1hoVGJFSlhZbFJDTkZSVVFYaFdNV1J6Vm14U2FHRXdjSFpXUm1Rd1dWZFdjMVpZYkd0U00xSnZXV3RXZDAxR2JGWlhiWFJZWWtac05sWkdhRzlaVmtsNllVaHdWMkpZYUhKYVJWcExaRWRPUjFwSGFHeGlSbXQ1Vm0weE1HRXdOVWRXV0doWFYwZDRWVmxVU2xOalZsWnlWMjFHV0Zac2NEQmFWV1JIWVcxS1IxTnNaRmROYm1ob1dXdGFZV05yTlZsalJtaG9UVmhDVlZkV1dtRlRiVlowVW10a2FWSnRVbGhhVjNSV1pERlplRmR0ZEZOTlZXdzFWV3hvZDJGV1NsVldiR2hhWWtad1RGWXhXbUZTTVdSMFpFWmFUbEpGV2xsV2FrbzBZakpHZEZadVNsaGlSM2hYV1d4b1RtVkdWbkZTYkZwc1ZqRmFSMWRyV210VWJVVjZVV3hrVjFadFVqTldWRVphWlVaa2NsZHNUbWhpUlhCWVYxWmtNRmxYUmtkWFdHaGhVbGhTVlZWcVJrdFRSbHBJVFZSU2FGWnRVa2xaVldSSFZqSkdjbGR1U2xWaE1YQmhXbFphVjFkWFNrZGFSMnhUVFZWd1lWWnRjRU5oTURWSFZWaG9XR0pzV25GVk1GVXhWMVpXZEdWRmRGaFdia0pIV1ZWa01GWXhTbkpqUkVKaFVsWktVRlpxUmxwbGJGSlZVbXhrVGxJeFNrMVdWM0JMVkRGSmVWSnJaR3BTVkZaVVdWUk9RMVZzV25STlNHUnNVbXN4TkZkcldtOVZNa1Y1WVVjNVZtSlVSbFJXUkVaaFkxWktjbVJHVWxkaVNFSmFWMVJDVjJFeVJYZE5WbHBwVWtaS1lWUlZXbUZrYkd4WFYydDBhbUY2VmxwVlYzaHJZVVV4YzFKcVRsZFNla1V3VjFaa1UxTkdVbkpYYlVaVFltdEtXVmRYZEd0Tk1ERkhWMjVHVkZaRldsVlVWbHBMWld4WmVVNVdUbWhTYTNCNlZUSXhSMWRzV2taalJsSlhZVEZ3YUZsNlJtdGtWbEowWTBkc1ZGSlZjRXBXYlhScVpVZE5lRlZ1VGxoaWEzQnhWVzB4VTFkR1duSldibHBPVW14d1JsVnRNVEJWTURGV1RsUkdWMVo2UlRCV2ExcEtaVzFHUjJOR2FGZGlSWEJKVjJ0U1IxVXhTWGhhU0Vwb1VqTm9WRll3V2t0bFZscFlZMFZrV2xack5YcFphMXBoVjBkS1ZsZHNXbHBpUmxveldsZDRWbVZIUmtsYVJtaFRZa2QzTWxac1kzaGlNV1JIVjI1U1ZtSkZTbWhWYkZwM1ZrWnJlVTFWZEZSU01EVklWa2N4YzFZd01YUmFNMnhYWWxoU2FGZFdaRXBsUmtwWllVWm9hVkl4U205V1Z6QjRWVEZrVjJKSVRtaFNhelZZVm0xNFMxZEdXblJPVjNSVllrVndlbGt3Vm5OWlZrcFlZVVpDVjAxR2NFdGFSRXBQVW0xS1IxcEdaRTVOYldkNVZtcEdZVmxXWkhSV2JrNVhZbXMxYUZWcVFtRldSbFp6VjI1a2JGWnRVbFpWTW5CVFZqQXhjazVZY0ZwTlJscDJXVmQ0UzFaV1duTmhSbkJwVWpKb2VGZHJVa2RaVjA1WFZHNUdVbUpYZUU5V2JURXpUVVphY1ZOcVFtbE5WbkJKVld4b2MyRkdTblJWYlVaYVlrZG9WRlpGV210V01XUjFWRzF3YVZJeFNYaFdNblJoVmpGVmVWTnJhR3RsYTBwWVdWZDBjMDVHVm5GU2JYUlRUVlUxZWxadGVFOWhWa3AxVVd4c1YySlVWak5WYWtGM1pVWmtjbUZIZUZOWFJrcFZWMWQwVmsxV1duTldiR2hzVWpOU2IxVnFRbGRPUm10M1ZXdDBXRkp0VWtwVlYzUnZWakZhTmxKc2FGWmhhMW96VlRGYVUyTXhjRWhpUm1ST1RXMW9WMVpxU2pSaGJWWkdUbFZrV0ZkSGFGbFpiWGhMVkRGYWNsZHJkRnBXYkhCNFZXMHhSMkpIU2tkalJteFZZa1paZDFZd1drcGtNazVHWTBaYVYyVnNXbEZXYlhCTFVqSk9jMXBJU214U2JIQlBWbTAxUW1Wc1dsaE5WRkpvVFd4S1dGa3dWbXRaVmtwVlZtMDVWVlpzY0hsYVZscGhZekZrZEdSRk9WTk5WVmt3Vm1wR2IyTXhXa2hTV0d4b1VtMVNZVlpxVGs1bFJsbDNWMnhrYW1KR2NEQlZiWGgzVmpKS2NsTnNhRmRoYTNBMlZHeGFhMUl4WkZsYVJUbFhWak5vYUZadGVHRmtNVlpIVjJ0b1RsWllVbGxWYWtKaFUxWlJlRmR0ZEZWaVZYQXdXVlZvYzFZeFNuTlhiV2hhWld0YWNsVnFSbGRrVmxwelZtMXNVMDF0YUdGV2JHUjNVekpKZVZOWWFGaGlSMmh6Vlcxek1XTldVbGRYYm1SVVVteHdXVnBWWkRCaFJrcHlZMFprVldKR2NGUldiRnBoWXpKT1JtVkhSbGROTW1oNVYxUkplRkl4U25KUFZtaG9VbXMxY0ZVd1ZrcE5WbGw0Vld0T1dsWXhSalJXTWpWUFYwWmtTVkZzVGxwV1JUVjJWakJhYzFkSFVrbGFSbFpUWWtoQ05sWnFTakJOUm1SSFYyNVdVbUV5YUZsWlZFWjNZMnhhVlZKdFJtdFdhMXA2VlcxNGExUnRTblJoUm14WFRWWndhRlpYTVZkU01rNUdXa2RvVTJKRmNIWldSbVEwVXpGa1YxcEdhR3hTTTFKUVZXcENjMDVHV2xobFJtUldZbFZXTmxaWGVHdFdNa3BaWVVST1ZWWldjRlJXYlRGSFUwZFNTR0pHVG1oTk1Fa3lWbTB3ZUdReFdYaFhia3BPVm0xb2IxVXdXbmRYUm14WVpFaGtWVkp0ZERWYVZXUXdZV3N4V0ZWdWNGcE5SMUo2VmxSS1JtVnNSbFZUYkdScFYwVktSVll4V21Gak1XUkhWbTVLYUZKdFVtOVVWekZ2Vmxaa1dHVkhPV2xOVm5CSVdXdG9TMkZHU2xaT1ZsWmFZVEZ3TTFVd1dtRmtSMVpHVDFaa1RsSkZXbHBXYkdRd1lqRmFjazFZUmxkaVJVcGhWbXBPYjFWR1ZYaFhhMlJyVW10d2VsWnRlR3RXTWtweVUyNWFWMDF1VW5KVWExcHJaRVpXV1dGSGNGTldia0phVjFkNGIySXhaRWRWYkZwWVltMVNWVlJXV25kV2JGVjVZMFpPYUZKVVJubFdNblJ6Vm0xS1NHRklTbGROUm5Cb1ZXMTRUMk15UmtkalIyeFRUVzFvUmxac1VrTlpWMDE0VjJ4a1ZXSnJjRkZXYWs1VFZrWnNWVlJyVGs5V2JHdzFXa1ZrTUZVd01WZFdhbEpYVFc1U2NsWXdaRXRrUmxaellrWmthR0Y2VmxWV2FrSmhaREZLVjFOdVVtdFNNMEpQVm1wR1NtVkdXbk5aTTJoUFVteFdOVlZ0Y0dGV01rcEhZMFpvVm1KWWFETldha1ozVm14YVZWSnNUazVXTVVwaFYxZDBWazVXV1hoWGEyaHNVakpvV0Zsc1VrZE9iRkpYVjJzNVUwMVhVbHBaYTJRMFZUSktWMU5zY0ZoV00yaFlWbXBCTVZZeFpITmhSM2hUWVhwV1dsZFdhSGRTTVU1SFlUTmtZVkpYVW1GV2JYUjNVakZaZVU1VmRGaGhla1o0VlcxNFUxWnJNVWhWYTNoV1lsaE5lRlpxUm5kU2F6VlhXa1prYkdKWFkzaFdiVEIzWlVkUmVGUllaRTVXVjFKWVZqQmtiMWRHV1hkYVJGSlhVbTE0VmxWdE5XdFdWVEZYWWtST1YySlVWbkpXYlhoTFl6SktSVlJzY0ZkV2JIQlJWbXBDWVZsWFVraFdhMlJZWWtad1QxbFhkRVpsUmxwMFkwVmtWRTFyTVRWV1IzUnJXVlpLZEZWck9WcGlWRVoxV2xkNGExZEhVa2hTYkdocFZtdFpNRll5ZEc5VE1rWkhVMjVTVm1KSGFGWldhMVozWkd4d1YxZHRkRmROVm5CNlZqSXhORlV5U2toa2VrWlhZVEpSZDFscVJsZFNNV1IxVld4YWFWWkhlR2hXYlhSWFdWVXdlR0pJUmxOaVdGSllWRlphWVdWV1pISlhibVJYVFd0d1NWcEljRU5XTVZwR1lUTm9WMkZyV21oYVJWcFBZMnhrYzFWdGJGTk5iV2hZVm0weE1GWXhUWGhWYTJSWVlrWndXVmxzVm1GamJGWnpWV3RrVkdKSGVGZFdiRkpIVmxkS1JtTkZaRmROYm1oNlZtcEtSMk50U2paUmJHUm9ZVEZ3YjFaVVFtRlRNbEpYVlc1T1ZtSlhlRzlVVm1oRFYwWmFkRTFJYUU5U01VWTFWVzEwYTFadFNrZGpSbXhhWVRKU1ZGa3hXbE5YUjFKSVVteFNWMkpyU2toV2FrbzBZVEZhV0ZOclpHcFNSVXBvVlRCb1ExTkdXWGRYYlVacVRWZFNNRmxWV25kaFIwVjRZMGhzV0dFeFdtaFZla1pyVjBaT2NscEdhR2xXTTJoVlYxWlNUMUV4WkhOWFdHaFlZa1UxVkZSWGVFZE9WbFowWkVkMFdGSXdjSHBWTWpWUFZtMUdjazVXVWxwTmJtaG9Xa1ZWTVZac1VuTlZiRTVwVTBWS1MxWnJXbUZpTVZGNFYyNUtUbFpXV2xSWmEyUlRXVlpzZEU1VlRsVlNiSEI0VlRKME1GZEdXbk5YYWtaV1lsUkdTRlpxUmxwbFJrNXpWV3hvYVZKdVFtOVdXSEJMVkcxV1NGUnJXbUZTYkhCd1ZXcEtiMVpXV2tkWk0yaHBUVlpzTkZZeU5WTmhiRXBXVGxjNVZWWnNjRmhVYTFwclkyeGtkR1JHYUZOTlNFSTJWbFJKTVZReFduUlNia3BVWWxkb1lWbFhkR0ZYUm5CR1drWmtWRlp1UWtoV1J6RnpWVEpLUjJFemFGZE5ibEpZV1ZSQmVGSXhjRVphUmxKcFlUTkNlRlpVUW10T1JteFhWV3hhV0dKdFVrOVVWbHB6VFRGa2NsWnRSbWxTYkhCNlZqSTFiMVl4U1hwaFNFcFhZV3RhVEZacVNrOVNhekZYV2tkb2FFMVlRblpXYkdSM1V6RlNkRlpzWkZWaWEzQm9WV3BLYjFaR2JITlhhM1JyVFZad1dWcFZZelZWYXpGV1RsaHdWMDFYYUhwWlZFWkxZMnMxVjFac1ZsZGlSbkEyVmtkMFlWWnRWa2hTYTJoUVZtNUNXRmxZY0ZkVFZscHhVMnBTVmsxWFVqQlZiR2h2WVd4S1dXRkhSbFZXVm5BelZqQmFjMDVzVG5KYVJrNXBVbXR2ZDFkc1ZtdGpNVlY1VTI1S1UyRnJOVmhaVkVaM1lVWnNjVk5zU214U2JGb3hWa2Q0YjJGWFNrWmpSbWhZVm5wQmVGVlVSbk5XTWtwSFZteE9hV0pXU25aV1Z6RTBZekF3ZUZwSVNsZGhhMHBZVkZaYWMwMHhhM2RXYms1WFZsUkdXRmt3YUV0WGJGcFlWV3RrWVZKRmNGQlZha3BMVWpGd1IxUnJOVTVXV0VJeVZtcEdVMU50VmtkV2JsSlhZVEpTY1ZWc1pEUldNV3h5VmxSR2FsSnNXbmhWTWpBMVZqRmFkRlZzYkdGU1YwMHhWbGN4UzFZeFNuRlZiR1JPWVd4YVVWWnFRbXRUTVVweVRsWmtWV0pHV2xoWmEyaENaV3hhUjFadFJscFdNVXBIVkd4YVlXRXhTblJoUmxKVlZsZG9RMXBWV21GV01YQkZWVzFzVGxZeFNqWldha1p2WkRGYWRGTnNhR2hTTUZwV1ZtNXdWMlJzVWxWU2JHUnFWbXR3TUZwRlpIZFViR1JHVTJ0d1dHRXhXbWhXUkVaVFl6RmtkVlpzU21oTk1FcFpWMWQ0YjJJeVRuTlZia3BZWWtWd2MxVnRNVk5YYkd4V1YyeE9hRll3V1RKV2JUVnZWakZhTmxKcVdsVldiSEJ5VldwS1MxTldVblJoUms1c1lsaG9ORlp0TUhkTlZrVjRWMWhvV0dKck5WZFpWRXBUVjBaV2RHUklaR3hpUm13MVdsVm9hMWRIU2tkalJtaGFUVVp3ZGxZeWVHRmpNazVHWkVkR1YxWnVRbEZYV0hCTFVqRkplVkpyWkdGU00yaHZWRlprTUU1V1duUmtSMFphVm0xNFdWVnNhRzlXUm1SSVlVZG9WazFHY0doV2JGcHpZMnh3U0U5WGNGTmlTRUkyVm1wSk1XRXhaRWhUYTJScVVtMTRWbFpzWkc5a2JGcEZVbXR3YkZKdFVqRlpNRnByVkcxR2MxZHNWbGRoTVVwSVZqSXhWMk14V25WVWJXaFRZa1p3V1ZadE1UQmtNVTVYVjI1R1UySlZXbkpVVmxaM1pXeGFkRTVWZEZaU2JIQXdWbGR6TlZkc1drWk9WVkpYWVd0YWFGcEZWWGhXVmxaelUyczFWMkpZWTNoV2JHTjNUVlpOZUZaWWJGTmlhelZWV1d0a2IxbFdXbkZVYkU1T1RWWndSMVl5ZUd0aGF6RllWV3BDWVZKWFVqTldSM2hyVW14T2NtSkdaR2hOYXpRd1YxaHdSMVp0VmtkalJWcFlZa1pLYjFSVVJrdFhWbVJZWlVaT1VrMUVWa2haTUZaWFZUSkZlVlZ1U2xaaVdHZ3pXbFphYzFac1pIUlNiV2hYWVRKM01WZFdWbUZXTVdSSFYyNU9WR0V6YUdGWlYzUmhZVVpXY1ZOcmRGUldiRXA2VjJ0a2MxWXhXblZSYlVaWFlrZE9ORlJyV2s1bFJtUjFWR3hrV0ZJemFGQldWM1JoV1Zaa1YxWnVVbXhUUjFKUFZXMTRkMWRXVW5OaFJUbFhUVVJHZVZrd1dtRldiVXBJWVVoS1YyRnJXbWhWYlhoTFkxWldjMXBIYkZkU1ZuQk9WbXhrTkZsV1dYbFVXR3hUWVRKb2IxVnNVbGRqUmxweFUyMDVWVTFXY0RCVVZsSkRWbXN4Vm1KRVVscGhNWEIyVm14a1MyTnRUa2RSYkdScFZrVlZkMVpzVWtkak1rNTBVbXRhVldKSGFGUlphMXAzVG14YWRFMUVSbHBXTUhCSVZqSTFUMkZzU2xoaFJtaFZWak5DU0ZVd1dscGxWMVpIWTBkMFRsSkdXbGxYVmxaaFdWWlNkRkp1VGxoaVJscFlXV3RhWVdGR1dYbE5WbVJxVFZad01WVXllRU5XTWtwWFUyNWtWMVl6UWtoVmFrRXhZekZrY2xwR2FHbFdWbkJvVm0wd2VGVXhUbGRYYmxKclVucHNWMVZ0ZUhOT2JGWllZM3BXVjAxcmNGWldiWFJQV1ZaS1JsZHRhRmROUjFKWVZUQlZOVmRIVGtaT1ZtUnBZVEJaZWxadGVGTlRNREZJVWxob1lWSlhhRlZaYTFwM1YxWnNjMVp0UmxwV2JYaFdWVEo0VDJFeVNrZGpSVnBXWWxSV2NsWnFTa3RUUmxaeFVteGtVMDB5YUhsWFZscGhVMjFXUjFSdVJsaGlSMUpQV1cxNFMyVldaSEpWYTJSV1RXc3hORmRyYUZkV1YwcFpVV3hTVm1KVVZrUldNVnBoVWpGc05sSnNXazVoZWxZMlYxZDBVMWxXVlhsVGExcFBWMFZhVmxadE1XOVNSbFp4VW14d2JGWXhXa2hXUnpGdlZqSkdObFpyYUZkV1JXOHdXa1JHYTFJeFpGbGpSbHBwVmpKb1dsWnRNSGhWTVU1SFZtNUdWR0Y2YkZSWmExcDNaV3hhU0UxWVRsWk5WbkJJVmpKd1YxWXlTa2hVYWxKaFZqTk9ORll3V21Gak1YQklVbXhTVTFkRlNuWldiRkpEVm1zeFYxZFlhRlppUjFKWVdXMHhVMk14V25STlZFSk9UVlpzTlZSc1ZUVldNREZGVW01c1drMUdjRE5XYlhoYVpXMUdSbFZzWkdoaE1YQnZWbGN4TkdFeVRYbFNhMlJZWWxkb2IxUldhRU5PVmxsNVpFZEdXbFpyTVRWV1JtaHZWbGRLY2s1WE9WWmlXRTE0VmtSR2MyTXhjRWhPVlRWVFlraENORlpYTUhoTlJsRjRVMjVPYVZKR1dsaFdiVEZ2Wkd4YWNscEZkR3BoZWxaWVdXdGFkMkZGTVhOVGFrcFlWMGhDU0ZacVNrOVdNVloxVkd4V2FWWXphRkJXYlRBeFVXMVJlRnBJU2xkaVZHeFdWRlphUjA1R1dYbE9WazVwVW10d01GWlhlRzlXTWtwMVVXdG9WazFHY0doWk1WcEhWMWRHU0dOSGJGZFdSbHBLVmpGU1ExbFhSWGhYV0d4WFltczFXVmxZY0VkWFJteHpWV3RPVDFKc1dUSlZiVEZIVmpBeFZrNVVSbGRTZWtaMlZsUktTMVl4VG5OUmJHUlhaV3RHTkZaV1VrZFZNVmw0WTBWa1YySkdTbTlaYTFaM1pWWmFSMWRzV2s1V2F6VklWbXhvYzFReFdsVmlSbWhYWVd0S00xWXhXbmRXYkd3MlZteGtWMkpJUWxwWFZsWlhWVEZrYzFkc1pHcFNNbWhvVld4a1UxZEdWbkZTYkU1cVRWVTFlVlJzV210aFZtUklWR3BPVjJKVVJYZFhWbVJLWlZaS1dXRkdXbGhTTW1odlZsZDRZV1F4VmtkWGJsSk9Wa1pLWVZadE1UUmxiR3hXV1hwV1YxWnJjSHBaTUZaaFZtMUtWVkpyYUZwV2VrWk1WVEJhVjJSWFNraFNiRTVYWW10R05sWnRNWGRUTVUxNFZHeGtVMkpyV2xkWmEyUlRWMFp3V0dSR1pFNU5WbkJJVm0weFIyRkZNVlppUkZKWVlUSm9XRlpzWkV0WFZrWnpWV3hrYUdGNlZqSlhWM0JIV1Zaa1NGWnJhR3RTYkhCUFZteFNWMU5XV25GU2JUbHFUV3R3U0ZVeGFHdFhSMHB5VjIxR1dtRXhjR2hVVkVaWFpFZFdSMk5IZUZkTlZuQktWMnRXWVdFeFVuUlRhMlJxVWtad1dGbFhkSFprTVZweFVteHdiRlpyTlhwV2JYaExZVWRLUm1OR2FGaGlSMUYzVjFaa1QyTXhaRmxhUm1ob1RURktlRmRYZUZkWlZrNUhWMnRvVGxkRk5WZFVWM1IzVTJ4V1dHVklaRmROUkVaWlZsWm9hMWR0Um5KWGEyUmhWbXh3YUZsNlJuZFRSa3B6Vkcxc1dGSXlaekJXYlhoclRrZEZlRlpZYUdsU2JWSlpXVzEwWVZaR2JGVlViRTVYVm14YU1GcFZXbXRVTVZwelUyNXdWMDF1VFRGWlZWcExWbFpLYzFwR2NFNVNia0p2Vm0xd1MxTXhXbGRTYkZaVFlrZFNjRlZ0TlVOaU1WcFlUVlJTVlUxck5UQldiWFJyVjBkR05sWnVRbHBpUjFKMldrZDRXbVZIUmtsYVJrNU9WbTEzTVZacll6RlZNVnBZVWxob2FsSnJTbGhaYkZKSFZrWnJkMWRzWkdwTlYxSXhWVEl4TUZSc1duVlJhbEpYVmtWd00xVlVSbHBrTURGWlUyMXNVMUpyY0ZsV1JtTXhWVEpTYzFkdVNtRlNXRkp4V1Zod1YxZEdXblJsU0dSb1ZtMVNSMVJXVWxOV01rcFpVV3RvV21WclduSlZNRnBYWTJ4a2RHUkdUazVpVjJoV1ZqRmtNR0l4Um5SVldHaGhVMFUxV0Zsc2FGTldSbEpZWkVkR2JGWnNTbGhXTWpWUFZtMUtWbFpxVmxwV1ZuQjJWbTB4UjJOck5WbFhiSEJYVm01Q2IxWlVRbXRXTVU1SFUyNVNhbEl5ZUZoV2ExcGhVMnhaZUZkc1pGcFdNRlkxVlcxMGIxVXhaRWhsU0VwaFZqTlNURll3V21GalZsSnlWR3hTVTJKSGR6RldSbHBoWVRGVmQwMVdiRkpoTTBKWVdXeG9iMVpHYkZaYVJtUnJVakZhU0Zrd1dtdFdNREIzVTJ4R1dGWXpRa2haVkVwT1pVZE9SbHBIUmxOaVNFSjJWa1prTkZNeFpGZGFSbVJvVTBkU1ZGUldaRk5UUm14eVlVVjBXRkl3Y0ZwV1YzaHpWbTFHY2xOc2FGVmlXR2hvVmpCa1YxTldVbk5hUlRWb1RUQkthRlp0ZUdwbFIwbDRZa1prV0ZkSVFtOVZNRlozV1ZaU1dFNVhPV3BpU0VKSFYydGFUMVV3TVZsUmEyUlZZa2RTZGxaSGMzaFNiVTVJVW14a2FWZEhhSGxXUjNSclUyMVdWMU5zYkdoU01GcFVWbXBHUzFkc1pGaE5XSEJPVm14d1dGbHJXbGRXUjBwVllrWnNWbUpZYUV4V01WcHlaREZhZEdSR2FGTmhNMEkyVm1wSk1XSXhXblJUYkd4b1VtdEtZVlpyVm1GaFJtdzJVbXM1YWxaclducFdNakZ6VjBaSmVXRkdTbGRpV0ZKeVdsY3hWMUl4VG5WVmJGWm9UV3hLV2xkWGRHdFZNazVIVm01R1UyRXhjSEpVVm1SVFYxWnJkMVp0ZEZaTmEzQllWakowYjFkck1VZFhibkJYWWtkU1RGVXdaRWRUVmtaelkwZG9UbFp0T1RaV01uaFhXVlpzVjFwRmFGZGhNbEpXV1d4b1ExUXhXblJsUm5CT1VteHdlbGRyVWxOaFJURllWV3RzVm1KSGFETldiVEZMVWpGa2MxcEdjR2xTTW1neVZrWlNSMVV4V25OYVNFNVZZbGhDVDFadE5VSmtNV1J5Vm0xR2FFMVdTbnBXTW5odllUQXdlbEZzYUZwV00xSm9WbXRhVjA1c1NuTmpSM2hYWVhwV05sWnRNVFJoTWtaWFUyeGFhbEp0ZUZsV2FrNXZWa1pXY1ZKc1RsTk5WMUphV1ZWa1IxVXhXWGhUYkZaWVZqTm9hRmRXV2s5U01XUjFWVzE0VTAweFNuWldiVEY2VFZaSmVGWlliRTlXTUZwWVZGZDBkMU5HVlhsa1JrNVhUV3R3VmxWdGVHOVdiVVp5VjJwT1ZtSllhSEpaZWtaSFl6RndTR0pHWkdoTk1FcHZWbTF3UjFsWFNYbFZXR2hZVjBkNFZWWXdaRzlXTVd4eVYyMUdWazFYZUZaV1IzaFBWakpLUjFkcVFtRldWMmh5V1d0a1MxSXlTa1ZXYkZaWFlsZG9lVlp0ZUd0VE1VbDVVMnRXVldKSFVuQldNRlpMVmxaYWRHTkZTbXhTYlZKSlZXMTBjMkZzU25SVmJUbFZWak5vVEZaR1dtRldWa1owWkVaa1RsWlhkekJXYkdNeFZESkdjMU51VWxaaVJrcFlXVlJHZDFsV2NGZFhiVVpxVm10d01GVnRlSGRXTURGRlVsUkNWMDF1VWxoWmFrWmhaRVpLV1dKSGFGTmlSWEJvVjFkMGEySXhTa2RoTTJSWVlrZFNjbFZxUm1GVGJHUnlWbFJXVmsxcmNFcFZWM2gzVmpGS2MxZHNVbFpoYTNCSVZXMXplRll4Y0VkYVIyaG9aV3hhV0ZadE1IZGxSMGw0Vld0a1dGZEhVbWhWYkZwM1l6RmFjVkp0UmxSV2JYaFhWakl4UjJGR1duSmpSRVpXVm0xb00xWnFTa3RTTVdSMFlVWm9WMkpJUWxGV1ZFSmhXVmRPYzFwSVVtdFNhelZQVkZaV2QxZHNXWGhYYkU1VFRXeEdNMVJzYUU5WFJtUklaVWhLVm1GclNtaFpha1pUVjBkU1NGSnNUazVXYTNCWlZtcEpNVlF4V25SVGJGcHFVbXh3WVZsVVJuZGxiRnB4VTJ0MFdGWXdXa2RhVlZwaFZHeEtkVkZ0T1ZoaE1WcFhXbFZhV21WSFRrWmFSbFpvWld4YVdWZFhkR3BPVlRWSFYyNU9WbUV6UW5OVmJYUnpUa1phYzJGSVRsZFNNSEJKV1ZWak5WWnRTbFZXYTFKWFRVWndhRmt4V2xOamJGSnpWMnhPYVZkSFp6QldiRkpMVGtkRmVGZFlaRTVXYldoWFdXMDFRMWxXV25OWGJGcHNVbXh3ZVZZeWRIZGlSbGwzVjJ0b1dsWldjSEpXVkVwTFUxWkdkRTlXYUZoVFJVcEVWa1phWVZOdFZrZGpSV3hWWWxkb1ZGUlVTbTlXVm1SeldUTm9UMUl4U25wV01uUnJWMGRLUjJORk9WZGlXRTE0VmpCYVdtVlhWa2hQVjJ4VFlUTkJkMVpzWkRSaU1WcFhWMWh3Vm1Gck5WaFVWelZ2Wld4YWRHVkdaR3BoZW14WVYydFZNVlV4U2xkalJuQlhUVlpLUkZkV1dsWmxSbkJKVld4a2FXRXpRbHBYVjNocllqSkdSMVp1VG1GU2F6VllWVzE0WVdWR1ZuUk9WM1JXVFd0Wk1sWnRlRzlYUjBWNVZXNXdXbFpXVmpSVk1HUlRVbFphYzFwSGJGaFNWWEJLVmpGYVUxRnRWa2RUV0doWVlrZDRiMVZxU2pSV1JteHpWMnQwV0dKR2NIaFZWekV3WVZVeFdGVnNhRnBoTVhCMldXdGFUMU5HVm5OaFJscHBWa1ZWZDFaR1ZtRmtNVnAwVW10b2ExSnRhRlJaVkU1Q1pERmtjMVp0T1d0TlZtdzBWakZvZDFadFNuSmpSbWhhVmtWYU0xWkZXbmRTYkhCSFZHeE9WMkpJUVhkV1Z6RTBZVEZaZDAxV1dsaFhTRUpZVkZaYWQxWkdWbkZTYXpsclVteGFXbGxWWkVkV1JrcFpVVzVhVjFaNlFqUldWRVpTWlVkS1NWVnRjRTVOYldoUlZsY3hOR1F5Vm5OWGJHaHJVbGhTY0ZWdGRIZGxiR3QzVld0T1YwMVZiRFpXVnpWTFYyeFplbUZGZUdGU1ZuQllXa1phUjJNeFpIUmhSMmhPVjBWS1RsWnFTalJoTURWSFlrWmtZVkpYYUZaWlZFWjNZVVpXZEUxV1RtcFNiSEF3V2xWb2ExZEdXbk5qU0hCWVlURktWRmxYYzNoamJHUnlZVVphVG1Gc1dsVlhWbFpoVkRGS2MxUnVVbE5pU0VKWVZXeGFkMkl4V2tkVmEyUnJUVlZ3V0ZVeU5WTlZNa3BJWVVaU1YyRXhXbWhYVmxwclZsWkdjMWRyTlZkaVIzZDZWa1phVjFZeFdYbFNXR3hzVW0xNFdGbFhjekZXUm14V1YyMUdhbFpyY0hwWGEyUXdWVEpHTmxacVZsaFdNMUpvVlhwS1IxTkdXblZWYlhoVFlsZG9XbFp0Y0U5aU1sSnpZa2hHVWxkSFVuTlZiWGhoWld4WmVXVkhPV2hXTUhCWVZUSjRjMWRHV1hwVmJscFdWa1ZhUzFwVlduZFRWazV6WVVkc1YxSXphREpXYlRCNFRVZFJkMDFWWkdwU1ZscFdXVzB4VTFkV1ZuUmxTRTVQWWtad1dWcFZXazlXTURGeVYyNXNWMDFxUm5aWFZscExWakpPUjFGc2NFNWhhMXBKVmxSQ2ExSXhTWGhXYms1VllsZDRiMVJWYUVOaFJscDBUVlJDV2xac2JEUlphMXB2Vm14a1NHVkdXbHBpV0UxNFZqQmFXbVF4Y0VkVWJXaFRZa1p3TmxZeWRHRlVNVmw0VTI1T1ZHSkhhRmhVVjNCWFkyeHNjbHBGZEZSU01VcEdWa2Q0YjJGRk1YUmhSa1pYWVd0S2FGVjZTazlrUmxKeVdrWm9hVkp1UW5kV1Z6RXdaREZLVjFkdVVtcFNWWEJ6VlcxNGMwNUdXa2hPVlhSb1VtdHdNRmxWV205WGJVVjVZVVZTV2xaV2NISlpla1pyWkVaS2MxcEZOV2hsYkZZelZteGplRTFIUlhoaVJtUlVWMGQ0YjFWc1VuTlhSbEpXVjIxR1ZWSnNTbnBXTWpGSFlXc3hXR1JFV2xoaE1sRXdWbFJLUzFJeFpGVlJiR1JwVW01Q01sZFhjRWRoTVU1SFZHNVdWV0pHU25CVmJGWjNWMVprV0dSSFJsZGlWbHBJVmpKNFlWZEhTbFpYYmtwV1lXdGFhRlV5ZUd0amJGcFZVbXhhVG1FelFraFhWRUpoWWpGa1IxZHVUbGhpYTFwV1dXdGFkMkZHYTNsak0yaFhZa1p3ZWxaSE1YTmhWbVJJWVVad1YyRXhjSEZVVmxwV1pWWldkVlJzYUdsaVJYQjRWa1pTUzJJeVRsZFhibEpzVTBkU2MxbHJXbmRYVm5CV1lVZDBWMDFFUmxkWk1GcHZWMnN4UjFacVVsZGhhMXBoV2xkNFIyTnRSa2RqUm1SVFYwVktWbFpzWkhkU01WRjVWV3hrVjJKck5WWlpiR1EwVmtaU1YxWnVaRlpXYkhCNVZqSjRhMVpyTVZaalNHeFZWbXhhY2xZd1dtdFRSMVpKVTJ4YWFHRjZWbFZXYkZaaFZqSlNSazFXVmxaaVIyaFlXV3RvUTFOc1pITldiWFJPVW14d2VWUldhRXRoYkVwWVpVZG9WMkpIVWs5VVZscGhaRVV4Vm1SR1pGZGhNMEY0Vm1wS05HRXlSa1pOVm14U1lXeHdXVlpyVm5aTlJteFZVMnhPVjAxck5VZFdNbmhEVmpKR05sWnVaRmRXUlVwWVZYcEdhMk14WkhWU2JGSm9ZVEJ3V0ZaR1dtRldNRFZYVm01T2FGSXpVbFpaYTJSVFVqRnJkMWR1VGxoaVJuQkhXVEJhVTFZeVNsbGhSMmhoVWxkU1dGVXhXbmRUUjFaSVlrWk9hV0V3Y0doV2JYUmhXVlpaZDAxVlpGZFhSM2hWV1ZSS2IxWXhiSFJPVlU1YVZteHdlbFl5Tld0VWF6RllaVVprVjJKSGFIWldNRnBoWTJ4a2RXSkdWbGRpU0VKNVYxWldWbVZHV1hsVWEyaFFWbTFTY0ZZd1ZrdFNSbHBIVjIxMFZXSldXa2hXVnpWWFZqSktSMU51UWxaaVJsb3pWakZhYTFkSFZraFNiRkpPVm14d1NWWnFTVEZWTWtwSFUycGFhVkpyTldGWmExcDNZVVpWZDFkc2NHeFdWRlpYV2tWYWIyRkhWbkpUVkVaWVZteGFkbFZxUm1GV01XUjFWRzF3VTJKWGFGZFhWM1JoWkRGWmVHTkdaR0ZTYlZKVlZXcEdTMU5HWkhKWGF6bFZZa1UxUjFVeWRITldNa3BIVTJ0NFZXRXlVa3RhVlZwM1UxWldjMVZ0YUU1aVYyZ3lWbXhrTkZsV1RYaFhXR2hXWWtad1dWbHRNVk5YVmxaMFRWUkNUMUpzYkRWYVJXUXdWMFpLYzJORVJsWldNMUo2VjFaYVlWWXlUa2RSYkhCWFlsWktTRmRyVWt0VU1VcDBWR3RrWVZJeWFHOVVWM0J5Wld4YWNWSnRSbHBXTURFMFYydFdhMVpIU25KalJteGFWMGhDV0Zac1dsZGpWazUwVDFaa2FWSXhTbHBYYTFaclVqSkZkMDFXYUZaaVIyaFlWRmR3VjFOR1duTmFSWFJYVmpCd1NWUXhXbUZoVmxwR1YyeFdWMkZyU21oV01qRlhWbXN4VjFac1NtbFNia0pRVmxkMFYxbFdaSE5YYms1aFUwZFNWRlJXV25OT1JsbDRZVWhrVjFac2NFZFdNbmh2VjJ4WmVsVnFUbGRTVm5Cb1dURmFTMk5yT1ZoalJUVm9UVEJLU2xacVNqQmhNazE0V2tWa1ZHSkdjSEZWYkZwM1YwWlNXRTVXVGxkU2JGcDRWVzE0UzJKR1NuUlZiSEJhWVRGd1ZGbFZWWGhqTVU1elkwWm9WMDB4U25sWFYzQkxWREZKZVZOclpHbFNNMEpVV1d4YVMxZHNXblJOU0doV1RWZFNXRmt3V21GWFIwcFpWV3hzV21FeGNIcFVhMXBhWlZkV1NFOVdaRTVTUlZwYVYxWldiMlF4WkhOWGExcFlZVE5vVjFsWGRHRlZSbXcyVTJ0a1UwMVdjSHBYYTFwcllVVXdkMU5yZEZkaVdGSm9WMVphYzFkR1VsbGhSbWhwWWtWd1ZWZFdVa2RrTWs1elZtNVNUbFpyTlZaVVZscGhaVlphZEUxVlpGZFNNSEJJV1RCb2QxZEhSWGhUYkZKYVZteFdORlpxU2s5VFYwcEhWbXhrYVZKdVFqVldiVEYzVWpGc1YxTnVUbUZUUlRWdlZXMDFRMWRHVWxWU2EzUnBUVmRTVmxVeWNGTmhiVXBYVjJ4c1YxSXpRbWhXVkVwTFUwWldjazlXWkU1U2JIQk5WbFJLTkdFeFpFaFZhMmhyVWpKNFQxWnRkSGRPYkZweVdrUkNXbFpzY0VsVk1uaFhZVlpLZEdGSFJscGhNWEJNVld0YVUxWldTblZhUms1WFlYcFdObFpVU1hoT1JsbDVVMnRrYWxJd1dsaFVWelZUVmpGU1YxZHNjR3hXYXpWNlYydGFVMkZXU25WUmJHeFlWbTFSZDFWNlNrOWpNa3BKVW14T2FWZEdTbFZXUmxwclZURmtjMXBJU21GU1YxSlhWRlpXZDJWV2EzZFhiazVYVFd0d1ZsVlhjRk5XVjBWNVZXeG9WMkZyV25KV01XUkxVbXM1VjFwRk5VNVdXRUpvVm0xNGFtVkZOVWhWV0dST1ZsZFNjVlZ0ZUhkaU1WVjNWbFJHV0ZKc1NsZFdWM1JyWWtaS2MxZHFRbUZTVjAweFZtcEJlR05zWkhWaVJscHBWMFZLVlZadGNFSmxSazVIVm01T2FGSnNjRTlXYWtaTFZWWmFXR05GZEZWTlZXdzBXVEJXYTFsV1NsVldiRkpXWWtaYWVWcEVSbUZrUjA1R1drZG9UbEpGV2twV1YzaHZZakZhVjFwRmFHaFNiRnBZVkZWa1UyUnNXblJsU0U1clVqRmFTVlZ0TVhkV01rcEhZak5rVjFKc2NHaFdSRVpoVm1zeFYyRkhlRk5pV0dodlZtMTRhMVV4VGtkaVNFcFlZbFZhY1ZSWGN6RlNiRlpZWlVoa1ZXSkZjSHBaYTFKUFZqSktXVlZzWkdGV1ZuQmhXbFphVTJOdFNraGpSazVwVmpKb01sWnJXbXBsUjBsNFZXeGtZVkp0VWxsWmJGWmhWbFpzYzFkclpFOVNiVko1V1ZWVk5WWXlTbFpqUld4WFZucFdSRlpxU2tabFIwNUlZVVphYVZKdVFubFhXSEJIWVRKU1IxTnVUbXBTYlZKUFZXdGFXazFzV1hoVmEwNVhUVlpzTkZZeU5WTldSMFY1Vld4V1dsZElRbnBXTUZwelkyeHdTRTlXVGxOaVJXOTNWMnhXWVdReVNrZFhXR2hVWVRKNFZsUldXbmRYUmxwSVRWVmFiRkl3TlVkWmExcHJWakZLV0dSRVVsZGlSa3BNVldwR1NtVkdVblZXYkZwcFZqSm9WVmRYZUdGVE1rWkhXa1prVm1FeVVuSlVWM1JoVTBaYVdHVkdaRlpOYTNCNVZHeG9SMVl5U2xsVmFrNVZWbFp3TTFWdGVHdGtSVGxYVjJzMVUxSldjRWhXYlRCNFRVZEplRmRZWkU1WFJscFhXVzEwZDFsV2JGaGtSMFpYVW01Q1IxWXljelZoYlVwSVZXcENXazFHY0ZCV2FrRjNaVmRHUjJOR1pHbFdSVll6Vm0xd1MxUXlVa2RYYmtwaFVtMW9jRmxVUm5kV1ZtUllaVVprV2xac2NGaFdiVFZUWVRGT1NGVnVUbFppV0doNlZHeGFVMVl5UmtaUFZtUm9aV3RhTlZkVVFtRmpNV1J6VjJ4a2FsTkdjRmhVVlZwM1dWWndXR1ZHWkd0U01GcElWakl4TkdGRk1WbFJhbFpYWWtkU00xVnFTa1psUm5CSFlVWk9hRTFzU25aV1YzQkxUa1prUjFkdVVrOVdWVFZZV1d0YWQyVldXWGxOVldSWVlrWnNORlZ0Y0U5V1ZscHpWMjVLVjJGcmNFeFpla1pQWTJzNVYxcEhhRTVXYmtKT1ZtMHdlRTVIVFhsVVdHaFlZbXMxYUZWc1VuTldSbXh6WVVaS2JHSkdjREJVVlZKSFZsVXhXRlZyYUZaTmFsWlFXVlphUzFJeVRrZGhSbVJvWVhwV01sWnRkR0ZYYlZGNFdraFNVMkpZUWs5WldIQlhVMVpaZVdSSGRGTk5WbXcxVlRKMGMxVnRTa1pYYkd4WFRVZG9SRlpGV2xkT2JFcHlZMGQ0VTJKclNrdFdiR040WXpGVmQwMVlVbWhTYTBwWVZXMTRZVmRHY0VWU2JYUnFUVmRTTVZWdGVFOWhWbHBYWTBoYVYxSnNXbFJWYWtaUFVqRmtjbHBIYUZSU1ZGWllWa1prTUZZd05WZFhiR2hzVW5wc1dGUlZVa2RUVmxwWVpVWk9WMDFFUmxoWk1HaDNWMjFXY21ORmFGWmhhMXBVV2tWa1QxSXhjRWhpUm1oVFRXMU9ORlp0Y0VkWlZsbDRWMWhvVmxkSGFGbFpWRXBUVjFac2RHTjZSbGRTYlhoWldsVldNRmRHV25SbFJscFdUVzVOZUZaSGVHRmpNazVGVVd4d2JHRjZWakpXYlhCQ1pVZE9jazVXV21GU2JXaHZWRlpvUTJJeFduSmFSRkpZWWxaYVdGbHFUbmRoYkVwMFZXNUNWMDFHV2t4Vk1WcGFaVVprZEZKc1VrNWlSWEJKVm10ak1WSXhaRWhUYTFwcVUwVktWMWxzVWxkU1JuQllaVWQwVjAxV1dubFhhMlF3VkcxRmVHTkZiRmROYmxKMlZrUkdhMU5HVG5OWGJHaHBVbTVDVjFadGNFOVVNRFZIVlc1S1dHSklRbk5XYkZKWFZqRlJlRmR0ZEZkTlJFWktWVmQ0ZDFkR1duTlhia1pWWWtad2VsWnFSbXRYVjA1SVlVWk9UbUpYYUZwV2ExcGhXVmRSZUdKR1pHcFNiSEJaV1d4b1UyTnNWbkZTYTNSVFRWWktlbFl5Y3pWaFJscDBWV3RzV2xaV2NETldha3BMVjFaR2NtRkdjR2hoTTBKTVYyeGFZVk15VWxkVmJrNVdZbGQ0Y0ZWc2FFTlhWbGw0V2tSQ2FFMUVWa2haYTFwcllWWktjMWRzVmxwaE1WVjRWakJhVjJSRk1WVlJhemxUWWtkM01WZHNWbFpPVmxsM1RWVldVMkp0ZUZoVVZ6VlRZMnhhY1ZKcmNHeGlWVnBJVmxkNGExWXhTbGxSYXpGWFlsaENTRlpFU2s5V01XUjFWRzFHVTFaR1duZFhWM1JYWkcxV1YxZHVVbXRTYXpWVlZGWldjMDVHVlhoaFJ6bFhWakJ3U1ZwVll6VldiVXBWVW01YVdrMUdjSHBhUldSVFVtMVNSMkZHWkdsVFJVcEtWbXBHYjJReFNYbFNiRnBPVm0xb1YxbFVTbTlYUmxKWVkwWmtWRkpzY0ZsYVZXUXdWa1pKZDFkcmFGcGhNWEJvV1ZaYWExTkhSa2hQVm1Sb1lUSTRkMWRXVWt0VU1rMTRZMFZzVjJKVldsUlpiRnBMVlVaYWRHVkhPVkpOVjFKWVYydGFWMVZ0U2xaWGJrSlZWbTFTVkZVeFdsWmxWMUpJWkVkb2FWSlhkekZYVmxaaFlqRlplVkpZYUZoaGF6VllWbXhhZDJWc1VuUmxSVGxxWVhwc1dGWkhNWE5XUmtwV1kwVjBWMDFXY0ZoWFZscFNaVVpXZFZWc1VtbGlSWEIyVmxkMFZrMVdaRWRpU0VwaFVtdHdUMVZ0TVRSbFJsWjBaRWRHYUUxRVJrWldiWGh2VjBkRmVHTklXbHBXYlZKSVZHMTRZV015UmtkaFJtUnBVbGhDUlZacldtRmhNVTUwVm10a1YySnJOV2hWYlRGdlkwWldjVkpyZEZaV2JIQlpWRlZvYjFack1YTlhiR2hYVFdwV1ZGWkhlR0ZTYkU1MFQxWmFhVmRIWjNwWGJGcGhWVEpOZUZkdVVtdFNiV2h2V2xkMFlWTldaRlZSYlRsclRWWnNNMVJXYUVkVk1rVjZZVVpvVlZac2NETldhMXBhWlVad1JscEdUazVYUlVwSlZqSjBZV0V5UmxoU1dHUnFVakJhV0ZsWGRIWmtNVnB4VW0xR2ExSnNjSGxYYTFwdlYwWkplV0ZHYUZoV2VrVXdWWHBLVG1WR1duVlZhelZYWVhwV2VGWlhNVFJXTURCNFYyNVNhMUpGU2xsWmExcDNaV3hzY2xWc1pGcFdhM0JZV1RCb1MxWXlSbkpqUldoVllsaG9hRmw2U2tkU01YQkdUbFprVG1KWFp6RldiVEV3WVRBMVIySkdaRmhYUjJob1ZUQlZNVll4YkhKaFJVNVlVbXhhZWxZeU5XRmlSMHBIWTBSQ1drMUdXbkpaVjNONFkyc3hWVlZzWkdsV1JscFJWakZhWVZNeFdsZFhia3BRVm0xU2NGWnJXbUZTUm1SeVZXdGtXbFpyYkRSWGEyaFBXVlpLVlZac1VscGlSbkJNVlRGYVlXTldUbFZTYkZKT1ZqRktTbFpVU1RGV01WWjBVMnRvYUZKdGFHRldhazVPWlVad1NHVklTbXhXTVZwSlZXMTRVMVV3TVZkalJXaFlWa1ZLY2xScldsWmxWa3B4VjJ4a2FHSkdjRnBXYlRFMFdWZEdSMkpJUmxSaE1sSllWRlpWTVUxV1duUmxSWFJvVmpCd1dsbFZXbk5XTWtwWlVXeENWbFpGV2xCVmFrWmhWMWRLUms1V1pHbFdhM0JXVm10YVlWWnJNVlpOVm1SWVlteEtjMVZ0TVZOaU1WcDBaVWhrV0ZKdGRETldNbmhyVmpBeGNtTkdjRmRXZWtaMlZqQmFZV015VGtoaFJtUm9ZVEZ3ZVZkVVNqUmtNVWw1VW10b2FWSnJOVTlXYkdoQ1RWWmFkR1JIUmxwV2JIQjVWRlphYTFsV1NsaFZiR3hYVFVkU2RsbHFSbFprTVZwVlVtMXdVMkpHYjNkWGExWnZWREZTY2sxV1pHbFNSbHBXVm0xNFlXTnNXbkZSV0docVlsVTFTRmt3V25kV01WbDVXak53VjJKWWFISlZla1pLWlZaU2NtRkhhRk5pU0VKMlYxWlNUMUV4VGxkWGJGWlRZbFZhVjFSWGMzaE9SbXQzVm0xMFYxWXdXVEpXYlhoVFYyMUZlVlZZWkZWaE1YQm9Xa1ZWZUZaV1ZuUmhSMmhzWVRGd1dsWnNVa2RpTWtsNFdrVm9WR0pyTlZWWmExcExXVlpzYzJGR1RrNU5WM1F6VmpJMWExZEdTWGhUYTJSaFVsWndkbFpVU2t0WFYwWkhXa1prVjJWclJqUlhWbEpIVjIxV1IxUnVWbFZpVjNoVVZXeFNWMWRXWkZoa1IzUnBUV3hLZWxZeGFHdFhSMFY2Vld4b1YyRnJTak5WTUZwelZteGtkR1JHV2s1aVJuQTFWbXBLZDFsV1dYbFRhMlJVWVROb1YxcFhkSGRWUm13MlVtczVhMVpyY0hwV2JURnpWVEF4Vm1OR1JsZE5WMDR6V2xWa1NtVkdjRWRhUm1oWVVqSm9XbGRYZUc5Vk1WcEhZa2hPV0dKVldsVlZiVEV3VFRGYWRFNVZPVmROVm13eldUQldjMWRzV2xoaFJWSlhUV3BHUjFwVldtdGpWbEowVW14a1RrMXRhSFpXYlhCRFZtMVdSMVJzYUZOaE1YQlJWbTF6TVdOR1duUmtTR1JVWWtad01GUlZhR3RVYkZweVlrUlNWMDF1YUhaV2EyUkxVakZrZFZGc1drNVNiSEJ2VmpGYVlXTXhXbGRUYmxaaFVsUldUMVp0TlVKa01XUnpWbTFHV2xZd2NFaFdNV2h2VmtkRmVHTkdaRmRpYmtKSVdrZDRjMVpzY0VkYVIzQnBVakZLTmxkVVFtRmhNa1pYVTFob1ZGZElRbGhXYlhoTFUwWnNWVk5yTld4U2JrSktWa2N4UjFVd01IZFRiRlpYVW0xT05GbHFTa2RTTVdSMVZXczFWMUpyY0hsV1JtUjZUVmRXYzFkdVRtaFNNMUpoVm0xMGQxZFdXbGhsUms1WVlrZFNTbFZYZEc5V01ERkhZMGhLV2sxdWFETlZNRlUxVjBkR1IxUnNaRk5XYmtKTlZtMTRZV0ZyTVZkaVJtUllWMGRTVDFadE1XOWlNVlp5VmxSR1YwMVlRbGxhUldSSFZtc3hXVkZzYUZkTmJtaFFWakJhV21ReFpISmlSbkJPVW01Q1VWWnRjRUprTWxaWVVtdGthRkp0VWs5V2FrWkdaREZrV0dORlpGTmlWbHBJVjJ0b1MxbFdTblJoU0VKYVZrVTFSRll5ZUd0WFIxWkhXa1p3VjJKV1NsbFdha2t4VlRGU2MxZHVTazlXYlhoWVdXeFNWMUpHV25GU2JYUnFZa1p3TUZwRldtdFViRnBaVVd4a1YxWjZSWGRYVmxwYVpWWk9jMkpIYUZSU2JrSlpWMVprTUZJd05VZGhNMmhZWWxWYWNWUldXbUZsYkdSeVYyczVWV0Y2UmpCWlZWcExWakpLUjFOclVscFdSVnBMV2xWYVUyTXhjRWRXYld4b1pXeGFXbFl4WkRCaE1WVjVWR3RrVjFkSFVsaFpWRTVUVmxac2NsZHVaR3hXYlZKNVZsZDBUMWRIU2tkalJFSlhWak5DUkZacVNrdFhWMFpJWVVaa1UxSldjRzlYV0hCTFZERkplRk51VG1GU01taHZWRlJDU21WV1duUmpSVTVhVmpBeE5GWXllR3RXYlVweVkwWmFXbUV4Y0V4V01GcHpZMjFHUmxSck9WTmlTRUpYVmxSSk1XRXhXbkpOV0VwWVlUSlNWbFp0ZUhkamJHeFlaVVYwYTFJd1draFpWVnBYVmpKV2MxZHJWbGhXYkZwb1YxWmtUMVl4VW5WVGJYUlRUVEJLVUZkV2FIZFdNVTV6VjJ4b1RsWkdTbTlVVjNSaFYwWlZlVTVXWkZaaVIxSktWVmQ0YzFkdFJYbFZiRTVWVmxad1lWcFdWWGhXTVU1MFpVWk9UbEpHV2tsV2Frb3dZVEZKZUZaWWJGTmhiSEJZV1cweFUxZEdiSE5WYTFwclRWaENSbFZ0Y3pWV01ERlpVV3RvV0dFeGNISlpWbHBoVmpKT1IxcEdaRk5pU0VKdlZsaHdTMVl5VFhoYVJteHBVbFJzV0Zsc1drdFhSbVJZWlVaa1YwMUVWbnBXTW5odllrWktObUpHYUZkaVdHZ3pXbGQ0Y21ReFZuSlBWbVJPVWtWYVNWZFVRbTlUTVZsNVVtNUtXR0ZyTlZkWmJHaHZZMnh3UmxwR1pGTk5XRUpKV1ZWVk1WUnNTbGhrUkZaWFlsUkdNMVY2UVhoU01rcEhXa1prV0ZJeWFHOVdWM2hyVlRGYVYxZFlaR0ZTUmtwd1ZGWmFZVTFHY0ZaaFIzUllVbXh3ZWxrd2FHOVdNVWw2WVVaQ1dsWldjRXhhUlZwWFl6SkdSMXBGTldoaE1WbDZWbTB4ZDFGdFZraFVibEpWWVRGd2IxVnRNVk5qUmxsM1drYzVWMVp0VWxoV01qRkhWa1V4V0ZWc2FGWmlWRlpRVmxjeFMxTkdWbk5oUjBaWFRURktURlpHVm1GWlYwMTRWbTVLWVZJeWFFOVdiR1F6VFVaa1ZWRnNaR3BOVm5CSlZUSjBiMVp0U2toaFJtUmFZa2RvZGxSVVJscGxSbVIwVW14T1RsWnVRalpXYTJRMFZERlNjMWRZYUZSaE1uaFlXV3hvYjJSc2JEWlRhMlJxVFZVMWVsbFZXbUZoVmtsNVlVZG9WMkZyU25aVlZFWlBVakpPUjFkc2FHbFNNVXA0Vmtaa01GbFdUbGRqUlZwWVlsaFNWbGxyV25kTlZsWllaRWM1V0ZKc2NFZFZNbmh2VmxkRmVHTkhhR0ZTVm5CUVdYcEdZV014VW5SaVJrNVhWMFZLV2xacVJtRmhNREZIWWtab1UyRXlVbkJWYTFwM1ZsWnNWVk5zVGxkU2JFcFlXVlZXVDFVd01WZFRibkJYWWtaS1NGWnFRWGhYUmxaeVdrWmFUbFl5YURaV2JYQkxVekZrVjFKdVNteFNiRnBZVm0wMVExZEdaSE5XYlVaVVRXeEtXRlpITlV0VU1WcDBWVzVDVjJKWVVqTlhWbHBoWkVkT1JsUnRhRTVoTW5jeFZsY3hNR0V4V1hoYVJXaFdZa2RvWVZsc1VrZFdSbGw0VjJ4a2ExSlVSbFpXVnpFMFZqSktTVkZxV2xkaVIxRjNXVlJLUjFOR1RuSlhiWEJVVTBWS2FGWkdWbXRpTURCNFYyNUdVbGRIYUhGV2JYaDNUVlpWZVdWSGRGVmlSWEF4VlZjd05WZEdaRWxSYTNoWFVrVmFURnBGV2t0amJIQklVbXhPVjFKc2NESldNVnBUVWpKUmVGUnVUbGhYUjJoWldXeG9VMk14YkhOWGJVWlVVbXhXTlZwVlpEQlhSa2wzWTBoc1ZXSkhUVEZXYlRGTFZsWktjMVZzY0U1U2JrSlpWMVJHWVZReVVrWlBWbHBRVmpKNFZGUldWbmRYYkZwMFpVZDBUbEl3VmpSV01uaGhWR3hhYzJOSVJsWk5SMUV3Vm0xNGMyTnNaSFZhUjNCcFVqRktXVlpxU2pCTlIwVjRWMjVLV0dGcldsZFdhazV2WVVac1YxZHRkRlJTYlRrMldUQmFiMVl3TUhkVGEyeFlWbXhLVEZaSE1WZFRSbEp5VjJ4a2FWSnVRbmRXYWtKWFV6SlJlRmR1VWs1V1JVcFpXVmh3UjFOR1dYaGhTRTVvVFZWdk1sbHJXbXRXVmxwelkwZG9WazFHY0dGYVZsVXhWakZTZEdGR1RtaGxiRnBKVm14U1MwNUhTWGhhU0ZKVFYwZDRWMWx0ZUhkV01XeFZVbTVrVjAxWVFsaFhhMXByVmtaSmVGTnJhRmhoTVZWNFZtcEtTMk5zVGxWVGJHUm9ZVEk1TTFZeFdtRmpNVmw0Vm01V1ZXSkhhSEJaYTFwM1ZrWmtWMXBFVWxwV2JWSklWbTAxVTJKR1RraFZiR3hXWWxSRk1GWnRlRlpsVjFKSVpFZG9hR1ZyV2xsV1ZFa3hZekZaZDAxWVJsTmhhelZZVm10V2QxUkdXWGRhUldSVVVqQmFTRmRyWkhOWFJrcFdZMFpLVjJKWWFGUlZla1pLWlVaT1dXSkdUbGhUUlVwM1ZsZHdUMkl4V2xkV2JrWlRZVE5TV0ZadE1WTlhWbkJHV1hwV1ZtRjZSbGRVYkZadlZqQXhkVlZ1V2xwaE1YQk1WbXhrUzFJeFpITmpSMnhUWWtoQ1dsWnJaREJaVjA1MFZWaG9XR0pzV2xaWmEyUlRWREZzVlZKc2NFNVdiSEI1VjJ0b2ExWnJNVmhWYWtKV1lsUldURll3WkV0U01VNTBVbXhXVjJWc1dsRldSM1JoV1ZkU1NGWnJhR3RTTTFKVVZGVmFkMU5HV2tobFJscE9WakJhV0ZZeGFITmhSa2wzVjJ4b1dsWXpVbWhaVlZwelZsWkdXV0ZHVGs1aE0wSkpWMVpXWVZReVJrWk5XRTVVWWtoQ1dWWnVjRVprTVdSWFYyMUdWMDFyY0VoV2JYaFBZVmRLVjFOdWFGZFNiSEJvV2tSQmVGSXlUa2RYYlVaVFZqRktXbFpYY0VOa01VNVhZMFphV0dKWVVsaFVWVkpIWlVaV2MyRkhkRmROUkVaSVdUQldORmRyTVhGU2EzaFdZa1p3V0ZsNlJtdGphelZZWWtkc1YwMXRhRWhXYlRCM1pVZFJlRlJZYUZSWFIzaFdXVzF6TVZac2JIUmxSWFJwVFZaYU1GUldZelZYUmtwMFpVaHdWMDF1VVhkV2JGcExaRVpXZFdOR1pHbFdSVnBKVm1wS05GZHRWa2RVYms1b1VtMVNjRlpyV21GVVZscHlWV3RrV2xZeFNraFdiVFZQVm0xS1NWRnNhRlppUmtwWVZXeGFXbVZHWkhSU2JIQlhUVVJGTUZkV1VrOWtNV3hYVTFod2FGSnNTbGhaVkVaM1lVWlZlRmRzY0d4V01VcEpWVzB4YjFSdFJYaGpSRnBYVmtWdk1GbFVTa2RqTVU1MVZXMW9VMDFHY0ZsWFZtUjZUVlphUjFkcldsaGlTRUp6VlcweFUyVnNaSEphUkVKV1RVUkdWMWt3VmpCV01ERjFWVzVLVldFeVVraFdha1pQWkZaV2RHUkhlR2hOU0VKYVZqRmtNR0V4Vm5SVldHaFdZa1p3V1ZscmFFTmpNVnAwWTNwR2JHSkdiRFZVVm1oclZtc3hjbU5JYkZaTmJtaDZWbXBHWVU1c1NsVlJiRnBzWVRGd1VWWlhjRWRoTWxKWFUyNU9WV0pYZUZoV2JUVkRWbXhaZUZwRVFsZE5iRVkxVm0xMGExZEhTa2hoU0U1V1lXczFWRlp0ZUhOamJGcDFXa1UxVjJKR2NGcFhiRlp2VkRGa1IxTnVUbXBTVjFKWVZGZHdSMlJzV25STlZtUnFZbFUxUjFReFpFZFdNVmw0VTJ4R1YxWjZSVEJhUkVaUFVqRk9kVlJzVm1obGJGcFFWMWQ0YTJKdFZsZFhibEpyVWpCYVlWWnRNVFJYUm1SeVlVWk9WMDFyY0hsVWJGcHpWMjFLV1dGRmVGZFNSVnBvV1RKNGEyTnRVa2RhUlRWWFlUTkNXbFp0TUhkbFJrbDRWVzVPVkdKck5YRlZiVEZ2V1ZaYWMxcEhPVlpTYkhCNFZWWm9iMkZ0U2tkalNHaFhZbGhvY2xacVFYZGxWMFpJVDFaa2FHRXlkekJXV0hCSFlURlplRlp1VG1sU01taFVXV3hhUzJSc1drZFhiVGxTVFVSV2VsZHJXbGRXUjBaelUyNUtWVlpzV25wVWExcGhWMFUxVms5WGFGTmhNMEkxVmtkNGIxRXhXblJUYTJob1VsWktXRlJWV25kaFJtdzJVbTEwYTFJeFNrZFViRnBQVmpGS1YyTkZjRmRpVkVVd1dXcEtTbVZHY0VaaFJsSnBZVE5DVVZacVFsZFpWbGw0WWtaV1UySlZXbFpWYlRGVFYwWlplV1ZGT1ZkTmEzQkpWbGR3UTFadFNsbGhSbWhYVmtWd1RGVXhXa2RqYlU1SFlVZHNVMkpJUWpWV2JHUjNVekZKZVZWclpGVmlhelZaV1d4b1ExWkdXblJPVlU1WVZteHdNRmt3VlRWaFZURnpVMjV3V21FeGNHaFdha1pyVTBkR1NWTnNXbWhoTUhCdlZsUkNZVll5VWtoV2EyaFFWbTFTVDFsVVRrTlRWbVJWVVcxd1QxWnNiRFJYYTFaelZXMUZlV0ZHYkZkaVdHZ3pXVEo0VjJOV1NuTlViWFJYWVhwVmQxWlhNVFJVTVZKMFUyeG9hRkpzY0ZoVVZtUlNUVVprVjFkck5XeFdiRm94VmtkNGIyRkZNWE5UYlRsWFZqTlNhRlY2Um1GU01rcEpWR3hvYUUxc1NsRldWekUwWXpBMVYxVnVUbGRpV0ZKWVZGWldjMDB4V1hsT1dHUlhZWHBHZUZWdGRHOVdNa1p5WTBWNFYySkdjRXhaZWtaWFl6RmtkR0ZIYUU1WFJVcFhWbTB3ZUdReFNYaGlSbWhXWWtkU1YxbHRlRXRpTVZaMFkzcEdhVTFXU2xaVlYzUjNWRzFLUjJKRVVsZFdNMUpRVm1wS1IwNXNXbk5oUm1ST1ZqSm9ObFp0ZEd0U2JWWlhWbTVPVjJKSVFtOVVWM2hMVFd4YWNWRnRSbFpOVm13MFYydG9WMWxXU1hwUmJrSldZbFJXUkZSdGVHRmpWazV4VVcxb1RtRXhXVEJXVkVreFV6SkdjMVJyYkZKaVZWcFdWbXhhZDAweGEzbGxTRTVYVFZkU01GVnRNWGRoVmxwWlVXdGtWMkV5VVRCWlZFcEhWakZrY2xkc1VsaFRSVXBaVmxjeE5HUXlSa2RYYkdoT1ZtMVNWRlJYY3pGU01WbDVUVmM1VmsxcmNFZFpNR2hoVmpGS2RGUnFVbHBoYTNCVVdYcEdhMk15UmtoalJrNVhWa1phYjFadE1IZGxSVFZIV2tWa2FWTkZjRmxaYTJSVFZqRlNXR1JJWkU1U2JIQlpWRlZTVjFZeVNsWmpSbkJhVmxkb00xWnNXbUZTYkdSMFVtMUdWMkpXU2xsV1Z6RjZUbFprU0ZKcmFHbFNiVkpaVld4V2QxUkdXblJOVkZKb1lYcEdXVlpXYUc5WlZrNUdZMFU1VjJKSFVuWldha1poWTJ4YWNtUkdhRk5pV0doYVYydFdWMkV4VVhoVGJrNVlZbTVDV0ZSWGNFZFRSbXhZVFZWMFYySkhVbmxaVlZwdllVVXhXVkZzUmxkaVJrcElWMVprVTFZeFNuVldiR2hwVWpGS1VGWnRNREZSTVZwWFYyeG9hbEpYVWxoWmJGcGhWMFphV0dWSVRtaFNhM0I2VmpJMVExZHNXa1pPVlZKWFRXNW9jbFl3WkZOVFIxSklZa1UxYUUxdVkzZFdiWGhyVGtkSmVGVllhRmhoYkhCd1ZXMHhORmxXYkZWU2JtUk9UVlpLVjFZeU5XdFZNa3BJVldwQ1lWSldjSEpXVkVaaFVteGtjVlpzWkdoaE1qa3pWMWR3UjFkdFVYZE5WbXhYWWxkb1ZGbHNaRzlYVmxwMFpFWmthMDFXU2toV2JHaHZWMGRGZVZWdVNsZGlXR2hNV2xkNGEyTnNjRWxVYkdoVFlUTkNOVmRYZEZOWlZsbDVVbGhvYWxJeWFGbFdiWGgzWVVad1JsZHRSbXBOYTFwSVYydGtiMVJ0U2xoaFJrNVhZbFJHTTFWNlNrcGxSbkJHV2taYWFWSnVRbHBYVjNSdlVURlJlR0pJU2xoaWJWSlpWVzB4VTFac1draE5WRUpYVmxSR1dGa3dhSGRYYlVWNFUyeFNWMkZyUmpSYVJscEhaRWRHUjFwR1pGTldia0oyVm14amVFNUdVWGxWYTJoVFlUSlNXVmxzWkc5VU1WcDBUbFZPVkdKR2NIbFdNbmhQVlRBeGMxSnFVbGROYWxaUVYxWmFUMUl4VG5OVmJIQm9UV3hLTWxacVFtRmpNbEpJVld0YWExSnNTbkJWYlRWRFYyeGFSMWRzVGxaTlZuQlhWRlphYTJGV1NrWk9WbHBYWWxob00xbFZXbk5YUjFaR1pFZHdUbUY2VmtsWFZsWmhaREZaZUZOc1pHbE5NMEpaVm0xNFlXRkdiRlZTYkhCc1VtNUNTbFV5Y3pWV01EQjRVMnhDVjFZelVsaFhWbHByVWpGa1dXSkhkRk5OTVVwNFZrWmFZV1F4VGtkV1dHeHNVMFUxVjFsc1ZuZFRiRlpZWlVoT1YwMXJjRlpWYlRWaFZsWmFSbGR1Y0ZWaVdHaFFXVEl4VDFOSFZrZFViV3hYWVRKM01GWnRNVFJoTWxaeVRWWmtXRmRIZUZSWlYzaDNWMFpzY2xkdVpGaFNiSEF4V1RCV1lWUnNTblJWYkdoWVlURndjbGxYYzNoamJVNUdZVVprVG1KdFozcFhWM1JyVXpGSmVWUnJaR2xTYlZKVVdXdGFkMVpXV2xoalJYUlhUVlpzTlZWc2FIZFpWa3AwWVVoQ1YySkdjRE5XTVZwclYwZFdSMXBIZEU1V1ZGWkpWbTE0YjJNeVJYaFRia3BQVm0xb1ZsWnNXa3RUUmxKWFYyNU9WMkpJUWtsVU1WcHJWakF4U1ZGdFJsaFdiRnBZVkd0YWEyUkdXblZUYlhCVFZqSm9XRmRXWkRCWlYwNXpZMFZhWVZKWVVsUlVWM1JoVTBaYVNHVkhkRlpOYTFZMFdXdFNZVll5U2xWUmFrNWhVa1Z3VTFwV1dtRmpiR1J5VDFaa1YwMXRhRlpXYlhCRFlUQTFSMWR1VG1sVFJrcHlWVEJrVTFZeFZuUmxTR1JPVW14S1dGWXljelZoUmtweVkwaHdWMDF1UWtSV2JGcGhZekpPUjFGc1pHbFNiRmt3Vm1wQ2ExWXhUbGhVYTJSb1VqSm9UMWxZY0VOT1JscDBUVmhrVW1KV1draFdNV2h6VmxkRmVXVkhPVlppV0dneldUQmFZV05zV25OalIzaHBVakZLV2xkclZtdFNNVnBHVFZaa2FsSnRhRmRVVjNCWFZFWnNWMWRyZEd0U2JGcDZXVlZhZDJGV1NYaFRha3BYVW0xUk1GZFdaRk5TYXpGWFZteGFhVll5YUZCV2JYaFRWakZPYzFkc2FFNVdSVXB2VkZkMFlWZEdWWGxPVm1SV1lsVndlVlV5ZUc5V1ZscFlWV3hTWVZJemFHaFZha1pyWkVaS2RHTkhiRk5pU0VFeFZtcEtNRmxYVVhoWFdHUk9WbXh3Y1ZWc2FFTlhSbXhWVTJ4T1RrMVhVbGhXTW5oaFlrWmFjazVZYkZwV1YxSjJWbFJLUzFKdFRraGhSbWhYWWtWd1RWZFhjRWRTYlZaSVZHdGFWMkpGTlhCV2JGcDNWbFphUjFkdGRGWk5iRnA2VmpKMGIySkdTWGRYYkZwYVlURndlbFJyV2xabFYxSkpWR3hrVG1FeGNEVlhWbEpQWWpGWmVWSnVTbGhpUjJob1ZXeGFkMVJHV1hoYVJYUlRUVmRTTUZscldrOVVhekYwWVVoYVYySlVRalJVVlZwYVpVZEtSMkZHVG1oTmJFcDJWa1pTUzA1SFRYaFdibEpQVmxVMWNWbHJXa3RYUm1SeVYyczVhVkpzY0RGVlYzUnJWMGRGZVdGSVNscFdWbkJvV1hwS1QxSXhaSE5hUjJ4WVVtdFplbFp0Y0VOWlZteFhVMjVPVldKc1NtOVZha0poVmtaV2MxZHVaRmRXYlZKYVdUQldhMVpWTVZoVmJHeFdUVzVTZGxsVldrdGphelZYVld4a1RsSnNjRTFXYWtvMFYyMVdSMk5GVmxaaVYzaFBWbXhhV2sxR1duSmFSRUpvVFZac05WVnROVTloYkVweVRsWm9XbFpGV21oWlZWcHlaVVprYzFSc1pFNVdia0Y0VmpKMGEwNUhSbGRUYmxaU1YwZFNXVmxyV21GV01WSnpXa1ZrVTAxWFVqRlZNakZ6VlRGS2NtTkdhRmRTYlUxNFdXcEtWMk14WkhWU2JFNXBVMFZLZWxkWGVGZFpWazVYWWtaYVlWSlhVbGRVVmxaM1YwWnJkMWRzWkZkTmEzQmFWVmQwYjFsV1NrWlhhM1JoVm14d1VGa3lNVWRUUjA1SFZHMW9iR0pHY0doV2JYaHFaVVV4U0ZWWWFHRlNWMUpaV1cxMGQxZFdiSE5XYlVaWVVtMTRXbGt3Vm10WFJrcDBWVzVzVjAxcVJYZFdha0Y0WTIxT1NXTkdXazVoYkZwTlZtMHdlRkl5VG5KT1ZtUldZa2RTVDFadE5VTlhWbVJWVW0xR1UwMXJNVFZXUjNSaFZERlplV1ZHVWxwaVdGSklWRlJHWVdOc2NFVlZiR1JPVm10Wk1GWXlkRmRpTVZwSVUydGthbEp0YUdGV2FrNXZWRVpaZDFkc1RsaFNNRFZIVjJ0YVUxVXlTbGRUYkd4WFlXdHZNRnBFU2t0VFJrNXpWMnhvYUUxdWFHaFdiWGhyVlRGT1IxZHNWbE5pU0VKelZXMXpNV1ZzYkhKWGJYUlhUVVJDTTFVeWRITldNa3BIVTJ0NFYxSjZSbGhWYWtaWFpGWmFjMWR0YkZkTk1taFdWakZrTkZsV1RYbFZXR2hZWWtaYVUxbHJaRk5XVmxKWFYydDBWRkpzYkRWVWJGcFBWbGRLUjJORlpGWk5ha0V4VmpKNGExTldSbkpoUm1ST1VtNUNiMVpYY0V0U01VNUdUMVprWVZJeWVGUlVWbFozVXpGWmVGZHNaRnBXTURFMFYydG9VMVpIU2tobFJscFhUVWRTZGxkV1dsTldNV1IxV2tab1UySnJTa2xXTW5SV1RsWmFSMWR1VGxSaWJrSlpXVlJHVm1WR1duRlJXR1JzVm01Qk1sVXllR3RoVm1SSVlVaHNWMUl6VW5KVmJURlhVakZrYzJKSGFGTmlSWEIzVjFkMFYyUXlWbk5YYkZaU1lsaFNjRlJXV25OT1JteHlZVVU1YUZKcmJ6SlphMXByVm0xS1dXRkVUbUZXVm5CWVZtcEtSMU5GT1ZoaFIyeFhWMFZLUzFadGVHcE5WMDE0V2tWb1UxZEhhSEZWTUZaM1YwWmFjbFpyWkU1TldFSkdWVlpvYjFZeFduTlhibkJhVmxad2NsbFdXazlTYkU1MVYyeGthVkl5WjNwV1dIQkhWbTFXUjFwR2JHaFNiRXB3V1Zod1YyUXhXbGhqUlU1YVZteHdTRmxyYUU5WlZrbzJZa1pzVjJKWWFETldNVnAzVm14a2RHUkhhRTVTUlZwYVZteGtOR0l4V1hkTldGWm9VMGhDWVZacVRtOVVSbGw0VjJ4a2FrMVdXbnBaTUdSelZUSktjbE5yY0ZkaE1YQlVWV3BHVm1WR1pGbGhSMFpVVW14d1YxZFhkR3RWTVdSSFZXeGFhRkpWTlZWWmEyUlRWMFphZEUxWVpGVk5WbkI2V1RCYWIxWXdNWFZSYldoWFZrVndURmw2U2s5U01rWkhWbXhrYVZORlJqWldNVnBYV1Zaa2RGVllhRmhpUmxwVVdXdGtiMWRHYkhSa1JYUlVWbXhzTlZwRldtRlViRnB6WWtSU1YwMXVVbkpXTUdSR1pXeEdjMkZHY0dsU01taEZWbGh3UjFVeFdYaGFTRXBQVmpOb1ZGUlZhRU5UVmxsNVpFZEdWazFyV2xoVk1XaDNZVVpLZEdGR2JGZGhhelZVV1ZWYWExWXhaSE5qUjNoVFRVaENTMVpyWTNoaU1WVjVWbTVTYkZOR2NGaFdibkJDWlVaV1ZWSnRkRmROYXpWSVZqSXhiMVV4V2tobFJteFhVbTFSZDFwRVJrOVdNV1J6WVVkd1UxWXhTbHBXVjNCRFZqQTFWMWRzYUU5V01GcFlWRlphZDFJeFdYbE5WemxYWWxWd1dsbFZhRXRYYlZaeVkwVjRWbUZyY0VoVmFrWjNVbXMxVms1V1RsaFNWWEJWVm0weGQxTXdNVWRXV0doVVYwZG9hRlV3V2t0WFJteFZVMnhPYUZKc1ZqTldiVFZyVjBaYWRHVkliRmhoTWsweFdWZDRTMk15VGtsaFJscE9ZV3RGZUZkV1ZtRlRNazE1Vkd0V1VtSlZXbFJXYlRWRFpWWmFjVk5xVWxwV01VcEpWbTEwYTJGR1NuVlJhemxXWWxSV1JGbHFSbUZqVmtaMFpFWlNUbFp1UWpaV01uUnZWakZhU0ZOcmFGWmlhMHBZVkZWYVYwNUdVbkpYYlVaVFRWWndNRlZ0ZUd0VWJVcEdZMFZ3VjJKVVJYZFhWbHBYVWpGa1dXSkhhRk5pVjJob1YxWlNTMVZ0Vm5OVmJHUllZbGhTV0ZSV1duZGxiRnBJWlVaa1ZXSkdjREJhU0hCSFZqRmFSbUo2UWxkaGExcFlXa1ZhUzJSV1VuTlZiV3hUWW10S2IxWnRNVEJXTWxGNFYydGtXR0pHV2xSWmJURlRWMFpzY2xwR1RteGlSbkJKVkZab2ExWlhTa2hWYTJSV1RXNVNNMVpxUm1GT2JFcFZVV3hrVTFKWVFrbFdiWEJIVkRKU1YxZHVUbFJpVjNoVVdXdG9RMWRzV25KWGJVWm9UVlphTUZaV2FHOWhWa3B6VjJ4U1dtRXhjRE5aZWtaaFpFZFdSbVJIZUdsU01VbzFWbXBKZUZJeVJrZFhia3BwVWtaS1YxUlhOVzlOTVZsM1YyMUdUMkpGV25oV1YzaHJWakZLVjJOSE9WZGlXRUpJV1ZSS1UxWXhXblZWYlhoVFlYcFdkMVp0TVRCa01WWnpWMjVTVGxOSFVrOVdiWFJYVGtaWmVHRkhPVnBXYTNBd1dsVm9SMVp0U2xWU2JGSmFZV3RhV0ZwRlpGTlRWbkJJWlVaa2FWZEdSalpXTVZwWFlqRlJlRnBGYUZOaGJIQlVXVlJLTkZsV1duTlhhM1JXVW14d2VGVXlkREJYUmxwelUyNW9WMVo2UmtoV1ZFcExWakZPY21KR1pGZFNWWEI1Vmxkd1IxTnRWa2hVYTFwb1VqSm9WRlJYTVc5VlJscEhWbXhrYTAxVk5YcFdNalZIVmtkR2MxTnNhRlZXYlZFd1ZqRmFWMk15UmtsVWJHUlhUVWhDU2xac1pEUmhNV1IwVTJ4c2FGSllhRmhaVkVaM1pXeHJlV1ZIUmxkV2EzQjZWbTF6TVZZeVJYcFJiVVpYWVRGd2FGbFhjekZYUmtwWllrWlNhRTFzU25kV1YzUmhVekZzVjFkdVRtRlNlbXh4V1d0YWQxWnNWbGRoUnpsb1lsVndTRmt3YUc5V01rcFpZVWhLVjJGclJqTmFWVnBQWkZkS1IxcEhiRmhTYTNBMVZteG9kMU14VVhsVWJrcFBWbTFTYUZWdE1XOWpSbFYzVm10MFdHSkdjRlpWVjNoclZrVXhXRlZzYUZkTmFsWklWbGN4UzFac1pIVlNiRlpYVFRKb1RWWlVSbUZaVm1SSVZXdG9VMkpJUWxoWlZFNURWakZhZEUxWWNFOVdiR3cxVlRKNFYxWXlSWGhUYkZwYVlrZG9kbGRXV25kV2JHUnpXa2R3YUdWdGVGcFhWbFpXVFZkR1JrMUlaRlJoTTBKWVdXdGFTMVJHVW5KWGJIQnNVbXh3V2xscldrOVhSa2w2WVVoYVYxWjZRalJaYWtaclVqSktTVlZyT1ZkV1ZGWmFWbGN4TkdReVZsZFhXR3hPVmxkU1dGUldXbmRsVm10M1ZXdE9XbFpyY0ZoWk1GcFRWakZhUmxKcVVsWmhhM0JRVlcweFUxSXhjRWRhUjNob1RWWlplbFp0Y0VkWlYwVjRVMWhvV0ZkSGFGWlphMlEwWWpGV2RHTjZSbGhXYkZwNFZXMTBNRmRHV25SVmJHaFlZVEZLUkZaclZYaGpiR1J5WVVad2FFMVZjRzlXYkZKTFV6RmtWMVp1VGxkaVJuQndWakJrYjJJeFpITlhiVVpxVFdzMWVsZHJhRTlXVjBwWVlVWm9XbUpHY0V4Vk1uaHJWakZhZEZKc1pFNVdNVXBKVm1wR2IyUXhXblJUYms1cVVtMVNXRmxVUm1GaFJtUlhWMjVrVjJKSFVqQmFSV1IzVkcxRmVHTkZhRmRTTTJob1dWUkdWbVZXU2xsalJrcHBVakpvV1ZkV1VrZGtNazV6Vld4YVdHSnJOVmxWYlhoM1pXeGtjbGR0Um1oV2EydzBWVEo0ZDFkR1dqWlNhbHBWVm14d1lWcFZaRXRUVmxKeldrZHNVMDFWY0ZKV2JUQjRUa2RSZUZwR1pGWmlSMUpZV1d4b1UxZFdWbkZSYm1SVVVtMTBNMVp0TVRCV01ERkZVbXBHVmxZemFFUldha3BIWTJ4a2NtVkdaR2hoTTBKUlZsUkdhMVF4U1hoalJXaHBVbTFvVkZSWE1WSk5iRnAwWlVkMGEwMVZiRFZXVm1odlZsZEZlV0ZHWkZwV1JYQlVWbTE0YzFkWFRrZGFSbWhUWWxobmQxZHJWbGROUmxwR1RWWmthbE5IYUZkWmJGSkdaREZhU0dWRmRHdFNNVnBJV1d0YVlWUnNXWGxoUkVwWFlXdEthRmxVUms5U01WcDFVMnhDVjJKSVFsQldWM0JIVW0xUmVGcEdhR3BTVjFKWVZGZHpNV1ZzV1hsT1ZtUmFWbXR3TUZsVldsTlhiVXBJWVVoYVZXSkdjR2haTVZwUFkxWkdjazVXVG1sVFJVcGFWbXhTU2sxV1VYbFNiazVWWVRKb2IxVnRNVk5XYkZwMVkwWmtWVTFZUWxkV01qVlBZVzFLU0ZWdWJHRlNWMUl6VmtjeFIwNXNXbkphUm1SWFpXdFZkMWRXVWt0U01WbDRZMFZhYUZJeWFGUlphMXAzVjJ4YWRFMVVVbXROYTFwSVZteG9jMVJzV25SVmJHeFdZbGhTTTFwV1duTmpiSEJHV2taYVRtRXpRbGxXVkVreFlURlplVkp1U2xSaWEzQmhXVmQwZDFNeGNGWlhibVJVVm1zMWVsWXlNVzlVYlVwR1kwUktWMkV4Y0hKYVZ6RlhVbXMxVmxwSFJsUlNXRUoyVmxkNFUyTXlTWGhXYmxKclUwVTFVRmxyWkRSV01WbDVaVVU1V0ZJd2NFbFdWM1IzVm14WmVtRklXbGRoYTBZMFZtcEtUMU5IUmtkWGJXaG9UVmhDTlZZeWRGZFpWazE1Vld0b1ZXRXhjRkJXYlhNeFZrWnNjbUZGVGxSTlZuQXdWRlpvYTFaRk1VVldhMnhXWWtkb2VsWlVTa1psVmxaelZteHdWMDB5WjNwWFZFSmhWakpTUmsxV1ZsWmlSMUpQVm1wT2IxZHNaSEpXYkdST1VteEtlVlJXV210aGJFcEdVMjFvVjJKSFVuWldWVnB6VjBVeFZtUkdVbE5pUm5BMFZsWmplRkl4VlhoWGJsWlNZbTE0V0Zsc2FFTlVSbFkyVW1zNVYwMVZjREZXUnpGelZUSktWMU5zYkZkV00yaHhWR3hWZDJWR2NFZGhSM0JUVmpGS2FGWnRjRUpOVjFaWFZXeGtXR0pyTlZoVVYzUjNWMVpzVmxkc1RsaGlWWEJKVmxjMVlWWXdNVmRqUjJoV1lXdGFhRnBGWkZOU01XUnlUbFprVGxaWVFrdFdiVEI0VGtkSmVWSllhRmhYUjJoWldWUktVMWRXYkhKYVJ6bFhZa1p3TUZSV1l6VlZNVXB6VjI1b1ZtSllhRkJaVjNONFYxWkdjbUpHVms1V2JrSlpWMVphWVZOdFZrZFVia3BvVW0xU1dGUlVTbTlOYkdSWVkwVmtXR0pXV2xoVk1qVlhWa2RLU0dGSVFscFdSVm96Vm1wR1lXUkZNVWxoUmxwT1ZteFpNRmRVUW1GWlZtUklVbGh3Vm1KSGVGaFpWM1JMWVVaVmVGZHNaR3RTTVZwSVZrZDRZVlJzV25WUmEyeFhZV3RzTkZWcVJscGtNREZYV2tkd1UySkZjRmhYVm1Rd1pERlZlR05HV2xoaWJWSlVWRlpvUTFOV2JISlhiRTVXVFZad1NGWXlOV0ZXTWtwSVZGaG9ZVkpGY0U5YVZscFBWMWRHUjFwSGJHbFNXRUkyVm14a2QxRXhiRmhVV0docFUwVndXVmx0Y3pGVlJscDBaVVYwYkdKSFVubFdWM1JQVmpBeFJWSnViRnBOUmxweVZqSnplRkl4VG5KVmJHaFhZa2hDVVZaVVJtRlNNazUwVm10a1lWSXllRmxWYkZKU1pERlplV1JIUmxwV2JHdzBWMnRhYTJGc1NsaFZiV2hXWVd0d2RsWkVSbHBrTVZweVpFWldWMkpIZHpGWGExWmhWREZWZDAxWVNsZGhiRnBZVlc1d1YxWkdXbFZUYTFwc1ZteGFNRmxWV21GaFZtUkdUVlJTVjJFeFNraFdWRVpyVW1zeFYyRkdRbGRpU0VKM1ZsY3dNVkZ0VVhoWGEyUllZbFJzYjFSV1dsZE5NVkpYVjIxR1ZXSkdjRWhXTW5odlZtMUtWVkp1V21GV00yaG9XWHBHZDFKc1pIUmxSbVJwVW0wNU5GWnNXbXRPUm14WVVteGtXR0V4Y0ZsWmExcGhWMVphY2xacmRHaFNiVkpZVjJ0Vk5XRnJNVmhWYWtaV1RXcEdNMVpVUm1GU01XUnpWbXhvVjAweFNqSldWbEpIVkRKTmVHTkZiRlJpUjFKd1ZqQmFTMVpXV2tkYVJFSmFWakZhV0ZaWGVHdFhSMHBWWWtab1dtSkdXbGhVYkZwelZteGtkRTlXYUdsV1dFSktWMVpXYjFsV2JGZFhXSEJvVTBoQ1dGbFhkR0ZqYkd0NVRWWk9WRkl3TlVsWlZXUTBZVlpLZFZGdGFGZGlXRkpVVldwR2MxWXhaRmxoUm1oWVVqRktVRlpVUW10T1IwbDRWbTVPVm1FeVVsbFZiVEUwVjFad1JtRkhSbFZpUlhBd1ZsZDRiMWRIUlhoV1ZFWlhZV3RHTkZadE1VOVNWa3B6V2taa2JHRXhXWHBXYlhoVFV6Rk5lRlJzWkZOaWF6VlRXV3RrVTJOR1dYZFdhM1JVVm14d1dsa3dWbXRXVlRGWFlrUlNXR0V5YUZoV1ZFcExVakZPYzJGR1dtbFNia0Y2Vm0weE5GbFdTWGhhU0ZKVFlsaENUMVZyV21GWFZscDBaVWM1YWsxcmNFaFZNV2hyVjBkS1NHVkdaRnBXTTFKTVZGUkdWbVZHWkhWYVJtUnBVakZKZDFkclZtRmlNa1pYVjJ4c1VtRXllRmhXYTFaMlpERnNWVkp0UmxkTlYxSjZWMnRrZDFVeFNsVldiR3hZVm0xUmQxZFdaRTlqTWtwRlYyeFNhR1Z0ZUZaV1YzQkhXVlpPUjFwSVNsZFdSVnBZVkZaa1UxSXhWWGxrU0U1WFRXdHdXbGxWWkc5WGJGbzJVbXhvVmsxR2NGUldNV1JIVWpGd1IyRkdUazVXV0VKU1ZtMHdlRTVIUlhkT1ZXUlhWMGRvY0ZWdGVHRldiR3hWVVZSR1dGWnNXakJVVmxKVFlrWmFkRlZ1YkZkaVJrcElXVlphUzJOdFRrVlJiVVpVVTBWS1RWWnRNSGhUTVdSWVVtdFdWV0pJUW05VVZtaERZakZrVlZOdWNFNVdiVkpaVlRKMGEyRkdTWGxoUlRsWFRVWmFURlp0ZUZwbFJtUnpXa1prYVZac2NFcFdiR1F3WWpGVmVWSlliR2hTZW14WFdXeFNSMVpHYTNkWGJIQnJUVmhDU1ZReFpITlViRmw0VTJwV1YySkhVWGRaVkVaaFkyc3hWMWR0YkZOU2EzQmFWMVpTUzJJeFpFZFhiazVoVWxoU1ZWVnFRbUZUVmxGNFYyeGtWMDFFUWpWWlZWVjRWMGRLUjFkdGFGaFdiVkpVVlcxemVGWXhXbk5YYld4VFlUTkNVVll4WkRCWlYxRjNUbGhPV0dKcldsUlpiRkp6WTFaU1dHUkhSazVTYkhBd1ZHeFdNRmRHU1hkalJscGFZVEZ3ZGxZeWVGcGxiRlp5WlVaV1YxSldjRmxYVkVaaFV6Sk5lVlJyYUd4U2F6VlBWVzAxUTFSR1duRlRha0phVmpCV05GWlhOVk5WTVdSSlVXeE9XbUV5VWxSV01GcGhaRmRPUmxwRk5VNVdia0pIVmxjd2VGSXlSbkpOVm1oV1ltMW9XRlJYTlc5VlJteFhWMnR3YkZZd1draFpWVnB2VmpKS1YxSnFUbGROVm5CeVZrUktUbVZHY0VkaVIyaFRUVVp3VlZacVFtRlRNVnBYVjJ0a1dHSlZXbkpVVlZKSFUwWnNjbGR0UmxkTlZuQkhWakl3TlZZeVNsbFZhazVYVFc1b1dGWnFTa2RUVmxKeldrVTFhRTB3U21oV01WcFhZakZKZUdKR1pGUmhNWEJ4VlcweGIxWXhiRmhrUjBab1VteHNORmRyVmpCVk1ERlhWMjV3V2xaV2NGQldSekZMVjBadmVtTkdaR2xYUjJoNFYyeFdWazFXU1hsVGEyUmhVbTFvYjFSWGVFdGtNVnBWVVcxR1ZFMVdSalJXTWpWVFlXMVdjbGRzYkZkaVdHZ3pWRlZhZDFac2NFWmFSbFpwVWxoQ05sWlVTalJpTVZsM1RWaFdWVlpGV21GV2JYaDNVekZ3UlZOck9WTmlWVnBJV1RCVk1WVXlSWHBSYTFwWFlsUkZNRmRXV25OWFJsSlpZVWRHVkZKc2NGWlhWM1J2VVRGa1IxZHVVazlXVlRWV1ZtMTRkMDFHY0ZaYVJXUlhVbFJHZWxVeWVITldNVWw2Vlc1S1YwMUhVa2hVYlhoaFpGWkdjMk5IYkZOTlZXOTRWako0WVZsV2JGaFZhMXBPVm0xNGFGVnRjekZVTVZwelZXdGFiR0pHY0VsYVZXTTFWbFV4V0ZWcmJGWk5hbFpNV1ZkNFQxSnJOVmRhUm5CcFVtdHdTVlp0ZEdGWlYwNXpXa2hPWVZJelFrOVdha1pLWlVaWmVXUkhkR3BOVmtwNlZqRm9iMVpIUm5OWGJHaGFZa1pLUkZScldsZGpWa3B6WTBkMFRsSkZXbUZXYTJRMFZUSkdWMU5ZYkdoU2JXaFpWbXBPYjFaR1duRlNiR1JUVFZoQ1NGZHJXbTloUlRCM1UyNXdWMkpZUWtoWFZscFBVakpLU1ZOc2FHbFdWbkIyVm0wd2VGVXhUa2RXV0d4cVVqQmFXRlJXVm5aTmJGWnpWV3RPV0ZKc2NEQldWM2hEVjIxV2NtTkdRbFppV0dob1dYcEdUMlJIU2tkVmJFNVhWMFZLYUZadGNFZGhNRFZJVTFoc1ZGZEhhR2hWTUZVeFYxWnNkR1JJWkZoV2JYaDZWbGMxVDJGc1NuTlRiR3hoVWxkU1NGbHJaRXRTTVZweFZtMUdWMVl3TUhoWFZscGhVekpPZEZOclZsZGlTRUpZVm0wMVEyVldXbkZUV0doVVRWVTFTVlZ0ZEhOWFIwcElWV3hTVjJKVVZrUlpha1poVjBkV1NGSnNVazVpUlhCWlZteGpNVlF4YkZkVGJsSldZbFJzYUZacVRtOVpWbEpXVjIxR2ExSXhTa2xhUldRMFlVZFdjbGRzYkZkaVdHaDJXWHBHWVZOR1RuSmhSbHBwVW14d2FGZFdVa3RpTVVwSFYxaG9XR0pyTlZoV2JYUjNUVVpXZEUxWVpHaFdhM0I2V1RCU1UxWXhXa1ppTTJSYVZrVmFWMXBXV2t0alZtUnpWRzFzVTAxdGFHRldNVnBUVXpGVmQwMUlhRmhpUmxwVVdWUk9VMWRHYkhOV1ZFWlVVbTE0VjFZeU1UQldhekZ5WTBaa1ZWWnNTbFJXYWtwTFVqRk9jbVZHWkZkU1dFSlFWMnhXWVdReFRsZFhiazVZWWxkb2MxbHJXbmRYYkZwMFkwVk9XbFpyTVRSV01qVlBWMGRLU0dGSVJsWmlSMUpVVjFaYVlXUkhUalpTYkdoVFlraEJkMVpIZUdGVU1rWlhVMjVLVDFaWGVGaFdibkJDVFZaYWNWTnJkRmhXYkZwNFZrY3hSMVl5U2tsUmFsWllZVEZLU0ZkV1pGTldNVloxVkcxR1UxWkdXblpXUmxKRFV6SkdSMWR1VW14U00wSnpWV3BDYzA1R1pISldiWFJZVWpCd2VsVXllR3RYYlVWNFYydDRWMDFHY0hwV01HUlRVMFpLYzFkc1RtbGhNSEJLVm0xd1MwNUdVWGxTV0doVVltdHdjVlV3YUVOWFJsWnhWR3MxYkZKc2NFbGFWV1JIVjBaYWNsZHVjRmhoTVhCeVdWWmFZVkpzVGxWUmJHUlRZa1p3YjFacVNYaFdNVTVIVkc1S1lWSXdXbFJaYkdSdlYyeGFXR05GZEdsTlYxSjZWMnRhYjJFeFNYcFZiR1JWVmpOU2FGVXdXbUZqTWtaSVpFZG9VMkV6UWxoV1IzaGhZVEZhZEZOc2JHaFNSVFZXVm14YWQwMHhXblJsUjNSclVqRktTRlp0Y3pGV01rcHlVMVJLVjJKVVFqUmFSRVphWlVkS1IxcEdVbWxTTW1oWFZtMTBWMWxXYkZkWGJrNVlZa2RTVUZWdE1UTk5iRlowVFZSQ2FFMVdiRE5aTUZadlYwZEZlRlpZYUZwV2JWSk1WakJhZDA1c1RuTmFSMnhZVWxWd1RWWXllRmRaVmsxNVZXdGtXR0pyY0c5VmJYaGhZakZTV0UxWE9XdGlSbkJaVkZWU1IxVnJNVmRTYWxKYVlUSm9WRlpIZUdGT2JVcEhZVVprYVZkSFozcFdSbFpoVlRGWmVGWnVUbFZpVjJoUFZXdFdZVmRHWkZWUmJUbHJUVmRTZVZSV1ZtdFhSMHB5WTBab1dtSkdTa2hXUlZwWFpFZE9ObEpzYUZOV1IzaFpWbTB4TkdFeFZYaFhiR3hTWVhwR1dGbFVSbmRYUm1SWFYyNU9XRkpzV25sWlZWcFhZVVV4V1ZGdWJGZFdNMmhVV1hwR1lWSXlTa2xUYkdScFUwVktVRlp0TVRSa01XUlhWV3hrVm1KRk5XOVZiRkpIVjBacmQxWnRPVmhTTUZZMFZqSTFkMVl4V2paU2EzaFhZa2RTVEZWcVJuZFNNazVJWWtaT2FFMHdTa3BXYlhSaFZqRnNWMXBJVWxaWFIyaG9WVEJhWVZac2JITmhSVTVWVFZad01GcFZhR3RVTWtwSFlrUldZVkpXY0doV1IzaGhZekZPZFdOR1pFNWhiRnBaVm14amVGSXlUWGhVYms1b1VtMVNiMVJXV25abFZscEhWbTFHYWsxV2NGaFdSelZMV1ZaSmVsRnRPV0ZXTTFKb1ZqRmFhMVl4V25SU2JIQlhUVVp3U2xaWGVHOWlNa1p6VTI1U2JGSnRhRmhaYlRWRFYwWlNWVkpzWkdwV2EzQjVWREZhVDFSc1dYaFRhbHBYWWxSRk1GWkVTa2RXTVhCR1drWlNhVkpzY0ZsV1Z6RTBaREZaZUZWc1pHRlNiVkp4VkZaa1UwMVdXbGhOVkZKV1RVUkNORlV5ZUc5V01VcDBWVmhrWVZKRlduSlZha1poVjFkR1IxZHRhRTVOVlhCYVZtdGFZVll5VVhsV2JrNW9UVEpTYUZWdWNITlhSbEpYVm01a1UwMVhkRE5XYkZKWFYyeGFjMk5HYUZwTlIyaE1Wakl4VjJOdFRrWmxSbHBPVWpGS1RWWlhjRWRWTWs1eVRsWmFUMVl5ZUZoVVZ6RnZWMVphZEUxSWFFNVNiWGhZVm14b2IxWkdaRWhoUmxwWFRVZFNkbGxWV2xkak1YQkhWR3hvVjJKWWFGZFdWRW8wVkRGa1IxTnVVbXhUUjNoWVdXdGFTMU5HV25Sak0yaFhUVlUxZWxkcldtdFdNREI1WVVoc1YyRnJTbWhWZWtwVFUwWmFjbUpIYkZOaVZrcFFWMVprTUZsV1RsZFhia1pTWWxoU1ZWUldXbk5PUm1SeVlVWmthR0pGY0RCV1YzTTFWMjFLVlZKdVdsVldNMmhvV2tWa1YxTkdTbk5oUjJ4WFlraEJNbFp0TUhkTlZsVjVVbXRrVkZkSFVsbFphMlJ2V1Zac1ZWTnRPVk5TYkd3elZqSXhNR0ZyTVZoVmJuQlhUVzVOZUZacVNrdFRWa1paV2taa2FWSXhSak5YVmxKSFl6RlplRlJ1VGxkaVIxSndWV3BLYjJGR1pGaGtSMFpVVFd4S2VsWlhOVTlYUjBwV1YyNUdWVlp0VVhkVWJYaHpWbXhhVlZac1drNVNSVnBLVjJ0b2QxRXhaRWRYV0hCV1lsZG9ZVlpyVm1GaFJsVjNWMnM1YW1KVldraFdNakZ6WVVVeFdWRnNiRmROVjFFd1dXcEtTbVZHVm5KYVIwWlRZbFpLV2xkWGRGWk5WbVJYVm01T1ZtSkhVbGxXYlhoSFRrWmFjMVZyWkZkV01IQklXVEJvZDFZd01WaGhSRTVYWVd0d1NGa3lNVXBsYkhCSFZteGtWMDFWY0VwV01WSkxaVzFXUjFkWWFHcFNWMUpYV1d4a05HTkdXWGRhUnpsWVVteHNORmRyVWtOaFJURlhWbXBXVjJKVVZsQlpWbHBMWkVaV2MySkdjR2hOYldoRlYxaHdSMWxYVGxkU2JsSlRZa1pLV0ZsclZscE5SbHB4VTFob1RsSXdXa2hXTWpWUFlXeEtXRlZzYUZwaE1sSjJXVEo0V21ReFpIUlNiWEJPVmxSV05WZHNWbUZoTVZsNVZtNUtXR0pIZUZoV2FrNURVMFphY1ZOck5XeFdhelY1V1ZWa2MxVXlSalpXYm1SWFZqTm9kbFZVUm5OV01XUjFWRzFHVkZJeFNsWldSbVF3WXpBMVIxcElTbWhTVkd4aFZtMTBkMDFHYkZaV1ZGWlhUVVJHU1ZsVlZsTldNVXBHVjIxb1lWSldWalJXYWtaVFl6SkdSMVJ0YkZoU01tTjRWbXBHWVZZeGJGZFZXR3hUWVRKb1ZWbHJaRk5YVm14MFRWUlNXRkpzU2xsWk1GcHJWVEZLYzJOSWNGZE5ha1pJV1ZkemVHTnJOVlpoUm5CWFZtNUNXVlp0Y0VkVE1WbDVWR3RzYVZKdGFGaFZiR00wWkRGa1YxVnJkRlZOYXpWNVZERmFhMWxXU1hkWGJGSlZWbnBHZGxwWGVHdFdNVlp5V2tkMFRsWXphRmxXYWtadll6SktSMU51VWxaaWEwcFdWbXBPYjFOR1VuSlhiSEJzVWpCYVNWcEZXbGRoVmtsNFUydG9WMkZyYnpCV1ZFWnJZekZrY2xkdGNGUlNia0paVmtaV1lXUXlWbk5YYms1WVlUTlNjbFp0TlVOVFJscDBaVVU1YUZadFVrbFdSM0JYVmpKS1IxTnJlR0ZXTTAxNFZtcEdZVmRYU2tkVmJXeFRZbXRLTkZac1pEUmhNRFZIVjFob2FWTkZOVzlWYm5CelZqRldkR1ZJWkd4U2JGcFlXVlZqTlZZd01YSmpSV3hYVmpOb00xWXljM2hTTWs1SlUyeHdWMkpJUW05V1Z6RTBZVEZrV0ZSclpHRlNiVkpQVkZWV2QxTnNXblJrUms1VVRWWldORlV4YUc5WFIwcHlUbGhDVm1GcmJ6QldhMXB6WTJ4a2RWcEhkR2xTYmtKSlZtcEpkMDVXVm5KTldFNVRZV3hLV0ZSWE5XOWtiR3hZWlVWMFYyRjZWbGxWYlhocllWWmFSbGRzVmxkV1JVcG9Wakl4VjFack5WZFhiVVpUWWtoQ2QxWlhjRWRUTVU1elYyNU9XbVZyV2xaVVZscDNUVVpWZVdWSVRtaFNhM0JIVkd4YVlWWXlTa2RqUkU1WFlURndhRnBGVlhoV2JIQkhWV3hPVjFJemFGcFdiWEJMWldzeFYxWllhRlJpUjFKd1dsZDBZVmRHYkZWVGJFcE9VbTE0ZUZVeWVFdGlSa3AwVld4d1dsWldjRlJaVldSTFUxWkdjMkpHYUZkTk1VcHZWbGh3UjJNeFdYaGFTRlpWWWtkb2NGbHNXa3RXTVZwWVRVUkdVazFWYkRSV01XaHpZa1pKZWxWdE9WVldiRm96Vm0xNGMyTnNaSFJQVm1ST1lUTkNZVmRXVm05VE1XUnpWMjVPYWxJd1dtaFdiVEZUVTBaV2RHVkhkR3BOV0VKSFZHeGFhMVJzV2xoa2VrcFhZbGhvY2xwRVJrNWxSazUxVld4a2FFMXNTbTlXVkVKV1RWZEdSMVp1VW14U1dGSnhWVzB4TkdWV1duUk9WM1JYVFZad01GWlhlSE5aVmtwWVZXdG9WMDF1YUdoWmVrWkxZMVpXYzJOSGFFNWlWMmhPVm0weGQxTXhUWGxWYTJSWFltczFXRmxyV25kalJsbDNXa2MxYkdKR2NGbFVWbEpUVmpBeGMxTnJaRlZXYkhCb1YxWmFTbVZYUmtkVmJHUm9UVlp3YjFacVNqUmhNazE0VjI1U1UySlhlRTlXYlRWRFRsWmFSMWR0Um1sTmExcElWa2QwYzFWdFNsWlhiVVpYWVRGYWFGUlVSbUZTYkdSMVZHczVhVkpZUWpWV1JFWnJaREZTYzFkWWFGUmhiSEJZVkZjMVUyTnNiRFpTYlhSVFRWVTFXbGxyWkc5V1JrcDFVV3hzV0Zac1NraGFSRVpoVWpGYWRWSnNVbWhOV0VKNlZsY3dlRlV4WkhOaVJscGhVbGRTV0ZWdGRIZFdiRnAwVGxjNVYwMVdiRFpWVjNoRFYyMUdjbGR1U2xaaGExcFlXWHBHZDFJeGNFaGlSMnhYWVROQ1dGWnRNSGRsUlRWSVZGaGtUMVp0VW5GVmJGcDNZVVpXY2xacmRHbE5WbkI2VmxkMGExZEdTbk5XYWxaVllrZG9jbFpxU2tkT2JFcHhVbXhrVjJWcldqSldiWEJDWlVaT1IxWnVTbUZTTUZwWVZGUktiMU5XWkZsalJYUlRUVlZzTkZrd1ZtOWhWa2w1WlVjNVZWWlhhRVJWTW5oaFpFZFNTRkpzWkU1V00yaGFWbGQ0YjJJeFpFZGFSV2hvVWpKb1YxUlZXbFpsUmxwMFpVaE9hazFyV2tkV1IzaFhWR3hhZEdRemNGZGlWRVYzVkZWYVlWSXhUblZVYlhCVVVqSm9XRlpHV210aU1sSnpZa1pXVWxkSGFGaFVWM014VWpGc1ZsZHRSbFZpVlhBd1dWVmpOVmRHV25SVlZFSldaV3R3VkZVd1drdGpiSEJJWWtaT2FWWnJjRE5XYlhCRFlUSkplRlZzWkZoaVJscFRXV3hXWVdOc1VsZFdibVJZVW14V05WUnNWVFZXTVZsM1kwVmtWV0pHVlRGV2FrcEhZMnhrY21WR2FGZGlTRUpvVjJ4YWExVXhUa2RUYmxKcFVsUldiMVJXYUVOWlZscHpXVE5vYTAxWGVGaFdNV2h6VmtkS2MxTnRPVlppVkVaMlZtcEdjMk15UmtoUFZUVk9Wak5vV0ZacVNYaE5SbGwzVFZac1VtRXlhRmxaVkVwVFRURmFTR1ZIZEZOaVJUVjVXa1ZhYTFZeFNsaFBTR1JZVmpOQ1RGVnFSbHBsUjA1R1YyMUdVMkpGY0hkV1YzQkxZakZrVjFkc2FFNVRSMmhYV1d4YVIwNUdhM2RXYkdSV1RXdFpNbGxyYUVkV1ZscHpZMFJPWVZZemFIcFdiWGgzVWxaR2MxcEdUbWhOYm1OM1ZteFNTMDVIVVhoWFdHaFlWMGhDVTFsVVJrdGhSbFp5Vm0xR1ZsSnNXbmhWYlRFd1YwWlpkMk5GWkZWTlZuQnlWakJhUzJOdFRrZGpSbVJPVmpGRmQxWnRjRWRqTVdSSFYyNU9ZVkp0YUZsVmFrNXZaV3hhV0dWR1RtcE5WM2hZVmpJMVUySkdUa2hWYms1YVlUSlJkMVJVUmxwbFYxSkdUMVpvVTAxSVFsbFdha2t4WXpGWmQwMVlSbGRoTTJoWlZtMTRkMVJHV1hkWGJHUnFUVlZhZWxZeU1XOWhSVEZaVVd4YVYwMVhhRE5WYWtwU1pVWk9kVk5yT1ZkaVYyaDNWbGN3ZUZVeFVYaGlTRTVoVWpOU1VGWnRlSGROUmxKV1lVZDBhRTFFUm5wVmJYQlhWakpLV1ZWdGFGZFNSVnBvVmpCYVYyUldSbk5YYld4WFVsWnZlVlp0TVhkU01XUjBWVmhvYWxKWFVsWlphMXBoVkRGYWRHVkdjR3hpUm13MVdrVmtkMVF4V1hkWGJuQldUV3BXVUZZd1pFZGpiRTUwWVVaa2FWSXhTakpYVkVvMFYyMVJlRnBJU210U00wSlBXVlJPUTFJeFduSmFSRkpwVFd0YVIxUldhRXRVYkU1SVlVWm9XbFl6VWt4WlZWcHJWakZ3Ums1WGVGZGlSWEExVm0weE5GTXlSbGRYYkdScVVteGFXRmxzYUVOVFJsWTJVbXM1VjAxWFVqRlZiWGhMWVZaa1IxTnNXbGRTYkhCWFZGWmFUMVl4WkhOaFIzUlRZbFpLV1ZadGNFTmtNVTVYVjJ4b2FtVnNXbGxaYTFwelRteGFXR1JIZEZwV2JIQllXVEJvUzFZeVJuSlhiV2hoVWxad1RGbDZTazlTTVhCR1RsWk9VMkpHYkRaV2JURTBWVEZOZDAxVlpGaFhSMmhaV1cxNFMxWldiRlZUYkU1cVZteFdNMVp0ZERCV01ERllaVVpzWVZKWGFISlpWRXBMVTFaR2MyRkdaRTVoYTFwSlYxWlNSMU50VVhkT1ZscGhVakJhVkZadE5VTlZWbHB5V1ROb1UwMUVWbnBXTW5oeldWWktkRlZzYUZaaVIwMHhWRlJHWVdSSFRrWmFSbkJYVFZWd1NWWnJZekZUTWtaSFUyNU9hbE5GU2xoWlZFcFNUVVpzVmxkdFJtdFNNVXBJVjJ0YWQxWXhXa1pUVkVKWVZqTlNkbFZxUmxabFZrNXpZa1phYVZJeWFGbFhWM2h2VkcxV1IxVnNaRmhpYTNCeVZGWmFkMVpzVm5SbFIzUlZZbFZXTmxWWGRIZFhSMFY1WVVST1ZsWkZXbkpWYWtaclkyeGtjMVZ0YkZOTmJXaHZWakZhYTAxSFVYaFVhMlJYWW10YVZGbFljSE5qYkZwMFkzcEdiRlpzUmpSV01qRXdWakF4Vm1KRVdscFdWbkIyVm1wS1MxWldSbkZWYkZab1RWaENObFp0TVhwbFJrNVlVbXRrYUZJeWVIQlZiR2hEVG14YWMxa3paRTVXYTFZMVZrWm9iMVl5U25OVGJFSlhZa1pWZUZaclduTmpiR1IwVW14b1YySnJTbGhYVmxaclRVWlpkMDFWVmxOaE1YQlhXV3hvYjJOc1duRlJXR2hYVFZVMWVWbFZXbXRoUjBWNlVXc3hWMVpGU21oV1ZFWnJWMFpLY2xwSFJsTmhlbFpWVm0wd01WRnJNWE5YYmxKT1YwZFNWRlJXV2xkT1ZscElUbFU1V2xack5VZFpNRnBIVmpKS1ZWSnNVbGRTUlZwNldYcEdkMU5GT1ZkaFJtUnBVak5qZDFadGNFdE9SbEY0Vmxoa1RsWnRhSE5WYlRGdlYwWmFjVlJzVG1waVIxSllWakowTUdFeFNuTlhibkJhWVRGd00xbFdXa3RqTWs1SVQxWm9WMUpYT0hkV2JYQkxWRzFXUjFkdVZsUmlWVnBVV1d4YVMyUXhXbGhOUkVaU1RWZFNlbGRyYUU5V01rcFpVV3hDVjJKWWFETmFWbHBUVmpKR1JtUkhhR2xTV0VKYVYyeFdhMkl4V25KTlZXaG9VbFpLVjFSVlduZFpWbkJGVW01a1UySldTa2hXUjNNeFZqQXhWbUpFVWxkaVJrcE1WR3RhV21WR1pGbGhSbWhwWWtad1ZGZFhNSGhPUm1SWFYxaGthRkpWTlZWVmJURTBWbXhWZVdWRk9WZE5SRVpZVlRKd1IxWXhXalpTYWs1WFZrVndTRlJ0ZUdGak1rcEhXa1pPYVZaVVVYZFdNV1IzVWpKRmVGZFlhR0ZUUmxwVldXdGtiMk5HV1hkWGEzUnNWbXh3U0ZZeU1VZGhhekZGVm10b1YwMXVVblpaVkVaS1pXeFdjMkpHV21oaE1HOTZWMnhhWVZVeVRYaGFTRlpWWWtkb2NGWnNhRU5UVmxweFUxaG9hVTFYVW5sVVZtaFhZVVpLZEdGSGFGWmlSMUpVVmpCYVZtUXhaSEprUjNCT1YwVktTbGRYZEdGVU1rWlhWR3RhVkdKWGFGaFpWM1IyVFVaYWNWTnJXbXROUkVaWFYydGFiMkZXU1hsaFJscFlWbXhLU0ZwRVNrOVdNVnAxVTJ4a2FWWldjRmxXUmxwaFpEQXhWMkV6WkZkaVdGSnZWRmQwZDFOR2JISlZhemxZVWpCV05GWXhhR3RXTVZwR1VtcFNXazF1VFhoV2JURlBVakZrY2s1WGJHbFdNbWN4Vm1wR1lWWXlSWGhUYmxKWFlUSm9WbGxVU2xOV1JteHlXa1pPV0ZKdVFsbGFSVnAzVkcxS1IyTkZiR0ZXVjFKSVZqQmtTMVl4WkhOaFJscE9ZV3hhVFZkV1ZtRlRiVlpZVW10a1ZtSklRbGxWTUZaTFYxWmtjbHBFVW1oTmF6RTBXVEJXVjFadFNrbFJiR2hYWVRGYWFGUnRlR0ZqVms1VlVteFNUbFl4U2twV1ZFb3dXVlpSZUZkdVNrOVdiSEJZV1d4b2IxZEdVbkpYYkU1cVRWZFNlbGRyWkRCVk1ERldZMFZ3V0dFeFdtaFpha1pXWlZaT2MxcEdVbWhOTUVwYVZtMHhORmxYUmtkaVJGcFRZbGhTY2xWdGRIZFhiR3h5VjIxR2FGWnJjSGxaTUdSdlYwWmFkRlZZWkZoV2JIQm9WV3BHYTJSV1NuTlViV3hYVm01Q05WWnRNSGhPUmsxNVZteGtWbGRIYUZsWldIQnpZakZhZEdWSVpHeFdiWGd4V1RCV2ExWXdNVVZTYkdoYVRVWndkbFpxU2t0WFZsSlpZVVprYUdFeGIzcFdWekUwWkRGSmVGWnVUbWhTYXpWUFZteG9RMWxXV25GU2JVWm9UVVJXU0ZaR2FHOWhWa3AwVld4a1dtRXhjRE5XTVZwelpFVXhWMVJ0Y0U1V00yZzFWbXBKTVZReFVYaFhibFpTWWtkU1dGUlhjRmRqYkd4WFYydHdhMDFyTlVkWlZWcGhWRzFLZEZvemNGZGhhMjh3VjFaYVdtVldVbkppUmxKcFVqRktWVlpHVWt0aU1rbDRXa2hLV0dKVldsUlVWM2hMVWpGUmVGZHRkR2hTYTJ3MVdWVlZOVll5U2xWV2ExSlZZa1p3YUZwRlZYaFhWbkJIVkdzMVYyRXhhM2RXYlhCSFlqSk5lRmRzYUZOWFIyaHhWVzB4TkZsV1dYZGhSVTVzWWtac00xWXlNVWRoYlVwSVZXcENWbUpZYUhaV2FrcExWakZPYzJOR1pGTmlTRUpWVmxaU1IxWnRVWGROVmxwWFlrVndiMWxyVm5kWFZscEhWMjEwYVUxc1ducFphMmhMVjBkRmVsVnVTbFppV0dob1ZGVmFVbVZHWkhOYVJtUk9WbTVDTlZkVVFsZGpNVmw0VjJ0YVdHSlhhRmhaVjNSM1ZERndWMWRyZEdwaVZWcElWVmQ0YTJGV1duSmpSbHBYVFZkUk1GZFdXazVsUmxKMVZHMUdVMkpXU2xsWFYzaFhXVlprUjFWc1pHRlNhelZ6V1d0YWMwNVdjRVphUldSb1VteHNORll5TlhOV2F6RjFZVWh3VjJGcmNFeFdNV1JIVWxaU2MxcEhhRTVYUlVwMlZqSjBWMkV4V1hoVWJHUnFVbGRTVmxsWWNGZFhSbXhWVTFSV1RrMVdiRFZhVlZwcllVVXhjazFVVWxkaVIyaDZWbXRrUzJOdFRrZFdiR1JvVFZad1RWWnFRbUZqTWs1elkwVmFVRlpVVms5V01GWkxWMFphZEdWSE9XbE5WbFl6VkZaYWEyRnNTblZSYlVaYVZrVmFNMVpyV25OV2JGcFpZVVpvVjJFeGNEWldWekUwWVRKR1NGSllaR3BUUjNoWVZXcE9VMk5zVm5GU2EzQnNVbTFTTVZadGVGZGhWa2w1WVVoa1dGWXphR2hWZWtwWFVqRndSMkZIZEZOTk1VcFJWbGN3ZUZVeFRrZFhXR2hvVTBVMWIxUldWVEZUVmxwWVRVUldWMVpzY0ZoVk1uUnZWbTFLV1dGSGFHRlNWMUpVVlRCYVMyTXhjRWhpUms1cFYwZE9OVlpxUm1GV01rbDRWRmhvV0ZkSGFGbFpWRVozVmtac1dHTjZSbWhTYkhCNlZqSTFhMVpzU25WUmEyUlhZa1pLV0ZacVFYaFhWa1p5WWtad2FFMVlRbEZXYTJRMFV6RkplRk51UmxWaVIxSndWbXRXU2sxR1pISlZhMlJVWWxaYVNGWlhOVmRXYlVwSVZXMDVWVlo2Um5aV2FrWnJWakZXY2xwSGRFNWhNWEJKVm0wd01WSXhXa2hTYms1VVlrZG9WMWxzYUc5VVJscHhVbXh3YkZaVVZsbGFSVnByVkd4YWRWRnFXbGhXUlVwVVZWUkdjMVl4VG5OaFJscG9UVzFvV1ZaR1l6RmlNa1pIWTBWYVdHSkhVbkZVVjNSaFUwWnNWbHBIT1ZWaVIxSkhWVEZvYzFZd01WZGpSbEpXWVd0YVQxcEVRVEZYVmxaelZXMW9UbUpGY0ZoV01XUXdXVlpzVjFwRlpHbFRSVFZaV1ZST1UxZEdXblJOVms1c1lrZFNlVlpYZUU5WFJrbDNZMFpvVjAxdWFISldiR1JMVWpKT1NHRkdhRmRpU0VKTlYxaHdTMVF4VGxkU2JrNWhVako0VkZSWE1XOVNiRnAwVFZoa1UwMXJWalJYYTFadlZtMUZlV0ZHVWxwaE1YQm9Wa1JHWVdSRk5WWlViR2hYWWtoQ05GWlVSbE5TTVZweVRWWmthbEpGU2xkVVZ6VlRZMnhhY2xwRmRGUlNiRnA2VmpKNGEyRldTblZSV0hCWFVteEtTRnBFUm10VFJscHlZa1pTYVZkSGFGbFdiWFJYV1Zaa1IxZFliR3RTTUZwV1ZGZDBZVk5XV25ST1ZrNXBVbXR3TVZWWGVITldNa3BaWVVkb1dsWldjR2hWYkZwUFkyeHdSMVJ0YUd4aE1YQm9WbXhqZDJWSFNYaFdXR2hVWW1zMWNWVnRNVFJYUmxaMFpVaGthbUpHY0ZsVVZscExZa1pLZFZGcmFGaGhNbEpJVmxSR2ExSnNUblZqUm1SWFpXdEpNRlpzVWtKbFJsbDRXa2hPYUZJemFGUlpXSEJYWkd4YWRFMVVRbXBOUkZaNldXdGFZV0ZHU1hkWGJHaFZWbXh3ZWxSdGVGZFhSMUpIVkd4b1UySklRalpYVkVKcllqRmtkRlp1U2xoaWEzQm9WVzE0ZDFSR2JEWlNiVVpyVWpCd1NGZHJXazlVYXpGMFlVYzVWMkpVUlRCWlZ6RlNaREF4VjFwR1RsaFNNbWhXVm1wQ2EySXlSa2RXV0dSWFltMVNXVlp0TVRSWGJHdDNZVVU1VjAxRVJsaFZNbmh2VmpBeGNWWnVTbHBoTVhCb1dYcEtTMUpXV25OalJUVlRZa2hDVWxadGNFTmhNVTE0VTFoc1ZXRXlVbTlWYlRGVFkwWldjVk50T1U1aVJuQXdXVEJXTUZVd01YSk9XSEJZWVRKb1dGWnJaRXRTTWs1SlVXeGtUbEl4U2pKV2JGcGhXVmRTU0ZacmFGTmlSbHBQV1Zod1JrMUdaRlZSYkdSYVZteEdORll5TlZOV2JVcFZZa1phVjJFeFdreFdSVnBYWTFaS2RGSnRkRk5XUlZwWFZteGtORmxXVW5OWGJHaHJaV3RLV0ZsVVNrNWxSbHBWVW14d2JGWnJjRnBaYTFwaFlWWlplV0ZHYUZoV00yaFVWVzF6ZUZJeVNrbFNiRTVwVWpGS2VWWlhjRWRaVmtsNFkwVmFXR0pVYkZoVVYzUjNVMFpaZUdGSVpGZE5hM0JXVld4b2ExWldXbGhWYTJSaFZteHdVRmt5ZUhkVFIwNUhWRzFzV0ZJeWFGbFdiVEIzWlVVMVIxUllhRlJoTWxKWldXMTBkMWRHV1hkYVJ6bFlWbXhhZUZWdE1VZFdSa3AwWlVaa1YwMXFSWGRXYkdSTFZteGtkV05HWkU1aWJXaFpWbXBDWVZkdFZuTldibEpvVW0xU1ZGVnNXbmRWVmxwWVkwVmtXbFl4U2xoV1Z6VlBXVlpKZVdWR1VscGhNbWhFVmpKNFdtVkdjRVZWYldoT1lUSjNNRlpVU2pSaE1XUklVMjVLV0dKR1NtRlphMXBoWVVaYWNWSnNUbGROVjFJeFZrZHpOVlV5U2toa2VrWlhVak5vYUZaRVNrZFNhekZYVjIxd1UxSlZjRmxXYlhCUFlqRmFSMWRZYkd4U01GcFVXVmh3VjFZeFdsaGxSM1JvVWpCV05Ga3dhSE5XTWtaeVUyNUtWMVpGV2xCVmFrWlBaRlpXZEdKR1RsZFNiSEJhVm10YVlWWXlVWGhVV0doWVltczFhRlZyV2t0alJsSllaRWhPVDFac1dqQlViRlUxVmpGWmQxWnFVbHBOUjJoSVZtMHhSMk5zVG5SaFJtaFhZa2hDYjFkVVNqUlpWMUpYWTBWa1lWSnJOWEJWYlRWQ1RVWmFjMWt6WkU1V01GWTBWbXhvYjFkSFNuSmpSa0pYVFVkUk1GWXdXbE5YUjA1R1YyczFVMkpZYUZsV2FrcDZUbFpWZVZOcldrOVhSM2hoV1ZSR2QyTnNXa2hOVlhScVRWVTFlbGxWV210Vk1rcEpVVzA1VjJGcmJEUldWekZTWkRBeFYxcEhSbE5pVjJoM1ZtMXdUMkl4V2xkWGJHaE9Va1ZhVTFSV1pGTlhSbVJ5VjIwNWFFMVZiRFpXVnpWRFZsWmFWMU5yVWxWaE1YQm9Xa1ZWTVZac2NFZFhhelZvVFRCS1MxWnRlR3BOVmsxNFYyNVNWR0pIZUc5VmExVXhZVVphZEdWSVpHcGlSM1ExV2xWa01HRnJNVmxSYTJ4YVZsWndjbGxWVlhoa1ZtdDZZa1prVGxadVFsbFhWM0JIWXpGWmVGcEdiR2hTYldodldXdG9RMVpHWkZkYVJGSlVUVmQ0V0ZscldtOWhNVTVJVld4a1ZtSllhR2hhVlZwV1pWZFNSVkZzWkZOaVNFSTFWa2Q0YjJReFpITlhiR2hXWW01Q1lWWnRlSGRoUm10NVRWVTVWRkpyY0hwWGEyUnpWVEF4UlZWcVdsZE5ibWhZVjFaYVlXUkdXbkphUjNCVFZqRktiMVpYY0U5Uk1WcEhZa2hLYUZKVk5XOVZiVEZUWld4a2NsVnNUbGhpUm13eldXdFNVMVl3TVhGV2JFSlhZbFJHUjFwV1dsZGpNa3BIVjIxc1YxSldXWHBXYTFwVFVqRmtkRlpzV2s1V1ZscFlXV3RrVTFReFZuSldiVVpQVm0xU1ZsVlhNVWRYYkZwellrUldWazF1YUhwV2JURkxZekpPUjJGR2NGZE5NVXB2VjFaV1lWWXlVa1pOVmxwUVZtczFjRlV3Vmt0VGJGcFlUVlJTYUUxV1NubFVWbWhUWVVaS2RWRnNhRlZXZWxaVVdWVmFhMVl4WkhOVGJYaFhZa1Z3WVZkV1ZtRmlNa1pZVW1wYVYySlViRmhXYWs1RFZFWlNjbGR0UmxkTlZuQXhWa2Q0YTJGV1RrWlRiRUpZVmpOU2FGcEVRWGhTTWs1SFYyeG9hR1Z0ZUZoWFZtaDNVakZrVjJOR1dsaGlWR3haVldwQ1YwNVdiRlpYYkU1WFRXdGFlVmt3VmpSV2JVWnlZMFpDVm1KWVRURldha1ozVTBkS1IyRkdUazVpVjJkNVZtMHdlRTVHVlhoVFdHeFZWMGQ0VmxsdGN6RmpWbFp6V2taT1YySkhlSHBYYTFKVFZsVXhWMkpFVGxkaVdGRjNWakJrUzFOR1ZuVmlSbVJwVmtWV00xWnNVa0psUm1SSFZtNUthVkpzY0U5WmJYaExaVlprVjFwRVVsVk5WVFZZVlcwMVQyRldTblZSYkdoV1lrWndNMVpHV21GWFIxSklVbTF3VGxadGR6Qldha28wWXpKR1IxTnVVbFpoZW14aFZtdFZNVkpHVm5GU2JVWnFZa2hDUmxaWGVHdFViRnAwWkhwR1YxWkZiekJaYWtwSFVqRk9kVlZ0ZUZOaVdHaFpWMWQ0YjJJeVJrZGlSbHBZWWxWYVZGWnRkSGRsVm10M1drUlNWMDFyY0VkWk1GSlhWMFphYzFkdGFGZFNSWEJJVm1wR1QxZFhSa2RWYld4cFUwVktXbFpzWTNoT1IxRjVVbXRrYWxKV1dsVlpWRTVEWXpGV2RFMVdUazVXYkZZMVdsVmtNR0ZHV25OalJtaGFUVVp3ZWxacVJrdGtSbFpWVVd4YWJHRXhjRkZXYlhCSFlUSlNWMVp1VW10U2F6VlBWVzAxUTFkV1duTlpNMmhQVWpBeE0xUnNhRTlXTWtwSVlVaEdZVll6YUdoV01GcFRWbXhXY2xwR1VsTmlSM2N4VjJ0V1UxVXhXWGxTYWxwVFlrZG9ZVlJWWkZOa2JHUlhWMnQwVjAxV2NIaFdWM2hyWVZaS2RWRnNiRmhoTVZweVZXcEdTMk5yTlZkYVIwWlRUVzVvV2xaWGNFSk5SVEZIVjI1U1RsWkdTbTlVVlZKWFUxWlZlR0ZJVGxkaVIxSkpXVlZhYjFkdFNsbGhSWGhYWVRGd1lWcEVTa2RTYkZKelYyczFWMDB5WnpGV2Frb3dZV3MxVjFwSVRsaGliRXB6VlRCa05GZFdiRlZUYXpWT1ZteHdWbFZ0ZERCaGF6RllWV3BHV21FeGNISldSekZIWTJ4YWNWUnNaR2xYUlVwRVYyeFdZV0V4V1hoVGJsWlVZbFZhVkZsclduZGtNVnBZWTBWa1UySldSalJXTWpWVFlXeEtXVlZzVmxWV2JGb3pWRlZhVm1WSFJrbGFSMmhUWVROQmQxWnNZM2RPVmxwWFYxaHdhRkpYVW1oVmExWmhZMnhhY1ZKc1pHcGlWa3BJVmtkek1WWXdNVlpqUlhCWFlrWktTMVJXV2twbFJuQkdZVVpTYUUxdGFGaFhWekV3VXpGWmVHSkdhR3RTTUZwV1ZXMTRjMDVXY0ZaYVJXUm9UVlZzTTFSc1ZtdFdWVEZYWTBkb1YxSjZSa2hVYlhoaFkxWmtjMXBIYUdoTmFtZ3pWbTB4ZDFJeFduUldiR1JWWW10d1dWbHNhRU5XVmxaelZXeGtXRkp0VWxsYVZWcFBWVEF4VjJORmFGZFdNMmh5VmpCa1MxWnNaSE5XYkZwb1lURndiMVpVU2pSaE1rNXpZMFZzVldKR2NFOVZhMVpoVXpGYVYxcEVRbWxOVjFKSVZqSjBZVlpIU25OalIyaFdZVEZhYUZkV1duZFdNV1J5VDFkd1RsWnVRalpXYTJRMFlURlZlRmRzYkZKaWJIQllXV3RrVW1ReFduRlNhM0JyVFVSV1YxZHJXbXRoVjBWNFkwWldXRll6VW5KV1ZFcFBWakZXYzFwSGFGTldWRlpXVmxjeE5HTXdOVmRWYkdSb1VsUnNXRmxZY0VkWFJtdDNWbTA1VjAxRVJqRlpWV2gzVmpKR2NsSnFVbGRoYTNCUVZURmFhMlJHU25OVWJFNVhZbXRLVGxacVNqUldNV3hZVlZob1ZGZEhhSEZWYkdSVFlqRldjVk5xVWxkU2JFcFpWRlpqTlZadFNrZGpSRUphVFVaYVVGbFZWWGhXTVZweFZXeG9hRTFXY0hsV2JUQjRVekZKZVZSclpHRlNia0pZVld4b1ExWldaRmxqUldSWFRXeEtTVlp0ZEhOWlZrcFZWbXhTV21KWVVreFdNRnBoWkVVeFdXTkZPVmRpVmtwSlZsUkdiMkV5Um5OVGJHaG9VakJhWVZaclZtRlVSbXhXVjJ4d2JGWXhXa2xWYlhoclZHeFplRk5zWkZkV2JWRXdXVlJLUjFOR1NsbGFSbWhYVWxWd1dWZFdaREJUTWtaSFYyNUdWR0Y2YkhKVmJYUjNaVlprY2xkdE9XaFNNVnA2VmpKNFYxZEdXalpTV0dSV1pXdGFWRmw2Um10WFYwWklZVVpTVTAxVmNGWldhMXBoWVRBMVIxcEdaRmhoTWxKdlZXNXdjMkl4YkhKV2JtUllVbTEwTTFZeWRFOVdNREZ5WTBWb1ZrMXVhSFpXYWtwR1pVZE9TRkp0UmxOU1ZuQnZWMVJKZUZVeFNYaFhiazVWWWxkNFZWVnNWbHBsYkZwMFpFZEdWMDFyYkRWVk1XaHZWbXhrU0dGR1ZscGlXRTE0V1RCYVYyTnNaSEprUm5CWFlsaG9WMVpYTURGaE1rWjBVMnRrYVZKRk5WaFVWM0JHWkRGYWNsZHJjR3hTYlZKNVdWVmFhMVJ0U25SYU0zQllWbXhhVjFwVlpFNWxSbEoxVkd4a2FWSXhTbmRXYlhSWFZtMVJlRnBHYkdwU1dGSlhWRlpWTVZOR1duUk9WWFJvVm10c00xWXllRk5XVmxvMlVtNWFWMkpHY0hKV01HUlRVMFpLZEdSSGJGZGhNV3QzVm1wS01GbFdXWGhYYkdoVVlteEtWMWxyV2t0V2JGcDBaVWhrVGsxV2NIaFZiWGhQVmpBeFdGVnFRbUZTVjFKMldWWmFTMVpXV25KalJtaFhZa1p3YjFkV1VrZGhNbEpIVkc1S2FGSXlhRlJaYTFaM1ZqRmFkR1JHWkZwV01WcDZWakkxVDFkSFJYbFZiR3hYWVd0S2FGVXdXbk5XYkdSeVQxZG9WMkV6UVhoV1ZscFRVekZaZDAxV2FGWlhSMUpoVm10V1lWTXhjRlpYYlVaWVZqQmFTRmxWV205Vk1ERjBZVVprVjAxV2NGUlZla0V4VWpGd1JscEhiRlJTVkZaMlZsYzFkMk14WkVkVmJHUm9VbFUxV0ZSV1duTk9WbkJXWVVkMGFGWnJjSGxaTUdoM1Ztc3hkVkZyYUZkaVZFWk1WakZrUjFKdFZrZGpSbVJwVTBWS1RsWXlkR0ZaVmtsNVZGaG9VMkpyTlc5VmJURlRZekZzVlZGdVNtdE5WbXcwVjJ0b2ExVnRTbGRYYTJ4WFVtMW9kbGxYZUV0WFJsWjBZVVphYVZaRldsVlhWRUpoV1ZkTmVGcElWbUZTYlZKd1ZXMDFRMU5XV25GVFdHaE9VbXh3ZVZSV1dtRlVNVnBZWVVab1ZWWXpRbGhXYTFwaFVsWktkRkpzWkZkTlNFSktWa1JHWVZsWFJsZGFSV1JVVjBoQ1dGVnRlSGRoUmxweFVtMTBVMkY2VmxoV01uaFhZVlpKZUZOdVpGZGlXR2gyVlZSR2MxWXhaSFZVYlVaVVVqRktWMVpHV21Ga01sWlhWV3hrV0dKWVVtOVphMVp6VGxac1ZsZHRkRmhpUm13MlZsY3hiMVl3TVVkalNHeGhWbTFTV0ZVeFduZFNNVkp5VGxab1UxWllRa3BXYlhSclRrZEZlVk5ZYkZSaE1taFZXVlJLVTJOV1ZuRlJiVVpZVW0xNGVsbFZZelZXTVVwelZtcFdXbVZyTlhaV2FrRjRWMFpXYzJOR2NGZFdia0l5VjFaYVlWTnRWbGhTYTJSWVlrZG9XRmxyVm5kVVZtUllZMFYwVkdKV1draFdNalZYVm0xS1dXRkdVbGROUm5CTVdWVmFZV1JGTVZWVmJYUk9Za1p3V1ZacVNURlVNVnAwVWxoc1ZtSkhVbFpXYlhoaFRURlNWbGR0UmxoU01WcEpWREZhYTFSc1NrWlhhbEpYVmpOb2RsbFVSbHBsVmtwMVUyeE9hR0pGY0ZsWFZtUXdaREZXUjFadVRsaGhNbEp4VkZaa1UwMUdiSEpYYlhSV1RWWndNRlF3YUhOV01rcFZVbGhrV2xaRlJYaFZha1ozVTFaV2MxcEhhRTVpUlhCWVZqRmplRTFIVVhsVWEyUlhZbXhLVDFadGN6RlhWbFowWlVkR2JHSkdiRFZVYkdRd1ZsZEtWbU5GYkZkV00yZ3pWakp6ZUZJeFpGbGFSbVJYVWxWWk1GWnRNSGhUTVVwWFZtNU9ZVkp0VW5OWmExcDNWR3haZUZkc1pGcFdhelV3Vm0xNGIxVXlSWGxWYkdSYVlUSm9SRmt3V2xkalZrcHlaRVUxYVZKdVFqUldWekI0VWpKR1JrMVdaR2xTUmtwaFZGVmFZV1ZzYkZobFJYUlhWbXh3ZWxsVldsZFdNa3BIWWpOd1YxSjZSVEJaVkVaclUwWldjbUZHVG1sVFJVcFpWMWQ0WVZNeFRuTlhiRlpVWVd4S2NWUldXbmROUmxWNVpFYzVhRkpyY0hwWk1GcHZWMjFLUjFOcmFGZGhNWEJvV1RKNGEyUldjRWRoUms1T1ZtNUNTbFl4VWtOaE1EVkhWMWhvV0dFeGNGbFphMlJUVjBac2NscEdTazVTYlZKWVZqSjRUMkZyTVZaT1dHeFhUVzVvZGxsVlZYZGxSazV6WWtaa2FWWkZTVEJXYkdONFZXMVdSMVp1VGxoaVIyaHdWVEJXUzJWc1duUk5WRUpyVFZkU2VsbHJhRXRYUjBwSVZXMDVWbUZyU2pOVmFrWnlaREZ3U0U5V2FGTmlTRUYzVm14YWIyRXhaRWRYYms1cVVqQmFhRlpzWkZOVlJsWnhVbTVrVTAxcldrbFpWVlV4Vkd4YVdWRlVRbGRpVkVJeldrUktWMUl4V2xsaVJtUnBZWHBXYjFaVVFsZGtNa1pIVmxoa1YxWkZXbkJVVmxwM1RVWndWbUZGT1ZWTlZuQXdXbFZhYTFZd01YRldia3BYWVd0R05Ga3lNVTlTTVdSelYyeGthVll5WjNsV2FrWmhXVlpOZUZOdVRtRlRSWEJ6VlcwMVExUXhiSFJqZWtKT1VteHdNRlJXVWxOaE1ERldUbFZzVjFJelVuSldiR1JMVTBaV2RWRnNXazVTYkhCTlZtMHhORmxYVWtaTlZteGhVbXR3VDFsVVJscE5WbHBWVW0wNWFVMVhVa2xWYkdoelZtMUtTRlZ0UmxwV1JYQlVXa2Q0Y21WR1pIVmFSbWhUVFZWd1NsWlhNVFJoTVZWNVUydGFhbEp0ZUZoWlYzUnlaVVphUlZKc1NteFNiVkl4Vm0xNFMyRldTWGhUYkhCWFlXdEtkbFZVUm10U01rcEhWMnhvYUUweFNuaFdSbVF3WkRGS2MxZHJhR3hUUjFKV1dXdFdkMDFXVmxoalJYUlhUV3R3VmxWdGNHRlpWbHBZVld4U1YwMUdjRXhaTWpGTFVqRldkR0pHVGs1V1dFSlNWbTE0YW1Rd01WZFNXR3hUWVRKU2FGVXdWVEZoUmxaeVYydDBXRkpzU2xsWmVrNXZWREZhYzFkcVFtRlNWMDB4Vm0xemVHTnRUa1phUmxacFVtNUNWVlp0Y0VKbFJrbDRXa2hLYkZKdFVrOVpiVEZ2WVVaa2MxWnRkRk5OVlRWWVdUQldhMVp0UmpaV2JHaFhUVVphU0ZSVVJtRmtSVEZKV2tVMVYySkZXVEZXVnpBeFZERmFTRk5yYUdoU2VteFhXVzAxUTJWc1duRlNiazVxVFd0YVIxUnNaRFJWTWtwWldUTnNWMVo2UVhoV1JFcEhZMnN4V1ZOc2FHaE5ibWhYVmtaYVlXUXlVbk5pUm1SWVlUTlNjbFZxUmtwTmJGWllaVWQwYUZJd1ZqVmFSRTUzVmpGSmVtRklTbFppVkVaVFdrUkJlRll4Y0VkaFIyeFhUVEpvVmxac1pEUlZNVmw0VjFob1dHSnNTazlXYTFwTFkyeFNXR042Um14aVJtdzFWR3hXYTFZeFNYZFdhbHBYVmpOb1dGWnRNVWRqYkU1MFlVWmFUbUp0YUc5V1ZFSnJWakZPUjFOdVVtaFNiVkp3Vm0xMGQxTldXbkpYYlVaV1RWWldORll4YUhOVk1rcHlZMFpXV21KSFVuWldNRnBoWTJ4YWRGSnRjR2xTYkZsNlZtcEtOR0V5Um5SVGJGcFlZVEpvV0ZWdWNFZGxiRmwzVjJ0d2JGWXdXa2haTUZwclZHeFplRkpxVGxkTlZuQnlWbFJLVTFJeFduTmlSMmhUVFVad1ZWZFhkR0ZrTVZwSFdrWm9iRkp0VW1GV2JYaDNaV3hhV0dWSGRGaFNNSEI1Vkd4Vk5WWldXbk5qUlhoWFRVWndlbFp0ZUdGalZrWnpZVVpPYUUxdVpEWldNVkpEVlRGRmVHSkdaRmhpUjFKeFZUQmFkMWRHYkhKWGJtUmFWbTVDV1ZwVlZtdGhiVXBXVjJ0c1ZtSllhRkJXUjNONFpFZEdTRTlXWkU1aWJXaHZWMVpTUjFVeVVrZFhibFpXWWtVMWIxUlhlRXRpTVZwWVpVWk9WMDFyYkRSWk1GcHZZa1pKZDFkc1ZsVldiSEI2Vkd0YVdtVlhWa2hrUm1ocFVtMTNNRlpYTVhkV01WcHlUVmhXVm1Kc2NGaFdhMVpoWTJ4VmQxcEZaRlJXYTNCNlZqSnpNVlV3TVZaV2FrNVhZbGhDU0ZkV1pFNWxSbVJ6V2taU2FXSkZjRlZYVjNodlVUSk9SMVp1VW14VFJYQnpWbTE0ZDFkV1VsZFZhMDVvVFVSR2VWa3dWbTlXYXpGeFZteENWMDFIVWtoWk1uaHJZekZ3UjFac1pHeGlSbkJSVm10YVlWbFdiRmhVYkdSVFlrZDRiMVZxVGxOWFJsSldWMjVrVkZadFVsbGFSV1JIWVVVeFYxWnFWbFpOYm1oeVZsUkdhMU5HVm5OaFJtUnBZbXRLUlZaSGRHRlpWMDVYVTI1S2FsSXphRlJaYlhSTFV6RmFkRTFVVWxwV01GcEpWbTAxVDFkSFNrbFJiR2hYWVdzMVJGVXdXbGRPYkVwMFVteGtUbFl4U2pWV01uUmhZakpHVjFwRlpGUmlSVnBZVm01d1EwNUdXbFZTYlhSVFRWZFNNVlpYY3pWV01WcElaVWhhVjFaNlJYZFpla0V4WXpGa2MyRkhlRk5OUm5CWlZtMHhOR1F5Vm5OaE0yUldZWHBzV0ZSVlVrZFhSbXQzV2tjNVYwMUVSa2xXVjNodlZtc3hTRlZzVWxaaGExb3pWVzF6TVZZeFVuTlViR1JwWVRCd1RsWnRNSGRsUlRWSVVtNUtUbFp0VW5CVmJURlRWMVpaZDFwRVVsZFdiWGhXVlRKNFQyRnNXbk5XYWs1YVZsWmFVRmxWV2t0ak1XUjFZMFpvYUUxWVFsRldiWEJIVXpKTmVGZHVSbFppUjFKUFdWZDRZV1ZXV25OVmEwcHNVbTFTU0ZadE5WZGhiRXAwVld4U1lWWXpVbWhVYlhoaFpFZFNTRkpzVWs1V2JrSTJWakowWVdNeVJuTlRibEpXWW10S1dGUlZXbmRVUm14eFVteHdiRkp0VWpCVmJURjNWR3hhZEdSNlFsZGlWRVV3V1hwS1IxWXhUblZUYXpsWFpXMTRWMVp0Y0U5aU1WSkhWMjVTYkZJelVsbFZiRkpIVjJ4cmQxWlVSbGROYTNCWVZUSjRjMWRHV1hwVmJXaGFZV3R3UjFwVldrOWpNa3BIVjIxc1UwMXRhRzlXTVZwVFV6RldjazFWWkdwU2JWSlpXV3RvUTJNeFduTlZhMlJYVFZkU2VWWXlNVEJoUmxweVkwWndWbFp0YUhKV01HUkxVakZrZEdGR2NHeGhNWEEyVm0xd1IyRXlUWGhqUldSb1VtMW9WRlJXVm5kaU1WcDBUVmhrVlUxV1JqTlViRlpyVjBaa1NGVnNiRnBoTWxKVVdUSjRZV05XUm5SU2JGSlRZa2QzTVZkc1ZtdE5SMFpYVTFoa1YyRnNTbUZVVlZwaFRURmFjVk5yZEZoV01GcElWbGQ0WVdGSFJYaGpTR3hZWVRGYWFGZFdaRTVsVmtweVdrWldhVll5YUZCWFZ6QjRZakF3ZUZkdVRscE5NbEp6VlcxNFYwNVdXa2hrUjNSWVVtMVNTVlpYZUhOWGJGcEdUbFpTV2sxR2NGUldha1pyWkZaU2NrOVdUbWxTTTJONFZtdGFZVlV4UlhoWFdHaFlWMGRTY1ZWdE1XOVhSbEpZVGxjNWEySkdjSGhWYlRGSFZESktSMk5JYkdGV1ZuQnlXVlZrUm1Wc1JuSk5WbVJYWld0Sk1GWnJVa2RVTVZsNFUyNVdWV0pWV2xSVVZ6VnZWbFprV0UxVVFsTk5SRlo2VmpJMVUxUnNXa2RUYlVaWFlsUkZNRll4V21GWFIxSklUMVprVjAxR1dUQlhWRUpyWWpGYWRGTnNiR2hTV0doWVZXdFdZV0ZHYkRaU2JHUnFUVmhDU0ZsVldtdGhWa2w2V1ROb1YwMXVVbGhaVkVaS1pWWktjbGRyTlZkaVZrcDRWbGQwVjFNeFdYaGlTRXBoVW5wc2NWbHJaRFJYVm5CV1ZsUldWazFyV1RKV2JYaHZWMGRGZUdORVRscFdiSEJNV1RJeFQxSnRTa2RhUjJ4WVVtdHdkbFp0TUhkbFJsWjBWbXRrYWxKWGVGZFphMVV4WTBaWmQxZHJkRmRXYkhBd1drVmtSMWRzV25SVmEyaFlZVEpvVEZacVNrdFhWbFoxVVd4V1YySklRalpXUjNoaFZqSk5lVkpyYkdGU2JIQndWV3BHUzFOc1duTmFSRkpwVFZkU01GVnNhSE5XYlVZMllrZG9WMkpHY0ROV01GcGhZekZrY21SSGNFNWhlbFpLVjJ0V1ZrMVdWWGhUYkdScVVtMTRXRmxYZEhaa01XeFZVMnhLYkZKc2NGcFpWV1JIVlRGWmVXRklXbGRXZWtJMFZsUkdhMVl4WkhWU2JGWnBWa2Q0ZVZkWGRHdE9SMVpIVmxoc2ExSXpVbGRVVlZKSFpWWlNjMVp0ZEZkTlJFWjRWVzEwYjFZeFdrWmpSWGhYWVd0YVVGbDZSbXRqTVhCSFdrVTFUbEpZUWt0V2JYaHZaREZKZUZWWWFGUlhSMmhvVlRCVk1XSXhWbkZVYTA1cVRWZDRWbFZ0Tld0WFJscHpZMFZvVjAxcVJraFpWRUY0Vm1zMVZtRkdaRTVXTW1nMlYxWlNSMVF4VGtkV2JrNW9VbXhhV0ZSVVJrcGxiRnAwVFZSU1YwMVhVa2xXUjNSaFZVWmFkRlZzYUZwaE1taEVWRzE0YTFaV1JuUmtSazVPVmpOb1dWWnFTalJoTWtaelUxaHNhRkl5YUZkWmJHaHZUVEZaZDFkdVRrOWlSWEI2VjJ0a01GVXdNVWRqUldoWFVqTm9jbGw2UmxabFJuQkdWMnhPV0ZJeFNsbFhWM2hUVW1zeFIySkdhR3BOTW1oWlZXMTRZVmRzYkhKWGJHUllVbXRzTlZsVmFHdFdNVm8yVVdwU1YxWkZXbkpXYWtwTFUxWldkR1JHVWxOTlZYQmhWbXhqZDJWRk5VaFdiazVZWW14S1QxWnNaRk5YUmxwelZXdGtXRkpzVmpWYVZXTTFWakF4UlZKdWFGZGlWRlpNVm1wS1JtVkhUa1psUm5Cc1lUTkNUVlpYZUdGWlYwMTRWMjVPWVZJeWVGUlpiWFJLVFZaYWRFMUlhR3ROVld3MFZrWm9jMVpYU25OVGJGcGFWa1Z3VkZZeFduTmpiR1IxV2tkd1UySkhkM3BXTW5ScVRsZEdWazFXWkdwU1JVcGhWRlZhWVdOc1dYZGFSWFJYVFZkU2VGVlhlR0ZoVm1SSFUyeHNWMkpZYUhKVmVrWlBVakZhZFZWc1FsZGlhMHBaVmxkNFYyUXlSa2RYYTJSWFlsVmFZVlp0TVZOVFZscDBaRWM1VmsxcmNFcFZWM2h2VmxaYVYxTnNhRmROVm5CaFdsWmtVMU5GT1ZkV2F6Vm9UVmhDU2xac1VrcE5WbFY0VjI1U1ZHSnJjRlZaYTJSVFdWWnNWVk5zVG10aVJscDVWakl4UjFkR1NYaFhhMmhhVFVkUk1GWnFRWGhXYlU1R1lrWmthRTFzUlhkV2JGSkhWVEpOZUZwSVRtaFNNMUp6V1ZSQ2QxZFdXblJrUm1SYVZqRktlbGxyYUVkVk1rcFdWMnhzVm1KWVRYaGFWbHB6Vm14d1JWVnNaRk5oTTBKWVYxUkNZV0l4WkVkWGJsSldZV3h3VmxadE1WTldSbXcyVW0xMGExWnJOWHBaVldSelZqRmFkVkZxVWxkTlYxRjNXV3BHUm1WR1RuVlViR2hwVWpKb2VsWlhOWGRqTVdSSFZXeG9hMU5IVWxsVmJYaFhUbFp3Vm1GSGRGaFNhMnd6V1RCV2IxWXdNWEZXYTJoWFlrZFNURlV3V2xkamJVWkhXa2RzV0ZKVVVYZFdiVEYzVXpGSmVGUnJhRmRoTWxKV1dXeGtORmRHVWxoTlZ6bGFWbXh3TUZSVmFHOWhNREZYVW1wV1ZrMVhhSHBXVkVwR1pWWldjMkpHWkU1U01VcFZWMVpXWVZZeVRYbFNhMlJWWWtkb1ZGbHNhRzlPVmxsNVpFZEdWVTFXU25wV01qVlBWMGRHY2xOdGFGZGlSMUpUV2tSR2MxWnNaSFJTYlhSVFlrWndOVll5ZEdGV01WbDVVMnRhYWxKc1dsaFpWM1JMWTJ4V05sSnJjR3hTYmtKS1ZsY3hiMVV5U2xkVGJscFlWbXhLU0ZwRVNsZFdNV1J6Vm14S2FWWldjR2hXYlhCQ1RWVXhSMVpZYkd0U2VteFhWRmQwZDFJeFVuTmhSVTVYVFd0d1dsWlhjRTlXTVZwelkwZEdZVlpXY0hKWmVrWlRZekZhY2s1V1pGZGlSM1F6Vm0xd1MwMUdiRmhTV0doaFVsZG9WVmxVU2xOWFZteHlWMjFHV2xac2NIaFdSM2hQVmxaS2RHUkVWbUZXVm5CUVZtcEJlRmRHVm5GU2JHUlRUVEF3ZUZac1VrdFRNVTVJVldwYVUySkhhRmhWYkZaM1pWWmFXR05GWkZwV01VcElWa2MxUzJGR1NuTmpSemxWVm5wV2RsbFZXbUZrUjFaSVVtMTBUbUpGY0RaV2Fra3hWVEZTYzFkc1pHcFRSVFZYV1d4U1IxWkdjRlpYYlVaVVVqRmFTVlZ0ZUZkaFZrcFpVVmhvVjFadFVqTlhWbHBhWlVaT2NWZHNUbGRTVlhCWVYyeGtNR1F4VmtkaE0yeHFaV3hhV0ZSWGRHRlRWbkJHVjJzNWFGWnNjSGxaTUZKUFZqSktTRlJxVG1GU1JVVjRWbTF6ZUZOWFJrZGhSbWhUVFcxb1lWWXhaREJoTVZWNFlrWmtXR0pzU25OVmJHUlRWVVphZEdWSFJrNVNia0pYVjJ0U1ExZEdTbkpqUkVKWFZqTlNlbGRXV21GWFJsSlZVbXhrYVZaRldrMVhhMXBoVWpKU1dGUnJaR0ZTVkZaVVdXMTBTazFzV1hoaFNHUlRUVlpzTlZaSE5VOVpWazVIVTI1S1ZtSkdTbGhXTUZwelpFZFNSbU5GTlZOaVNFSTJWakZTVDJFeFVuTlhiazVUWVd4S1dWbFVSbUZqYkZweVdrVjBhbUpWTlVwVmJYaGhWR3hKZUZKWVpGZGhhMXBvV1hwR1lWWXhVblZVYkZab1pXeGFVRlp0TURGUk1WbDRWMnhXVkdGclNrOVZiWGh6VFRGU1YxZHRSbFZOVjFKS1ZWY3hSMVpXV2xkalJFNWhVak5vYUZreFdrOWpNWEJJWTBkc1UxWkdXbGhXYkZwclRrZEZlVkpzWkZSaWEzQnhWV3hrTkZkV1duUmxSWFJVVW14V05WUldXbXRXTURGWFUycEdWazFxUm5wV1ZFcExVbTFPU1ZwR1pHbFhSMmh2VjJ0U1IxbFdXWGhqUldSaFVqSm9WVlZxUmt0WFZscEhWMjFHV2xack5VaFdNV2h6VkRGYWNrNVdXbHBoTVhBelZUQmFWbVZWTlZaa1JtUlhZa2hDTmxadGVHOWlNVmwzVFZWa2FsSXlhRmhVVldSVFYwWlZkMXBHVGxSU01GcElWa2N4YjFSdFNuUlVhbFpYWWxSRk1GbFVRVEZUUms1WllVWm9hVkl4U2xwWFYzUnJWVEZhVjJKR1ZsUmlWR3h2VlcxNGQwMUdjRlpoUjNSb1VtdHdNVlZYZEd0WFIwVjRWbFJHVjJFeGNFeFpNakZQVTFkT1IyRkhhRTVpUlc4eVZtMTRVMU14VFhoYVJtUm9UVE5DY0ZWdE1WTmpSbFowVGxWT2JGSnRVbnBXYlRFd1ZrZEtWMWRyYUZoaE1YQjZWMVphUzFaV1duTmhSbVJvWVRGd1RWZHNWbUZaVm1SSVZHdGFhMUl5ZUU5V2JURXpUVVprV0dSSE9WVk5hMXBJVlRKd1lXRldTblJWYkdSYVlrWktXRlZyV2xaa01XUnpZMGQ0VjAxRVVYbFdiVEI0WWpKR1NGWnVTbGhpUjNoWlZtdFdTMVpHVmxWU2JYUnFUVmRTZWxkcldtdFhSa2w1WVVac1YxSnNXbWhhUkVaVFVqRmtkVlZyTlZkV1IzaFZWa1prZWsxV1RrZGFTRXBoVW5wc2IxVnNVa2RsUm14V1ZXczVWMDFyV25sV01qRnZWMFphZEZWck9XRldWbkJ5VmpGa1IxSXhjRWhpUms1T1RXMW5lbFp0ZUdwbFJUVkhZa1prWVZKdFVsaFpiWFJoVmxac2MxVnVUbXBOVmxvd1dsVm9hMWRHV25WUmJHUllZVEZLUkZacVNrZE9iRXB6WVVad2FFMVZjRlZXYWtsNFVtMVdXRkpyWkZKaVIyaFlXV3RvUTFSV1draE5TR2hVVFZVMVdGVXlOVTlYUjBwWVpVWnNWbUZyY0haYVIzaGFaVmRXU0dSRk9WTk5SRVV3Vm1wSk1WUXhaRWhUYmtwcVVtdGFXRmxzVWtka2JGcHlWMnhPVjJKVldrZFdSM2hUVmpKS1YxTnNjRmhoTVZwb1ZrUkdZV05yTVZkYVIyeFRVbFJXVjFadE1IaGlNVTVIVjJ4V1UySllVbFZWYlhoaFpXeHNWbGR0Um1oU01Ga3lWbTF3UzFZeFpFbFJhMmhoVWtWYWFGbDZSbmRUVms1elVXeGtUazFWY0ZwV2ExcFhZakZGZUZSc1pGaGliRXBQVm10YVMySXhVbGhrUjBaWVVteFdOVlJzV210V2JVcFdWMjV3VjAxdWFIWldNakZMVWpGT2NtRkdWbGRTVm5CWlZrY3hORk15VG5SVWEyaHNVbTFTY0ZWc2FFTmhSbGw0V2tSQ1dsWnNiRFZWYlhSaFZHeGtSazVXVmxwaE1sRXdWakZhWVdOV1VuTlViWFJwVW14d1YxWlhNSGhOUmxWM1RWWmthbEpGV2xoVmJuQkhaR3hhVlZKdFJsZFdiSEI2V1d0YWEyRldXa1pXV0dSWVlURktRMXBWV2twbFZsSnlXa1pvYVZaV2NGVldiWEJIVXpGa1YxZHJaRmRpUlRWVVZGZDRZV1ZzV25OaFNFNW9UVlUxUjFSc1dtOVdWbHB6VjI1d1ZXSllhRmhXTUZWNFYwVTVWMXBGTlZkaWEwcEpWakZTUTFZd05VZFhXR1JPVm0xb1YxbFVTbTlXTVd4WVpFaGtWRkpzV25oVk1uTTFWa1pKZDFkclpGVmlSMUo2VmxSR1lXUkhVa1ZXYkdScFZrVldNMVl4V21Gak1WbDVVMnRrWVZJeWVGUlpiRnBMVm14YWNWRnRkR2xOYTFwSVZteG9hMWRIUlhwVmJHUlhZbGhvTTFwVldsWmxWVEZGVm14a1YxWkZXbGxYVkVKVFVURmFXRk5yWkZoaVJVcFlWV3RXWVdGR2JEWlRhemxUWWxWYVNGZHJWVEZoUjBWM1ZtcFNWMkpVUlhkV2JURlhVMFpTZFZSdFJsUlNiSEI0VmxjeE5HUXhVWGhpUm1oc1VqQmFXVlp0ZUhkbGJHUlZWRzA1VjFKVVJsaFpNR2gzVjBkRmVXRkdRbHBXVm5CTVdrWmFSMlJGT1ZkV2JHUnBWakpvUlZZeWVHdE9SbXhYVTFob1YySnJjR2hWYWs1VFZERmFjVkpyZEZSaVJuQXdWRlpTUTJGRk1YSlhibkJXVFZkb00xWnRNVWRPYlVwSFlVWndWMDB4U205V2ExWmhWVEpTU0ZacmFHdFNiVkpZV1ZSR2RtUXhaSEpXYkZwUFZteFdNMVJXVm10aGJFcDBaVVpvV2xZelVqSlVWVnB6VmxaT2NscEhjRTVXVkZZMlYxZDBZVmxYUmxkVFdHeG9VakpvV0Zsc2FFTlZSbHBWVVZob2FrMVdXbnBXTW5odllWZEdObFpzYkZkaVZFVjNXa1JLVjJNeVJYcGFSMFpUVW10d1dGWkdaREJYYXpGelYyNVNhbEl3V2xoVVZWSkhUVlphV0U1VmRGcFdhM0JIVmpJeGIxWnRSbkpYYkVKWFRWZFNVRlV3WkVkU01WSjBZa1pvVTAxdGFHaFdiWEJIWVRBMVNGTllhRk5YUjJoWVdWUktVMWRHYkhKWGJVWlhVbTE0V2xrd2FFOVdNVXB6VTJ4c1drMHpRa2hXVkVGNFZqSk9SVkZ0UmxkV2JGVjRWMVpXWVZNeFdsZFNia1pWWWtad1QxbFhlRnBsYkZwMFkwVmtXR0pXV25wVmJUVkxWbGRLUjFkc2FGcGhNbWhFVmtWYWEyTXhXblJrUmxKT1ZsZDNNRll5ZEc5VU1rWkhVMWhzYUZORk5XRlphMlJ2Wkd4U1dHVkhSbXRTVkVaS1dWVlZNVlV3TVZaWFZFSlhZV3RyZUZaRVJtdFRSazUxVkd4U2FWSlZjRmxYVm1SNlRWWmFSMWRZWkZoaVJUVlpWV3BHUzFOc1pISlhiWFJvVm10d2Vsa3dVbUZYUmxwelYyNUtWVlpXY0hKWmVrWnJaRlpPZEdOR1RsZE5WWEJaVmpGa01HRXlTWGxWYms1WVlteEtUMVpzWkZOalZteHlXa1pPVGxac1ZqVlVWbFpyVm1zeGNtTkZjRlpXTTJoSVZqQmFhMU5XUm5KbFJscG9ZVEZ3VVZaVVFtRlVNazV6WTBWb1UySkZOWEJXYlhSM1RURlplRmRzVGxKTmF6RXpWR3hhYTFkSFNuTlRhemxYWVRGYVRGZFdXbUZrUlRGVlZXeG9VMkpZYURWV2FrbDRUVVprUjFOdVVsWmhNbmhZVm1wT1RrMVdXblJqTTJoVVVteGFNVll5ZUd0aFIwVjRZMFJhV0ZaRmJ6QmFSRVpLWlVaV2RWUnRhRk5pVmtwM1ZtcENhMkpyTVhOWFdHaFlZa2RTWVZadGVFZE9SbVJ5Vm0xMFYxSXdjSGxVYkZwWFYyMUZlVlZVUWxwV1ZuQllXWHBHZDFORk9WaGpSMnhUVFRKbk1WWnFTakJXTURGSFZsaGtUbFp0VW5GVk1HUnZWMFpzYzJGSE9WaFNiWGhZVmpKME1HRnJNVmRqUm5CYVZsWndjbGxXV210U2JFNXlUVlprV0ZORlNrbFdNVnByVlRGSmVGWnVWbFJpUjJod1ZtcEtiMVpXWkZoa1J6bFNUVlphU0ZkcldtdFpWa3BIVTJ4c1dtSkdjR2hhVjNoYVpWVTFWbHBHWkZOaVZrcEtWMVpXWVZVeFdsZFhXSEJWVjBkb2FGWnFUbTlqYkd0NVRWVmtVMDFXU2pCWlZWcFBZVVV4ZFZwRVdsZGlXRUpNVkd0YVZtVkdaRmxpUms1cFlUTkNXbGRXVWs5aU1XUkhZa2hLV0dKdFVtOVZiWGgzWld4WmVXUkVRbWhOVlhCNVdUQm9kMVl3TVhWVVdHaGFWbGRTV0ZsNlJtdFdWa3B6V2tkb1RsWllRa3BXYWtaaFlURktkRlpyWkdGVFJUVnZWVzE0UzJOR1ZuRlRiVGxzWWtad1dWUldVbE5XUlRGWVpVWm9XbUV4Y0ZoV2EyUkxVbTFPU1ZOc1ZsZGlTRUpOVjJ4YVlWZHRWbFpOVmxwaFVqSm9UMVpzWkROTlJscFZVMnBDYWsxWGVGaFZNbmhyVmpGYVJsZHNhRmRoTVZwSVZHdGFWMk5XVG5KUFZrNVhZa2hDTmxZeWRHRlVNVkp5VFZoU2FGTkdjRmhVVmxwM1ZrWldjVk5yV214U2F6VmFXVlZrZDFVeFduVlJibHBYVm5wRk1GcEVTa3BsUjA1SFlVVTFWMUpyY0ZwV2JUQjRWVEZrVjJOR1dscGxiRnB2Vm14U1IxSnNWbGhqUms1WVlrWndSMVJzYUdGV01ERklWV3Q0Vm1GcmNGQlZNVnBQWXpGYWMxcEZOVTVXV0VJeVZtMTRhMlF4U1hoaVJtUlZZVEpvV0ZsVVNqUmhSbFowVFZaT1ZVMVhlRlpXUjNSUFZrWktkRlZzV2xaV2VrWklXVlpWZUZZeVNrVlViRlpYWWxkb1dWWnRNSGhUTWs1eldraE9XR0pJUW05VVZtaENaV3hrVjFadFJscFdNRFZZVlRJMVMxVkdXWHBWYkdoYVlURmFNbHBFUm10V1ZrWjBVbXhhVGxac1dYcFdSbHB2VlRKR1IxTnVVbXhTYldoV1ZtMHhVMVV4VWxaWGJVWlhWbXR3ZVZrd1pEUlZNa3BHWTBSV1YwMXVVbWhaYWtwSFZqRk9kVlJ0Y0ZOaVNFSmFWbTB4TkZNeFZrZFhiRlpUWWxoU1ZGUlhkSGRUUm14eVdraGtWazFyY0ZoVk1uaHpWakZLYzJOSVNsVmhNWEJoV2xWYWExZFhTa1pQVm1ST1RWVndXbFpyV2xkVk1VbDRXa1ZrYUUweVVsZFpWRXBUVjBac2NsZHVaRTVTYlhoWFZsZHpOVll3TVVWU2EyaGFUVWRTU0ZkV1dscGxiVVpIWVVkR1UySklRbEZYV0hCSFlUSlNTRk5yWkdGU2F6VllXVzEwUzJGR1duUmpSV1JwVFd4R05GVXhhRzlXVm1SSVpVWmtXbUV5VWxSV2JYaHpaRWRTU1ZwR1dsTmlTRUYzVmtaYVlWUXlSbk5UYms1cVVrVkthRlZzWkc5amJGbDNXa1YwVTAxck5VcFphMXByVkcxS2RHRkdSbGRpUjFJMldsVmFZV05yTVZkV2JGcHBVakZLVlZaR1VrdGlNbFpYVjFob1dHSlZXbFZVVjNoTFUwWmFkRTVWT1ZwV2EzQXhWVmQ0YjFadFNrZFRiR2hYWWtad2FGcEZaRTlTYkhCSFYyczFWMkpZWTNkV2JYQktUVlpaZUZkc2FGTmhiSEJ3VlcxNFMxbFdiRlZUYlRsVFVteFdOVnBWWkVkV1JrbDRWMnRzVm1KVVJuWldSM2hoWkVkU05sRnNaR2hoTVhBeVYxWlNTMUl5VFhoVWJrNW9VakpvVkZSVlduZFdNVnAwWlVkMFZrMXNTbnBXYlRWTFYwZEtWbGR1U2xaaVJrcElWbXBHZDFKc1pISlBWbFpwVW01Q1YxWnRNWGRaVm1SSFYyNU9XR0pYYUdGV2ExWmhWa1pzTmxKdGRHdFdiSEI2VlRJeGMxWXhTWHBoUm5CWFRWWndjbFJWV2s1bFJtUlpZVWR3VTJKSVFscFhWM2hYV1Zaa1IxVnNaRmhpYlZKUFZtMTRkMWRXVWxkVmEwNVhZWHBHUmxWdGNFZFhiRnBYWTBod1YwMUdjR0ZhVjNoWFpGWmtjMWRzWkZOV2JrSTFWakZvZDFJeVJYbFZiR1JYWW14S2NWVnRjekZYVmxaelZtNWtWbFpzY0RCVVZXaHZWREZLYzJKRVRsVmlSbHB5VmpCa1MxTkhSa2RSYkdScFVtdHdObFpxUW1GWlYwNVhVbTVPWVZKVWJGaFpiR2h2VjBaYWNWTllhRTVTYlZKSlZUSjRZV0ZzU25WUmJHaFdZbFJHZGxwSGVHRmpWazV5V2tkd2FWSXhTWGhYVkVKaFpERlNkRk51VW1oVFIzaFpWbXRXYzA1R1dsVlNhM0JzVm10d2VWZHJXbGRoVmxsNllVWldXRll6VW5KVVZWVjNaVVprZFZWck5WaFNNVXBXVjFkNFlWbFdUa2RXV0dob1VucHNXVlZ0TVZOVFZscFlZM3BXVjAxRVJraFdNbkJQVmpBeFYyTkljRmRpUm5CVVdUSjRVMk15UmtkVWJXeFRZbXRGZDFadE1UQmhiVkYzVGxab1UySnNTbFZaVkVwVFkxWldjMXBFVWxkaVJuQXdXbFZrUjJGR1NuUmxTR3hZWVRGWmQxWlVTa3RUUmxaeFVteHdhRTFZUVhwV2EyUTBVekpTVjFKdVZtbFNiV2hZV1d0b1EySXhXbFZUV0doV1lsWkdNMVJzV21GaFZrbDZVV3hTV21KR2NFeFdiRnBoVWpGV2NtUkhiRTVoTW5jd1ZtcEdiMkl4WkVoVGJGcFlZa2Q0WVZsclduZGhSbFYzVjI1S2EwMVdjREZXUjNoclZUQXhTVkZyY0ZoV2JGcDJWVlJHV21Rd01WWmFSbWhvVFRKb1dWZFhkR0ZrTWs1elYxaGtZVkpyTlZSVVZtaERVMVp3UmxaVVJsZE5SRVpYV1RCYWQxWXlTbGxSYTNoVlZsZFNSMXBWV25kU2JVWkhWVzFzVTJKclNtRldNV040VFVkUmVGZHVUbGhpYTFwV1dXeFNjMkl4Vm5ST1ZVNVlWbTVDVjFsVlZqQmhSVEZGVW14b1drMUdTa1JXYlRGTFYxZEdTVk5zWkZOTk1taG9WMnhXWVZReVRuUlVhMlJvVW0xU2NGVnROVU5rYkZsNFdraGtVMDFYZUZoV01XaHZXVlpPUjFkc1dscGlSMmhFVm10YVdtUXhjRWhQVjJ4T1ZtNUJkMWRVUWxaT1YwWldUVmhPV0dKdVFsaFVWM0JYVmtac2NsZHJjR3hpUmxveFZXMTRkMWRHVGtaVGFscFhZV3RhYUZsNlJtRmpNWEJKVlcxMFUwMXRhRlZXYlhSWFUyMVdjMWRzVmxSWFIyaHdWRlphYzA1V1ZYbGtSM1JvWWtVMVIxWXlNVzlXTWtwSFkwUk9WbVZyV2pOV2JYaHJaRWRTUjJGR1pHbGhNSEJKVm10a05GbFhTWGhXV0d4VVlUSjRVMWxyWkRSWFJsSlhXa1pLYTAxWGVGWlZNblIzWWtaSmQyTkZhRmhoTWxKNlZsUktTMWRIUmtsaVJtUlhVbFZ3ZVZac1VrZFpWa2w0Vm01T1lWSXlhRlJXYkZKWFYxWmFSMWR0Um1wTlJGWllWbGQ0YTFadFJYZE9WemxXWVd0S00xWnFSbkprTVZwMVdrWmthVkp0ZHpKV2JHTXhXVlpaZDAxWVZtaFNNbWhZVkZWYWQxZEdjRWRhUlRsVFRXczFTRmRyV210VWJGcFpVVzFHVjJGclduWmFSRVpLWlZaS1dXSkdWbWxTTVVwWlYxY3hlazFYUmtkV2JrWlVZV3hLV0ZWdGVFdFhSbHAwWlVkMFZXRjZSbGhaYTFKVFZqQXhkV0ZHUWxkV2VrWklWRzE0UzJNeVJrZFhhelZYVFcxbk1sWnRNVEJoTVVwMFZteGtWMkpzU205VmJYaDNZMFpaZDFwSE5XeGlSMUpXVlZjeFIxWXdNWE5UYTJSVllrWndhRlpzWkV0VFIwWkpVV3hhYUdFeGNFMVdha28wV1ZaSmVGZHVVbEJXTW5oUFZtMDFRMDVXV2tkWGJVWm9UV3RhV0ZVeWRHdFdSMHBJWVVkR1dtRXhjRXhXTUZwaFkyeGtkVlJ0Y0dsU01VbzFWa1JHWVZVeFZYbFRhMlJwVFRKb1dGbFVTbEpOUm1SWFdrVmtWMDFZUWtkWlZXUnZWVEpXZEdWR2JGZFdla1V3VjFaa1IxSXlUa1pXYkU1cFZsWndlVlpYTVRCa01sWlhZa1phWVZKRlNsZFVWVkpIVFVac1ZsZHNaRmROYTNCYVZsZDRiMWRHV25OalJYUmhWbFp3Y2xsNlNrZFNhelZYV2taT2FFMHdTWHBXYlhSaFdWZEZlRlpZYkZkaVIxSlhXV3RrVTFkR2JITlZiazVwVFZaYU1Ga3pjRWRXUmtwMFpFUk9WMDFxUVRGV01HUkxVakpLUlZkc1pGZE5NRXBSVm0xd1IxTXhXWGxVYTJoVFlsVmFXRlp0TlVKbGJGcFlUVlJTYTAxVmJEUldiVFZQV1ZaSmVXRklUbHBoTVhCNVdsWmFZV1JIVGtaa1JUVlRUVVpaTVZaVVJtOWpNVlY1VWxob2FsSlViRmhaYTJSVFZrWnJkMWRzWkdwaVIxSXhWMnRhYjFVeVNrWmpSbkJYVWpOb2FGWkVSbHBsUms1MVZHeG9hVkl6YUZkV2JURTBaREpPYzFkc1ZsSlhSMmhZVkZaVk1VMVdhM2RYYm1SWFRWWndNVlZYZUVkWFJscHpWMnhrWVZaWFVrOWFWVnBUWkZaV2MxRnNaR2xXYTNCYVZtdGFVMU15U1hoWGJHUllZbXhLY1ZWc1pGTmlNVkpYVm01T1QxWnNWalZhUldoUFZqSktWbU5HY0ZkV00yaFVWbXBCZUZJeVRrWmxSMFpYWWtoQ2VWWnFRbXRWTVU1SFUyNVNhMUpVVm5CVmJUVkNUV3haZUZwRVFscFdiWGhaVlcxMGExWkdaRWxSYkdSYVlUSlNWRlp0ZUdGak1XUnlaRVpTVTJKSVFqUldWekUwVkRGWmQwMVdaRmhpYmtKWldWUkdkMk5zV2tobFIwWllWbXRhV2xkcldtOVdNa3BIWTBSS1YwMVdjR2hXTWpGWFZqRlNkVk50YUZOaVNFSjJWa1pTUzJJeVJrZGFTRTVoVWtWS1lWWnFRVEZsYkd4eVZXMUdWazFyY0VsV1Z6VkhWbFpaZWxSWWFGWk5WbkI2Vm0xNFlWWldTbk5oUms1b1RUQktXVlp0Y0VkVk1VMTRWMWhzVTJKcmNGbFphMXBMVmpGYWNsWnRSbXhpUm5CNFZXMHhNRmRHV1hkalJXaFhUV3BHZGxaSGVHdFNiRTV6VTJ4a2FWWkZTVEJXUjNSclZXMVdSMXBJVmxWaVYzaFZWV3hvUTFkc1pGaE5TR2hXVFZkU1NGWnROVk5VYkZwSFUyNU9WMkpVUlRCV2FrWmhaRWRTUlZGdGFGTldSVnBIVmxjeE5HTXhXWGhYV0hCb1VqSm9XRmxzYUc5WlZuQllUVlZrVkZack5YcFpNRnByVmpKS1IyRXpaRmRpVkVZelZYcEdVbVZHVG5WVWJYQlRWakZLV1ZkWGRHdFZNazVIVmxoa1YyRXpVbkpaYTFwM1RVWndSbGRyT1ZaTlJFWlpXbFZhYzFZeFdYcFZibHBYVmtWd1IxcFdXbGRrUlRsWFYyMXNXRkl5YUhaV2JYQkRXVmRSZUZwRmFGZGhNbWhVV1Zod1YyTkdWbkZTYTNSUFZteHNOVnBGV2s5V2F6RnlWMjVzVlZac2NIWldiVEZHWlZkV1IyRkdjR2xTTW1oVlYxWldZV014V2xkVGJrcHJVak5TVkZSVlduZFRWbVJYVm0xR2EwMXJXa2RVVmxwelZXeGtTVkZzYUZaaWJrSkhWRlZhYTFZeGNFWk9WM2hUVFVSV1NGWnRNVFJaVjBaWFUxaG9WR0pGU2xoWmJGSkRUa1pTVlZGWWFGZE5WMUo2Vm0xNFUyRkhSWGRqU0ZwWFVtMVJkMWRXWkZkak1WcFpZa2QwVTAweFNuWlhWM1JYWkRBeFIySkdXbGhpV0ZKWldXdGFjMDVzV2tkaFJ6bGFWbXRzTmxsVmFIZFdNa3BaWVVoS1lWSldjRXhhUldSUFVqRndTR0ZIZUdsU2JYUTFWbTB3ZUUxSFJYZE9WV1JYVjBkb1dGWXdaRFJXVm14VlUyeE9hbFpzV25sV01qRkhWMFphYzJORVFtRldWMUpJV1ZjeFMxSXhUbk5hUm1ST1ltMW9iMWRYZEdGWlYwNXlUbFpzYWxKdGFHOVVWbWhEVmxaa1YxZHRSbFJpVmxvd1ZXMTBhMkZXU25SVmJHaGhWak5TVjFwRVJscGxSbVIwWkVaT1RsWlhkekZXVjNodlpESkdWMU5zVmxkaVIyaGhXV3RhZDFSR1dYaFhiVVpUVFZkU01GcEZXbUZVYkVwR1YyeHNWMkZyYnpCWmFrcEhaRVphZFZOc2FHbFNNMmhZVjFkNGIxUnRWa2RXYmtaVFlrWndjMVpxUm1GU01XUnlWMjEwVldKVlZqWlZWM2hyVmpGYWRGVnFUbGRXUlZwaFdsVmFhMk5zWkhOVWJXaHBVbGhDV1ZZeFdtdE5SbXhZVW10a1dGZEhhR2hWYkdoVFZsWldjVkpyZEZSU2JIQkpWRlpTVTJGR1duUlZhMnhhVmxkU1NGWnFTa2RqYkdSMVUyeFdhRTFZUW1oWGJGcGhWakZrV0ZOclpHRlNNbmh2V2xkNFlVMXNXbkpYYkU1VVRWWldORmRyV210aFZrNUdUbFprV21KWVRYaFdNVnBYWkVkV1JtUkdhRmRpYTBwSVZtcEplRTFHV2xaTlZscHFVMGhDWVZsVVJrdFhSbHB6VjIxR2ExSnNTbFpWYlhoclZHeEplRk5yTVZkV00wSk1Wa1JHU21WV1NuSmFSM0JUVmtaYVZWZFdVazlSTVZaelYyNVNUbE5IVW5OVmJYTjRUa1prY2xkdE9WWk5hMVkxV1ZWak5WWnRTbFZTYkZKWFVrVmFhRmt4V2t0amJWSkhWV3hrYVZORlNtRldNVkpEVmpKRmVGZFlaRTVYUlhCUFZtdGFTMWxXVWxaWGJVWnJZa2Q0V0ZZeWRIZGlSbGwzVjJ0a1ZVMVdjR2hXUjNoTFl6Sk9SazFXWkdoTldFSnZWakZhYTFVeFRrZFZia3BZWWxoU1ZGWnJaRFJXVm1SWVpFZDBUazFFUmtoWGExcHZZVEZKZDFkdE9WVldiSEF6V2xkNGEyTnNXblJQVjJoVFlUTkJkMWRzVm1GaU1WcFhWMnhvVm1KR1NtaFZhazV2WVVac05sSnRkR3RXYkVvd1drVmFUMVJzU2tkU2FsWlhZa2RPTTFwVlpGSmxSbVJaWWtaU2FFMXNTbmhXVjNSaFpERmtWMWR1VW14U01GcHZWVzE0ZDFKc1ZuUk5WRUpXVFVSR1YxUnNVa2RXTVZvMlVsUkNWMkV4Y0V0YVZ6RkhVakpPUjJGR1pHbFNXRUpLVmpKMFUxSXhWWGhUV0doaFUwVndiMVZxVG05V1JsbDNWMnQwYkZac2NGbFpNRlpyVjJ4YWNrNVljRnBoTVhCb1ZqQmtTMVpzWkhOWGJIQnBVbXh2ZWxkc1pEUldiVlpJVW10c1lWSnRhRlJaYTJRelRXeGFjMWt6YUdsTlZuQXdWbTAxUzJGc1NuTlRiR1JhVmpOU2FGbFZXbmRTTVdSelZHMTBVMDFFVmtsV2EyTjRZekpHUmsxVmJGSmlWVnBZV1d4U1EwNUdjRVZTYTNCc1VteEtXbGxWV2xkaFZrbDRVMnh3V0ZaNlJqWlVWbHBhWlVkS1IxWnNVbWxTVkZaYVZtMHdlRTVIVm5OWFdHeE9WbGRTV1ZWdGVIZGxiRmw1WTBWT1dsWnJjRmxaVlZwRFZqQXhSMk5GZEdGU1JYQlFWVzB4UzFJeGNFZGFSVFZPWWxka05WWnRjRWRaVm14WFdraFNWMkpyTlZoWmJYUjNZMnhXZEdWSFJsaFNiSEF3Vkd4V1QyRlZNVmRqUmxwV1ZucEZkMVp0YzNoV2F6VldZVVphVG1Gc1dsVlhWbVEwVXpGYVYxZHVUbWhTYmtKd1ZXcEtiMlZHWkhOV2JVWmFWakF4TkZadE5VdGhNVXBWVm14U1ZWWldTa2RVVlZwaFkxWk9jVlZ0YkU1V2JrSktWbFJLTUdJeVJrZFRhbHBwVW0xU1lWbHJaRzlrYkZwR1YyeHdhMDFYVWpGV1IzaHJWakpGZWxGWWFGZE5ibEp5V1dwR1ZtVldUblZUYkZKcFUwVktXbGRYZEdGWlYwNXpWbTVHVTJKWVVsUlVWbFV4Wld4YWRHVkZPV2hXYTNBeFZWZDRjMVl5U2xWV2FrNVdZbFJHVTFwVldtdGpiVVpHVGxaa1dGSnJjRlpXYTFwclpXc3hWMU5ZYUdsVFJYQlpXV3hvVTJJeFduUmxTR1JUVFZaYU1Ga3dXazlXTURGeVkwVm9WazF1VW5aV2FrWmhUbXhLYzJGR1dtaGhNVzk2VmxSR1lWVXlUWGhqUldocFVtMVNUMVJYTVc5V01WcHhVMnBTYUdKV1drZFViRlp2VlRKRmVWVnRhRlppVkVaMldUSjRWMk5XUm5SU2JIQlhZa2hDTmxac1pEQlVNVkY0VTI1T2FsTklRbUZXYkdSdlZVWnNWMWRyZEdwaVZUVkdWVmQ0YTFZd01IbGhSRnBYWWxSQ05GVnFTazlqTVhCSlUyMTRVMkpJUWxCWFZ6QjRZakpKZUZkc1ZsSmlXRkpZVkZaVk1WTldXbGhrUjNSYVZtdHdWbFp0ZUc5WGJVcFpWV3Q0VmsxV2NHaGFSV1JQVW0xU1JrOVdUazVXVm10M1ZtMXdSMkl5VFhoWGEyaFRWMGQ0YjFWdE1WTlpWbHB4VkdzMWJGSnNiRE5XTW5ocllXMUtSMk5FUWxaaVZFWXpXVlphU21Wc2EzcGlSbVJYWld0Sk1GWkdWbXRTYlZaSFdraFdWV0pHU205WlZFSjNZVVphUjFadFJtdE5WbHBJVmpGb2ExZEhSWHBSYms1WFlXdEthRlV4V2xKbFJtUjBaRVpXYVZaWVFYZFhWbFp2WXpGWmVGTnVUbGhpVjJoaFdsZDBZV05zVm5GU2JHUnJWbXh3ZWxadE1YTlZNREYwWVVkR1YySkhVak5WZWtwS1pWWk9XV0ZHYUdsU01taDZWbGN4ZWsxWFRsZFZiR1JZWW0xU1ZWVnRlSGRYVm5CV1drUkNhRkpyY0hsWk1GcHJWbGRLUjJOR1VsZGlSbkJvV1hwS1QxSnRWa2hTYkdST1RXMW9OVll4VWtwbFJrbDRVMjVLVUZadGFHOVZiWE14WTBaVmQxWnJjRTVXYkd3MFZsZDBUMWRzV1hoU2FsSlhUV3BXVUZZd1dtdFRWa1p6Vkd4d1YxSlVWakpXYWtKaFl6RmtTRlZyYkdGU2JGcFVXV3RvUTA1c1duRlRha0pPVW0xU1NGWXlOVmRWYlVWNVlVWnNXbFpGV2pOWk1uaGhWbFpLZEZKdGRGZGhNWEExVmtaYVlXRXhVblJUYmxKb1VtMTRXRlJXV25kamJGcFlUVlprVTAxV1dqRldSekZIVlRKS1YxTnVaRmhXYldnelZtcEtTbVZHWkhOaFIzQlRWMFpLZDFaR1dtRlNNRFZIWWtoS2FGSllVbGhVVjNSM1RVWmFXRTVWZEZoaVZWWTBXVEJTVDFsV1dYcGhSMmhYVFVkU1ZGVnRjelZXTWtaSVlrWk9hV0V3V1hwV2FrbzBWakZzV0ZOWWFGaFhSMUpQVmpCV1lWZEdiSEpXYTNSYVZteHdNRnBWYUd0V2JFcHpWMnBDVlZac1ZURldhMXBLWkRGa2NtRkdaRTVoYTFvMlYxWmFhMUp0VVhsVGFscFVZa2RTVDFadGRIZFNWbGw0VjIxR1YySldXa2hYYTFwellVWkplbEZzVWxkaVdHZ3pWakJhYTFkSFVraGtSbHBPWVhwV1NWWnRNREZWTWtwSFZHdG9WbUpIZUdGWlZFWjNUVEZWZUZkdVpGZGlTRUpHVlZkNFYyRldTbGxSYWxwWVZqTlNWRlpFUm1GV01XUjFWR3hvYVZJeWFGbFdiWFJYWkRGU1IxWllaR0ZTVjFKVlZXMTBkMlZzV25SbFIzUlhUV3R3ZVZVeWN6RldNa3BJVlZoa1dGWnNjSHBXTUZwVFYxZEdTRkpzVWxOaE0wSldWakZrTkdJeFJYaFZXR2hZWW1zMVYxbHJaRk5WUm14eVYyNWtiR0pIVW5sV1YzaFBZVVpLVlZKdWJGZE5ibEp5Vm14YVlXTXlUa2xUYkdST1VtNUNiMVpYTVRSVU1rMTVVbXRrYWxJeWVGUlpWRTVEVW14YWNscEVRbHBXYlhoWVZUSjRhMVpIU25KalNFcFdZV3MxVkZaclduTldWbEp5VkdzNVYySkhkekZYYTFaclRVWlZkMDFXWkZkaGJFcFlWRmMxVTJOc1dYZGFSWFJyVW14YWVsbHJXbXRoUjBZMlZteFdWMkZyU21oYVJFWlBVbXN4VjFwSFJsTmlWa3BRVm0xd1IxTXhiRmRhUm1SWFlsVmFjRlJYZEdGWFJtUnlWbTEwVjFJd2NERlZWM2h6VmpKR2NrNVlXbHBXVm5CWVdURmFSMVpXU25OYVJUVlhUVlZzTkZadGVHcGxSVFZIVmxoc1YySnNTbk5WYlRGdlYwWldkRTFXU210TlZuQjRWVlpTUjFZd01WaFZibkJhVmxaVk1WWnFSbUZXVmxwellrWm9WMDB5YUZsWGExSkhZVEpOZVZOclpGaGlSbkJ2V2xjeE5GZHNaRmhsUm1SYVZqRmFXRll4YUhOVU1XUklWV3hvVlZZelVqTlZNRnB5WkRGYWNWVnNjRmRoTTBJMlYxUkNVMVF4V25KTlZXaFdZVE5vVjFsc2FFNWxSbHB4VW01a1ZGSXdjRWxaVlZVeFZrWktWbU5IYUZkaVZFSXpXbFZWTVZJeVNrZGhSazVwWWtWd1dWZFdVa3RWTVZwWFYxaGtZVkpHU2xoVmJURTBWbXhXZEU1WGRGZFdWRVpZV1d0U1QxWXlTbFZXYmtwWFlsaG9URmw2U2t0U1ZsSnpZMFprVjJKSVFsSldiWEJEV1Zac1dGVnJhRmRoTWxKWldXdGFkMVF4YkZoa1JWcHNVbXh3TUZrd1ZtdFdSVEZ5VFZSV1YxSXpVbkpYVmxwTFpFWldjazlXY0ZkTk1VcHZWbFJHWVdFeFdYaFdia3BoVW14S2NGWnRkRnBOUmxsNVpFYzVWRTFyV2toVk1qVlRWbTFLU0dGR1dsZGhNVm96V2taYWQxZEhWa2hTYlhCWFlURnZkMVpYTVRSV01WSnpWMnhzVW1Gc2NGaFpWRXBPWlVaYVJWTnJaRmROVlRVeFZsZDRZV0ZXU1hsaFJtaFlWak5TYUZkV1ZYZGxSMHBKVW14T2FWTkZTbnBXVnpCNFZUQXhSMVp1VW14VFIxSllWRmQwZDFOV2NFbGpSVTVYVFd0d1NWWkdhRzlXTWtaeVYyeGtZVlpzY0ZCWk1uaDNVMGRPUjFWc1RsZFhSVXBoVm0xMFlWWXhiRmRpUm1SV1lUSlNXVmxyV25kWFZteHpWbTFHYW1KR1ducFdWM1JyVmtkS1NHVkdaRmRpUmtwSVZteGtTMUp0VGtaYVJtUk9ZbTFvTmxadGNFdFNNazUwVTJwYVVtSkhVbTlaVkVaM1lqRmFWVkZ0UmxSTmJFcFlWbGMxVDFadFNsaGxSemxWVm0xb1JGWXdXbUZrUlRGSllVVTVVMDFWV1RGV1Z6RXdZVEZhZEZOclpHcFNiWGhoV1ZSS1UxWkdhM2hYYkU1WVVqRktTVlZ0ZUZOV01rcHlVMnRvVjJGcmJ6QlpWRVpoVjBaT2NscEhjRk5TVlhCdlZsUkNiMUV4VGtkWFdHUllZbFZhY1ZSV1pGTk5SbXhXVjI1a2FGSXdWalJaTUdoelYwZEZlRmR0YUZabGExcHlWakJhVDJOc2NFZGhSMnhYVFRKb1ZsWXhXbE5VTVVWNFdraE9XRmRIYUZsWmExVXhWa1pTV0dWRlpFOVdiRm93V2tWa01GZEdTWGRqU0hCV1RXcFdVRlp0TVVkamF6VlhWV3h3VG1KdGFHOVhhMVpyVmpGS2RGVnJhR3hTYlZKd1ZXeGFjbVF4V25GVGFrSnBUVlpHTkZZeU5VdFViRnAwWVVaa1dsWkZjRlJXYWtaell6SkdSbFJzWkZOaVNFSTBWbFJLTUdFeVJuUlRiRnBwVWtad1dWbFVSbmRrYkZweFUydDBWRlpyV25wV1YzaHZZVlpLYzJOSE9WZGlXRUpNVmxSR1dtVkdXblZXYkZacFZqSm9WVlpHWXpGaU1sRjRWMnhvVGxKRldsTlVWbHAzVjBaWmVHRkhPVmhTTUhCYVZsZDRRMVp0Um5KWGEyaFZZVEZ3Y2xreWVHRmtSMUpJWVVaa2FHVnNXa2xXTVZKRFlUSkplRmR1VWxSaE1sSlZXVzAxUTFkR1duTlhibVJZVW01Q1IxWnNhRzlXTVZwelUyNXNWV0pIVW5wV1ZFcExVMFU1VlZSc1pFNWliV2haVjFaU1IxTnRWbGRUYms1aFVteEtjRmxZY0ZkbFJscFZVVzEwVDFKc2NIcFphMmhMVjBkRmVsVnNWbFppV0dnelZGVmFjMDVzVW5SUFYyaE9WbTEzZWxacVNqQmlNVmw0VjFod2FGSkZOVmhaVjNSaFdWWndWbGRyT1dwaVZYQklWMnRhVDJKSFJYaFdhazVYWVd0YWFGbFVSbE5rUmxweldrWldhV0V6UW05V1YzQkxZakZhUjJKSVRsaGhNMUpYVlcxNGQxTkdaRlZVYlRsb1ZsUkdXRmt3YUhkV01ERnhWbXhDVjAxdVRqTmFWbHBYWkZaU2MxZHRiRmhTTW1oMlZtdGFWMWxXYkZoVmEyaFdZVEpvY2xWcVNtOWpSbFp6WVVWT1dHSkdjSHBYVkU1dllWVXhWMk5FUWxaTmJtaFlWbFJLUzJNeVRraFNiRlpYVm01QmVsZHNaRFJYYlZaSFkwVmFVRlpyTlU5V01GWkxVMVprVjFadFJtaE5hMXBZVmpJMVMyRnNTblZSYkdoVlZteHdNMVl3V25OalZrNXlWMjE0VTJKSVFtRldNblJXVFZaWmVWTnNhR2hTYldoWlZtNXdRbVZHVmxWU2JYUlRUVlphZWxsVlZUVldNa1kyVm01c1dGWXpVbkpVYTJSWFZqRmtXV0pIZEZOU1ZYQlhWa1prTUdReFdYaGhNMlJYWW1zMVdGWnNVa2RYUm10M1lVVjBXR0pHY0ZsV1YzUnJXVlpLUm1ORmRHRldla1pRVldwR2QxSXhjRVpPVlRWVFYwVktURlp0Y0VkVk1VNTBWbXRrVjJKc1NsaFpWRXBUWTFaV2MxcEVVbGRXYlhoNVZqSXhSMkZzU25OWGJtaFdZbGhSZDFadGVFdGpNazVGVVd4V1YxWnJjRWxXYkdSNlpVWmFjazVXV21oU2JWSlBXVzB4YjFkV1duUmtSMFphVm10d2VsZHJhRTlXTWtwSFYyeG9XbUpHY0V4V2JGcGhVakZhZEZKc1pFNWlSWEJJVmtkNFlWbFhSWGhUYmxKb1VteEtWbFpzWkc5U1JsbDVaVWQwVjAxV2NEQlZiVEZ6Vkd4WmVGTnFXbGRoYTFwMldrUkdZV1JHVG5OaFIyaFRZbGRvVjFadGVHRmtNREI0WTBab2JGSnJOWEpWYWtaaFVqRndSbHBFUWxkTmEzQjVWVEowYzFZeVNraFZWRUpYVWtWd1NGVnRjM2hUVm5CSFZXeGtVMWRGU2xwV01XUTBZakZWZVZSc1pHcFNiSEJvVld4b1EyTXhXblJqZWtac1ZtMTRWMVl5ZUU5aFJrcFZVbTV3VmsxcVZuWldha1phWld4R2NtVkdjR2hoTVhCNVZsZHdTMU14VGxkVmJsSm9VbXMxYzFsc2FHOU9SbHAwVFVoa1RsWnJWalJXTVdodlYwZEtjazVXWkZwV1JYQlVWakJhVjJSSFVrbGFSM2hwVW0xM01WZHNWbTloTVdSSFUxaGtWMkZzU2xoWmEyUnZaR3hhY1ZOclpHcGlSMUl3VlcweFIxWXhXblZSYkVaWVYwaENURlZxUmtwbFZrcHlXa2RHVTAweWFIWldSbHByVFVVMVYxZHVVbXRTTUZwaFZtMHhORmRXVm5OaFJ6bFlVbTFTU1ZwVldsZFhiRnBHWW5wQ1YySllhSHBaZWtaM1UwVTVWMXBHVG1sWFIyaG9WakZTUTFsWFJYaGFSV2hVWVRKU2NWVnJWa3RXYkZwMFpVVjBWMUpzYkRWYVZXUkhWakZhY21OSWJGcFdWbkF6VmtkNFMyTXlUa2hQVm1oWFlrWndiMVpZY0VkWlZtUkhWRzVLWVZKdGFIQlZNRlpMVjJ4YVZWRnNaRlJOVlRWWVZqSTFSMVV5U2xaWGJrcFZWbXhhTTFwWGVHRmtSVFZXWkVaYVUySklRWGRXYkdSNlRsWmtjMWRyV2s5V1ZrcFlXVmQwWVdGR2NFWldXR2hYVm14YWVsVXljekZXTWtwWldUTm9WMkpIVGpOVVZscE9aVVphV1dKR1RtbGhlbFpXVjFkMGEySXhiRmRYYmtaVllrVTFUMVJXV25kU01WbDVaVVU1YUUxVmJEUldNblJyVmxVeFdGVnFUbGRTTTJoaFdsVmFUMk5XWkhOYVJUVnBZa1Z3TlZZeGFIZFNNVnAwVm10a2FsSldjRmxaYTFwTFlqRlNWVkpyZEZoV2JWSlpXbFZhVDFWck1VVldhMmhhVFVaYVdGWlVTa1psVmxaMVUyeGFhVmRIWjNwWGJGcGhZekZhYzFwSVVsTmlWMmhZV1ZSS00wMVdaRmRXYlVaWFRWZFNTRll5TlU5V1IwVjZZVWRHV2xZelVqTlZla1ozVm14a2RGSnRkRmRpUm05M1YyeFdZVlV4VlhkTlZscHFVa1pLV0ZsclpFOU9SbEp5V2tVMWEwMUVSa3BaVldSSFZrWktXVkZ0YUZoaVIxRXdWMVprVDFJeFduVlZiWGhVVWpGS1VGWlhNVFJrTVdSWFkwWmFZVkpYVWxoVVYzUjNWakZyZDFkdFJsZGlWWEJhVmxjMVlWWXlSbkpqUlhoWFRWWndWRmt4V2xkak1rNUdUbGRzYUdWc1JqTldiVEI0VGtac1YySkdhRlZYUjJoeFZXeGtVMVpzYkZsalJtUlZUVlp3ZWxkWWNGZFVNVnB6WTBob1ZtSlVSa2hXYWtGNFYwZFdSMkZHWkZObGJGcFZWbTF3UzFNeFRraFNhMlJXWWtoQ1dGVnNXblpsYkZwelYyMUdXbFl4U2tkVVZscHJWbGRLUjFkck9WZGlXR2d5V2tSR2EyTXhXblJQVjJoT1ZtNUNXVlpxU1RGVU1rWnpVMnhvYUZKdGVHRldhMVpoVkVaYWNsZHNjR3hXTVZwSVdUQmtORlV5UmpaV2FsWlhUVzVTYUZacVJscGxWazV5WWtaS2FHSklRbGxXUmxwaFpESkdSMVpxV2xSaGVteHlWVzE0UzJWV1dYbGxSVTVYVFd0d1dGVXlOV3RXTWtwWlZXMW9XRlpzY0V4VmFrWjNVMVpPYzFkdGFFNWlSWEJ2Vm0weGQxSXhUWGhUV0doV1lrZFNXVmxyWkZOV01XeHpWbTVrV0ZadGVGZFdiRkpYVmpBeGNsZHViRmROYmxFd1ZtMXplR1JYUmtoaFJtUnBVbTVDVVZkVVJtRlNNbEpJVTJ0YVQxWnRVbkJaVkVKYVpXeGFkR1ZHVGxSTlJFWkpWVEZvYzFVeVJYbFZiRlpYVFVkU1ZGWXhXbk5qTVZwMFVteHdWMkpZYUZkV1ZFbzBWREpGZVZOcmJGSmhNbmhvVm14a1UxTkdXbFZUYTNSVVVteGFlRlZ0ZUd0Vk1sWnlWMWh3VjJKWVFreFZiVEZYWXpGS2RWSnNhR2xTTVVwUVYxY3hORk15VmxkYVNFcFdZVEpTVjFSWGMzaE9SbVJ5WVVaa1YxWXdjRnBWVjNoVFZtMUtWVlpyVWxkTlZuQm9WV3BHYzA1c1NuTlhhelZvWld4Wk1sWXhaREJWTVd4WFZsaHNWR0V4Y0ZCV01GWmhWbXhhZEUxWE9WTlNiRnA0VlcxNGQySkdXWGhYYTJoWFVucEdkbFpxU2tkT2JGcHlZVVprVjFKWE9IZFhhMUpIWVRGSmVGcEdiR3BTYkhCd1ZtcEtiMWRzV25STlNHaFdUVlUxU0ZadE5VZFdSMFY2Vld4U1ZWWnNjRE5hVjNoaFUwVXhXVlJzV2s1V2JrSkpWbXBLZDFVeFdYZE5WbVJxVTBad2FGVnJWbUZUTVhCV1YyNWtVMkpJUWtsVmJYaFRWVEZrUmxOdVdsZGlSa3BFV1ZSR1ZtVkdaRmxoUmxwcFVqRktXVmRYTUhoVk1XUkhWV3hrWVZKRlNrOVVWbHB6VGxaU1YxVnJUbGROUkVaR1ZXMDFjMWRyTVVkalJFNVhUVzVvYUZZd1pFZFNiVlpIV2tVMWFHRXhjRXBXTVZKS1pVWlJlRk5ZYUZkaWF6VnhWV3BPYjJJeFVsZGhSVTVQVm14c05GWlhkSGRpUmtweVlrUlNWMUl6VW5aV2FrcEdaVlpXYzFkc2NHaE5iRW95Vm0xMFlWbFhUWGxTYTFwVVlYcFdXRmxyYUVKa01XUnlWbTEwVTAxWFVucFdNalZUWWtaS2RHVkdhRmRpVkVaMldsZDRZV05XVG5KWGJYaFhZa1p3TmxkWGRHRmtNa1pHVFZoT1ZHRnJjRmxXTUdoRFUwWmFkRTFXU214U01EVkhWMnRhVjJGV1dYcGhSa0pYWWxSRk1GcEVRVEZqTVdSMVZHMUdVMUpWY0haV1JscHJWVEZPVjFaWWJHdFNNMUpaVldwQ2QxTldjRlpYYlVaWVlsVldOVlpYTldGV01WcFhZMGRvV2sxV2NFaFdNV1JIVTBkT1NHSkdaRmRTYkhCTFZtcEdVMUV4YkZoU1dHaFlWMGQ0V0ZsdGRIZFhWbXhZWkVoa1dGSnRlRmxhUldoaFZHeEtkRlZzYUZkTmJsRjNXVmR6ZUZkV1JuSmpSbVJUVFRKb1RWZFdXbUZUTWxKWFVtNU9VbUpIVWxoYVYzUkhUa1phVjFWcmRGUmlWbHBJV1RCV2ExWXlTa2RUYkd4V1lXdHdkbFpzV21GU01XUnpXa2R3VGxKR1drbFdiVEF4VlRGUmVGZHNWbWxTTUZwWVdXeG9VMlZzVW5OWGJtUlhZa2RTZWxkcldtdGhWbHBaVVd0c1YyRnJjRE5WZWtaelZqRmtXV05IYUZOTmJXaG9Wa1phWVdReFVrZGpSVnBoVWxSc1ZWVnFSbUZUUmxwSVpVZDBWazFXY0RGVlYzUXdWakpLVlZKWVpGaFdiVkpMV2xaYVMxZFhSa2RYYkdoVFRXMW9kbFpzWkRSWlYxRjRWbXRrV0dKc1NrOVdhMXBMV1ZaYWRFMVVVbXhpUjNoWFYxaHdWMVl4V25KalNIQmFUVVphYUZadE1VdFdWa3B5WVVad1YyVnJXazFXVkVKaFZqSlNXRk5yYUZOaVJUVllXVzEwUjA1c1duUk5XR1JVVFZVeE5GWkhlR3RWTWtweVYyeGtXbUV5VWxSV01GcHpZMjFHUmxSc1pGZGlTRUphVjFSQ1YwMUdXa1pOVmxwUFZsZG9XRlZ1Y0ZkVVJtUlhWMnR3YkZZeFdraFdWM2hoWVZaa1NGb3pjRmRpV0VKSVdWUkdhMU5HVm5KaFJrNXBVakpvZDFadE1UQlhhekZIV2tab2ExSXdXbUZXYlhoelRrWmtjbFp0T1doU2EzQXdXVlZrUjFkdFJYaGpSbVJoVmxad1YxcFdaRmRUVms1MFpFVTFWMDFWYkROV01uUlhXVlpaZVZKc1pGaGlSM2hUVmpCa1UxZFdXblJsUjBab1VteHdlRlZ0ZUhkaVJscHlZMFJHVmsxcVJucFdWRVpMWTIxT1IyRkdhRmROTW1oVlZsZHdSMkV4U1hoYVJteGhVbTFvYjFSVVJrdGxSbVJZWkVkMFZrMXNXbnBXTVdoelZHeGtSazVXWkZWV1ZrcElWbXBHY21ReFpISmFSbVJPVWtWYVdsWnJaSGRVTVd4WFYyeG9WbUV6VW1oV2JYaDNZVVpzTmxKdVpGUlNhM0I2VmtjeGMxZEdTWGxhZWtKWFlsaG9jbFJyWkVabFJscFpZVWRzVTJKV1NscFhWekV3V1ZaYVIySkdWbFZpUlRWWVZtMTRkMDFHY0ZaaFIzUllVbXh3TVZWWGRHdFhSMFY0VTJ0U1YyRnJSalJXYWtwTFVsWlNjMXBGTlZkaE0wSk9WbTB4ZDFNeFRYaFhiR1JUWWtaYVZGbHJaRk5qUmxaMFRsVk9hVTFYVW5sV2JURXdWVEF4Vm1OSWNGZFdlbFpRVm1wS1MxTkdWblZSYkZwT1VteHdUVmRyWkRSWGJWWkhWbTVLYTFKVWJGUlVWVnBhVFZaYWMxcEVRbWhOVm5CSlZUSTFTMVF4WkVaWGJHUmFZa1pLU0ZacldtRlNWa3B6V2tkd2FWSnVRalpXYWtsNFRVWlNjMWR1VmxKWFIxSllWVzE0WVdSc2JGVlNiRTVxVFZkU01WWkhlR3RoUjBwR1kwWnNXRll6VW5KWmFrcFRZekZ3UjFwR2FHaE5NVXBhVmxkd1IxbFdUa2RYYTJoc1UwZFNiMVZzVWtkWFJscDBZMFpPVjAxRVJsaFpNR1J2VjIxV2NsZHRhRmRoYTFwVVdrWmFVMk14Vm5SaFIzaHBVbTVDVjFacVJtdE9SbXhYVkZob1lWSnRVbGxaYlhSaFZsWlpkMXBIT1ZkU2JFcFpXa1ZrUjFSc1NuTldhbFpoVWxkUmQxbFZaRXRTYlU1R1drWmFUbUp0YUhsV2FrbDRVekZPU0ZKcldsQldNRnBZVm0wMVEySXhXbFZSYlhSWFRWVTFTRlV5TlZOaE1VcDBWVzA1VlZadGFFTlVWM2hhWlVaa2MxcEdjRmROUmxreFZsY3hNR0l4VlhoYVJXaHNVMFZ3YUZacVRsTlVSbGwzVjIxR2FsWnNTbmxXUjNoVFZUSktWMU5zYkZkaGEyOTNXa1JLUzFJeFRuVlViRkpwWW10S2FGZFdVa3RWTWxKelYyeFdWR0V6VWxsVmFrSmhVMnhaZVdWSGRGWk5hM0JYVkZaU1UxZEdXWHBSYTJoYVZrVmFTMXBWWkU5U2JIQklZVVpPVGsxdGFGWldNbmhxWlVVMVNGVllhRmhoTWxKb1ZUQm9RMVF4V25GU2JVWnNZa1pzTkZsVmFFOVdWVEZYWTBac1YxWXphSFpXYlRGSFkyeE9jMkZHVm1oTldFSTFWMnRTUzFJeFNuSlBWbVJvVWpKNFdGWnRlSEprTVZwMFkwVndiRkl3YkRSWmExcHJWMFprU1ZGdE9WWk5SbG96VjFaYVUxZEZOVmhQVjNCcFUwVktTRll5ZEdGVU1WVjNUVlpzVW1FeVVsWlphMlJUWld4YVZWTnJkR3BpUlhCYVdWVmFhMkZXV2taVFZFSlhVak5TY2xVeU1WZFdNVTV6WWtkb1UwMUdjRlZXYlhCSFV6RmtjMXBHYUU1WFNFSlBWbTE0ZDFkR2JISlhiR1JYVmpCd1ZsbHJXbTlXVmxwMFZWUkNWMDFXY0ROVmJYaDNVbXh3UjFwR1pHaE5NRVl6VmpKMFYxVXhXWGhhU0ZKWFltdHdVRll3V25kWFJteFlaRVZrVDFKc2JEUldNblJyWVcxS1ZtTkZhRnBOUjFKMlZrZDRhMUpzVG5OVGJHUk9WbTVDV1ZadE1IaFZiVlpYVm14c2FGSnNXbkJaVkVaM1ZteGtXR1JIZEZaTlZrWTBWakkxVTFReFdsWk9WbWhYWWxob00xcFdXbUZYUjFKSVpFWmFUbUV6UWxsV2Frb3dZakZrY2sxVlpGaGlia0pZV1d0a1UxUkdWWGRhUldSVVZtdGFlbGt3Wkc5VWJGcDBUMVJhVjAxdWFGaFhWbHB6VmpGd1JtRkdaR2hOYkVwWFYxZDRiMUV4VVhoWGJsSnNVbTVDVDFWdGVIZGxiR1J5Vld4T2FGSlVSbGxXVjNSelZtMUtTR0ZFVGxkaVZFWk1WV3BHYTJNeGNFZGpSMnhUVFcxbmVWWnJXbE5TTVZWNFYyNU9ZVk5GTlZaWmJHaERWREZhZEU1VlNtdE5WMUo1Vm0weFIyRkZNVmRUYm5CWFRXNW9kbGxVUVhkbGJFWnpZVVp3VjAweFNtOVdiWFJoVmpBMWMxTnVUbXBTTTJoWVdWaHdWMDVzV25STlZGSm9UV3RhV0ZVeWVHRmhiRXAwWlVac1YyRnJOWFpXYTFwWFkxWktjMVJzVGs1V01VcGhWMVpXYTFJeFZYaFhXR2hVWWtaYVdWWnFUbTloUm1SWFYyczVVMDFYVWpGV1Z6RTBWVEF3ZUZOdVdsZGlWRVkyVkZaYVNtVkdXbGxpUlRsWFRVWndXVlpHWkRCa01VNUhWbGhzYTFKck5WaFVWM1IzVm14V2RHVkhPVmRpVlZwNVZqSndUMVp0U2xsaFNFcGFaV3RhU0ZsNlJuZFRSMHBIV2tkb1RrMUZjSFpXYlRGM1VqRnNXRk5ZYkZaWFIyaFpWakJrTkZaV1dYZGFSemxYVFZkNGVWWXlNVWRXYXpGWVpVWmFWMUl6YUZCV2FrcExVakZrY1ZGdFJsZFdNbWg1VjFkMGExTXhTWGxUYTFaWFlrWmFXRmxzWkc5bFZscDBaVWQwVkUxVmJEVlZNblJYVmxkS1NGVnVRbGROUmxwTVZteGFZV1JIVGtaVGJYaFRZbFpLU2xaWE1UQmpNV1JJVTJ0b1ZtRjZiRmRaVjNSaFZFWlZlRmR0ZEZoV01EVkhXa1ZhVjFSc1dsaGtla0pYWWtkTmVGWkVSbk5XTVU1elZteGthVkpyY0ZkV2JURTBXVlV4YzJOR1pGaGlWVnB5Vld4U1IxZHNaSEpYYXpsVllrWnNObGxWV25kV01rVjVWRmhvVjFKRlduSlZNRnBQWkZaU2MyRkhiRmROYldoWlZqRmtOR0l5U1hoVmEyUllZbXR3V1ZsdGN6RmpWbXh5V2taT1RsWnRVbmxXYkZKWFZtc3hjbU5GY0ZaV00yZ3pWbXBHUzJNeFpITlZiRnBvWVROQ1NWWlhNWHBsUmxsNFkwVmtZVkl5YUc5YVYzaGhWMFphZEUxSVpHeFNNR3cwVmxkMGExZEdaRWhWYldoV1lrWndNMWw2Um1GalZrcDBVbXhTVjJKWWFGaFdha2w0VWpKR1IxZHVTbXBTUlZwWFZtMHhiMDB4V25GVGEzUlRUVmRTTUZsVldtOVdNa3BKVVd4R1YxWkZTbWhXVkVaclYwWlNjbUZIYUZOaGVsWjNWbTB4TUdRd01IaFhibEpPVmtaS1YxUldXbk5PUmxwSVpVZDBXbFpyY0RCWlZXaExWbTFHY2xOdGFGcGhhMXBVVm1wR2EyTnRVa2hsUjJ4VFlsaGplRlpyWkRSWlYwVjRWMjVTVkdKR2NGbFpiVEUwV1ZaU1ZsZHVaR3hpUm13MVdsVmtSMVV5U2toVmJteGhWbFp3YUZaSGVFdGtWa1p6WVVab2FWSnVRbGhYYkZaaFYyMVdTRlJyV21GU2JGcHZXbGQ0WVZkV1pGaGtSM0JQVmxSV1NGWXlOVTlXYlVWNlVXNU9WbUpZVW5wVWExcGhZekpHU1ZSc1pGTk5TRUpLVjFaV2FrNVdXblJUYkZaWFlURktXRlJWV25kaFJtdDRWMnhPYW1KR1NucFdNbmhQWVZaa1NGcDZRbGRpUjA0MFZHdGtSbVZHWkZsYVJUVlhZbGRvV0ZkV1pEQlpWbVJIVjI1V2FsSldjRTlWYlhoM1ZteFZlV1ZIZEdoTlZXdzBWakowYjFkc1dsZGpTRXBYVmtWd1RGVXhXa2RrVjBwSFdrZHNVMkV6UWtwV01WcFRVakZPZEZaclpHcFNWM2hZV1d0YWQySXhjRmhOVkZKWVZteHdNRmt3Vm10V1JURllWV3RvV0dFeGNIWlphMXBMWkVaV2RWTnNWbGRXYTNCSlZsUkNZVmR0VmxoV2EyaFFWako0VkZsVVRrSmtNVnB6V2tSU2FrMVhVakJWTW5SclYwZEtTR0ZHV2xwV1JWb3pXbFphZDFKV1NuVmFSbEpUVmtkNFdWWXlkRlpOVmxWNFUyeGthbEp1UWxoVVZscExVa1prVjFkc1dteFNia0pLVmxkNGEyRlhSWHBSYkhCWVZqTm9jbGxxUm5OV01WWnpXa1pvYVdKV1NsWldWekI0VFRBeGMxWnVVazlXTTFKWFZGZDBXazFzV25SbFJ6bFlVakJXTlZaWE5YZFhiRnBYVm1wU1ZrMUhVbFJWYkZwaFl6RndTR0pHYUZOV1dFSkxWbTB4TkZVeFNYaFRibEpYWWtkU1ZsbHJaRFJqUmxaMFpVaGtXRlpzV25oVk1qQTFZVlV4VjJOR1dsWldNMmh5V1ZSQmVGWXhTbkZWYkdST1lXeGFVVll4V21GVE1rNXlUbFprYUZKdFVuQldhMVpXWkRGa2MxZHRSbHBXTVVwSlZsZDBWMVZ0U2toaFJsSmFZVEpvUkZSdGVHdFdWa1p6Vkd4S1RsWXphRmxXYWtvMFlqSkdSMVJyV21wU01GcFlXV3RhZDAweFdrWlhibVJUWWtoQ1NGWkhjelZoVmtwVlZtcGFWMkZyY0RaVVZtUkhWMFpLY1Zkc1NtaGlSWEJaVjFkNGIySXhXa2RXYmtaVFltczFXVlZ0ZUV0WGJHeFdWMnhrYUZZd2NFaFpNR2h2VmpGYU5sRnFVbGRXUlZwVFdsVmtTMUl5Umtoa1JrNU9VbTVDVWxZeFpEQlpWMUY1Vm10a1YySkhhRTlXYkdSVFYwWldjVkZ1WkZoU2JHdzFXbFZvVDFZeVNsWmpSbkJYVmpOb2RsWnFTa2RqYlU1R1pVWmFUbEp1UWxsWFZFcDZUbFpaZUdORmFHaFNNbWhQVkZWV2MwNUdXbkZUYWxKb1RVUldTRmxyV210WlZrcFlZVVphV2xaRldqTlpNbmhYWkVkV1NWcEhjRk5pU0VGM1YyeFdiMkV4V2tkWGJrNXFVMGQ0V1ZsVVJrdFdSbXhZWXpOb2FtSkhVbmxaVlZwaFZHMUdjMWRzVmxoV2JGcG9Wa1JHUzJNeFVuVlZiRTVwVTBWS1dWWlhlR0ZrTWtsNFYydGtWbUV5VW5KVVZsWjNWMFpWZVU1V1RsWk5hM0JKV1ZWYVUxWXlSWGhYYldoWVZteHdjbFpzV2tkak1XUnlUbFprYVZJelpEWldhMXBoVmpGWmVGZFliRk5YUjNoelZXMHhORmRHYkZoamVrWlhVbTE0VjFZeU1VZGhiRnB5WTBod1dHRXlVWGRXVkVwSFRteGFjVlpzYUZkTk1VcHZWbGh3UzFJeFRrZFhibFpXWWxob1ZGbHNaRzlYYkZwMFkwVTVhVTFzU25wWmEyaEhWV3hrU0ZWdVRsWmlXR2hvV2xkNFdtVlhWa2hQVjJoWFRVaENXVlpVU2pSak1XUkhWMWh3Vm1Kc2NGZFdhMVpoVXpGd1ZsZHVaRlJXYXpWNldWVmtjMVl4U1hwaFJFcFhZbFJDTkZSVlpGSmtNREZXV2tkd1UxWnNjRmRYVnpCNFZURmtWMVp1VW14VFJUVlFXV3RhZDFkV2NGWlhhemxYVFVSR2VWWXlOWE5XTURGeFVtNWFXRlpzY0V4V2FrcFBVakZHYzJORk5XaGhNWEJLVm14U1EyRXhTWGhUV0doWFltczFWbGxzWkRSaU1WSldZVVZPYVUxV2NEQlVWV2hyWVRBeGMxZHJaRlZpUmxwMlZtMTRhMU5IUmtkYVJuQlhVbGhDVlZacVJtRlhiVkY0WTBWa1ZXSlhhRlJaYTFwM1RteFplV1JIUmxWTlZtdzBWVEkxVDFaSFNraGhSbWhWVmpOQ1dGa3llSE5qYkhCR1pFWlNVMDFWY0VkV2EyUTBZVEZTZEZKdVNsZGhhelZZV1d4U1IwNXNjRlpYYlhSVFRWWndNVlV5TVVkVk1rcEpVV3hDV0ZaNlFqUlpha3BLWlVaa2RWVnRjRk5YUmtwV1ZrWmFhMVV4WkVkV2JsSlBWbGhTYjFWdGRIZE5SbXhXVjIwNVdHSlZjRWhaTUZZMFZqRmFWMk5JU2xwbGExcHlXa1ZhUzJNeGNFWk9WMmhzWWtaWmVsWnRlR3BsUlRGSVVsaG9ZVkpYYUZWWmEyUnZZakZXYzFWdVRscFdiWGg1VjJ0YVQyRXlTa2RqUkVKaFZsWndNMWxyV2t0a1ZrWnlWMnhhVjJWcldqSldhMlEwV1ZkTmVGcEdWbE5pUjFKdlZGZDRSMDB4WkZkVmEyUllZbFphV0ZaSE5WZFdSMHBJWVVoQ1ZtSlVWa1JaVlZwclYwZFNTRkpzVWs1aVJuQTJWbXBLTkZsV1pFaFRiRnBZWW10d1YxbFhkR0ZoUmxWNVpVZEdWRkl3TkRKV2JYaHJWRzFGZWxGcVZsZFdSVzkzV1dwR1dtUXdNVmxXYkZwcFVqSm9hRlp0ZEZkWlZteFhZMFphV0dKWVVuRlVWbHAzWld4YVNFMVlUbFpOUkVZd1dWVmFkMVl3TVZoVlZFSmFZV3RhUjFwVldtRmpiSEJIWVVkc2FHVnNXbUZXTVdRMFZqRnNXRlJzWkZaaVIyaHhXbGQwWVZaV2JISmFSRUpPVFZac05WUldVa05XTURGRlVtNXdWMDFxVm5wV2FrRjRaRlpXZFZkc1pFNVNNVXBOVmxkd1IyRXlVbGRVYms1aFVtczFWRlp0TlVOVVZsbDVaVVprYUUxV1JqUlZNalZQWVd4S1dHRkdVbHBoTVZWNFZrUkdjMlJGTVZoUFZtaHBVbTVDTmxZeWRGTlZNV1J6VjFob1ZHRnJTbGhaYkdodlkyeFpkMWR0ZEZSU01WcEtWVEo0WVdGSFJqWldiRlpYWWtaYWFGWnFTbE5TYXpGWFZteGFhVkl5YUZsWFYzUnZVVEZPYzFwSVRsZGlXRkpQVlcxNGQyVldVbGRoUlhSb1lrVndXVnBWWkc5V01rcElWV3M1VlZac2NHaGFSVlY0Vm0xU1IxcEdaR2hOTUVZMFZtMXdTMDVIUlhsU2ExcE9WbTE0VTFsWGVIZFhWbHB5Vm01YVRsSnRlRlpWTW5oUFZqQXhXVkZyY0ZkV2VrVXdWbFJLUjA1c1duVmFSbVJwVmtWV00xZHJVa2RoTVVsNFdraFdWV0pIYUhCV01GWkxaV3hhV0UxVVFtcE5SRlpZVm0wMVQyRkdTWHBWYkZwYVlURndNMVJWV21GWFJUVldWR3hrYVZaV1dUQlhWRUpYVGtaWmQwMVZaR3BTYkVwWVdWZDBZVTB4VlhkV1ZGWllVakZLU1ZscldrOWhWMFYzWVROb1YySllRa3hVVlZwYVpWWktXV0pHVG1saE0wSlFWbXBDVjJReFZrZFhiazVoVW5wc1lWWnRNVFJXYkZaMFRsZDBhR0pWY0VsYVZWcHZWakF4Y1ZKWVpGZGhNWEJNV2tWVk5WWldaSE5qUlRWVFltdEplVlp0TVhkVE1VMTRVMWhzVldFeWFGRldiVEZ2VjFaVmQxWnJkRlJXYkd3MFZqSXhSMWRIU2xkWGEyaFhWbnBXV0ZacVNrdFNNVTUxVVd4YWFWSnNiM3BXYWtaaFlURmtTRlZyWkdGU00xSlBWbTAxUTFkV1dYbGtSMFpvVFZad01GVnRjR0ZoVmtweVRsWmFWMkpHY0V4V01GcGFaREZrYzJOSGVGTk5SbkJMVm10amVHSXhVbk5YYkdoclpXdHdXRmxyWkU1bFJsWlZVbTFHVjAxWFVqRldSekYzVlRKS1dHRkdaRmhXTTFKb1drUkdXbVZIVGtkYVIwWlRZbFpLVmxaWGNFZFRNVTVIV2toS1dHRjZiRlpaYTFVeFVqRldkR05GT1ZkTmEzQmFXVlZvUzFaWFJYbFZhM1JoVmxad00xVXhXbGRqTVZaMFlVVTFhVll5WjNsV2JYaHFaVVUxUjFSWWFHRlNWMUpYV1d0YWQxZFdiSFJOVms1WVVteEtXRmxWVms5WFJrcDBWVzVzVjJKR1NraFpWbHBLWkRKT1IxcEdaRTVpYkVveVZtMXdSMU50Vm5OVmJHeG9VbTFTYjFsVVFscE5SbHAwVFVob1ZFMUVWbnBWTWpWUFdWWktWVlpzYUZwaVdGSk1Wako0V21WR1pITlViRXBwVm14d1NWWlVSbTlpTVdSSVUydG9iRkl5YUZkWmExcExWMFphYzFkc1pHcFdhelV3VkRGYWEyRldTWGhUYkhCWVlURmFjbFJWWkVkV2F6RlhZVVphYVZJeWFGbFdSbVIzVmpGT1IxZHVUbUZTV0ZKWVZtcENkMU5XVVhoWGJVWm9WbXh3UjFZeWVGZFdNa1p5VTIxb1YwMXFSbGhXYlhONFZqRmFjMU50YkZOaWEwcFJWbXhrTUZZeGJGZGFTRTVZWW1zMWFGVXdaRk5XUmxKWFYyNU9UMUpzYkRSWlZXaHJWakZhYzJORlpGZE5ibWgyVmpKNFdtVnNWbkZVYkdSVFZtNUNiMWRVUm1GVE1rNXlUMVpvYWxKVVZtOVVWRUpMVTJ4YWNWTnFRbWhOYXpFMFYydFdhMVpIU2tkalNFWldZa1p3TTFZd1dsTlhSVFZYVkd4a1UySkdjRFJXVnpFMFV6SktSMU51VWxaaVNFSmhXVlJHZDFaR2JGWldXR2hxVFZVMWVsa3dXbTlXTURCNVlVaHNXRll6UWtoWFZscEtaVVp3U1Zac1ZtbFNia0ozVmxkd1IxTXhaSE5hUm1oclVqTlNWMVJXWkZOWFJtdDNWbTFHV2xacmNFZFZNbmh2VjJ4a1NWRnJhRmRoYTFwVVdYcEtSMU5XY0VkYVJUVm9UVEJLYUZZeFdsZGlNV3hYV2toU1UxZEhhSEZWYkdodlZteHNjMVZyWkZWU2JGcDRWVEowTUZVd01YSk9WV3hhWVRGd1VGbFdXazlTYkU1eFUyeGthR0V5T0hkV01WcGhZekZaZUdORmJGWmlSMUp3VlcwMVExVkdXblJOU0docFRWWmFXRll5TlZOVWJGcHlUbFphVlZac2NHaGFWbHBoWkVVeFZscEdaRk5OU0VKSlYxUkNiMlF4WkVoU1dHaFVZa1pLWVZadGVGZE9SbHB4VTJzNVZGWXdjRWhXYlhocllWWktkVkZxVmxkaVZFWXpWV3BHYzFZeFRuVlViVVpVVWxSV2RsWlhNREZSTVdSSFZXeFdVMkV6VW5CVVZtUlRWbXhWZVdOR1RtaGlWWEJZVmpKNGMxWXhTWHBSYldoWFZrVndURlV3WkVkU01WWnpWbXhrVjJKclJqWldiRkpMVGtkRmVWUllhRmhpYkVweVZXcE9RMVF4V25SbFJuQk9WbXh3VmxVeFVrZFdSVEZYWTBWc1ZrMXVhRmhaVmxwTFpFZEdTRkpzY0doTldFSk5WbFJDWVZVeFdsZFRiazVoVWpOQ1dGbFljRmRPVmxweFUxaG9UbEpzU25wVk1uUmhWMGRLU0dGR2JGZGlXR2hvV1ZWYVlWWldTblJrUms1T1ZsUldZVmRYZEd0aU1WVjVVMnhvYUZKdGVGbFdiVEZTWkRGV05sTnJPV3BOYTNCS1ZXMTRUMkZXWkVkVGJHeFhVbXh3Y2xaVVJtdGpNWEJKVTIxR1UxWXhTbGhXUm1RMFdWVXhSMk5HV2xoaWJWSllWRmQwZDFac1ZsaGpSazVYVmpCV05Ga3daRzlYYlZaeVYyMW9ZVkpzY0ZoWk1uTTFWakZ3Ums1Vk5WZFhSVXB2Vm0weE5HRnRWa1pPVldoV1YwZFNUMVpzWkZOalZsWjBaVWhrYVUxV1ZqTldiRkpIVjBaS2MxTnNaRmRXTTFKeVZrZDRZV015VGtkaFJuQlhWakZHTTFadGNFSmxSMDV6V2toV2FWSnVRazlWYlhoeVpERmFkRTFJYUZOTmF6VXdWa2QwYTFWdFNrZGpTRUpXWWxSV1JGVXhXbXRqYkZwMFVteFNUbUY2UlRCWFZFSlhZVEZzVjFOc1ZsZGlhMHBZV1ZkMGQyTldjRlpYYlVaclVsUkdTbGRyWkRSVk1WcEdWMnRzV0ZZelVtaFpWRVpoVmpGd1JtRkhlRk5pU0VKWlZrWldhMVV5VW5OWGJsSnNVMFUxY2xWcVJtRlRWbFowVFZoa1ZrMXJjRWhaYWs1clZqRktjMk5IYUZkU1JWcG9WbTF6ZUZZeVJraGxSazVUVmxoQ1dGWnRNSGRsUmxKMFZtdGthVk5GY0doVmJHaFRWbFpXZEdWSFJteGlSM2g1VjJ0V2ExWnJNVmRpUkZKV1RXNVNlbFpxU2tkamJVbzJVV3hvVjJKV1NsQlhiRnBoVlRKT2MyTkZhR2hTYXpWd1ZUQldTMVZXV1hoWGJYUlBVbTE0V0ZadGVHdFhSMHB5VjJ4T1dtSkhhRlJXYkZwVFZqRmFkVlJyT1ZkaVNFSktWMnRXYTAxSFJrZFRia3BwVWtVMVdGUlhOVzlrYkZwelYyMUdVMkpIVW5sYVZWcDNZVWRGZUdOSE9WZFdNMEpJV2tSR1MxWXhXblZVYlhCVFlsWktVRlpYZEZkV2JWRjRWMjVTVGxOSFVrOVdiWE40VGxaV2MyRkhPVmRTTUhCNVZHeGFWMWRzWkVsUmJuQlhUVVp3ZWxreWVHdGpiVkpIWVVaT2FWSXpZM2RXYlhCS1pVWkplRnBGWkZSaVJscFVXV3RhZDFkR1duVmpSV1JPVFZad1NWcFZXbmRpUjBwV1YydG9XbUV4Y0hKV2FrWkxWMGRTUlZWc1pHbFNhM0JKVmpGYWExVXhTWGhWYmxaWFlrWktjRlZ0ZEhka01WcFlZMFZrVkUxcldraFdNalZUWVd4S1ZXSkdaRlZXTTFKb1ZUQmFZV015Umtoa1JtaFRUVWhDU0ZaSGVHRmlNVmw1VTJ4c1ZtRnJOVlpXYkZwM1RURldkR1ZIZEd0U1ZHeFlWMnRWTVZVeFNsZGpSV2hYWWxSQ05GUlZaRXBsUm1SWldrVTFXRkpzY0ZoWFZ6RXdaREZzVjJKR2FHdFNNRnBZVlcweE0wMXNWblJOVkVKb1lYcEdXRmt3YUhkWFIwVjVWVzVhVjFKNlJreGFSV1JIVWpKT1IxcEhiRmRTVmxsNlZtMHhkMU14VVhsVmEyUllZbXR3YUZWdE1XOWpSbXhWVW01a1YxWnRVbGxhVlZwclYyeGFjMk5HYUZkaVZGWlVXVlJHVDFOR1ZuVlViRnBwVjBkb05sWkhlR0ZWTVZsNVVtdGFVRlp0VW05YVYzUmhUbFprVlZGdFJtcE5WMUo2VmpKNGEyRnNUa2RqUm1oVlZsWndNMWRXV25kWFIxWkhXa2QwVTAxR2NFbFdha2w0VGtkR1JrMVdiRkpoYkZwWVdXdGtVMDB4Vm5GVGExcHNVbTVDU0ZsVldrOWhSVEZ6VTI1YVYxWXpRa3hVYTFwclZqRmFkVlZ0ZEZSU01VcGFWMWQwWVdReVZsZFhXR3hPVmxkU2IxWnNVa2RXTVZwMFkwWk9WMkY2Um5oV2JYaERWakpHY21ORmVGWk5SMUpJVlcxek5WWXhjRWhoUlRWWFltdEtUMVp0TUhkbFJUVklWRmhzVldKck5XaFZNRnBoWVVaV2RFMVdUbXBTYkZvd1ZHeFdTMkV3TVZoVmJteFhZbFJCTVZac1ZYaFhSbFp5WVVaYVRtRnNXbEZYVm1RMFZERk9WMUp1VG1GU2JGcFlXbGQ0WVUxc1dsaGtSMFpZWWxaYVYxUldXbXRaVmtsNlVXNUNWMkpHU2xoVk1GcHJZekZhZEZKc2NGZE5SbkJLVmxkNGIySXlSbk5UYmtwWVlrZG9ZVlpxVGxOaFJtdDVaVWRHVTFacmNIbFpNR1EwVlRKS2NsTnJkRmRpUjA0MFdYcEdWbVF3TVZsVmJXaFRZVEJ3V1ZaWE1UUlpWbVJIWTBWV1UySllVbkZVVm1SVFRWWldkR1ZGT1doV2JIQllXVEJvWVZZeFNuTlhiRkpXWVd0YVVGVnFSbXRqYkhCSVlVWlNVMVpHV2xsV2ExcHJUVVpaZDA1V1pGaGlSMmh6Vlc1d2MxZEdVbFpWYTJSVVZteHdXVnBWV2s5V01ERkZVbXhvV2sxSGFETlhWbHBMVjBaV2MxVnNXazVXYmtGNlZsUkNhMVF4VGtoVGEyUlZZbGRvVDFSVlZuZGhSbHAwWTBWa1dsWnNiRFJXTVdodlZteGtTR0ZHYUZkTlIxRXdWbXhhYzFaV1RuTlViWEJYWWtadmQxWkdXbE5WTVZsNVUydGthbEpGU2xaV2JYaFdaVVphU0dWSFJtcE5helZHVlZkNGQySkhSalpXYWtwWFlsaENRMXBWWkU5amF6VlhWMjFHVTJKWGFIWldSbHB2VVRKSmVGZHVTbUZTUmtwWldXeGFZVmRHYkhGVWJtUm9Za1Z3TUZaWE5VTldNREZIVjJ0NFZrMVdjR0ZhVlZwclpFWktjMVZyTldsU1dFSktWbTEwYWsxV1NYaGFSV2hVWVRGd2NWVXdWa3RXTVd4elZXeGtVMUp1UWtsYVZXUXdWakF4VjFkdWJGaGhNbEYzVmtjeFJtVkhUa1ppUm1ST1lteEtNbFpZY0VkWlYxSkhVMnhzWVZJelFsVlZiRkpYVjBaa1dHVkdUbE5OVm5CSVZqRm9hMWRIU2tsUmJrNVhZa1pLV0ZZd1dtRlRSVEZZVDFaYVRtRXhXVEpXVm1SM1ZqRlplRk5ZY0doU2JWSldXV3RhZDJOc2NFWlhhemxxWWxWYVNGWXlNWE5oVms1R1UyMUdWMkpVUWpSVWEyUlNaVlpLY2xwSGNGTldia0paVm1wQ2EySXhXbGRYYmtaU1lsVmFWRlJXV2tkT1JsbDVZM3BXVjFZd2NFaFpNRnB2VjJ4YVJrNVlTbGRoYTNCTVZqRmtSMU5IUmtkalIyaG9UVEJLVFZZeWVHRlpWazE1Vld4a1ZtSnJOVmRaYkdRMFkwWldjMkZGVGxoV2JHdzBWMnRTUTJGRk1VVldhMmhhWVRGd2NsbFdXa3RqTVdSelZXeHdhRTFZUVhwWFdIQkhWakpTUmsxV1ZsSmhlbXhZV1cxMFMxZEdXWGxrUm1Sb1RXdGFSMVJXV21GaFZrcEhVMnhvVlZaNlZsUlpNbmhyVmpGa2NtUkdaRTVXYmtKaFYxWldZV0V4V1hoVGJHeFNZWHBHV0ZacVRrTlVSbFY1VFZaa2FrMXJOVWRYYTJSdlZUQXhkV0ZHVmxoV00xSjJWVlJLVTJNeFpIVlZiWFJUWVhwV1ZWWkdXbXRPUm1SWFYydG9UMVpZVWxaWmExcDNUVVphV0UxWE9WZGlWVnA1Vkd4V1UxWXlSWGhqUjJoYVRWWndVRnBGVlRWV01rWkhXa2RzVkZKVmNFdFdiWEJIWWpKUmVGTlliRk5pUm5CUFZteGFZVlV4YkZobFJYUllVbXhLV1Zrd1dtdFdSa3B6WTBac1lWWlhVWGRXYTFwS1pERmtjbUZHY0doTldFSnZWMVphWVdFeFRraFNhMmhRVm0xU2NGWnJWbFprTVZwMFkwVmthRTFWTlVoV01qVkxZVlpKZDFkc1VscGlSbkJNVmxWYVlXUkhWa2hQVmtwT1ZqRktTVlpxU1RGVk1WSnpXa1ZvVm1KSFVsWldiWGgzWld4U2NsZHNjR3hTTUZwS1YydGFZV0ZXV2xkWFZFWllWbXhhY2xWcVJscGxWa3BaWVVab2FHRjZWbGxXYlhoaFpESldjMVZ1VW14U1ZHeHhXVmh3YzFkR1draE5XRTVYVFZad01WVlhkREJXTURGWVZWaGtXRlpzY0ZOYVZscExZekZ3UjFWdGJGTk5NbWhWVmpGa01GbFhVWGhhUldScFUwVTFiMVZzVlRGV1JsWjBaVWhrYkZKc1dqQlpNM0JIWVVVeFJWSnJXbFppV0dnelZtcEdTbVZ0UmtsWGJIQlhZbFpLU1ZaSE1UUlpWMUpHVDFaa1lWSnRVazlVVmxaM1pHeGFjMkZJWkZOTmExWTBWVEZvYzFaSFJYbFZia0pXWVdzMVJGWnJXbUZqVmtweVpFWm9hVkp1UWxwV1JscFRWVEpHY2sxVlZsZGhNbWhoV1ZSR2QyRkdXWGxOVm1ScVRWZFNlbGxyV21GaFZtUkhVMnBhVjFKc1NraFpNakZTWlZaS2NtSkhSbE5pVmtwMlYyeGtNRmxWTlVkWGJsSk9Wa1pLVTFSV1duTk9WbFY1WlVoT1YxWXdXbnBWTW5oclZsWmFWMk5FVGxkTlJuQjZWRzE0UzJNeGNFaGpSVFZZVWxWd1NsWnRkR3RPUmxGNFYxaHNWR0pyY0ZWWmJGWmhWMFpzV0dSSVdtdE5WbkI0VlRKMFlXSkdTblJWYkhCYVZsWndWRmxXWkV0U2JVNUhZVVpvVjJKRmNFMVdiRkpMVWpGSmVGZHVWbFZpUm5Cd1ZXcEdTMWRzV2xoTlZGSlVUVlp3ZWxac2FITlViRXBIVjJ4c1ZtSllhRE5hVjNoeVpESkdTRTlXWkdsV1dFSlhWbFphVTFJeFpITlhhMXBUWVd4S1dGbFhkSGRVUmxaelYyeGthazFZUWtkVWJGcHJWRzFLV0ZwRVZsZGlWRVl6VlZSS1JtVkdVbGxoUmxKWVVqSm9iMVpVUWxaTlZsbDRZa2hLYUZKVk5YQlVWbHBMVjFad1ZsWnFRbGROVm5CNldXdFNVMVl3TVhGU2EyaFhZbGhPTkZacVNrOVRWMDVIWVVkb1RtSlhhRTVXTVZwVFVqRk5lVlJ1U2s5V2JWSlhXV3RvUTJJeFVsaE5WemxUVm14d1NWcEZaRWRYYkZwMFZXdGtWVlpzY0ZoV2JURkxWMVpXY2s5V2NGZFNWRlpGVmxSS05GbFdXbGRVYmtaU1lraENXRmxzV2t0VGJGcFZVMVJHVmsxcmNFaFZNalZUWVVaS2RHRkhSbGRoYXpWUFdsVmFkMU5IVmtsVGJYaFhUVlp3UzFaclpEUmhNa1pYVkd0YVZHRXlhRmhaVjNSelRrWlNjbHBGWkZkTlZUVjZWMnRrZDFVeFNuTmpSbXhYVm5wRk1GcEVTa2RTTWtwSFZteFNhRTFzU2xsV1JscHZVVEZKZUdKR1dtRlNlbXhYVkZkNFlVMUdjRlpYYms1WFRWVndlbGt3Wkc5WlZrcEdZMFpDV21WclduSlpNakZIVW1zMVYxcEhiRmRoTTBKWFZtMTBZVmxXV25KTlZscE9WbTFTV1ZsdGVFdGpNVlowVFZaT2FVMVdjREJhVldoclYwWktkR1JFVGxkTmJtaHlWbXBCZUdOdFRrZGpSbVJYWld0YU1sWnFRbUZaVjAxNVZHdG9hRkp0VW05WlZFWjNaVlprVlZOcVVtdE5WV3cxVlcxMGIyRldTbkpPVlRsWFlrZG9RMVJXV21Ga1IxSklVbXh3VjJKWWFGbFdhMXB2WXpGWmVWTnVTazlXYlhoWVZGVmtVMlJzYkhGU2JHUnJWakExU2xaSE1YTlViRnB6WWpOa1dGWkZOVE5WYWtaaFVqRmtkVlJ0Y0ZOaVdHaHZWbTE0WVdReFZrZFhia1pUWWxWYWNWUlhjekZUYkd0M1YyNWtWV0pGY0hwWk1GSkxWakpLV1dGSVNsWmxhMXBMV2xaYVUyTnRSa2hoUms1cFZtdHdVVlpzWkhkU01VMTRXa1prV0dKR1dsTlpiR2hUVmpGU1YxWnVUazlTYlhRelZtMHdOV0ZHV25KalJFSlhWak5vZWxadE1VdFNNV1IxWWtkR1YxWnVRbTlYYTFaclZURk9TRlZyV2xCV2F6VndWakJrYjFsV1duUmtSMFpwVFd0c05GbHJXbXRXVjBWNVZXeFdXbUV4Y0doWFZscGhZMnhhZFZwSGRHbFNia0kwVmxjd2VGSXlSblJUYTJScVUwZDRhRlZzV25ka2JGcFZVMnQwVTJKVk5VaFphMXByWVVkRmVXUkVVbGhXYkVwSVdWUkdTbVZHVW5WV2JGcHBWMFpLZWxkV1VrOVJNV1JIV2tab2JGSjZiSEJVVjNNeFpXeHNjbGR0T1ZWaVJuQmFWbGQ0VjFadFNsbGhSMmhWVm14d2Vsa3llR3RqTVhCSVlVWmthRTB3UmpSV2JGcHJUa1pKZUZwRlpGaGlhelZ4VldwS2IxZEdWbkpXYlVaVlVtMTNNbFZ0Y3pWaE1WcHlZMGh3VjJKVVJucFdWRUY0Vm0xT1JWTnNaR2hOV0VKdlYxZHdSMUp0VmxkVWJHeG9VbTFvY0ZsWWNGZFhSbVJYVld0MFZrMVdjRWhaYTJoUFYwZEtWbGRzVmxaaVZFVjNWRlJHWVdSRk5WWlBWbVJPVm0xM2VsZFVRbGRqTVdSelYyeG9hRkpXU2xoVVZ6VnZZMnhWZUZkclpHcE5hMXBJVjJ0Vk1WWXlTbkpUYWxaWFlsUkdNMVZxU2xKbFJrNXpXa1prYVdGNlZsaFhWbWgzVmpGa1IxVnNaRmRpYlZKVldXdGFkMDFHY0ZaYVJFSlZUVlZzTTFadGNGTlhiVVY0WTBoS1YyRXlVa2haZWtwUFUxWkdjMWRyTlZOaVJ6azJWbXBHWVZsWFRYaFhiR1JWWW1zMVZsbHJaRk5XUm14eVdrUk9iR0pHY0hoVk1uQlRZVEF4Y21ORmFGZE5WMmh5VmtSR1MxSnRUa2RoUm5CcFVqSm9NbGRXVm1GWlZrNUlWbXRhYTFKck5YQlZha1pMVG14a1ZWRnRSbWhOYTFwWVZURm9iMVpHWkVsUmJHaFhZbGhvVEZVd1duTldWazV5VGxkNFUySnJTa3RXYTJONFVqRlZkMDFJWkZSaVJscFlWVzB4VDA1R2JIRlRhMlJUVFZkU01WWlhjekZXTVVweVkwaHNWMUp0VVhkWFZscFBVakZrZFZWck9WZGhlbFozVmxjeE1HTXdOWE5YYkdoUFZsZFNXRlJYZEhkWGJGcEhZVWM1V2xac2JEWlpWV2hMVjJzeGRXRkVUbFpOVm5CVVdYcEtSMUl4VW5SaFJUVk9VbGQwTkZadGNFZFZNVVY1VTFob2FWSnRVbGxXTUdSVFZERmFkRTFYT1dsTlZscDVWbXhTUjFZd01WbFJiR3hoVWxkU1NGWnRjM2hYVmtaellVWmtUbUp0YUZGV2FrSmhWMjFSZVZScldtaFNiVkp3Vm10V1lVMXNXbkphUkZKb1RWVndlbFpITlU5aGJFcDBWV3M1VjJGcldraFVWRVphWlVaa2RGSnRjRTVXTVVwSlZtdGtOR015UmtkVFdIQlNZa1pLWVZsclpGTmtiSEJZWlVkR1dGSXdOVWRXUjNoM1ZqSktWMU5zYkZkaGEydDRWbFJHVTJNeFpIVlRhemxYWWxob1dWZFhlRk5XTVVwSFZtNUdVMkpZVWxsV2FrRXhVMFprY2xkdGRHaFdiSEJZV1ZST2MxWXhXalpTVkVKYVZrVmFhRll3V2s5amJVWklZVVpPVTFaR1dscFdhMXBYWVRGVmVGTllhR3BTYlZKb1ZXeGtVMVpHVWxkV2JVWnNZa2RTZVZkcll6VmhSa3BWVVdwT1ZrMXVUWGhXYWtwTFZsWkdjVlZzVm1oTmJFcElWMnhhWVZZeVRuTmFTRTVTWWtkU2NGWnRkSGRYYkZsNFdrUkNhRTFXVmpWV1IzUnJWakZrU0ZWc2FGcFdSVFZVVm0xNGMyTnNaSFZVYXpsWFltdEtXRll5ZEZOUk1WcFdUVlphYWxOSVFtRlVWVnBMVWtaYWNWTnJkRmhXTUZwSldWVmFhMVV4U2xkalJ6bFlWMGhDVEZaRVJrcGxSazUxVkcxR1UwMXRhSFpXUmxKRFUyMVdWMWR1VW1wU1ZUVmhWbXBCZUU1R1dYbGxSM1JYWWxWd2VWa3dXbUZYYlVWNFkwVjRWMkV4Y0hwWk1qRkhVbXhTYzFWdGJGTk5WVzh5Vm0wd2QyVkZNVWRXV0dST1ZtMW9WMWx0TlVOWFJsSllZMFprVmxKdGVGaFdNblF3VlRBeFdGVnVjRmhoTVhCWVZtcEtWMk14WkhGVGJHUm9ZVEJ3YjFZeFdtRlpWbGw0Vlc1V1ZHSllVbFJVVkVKTFZVWmtWMkZJWkZkTlZUVllWMnRhYTFZeVNsWlhiVVpYWVd0S2FGWXdXbFpsVlRWWFdrWmFhVkl4U2t0V1ZtUTBZakZhVjFkdVRtcFNSVFZoVm14YWQwMHhWbk5YYTNScVlsWktTRmRyVlRGV01WcEhWbXBTVjJKVVFqTmFWVnBLWlVaYVdXSkdUbWhpU0VKWlYxY3dlRlV4WkVkaVNFNVdZVEZ3Y2xSV2FFTlNiRlowWTNwV2FHRjZSbHBWVjNSM1Ztc3hkV0ZJU2xwV2JIQm9WbXBLVDFOV1pITmFSazVwVm10WmVsWnFSbUZaVms1MFZtdGtWMkpyTldoVmJURnZZMFpzV1dOR1pGaFNiVkpaV2tWa1IyRXdNVlppUkZKYVZrVTFjbFl3WkV0V1YwcEhZVVprYVZkSFozcFhiR1EwWTIxUmVGWnVTbEJXYlZKUFZXdFdZVk5XWkZWUmJUbFVUVlpzTlZWdE5VdFhSMHB5WTBkR1lWWXpVak5XVlZwV1pERndSMXBHVGs1V2EyOTNWMWQwWVdFeVJrWk5TR1JVWW14d1dGbHNhRU5UUm14VlVWaG9VMDFyY0VoWlZWcFBWMFpKZW1GR1ZsaFdNMUp5V1dwR1lWSXlTa2RoUjNoVVVqRktXbFpYTUhoT1IxWlhZa1phVjJGNmJGbFZiWGgzWld4cmQxVnJUbGRXYkhCNldUQldORmRzV2taU2FsSlhUVlp3U0ZreWVHdGpNV1IwWWtaa1UxWnNiRFpXYlRCNFpERkdkRlpyYUZWaWJFcFdXVlJHZDJOV1ZuUmxTR1JWVFZkNFdWcEZaRWRXUmxwelkwaHdWMVl6VVhkV1ZFcExWakZrZFdOR1dtbFdSbHBSVm14amVGTXhUa2RXYms1b1VqQmFXRlJVUmt0VVJscEhWbTFHV2xZd01UUldiVFZMV1ZaSmVXRkZPVmRpUjFGNlZGVmFhMVpXUm5OYVIzQk9WbTVDU2xaVVNqQmlNVnAwVTJ0b2FGSnRVbUZaYTJSdlpHeFNWVkpzY0d4U2JWSXdWVzE0VDFSc1duVlJhbHBYWVRKUk1GWkVSbE5qTVdSMVZXMTBiR0V3Y0ZwV2JURTBVekZXUjJKR1ZsUmhNbEpVVkZaYVMyVldiRlpYYlVab1ZtdHNObGxWWkc5WFJsbDZWVzFvV0Zac2NISlZha1pYWkZaU2MyRkhiRmRXYmtKaFZteGtORlV4V1hoYVJtUlhZbXhLYzFWcVRsTldiR3h5VjI1a1RsWnNXbGxhUldNMVYwWktjMk5GWkZaTmJtaDJWbXhrUm1WSFRraGhSMFpUVm01Q1VWZFljRWRaVjAxNFZXNVNhVkpyTlZoV01GWkxWMnhhY1ZKdFJtaE5SRVpJV1d0YWIxVXlSWGxWYmtKV1lURndNMVpyV25Oa1JURlhWR3hrVTJKRmNGbFdha293VFVaU2MxTnVVbXhUUjNoWVZGYzFUazFXYkZaWGJIQnJUVlp3ZUZaSGVIZGhSMFkyVm1wYVYySllRa3hWZWtaclZqRktkVk50ZUZOaVJuQlpWbTB3TVZFeFpFZGFTRTVYWWxWYVZsUldaRk5YVmxaMFpFZDBXRkl3Y0VsWlZWcFRWbFphTmxKdVdsZGhhMXBvV2tWa1QxSnNVblJoUlRWb1RXNWplRlpzWTNoTlIwVjRWMWhvWVZKWGFGZFphMlEwV1Zac2NsZHRSbWhTYkd3elZqSTFUMkZ0U2tsUmExcFhWbnBGTUZacVNrdFhWMFpIWVVaa2FWWkZXVEpXUjNoaFYyMVdSMXBJVGxkaVJUVndWV3BLYjFkR1drZFpla1pwVFd4YWVsWXlOVTlYUjBwV1YyNUtWbUpZYUV4V2JYaFhaRWRXU0dSSGFGTk5SbGt3VjFSQ2FrNVdaRWRhUld4U1lUTm9XRlZyVm1GVVJuQkdWMnQwYW1KSVFrbFZiWGhQVmpGS2MyTkVTbGROVm5CVVZXcEtVbVZHVW5WVWJHaFlVakpvV2xkWGVHOVZNazE0WWtoT1dHSlZXbFZWYlhoWFRsWndWbHBFUWxkaGVrWjVXVEJvYzFZd01YVmhTRXBYVFdwR1IxcFdXbGRqTVZaeldrVTFVMkpyU2xaV2JURTBXVlpSZVZWcldsQldiV2h3Vld4U1YxZEdVbGRXYm1SWVlrWndNRlJWYUd0aVJrcHlZa1JTVjAxdWFHaFdSM2hoWXpKT1NWSnNXazVTTVVWM1ZtMHhOR015VG5OYVNGWmhVak5TY0ZWdE5VTlhSbHB4VTFob1UwMXJXbmxVVm1oTFZERmFXVkZzWkZkaGF6VjJXVEo0WVZOSFZrWmtSM1JYWVRGd05WZHNWbUZpTWtaWFUyNVdVbUpVYkZoVVZscDNZVVpWZVUxV1pGUlNiRXA1VmpKNGEyRldTblZSYm1SWFlXdEtXRlY2UmxkU01YQkhXa2RvVkZJeFNsbFdSbFpUVmpKV2MxZFlhR2hUUlRWdlZGWldkazFzYkhKWGJYUlhWbXh3ZWxrd1pHOVdhekZIWTBkR1lWWnNWWGhXYWtaVFpFZEdSMVJ0YUd4aVJuQktWbTE0VTFNd05VaFRXR2hoVTBaS1ZGWXdaRFJXTVd4MFpVaGtWMDFYZUZaVmJUVnJWakF4V1ZGc2FGaGhNWEJ5Vm10YVNtVkdUbkpoUm1ob1RWWldORlp0Y0V0VE1rNXpWR3hXVkdKSFVtOVpWRWsxVFRGWmVGZHRSbXBOVm13MFZtMDFWMVpYU2toaFNFSmFZVEZ3TTFacldtdFdNWEJGVld4d1YySldTa2xXYlRBeFZUSktSMVJyYUZaaVIzaFhXV3hTUmsxR1duUmxSbHBzVmpGS1NWcEZaRzloUjFaeVYyeHNWMVpGYTNoWmVrWnJaRVpLV1dGSGNGTlhSMmhvVm0weE5HUXhUWGhqUm1SaFVsZFNWVlZxUW1GVFJteFdWMjEwYUZacmNGcFZWM1IzVmpBeGRWVnNVbFpXZWtaVFdsWmFZV05zY0VoU2JGSlRWa1phWVZZeFpEQmhNa2w1Vkd0a2FWSnNXbFpaVkVFeFl6RnNjbGR1WkU1U2JYUXpWbTEwTUZaWFNrWmpSbHBXWWxSV00xWnFTa3RXVmxwelZXeHdhRTFZUWsxV1J6QjRVekZKZUdORlpGZGlSMUpZV1ZST1ExTnNXblJqUlU1YVZqQTFNRlpXYUc5WFIwcHpWMnhhV21FeVVsUldSRVp6VmxaS2MyTkZOVmRpU0VJMlZqSjBiMkV4WkhOWGJrNXFVbTFvV0ZSWGNGZFZSbXhZWlVWMGExSnNXakJaVlZwcllWWktkVkZZY0ZkaVJscG9Xa1JHU21WR2NFbFViRlpwVjBaS1ZWWkdWbE5XTVU1WFYyNUtZVkpHU25CVVZscFhUa1paZVdWSVRsWmlWWEJYVmpKNGIxZHNXWHBWYldoYVRXNW9WRmt5ZUhkU2JVNUlaVVpPYUUwd1NtaFdNVnBYV1Zac1dGSnJXazVYUlRWVldXdGtiMWRXV25GVWJFNW9VbTVDUmxVeWRHdFZNREZYWTBSR1YxSXphSFpaVm1STFZqRk9kV0ZHWkZOaVNFSnZWMnRTUW1WR1NYbFNXSEJxVWpOQ1ZGWnFSa3RYYkZwWVkwVk9hMDFWTlZoWk1GcGhWMGRLV1ZWc2FGVldWa3BJV2xWYVYyTXlSa2hrUm1ST1VrVmFTVmRVUWxkT1JtUnlUVmhHVTJFemFGZFphMXAzWTJ4c05sTnJPVk5OV0VKSVYydGtjMkZGTVVsUmJXaFhZbFJDTkZwRVJrWmxSMHBIV2tkc1UySlhhRmhYVmxKTFZURmtSMkpJU2xoaVZWcFhWRlprTkdWc1duUk5WV1JYVFZWd2VsWXlOWGRXTURGeFZtNUtXbUV4Y0doWmVrcFBVakpLUjJORk5WTmlSM2Q2Vm0weE1GWnRWa2RYYmtwUFZtMVNiMVZ0TVZOV1JuQllaVWRHVjFac2NIcFdWM1F3VmtVeFZtTkliRlZpUm5CeVZtMHhTMU5XUm5OaFJscHBVbXR3V1ZaWGVHRlhiVlpIV2toU1UySklRbGhVVlZKR1RVWmtWMVZyT1d0TmExcElWVEo0VjJGV1NuTlRiRnBYWWxob2FGZFdXbE5XTVdSMFVtMTBVMVpGV2xkV1ZtTjRZakZTYzFkWWFGUmhNMEpZVm1wT2IyUnNiRFpUYTJSVFRWWktlVll5TVhkVk1rcFhVMjFvV0Zac1NraGFSRVpUVWpKT1IyRkhlRk5pYTBwNVZrWmFhMVV3TVZkWGEyaE9WMGRTYjFadGRIZE5WbFpYWVVjNVYwMUVSakZXVjNoclZsWmFjMk5HWkdGV2JIQlFXa1phVDJNeFZuUmlSazVPWWxkb2FGWnRNSGRsUlRWSFlrWm9WV0pIVWxkWmJYTXhWMVpzY21GRlRtcE5WbkF3V1ROd1IySkhTa2RpUkZaVlZtMW9jbFp0YzNoamJVNUpZa1phVG1KdGFEWldiWEJIV1ZVMWMxTnNWbEppUm5CeldWUkdkMVZXV2xoalJXUm9UV3hLV0ZVeU5VOVdWMHBZWlVab1YySlVWa1JXYlhoYVpVWndSVkZzWkU1aVJWa3hWbTB4TUdFeFpFaFRhMmhvVTBVMVYxbFhjekZXUmxwMFpVaE9hbUpHY0RGWGExVXhWakpLUjJOR2NGaGlSbHAyVmtSR2ExSXhUblZWYkZwb1RUQktXRlp0Y0U5VmF6RkhWMjVHVTJFelVsUlphMlJUWlZad1JscEZaRmROYTNCS1ZWZDRWMWRHV2taaWVrSmhVa1ZhVUZWcVJrOWtWbEp6Vm0xc1YwMHlhRnBXTVZwVFZERkZlRlp1VGxoaWJFcFBWVEJrYjFWR1ZuRlJiazVQVW14YWVsbFZZelZXTVZwMFZXdHNXbFpXY0hwV01qRkxWMWRHUm1WR1pGTlNWbkJ2VjFSS05HRXlUblJWYTJSaFVsUldXRmxVVGtOWGJGcDBUVWhrVGxac1JqUldWbWh2VmtkS2NrNVlSbFppUjFKMlYxWmFZV014Y0VaT1ZUVlhZa2QzZWxacVNqQmtNa1YzVFZoS1QxWllRbUZVVlZwM1lVWmFTRTFWZEd0U01GcEpWREZhYTJGSFJYbFBTR1JYVFZad2FGVjZTbE5TTVZaMVUyMUdVMkpJUW5kV1ZFSlhVekZXUjFkc2FFNVNSVnBUVkZaa1UxZEdaSEpoUlhSWFRXdHdTRmt3YUU5V2JVcFpZVWh3VldFeGNHaFdNRlV4Vm1zNVYyTkdaR2hOTUVreFZtdGtOR0l4UlhoWFdHUk9WbGRvVjFsdGVHRldiRnAwWlVoa1dsWnVRbGRXTWpFd1lXc3hXVkZyYUZoaE1WVjRWbXBLUm1WSFJYcGhSbVJwVWpBME1GWkhkR0ZqTVZsNFZtNVdWV0pIYUhCWmExWjNWMFprV0UxVVFscFdiR3cwV1d0YVYxVXlTbFpYYkZwV1lsUkdWRll3V2xwbFYxWkdUMVprVG1FelFrcFdiR1IzVVRGYWRGTnNiR2hTYldoWVZtdFdkMVJHVlhoWGEyUnFZbFUxU0ZsVlpITlZNa3BKVVdwV1YySkhVak5WZWtaS1pWWldjbHBHVm1saGVsWmFWMWQ0YjFFeFdrZFhibEpQVmxVMVdWWnRNVk5YVm5CV1dYcFdhRlpVUm5sV01uUnZWakF4ZFZWdVdsZFNNMmhvVmpGYVYyUldTbk5XYkdScFVteFpNRll5ZUZkWlZtUjBWbXhvVjJFeWFISlZha3B2VjBac2MxZHJkRlJXYkhCV1ZURlNSMkZyTVZkaVJGSllZVEZhZWxaWE1VWmxWMFpIWVVaYWFFMVdjRzlXYkZaaFZqSk9WMU51U2xCV00xSllXVmh3Vm1ReFpGaGtSMFpWVFd0YVIxUlZhR3RXUjBaeVRsWm9XbUV5VWxSVVZFWlhZMVpLY2s1WGVGZGlSbTk0Vm10a05HSXlSa1pOV0U1VVlsUnNXRlpxVGxOaFJsWTJVbTFHVTAxcmNFcFdSM2h2WVVVeGMxTnNSbGRXZWtVd1dYcEJNVll4Vm5WVWJHUnBWMFpLV1ZkV2FIZFNNbFpYWVROa1dHSllVbGhVVlZKSFpVWldkR1JIT1ZkTmExcDVXVEJXTkZZd01WZGpSbWhoVW0xU1VGVnFSbUZrUjBaR1RsWm9VMVpYZERSV2JYQkxUVVpWZUZOWWFHbFNiV2hXVmpCa2IyTldWbk5hUms1WVZtMTRlbGRyVWxOWFJrcHpZa1JPVjJKWVVYZFpWVnBMWXpKT1JWRnRSbGRXTVVZelYxZDBhMUl3TlhOWGJrNW9VbTFvYjFSWE1XOVdWbHB6Vld0a2FFMVZOVWxWYlhSelZUSktSMk5IT1ZWV2JIQllWR3RhWVdOV1JuUlNiRnBPVm0xM01GWXlkRzlXTVd4WFUxaHNhRkpzU21GWmEyUnZWVEZTVmxkdFJtcFdhelY0VlZkek1WVXdNVWRYVkVKWFZrVnZNRlpxU2tkV01VNTFWVzE0VTAxR2NGZFdiWGhoWkRGWmVHTkdXbGhpYXpWWVdXdGFkMWRzWkhKYVJFSlZZa1p3VmxadGNGZFhSbHBHVTIxb1dsWkZjRWhXYWtaUFpGWk9kR05HVGxkU1ZuQmFWbXhrZDFReFZYbFNhMlJZVjBkNFQxWnRNVk5YUmxKWFZsUkdUbFpzY0VsVVZsWnJWbXN4Y21ORlpGcE5SMmh5VmpCYVdtVnNWbk5oUjBaVFVsaENWVmRZY0VkaE1rMTVVbXRhVDFadFVsUlpWRTVEVGxaYWNsZHRSbWhOVmxZMFZrZDBhMkZXVGtaalJteGFZa1pLZWxscVJuTmpNV1IwVW0xNFYySkhkekZYYkZacVRsWlplVk5zV21wU2JrSmhWbXhrYjAweFduTlhiVVpUWWtkU01GVnRNVWRXTWtwWFUyeHNWMVo2UmpaVWJGcHJVMFpLY21GSGJGTmlWa3BhVmxkNFYyUXhVa2RYYmxKT1ZrWktiMVJYZUVkT1JsVjRZVWM1V0ZJd2NIbFpNRlUxVmpBeFIxZHRhRmRoTVhCaFdrUkdkMUl4VW5OaFJrNXBVbTVCTUZadGRHcGtNRFZZVW01U1ZHRXlVbGxaVjNSTFlVWmFjMWRzV2s1V2JYaFpWRlpXTUZZeVJqWldiR1JhVmxad2RsbFZWWGhYVmtaelVteGthVkpyY0VsV01WcHJWVEZaZUZOdVZsZGlSMmh3VldwR1MxVkdXblJOUkVaU1RWWndXRll5ZUc5aGJFcFlWV3hvV21KR2NHaFdNRnBoVjBkV1NWUnRhRk5oTW5kNlZtcEtORll4V25SVGJHeG9Va1UxV0ZSV1duZGpiRmwzV2taT1UwMVlRa2xhUlZVeFlVVXhkVmt6WkZkaVdHaHlWR3RrU21WR1ZuVlViR2hvWWtoQ2QxWlhNSGhPUm1SSFlraE9WbUV5VWxoVmJYaHpUVEZaZVUxVVFtaGlWWEJJVmpJMWMxWXhTalpTYmxwWFVucEdSMXBWWkVabGJVcEhXa1prYkdFeFdYcFdNV1IzVWpGa2RGVllaRTVXYlhoWVdXeGtiMVpHYkhOYVJ6bFlWbXh3TUZwRldtdGhNREZYVTJ0b1YySkhhSFpXTUdSR1pWWldkVk5zWkdsWFJURTBWMnhrTkZsWFVraFdhMmhyVW0xU1QxbFVSbHBOYkZwWFdrUkNhMDFXYkRWVk1uaFhWVEpHY2s1V1pGcFdNMUl6VldwR2QxWXhaSE5VYlhSWFlrVnZkMVpYTVRSVk1WVjVVbGh3VW1Gc1dsaFphMlJUVFRGV05sTnJjR3hTYlZKNVYydGFZV0ZXU25WUmJscFhWak5vVjFSV1dtRldNVnAxVldzMVYyRjZWbGxYVjNSaFdWWmtWMVZzWkZkaVdGSnZWV3BDV2sxc1ZuUmxTRTVYVFZac05sWlhOV0ZXTWtaeVVtcFNWMDFIVWtoVmJGcFRZekpPUjFwR1pHbGhNSEJUVm0xNGEyUXhUWGhWV0doVVYwZDRWRmxVU2xOWFZteHpXa1JTYWxKdGVGWlZWelZyVmtkS1IyTkVRbHBOUmxwUVZqSjRZV015U2tWV2JHUlRUVEpvZVZadGRHdFRNazE0Vkc1V1ZHSkdjRzlaV0hCWFZsWmFjVkZ0Um1wTmF6VjZWMnRvVjFkSFNsbFZhemxYWVd0YVRGWnFSbUZXTVd0NllVVTFVMkpGV1RCV1ZFWnZZVEZrU0ZOcmFHaFNiVkpXVm1wT1ExZEdXWGRYYlVaWVVsUkdWMXBGV2xOV01rVjRZMFJhV0Zac1dtaGFSRVphWlVaT2MxcEhiRTVOTUVwYVZtMHhORmxYUmtkaVJGcFVZWHBzV0ZSV1ZURk5WbFY1WlVjNWFGWnRVa2xaVlZwWFYwWlplbFZzYUdGU1JVVjRXWHBHYTFkWFNraGtSazVPVFZWd05GWnJXbUZaVjFGNFZHdGtWMWRIZUhOVk1GVXhWakZzYzFadVpGUmlSbHBaV2xWb1QxWXdNWEpqUmxwV1lsUldhRlpzV21GU2JHUjFZMFpXYVZkSGFGRlhWRWw0VkRGT1NGWnJaRlZpVjNoWVdWUktNMDFHV25SbFIzQnNVbFJXU0ZaR2FITlZNa3BJVld4V1YwMUhVblpXYkZwelkyeGFjbVJHYUZOaVJtOTNWMnhXYjJFeVJuUlRhMlJVWWtkU1dGbHJaRzlqYkd4eVYydDBhMUpzV25oVmJYaHJWakpXY2xkWWNGZGlSa3BNVldwQk1XTXhaSFZVYld4VFlsWktWVmRYZEdGa01WcFhWMnhvYWxKWVVsaFVWbHB6VGxaV2MyRklaRnBXYTNBd1dWVm9RMVl5U2tkalJFNVhUVlp3Y2xZd1pGZFNNWEJJWkVVMVYxWkdXa3BXYlRFMFlqSk5lVkpZYUZSaWEzQlFWbTB4YjFac1duTlhhM1JVVW14S1dGWXlOVTlXTWtwSlVXdHNWVTFXY0hKV2FrRjRVMVpHZEZKc2FGZGlSbkJaVmtkMFlXRXlVa2RYYmxaVVlrZG9jRlZ0ZEhkaU1WcFlaVWRHYTAxV1NraFphMUpoVlRKS1JrNVlSbFZXYkhCTVdsZDRhMk5zWkhSa1IyaFhZbFpLU1ZaWE1YZFpWbGw1VTJ4V1VtRnJOV2hWYTFaM1YwWlZkMWRzWkZoV01GcElWbGQ0YjFVd01IbGhSbXhYWWxoQ1JGbFVTa3BsUm1SMVZHMXNVMkpHY0ZaWFYzaFRZekZrUjFkdVVrNVdSa3BZV1d0YVYwNVdjRlpXVkZaWFRVUkdlVmt3Vm5OWlZscFlZVVJPVjAxSFVrZGFWVnBQWXpGV2MxcEZOVk5pYTBwT1ZqSjBWMkV4V1hoVFdHaGhVMFUxYUZWdGN6RlVNVkpYVm01a1ZtSkdjREJaTUZZd1ZERktkR1ZHYkZkU2JXaDZWbXhrUm1WWFZraFBWbHBwVjBkbmVsZFVRbUZaVjA1elYyNU9ZVkpVVms5V2JUVkRUbFpaZVdSR1RsWk5WbkJKVlRKNGExVXlSbk5UYkdoVlZqTkNXRlV3V21Ga1JURldaRVpTVTJKR2IzaFdWbVEwV1ZkR1NGSlljRkpoYTNCWVZXMHhVazFHV1hsTlZtUlRUVmhDU2xaWGVFOWhWa3B5WTBaQ1YySllRa2hWZWtaUFZqRmtkVlZyTlZOU1ZuQlpWa1phWVZsVk1VZFdXR3hyVWpOU2IxbHJWbmRXYkd4eVYyMTBXR0pWY0VsWlZXaGhWbFpaZW1GRVRsZE5SMUpZVlRCa1UxSXhjRVpPVm1ScFlUQlplbFp0ZUdwbFJUVklVbGhvVm1Kc1NsVlpWRVozWTFaV2RFNVZUbGhTYlhoV1ZUSjRTMkV3TVZoa2VrcFdZbFJHU0ZZd1drdGphelZaWWtad1YxWnVRbTlYVmxaclZqSlNTRlpyWkdsU2JXaFlWRlJLYjFaV1duUmpSV1JUWWxaYVNWWkhkR0ZXTWtwR1RsaENWMDFHY0V4YVZWcGhVakZrZEZKdGRFNVNSVnBKVjFSQ1YxbFdaRWhTYWxwcFVteHdZVmxyV21GWFJsSjBaVVprV0ZJeFNrcFdSM2hyVkcxRmVHTkVWbGhXYkVwUVdXcEdXbVZHWkhKWGJHaHBWakpvYjFaWGVHRmtNVlpIWTBWa1dHSkhVbkpWYWtaaFUwWmFTRTFZVGxkTlJFWXdXVlZrUjFZeVJuSlhiV2hhVmtWd1dGa3ljM2hXTWtaSFYyMXNhR1ZzV21GV01XUXdXVmRSZUZwR1pHbFRSVFZZV1d4V1lXTldiSEpYYlVac1VteGFXRmxWWXpWV1ZURnlZMFZzWVZaV2NISldha0Y0WTFaS1dWcEdaR2xTTVVwTlZtMHhOR0V4V2xkVWJrNWhVako0V1ZWdGRIZE9WbHAwVFZoa1UwMVhlRmxXVjNSclZqSktSMWRzVGxwaE1taEVWakJhVjJNeFpIVmFSMmhUWWxaS05WWnNaREJUTWtwSFUyNUtUMVp0YUdGVVZWcGhZMnhhZEUxVmRGaFNNRnBIVkRGYWQyRldXa1pYYWtwWFlXdHZNRll5TVZkU01YQkpWVzEwVTFaR1dsVldSbFpUVW0xV2MxZHJhR3hTYlZKdlZGWmFjMDVXVlhsT1ZYUllVakJ3U0ZZeU1VZFdNREZJWVVWU1lWWXphSGxhVlZwclpGWlNjMkZHWkU1U1JscEtWbXBLTUZsWFNYaFdXR3hVWWtkNGIxVnJXbUZYUm14WVpFaGFUbEpzY0VaVk1uUnJWVEF4V0ZWcVJsWk5ha1o2VmxSR1MyTnRUa2RoUm1SVFlsVXhORmRYY0V0V01rMTRXa2hXVTJKR1NtOVVWRVpMVjFaYWRFMVVRbHBXYlZKNldXdGFZVmRIU2xaWGJHaFZWbXhhTTFZeWVGZFhSMUpGVld4b1UwMUlRa2xXYWtsNFlqRmtjMWRyV21wU2JFcFlXVmQwWVdGR2NFZFhhemxxWVhwc1dGZHJaSE5XTURGMFlVWm9WMkpZYUhKVWExcGFaVlpXV1dGR1pHbFNNVXBhVjFjeE5GTXhVWGhXV0dSaFVtczFjVlJXV21GTlJuQldWMjEwVlUxVmNEQldWelZ6VmpKS1ZWSllaRmROUm5CTVdrVmFWMk50U2toU2JHUlhZbXRLUmxadE1YZFRNVTE0VTFob1ZXSnNXbkZWYlRGVFZERmFkRTVWVGxoV2JWSldWVzB4UjFVd01YTlRiR2hhVFVaYWNsWnNaRWRPYkZwellVWndWMUpVVmtSV1JtUTBWMjFXUjFwSVRtRlNiVkpQVm0xMFdrMUdXbkZTYlRscVRWWndTVlV5ZEd0aGJFNUdWMnhrV21FeVVsUmFSM2hyVmpGa2MxUnNaR2xUUlVwS1ZrUkdWazFXVW5OWGJsWlNZV3h3V0ZSWE5WTlhSbEpXVjIxMFUwMVhVbHBYYTFwdllVVXhkV0ZIYUZkaVdHaG9Xa1JCZDJWSFNrbFRiVVpUVm01Q2VsWlhjRUpOVms1SFlraEtXR0pVYkZoVVZsWjNWMnhXVjFWcmRGZE5WV3cyV1ZWa2IxZHNXa1pYYkVKV1lXdGFVRnBHV2s5ak1rWklZVWQ0YVZkSGFHRldiWFJoWVdzeFdGTllhRmhpUjFKWldXMTBZVlV4YkhKYVJrNVhVbTE0ZWxZeU1VZFhSa3B6WWtSV1ZXSkdjRkJaVmxwTFkyMUtSVlJzWkU1aGEwVjRWbTE0WVZsV1dYaFViazVvVW14d1QxVnROVU5pTVZwWVkwVjBVMDFWTlZoV1Z6VlBWMGRHTmxadE9WVldSVXBNVlhwR1dtVkdaSE5hUm5CWFRVZDNNRll5ZEc5Vk1WcElVMnRvYkZKdFVtRlphMlJUWkd4WmQxZHRSbXBpUm5Bd1ZXMHhOR0ZXU25WUmFscFhZV3R2TUZaRVNrWmxSazV6Vm0xc1UySlhhRmxXVjNCUFlqSk9jMkpHWkZoaVZWcHhXV3hXZDFKc1dsaGxSM1JWWWtac05GVXhhSGRXTWtWNFUydDRWbUpVUmxoVmFrWnJaRlpPZEZKc1RtbFdNbWd6Vm14amQwMVdSWGhXYkdSWVltdGFVMWxzVm1GWlZscDBaVWhPVDFKc2NEQlViRnBQWVZaS2NtTkdiRmRXTTAweFZteGFZV015VGtkaFJsWnBWMGRvZVZkVVNYaFNNVTVIVTI1T1dHSkhVbkJWYlRWRFdWWmFjbFZyVGxaTmF6RTBWVEowYTJGc1NrZGpSVGxXWVRKUk1GVnNXbXRrVjBsNldrWkNWMVpVVmpGV1ZWcFNaREZPTTJKNk1Fc0sK Mirando los caracteres que hay y el nombre del reto, podemos deducir que se trata del resultado de codificar un cierto texto en Base64 muchas veces.
Como es posible que haya muchas codificaciones, podemos utilizar un bucle en Bash hasta que encontremos la flag en texto claro:
$ f=$(cat flag.txt); while true; do if [[ $f = CTFlearn* ]]; then echo $f; break; fi; f=$(echo $f | base64 -d); done CTFlearn{pr3tty_b4s1c_r1ght?</description></item><item><title>Space pirate: Entrypoint</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-entrypoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-entrypoint/</guid><description>Se nos proporciona un binario de 64 bits llamado sp_entrypoint:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./glibc/' Podemos ejecutarlo para ver lo que hay, dos opciones:
$ ./sp_entrypoint Authentication System ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░▒▓▓▓░░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓▒░▓▓▓▓▓ ░ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓▒░░▓▓▓░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒░▓▓░░░▓▓▓░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒▒▒▒▓▓░░░▓▓▒░░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒▒░░░▓▓░░░▓▓▒░ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▒░░░▒▓▓░░░▓▓▒ ░▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░░░░░▓▓░░░▓▓▓ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░▓▓▓▒░░░░▓▓▒ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓░▒░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓░▒▓▓▓░░░░░▓▓░ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▒░▓▓▓░░░░ ▓▓ ▓▓▒ ▓▓▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 1.</description></item><item><title>Space pirate: Going Deeper</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-going-deeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/space-pirate-going-deeper/</guid><description>Se nos proporciona un binario de 64 bits llamado sp_going_deeper:
Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./glibc/' Si lo ejecutamos, tenemos tres opciones:
$ ./sp_going_deeper Trying to leak information from the pc.. 🖥️ ____________________________________________________ / \ | _____________________________________________ | | | | | | | goldenfang@d12:$ history | | | | 1 ls | | | | 2 mv secret_pass.</description></item><item><title>Space Pirates</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/space-pirates/</guid><description>Se nos proporciona el siguiente código en Python:
fromsympyimport* fromhashlibimportmd5 fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad fromrandomimportrandint, randbytes, seed FLAG=b'HTB{dummyflag}' classShamir: def__init__(self, prime, k, n): self.p=prime self.secret=randint(1, self.p-1) self.k=k self.n=n self.coeffs=[self.secret] self.x_vals=[] self.y_vals=[] defnext_coeff(self, val): returnint(md5(val.to_bytes(32, byteorder='big')).hexdigest(), 16) defcalc_coeffs(self): foriinrange(1, self.n+1): self.coeffs.append(self.next_coeff(self.coeffs[i-1])) defcalc_y(self, x): y=0 fori, coeffinenumerate(self.coeffs): y+=coeff*x**i returny%self.p defcreate_pol(self): self.calc_coeffs() self.coeffs=self.coeffs[:self.k] for_inrange(self.n): x=randint(1, self.p-1) self.x_vals.append(x) self.y_vals.append(self.calc_y(x)) defget_share(self): returnself.x_vals[0], self.y_vals[0] defmain(): sss=Shamir(92434467187580489687, 10, 18) sss.create_pol() share=sss.get_share() seed(sss.secret) key=randbytes(16) cipher=AES.new(key, AES.MODE_ECB) enc_FLAG=cipher.encrypt(pad(FLAG, 16)).hex() print(sss.coeffs) f=open('msg.enc', 'w') f.</description></item><item><title>Spiky Tamagotchi</title><link>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/web/spiky-tamagotchi/</guid><description>Se nos proporciona el código fuente de un proyecto web en Node.js con Express JS y MySQL. En el Dockerfile se utiliza el siguiente script entrypoint.sh:
#!/bin/ash # Secure entrypoint chmod 600 /entrypoint.sh # Initialize &amp;amp; Start MariaDB mkdir -p /run/mysqld chown -R mysql:mysql /run/mysqld mysql_install_db --user=mysql --ldata=/var/lib/mysql mysqld --user=mysql --console --skip-name-resolve --skip-networking=0 &amp;amp; # Wait for mysql to start while ! mysqladmin ping -h'localhost' --silent; do echo "mysqld is not yet alive"</description></item><item><title>Spooky RSA</title><link>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/hackthebooctf/spooky-rsa/</guid><description>Se nos proporciona el siguiente código en Python para cifrar la flag:
fromCrypto.Util.numberimportbytes_to_long, getStrongPrime fromrandomimportrandint FLAG=b'HTB{????????????????????????????????????????????}' defkey_gen(bits): p, q=getStrongPrime(bits), getStrongPrime(bits) N=p*q returnN, (p, q) defencrypt(m, N, f): e1, e2=randint(2, N-2), randint(2, N-2) c1=(pow(f, e1, N) +m) %N c2=(pow(f, e2, N) +m) %N return(e1, c1), (e2, c2) defmain(): N, priv=key_gen(1024) m=bytes_to_long(FLAG) (e1, c1), (e2, c2) =encrypt(m, N, priv[0]) withopen('out.txt', 'w') asf: f.write(f'N = {N}\n(e1, c1) = ({e1}, {c1})\n(e2, c2) = ({e2}, {c2})\n') if__name__=="</description></item><item><title>St3g0</title><link>https://7rocky.github.io/ctf/picoctf/forensics/st3g0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/forensics/st3g0/</guid><description>Tenemos una imagen PNG llamada pico.flag.png:
Como el reto se llama St3g0, parece que la imagen tiene datos ocultos mediante esteganografía. Podemos utilizar zsteg para mostrar la flag:
$ zsteg pico.flag.png b1,r,lsb,xy .. text: "~__BwV_G@" b1,rgb,lsb,xy .. text: "picoCTF{7h3r3_15_n0_5p00n_96ae0ac1}$t3g0" b1,abgr,lsb,xy .. text: "E2A5q4E%uSA" b2,b,lsb,xy .. text: "AAPAAQTAAA" b2,b,msb,xy .. text: "HWUUUUUU" b2,a,lsb,xy .. file: Matlab v4 mat-file (little endian) &amp;gt;&amp;lt;?P, numeric, rows 0, columns 0 b2,a,msb,xy .. file: Matlab v4 mat-file (little endian) | &amp;lt;?</description></item><item><title>Stonks</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/stonks/</guid><description>Se nos da el código fuente en C de un binario. El código es relativamente largo, por lo que se muestra la función más interesante:
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int buy_stonks(Portfolio *p) { if (!p) { return 1; } char api_buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>Substitution Cipher</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/substitution-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/substitution-cipher/</guid><description>Se nos proporciona este texto cifrado:
MIT YSAU OL OYGFSBDGRTKFEKBHMGCALSOQTMIOL. UTFTKAMTR ZB DAKQGX EIAOF GY MIT COQOHTROA HAUT GF EASXOF AFR IGZZTL. ZT CTKT SGFU, MIT YSACL GF A 2005 HKTLTFM MODTL MIAF LMADOFA GK A CTTQSB LWFRAB, RTETDZTK 21, 1989 1990, MIT RKTC TROMGKL CAL WHKGGMTR TXTKB CGKSR EAF ZT YGWFR MIT EGFMOFWTR MG CGKQ AM A YAOMIYWS KTHSOTL CITKT IGZZTL, LMBST AOD EASXOF, AMMAEQ ZGMI LORTL MG DAKQL, "</description></item><item><title>Sum-O-Primes</title><link>https://7rocky.github.io/ctf/picoctf/cryptography/sum-o-primes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/cryptography/sum-o-primes/</guid><description>Tenemos la salida de un cifrado RSA:
x = 17fef88f46a58da13be8083b814caf6cd8d494dd6c21ad7bf399e521e14466d51a74f51ad5499731018b6a437576e72bd397c4bb07bfbb699c1a35f1f4fa1b86dee2a1702670e9cea45aa7062f9569279d6d4b964f3df2ff8e38cf029faad57e42b831bde21132303e127cba4e80cd3c9ff6a7bad5b399a18252dc35460471ea8 n = 85393637a04ec36e699796ac16979c51ecea41cfd8353c2a241193d1d40d02701b34e9cd4deaf2b13b6717757f178ff75249f3d675448ec928aef41c39e4be1c8ba2ba79c4ada36c607763d7dc8543103acfe1027245acda2208f22fcabe0f37bdadf077e4f943c4f4178cedeb5279a4ebc86323356e23a58b6666ac6ffbf4f1c8229117ffb9071a94dfb724957f10d6664e4ee02e16bed29eb922f126e2082e2f73b5c5b7817e0543155eb9673f4de3de8c91707c1261e8ba6e7348d930293f7796679218c2b1dabe41527eccd72ec3e7284344622eff81ae0541769fb70b6146b54bd092c2dfbe7f8e9653cad80d0fb4f3ef288778927b3852f9ff3a4076d7 c = 42cafbc77ed8396a681dac328701ee02cd746488ae084f15a3e6a5b8f666c595a372a69bbca0dae934fd5ed2292d4393912ee10a22a3b57de9cee2f30b5dc7c67f574b0453f6074171cca37bd407529cb30ba17f152ef5b2484d94b38cf0a513a723255d725e5c3b3f3c985f9223095be3fa148afedf91e4ed37720c3d97dd29cf07830efa8a557a9da68d3095fc3b31f3763e030b62c70d94c3d2951e163e48683f3b9611d562ea06bf1e5d8465e8bf5a6345050a5e7b0c175faf136562cf2a196fdb61ac6503446616cffa9ed85015b86dda73f6eda4d688d3e719a07439d98f95fb5dcf675948ec58d9af83fa29afa4375213ec48f09a6c8cbc431cfe7c6a Contexto de RSA También se nos proporciona el código fuente para generar esta salida. Ahí, podemos ver que $x = p + q$, $n = p q$ y $c$ es el texto cifrado. El exponente $e = 65537$.
RSA funciona de manera que, dado un mensaje $m$ en formato decimal, podemos cifrarlo como sigue:</description></item><item><title>Taking LS</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/taking-ls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/taking-ls/</guid><description>Se nos proporciona un archivo ZIP que contiene estos archivos y directorios:
$ unzip -l The\ Flag.zip Archive: The Flag.zip Length Date Time Name --------- ---------- ----- ---- 0 10-30-2016 14:45 The Flag/ 6148 10-30-2016 14:45 The Flag/.DS_Store 0 10-30-2016 14:46 __MACOSX/ 0 10-30-2016 14:46 __MACOSX/The Flag/ 120 10-30-2016 14:45 __MACOSX/The Flag/._.DS_Store 0 10-30-2016 14:40 The Flag/.ThePassword/ 42 10-30-2016 14:41 The Flag/.ThePassword/ThePassword.txt 16647 10-30-2016 14:45 The Flag/The Flag.pdf 177 10-30-2016 14:45 __MACOSX/The Flag/.</description></item><item><title>Tapping</title><link>https://7rocky.github.io/ctf/picoctf/cryptography/tapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/cryptography/tapping/</guid><description>Se nos proporciona un mensaje raro a través de nc:
$ nc jupiter.challenges.picoctf.org 9422 .--. .. -.-. --- -.-. - ..-. { -- ----- .-. ... ...-- -.-. ----- -.. ...-- .---- ... ..-. ..- -. ..--- -.... ---.. ...-- ---.. ..--- ....- -.... .---- ----- } Ncat: Broken pipe. Vemos que el mensaje solamente tiene . y - (y también llaves, lo cual indica que el mensaje podría ser la flag).</description></item><item><title>Teleport</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/teleport/</guid><description>Se nos proporciona un binario llamado teleport:
$ file teleport teleport: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1f87fe68fd7d1deaffefcf08ed2b30d660ee2d0b, stripped Si lo ejecutamos, nos pregunta por una contraseña:
$ ./teleport Missing password Podemos probar a añadirla como argumento de línea de comandos:
$ ./teleport asdf Something's wrong... $ ./teleport 'HTB{asdf}' Something's wrong... Con ltrace podemos ver que nuestra entrada se copia en una dirección de memoria y luego hay un montón de saltos (44 llamadas a _setjmp):</description></item><item><title>The Office</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/the-office/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/the-office/</guid><description>Se nos proporciona un binario de 32 bits llamado the_office:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) El reto dice que han implementado un heap seguro utilizando canarios (heap canaries).
No disponemos del código en C. Por tanto, necesitamos utilizar una herramienta de ingeniería inversa como Ghidra.
Aunque el archivo ha sido despojado de los símbolos:
$ file the_office the_office: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.</description></item><item><title>The secret of a Queen</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/the-secret-of-a-queen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/the-secret-of-a-queen/</guid><description>Se nos proporciona una imagen con unos símbolos raros:
El nombre del reto es una pista, ya que se está utilizando el cifrado de la reina María de Escocia. El cifrado se basa en la sustitución de letras por símbolos utilizando el siguiente alfabeto:
Si traducimos cada símbolo de la imagen a una letra, obtenemos la flag: HTB{THEBABINGTONPLOT}.</description></item><item><title>The Three-Eyed Oracle</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/the-three-eyed-oracle/</guid><description>Se nos proporciona el siguiente código en Python:
fromCrypto.CipherimportAES fromCrypto.Util.Paddingimportpad importrandom importsignal importsubprocess importsocketserver FLAG=b'HTB{--REDACTED--}' prefix=random.randbytes(12) key=random.randbytes(16) defencrypt(key, msg): msg=bytes.fromhex(msg) crypto=AES.new(key, AES.MODE_ECB) padded=pad(prefix+msg+FLAG, 16) returncrypto.encrypt(padded).hex() defchallenge(req): req.sendall(b'Welcome to Klaus\'s crypto lab.\n'+ b'It seems like there is a prefix appended to the real firmware\n'+ b'Can you somehow extract the firmware and fix the chip?\n') whileTrue: req.sendall(b'&amp;gt; ') try: msg=req.recv(4096).decode() ct=encrypt(key, msg) req.sendall(ct.encode() +b'\n') exceptExceptionase: print(e) req.sendall(b'An error occurred! Please try again!') classincoming(socketserver.</description></item><item><title>Time Traveller</title><link>https://7rocky.github.io/ctf/ctflearn/miscellaneous/time-traveller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/miscellaneous/time-traveller/</guid><description>En este reto, nos piden encontrar una dirección de email que se mostró en la página web de la NASA (nasa.gov) el 31 de diciembre de 1996.
La manera de encontrar algo en una fecha concreta es recurrir a web.archive.org (WayBack Machine):
Aquí podemos buscar por nasa.gov y obtener un montón de snapshots de la página web. Curiosamente, la más antigua es del 31 de diciembre de 1996:
Si vamos a ese snapshot, veremos alguna información.</description></item><item><title>Tree of Danger</title><link>https://7rocky.github.io/ctf/htb-challenges/misc/tree-of-danger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/misc/tree-of-danger/</guid><description>Se nos proporciona el código Python que está ejecutando la instancia remota (util.py):
#!/usr/bin/env python3.10 importast importmath fromtypingimportUnion defis_expression_safe(node: Union[ast.Expression, ast.AST]) -&amp;gt; bool: matchtype(node): caseast.Constant: returnTrue caseast.List|ast.Tuple|ast.Set: returnis_sequence_safe(node) caseast.Dict: returnis_dict_safe(node) caseast.Name: returnnode.id =="math"andisinstance(node.ctx, ast.Load) caseast.UnaryOp: returnis_expression_safe(node.operand) caseast.BinOp: returnis_expression_safe(node.left) andis_expression_safe(node.right) caseast.Call: returnis_call_safe(node) caseast.Attribute: returnis_expression_safe(node.value) case_: returnFalse defis_sequence_safe(node: Union[ast.List, ast.Tuple, ast.Set]): returnall(map(is_expression_safe, node.elts)) defis_dict_safe(node: ast.Dict) -&amp;gt; bool: fork, vinzip(node.keys, node.values): ifnotis_expression_safe(k) andis_expression_safe(v): returnFalse returnTrue defis_call_safe(node: ast.Call) -&amp;gt; bool: ifnotis_expression_safe(node.func): returnFalse ifnotall(map(is_expression_safe, node.args)): returnFalse ifnode.</description></item><item><title>Unsubscriptions Are Free</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/unsubscriptions-are-free/</guid><description>Se nos proporciona un binario de 32 bits llamado vuln:
Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Tenemos también el código fuente en C:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr() { char buf[FLAG_BUFFER]; FILE *f = fopen("</description></item><item><title>Ursa Minor</title><link>https://7rocky.github.io/ctf/other/ursa-minor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/other/ursa-minor/</guid><description>Se nos proporciona el siguiente código y una instancia a la que conectarnos:
#!/usr/local/bin/python # # Polymero # # Imports fromCrypto.Util.numberimportisPrime, getPrime, inverse importhashlib, time, os # Local import FLAG=os.environ.get('FLAG').encode() classURSA: # Upgraded RSA (faster and with cheap key cycling) def__init__(self, pbit, lbit): p, q=self.prime_gen(pbit, lbit) self.public={'n': p*q, 'e': 0x10001} self.private={'p': p, 'q': q, 'f': (p-1)*(q-1), 'd': inverse(self.public['e'], (p-1)*(q-1))} defprime_gen(self, pbit, lbit): # Smooth primes are FAST primes ~ !</description></item><item><title>Vault-breaker</title><link>https://7rocky.github.io/ctf/htb-challenges/pwn/vault-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/pwn/vault-breaker/</guid><description>Se nos proporciona un binario de 64 bits llamado vault-breaker:
Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'./.glibc/' Si lo ejecutamos, tenemos dos opciones:
$ ./vault-breaker Current status: Unlocked🔓 ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒▒▓▓▓▓▒▒▒▒▒▒░░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒░░▒▒░░████▓▓████░░▒▒▓▓▓▓▓▓▓▓▓▓░░▒▒░░ ░░░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒▓▓░░▓▓▒▒▒▒▒▒░░░░▒▒▓▓██▒▒▒▒▓▓▓▓▓▓░░░░ ░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░▒▒▒▒▓▓░░▓▓░░██▓▓▓▓▓▓▒▒▒▒██░░▓▓▓▓▒▒▒▒ ░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓░░░░▓▓▒▒░░▒▒██░░██▒▒▒▒▒▒▒▒██▒▒▒▒██▓▓▒▒▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▒▒▓▓▒▒▓▓░░▒▒▓▓▒▒▒▒░░░░░░▒▒██░░██▒▒▒▒ ▒▒▒▒▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▒▒░░░░▓▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒░░░░░░░░▒▒▓▓▓▓▓▓▒▒ ░░▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▒▒▒▒▒▒▓▓░░▓▓░░░░░░░░▒▒▒▒██▒▒██▒▒ ▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▓▓▒▒░░▒▒▓▓░░░░░░░░░░▒▒▒▒▓▓▒▒██░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▓▓▒▒░░▒▒▓▓░░▒▒░░░░░░░░░░▓▓▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒▒▒▒▒▓▓▒▒░░░░░░░░░░░░▒▒▒▒██▒▒ ░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▒▒▒░░▓▓▒▒░░░░▒▒░░▒▒▒▒▓▓▒▒▓▓░░ ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▒▒▓▓░░░░░░▒▒░░▒▒▓▓▓▓██▒▒ ░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓██▒▒░░▒▒▒▒▓▓▒▒░░░░▒▒▒▒▓▓▓▓▒▒░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓██▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▒▒██▒▒░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▒▒▒▒▓▓▒▒▒▒░░▓▓▒▒▒▒▒▒▓▓▒▒██▒▒▓▓▓▓░░░░ ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓██▓▓▒▒██▒▒░░▒▒▒▒▒▒▓▓▓▓▓▓▒▒▓▓▓▓▓▓░░░░ ░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▓▓██▓▓████▒▒▒▒▓▓▓▓▓▓▓▓▓▓░░░░░░░░ ░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓██▒▒▓▓▒▒▒▒░░▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ [+] Random secure encryption key has been generated!</description></item><item><title>Vigenère Cipher</title><link>https://7rocky.github.io/ctf/ctflearn/cryptography/vigenere-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/cryptography/vigenere-cipher/</guid><description>Tenemos este texto cifrado:
DETctysy{QzeffcgRgcBhsjdkf} Y también una palabra extraña: blorpy.
Como el reto se llama &amp;ldquo;Vigenère Cipher&amp;rdquo;, podemos deducir que el algoritmo de cifrado es precisamente el Cifrado Vigenère, que es un tipo de cifrado César de sustitución. Para descifrar el mensaje, podemos ir a CyberChef y usar blorpy como clave:
Flag: CTFlearn{CiphersAreAwesome}.</description></item><item><title>Weak RSA</title><link>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/crypto/weak-rsa/</guid><description>Se nos proporciona una clave pública en formato PEM de una implementación de RSA (key.pub):
-----BEGIN PUBLIC KEY----- MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip 4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy 23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3 RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ 4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr lb/N -----END PUBLIC KEY----- $ python3 -q &amp;gt;&amp;gt;&amp;gt; from Crypto.PublicKey import RSA &amp;gt;&amp;gt;&amp;gt; key = RSA.import_key(open('key.pub').read()) &amp;gt;&amp;gt;&amp;gt; key.n 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923 &amp;gt;&amp;gt;&amp;gt; key.e 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605 RSA funciona de la siguiente manera: Se cogen dos números primos grandes $p$ y $q$ y se toma $n = pq$ como módulo.</description></item><item><title>what's a net cat?</title><link>https://7rocky.github.io/ctf/picoctf/general-skills/whats-a-net-cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/general-skills/whats-a-net-cat/</guid><description>Se nos proporciona una instancia remota a la que conectarnos. Si establecemos la conexión con nc, obtenemos la flag:
$ nc jupiter.challenges.picoctf.org 25103 You're on your way to becoming the net cat master picoCTF{nEtCat_Mast3ry_d0c64587}</description></item><item><title>where are the robots</title><link>https://7rocky.github.io/ctf/picoctf/web-exploitation/where-are-the-robots/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/web-exploitation/where-are-the-robots/</guid><description>Se nos proporciona una página web como esta:
La página habla de robots. Existe un archivo especial llamado robots.txt que previene a crawlers y arañas web que accedan a ciertas rutas listadas en el archivo. Vamos a echar un vistazo:
Genial, hay una línea Disallow: /8028f.html, que no significa que no podamos entrar (solamente dice a los escáneres automáticos que no entren). Este es /8028f.html:
Y ahí está la flag: picoCTF{ca1cu1at1ng_Mach1n3s_8028f}.</description></item><item><title>WIDE</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/wide/</guid><description>Se nos proporciona un binario de 64 bits llamado wide y otro archivo llamado db.ex con algunas cadenas de texto:
$ file wide wide: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=13869bb7ce2c22f474b95ba21c9d7e9ff74ecc3f, not stripped $ strings db.ex Primus people breathe variety practice Our home dimension Cheagaz scene control river importance The Ice Dimension Byenoovia fighting cast it parallel The Berserk Dimension Cloteprea facing motor unusual heavy The Hungry Dimension Maraqa stomach motion sale valuable The Water Dimension Aidor feathers stream sides gate The Bone Dimension Flaggle Alpha admin secret power hidden HOt* 0ANe Si ejeutamos el binario tenemos lo siguiente:</description></item><item><title>WOW... So Meta</title><link>https://7rocky.github.io/ctf/ctflearn/forensics/wow...-so-meta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/ctflearn/forensics/wow...-so-meta/</guid><description>Se nos pide encontrar la flag en esta imagen:
Sin embargo, la flag no está visible en la propia imagen ni oculta en su contenido. Como el reto habla de &amp;ldquo;Meta&amp;rdquo;, lo mismo la flag se encuentra en los metadatos del archivo.
Para extraer los metadatos podemos utilizar exiftool y filtrar por CTFlearn encadenando el comando anterior con grep:
$ exiftool 3UWLBAUCb9Z2.jpg | grep CTFlearn Camera Serial Number : CTFlearn{EEe_x_I_FFf}</description></item><item><title>XORed</title><link>https://7rocky.github.io/ctf/imaginaryctf/xored/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xored/</guid><description>El programa dice que alguien ha usado un cifrado XOR con una clave de un solo byte. Este es el resultado: * 7%8-s70&amp;amp; 61&amp;amp;&amp;gt;.
Como sabemos que las flags empiezan por ictf{, podemos obtener la clave mediante &amp;quot;*&amp;quot; ^ &amp;quot;i&amp;quot; debido a las propiedades del cifrado XOR:
$$ c = m \oplus k \iff k = c \oplus m $$
Entonces podemos resolver el reto así:
$ python3 -q &amp;gt;&amp;gt;&amp;gt; from pwn import xor &amp;gt;&amp;gt;&amp;gt; c = b'* 7%8-s70&amp; 61&amp;&amp;gt;' &amp;gt;&amp;gt;&amp;gt; k = xor(c[0], b'i') &amp;gt;&amp;gt;&amp;gt; m = xor(c, k) &amp;gt;&amp;gt;&amp;gt; m b'ictf{n0tsecure}'</description></item><item><title>xorrot</title><link>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/imaginaryctf/xorrot/</guid><description>Se nos proporciona el código fuente para cifrar la flag, y también el texto cifrado como un comentario en el código:
#!/usr/bin/env python3 flag=open('flag.txt', 'rb').read() key=open('/dev/urandom','rb').read(1)[0] out=[] forcinflag: out.append(c ^ key) key=c print(f'{bytes(out).hex() = }') # bytes(out).hex() = '970a17121d121d2b28181a19083b2f021d0d03030e1526370d091c2f360f392b1c0d3a340e1c263e070003061711013b32021d173a2b1c090f31351f06072b2b1c0d3a390f1b01072b3c0b09132d33030311' A partir del código fuente, podemos ver que la clave es un solo byte. Además, la clave se actualiza con el caracter en claro actual.
Por tanto, podemos utilizar un script en Python para solucionar el reto:</description></item><item><title>You Cant C Me</title><link>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/htb-challenges/reversing/you-cant-c-me/</guid><description>Se nos proporciona un binario llamado auth:
$ file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped Si lo ejecutamos, pregunta por una clave:
$ ./auth Welcome! Podemos introducir una clave y ver que no es correcta:
$ ./baby Insert key: asdf I said, you can't c me! Podemos hacer uso de ltrace para ver las llamadas a funciones externas (funciones que pertenecen a librerías como Glibc):</description></item><item><title>zero_to_hero</title><link>https://7rocky.github.io/ctf/picoctf/binary-exploitation/zero_to_hero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://7rocky.github.io/ctf/picoctf/binary-exploitation/zero_to_hero/</guid><description>Se nos proporciona un binario de 64 bits llamado zero_to_hero:
Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'./' También tenemos la librería compartida Glibc y el loader (versión 2.29):
$ ./ld-2.29.so ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.29-0ubuntu2) stable release version 2.29. Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description></item></channel></rss>